{"sha": "a555d49757bb25111d63b18923fd254868d1fb96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTVkNDk3NTdiYjI1MTExZDYzYjE4OTIzZmQyNTQ4NjhkMWZiOTY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-06-03T16:37:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-03T16:37:29Z"}, "message": "Add doc comments to librustc/infer/region_inference/mod.rs", "tree": {"sha": "55515e83e30828d79972a33cd01b2a2f166734a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55515e83e30828d79972a33cd01b2a2f166734a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a555d49757bb25111d63b18923fd254868d1fb96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a555d49757bb25111d63b18923fd254868d1fb96", "html_url": "https://github.com/rust-lang/rust/commit/a555d49757bb25111d63b18923fd254868d1fb96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a555d49757bb25111d63b18923fd254868d1fb96/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8426ade5807a55b5a3513945fd9962325d2728", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8426ade5807a55b5a3513945fd9962325d2728", "html_url": "https://github.com/rust-lang/rust/commit/6f8426ade5807a55b5a3513945fd9962325d2728"}], "stats": {"total": 131, "additions": 66, "deletions": 65}, "files": [{"sha": "0bf9007b1784b8076338200f6a79bba26da7e935", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a555d49757bb25111d63b18923fd254868d1fb96/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a555d49757bb25111d63b18923fd254868d1fb96/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=a555d49757bb25111d63b18923fd254868d1fb96", "patch": "@@ -35,31 +35,31 @@ use std::u32;\n \n mod graphviz;\n \n-// A constraint that influences the inference process.\n+/// A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum Constraint<'tcx> {\n-    // One region variable is subregion of another\n+    /// One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n-    // Concrete region is subregion of region variable\n+    /// Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region<'tcx>, RegionVid),\n \n-    // Region variable is subregion of concrete region. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// Region variable is subregion of concrete region. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainVarSubReg(RegionVid, Region<'tcx>),\n \n-    // A constraint where neither side is a variable. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// A constraint where neither side is a variable. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n-// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-// associated type) must outlive the region `R`. `T` is known to\n-// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-// `i`. Inference variables may be involved (but this verification\n-// step doesn't influence inference).\n+/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// associated type) must outlive the region `R`. `T` is known to\n+/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// `i`. Inference variables may be involved (but this verification\n+/// step doesn't influence inference).\n #[derive(Debug)]\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n@@ -74,29 +74,29 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-// When we introduce a verification step, we wish to test that a\n-// particular region (let's call it `'min`) meets some bound.\n-// The bound is described the by the following grammar:\n+/// When we introduce a verification step, we wish to test that a\n+/// particular region (let's call it `'min`) meets some bound.\n+/// The bound is described the by the following grammar:\n #[derive(Debug)]\n pub enum VerifyBound<'tcx> {\n-    // B = exists {R} --> some 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive all\n-    // regions in {R}, so if any of those outlives 'min, then the\n-    // bound is met.\n+    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive all\n+    /// regions in {R}, so if any of those outlives 'min, then the\n+    /// bound is met.\n     AnyRegion(Vec<Region<'tcx>>),\n \n-    // B = forall {R} --> all 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive some\n-    // region in {R}, so if all of those outlives 'min, then the bound\n-    // is met.\n+    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive some\n+    /// region in {R}, so if all of those outlives 'min, then the bound\n+    /// is met.\n     AllRegions(Vec<Region<'tcx>>),\n \n-    // B = exists {B} --> 'min must meet some bound b in {B}\n+    /// B = exists {B} --> 'min must meet some bound b in {B}\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    // B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// B = forall {B} --> 'min must meet all bounds b in {B}\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -183,56 +183,57 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n-    // Constraints of the form `A <= B` introduced by the region\n-    // checker.  Here at least one of `A` and `B` must be a region\n-    // variable.\n+    /// Constraints of the form `A <= B` introduced by the region\n+    /// checker.  Here at least one of `A` and `B` must be a region\n+    /// variable.\n     constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n-    // A \"verify\" is something that we need to verify after inference is\n-    // done, but which does not directly affect inference in any way.\n-    //\n-    // An example is a `A <= B` where neither `A` nor `B` are\n-    // inference variables.\n+    /// A \"verify\" is something that we need to verify after inference is\n+    /// done, but which does not directly affect inference in any way.\n+    ///\n+    /// An example is a `A <= B` where neither `A` nor `B` are\n+    /// inference variables.\n     verifys: RefCell<Vec<Verify<'tcx>>>,\n \n-    // A \"given\" is a relationship that is known to hold. In particular,\n-    // we often know from closure fn signatures that a particular free\n-    // region must be a subregion of a region variable:\n-    //\n-    //    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    //\n-    // In situations like this, `'b` is in fact a region variable\n-    // introduced by the call to `iter()`, and `'a` is a bound region\n-    // on the closure (as indicated by the `<'a>` prefix). If we are\n-    // naive, we wind up inferring that `'b` must be `'static`,\n-    // because we require that it be greater than `'a` and we do not\n-    // know what `'a` is precisely.\n-    //\n-    // This hashmap is used to avoid that naive scenario. Basically we\n-    // record the fact that `'a <= 'b` is implied by the fn signature,\n-    // and then ignore the constraint when solving equations. This is\n-    // a bit of a hack but seems to work.\n+    /// A \"given\" is a relationship that is known to hold. In particular,\n+    /// we often know from closure fn signatures that a particular free\n+    /// region must be a subregion of a region variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically we\n+    /// record the fact that `'a <= 'b` is implied by the fn signature,\n+    /// and then ignore the constraint when solving equations. This is\n+    /// a bit of a hack but seems to work.\n     givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n     skolemization_count: Cell<u32>,\n     bound_count: Cell<u32>,\n \n-    // The undo log records actions that might later be undone.\n-    //\n-    // Note: when the undo_log is empty, we are not actively\n-    // snapshotting. When the `start_snapshot()` method is called, we\n-    // push an OpenSnapshot entry onto the list to indicate that we\n-    // are now actively snapshotting. The reason for this is that\n-    // otherwise we end up adding entries for things like the lower\n-    // bound on a variable and so forth, which can never be rolled\n-    // back.\n+    /// The undo log records actions that might later be undone.\n+    ///\n+    /// Note: when the undo_log is empty, we are not actively\n+    /// snapshotting. When the `start_snapshot()` method is called, we\n+    /// push an OpenSnapshot entry onto the list to indicate that we\n+    /// are now actively snapshotting. The reason for this is that\n+    /// otherwise we end up adding entries for things like the lower\n+    /// bound on a variable and so forth, which can never be rolled\n+    /// back.\n     undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n+    \n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n-    // This contains the results of inference.  It begins as an empty\n-    // option and only acquires a value after inference is complete.\n+    /// This contains the results of inference.  It begins as an empty\n+    /// option and only acquires a value after inference is complete.\n     values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n "}]}