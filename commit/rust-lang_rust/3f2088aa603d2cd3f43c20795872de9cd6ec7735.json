{"sha": "3f2088aa603d2cd3f43c20795872de9cd6ec7735", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMjA4OGFhNjAzZDJjZDNmNDNjMjA3OTU4NzJkZTljZDZlYzc3MzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T12:36:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T12:36:18Z"}, "message": "Auto merge of #79169 - LeSeulArtichaut:ty-lib, r=nikomatsakis\n\nCreate `rustc_type_ir`\n\nDecided to start small \ud83d\ude04\n\nThis PR creates a `rustc_type_ir` crate as part of the WG-Traits plan to create a shared type library.\n~~There already exists a `rustc_ty` crate, so I named the new crate `rustc_ty_library`. However I think it would make sense to rename the current `rustc_ty` to something else (e.g. `rustc_ty_passes`) to free the name for this new crate.~~\n\nr? `@jackh726`", "tree": {"sha": "a2e4fbcc35e4c0b536750745c05c1f0b17759264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2e4fbcc35e4c0b536750745c05c1f0b17759264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2088aa603d2cd3f43c20795872de9cd6ec7735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2088aa603d2cd3f43c20795872de9cd6ec7735", "html_url": "https://github.com/rust-lang/rust/commit/3f2088aa603d2cd3f43c20795872de9cd6ec7735", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2088aa603d2cd3f43c20795872de9cd6ec7735/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ed6681ff8d446e68ce272be4bf66f4145f6e29", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ed6681ff8d446e68ce272be4bf66f4145f6e29", "html_url": "https://github.com/rust-lang/rust/commit/c3ed6681ff8d446e68ce272be4bf66f4145f6e29"}, {"sha": "0cf5a8ad15af795beff92f923eac9ba4b71e2790", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf5a8ad15af795beff92f923eac9ba4b71e2790", "html_url": "https://github.com/rust-lang/rust/commit/0cf5a8ad15af795beff92f923eac9ba4b71e2790"}], "stats": {"total": 428, "additions": 234, "deletions": 194}, "files": [{"sha": "59525a29a8051003f2b12fc121954ebc90c190d1", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -3932,6 +3932,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec 1.4.2\",\n  \"tracing\",\n ]\n@@ -4266,6 +4267,16 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_type_ir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags\",\n+ \"rustc_data_structures\",\n+ \"rustc_index\",\n+ \"rustc_serialize\",\n+]\n+\n [[package]]\n name = \"rustc_typeck\"\n version = \"0.0.0\""}, {"sha": "47b7768b410a1eb15b2eaf99072de4ad30390396", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -30,3 +30,4 @@ chalk-ir = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "7428f34153c87e48bf1ff16deba28d18912f3e92", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -56,7 +56,7 @@ pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n-pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n+pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n@@ -67,6 +67,7 @@ pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n+pub use rustc_type_ir::{DebruijnIndex, TypeFlags, INNERMOST};\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -497,91 +498,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-bitflags! {\n-    /// Flags that we track on types. These flags are propagated upwards\n-    /// through the type during type construction, so that we can quickly check\n-    /// whether the type has various kinds of types in it without recursing\n-    /// over the type itself.\n-    pub struct TypeFlags: u32 {\n-        // Does this have parameters? Used to determine whether substitution is\n-        // required.\n-        /// Does this have [Param]?\n-        const HAS_TY_PARAM                = 1 << 0;\n-        /// Does this have [ReEarlyBound]?\n-        const HAS_RE_PARAM                = 1 << 1;\n-        /// Does this have [ConstKind::Param]?\n-        const HAS_CT_PARAM                = 1 << 2;\n-\n-        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_RE_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits;\n-\n-        /// Does this have [Infer]?\n-        const HAS_TY_INFER                = 1 << 3;\n-        /// Does this have [ReVar]?\n-        const HAS_RE_INFER                = 1 << 4;\n-        /// Does this have [ConstKind::Infer]?\n-        const HAS_CT_INFER                = 1 << 5;\n-\n-        /// Does this have inference variables? Used to determine whether\n-        /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_RE_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits;\n-\n-        /// Does this have [Placeholder]?\n-        const HAS_TY_PLACEHOLDER          = 1 << 6;\n-        /// Does this have [RePlaceholder]?\n-        const HAS_RE_PLACEHOLDER          = 1 << 7;\n-        /// Does this have [ConstKind::Placeholder]?\n-        const HAS_CT_PLACEHOLDER          = 1 << 8;\n-\n-        /// `true` if there are \"names\" of regions and so forth\n-        /// that are local to a particular fn/inferctxt\n-        const HAS_FREE_LOCAL_REGIONS      = 1 << 9;\n-\n-        /// `true` if there are \"names\" of types and regions and so forth\n-        /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES        = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits\n-                                          | TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits\n-                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n-\n-        /// Does this have [Projection]?\n-        const HAS_TY_PROJECTION           = 1 << 10;\n-        /// Does this have [Opaque]?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n-        /// Does this have [ConstKind::Unevaluated]?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n-\n-        /// Could this type be normalized further?\n-        const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n-                                          | TypeFlags::HAS_CT_PROJECTION.bits;\n-\n-        /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n-\n-        /// Does this have any region that \"appears free\" in the type?\n-        /// Basically anything but [ReLateBound] and [ReErased].\n-        const HAS_FREE_REGIONS            = 1 << 14;\n-\n-        /// Does this have any [ReLateBound] regions? Used to check\n-        /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n-\n-        /// Does this have any [ReErased] regions?\n-        const HAS_RE_ERASED               = 1 << 16;\n-\n-        /// Does this value have parameters/placeholders/inference variables which could be\n-        /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n-    }\n-}\n-\n #[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future."}, {"sha": "5b787f9841c4ee13d58b983b983254277f9ac9be", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 108, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -1289,53 +1289,6 @@ impl<'tcx> ParamConst {\n     }\n }\n \n-rustc_index::newtype_index! {\n-    /// A [De Bruijn index][dbi] is a standard means of representing\n-    /// regions (and perhaps later types) in a higher-ranked setting. In\n-    /// particular, imagine a type like this:\n-    ///\n-    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-    ///     ^          ^            |          |           |\n-    ///     |          |            |          |           |\n-    ///     |          +------------+ 0        |           |\n-    ///     |                                  |           |\n-    ///     +----------------------------------+ 1         |\n-    ///     |                                              |\n-    ///     +----------------------------------------------+ 0\n-    ///\n-    /// In this type, there are two binders (the outer fn and the inner\n-    /// fn). We need to be able to determine, for any given region, which\n-    /// fn type it is bound by, the inner or the outer one. There are\n-    /// various ways you can do this, but a De Bruijn index is one of the\n-    /// more convenient and has some nice properties. The basic idea is to\n-    /// count the number of binders, inside out. Some examples should help\n-    /// clarify what I mean.\n-    ///\n-    /// Let's start with the reference type `&'b isize` that is the first\n-    /// argument to the inner function. This region `'b` is assigned a De\n-    /// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n-    /// fn). The region `'a` that appears in the second argument type (`&'a\n-    /// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n-    /// second-innermost binder\". (These indices are written on the arrays\n-    /// in the diagram).\n-    ///\n-    /// What is interesting is that De Bruijn index attached to a particular\n-    /// variable will vary depending on where it appears. For example,\n-    /// the final type `&'a char` also refers to the region `'a` declared on\n-    /// the outermost fn. But this time, this reference is not nested within\n-    /// any other binders (i.e., it is not an argument to the inner fn, but\n-    /// rather the outer one). Therefore, in this case, it is assigned a\n-    /// De Bruijn index of 0, because the innermost binder in that location\n-    /// is the outer fn.\n-    ///\n-    /// [dbi]: https://en.wikipedia.org/wiki/De_Bruijn_index\n-    #[derive(HashStable)]\n-    pub struct DebruijnIndex {\n-        DEBUG_FORMAT = \"DebruijnIndex({})\",\n-        const INNERMOST = 0,\n-    }\n-}\n-\n pub type Region<'tcx> = &'tcx RegionKind;\n \n /// Representation of regions. Note that the NLL checker uses a distinct\n@@ -1450,7 +1403,7 @@ pub enum RegionKind {\n \n     /// Region bound in a function scope, which will be substituted when the\n     /// function is called.\n-    ReLateBound(DebruijnIndex, BoundRegion),\n+    ReLateBound(ty::DebruijnIndex, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n@@ -1614,65 +1567,6 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n     }\n }\n \n-impl DebruijnIndex {\n-    /// Returns the resulting index when this value is moved into\n-    /// `amount` number of new binders. So, e.g., if you had\n-    ///\n-    ///    for<'a> fn(&'a x)\n-    ///\n-    /// and you wanted to change it to\n-    ///\n-    ///    for<'a> fn(for<'b> fn(&'a x))\n-    ///\n-    /// you would need to shift the index for `'a` into a new binder.\n-    #[must_use]\n-    pub fn shifted_in(self, amount: u32) -> DebruijnIndex {\n-        DebruijnIndex::from_u32(self.as_u32() + amount)\n-    }\n-\n-    /// Update this index in place by shifting it \"in\" through\n-    /// `amount` number of binders.\n-    pub fn shift_in(&mut self, amount: u32) {\n-        *self = self.shifted_in(amount);\n-    }\n-\n-    /// Returns the resulting index when this value is moved out from\n-    /// `amount` number of new binders.\n-    #[must_use]\n-    pub fn shifted_out(self, amount: u32) -> DebruijnIndex {\n-        DebruijnIndex::from_u32(self.as_u32() - amount)\n-    }\n-\n-    /// Update in place by shifting out from `amount` binders.\n-    pub fn shift_out(&mut self, amount: u32) {\n-        *self = self.shifted_out(amount);\n-    }\n-\n-    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n-    /// innermost binder. That is, if we have something bound at `to_binder`,\n-    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n-    /// when moving a region out from inside binders:\n-    ///\n-    /// ```\n-    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n-    /// // Binder:  D3           D2        D1            ^^\n-    /// ```\n-    ///\n-    /// Here, the region `'a` would have the De Bruijn index D3,\n-    /// because it is the bound 3 binders out. However, if we wanted\n-    /// to refer to that region `'a` in the second argument (the `_`),\n-    /// those two binders would not be in scope. In that case, we\n-    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// De Bruijn index of `'a` to D1 (the innermost binder).\n-    ///\n-    /// If we invoke `shift_out_to_binder` and the region is in fact\n-    /// bound by one of the binders we are shifting out of, that is an\n-    /// error (and should fail an assertion failure).\n-    pub fn shifted_out_to_binder(self, to_binder: DebruijnIndex) -> Self {\n-        self.shifted_out(to_binder.as_u32() - INNERMOST.as_u32())\n-    }\n-}\n-\n /// Region utilities\n impl RegionKind {\n     /// Is this region named by the user?\n@@ -1703,7 +1597,7 @@ impl RegionKind {\n         }\n     }\n \n-    pub fn bound_at_or_above_binder(&self, index: DebruijnIndex) -> bool {\n+    pub fn bound_at_or_above_binder(&self, index: ty::DebruijnIndex) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn >= index,\n             _ => false,"}, {"sha": "d50451b7794c6e11ec6980ec7c3d871e5f2258f5", "filename": "compiler/rustc_type_ir/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_type_ir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_type_ir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2FCargo.toml?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"rustc_type_ir\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+bitflags = \"1.2.1\"\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "1c9475f7a66e78a9a56a6817b9b857cb975ebb68", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2088aa603d2cd3f43c20795872de9cd6ec7735/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=3f2088aa603d2cd3f43c20795872de9cd6ec7735", "patch": "@@ -0,0 +1,204 @@\n+#![feature(never_type)]\n+#![feature(const_panic)]\n+#![feature(control_flow_enum)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n+bitflags! {\n+    /// Flags that we track on types. These flags are propagated upwards\n+    /// through the type during type construction, so that we can quickly check\n+    /// whether the type has various kinds of types in it without recursing\n+    /// over the type itself.\n+    pub struct TypeFlags: u32 {\n+        // Does this have parameters? Used to determine whether substitution is\n+        // required.\n+        /// Does this have `Param`?\n+        const HAS_TY_PARAM                = 1 << 0;\n+        /// Does this have `ReEarlyBound`?\n+        const HAS_RE_PARAM                = 1 << 1;\n+        /// Does this have `ConstKind::Param`?\n+        const HAS_CT_PARAM                = 1 << 2;\n+\n+        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n+                                          | TypeFlags::HAS_RE_PARAM.bits\n+                                          | TypeFlags::HAS_CT_PARAM.bits;\n+\n+        /// Does this have `Infer`?\n+        const HAS_TY_INFER                = 1 << 3;\n+        /// Does this have `ReVar`?\n+        const HAS_RE_INFER                = 1 << 4;\n+        /// Does this have `ConstKind::Infer`?\n+        const HAS_CT_INFER                = 1 << 5;\n+\n+        /// Does this have inference variables? Used to determine whether\n+        /// inference is required.\n+        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n+                                          | TypeFlags::HAS_RE_INFER.bits\n+                                          | TypeFlags::HAS_CT_INFER.bits;\n+\n+        /// Does this have `Placeholder`?\n+        const HAS_TY_PLACEHOLDER          = 1 << 6;\n+        /// Does this have `RePlaceholder`?\n+        const HAS_RE_PLACEHOLDER          = 1 << 7;\n+        /// Does this have `ConstKind::Placeholder`?\n+        const HAS_CT_PLACEHOLDER          = 1 << 8;\n+\n+        /// `true` if there are \"names\" of regions and so forth\n+        /// that are local to a particular fn/inferctxt\n+        const HAS_FREE_LOCAL_REGIONS      = 1 << 9;\n+\n+        /// `true` if there are \"names\" of types and regions and so forth\n+        /// that are local to a particular fn\n+        const HAS_FREE_LOCAL_NAMES        = TypeFlags::HAS_TY_PARAM.bits\n+                                          | TypeFlags::HAS_CT_PARAM.bits\n+                                          | TypeFlags::HAS_TY_INFER.bits\n+                                          | TypeFlags::HAS_CT_INFER.bits\n+                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n+                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n+\n+        /// Does this have `Projection`?\n+        const HAS_TY_PROJECTION           = 1 << 10;\n+        /// Does this have `Opaque`?\n+        const HAS_TY_OPAQUE               = 1 << 11;\n+        /// Does this have `ConstKind::Unevaluated`?\n+        const HAS_CT_PROJECTION           = 1 << 12;\n+\n+        /// Could this type be normalized further?\n+        const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n+                                          | TypeFlags::HAS_TY_OPAQUE.bits\n+                                          | TypeFlags::HAS_CT_PROJECTION.bits;\n+\n+        /// Is an error type/const reachable?\n+        const HAS_ERROR                   = 1 << 13;\n+\n+        /// Does this have any region that \"appears free\" in the type?\n+        /// Basically anything but `ReLateBound` and `ReErased`.\n+        const HAS_FREE_REGIONS            = 1 << 14;\n+\n+        /// Does this have any `ReLateBound` regions? Used to check\n+        /// if a global bound is safe to evaluate.\n+        const HAS_RE_LATE_BOUND           = 1 << 15;\n+\n+        /// Does this have any `ReErased` regions?\n+        const HAS_RE_ERASED               = 1 << 16;\n+\n+        /// Does this value have parameters/placeholders/inference variables which could be\n+        /// replaced later, in a way that would change the results of `impl` specialization?\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    /// A [De Bruijn index][dbi] is a standard means of representing\n+    /// regions (and perhaps later types) in a higher-ranked setting. In\n+    /// particular, imagine a type like this:\n+    ///\n+    ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+    ///     ^          ^            |          |           |\n+    ///     |          |            |          |           |\n+    ///     |          +------------+ 0        |           |\n+    ///     |                                  |           |\n+    ///     +----------------------------------+ 1         |\n+    ///     |                                              |\n+    ///     +----------------------------------------------+ 0\n+    ///\n+    /// In this type, there are two binders (the outer fn and the inner\n+    /// fn). We need to be able to determine, for any given region, which\n+    /// fn type it is bound by, the inner or the outer one. There are\n+    /// various ways you can do this, but a De Bruijn index is one of the\n+    /// more convenient and has some nice properties. The basic idea is to\n+    /// count the number of binders, inside out. Some examples should help\n+    /// clarify what I mean.\n+    ///\n+    /// Let's start with the reference type `&'b isize` that is the first\n+    /// argument to the inner function. This region `'b` is assigned a De\n+    /// Bruijn index of 0, meaning \"the innermost binder\" (in this case, a\n+    /// fn). The region `'a` that appears in the second argument type (`&'a\n+    /// isize`) would then be assigned a De Bruijn index of 1, meaning \"the\n+    /// second-innermost binder\". (These indices are written on the arrays\n+    /// in the diagram).\n+    ///\n+    /// What is interesting is that De Bruijn index attached to a particular\n+    /// variable will vary depending on where it appears. For example,\n+    /// the final type `&'a char` also refers to the region `'a` declared on\n+    /// the outermost fn. But this time, this reference is not nested within\n+    /// any other binders (i.e., it is not an argument to the inner fn, but\n+    /// rather the outer one). Therefore, in this case, it is assigned a\n+    /// De Bruijn index of 0, because the innermost binder in that location\n+    /// is the outer fn.\n+    ///\n+    /// [dbi]: https://en.wikipedia.org/wiki/De_Bruijn_index\n+    pub struct DebruijnIndex {\n+        DEBUG_FORMAT = \"DebruijnIndex({})\",\n+        const INNERMOST = 0,\n+    }\n+}\n+\n+impl DebruijnIndex {\n+    /// Returns the resulting index when this value is moved into\n+    /// `amount` number of new binders. So, e.g., if you had\n+    ///\n+    ///    for<'a> fn(&'a x)\n+    ///\n+    /// and you wanted to change it to\n+    ///\n+    ///    for<'a> fn(for<'b> fn(&'a x))\n+    ///\n+    /// you would need to shift the index for `'a` into a new binder.\n+    #[must_use]\n+    pub fn shifted_in(self, amount: u32) -> DebruijnIndex {\n+        DebruijnIndex::from_u32(self.as_u32() + amount)\n+    }\n+\n+    /// Update this index in place by shifting it \"in\" through\n+    /// `amount` number of binders.\n+    pub fn shift_in(&mut self, amount: u32) {\n+        *self = self.shifted_in(amount);\n+    }\n+\n+    /// Returns the resulting index when this value is moved out from\n+    /// `amount` number of new binders.\n+    #[must_use]\n+    pub fn shifted_out(self, amount: u32) -> DebruijnIndex {\n+        DebruijnIndex::from_u32(self.as_u32() - amount)\n+    }\n+\n+    /// Update in place by shifting out from `amount` binders.\n+    pub fn shift_out(&mut self, amount: u32) {\n+        *self = self.shifted_out(amount);\n+    }\n+\n+    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n+    /// innermost binder. That is, if we have something bound at `to_binder`,\n+    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n+    /// when moving a region out from inside binders:\n+    ///\n+    /// ```\n+    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n+    /// // Binder:  D3           D2        D1            ^^\n+    /// ```\n+    ///\n+    /// Here, the region `'a` would have the De Bruijn index D3,\n+    /// because it is the bound 3 binders out. However, if we wanted\n+    /// to refer to that region `'a` in the second argument (the `_`),\n+    /// those two binders would not be in scope. In that case, we\n+    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n+    /// De Bruijn index of `'a` to D1 (the innermost binder).\n+    ///\n+    /// If we invoke `shift_out_to_binder` and the region is in fact\n+    /// bound by one of the binders we are shifting out of, that is an\n+    /// error (and should fail an assertion failure).\n+    pub fn shifted_out_to_binder(self, to_binder: DebruijnIndex) -> Self {\n+        self.shifted_out(to_binder.as_u32() - INNERMOST.as_u32())\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for DebruijnIndex {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        self.as_u32().hash_stable(ctx, hasher);\n+    }\n+}"}]}