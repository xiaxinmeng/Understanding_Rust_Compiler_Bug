{"sha": "35b3fc02e02fa21deb51105d04132d55d4282754", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YjNmYzAyZTAyZmEyMWRlYjUxMTA1ZDA0MTMyZDU1ZDQyODI3NTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T13:00:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T13:00:01Z"}, "message": "comments", "tree": {"sha": "f4ef767d1c24203047693ee771b12ab0354c892f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ef767d1c24203047693ee771b12ab0354c892f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35b3fc02e02fa21deb51105d04132d55d4282754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35b3fc02e02fa21deb51105d04132d55d4282754", "html_url": "https://github.com/rust-lang/rust/commit/35b3fc02e02fa21deb51105d04132d55d4282754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35b3fc02e02fa21deb51105d04132d55d4282754/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe0ec5497cdbd7910b0197d254c2b2356fe1874", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe0ec5497cdbd7910b0197d254c2b2356fe1874", "html_url": "https://github.com/rust-lang/rust/commit/4fe0ec5497cdbd7910b0197d254c2b2356fe1874"}], "stats": {"total": 47, "additions": 35, "deletions": 12}, "files": [{"sha": "6d59ef6596deed44d4a61ccf6b82422d4157d1cd", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=35b3fc02e02fa21deb51105d04132d55d4282754", "patch": "@@ -29,6 +29,8 @@ use crate::{\n pub struct HirFileId(HirFileIdRepr);\n \n impl HirFileId {\n+    /// For macro-expansion files, returns the file original source file the\n+    /// expansionoriginated from.\n     pub(crate) fn original_file_id(self, db: &impl HirDatabase) -> FileId {\n         match self.0 {\n             HirFileIdRepr::File(file_id) => file_id,\n@@ -45,6 +47,7 @@ impl HirFileId {\n             HirFileIdRepr::Macro(_r) => panic!(\"macro generated file: {:?}\", self),\n         }\n     }\n+\n     pub(crate) fn hir_source_file(db: &impl HirDatabase, file_id: HirFileId) -> SourceFileNode {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.source_file(file_id),"}, {"sha": "8ee52a466dd51faf5ba077aaec6d722a8e79f5c4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=35b3fc02e02fa21deb51105d04132d55d4282754", "patch": "@@ -25,6 +25,7 @@ pub mod source_binder;\n mod ids;\n mod macros;\n mod name;\n+// can't use `crate` or `r#crate` here :(\n mod krate;\n mod module;\n mod function;"}, {"sha": "b7b75e70221fc54847ab5e470a65c1e4225d6234", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b3fc02e02fa21deb51105d04132d55d4282754/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=35b3fc02e02fa21deb51105d04132d55d4282754", "patch": "@@ -1,3 +1,12 @@\n+/// Machinery for macro expansion.\n+///\n+/// One of the more complicated things about macros is managing the source code\n+/// that is produced after expansion. See `HirFileId` and `MacroCallId` for how\n+/// do we do that.\n+///\n+/// When file-management question is resolved, all that is left is a token tree\n+/// to token tree transformation plus hygent. We don't have either of thouse\n+/// yet, so all macros are string based at the moment!\n use std::sync::Arc;\n \n use ra_db::LocalSyntaxPtr;\n@@ -16,6 +25,8 @@ pub enum MacroDef {\n }\n \n impl MacroDef {\n+    /// Expands macro call, returning the expansion and offset to be used to\n+    /// convert ranges between expansion and original source.\n     pub fn ast_expand(macro_call: ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n         let (def, input) = MacroDef::from_call(macro_call)?;\n         let exp = def.expand(input)?;\n@@ -109,38 +120,46 @@ pub struct MacroInput {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct MacroExpansion {\n+    /// The result of macro expansion. Should be token tree as well.\n     text: String,\n+    /// Correspondence between ranges in the original source code and ranges in\n+    /// the macro.\n     ranges_map: Vec<(TextRange, TextRange)>,\n+    /// Implementation detail: internally, a macro is expanded to the whole file,\n+    /// even if it is an expression. This `ptr` selects the actual expansion from\n+    /// the expanded file.\n     ptr: LocalSyntaxPtr,\n }\n \n impl MacroExpansion {\n-    //FIXME: does not really make sense, macro expansion is not neccessary a\n-    //whole file.\n+    // FIXME: does not really make sense, macro expansion is not neccessary a\n+    // whole file. See `MacroExpansion::ptr` as well.\n     pub(crate) fn file(&self) -> SourceFileNode {\n         SourceFileNode::parse(&self.text)\n     }\n \n     pub fn syntax(&self) -> SyntaxNode {\n         self.ptr.resolve(&self.file())\n     }\n-    pub fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n+    /// Maps range in the source code to the range in the expanded code.\n+    pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n         for (s_range, t_range) in self.ranges_map.iter() {\n-            if tgt_range.is_subrange(&t_range) {\n-                let tgt_at_zero_range = tgt_range - tgt_range.start();\n-                let tgt_range_offset = tgt_range.start() - t_range.start();\n-                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n+            if src_range.is_subrange(&s_range) {\n+                let src_at_zero_range = src_range - src_range.start();\n+                let src_range_offset = src_range.start() - s_range.start();\n+                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n                 return Some(src_range);\n             }\n         }\n         None\n     }\n-    pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n+    /// Maps range in the expanded code to the range in the source code.\n+    pub fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n         for (s_range, t_range) in self.ranges_map.iter() {\n-            if src_range.is_subrange(&s_range) {\n-                let src_at_zero_range = src_range - src_range.start();\n-                let src_range_offset = src_range.start() - s_range.start();\n-                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n+            if tgt_range.is_subrange(&t_range) {\n+                let tgt_at_zero_range = tgt_range - tgt_range.start();\n+                let tgt_range_offset = tgt_range.start() - t_range.start();\n+                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n                 return Some(src_range);\n             }\n         }"}]}