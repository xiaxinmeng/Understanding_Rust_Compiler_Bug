{"sha": "2deff71719a32af76eb4493ddb1dc4653fb88cad", "node_id": "C_kwDOAAsO6NoAKDJkZWZmNzE3MTlhMzJhZjc2ZWI0NDkzZGRiMWRjNDY1M2ZiODhjYWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T01:19:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T01:19:25Z"}, "message": "Auto merge of #105462 - oli-obk:feeding_full, r=cjgillot,petrochenkov\n\ngive the resolver access to TyCtxt\n\nThe resolver is now created after TyCtxt is created. Then macro expansion and name resolution are run and the results fed into queries just like before this PR.\n\nSince the resolver had (before this PR) mutable access to the `CStore` and the source span table, these two datastructures are now behind a `RwLock`. To ensure that these are not mutated anymore after the resolver is done, a read lock to them is leaked right after the resolver finishes.\n\n### PRs split out of this one and leading up to it:\n\n* https://github.com/rust-lang/rust/pull/105423\n* https://github.com/rust-lang/rust/pull/105357\n* https://github.com/rust-lang/rust/pull/105603\n* https://github.com/rust-lang/rust/pull/106776\n* https://github.com/rust-lang/rust/pull/106810\n* https://github.com/rust-lang/rust/pull/106812\n* https://github.com/rust-lang/rust/pull/108032", "tree": {"sha": "40f0c67b323ffca820dd9ddeec89d864e7159591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40f0c67b323ffca820dd9ddeec89d864e7159591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2deff71719a32af76eb4493ddb1dc4653fb88cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2deff71719a32af76eb4493ddb1dc4653fb88cad", "html_url": "https://github.com/rust-lang/rust/commit/2deff71719a32af76eb4493ddb1dc4653fb88cad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2deff71719a32af76eb4493ddb1dc4653fb88cad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "html_url": "https://github.com/rust-lang/rust/commit/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc"}, {"sha": "0847b79adaf209e9d174e315e3b49127643312c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0847b79adaf209e9d174e315e3b49127643312c6", "html_url": "https://github.com/rust-lang/rust/commit/0847b79adaf209e9d174e315e3b49127643312c6"}], "stats": {"total": 933, "additions": 480, "deletions": 453}, "files": [{"sha": "6c17edd302081e8044fd3780b2b79e3fbc87d149", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -4180,6 +4180,7 @@ dependencies = [\n  \"rustc_hir_analysis\",\n  \"rustc_hir_typeck\",\n  \"rustc_incremental\",\n+ \"rustc_index\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_metadata\","}, {"sha": "019ec0758d6efe0606aa65b00b59ed6f5ad7a290", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -33,6 +33,7 @@ use rustc_target::spec::{RelocModel, Target};\n /// <dt>dylib</dt>\n /// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n /// </dl>\n+#[derive(Debug)]\n pub struct DefaultMetadataLoader;\n \n fn load_metadata_with("}, {"sha": "d7e9e00f3b63bb40fc0df2d62cfc65e7aeef8a9f", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -320,7 +320,7 @@ fn run_compiler(\n             }\n \n             // Make sure name resolution and macro expansion is run.\n-            queries.global_ctxt()?;\n+            queries.global_ctxt()?.enter(|tcx| tcx.resolver_for_lowering(()));\n \n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();"}, {"sha": "5679cdcbbd0625e8d03c7769b38ac65d850fc134", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -16,7 +16,6 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_errors::{Applicability, ErrorGuaranteed};\n-use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n };\n@@ -379,7 +378,6 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n /// Converts a macro item into a syntax extension.\n pub fn compile_declarative_macro(\n     sess: &Session,\n-    features: &Features,\n     def: &ast::Item,\n     edition: Edition,\n ) -> (SyntaxExtension, Vec<(usize, Span)>) {\n@@ -508,7 +506,7 @@ pub fn compile_declarative_macro(\n                         true,\n                         &sess.parse_sess,\n                         def.id,\n-                        features,\n+                        sess.features_untracked(),\n                         edition,\n                     )\n                     .pop()\n@@ -532,7 +530,7 @@ pub fn compile_declarative_macro(\n                         false,\n                         &sess.parse_sess,\n                         def.id,\n-                        features,\n+                        sess.features_untracked(),\n                         edition,\n                     )\n                     .pop()"}, {"sha": "ac6e8fca69554baadc02d292dab06640bea461f6", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -24,6 +24,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../rustc_ast_passes\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_traits = { path = \"../rustc_traits\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }"}, {"sha": "aa59654099a689e20ae6b8efd746a15e26be2e76", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -8,11 +8,12 @@ use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_errors::{ErrorGuaranteed, PResult};\n+use rustc_errors::PResult;\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n-use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n+use rustc_lint::{unerased_lint_store, BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n@@ -171,14 +172,12 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n /// standard library and prelude, and name resolution.\n-pub fn configure_and_expand(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    mut krate: ast::Crate,\n-    crate_name: Symbol,\n-    resolver: &mut Resolver<'_, '_>,\n-) -> Result<ast::Crate> {\n-    trace!(\"configure_and_expand\");\n+#[instrument(level = \"trace\", skip(krate, resolver))]\n+fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>) -> ast::Crate {\n+    let tcx = resolver.tcx();\n+    let sess = tcx.sess;\n+    let lint_store = unerased_lint_store(tcx);\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n     pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n@@ -249,20 +248,19 @@ pub fn configure_and_expand(\n             ecx.check_unused_macros();\n         });\n \n-        let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n+        // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n+        // with a large AST\n+        if ecx.reduced_recursion_limit.is_some() {\n+            sess.abort_if_errors();\n+            unreachable!();\n+        }\n \n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n \n-        if recursion_limit_hit {\n-            // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n-            // with a large AST\n-            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            Ok(krate)\n-        }\n-    })?;\n+        krate\n+    });\n \n     sess.time(\"maybe_building_test_harness\", || {\n         rustc_builtin_macros::test_harness::inject(sess, resolver, &mut krate)\n@@ -365,7 +363,7 @@ pub fn configure_and_expand(\n         )\n     });\n \n-    Ok(krate)\n+    krate\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -564,6 +562,28 @@ fn write_out_deps(\n     }\n }\n \n+fn resolver_for_lowering<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (): (),\n+) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n+    let arenas = Resolver::arenas();\n+    let krate = tcx.crate_for_resolver(()).steal();\n+    let mut resolver = Resolver::new(tcx, &krate, &arenas);\n+    let krate = configure_and_expand(krate, &mut resolver);\n+\n+    // Make sure we don't mutate the cstore from here on.\n+    tcx.untracked().cstore.leak();\n+\n+    let ty::ResolverOutputs {\n+        global_ctxt: untracked_resolutions,\n+        ast_lowering: untracked_resolver_for_lowering,\n+    } = resolver.into_outputs();\n+\n+    let feed = tcx.feed_unit_query();\n+    feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n+    tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, Lrc::new(krate))))\n+}\n+\n fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     let sess = tcx.sess;\n     let _timer = sess.timer(\"prepare_outputs\");\n@@ -597,7 +617,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n         }\n     }\n \n-    write_out_deps(sess, tcx.cstore_untracked(), &outputs, &output_paths);\n+    write_out_deps(sess, &*tcx.cstore_untracked(), &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -618,6 +638,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     providers.analysis = analysis;\n     providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n     providers.output_filenames = output_filenames;\n+    providers.resolver_for_lowering = resolver_for_lowering;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);"}, {"sha": "c957578b59e1d4d51ec11d94756e2a3ba3af2d98", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -7,16 +7,19 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_data_structures::sync::{Lrc, OnceCell, RwLock, WorkerLocal};\n+use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_incremental::DepGraphFuture;\n+use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n+use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n-use rustc_middle::ty::{self, GlobalCtxt, TyCtxt};\n+use rustc_middle::ty::{GlobalCtxt, TyCtxt};\n use rustc_query_impl::Queries as TcxQueries;\n-use rustc_resolve::Resolver;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n+use rustc_session::cstore::Untracked;\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n@@ -187,35 +190,18 @@ impl<'tcx> Queries<'tcx> {\n         self.gcx.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n             let (krate, lint_store) = self.register_plugins()?.steal();\n-            let (krate, resolver_outputs) = {\n-                let _timer = self.session().timer(\"configure_and_expand\");\n-                let sess = self.session();\n-\n-                let arenas = Resolver::arenas();\n-                let mut resolver = Resolver::new(\n-                    sess,\n-                    &krate,\n-                    crate_name,\n-                    self.codegen_backend().metadata_loader(),\n-                    &arenas,\n-                );\n-                let krate = passes::configure_and_expand(\n-                    sess,\n-                    &lint_store,\n-                    krate,\n-                    crate_name,\n-                    &mut resolver,\n-                )?;\n-                (Lrc::new(krate), resolver.into_outputs())\n-            };\n-\n-            let ty::ResolverOutputs {\n-                untracked,\n-                global_ctxt: untracked_resolutions,\n-                ast_lowering: untracked_resolver_for_lowering,\n-            } = resolver_outputs;\n \n-            let gcx = passes::create_global_ctxt(\n+            let sess = self.session();\n+\n+            let cstore = RwLock::new(Box::new(CStore::new(sess)) as _);\n+            let definitions = RwLock::new(Definitions::new(sess.local_stable_crate_id()));\n+            let mut source_span = IndexVec::default();\n+            let _id = source_span.push(krate.spans.inner_span);\n+            debug_assert_eq!(_id, CRATE_DEF_ID);\n+            let source_span = RwLock::new(source_span);\n+            let untracked = Untracked { cstore, source_span, definitions };\n+\n+            let qcx = passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n                 self.dep_graph()?.steal(),\n@@ -226,17 +212,18 @@ impl<'tcx> Queries<'tcx> {\n                 &self.hir_arena,\n             );\n \n-            gcx.enter(|tcx| {\n+            qcx.enter(|tcx| {\n+                let feed = tcx.feed_local_crate();\n+                feed.crate_name(crate_name);\n+\n                 let feed = tcx.feed_unit_query();\n-                feed.resolver_for_lowering(\n-                    tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n+                feed.crate_for_resolver(tcx.arena.alloc(Steal::new(krate)));\n+                feed.metadata_loader(\n+                    tcx.arena.alloc(Steal::new(self.codegen_backend().metadata_loader())),\n                 );\n-                feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n                 feed.features_query(tcx.sess.features_untracked());\n-                let feed = tcx.feed_local_crate();\n-                feed.crate_name(crate_name);\n             });\n-            Ok(gcx)\n+            Ok(qcx)\n         })\n     }\n "}, {"sha": "b05626311e8e1f0deccd2b455aa0c5d4f38b770e", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -8,15 +8,15 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::ReadGuard;\n+use rustc_data_structures::sync::MappedReadGuard;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n+use rustc_session::cstore::ExternCrateSource;\n use rustc_session::cstore::{CrateDepKind, CrateSource, ExternCrate};\n-use rustc_session::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_session::lint;\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n@@ -60,17 +60,22 @@ impl std::fmt::Debug for CStore {\n     }\n }\n \n-pub struct CrateLoader<'a> {\n+pub struct CrateLoader<'a, 'tcx: 'a> {\n     // Immutable configuration.\n-    sess: &'a Session,\n-    metadata_loader: &'a MetadataLoaderDyn,\n-    definitions: ReadGuard<'a, Definitions>,\n-    local_crate_name: Symbol,\n+    tcx: TyCtxt<'tcx>,\n     // Mutable output.\n     cstore: &'a mut CStore,\n     used_extern_options: &'a mut FxHashSet<Symbol>,\n }\n \n+impl<'a, 'tcx> std::ops::Deref for CrateLoader<'a, 'tcx> {\n+    type Target = TyCtxt<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.tcx\n+    }\n+}\n+\n pub enum LoadedMacro {\n     MacroDef(ast::Item, Edition),\n     ProcMacro(SyntaxExtension),\n@@ -127,11 +132,10 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n }\n \n impl CStore {\n-    pub fn from_tcx(tcx: TyCtxt<'_>) -> &CStore {\n-        tcx.cstore_untracked()\n-            .as_any()\n-            .downcast_ref::<CStore>()\n-            .expect(\"`tcx.cstore` is not a `CStore`\")\n+    pub fn from_tcx(tcx: TyCtxt<'_>) -> MappedReadGuard<'_, CStore> {\n+        MappedReadGuard::map(tcx.cstore_untracked(), |c| {\n+            c.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        })\n     }\n \n     fn alloc_new_crate_num(&mut self) -> CrateNum {\n@@ -256,23 +260,13 @@ impl CStore {\n     }\n }\n \n-impl<'a> CrateLoader<'a> {\n+impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     pub fn new(\n-        sess: &'a Session,\n-        metadata_loader: &'a MetadataLoaderDyn,\n-        local_crate_name: Symbol,\n+        tcx: TyCtxt<'tcx>,\n         cstore: &'a mut CStore,\n-        definitions: ReadGuard<'a, Definitions>,\n         used_extern_options: &'a mut FxHashSet<Symbol>,\n     ) -> Self {\n-        CrateLoader {\n-            sess,\n-            metadata_loader,\n-            local_crate_name,\n-            cstore,\n-            used_extern_options,\n-            definitions,\n-        }\n+        CrateLoader { tcx, cstore, used_extern_options }\n     }\n     pub fn cstore(&self) -> &CStore {\n         &self.cstore\n@@ -563,9 +557,10 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n+            let metadata_loader = self.tcx.metadata_loader(()).borrow();\n             let mut locator = CrateLocator::new(\n                 self.sess,\n-                &*self.metadata_loader,\n+                &**metadata_loader,\n                 name,\n                 hash,\n                 extra_filename,\n@@ -970,7 +965,7 @@ impl<'a> CrateLoader<'a> {\n                     &format!(\n                         \"external crate `{}` unused in `{}`: remove the dependency or add `use {} as _;`\",\n                         name,\n-                        self.local_crate_name,\n+                        self.tcx.crate_name(LOCAL_CRATE),\n                         name),\n                 );\n         }\n@@ -990,6 +985,7 @@ impl<'a> CrateLoader<'a> {\n         &mut self,\n         item: &ast::Item,\n         def_id: LocalDefId,\n+        definitions: &Definitions,\n     ) -> Option<CrateNum> {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n@@ -1012,7 +1008,7 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind)?;\n \n-                let path_len = self.definitions.def_path(def_id).data.len();\n+                let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {"}, {"sha": "60ea08a16473c96876a445a11fee5ac9342628fc", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -130,7 +130,13 @@ macro_rules! provide_one {\n                 $tcx.ensure().crate_hash($def_id.krate);\n             }\n \n-            let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n+            let cdata = rustc_data_structures::sync::MappedReadGuard::map(CStore::from_tcx($tcx), |c| {\n+                c.get_crate_data($def_id.krate).cdata\n+            });\n+            let $cdata = crate::creader::CrateMetadataRef {\n+                cdata: &cdata,\n+                cstore: &CStore::from_tcx($tcx),\n+            };\n \n             $compute\n         }"}, {"sha": "d4019b5bf17eb3c1ed9455a59d3f91d801d235e3", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -35,6 +35,8 @@ macro_rules! arena_types {\n                 rustc_data_structures::sync::Lrc<rustc_ast::Crate>,\n             )>,\n             [] output_filenames: std::sync::Arc<rustc_session::config::OutputFilenames>,\n+            [] metadata_loader: rustc_data_structures::steal::Steal<Box<rustc_session::cstore::MetadataLoaderDyn>>,\n+            [] crate_for_resolver: rustc_data_structures::steal::Steal<rustc_ast::ast::Crate>,\n             [] resolutions: rustc_middle::ty::ResolverGlobalCtxt,\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n             [decode] code_region: rustc_middle::mir::coverage::CodeRegion,"}, {"sha": "893bf54b8660b101e5dafda730db29fde96b5517", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -194,11 +194,6 @@ impl EffectiveVisibilities {\n     }\n }\n \n-pub trait IntoDefIdTree {\n-    type Tree: DefIdTree;\n-    fn tree(self) -> Self::Tree;\n-}\n-\n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n@@ -217,25 +212,21 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         self.map.entry(id).or_insert_with(|| EffectiveVisibility::from_vis(lazy_private_vis()))\n     }\n \n-    pub fn update<T: IntoDefIdTree>(\n+    pub fn update(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n-        lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n-        mut into_tree: T,\n+        tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = match self.map.get(&id).copied() {\n-            Some(eff_vis) => eff_vis,\n-            None => {\n-                let private_vis;\n-                (private_vis, into_tree) = lazy_private_vis(into_tree);\n-                EffectiveVisibility::from_vis(private_vis)\n-            }\n-        };\n-        let tree = into_tree.tree();\n+        let mut current_effective_vis = self\n+            .map\n+            .get(&id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n \n         let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.at_level(level);\n         let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;"}, {"sha": "3b559c7f8adff5cfcb98b9cac6df176fdefd0767", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -33,7 +33,7 @@ rustc_queries! {\n     }\n \n     query resolver_for_lowering(_: ()) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n-        feedable\n+        eval_always\n         no_hash\n         desc { \"getting the resolver for lowering\" }\n     }\n@@ -2077,6 +2077,18 @@ rustc_queries! {\n         desc { \"looking up enabled feature gates\" }\n     }\n \n+    query metadata_loader((): ()) -> &'tcx Steal<Box<rustc_session::cstore::MetadataLoaderDyn>> {\n+        feedable\n+        no_hash\n+        desc { \"raw operations for metadata file access\" }\n+    }\n+\n+    query crate_for_resolver((): ()) -> &'tcx Steal<rustc_ast::ast::Crate> {\n+        feedable\n+        no_hash\n+        desc { \"the ast before macro expansion and name resolution\" }\n+    }\n+\n     /// Attempt to resolve the given `DefId` to an `Instance`, for the\n     /// given generics args (`SubstsRef`), returning one of:\n     ///  * `Ok(Some(instance))` on success"}, {"sha": "cf4836ded474bb94538f4f10b50fffd5eae371aa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -36,7 +36,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, MappedReadGuard, ReadGuard, WorkerLocal};\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n@@ -836,7 +836,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.untracked.cstore.def_key(id)\n+            self.cstore_untracked().def_key(id)\n         }\n     }\n \n@@ -850,7 +850,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.untracked.cstore.def_path(id)\n+            self.cstore_untracked().def_path(id)\n         }\n     }\n \n@@ -860,7 +860,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.untracked.cstore.def_path_hash(def_id)\n+            self.cstore_untracked().def_path_hash(def_id)\n         }\n     }\n \n@@ -869,7 +869,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked.cstore.stable_crate_id(crate_num)\n+            self.cstore_untracked().stable_crate_id(crate_num)\n         }\n     }\n \n@@ -880,7 +880,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.cstore_untracked().stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -899,7 +899,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &*self.untracked.cstore;\n+            let cstore = &*self.cstore_untracked();\n             let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n             cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n@@ -913,7 +913,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name(LOCAL_CRATE), self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &*self.untracked.cstore;\n+            let cstore = &*self.cstore_untracked();\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1011,10 +1011,14 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.untracked.cstore\n+    pub fn cstore_untracked(self) -> MappedReadGuard<'tcx, CrateStoreDyn> {\n+        ReadGuard::map(self.untracked.cstore.read(), |c| &**c)\n     }\n \n+    /// Give out access to the untracked data without any sanity checks.\n+    pub fn untracked(self) -> &'tcx Untracked {\n+        &self.untracked\n+    }\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n@@ -1026,7 +1030,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n-        self.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n+        self.untracked.source_span.read().get(def_id).copied().unwrap_or(DUMMY_SP)\n     }\n \n     #[inline(always)]\n@@ -2518,5 +2522,5 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };\n     providers.source_span =\n-        |tcx, def_id| tcx.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n+        |tcx, def_id| tcx.untracked.source_span.read().get(def_id).copied().unwrap_or(DUMMY_SP);\n }"}, {"sha": "f61fe707ac934fd41a631060c88a00798824a8e1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -43,7 +43,6 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_session::cstore::Untracked;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n@@ -157,7 +156,6 @@ pub type RegisteredTools = FxHashSet<Ident>;\n pub struct ResolverOutputs {\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n-    pub untracked: Untracked,\n }\n \n #[derive(Debug)]"}, {"sha": "8db8ee9428bc737fb78c413f1a99b889b64a2717", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -90,7 +90,7 @@ impl<'a> StableHashingContext<'a> {\n         if let Some(def_id) = def_id.as_local() {\n             self.local_def_path_hash(def_id)\n         } else {\n-            self.untracked.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.read().def_path_hash(def_id)\n         }\n     }\n \n@@ -146,7 +146,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        *self.untracked.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n+        *self.untracked.source_span.read().get(def_id).unwrap_or(&DUMMY_SP)\n     }\n \n     #[inline]"}, {"sha": "b1e023f2caa5761b3620d7e030268dd8a74b91d3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -130,11 +130,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n                     };\n \n+                    let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n+                    let span = self.cstore().get_span_untracked(def_id, &self.tcx.sess);\n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n-                        self.cstore().module_expansion_untracked(def_id, &self.session),\n-                        self.cstore().get_span_untracked(def_id, &self.session),\n+                        expn_id,\n+                        span,\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),\n                     ))\n@@ -179,7 +181,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return macro_data.clone();\n         }\n \n-        let (ext, macro_rules) = match self.cstore().load_macro_untracked(def_id, &self.session) {\n+        let load_macro_untracked = self.cstore().load_macro_untracked(def_id, &self.tcx.sess);\n+        let (ext, macro_rules) = match load_macro_untracked {\n             LoadedMacro::MacroDef(item, edition) => (\n                 Lrc::new(self.compile_macro(&item, edition).0),\n                 matches!(item.kind, ItemKind::MacroDef(def) if def.macro_rules),\n@@ -204,9 +207,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n-        for child in\n-            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.session))\n-        {\n+        let children =\n+            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.tcx.sess));\n+        for child in children {\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -346,7 +349,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n     fn insert_field_names_extern(&mut self, def_id: DefId) {\n         let field_names =\n-            self.r.cstore().struct_field_names_untracked(def_id, self.r.session).collect();\n+            self.r.cstore().struct_field_names_untracked(def_id, self.r.tcx.sess).collect();\n         self.r.field_names.insert(def_id, field_names);\n     }\n \n@@ -539,14 +542,15 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         }\n \n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(item.span, \"`$crate` may not be imported\")\n                             .emit();\n                     }\n                 }\n \n                 if ident.name == kw::Crate {\n-                    self.r.session.span_err(\n+                    self.r.tcx.sess.span_err(\n                         ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\",\n@@ -575,7 +579,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -690,7 +694,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -755,7 +759,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -837,7 +841,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         let (used, module, binding) = if orig_name.is_none() && ident.name == kw::SelfLower {\n             self.r\n-                .session\n+                .tcx\n+                .sess\n                 .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                 .span_suggestion(\n                     item.span,\n@@ -850,7 +855,10 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         } else if orig_name == Some(kw::SelfLower) {\n             Some(self.r.graph_root)\n         } else {\n-            let crate_id = self.r.crate_loader().process_extern_crate(item, local_def_id);\n+            let tcx = self.r.tcx;\n+            let crate_id = self.r.crate_loader(|c| {\n+                c.process_extern_crate(item, local_def_id, &tcx.definitions_untracked())\n+            });\n             crate_id.map(|crate_id| {\n                 self.r.extern_crate_map.insert(local_def_id, crate_id);\n                 self.r.expect_module(crate_id.as_def_id())\n@@ -887,7 +895,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 {\n                     let msg = \"macro-expanded `extern crate` items cannot \\\n                                        shadow names passed with `--extern`\";\n-                    self.r.session.span_err(item.span, msg);\n+                    self.r.tcx.sess.span_err(item.span, msg);\n                 }\n             }\n             let entry = self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n@@ -998,23 +1006,26 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             | Res::Err => bug!(\"unexpected resolution: {:?}\", res),\n         }\n         // Record some extra data for better diagnostics.\n-        let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) => {\n+                let cstore = self.r.cstore();\n                 if let Some((ctor_kind, ctor_def_id)) = cstore.ctor_untracked(def_id) {\n                     let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n                     let ctor_vis = cstore.visibility_untracked(ctor_def_id);\n                     let field_visibilities =\n                         cstore.struct_field_visibilities_untracked(def_id).collect();\n+                    drop(cstore);\n                     self.r\n                         .struct_constructors\n                         .insert(def_id, (ctor_res, ctor_vis, field_visibilities));\n+                } else {\n+                    drop(cstore);\n                 }\n                 self.insert_field_names_extern(def_id)\n             }\n             Res::Def(DefKind::Union, def_id) => self.insert_field_names_extern(def_id),\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.fn_has_self_parameter_untracked(def_id, self.r.session) {\n+                if self.r.cstore().fn_has_self_parameter_untracked(def_id, self.r.tcx.sess) {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n@@ -1033,7 +1044,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.r.session.struct_span_err(span, &msg).note(note).emit();\n+            self.r.tcx.sess.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n \n@@ -1045,7 +1056,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             if attr.has_name(sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         item.span,\n                         E0468,\n                         \"an `extern crate` loading macros must be at the crate root\"\n@@ -1055,7 +1066,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.kind {\n                     if orig_name == kw::SelfLower {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(\n                                 attr.span,\n                                 \"`#[macro_use]` is not supported on `extern crate self`\",\n@@ -1064,7 +1076,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n                 let ill_formed = |span| {\n-                    struct_span_err!(self.r.session, span, E0466, \"bad macro import\").emit();\n+                    struct_span_err!(self.r.tcx.sess, span, E0466, \"bad macro import\").emit();\n                 };\n                 match attr.meta() {\n                     Some(meta) => match meta.kind {\n@@ -1135,8 +1147,13 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         allow_shadowing,\n                     );\n                 } else {\n-                    struct_span_err!(self.r.session, ident.span, E0469, \"imported macro not found\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.r.tcx.sess,\n+                        ident.span,\n+                        E0469,\n+                        \"imported macro not found\"\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -1148,7 +1165,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         for attr in attrs {\n             if attr.has_name(sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n-                let mut err = self.r.session.struct_span_warn(attr.span, msg);\n+                let mut err = self.r.tcx.sess.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n@@ -1159,7 +1176,10 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n \n             if !attr.is_word() {\n-                self.r.session.span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n+                self.r\n+                    .tcx\n+                    .sess\n+                    .span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n             }\n             return true;\n         }\n@@ -1183,11 +1203,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.session.contains_name(&item.attrs, sym::proc_macro) {\n+        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.session.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.session.find_by_name(&item.attrs, sym::proc_macro_derive)\n+        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n         {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n@@ -1222,7 +1242,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         let def_id = self.r.local_def_id(item.id);\n         let (ext, ident, span, macro_rules, rule_spans) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n-                let (ext, rule_spans) = self.r.compile_macro(item, self.r.session.edition());\n+                let (ext, rule_spans) = self.r.compile_macro(item, self.r.tcx.sess.edition());\n                 let ext = Lrc::new(ext);\n                 (ext, item.ident, item.span, def.macro_rules, rule_spans)\n             }\n@@ -1243,7 +1263,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1507,7 +1527,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n         let ctor_vis = if vis.is_public()\n-            && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n+            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n         {\n             ty::Visibility::Restricted(CRATE_DEF_ID)\n         } else {"}, {"sha": "0114e116386b028be4cb2d9e779bc7de051fedfc", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -290,7 +290,7 @@ impl Resolver<'_, '_> {\n             let ms = MultiSpan::from_spans(spans.clone());\n             let mut span_snippets = spans\n                 .iter()\n-                .filter_map(|s| match visitor.r.session.source_map().span_to_snippet(*s) {\n+                .filter_map(|s| match visitor.r.tcx.sess.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 })\n@@ -317,7 +317,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if visitor.r.session.opts.test {\n+            let test_module_span = if visitor.r.tcx.sess.opts.test {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module("}, {"sha": "9aec25fff0b4f4f3d64f6f10ec2154f951cc64ba", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 81, "deletions": 70, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -154,8 +154,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             if !candidates.is_empty() {\n                 show_candidates(\n-                    &self.session,\n-                    &self.untracked.source_span,\n+                    &self.tcx.sess,\n+                    &self.tcx.untracked().source_span.read(),\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n \n         let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+            (ident.name, self.tcx.sess.source_map().guess_head_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -226,15 +226,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, true) => struct_span_err!(self.tcx.sess, span, E0259, \"{}\", msg),\n             (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+                true => struct_span_err!(self.tcx.sess, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.tcx.sess, span, E0260, \"{}\", msg),\n             },\n             _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+                (false, false) => struct_span_err!(self.tcx.sess, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.tcx.sess, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.tcx.sess, span, E0255, \"{}\", msg),\n             },\n         };\n \n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         if !old_binding.span.is_dummy() && old_binding.span != span {\n             err.span_label(\n-                self.session.source_map().guess_head_span(old_binding.span),\n+                self.tcx.sess.source_map().guess_head_span(old_binding.span),\n                 format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n             );\n         }\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(binding_span) {\n                         if pos <= snippet.len() {\n                             suggestion = Some(format!(\n                                 \"{} as {}{}\",\n@@ -426,12 +426,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+            find_span_of_binding_until_next_binding(self.tcx.sess, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+            if let Some(span) = extend_span_to_previous_binding(self.tcx.sess, span) {\n                 err.tool_only_span_suggestion(span, message, \"\", Applicability::MaybeIncorrect);\n             } else {\n                 // Remove the entire line if we cannot extend the span back, this indicates an\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let first_name = match path.get(0) {\n             // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.is_rust_2015() && self.session.is_rust_2015() => {\n+            Some(seg) if seg.ident.span.is_rust_2015() && self.tcx.sess.is_rust_2015() => {\n                 seg.ident.name\n             }\n             _ => return,\n@@ -541,14 +541,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match resolution_error {\n             ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     span,\n                     E0401,\n                     \"can't use generic parameters from outer function\",\n                 );\n                 err.span_label(span, \"use of generic parameter from outer function\");\n \n-                let sm = self.session.source_map();\n+                let sm = self.tcx.sess.source_map();\n                 let def_id = match outer_res {\n                     Res::SelfTyParam { .. } => {\n                         err.span_label(span, \"can't use `Self` here\");\n@@ -605,10 +605,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::NameAlreadyUsedInParameterList { span, first_use_span, name }),\n             ResolutionError::MethodNotMemberOfTrait(method, trait_, candidate) => {\n-                self.session.create_err(errs::MethodNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::MethodNotMemberOfTrait {\n                     span,\n                     method,\n                     trait_,\n@@ -619,7 +620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::TypeNotMemberOfTrait(type_, trait_, candidate) => {\n-                self.session.create_err(errs::TypeNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::TypeNotMemberOfTrait {\n                     span,\n                     type_,\n                     trait_,\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::ConstNotMemberOfTrait(const_, trait_, candidate) => {\n-                self.session.create_err(errs::ConstNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::ConstNotMemberOfTrait {\n                     span,\n                     const_,\n                     trait_,\n@@ -648,7 +649,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let msp = MultiSpan::from_spans(target_sp.clone());\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     msp,\n                     E0408,\n                     \"variable `{}` is not bound in all patterns\",\n@@ -686,8 +687,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         err.span_help(span, &help_msg);\n                     }\n                     show_candidates(\n-                        &self.session,\n-                        &self.untracked.source_span,\n+                        &self.tcx.sess,\n+                        &self.tcx.untracked().source_span.read(),\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -701,17 +702,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name, first_binding_span) => {\n-                self.session.create_err(errs::VariableBoundWithDifferentMode {\n+                self.tcx.sess.create_err(errs::VariableBoundWithDifferentMode {\n                     span,\n                     first_binding_span,\n                     variable_name,\n                 })\n             }\n             ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInParameterList { span, identifier }),\n             ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInSamePattern { span, identifier }),\n             ResolutionError::UndeclaredLabel { name, suggestion } => {\n                 let ((sub_reachable, sub_reachable_suggestion), sub_unreachable) = match suggestion\n@@ -737,7 +740,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // No similarly-named labels exist.\n                     None => ((None, None), None),\n                 };\n-                self.session.create_err(errs::UndeclaredLabel {\n+                self.tcx.sess.create_err(errs::UndeclaredLabel {\n                     span,\n                     name,\n                     sub_reachable,\n@@ -762,21 +765,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     (Some(suggestion), Some(mpart_suggestion))\n                 };\n-                self.session.create_err(errs::SelfImportsOnlyAllowedWithin {\n+                self.tcx.sess.create_err(errs::SelfImportsOnlyAllowedWithin {\n                     span,\n                     suggestion,\n                     mpart_suggestion,\n                 })\n             }\n             ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-                self.session.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n-            }\n-            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-                self.session.create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span })\n+                self.tcx.sess.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n             }\n+            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => self\n+                .tcx\n+                .sess\n+                .create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span }),\n             ResolutionError::FailedToResolve { label, suggestion } => {\n                 let mut err =\n-                    struct_span_err!(self.session, span, E0433, \"failed to resolve: {}\", &label);\n+                    struct_span_err!(self.tcx.sess, span, E0433, \"failed to resolve: {}\", &label);\n                 err.span_label(span, label);\n \n                 if let Some((suggestions, msg, applicability)) = suggestion {\n@@ -790,7 +794,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-                self.session.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n+                self.tcx.sess.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n             }\n             ResolutionError::AttemptToUseNonConstantValueInConstant(ident, suggestion, current) => {\n                 // let foo =...\n@@ -802,12 +806,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // the further the two are apart, the higher the chance of the suggestion being wrong\n \n                 let sp = self\n-                    .session\n+                    .tcx\n+                    .sess\n                     .source_map()\n                     .span_extend_to_prev_str(ident.span, current, true, false);\n \n                 let ((with, with_label), without) = match sp {\n-                    Some(sp) if !self.session.source_map().is_multiline(sp) => {\n+                    Some(sp) if !self.tcx.sess.source_map().is_multiline(sp) => {\n                         let sp = sp.with_lo(BytePos(sp.lo().0 - (current.len() as u32)));\n                         (\n                         (Some(errs::AttemptToUseNonConstantValueInConstantWithSuggestion {\n@@ -828,7 +833,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     ),\n                 };\n \n-                self.session.create_err(errs::AttemptToUseNonConstantValueInConstant {\n+                self.tcx.sess.create_err(errs::AttemptToUseNonConstantValueInConstant {\n                     span,\n                     with,\n                     with_label,\n@@ -842,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 article,\n                 shadowed_binding,\n                 shadowed_binding_span,\n-            } => self.session.create_err(errs::BindingShadowsSomethingUnacceptable {\n+            } => self.tcx.sess.create_err(errs::BindingShadowsSomethingUnacceptable {\n                 span,\n                 shadowing_binding,\n                 shadowed_binding,\n@@ -859,13 +864,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 name,\n             }),\n             ResolutionError::ForwardDeclaredGenericParam => {\n-                self.session.create_err(errs::ForwardDeclaredGenericParam { span })\n+                self.tcx.sess.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n             ResolutionError::ParamInTyOfConstParam(name) => {\n-                self.session.create_err(errs::ParamInTyOfConstParam { span, name })\n+                self.tcx.sess.create_err(errs::ParamInTyOfConstParam { span, name })\n             }\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n-                self.session.create_err(errs::ParamInNonTrivialAnonConst {\n+                self.tcx.sess.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n                     name,\n                     sub_is_type: if is_type {\n@@ -874,13 +879,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n                     },\n                     help: self\n-                        .session\n+                        .tcx\n+                        .sess\n                         .is_nightly_build()\n                         .then_some(errs::ParamInNonTrivialAnonConstHelp),\n                 })\n             }\n             ResolutionError::SelfInGenericParamDefault => {\n-                self.session.create_err(errs::SelfInGenericParamDefault { span })\n+                self.tcx.sess.create_err(errs::SelfInGenericParamDefault { span })\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {\n                 let ((sub_suggestion_label, sub_suggestion), sub_unreachable_label) =\n@@ -908,7 +914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // No similarly-named labels exist.\n                         None => ((None, None), None),\n                     };\n-                self.session.create_err(errs::UnreachableLabel {\n+                self.tcx.sess.create_err(errs::UnreachableLabel {\n                     span,\n                     name,\n                     definition_span,\n@@ -924,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 trait_item_span,\n                 trait_path,\n             } => {\n-                let mut err = self.session.struct_span_err_with_code(\n+                let mut err = self.tcx.sess.struct_span_err_with_code(\n                     span,\n                     &format!(\n                         \"item `{}` is an associated {}, which doesn't match its trait `{}`\",\n@@ -937,9 +943,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::TraitImplDuplicate { span, name, trait_item_span, old_span }),\n-            ResolutionError::InvalidAsmSym => self.session.create_err(errs::InvalidAsmSym { span }),\n+            ResolutionError::InvalidAsmSym => {\n+                self.tcx.sess.create_err(errs::InvalidAsmSym { span })\n+            }\n         }\n     }\n \n@@ -949,7 +958,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n-                self.session.create_err(errs::Relative2018 {\n+                self.tcx.sess.create_err(errs::Relative2018 {\n                     span,\n                     path_span: path.span,\n                     // intentionally converting to String, as the text would also be used as\n@@ -958,18 +967,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             VisResolutionError::AncestorOnly(span) => {\n-                self.session.create_err(errs::AncestorOnly(span))\n+                self.tcx.sess.create_err(errs::AncestorOnly(span))\n             }\n             VisResolutionError::FailedToResolve(span, label, suggestion) => {\n                 self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n             }\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n-                self.session.create_err(errs::ExpectedFound { span, res, path_str })\n+                self.tcx.sess.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n             VisResolutionError::Indeterminate(span) => {\n-                self.session.create_err(errs::Indeterminate(span))\n+                self.tcx.sess.create_err(errs::Indeterminate(span))\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.tcx.sess.create_err(errs::ModuleOnly(span))\n             }\n-            VisResolutionError::ModuleOnly(span) => self.session.create_err(errs::ModuleOnly(span)),\n         }\n         .emit()\n     }\n@@ -1206,7 +1217,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs_untracked(did, this.session).any(\n+                                    && this.cstore().item_attrs_untracked(did, this.tcx.sess).any(\n                                         |attr| {\n                                             if attr.has_name(sym::rustc_diagnostic_item) {\n                                                 [sym::TryInto, sym::TryFrom, sym::FromIterator]\n@@ -1304,7 +1315,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                let crate_id = self.crate_loader().maybe_process_path_extern(ident.name);\n+                let crate_id = self.crate_loader(|c| c.maybe_process_path_extern(ident.name));\n                 if let Some(crate_id) = crate_id {\n                     let crate_root = self.expect_module(crate_id.as_def_id());\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n@@ -1341,8 +1352,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n-            &self.session,\n-            &self.untracked.source_span,\n+            &self.tcx.sess,\n+            &self.tcx.untracked().source_span.read(),\n             err,\n             None,\n             &import_suggestions,\n@@ -1366,7 +1377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n             && let Some(span) = self.opt_span(def_id)\n         {\n-            let source_map = self.session.source_map();\n+            let source_map = self.tcx.sess.source_map();\n             let head_span = source_map.guess_head_span(span);\n             if let Ok(head) = source_map.span_to_snippet(head_span) {\n                 err.span_suggestion(head_span, \"consider adding a derive\", format!(\"#[derive(Default)]\\n{head}\"), Applicability::MaybeIncorrect);\n@@ -1443,7 +1454,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n         let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n             LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(self.cstore().get_span_untracked(def_id, self.session)),\n+            _ => Some(self.cstore().get_span_untracked(def_id, self.tcx.sess)),\n         });\n         if let Some(def_span) = def_span {\n             if span.overlaps(def_span) {\n@@ -1473,7 +1484,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             };\n \n             err.span_label(\n-                self.session.source_map().guess_head_span(def_span),\n+                self.tcx.sess.source_map().guess_head_span(def_span),\n                 &format!(\n                     \"{}{} `{}` defined here\",\n                     prefix,\n@@ -1498,15 +1509,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         let res = b.res();\n-        if b.span.is_dummy() || !self.session.source_map().is_span_accessible(b.span) {\n+        if b.span.is_dummy() || !self.tcx.sess.source_map().is_span_accessible(b.span) {\n             // These already contain the \"built-in\" prefix or look bad with it.\n             let add_built_in =\n                 !matches!(b.res(), Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod);\n             let (built_in, from) = if from_prelude {\n                 (\"\", \" from prelude\")\n             } else if b.is_extern_crate()\n                 && !b.is_import()\n-                && self.session.opts.externs.get(ident.as_str()).is_some()\n+                && self.tcx.sess.opts.externs.get(ident.as_str()).is_some()\n             {\n                 (\"\", \" passed with `--extern`\")\n             } else if add_built_in {\n@@ -1532,7 +1543,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             (b1, b2, misc1, misc2, false)\n         };\n \n-        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{ident}` is ambiguous\");\n+        let mut err = struct_span_err!(self.tcx.sess, ident.span, E0659, \"`{ident}` is ambiguous\");\n         err.span_label(ident.span, \"ambiguous name\");\n         err.note(&format!(\"ambiguous because of {}\", kind.descr()));\n \n@@ -1604,7 +1615,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Print the primary message.\n         let descr = get_descr(binding);\n         let mut err =\n-            struct_span_err!(self.session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+            struct_span_err!(self.tcx.sess, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n         err.span_label(ident.span, &format!(\"private {}\", descr));\n         if let Some(span) = ctor_fields_span {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n@@ -1650,7 +1661,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 which = if first { \"\" } else { \" which\" },\n                 dots = if next_binding.is_some() { \"...\" } else { \"\" },\n             );\n-            let def_span = self.session.source_map().guess_head_span(binding.span);\n+            let def_span = self.tcx.sess.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis.is_public() {\n                 note_span.push_span_label(def_span, \"consider importing it directly\");\n@@ -1719,7 +1730,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     )),\n                 )\n-            } else if self.session.is_rust_2015() {\n+            } else if self.tcx.sess.is_rust_2015() {\n                 (\n                     format!(\"maybe a missing crate `{ident}`?\"),\n                     Some((\n@@ -1738,7 +1749,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let parent = match parent {\n                 // ::foo is mounted at the crate root for 2015, and is the extern\n                 // prelude for 2018+\n-                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                kw::PathRoot if self.tcx.sess.edition() > Edition::Edition2015 => {\n                     \"the list of imported crates\".to_owned()\n                 }\n                 kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n@@ -2079,7 +2090,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     import.span,\n                     import.use_span,\n                 );\n@@ -2098,7 +2109,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) =\n-                        extend_span_to_previous_binding(self.r.session, binding_span)\n+                        extend_span_to_previous_binding(self.r.tcx.sess, binding_span)\n                     {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -2116,7 +2127,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     module_name,\n                     import.use_span,\n                 );\n@@ -2125,7 +2136,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     has_nested, after_crate_name\n                 );\n \n-                let source_map = self.r.session.source_map();\n+                let source_map = self.r.tcx.sess.source_map();\n \n                 // Make sure this is actually crate-relative.\n                 let is_definitely_crate = import"}, {"sha": "7bd90d7e3455b7e365e165afd1c7d5cce64e01ac", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -1,4 +1,4 @@\n-use crate::{NameBinding, NameBindingKind, Resolver, ResolverTree};\n+use crate::{NameBinding, NameBindingKind, Resolver};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n@@ -7,8 +7,8 @@ use rustc_ast::EnumDef;\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility};\n-use rustc_middle::middle::privacy::{IntoDefIdTree, Level};\n use rustc_middle::ty::{DefIdTree, Visibility};\n use std::mem;\n \n@@ -67,13 +67,6 @@ impl Resolver<'_, '_> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> IntoDefIdTree for &'b mut Resolver<'a, 'tcx> {\n-    type Tree = &'b Resolver<'a, 'tcx>;\n-    fn tree(self) -> Self::Tree {\n-        self\n-    }\n-}\n-\n impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n@@ -107,11 +100,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n             let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n             if let Some(node_id) = import.id() {\n-                r.effective_visibilities.update_eff_vis(\n-                    r.local_def_id(node_id),\n-                    eff_vis,\n-                    ResolverTree(&r.untracked),\n-                )\n+                r.effective_visibilities.update_eff_vis(r.local_def_id(node_id), eff_vis, r.tcx)\n             }\n         }\n \n@@ -167,26 +156,28 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let nominal_vis = binding.vis.expect_local();\n         let private_vis = self.cheap_private_vis(parent_id);\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n+        let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n-            |r| (private_vis.unwrap_or_else(|| r.private_vis_import(binding)), r),\n+            || private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n-            &mut *self.r,\n+            tcx,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n         let private_vis = self.cheap_private_vis(parent_id);\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n+        let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            |r| (private_vis.unwrap_or_else(|| r.private_vis_def(def_id)), r),\n+            || private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),\n-            &mut *self.r,\n+            tcx,\n         );\n     }\n "}, {"sha": "ba7f04239c35fd822e998c719e8122f372a3d100", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                 is_type: true,\n                                             },\n                                         );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                        self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n                                     return Res::Err;\n@@ -1255,7 +1255,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         | ForwardGenericParamBanRibKind => continue,\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             is_type: false,\n                                         },\n                                     );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                 }\n \n                                 return Res::Err;\n@@ -1397,7 +1397,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == kw::PathRoot && ident.span.is_rust_2015() && self.session.rust_2018()\n+                    if name == kw::PathRoot\n+                        && ident.span.is_rust_2015()\n+                        && self.tcx.sess.rust_2018()\n                     {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n@@ -1494,7 +1496,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         record_segment_res(self, res);\n                     } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n-                            self.session\n+                            self.tcx\n+                                .sess\n                                 .struct_span_err(\n                                     ident.span,\n                                     \"cannot use a tool module through an import\","}, {"sha": "449d8094bd60a168042f3465137b3bb8001ef2aa", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n-        let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.r.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n             diag.note(note);\n@@ -548,8 +548,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if let Some(candidates) = &err.candidates {\n                 match &import.kind {\n                     ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n-                        self.r.session,\n-                        &self.r.untracked.source_span,\n+                        self.r.tcx.sess,\n+                        &self.r.tcx.untracked().source_span.read(),\n                         &mut diag,\n                         Some(err.span),\n                         &candidates,\n@@ -561,8 +561,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     ),\n                     ImportKind::Single { nested: true, source, target, .. } => {\n                         import_candidates(\n-                            self.r.session,\n-                            &self.r.untracked.source_span,\n+                            self.r.tcx.sess,\n+                            &self.r.tcx.untracked().source_span.read(),\n                             &mut diag,\n                             None,\n                             &candidates,\n@@ -658,7 +658,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     source_binding @ (Ok(..) | Err(Determined)) => {\n                         if source_binding.is_ok() {\n                             let msg = format!(\"`{}` is not directly importable\", target);\n-                            struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            struct_span_err!(this.tcx.sess, import.span, E0253, \"{}\", &msg)\n                                 .span_label(import.span, \"cannot be imported directly\")\n                                 .emit();\n                         }\n@@ -706,7 +706,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 } else if self.r.privacy_errors.is_empty() {\n                     let msg = \"cannot determine resolution for the import\";\n                     let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                    self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                    self.r.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n@@ -859,7 +859,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                             let msg = \"cannot determine resolution for the import\";\n                             let msg_note =\n                                 \"import resolution is stuck, try simplifying other imports\";\n-                            this.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                            this.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                         }\n                     }\n                     Err(..) => {\n@@ -1035,13 +1035,13 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         format!(\"re-export of private `{}`\", ident)\n                     };\n \n-                    struct_span_err!(self.r.session, import.span, E0365, \"{}\", error_msg)\n+                    struct_span_err!(self.r.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n                         .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n-                        struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n+                        struct_span_err!(self.r.tcx.sess, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n                         NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n@@ -1164,12 +1164,12 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n \n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n-            self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n+            self.r.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(import.span, \"items in traits are not importable\");\n+            self.r.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;"}, {"sha": "7df17376b3eaeb13a558e6c0d2a66ba2a340d22b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -682,7 +682,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n                 // This span will be used in case of elision failure.\n-                let span = self.r.session.source_map().start_point(ty.span);\n+                let span = self.r.tcx.sess.source_map().start_point(ty.span);\n                 self.resolve_elided_lifetime(ty.id, span);\n                 visit::walk_ty(self, ty);\n             }\n@@ -1571,7 +1571,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n                     };\n                     let mut diag = rustc_errors::struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         lifetime.ident.span,\n                         E0637,\n                         \"{}\",\n@@ -1748,7 +1748,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n                     LifetimeRibKind::AnonymousCreateParameter { report_in_path: true, .. } => {\n-                        let sess = self.r.session;\n+                        let sess = self.r.tcx.sess;\n                         let mut err = rustc_errors::struct_span_err!(\n                             sess,\n                             path_span,\n@@ -2194,7 +2194,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n                 if this.should_report_errs() {\n                     this.r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n                 }\n             };\n@@ -2438,7 +2439,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             if let GenericParamKind::Lifetime = param.kind\n                 && let Some(&original) = seen_lifetimes.get(&ident)\n             {\n-                diagnostics::signal_lifetime_shadowing(self.r.session, original, param.ident);\n+                diagnostics::signal_lifetime_shadowing(self.r.tcx.sess, original, param.ident);\n                 // Record lifetime res, so lowering knows there is something fishy.\n                 self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n@@ -2462,7 +2463,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::UnderscoreLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0637,\n                     \"`'_` cannot be used here\"\n@@ -2476,7 +2477,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::StaticLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0262,\n                     \"invalid lifetime parameter name: `{}`\",\n@@ -2506,7 +2507,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n                 NormalRibKind => {\n-                    if self.r.session.features_untracked().non_lifetime_binders {\n+                    if self.r.tcx.sess.features_untracked().non_lifetime_binders {\n                         Res::Def(def_kind, def_id.to_def_id())\n                     } else {\n                         Res::Err\n@@ -3384,7 +3385,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             Res::SelfCtor(_) => {\n                 // We resolve `Self` in pattern position as an ident sometimes during recovery,\n                 // so delay a bug instead of ICEing.\n-                self.r.session.delay_span_bug(\n+                self.r.tcx.sess.delay_span_bug(\n                     ident.span,\n                     \"unexpected `SelfCtor` in pattern, expected identifier\"\n                 );\n@@ -3664,7 +3665,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     #[inline]\n     /// If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n     fn should_report_errs(&self) -> bool {\n-        !(self.r.session.opts.actually_rustdoc && self.in_func_body)\n+        !(self.r.tcx.sess.opts.actually_rustdoc && self.in_func_body)\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n@@ -3829,7 +3830,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             }\n \n             if let Ok((_, orig_span)) = self.resolve_label(label.ident) {\n-                diagnostics::signal_label_shadowing(self.r.session, orig_span, label.ident)\n+                diagnostics::signal_label_shadowing(self.r.tcx.sess, orig_span, label.ident)\n             }\n \n             self.with_label_rib(NormalRibKind, |this| {\n@@ -4211,8 +4212,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 if let Some(res) = res\n                     && let Some(def_id) = res.opt_def_id()\n                     && !def_id.is_local()\n-                    && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n-                    && matches!(self.r.session.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n+                    && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n+                    && matches!(self.r.tcx.sess.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n                     // Encoding foreign def ids in proc macro crate metadata will ICE.\n                     return None;\n                 }\n@@ -4224,10 +4225,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn resolve_doc_links(&mut self, attrs: &[Attribute], maybe_exported: MaybeExported<'_>) {\n-        match self.r.session.opts.resolve_doc_links {\n+        match self.r.tcx.sess.opts.resolve_doc_links {\n             ResolveDocLinks::None => return,\n             ResolveDocLinks::ExportedMetadata\n-                if !self.r.session.crate_types().iter().copied().any(CrateType::has_metadata)\n+                if !self.r.tcx.sess.crate_types().iter().copied().any(CrateType::has_metadata)\n                     || !maybe_exported.eval(self.r) =>\n             {\n                 return;\n@@ -4281,9 +4282,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         .into_iter()\n                         .filter_map(|tr| {\n                             if !tr.def_id.is_local()\n-                                && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                                && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n                                 && matches!(\n-                                    self.r.session.opts.resolve_doc_links,\n+                                    self.r.tcx.sess.opts.resolve_doc_links,\n                                     ResolveDocLinks::ExportedMetadata\n                                 )\n                             {"}, {"sha": "36415936bdc6512820503cd2e9acdfe2a297b56b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -170,7 +170,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n             LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n+            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.tcx.sess)),\n         }\n     }\n \n@@ -200,7 +200,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     Res::Def(DefKind::Fn, _) => {\n                         // Verify whether this is a fn call or an Fn used as a type.\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .source_map()\n                             .span_to_snippet(span)\n                             .map(|snippet| snippet.ends_with(')'))\n@@ -255,7 +256,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 };\n                 (String::new(), \"this scope\".to_string(), suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n-                if self.r.session.edition() > Edition::Edition2015 {\n+                if self.r.tcx.sess.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n@@ -323,7 +324,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n-            self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+            self.r.tcx.sess.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n@@ -432,7 +433,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     } else {\n                         (\n                             self.r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .source_map()\n                                 .span_through_char(*fn_span, '(')\n                                 .shrink_to_hi(),\n@@ -505,7 +507,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 {\n                     if self\n                         .r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .parse_sess\n                         .type_ascription_path_suggestions\n                         .borrow()\n@@ -596,7 +599,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             if let Some((call_span, args_span)) = self.call_has_self_arg(source) {\n                 let mut args_snippet = String::new();\n                 if let Some(args_span) = args_span {\n-                    if let Ok(snippet) = self.r.session.source_map().span_to_snippet(args_span) {\n+                    if let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(args_span) {\n                         args_snippet = snippet;\n                     }\n                 }\n@@ -732,7 +735,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         let is_in_same_file = &|sp1, sp2| {\n-            let source_map = self.r.session.source_map();\n+            let source_map = self.r.tcx.sess.source_map();\n             let file1 = source_map.span_to_filename(sp1);\n             let file2 = source_map.span_to_filename(sp2);\n             file1 == file2\n@@ -895,7 +898,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                                 .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n                             (\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_through_char(span, '(')\n                                     .shrink_to_hi(),\n@@ -949,9 +953,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             && let PathSource::Trait(_) = source\n             && let Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)) = res\n             && let Ok(self_ty_str) =\n-                self.r.session.source_map().span_to_snippet(self_ty.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(self_ty.span)\n             && let Ok(trait_ref_str) =\n-                self.r.session.source_map().span_to_snippet(trait_ref.path.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(trait_ref.path.span)\n         {\n                 err.multipart_suggestion(\n                     \"`impl` items mention the trait being implemented first and the type it is being implemented for second\",\n@@ -1095,7 +1099,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             format!(\n                                 \"{}: {}<{} = {}>\",\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n                                     .unwrap_or_else(|_| constrain_ident.to_string()),\n@@ -1164,7 +1169,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         // parser issue where a struct literal is being used on an expression\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let sp = sm.span_look_ahead(span, None, Some(50));\n         let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n@@ -1212,7 +1217,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 true\n             } else if kind == DefKind::Struct\n             && let Some(lhs_source_span) = lhs_span.find_ancestor_inside(expr.span)\n-            && let Ok(snippet) = self.r.session.source_map().span_to_snippet(lhs_source_span)\n+            && let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(lhs_source_span)\n             {\n                 // The LHS is a type that originates from a macro call.\n                 // We have to add angle brackets around it.\n@@ -1352,11 +1357,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n-                if self.r.session.is_nightly_build() {\n+                if self.r.tcx.sess.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n                     if let Some(span) = self.def_span(def_id) {\n-                        if let Ok(snip) = self.r.session.source_map().span_to_snippet(span) {\n+                        if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n                             // The span contains a type alias so we should be able to\n                             // replace `type` with `trait`.\n                             let snip = snip.replacen(\"type\", \"trait\", 1);\n@@ -1387,7 +1392,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     .last()\n                     .map(|sp| {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .parse_sess\n                             .type_ascription_path_suggestions\n                             .borrow()\n@@ -1694,8 +1700,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n                                 self.r\n-                                    .crate_loader()\n-                                    .maybe_process_path_extern(ident.name)\n+                                    .crate_loader(|c| c.maybe_process_path_extern(ident.name))\n                                     .and_then(|crate_id| {\n                                         let crate_mod =\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n@@ -1774,12 +1779,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     /// Only used in a specific case of type ascription suggestions\n     fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         start.to(sm.next_point(start))\n     }\n \n     fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             if let Ok(snippet) = sm.span_to_snippet(sp) {\n@@ -1809,7 +1814,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             show_label = false;\n                             if !self\n                                 .r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .parse_sess\n                                 .type_ascription_path_suggestions\n                                 .borrow_mut()\n@@ -2272,7 +2278,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         debug_assert_ne!(lifetime_ref.ident.name, kw::UnderscoreLifetime);\n         let mut err = if let Some(outer) = outer_lifetime_ref {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0401,\n                 \"can't use generic parameters from outer item\",\n@@ -2282,7 +2288,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             err\n         } else {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n@@ -2340,8 +2346,13 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         );\n                         (span, sugg)\n                     } else {\n-                        let span =\n-                            self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n+                        let span = self\n+                            .r\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_through_char(span, '<')\n+                            .shrink_to_hi();\n                         let sugg = format!(\"{}, \", name.unwrap_or(\"'a\"));\n                         (span, sugg)\n                     };\n@@ -2375,7 +2386,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n         struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             lifetime_ref.ident.span,\n             E0771,\n             \"use of non-static lifetime `{}` in const generic\",\n@@ -2395,10 +2406,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         &self,\n         lifetime_ref: &ast::Lifetime,\n     ) {\n-        let feature_active = self.r.session.features_untracked().generic_const_exprs;\n+        let feature_active = self.r.tcx.sess.features_untracked().generic_const_exprs;\n         if !feature_active {\n             feature_err(\n-                &self.r.session.parse_sess,\n+                &self.r.tcx.sess.parse_sess,\n                 sym::generic_const_exprs,\n                 lifetime_ref.ident.span,\n                 \"a non-static lifetime is not allowed in a `const`\",\n@@ -2416,7 +2427,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n \n         let mut err = struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             spans,\n             E0106,\n             \"missing lifetime specifier{}\","}, {"sha": "66034baaa0b6b7a89b4ab2ad02b591763ca11291", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 56, "deletions": 85, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -27,26 +27,25 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::sync::{Lrc, RwLock};\n+use rustc_data_structures::sync::{Lrc, MappedReadGuard};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathData, Definitions};\n+use rustc_hir::definitions::DefPathData;\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n+use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, TyCtxt};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn, Untracked};\n+use rustc_session::cstore::CrateStore;\n use rustc_session::lint::LintBuffer;\n-use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -865,7 +864,7 @@ struct MacroData {\n ///\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a, 'tcx> {\n-    session: &'tcx Session,\n+    tcx: TyCtxt<'tcx>,\n \n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n@@ -956,9 +955,6 @@ pub struct Resolver<'a, 'tcx> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    local_crate_name: Symbol,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n-    untracked: Untracked,\n     used_extern_options: FxHashSet<Symbol>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n@@ -1117,27 +1113,10 @@ impl<'a, 'tcx> AsMut<Resolver<'a, 'tcx>> for Resolver<'a, 'tcx> {\n     }\n }\n \n-/// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n-/// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n-#[derive(Clone, Copy)]\n-struct ResolverTree<'a>(&'a Untracked);\n-\n-impl DefIdTree for ResolverTree<'_> {\n-    #[inline]\n-    fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        let ResolverTree(Untracked { definitions, cstore, .. }) = self;\n-        match id.as_local() {\n-            Some(id) => definitions.read().def_key(id).parent,\n-            None => cstore.as_any().downcast_ref::<CStore>().unwrap().def_key(id).parent,\n-        }\n-        .map(|index| DefId { index, ..id })\n-    }\n-}\n-\n impl<'a, 'b, 'tcx> DefIdTree for &'a Resolver<'b, 'tcx> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        ResolverTree(&self.untracked).opt_parent(id)\n+        self.tcx.opt_parent(id)\n     }\n }\n \n@@ -1164,10 +1143,11 @@ impl<'tcx> Resolver<'_, 'tcx> {\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.untracked.definitions.read().def_key(self.node_id_to_def_id[&node_id]),\n+            self.tcx.definitions_untracked().def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.untracked.definitions.write().create_def(parent, data);\n+        // FIXME: remove `def_span` body, pass in the right spans here and call `tcx.at().create_def()`\n+        let def_id = self.tcx.untracked().definitions.write().create_def(parent, data);\n \n         // Create the definition.\n         if expn_id != ExpnId::root() {\n@@ -1176,7 +1156,7 @@ impl<'tcx> Resolver<'_, 'tcx> {\n \n         // A relative span's parent must be an absolute span.\n         debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.untracked.source_span.push(span);\n+        let _id = self.tcx.untracked().source_span.write().push(span);\n         debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n@@ -1195,17 +1175,19 @@ impl<'tcx> Resolver<'_, 'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n         } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n+            self.cstore().item_generics_num_lifetimes(def_id, self.tcx.sess)\n         }\n     }\n+\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n }\n \n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub fn new(\n-        session: &'tcx Session,\n+        tcx: TyCtxt<'tcx>,\n         krate: &Crate,\n-        crate_name: Symbol,\n-        metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a, 'tcx> {\n         let root_def_id = CRATE_DEF_ID.to_def_id();\n@@ -1215,7 +1197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n             krate.spans.inner_span,\n-            session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            tcx.sess.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1227,8 +1209,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             &mut FxHashMap::default(),\n         );\n \n-        let definitions = Definitions::new(session.local_stable_crate_id());\n-\n         let mut visibilities = FxHashMap::default();\n         visibilities.insert(CRATE_DEF_ID, ty::Visibility::Public);\n \n@@ -1240,31 +1220,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut invocation_parents = FxHashMap::default();\n         invocation_parents.insert(LocalExpnId::ROOT, (CRATE_DEF_ID, ImplTraitContext::Existential));\n \n-        let mut source_span = IndexVec::default();\n-        let _id = source_span.push(krate.spans.inner_span);\n-        debug_assert_eq!(_id, CRATE_DEF_ID);\n-\n-        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n+        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = tcx\n+            .sess\n             .opts\n             .externs\n             .iter()\n             .filter(|(_, entry)| entry.add_prelude)\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !session.contains_name(&krate.attrs, sym::no_core) {\n+        if !tcx.sess.contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !session.contains_name(&krate.attrs, sym::no_std) {\n+            if !tcx.sess.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }\n \n-        let registered_tools = macros::registered_tools(session, &krate.attrs);\n+        let registered_tools = macros::registered_tools(tcx.sess, &krate.attrs);\n \n-        let features = session.features_untracked();\n+        let features = tcx.sess.features_untracked();\n \n         let mut resolver = Resolver {\n-            session,\n+            tcx,\n \n             expn_that_defined: Default::default(),\n \n@@ -1318,23 +1295,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            metadata_loader,\n-            local_crate_name: crate_name,\n             used_extern_options: Default::default(),\n-            untracked: Untracked {\n-                cstore: Box::new(CStore::new(session)),\n-                source_span,\n-                definitions: RwLock::new(definitions),\n-            },\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             builtin_macro_kinds: Default::default(),\n             registered_tools,\n             macro_use_prelude: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n-            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n-            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n-            non_macro_attr: Lrc::new(SyntaxExtension::non_macro_attr(session.edition())),\n+            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(tcx.sess.edition())),\n+            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(tcx.sess.edition())),\n+            non_macro_attr: Lrc::new(SyntaxExtension::non_macro_attr(tcx.sess.edition())),\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n             macro_rules_scopes: Default::default(),\n@@ -1430,7 +1400,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let effective_visibilities = self.effective_visibilities;\n-        let untracked = self.untracked;\n         let global_ctxt = ResolverGlobalCtxt {\n             expn_that_defined,\n             visibilities,\n@@ -1469,26 +1438,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n         };\n-        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n+        ResolverOutputs { global_ctxt, ast_lowering }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.untracked)\n+        StableHashingContext::new(self.tcx.sess, self.tcx.untracked())\n     }\n \n-    fn crate_loader(&mut self) -> CrateLoader<'_> {\n-        CrateLoader::new(\n-            &self.session,\n-            &*self.metadata_loader,\n-            self.local_crate_name,\n-            &mut *self.untracked.cstore.untracked_as_any().downcast_mut().unwrap(),\n-            self.untracked.definitions.read(),\n-            &mut self.used_extern_options,\n-        )\n+    fn crate_loader<T>(&mut self, f: impl FnOnce(&mut CrateLoader<'_, '_>) -> T) -> T {\n+        let mut cstore = self.tcx.untracked().cstore.write();\n+        let cstore = cstore.untracked_as_any().downcast_mut().unwrap();\n+        f(&mut CrateLoader::new(self.tcx, &mut *cstore, &mut self.used_extern_options))\n     }\n \n-    fn cstore(&self) -> &CStore {\n-        self.untracked.cstore.as_any().downcast_ref().unwrap()\n+    fn cstore(&self) -> MappedReadGuard<'_, CStore> {\n+        CStore::from_tcx(self.tcx)\n     }\n \n     fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n@@ -1521,18 +1485,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        self.session.time(\"resolve_crate\", || {\n-            self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n-            self.session.time(\"compute_effective_visibilities\", || {\n+        self.tcx.sess.time(\"resolve_crate\", || {\n+            self.tcx\n+                .sess\n+                .time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n-            self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n-            self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n-            self.session.time(\"resolve_main\", || self.resolve_main());\n-            self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n-            self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n-            self.session.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n+            self.tcx.sess.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n+            self.tcx.sess.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n+            self.tcx.sess.time(\"resolve_main\", || self.resolve_main());\n+            self.tcx.sess.time(\"resolve_check_unused\", || self.check_unused(krate));\n+            self.tcx.sess.time(\"resolve_report_errors\", || self.report_errors(krate));\n+            self.tcx\n+                .sess\n+                .time(\"resolve_postprocess\", || self.crate_loader(|c| c.postprocess(krate)));\n         });\n+\n+        // Make sure we don't mutate the cstore from here on.\n+        self.tcx.untracked().cstore.leak();\n     }\n \n     fn traits_in_scope(\n@@ -1871,10 +1842,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let crate_id = if finalize {\n                     let Some(crate_id) =\n-                        self.crate_loader().process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n+                        self.crate_loader(|c| c.process_path_extern(ident.name, ident.span)) else { return Some(self.dummy_binding); };\n                     crate_id\n                 } else {\n-                    self.crate_loader().maybe_process_path_extern(ident.name)?\n+                    self.crate_loader(|c| c.maybe_process_path_extern(ident.name))?\n                 };\n                 let crate_root = self.expect_module(crate_id.as_def_id());\n                 let vis = ty::Visibility::<LocalDefId>::Public;\n@@ -1922,14 +1893,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.untracked.source_span[def_id])\n+        def_id.as_local().map(|def_id| self.tcx.source_span(def_id))\n     }\n \n     /// Retrieves the name of the given `DefId`.\n     #[inline]\n     fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n         let def_key = match def_id.as_local() {\n-            Some(def_id) => self.untracked.definitions.read().def_key(def_id),\n+            Some(def_id) => self.tcx.definitions_untracked().def_key(def_id),\n             None => self.cstore().def_key(def_id),\n         };\n         def_key.get_opt_name()\n@@ -1961,7 +1932,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let attr = self\n                     .cstore()\n-                    .item_attrs_untracked(def_id, self.session)\n+                    .item_attrs_untracked(def_id, self.tcx.sess)\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {"}, {"sha": "341db774b4d3919a98979b2bda028d0742a94506", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -195,7 +195,8 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n \n     fn register_builtin_macro(&mut self, name: Symbol, ext: SyntaxExtensionKind) {\n         if self.builtin_macros.insert(name, BuiltinMacroState::NotYetSeen(ext)).is_some() {\n-            self.session\n+            self.tcx\n+                .sess\n                 .diagnostic()\n                 .bug(&format!(\"built-in macro `{}` was already registered\", name));\n         }\n@@ -216,7 +217,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n             ExpnData::allow_unstable(\n                 ExpnKind::AstPass(pass),\n                 call_site,\n-                self.session.edition(),\n+                self.tcx.sess.edition(),\n                 features.into(),\n                 None,\n                 parent_module,\n@@ -430,7 +431,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 PathResult::NonModule(..) |\n                 // HACK(Urgau): This shouldn't be necessary\n                 PathResult::Failed { is_error_from_last_segment: false, .. } => {\n-                    self.session\n+                    self.tcx.sess\n                         .struct_span_err(span, \"not sure whether the path is accessible or not\")\n                         .note(\"the type may have associated items, but we are currently not checking them\")\n                         .emit();\n@@ -455,7 +456,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     }\n \n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n-        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.tcx.sess)\n     }\n \n     fn declare_proc_macro(&mut self, id: NodeId) {\n@@ -493,10 +494,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Report errors for the resolved macro.\n         for segment in &path.segments {\n             if let Some(args) = &segment.args {\n-                self.session.span_err(args.span(), \"generic arguments in macro path\");\n+                self.tcx.sess.span_err(args.span(), \"generic arguments in macro path\");\n             }\n             if kind == MacroKind::Attr && segment.ident.as_str().starts_with(\"rustc\") {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     segment.ident.span,\n                     \"attributes starting with `rustc` are reserved for use by the `rustc` compiler\",\n                 );\n@@ -508,7 +509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def_id) = def_id.as_local() {\n                     self.unused_macros.remove(&def_id);\n                     if self.proc_macro_stubs.contains(&def_id) {\n-                        self.session.span_err(\n+                        self.tcx.sess.span_err(\n                             path.span,\n                             \"can't use a procedural macro from the same crate that defines it\",\n                         );\n@@ -540,7 +541,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n             let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n-            self.session\n+            self.tcx\n+                .sess\n                 .struct_span_err(path.span, &msg)\n                 .span_label(path.span, format!(\"not {} {}\", article, expected))\n                 .emit();\n@@ -550,18 +552,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We are trying to avoid reporting this error if other related errors were reported.\n         if res != Res::Err\n             && inner_attr\n-            && !self.session.features_untracked().custom_inner_attributes\n+            && !self.tcx.sess.features_untracked().custom_inner_attributes\n         {\n             let msg = match res {\n                 Res::Def(..) => \"inner macro attributes are unstable\",\n                 Res::NonMacroAttr(..) => \"custom inner attributes are unstable\",\n                 _ => unreachable!(),\n             };\n             if soft_custom_inner_attributes_gate {\n-                self.session.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n+                self.tcx.sess.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n             } else {\n-                feature_err(&self.session.parse_sess, sym::custom_inner_attributes, path.span, msg)\n-                    .emit();\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::custom_inner_attributes,\n+                    path.span,\n+                    msg,\n+                )\n+                .emit();\n             }\n         }\n \n@@ -655,7 +662,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n                     // situations should be reported as errors, so this is a bug.\n-                    this.session.delay_span_bug(span, \"inconsistent resolution for a macro\");\n+                    this.tcx.sess.delay_span_bug(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently\n@@ -672,7 +679,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Segment::names_to_string(path)\n                     );\n                     let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                    this.tcx.sess.struct_span_err(span, &msg).note(msg_note).emit();\n                 }\n             }\n         };\n@@ -699,7 +706,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // try to suggest if it's not a macro, maybe a function\n                         if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n                             && partial_res.unresolved_segments() == 0 {\n-                            let sm = self.session.source_map();\n+                            let sm = self.tcx.sess.source_map();\n                             let exclamation_span = sm.next_point(span);\n                             suggestion = Some((\n                                 vec![(exclamation_span, \"\".to_string())],\n@@ -762,7 +769,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(..) => {\n                     let expected = kind.descr_expected();\n                     let msg = format!(\"cannot find {} `{}` in this scope\", expected, ident);\n-                    let mut err = self.session.struct_span_err(ident.span, &msg);\n+                    let mut err = self.tcx.sess.struct_span_err(ident.span, &msg);\n                     self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n@@ -804,7 +811,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);\n                     stability::report_unstable(\n-                        self.session,\n+                        self.tcx.sess,\n                         feature,\n                         reason.to_opt_reason(),\n                         issue,\n@@ -840,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n                 let msg =\n                     format!(\"cannot use {} {} through an import\", kind.article(), kind.descr());\n-                let mut err = self.session.struct_span_err(span, &msg);\n+                let mut err = self.tcx.sess.struct_span_err(span, &msg);\n                 if let Some(binding) = binding {\n                     err.span_note(binding.span, &format!(\"the {} imported here\", kind.descr()));\n                 }\n@@ -855,7 +862,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n             let macro_kind = self.get_macro(res).map(|macro_data| macro_data.ext.macro_kind());\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     ident.span,\n                     &format!(\"name `{}` is reserved in attribute namespace\", ident),\n                 );\n@@ -871,12 +878,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         item: &ast::Item,\n         edition: Edition,\n     ) -> (SyntaxExtension, Vec<(usize, Span)>) {\n-        let (mut result, mut rule_spans) = compile_declarative_macro(\n-            &self.session,\n-            self.session.features_untracked(),\n-            item,\n-            edition,\n-        );\n+        let (mut result, mut rule_spans) = compile_declarative_macro(self.tcx.sess, item, edition);\n \n         if let Some(builtin_name) = result.builtin_name {\n             // The macro was marked with `#[rustc_builtin_macro]`.\n@@ -895,7 +897,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     BuiltinMacroState::AlreadySeen(span) => {\n                         struct_span_err!(\n-                            self.session,\n+                            self.tcx.sess,\n                             item.span,\n                             E0773,\n                             \"attempted to define built-in macro more than once\"\n@@ -906,7 +908,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n-                self.session.span_err(item.span, &msg);\n+                self.tcx.sess.span_err(item.span, &msg);\n             }\n         }\n "}, {"sha": "97aa930b5ec8e8b5422df3ae9d79b9d5a0d57ebd", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -200,12 +200,12 @@ pub enum ExternCrateSource {\n /// At the time of this writing, there is only one backend and one way to store\n /// metadata in library -- this trait just serves to decouple rustc_metadata from\n /// the archive reader, which depends on LLVM.\n-pub trait MetadataLoader {\n+pub trait MetadataLoader: std::fmt::Debug {\n     fn get_rlib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String>;\n     fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String>;\n }\n \n-pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n+pub type MetadataLoaderDyn = dyn MetadataLoader + Send + Sync;\n \n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n@@ -250,12 +250,12 @@ pub trait CrateStore: std::fmt::Debug {\n     fn import_source_files(&self, sess: &Session, cnum: CrateNum);\n }\n \n-pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n+pub type CrateStoreDyn = dyn CrateStore + sync::Sync + sync::Send;\n \n #[derive(Debug)]\n pub struct Untracked {\n-    pub cstore: Box<CrateStoreDyn>,\n+    pub cstore: RwLock<Box<CrateStoreDyn>>,\n     /// Reference span for definitions.\n-    pub source_span: IndexVec<LocalDefId, Span>,\n+    pub source_span: RwLock<IndexVec<LocalDefId, Span>>,\n     pub definitions: RwLock<Definitions>,\n }"}, {"sha": "580f70c974290ef84a59864358e8aac0f5d6dd1b", "filename": "tests/rustdoc-ui/bounded-hr-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -4,7 +4,5 @@ error: lifetime bounds cannot be used in this context\n LL |     for<'a: 'b + 'c> &'a (): std::fmt::Debug,\n    |             ^^   ^^\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "0864159c8e222b53fa1f9881f5a9982e34d44430", "filename": "tests/rustdoc-ui/feature-gate-doc_cfg_hide.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -7,8 +7,6 @@ LL | #![doc(cfg_hide(test))]\n    = note: see issue #43781 <https://github.com/rust-lang/rust/issues/43781> for more information\n    = help: add `#![feature(doc_cfg_hide)]` to the crate attributes to enable\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "c34ea0567a9d4f1430271e4da9199c7d562ee0eb", "filename": "tests/rustdoc-ui/feature-gate-rustdoc_missing_doc_code_examples.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -1,10 +1,12 @@\n #![deny(unknown_lints)]\n //~^ NOTE defined here\n-\n #![allow(rustdoc::missing_doc_code_examples)]\n //~^ ERROR unknown lint\n //~| ERROR unknown lint\n+//~| ERROR unknown lint\n+//~| NOTE lint is unstable\n //~| NOTE lint is unstable\n //~| NOTE lint is unstable\n //~| NOTE see issue\n //~| NOTE see issue\n+//~| NOTE see issue"}, {"sha": "326dcfe3bdef0d89e390bcdef6c8b286cbd7c08d", "filename": "tests/rustdoc-ui/feature-gate-rustdoc_missing_doc_code_examples.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -1,5 +1,5 @@\n error: unknown lint: `rustdoc::missing_doc_code_examples`\n-  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:4:1\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n    |\n LL | #![allow(rustdoc::missing_doc_code_examples)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -14,7 +14,7 @@ LL | #![deny(unknown_lints)]\n    |         ^^^^^^^^^^^^^\n \n error: unknown lint: `rustdoc::missing_doc_code_examples`\n-  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:4:1\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n    |\n LL | #![allow(rustdoc::missing_doc_code_examples)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +23,15 @@ LL | #![allow(rustdoc::missing_doc_code_examples)]\n    = note: see issue #101730 <https://github.com/rust-lang/rust/issues/101730> for more information\n    = help: add `#![feature(rustdoc_missing_doc_code_examples)]` to the crate attributes to enable\n \n-error: Compilation failed, aborting rustdoc\n+error: unknown lint: `rustdoc::missing_doc_code_examples`\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n+   |\n+LL | #![allow(rustdoc::missing_doc_code_examples)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `rustdoc::missing_doc_code_examples` lint is unstable\n+   = note: see issue #101730 <https://github.com/rust-lang/rust/issues/101730> for more information\n+   = help: add `#![feature(rustdoc_missing_doc_code_examples)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "75e6b4ed217ddb44eb7a44447754656fa8f28940", "filename": "tests/rustdoc-ui/impl-fn-nesting.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -58,9 +58,7 @@ error[E0412]: cannot find type `UnknownType` in this scope\n LL |             pub fn doubly_nested(c: UnknownType) {\n    |                                     ^^^^^^^^^^^ not found in this scope\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 10 previous errors\n \n Some errors have detailed explanations: E0405, E0412.\n For more information about an error, try `rustc --explain E0405`."}, {"sha": "14f560618521d73afc0b6bd179994fb33a57cc88", "filename": "tests/rustdoc-ui/intra-doc/unresolved-import-recovery.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -6,8 +6,6 @@ LL | use unresolved_crate::module::Name;\n    |\n    = help: consider adding `extern crate unresolved_crate` to use the `unresolved_crate` crate\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "d16ec6a853a5ca68da33ca341c170f9f3868c6b2", "filename": "tests/rustdoc-ui/issue-61732.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fissue-61732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Fissue-61732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-61732.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -6,8 +6,6 @@ LL | pub(in crate::r#mod) fn main() {}\n    |\n    = help: consider adding `extern crate r#mod` to use the `r#mod` crate\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "bf529b9f8e26327b6add65ba5a79f8d550afade4", "filename": "tests/rustdoc-ui/unknown-renamed-lints.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -58,7 +58,5 @@ error: unknown lint: `rustdoc::intra_doc_link_resolution_failure`\n LL | #![deny(rustdoc::intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "4bd4780e25f6b0e42fa58cb9e58c7b658144f949", "filename": "tests/ui/panics/default-backtrace-ice.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2deff71719a32af76eb4493ddb1dc4653fb88cad/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr?ref=2deff71719a32af76eb4493ddb1dc4653fb88cad", "patch": "@@ -13,4 +13,5 @@ error: the compiler unexpectedly panicked. this is a bug.\n \n \n query stack during panic:\n+#0 [resolver_for_lowering] getting the resolver for lowering\n end of query stack"}]}