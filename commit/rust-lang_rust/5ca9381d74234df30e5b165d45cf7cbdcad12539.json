{"sha": "5ca9381d74234df30e5b165d45cf7cbdcad12539", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTkzODFkNzQyMzRkZjMwZTViMTY1ZDQ1Y2Y3Y2JkY2FkMTI1Mzk=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-15T18:37:36Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-15T18:37:36Z"}, "message": "Adjust for unified enum variants and structs", "tree": {"sha": "1ab8fc68cfc201588501c8b3ce60305138a2f8c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab8fc68cfc201588501c8b3ce60305138a2f8c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca9381d74234df30e5b165d45cf7cbdcad12539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca9381d74234df30e5b165d45cf7cbdcad12539", "html_url": "https://github.com/rust-lang/rust/commit/5ca9381d74234df30e5b165d45cf7cbdcad12539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca9381d74234df30e5b165d45cf7cbdcad12539/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f04358e398ea0ebdc89e70299329e97da16133ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04358e398ea0ebdc89e70299329e97da16133ac", "html_url": "https://github.com/rust-lang/rust/commit/f04358e398ea0ebdc89e70299329e97da16133ac"}], "stats": {"total": 133, "additions": 66, "deletions": 67}, "files": [{"sha": "18b9118532c07ea553b10074a17cdde9c972f8e0", "filename": "src/items.rs", "status": "modified", "additions": 66, "deletions": 67, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5ca9381d74234df30e5b165d45cf7cbdcad12539/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca9381d74234df30e5b165d45cf7cbdcad12539/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=5ca9381d74234df30e5b165d45cf7cbdcad12539", "patch": "@@ -746,73 +746,74 @@ impl<'a> FmtVisitor<'a> {\n             result.push_str(&indent.to_string(self.config));\n         }\n \n-        let variant_body = match field.node.kind {\n-            ast::VariantKind::TupleVariantKind(ref types) => {\n+        let variant_body = match *field.node.data {\n+            ast::VariantData::Tuple(ref types, _) => {\n                 let mut result = field.node.name.to_string();\n+                let items = itemize_list(self.codemap,\n+                                         types.iter(),\n+                                         \")\",\n+                                         |arg| arg.node.ty.span.lo,\n+                                         |arg| arg.node.ty.span.hi,\n+                                         |arg| {\n+                                             // FIXME silly width, indent\n+                                             arg.node\n+                                                .ty\n+                                                .rewrite(&self.get_context(), 1000, Indent::empty())\n+                                         },\n+                                         span_after(field.span, \"(\", self.codemap),\n+                                         field.span.hi);\n+                let item_vec = items.collect::<Vec<_>>();\n \n-                if !types.is_empty() {\n-                    let items = itemize_list(self.codemap,\n-                                             types.iter(),\n-                                             \")\",\n-                                             |arg| arg.ty.span.lo,\n-                                             |arg| arg.ty.span.hi,\n-                                             |arg| {\n-                                                 // FIXME silly width, indent\n-                                                 arg.ty.rewrite(&self.get_context(),\n-                                                                1000,\n-                                                                Indent::empty())\n-                                             },\n-                                             span_after(field.span, \"(\", self.codemap),\n-                                             field.span.hi);\n-                    let item_vec = items.collect::<Vec<_>>();\n-\n-                    result.push('(');\n-\n-                    let indent = indent + field.node.name.to_string().len() + \"(\".len();\n-\n-                    let comma_cost = if self.config.enum_trailing_comma {\n-                        1\n-                    } else {\n-                        0\n-                    };\n-                    let budget = self.config.max_width - indent.width() - comma_cost - 1; // 1 = )\n-                    let tactic = definitive_tactic(&item_vec,\n-                                                   ListTactic::HorizontalVertical,\n-                                                   budget);\n-\n-                    let fmt = ListFormatting {\n-                        tactic: tactic,\n-                        separator: \",\",\n-                        trailing_separator: SeparatorTactic::Never,\n-                        indent: indent,\n-                        width: budget,\n-                        ends_with_newline: true,\n-                        config: self.config,\n-                    };\n-                    let list_str = try_opt!(write_list(&item_vec, &fmt));\n-\n-                    result.push_str(&list_str);\n-                    result.push(')');\n-                }\n+                result.push('(');\n \n-                if let Some(ref expr) = field.node.disr_expr {\n-                    result.push_str(\" = \");\n-                    let expr_snippet = self.snippet(expr.span);\n-                    result.push_str(&expr_snippet);\n-                }\n+                let indent = indent + field.node.name.to_string().len() + \"(\".len();\n+\n+                let comma_cost = if self.config.enum_trailing_comma {\n+                    1\n+                } else {\n+                    0\n+                };\n+                let budget = self.config.max_width - indent.width() - comma_cost - 1; // 1 = )\n+                let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, budget);\n+\n+                let fmt = ListFormatting {\n+                    tactic: tactic,\n+                    separator: \",\",\n+                    trailing_separator: SeparatorTactic::Never,\n+                    indent: indent,\n+                    width: budget,\n+                    ends_with_newline: true,\n+                    config: self.config,\n+                };\n+                let list_str = try_opt!(write_list(&item_vec, &fmt));\n+\n+                result.push_str(&list_str);\n+                result.push(')');\n \n                 Some(result)\n             }\n-            ast::VariantKind::StructVariantKind(ref struct_def) => {\n+            ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n                 self.format_struct(\"\",\n                                    field.node.name,\n                                    ast::Visibility::Inherited,\n-                                   struct_def,\n+                                   &*field.node.data,\n                                    None,\n                                    field.span,\n                                    indent)\n             }\n+            ast::VariantData::Unit(..) => {\n+                let tag = if let Some(ref expr) = field.node.disr_expr {\n+                    format!(\"{} = {}\", field.node.name, self.snippet(expr.span))\n+                } else {\n+                    field.node.name.to_string()\n+                };\n+\n+                wrap_str(tag,\n+                         self.config.max_width,\n+                         self.config.max_width - indent.width(),\n+                         indent)\n+            }\n         };\n \n         if let Some(variant_str) = variant_body {\n@@ -827,7 +828,7 @@ impl<'a> FmtVisitor<'a> {\n                      item_name: &str,\n                      ident: ast::Ident,\n                      vis: ast::Visibility,\n-                     struct_def: &ast::StructDef,\n+                     struct_def: &ast::VariantData,\n                      generics: Option<&ast::Generics>,\n                      span: Span,\n                      offset: Indent)\n@@ -837,14 +838,13 @@ impl<'a> FmtVisitor<'a> {\n         let header_str = self.format_header(item_name, ident, vis);\n         result.push_str(&header_str);\n \n-        if struct_def.fields.is_empty() {\n-            result.push(';');\n-            return Some(result);\n-        }\n-\n-        let is_tuple = match struct_def.fields[0].node.kind {\n-            ast::StructFieldKind::NamedField(..) => false,\n-            ast::StructFieldKind::UnnamedField(..) => true,\n+        let (is_tuple, fields) = match *struct_def {\n+            ast::VariantData::Unit(..) => {\n+                result.push(';');\n+                return Some(result);\n+            }\n+            ast::VariantData::Tuple(ref vec, _) => (true, vec),\n+            ast::VariantData::Struct(ref vec, _) => (false, vec),\n         };\n \n         let (opener, terminator) = if is_tuple {\n@@ -859,15 +859,14 @@ impl<'a> FmtVisitor<'a> {\n                                               opener,\n                                               offset,\n                                               offset + header_str.len(),\n-                                              codemap::mk_sp(span.lo,\n-                                                             struct_def.fields[0].span.lo)))\n+                                              codemap::mk_sp(span.lo, fields[0].span.lo)))\n             }\n             None => opener.to_owned(),\n         };\n         result.push_str(&generics_str);\n \n         let items = itemize_list(self.codemap,\n-                                 struct_def.fields.iter(),\n+                                 fields.iter(),\n                                  terminator,\n                                  |field| {\n                                      // Include attributes and doc comments, if present\n@@ -886,7 +885,7 @@ impl<'a> FmtVisitor<'a> {\n         let used_budget = offset.width() + header_str.len() + generics_str.len() + 3;\n \n         // Conservative approximation\n-        let single_line_cost = (span.hi - struct_def.fields[0].span.lo).0;\n+        let single_line_cost = (span.hi - fields[0].span.lo).0;\n         let break_line = !is_tuple || generics_str.contains('\\n') ||\n                          single_line_cost as usize + used_budget > self.config.max_width;\n \n@@ -932,7 +931,7 @@ impl<'a> FmtVisitor<'a> {\n     pub fn visit_struct(&mut self,\n                         ident: ast::Ident,\n                         vis: ast::Visibility,\n-                        struct_def: &ast::StructDef,\n+                        struct_def: &ast::VariantData,\n                         generics: &ast::Generics,\n                         span: Span) {\n         let indent = self.block_indent;"}]}