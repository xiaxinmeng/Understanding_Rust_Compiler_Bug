{"sha": "973da22ea3d8074d8ce1214f7a356e96efe4131a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3M2RhMjJlYTNkODA3NGQ4Y2UxMjE0ZjdhMzU2ZTk2ZWZlNDEzMWE=", "commit": {"author": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-15T18:49:04Z"}, "committer": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-20T01:08:53Z"}, "message": "Wrapped inferred context changes in a probe, handle fnOnce trait require error with a fallback, renamed variable to something clearer", "tree": {"sha": "22a5761fca36951803a55f9b98b350e6e692e793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22a5761fca36951803a55f9b98b350e6e692e793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/973da22ea3d8074d8ce1214f7a356e96efe4131a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/973da22ea3d8074d8ce1214f7a356e96efe4131a", "html_url": "https://github.com/rust-lang/rust/commit/973da22ea3d8074d8ce1214f7a356e96efe4131a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/973da22ea3d8074d8ce1214f7a356e96efe4131a/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a0b0eece9e3ac852413bc715f788261a217e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a0b0eece9e3ac852413bc715f788261a217e74", "html_url": "https://github.com/rust-lang/rust/commit/c8a0b0eece9e3ac852413bc715f788261a217e74"}], "stats": {"total": 63, "additions": 36, "deletions": 27}, "files": [{"sha": "a61985d3a00f628a380247279236da231a4037ee", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/973da22ea3d8074d8ce1214f7a356e96efe4131a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973da22ea3d8074d8ce1214f7a356e96efe4131a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=973da22ea3d8074d8ce1214f7a356e96efe4131a", "patch": "@@ -73,40 +73,49 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         // snippet\n                     };\n \n-                    fn span_stored_function() {\n-                        cx.sess.span_note(span, &format!(\"use `({0}.{1})(...)` if you meant to call \\\n-                                                          the function stored in the `{1}` field\",\n-                                                         expr_string, item_name));\n-                    }\n+                    macro_rules! span_stored_function {\n+                        () => {\n+                            cx.sess.span_note(span,\n+                                              &format!(\"use `({0}.{1})(...)` if you meant to call \\\n+                                                        the function stored in the `{1}` field\",\n+                                                       expr_string, item_name));\n+                        }\n+                    };\n \n-                    fn span_did_you_mean() {\n-                        cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n-                                                         expr_string, item_name));\n-                    }\n+                    macro_rules! span_did_you_mean {\n+                        () => {\n+                            cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                             expr_string, item_name));\n+                        }\n+                    };\n \n                     // Determine if the field can be used as a function in some way\n                     let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n-                        let fn_once_substs = Substs::new_trait(vec![fcx.inh.infcx.next_ty_var()],\n-                                                               Vec::new(),\n-                                                               field_ty);\n-                        let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n-                                                          cx.mk_substs(fn_once_substs));\n-                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                        let obligation = Obligation::misc(span,\n-                                                          fcx.body_id,\n-                                                          poly_trait_ref.as_predicate());\n-                        let mut selcx = SelectionContext::new(fcx.infcx(), fcx);\n-\n-                        if selcx.evaluate_obligation(&obligation) {\n-                            span_stored_function();\n-                        } else {\n-                            span_did_you_mean();\n-                        }\n+                        let infcx = fcx.infcx();\n+                        infcx.probe(|_| {\n+                            let fn_once_substs = Substs::new_trait(vec![infcx.next_ty_var()],\n+                                                                   Vec::new(),\n+                                                                   field_ty);\n+                            let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                              cx.mk_substs(fn_once_substs));\n+                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                            let obligation = Obligation::misc(span,\n+                                                              fcx.body_id,\n+                                                              poly_trait_ref.as_predicate());\n+                            let mut selcx = SelectionContext::new(infcx, fcx);\n+\n+                            if selcx.evaluate_obligation(&obligation) {\n+                                span_stored_function!();\n+                            } else {\n+                                span_did_you_mean!();\n+                            }\n+                        });\n                     } else {\n                         match field_ty.sty {\n-                            ty::TyClosure(_,_) | ty::TyFnPtr(_,_) => span_stored_function(),\n-                            _ => span_did_you_mean(),\n+                            // fallback to matching a closure or function pointer\n+                            ty::TyClosure(_,_) | ty::TyBareFn(None,_) => span_stored_function!(),\n+                            _ => span_did_you_mean!(),\n                         }\n                     }\n                 }"}]}