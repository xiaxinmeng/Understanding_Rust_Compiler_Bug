{"sha": "c30dcff97a43292b729f384f847febe777daf629", "node_id": "C_kwDOAAsO6NoAKGMzMGRjZmY5N2E0MzI5MmI3MjlmMzg0Zjg0N2ZlYmU3NzdkYWY2Mjk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-07T13:21:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-07T13:21:47Z"}, "message": "review feedback", "tree": {"sha": "53eaf49f128d36d04faa3838d5947c1dc49b33f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53eaf49f128d36d04faa3838d5947c1dc49b33f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c30dcff97a43292b729f384f847febe777daf629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c30dcff97a43292b729f384f847febe777daf629", "html_url": "https://github.com/rust-lang/rust/commit/c30dcff97a43292b729f384f847febe777daf629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c30dcff97a43292b729f384f847febe777daf629/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "595e192274b581e3a3a938c84eb128fa8c20c60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/595e192274b581e3a3a938c84eb128fa8c20c60d", "html_url": "https://github.com/rust-lang/rust/commit/595e192274b581e3a3a938c84eb128fa8c20c60d"}], "stats": {"total": 85, "additions": 43, "deletions": 42}, "files": [{"sha": "e35145c4ade48dc6538aca96c46deb126edaea48", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c30dcff97a43292b729f384f847febe777daf629/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c30dcff97a43292b729f384f847febe777daf629/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=c30dcff97a43292b729f384f847febe777daf629", "patch": "@@ -1992,6 +1992,7 @@ mod type_keyword {}\n /// ```rust\n /// # #![allow(dead_code)]\n /// #![deny(unsafe_op_in_unsafe_fn)]\n+///\n /// /// Dereference the given pointer.\n /// ///\n /// /// # Safety\n@@ -2020,22 +2021,22 @@ mod type_keyword {}\n /// ///\n /// /// `make_even` must return an even number.\n /// unsafe trait MakeEven {\n-///   fn make_even(&self) -> i32;\n+///     fn make_even(&self) -> i32;\n /// }\n ///\n /// // SAFETY: Our `make_even` always returns something even.\n /// unsafe impl MakeEven for i32 {\n-///   fn make_even(&self) -> i32 {\n-///     self << 1\n-///   }\n+///     fn make_even(&self) -> i32 {\n+///         self << 1\n+///     }\n /// }\n ///\n /// fn use_make_even(x: impl MakeEven) {\n-///   if x.make_even() % 2 == 1 {\n-///     // SAFETY: this can never happen, because all `MakeEven` implementations\n-///     // ensure that `make_even` returns something even.\n-///     unsafe { std::hint::unreachable_unchecked() };\n-///   }\n+///     if x.make_even() % 2 == 1 {\n+///         // SAFETY: this can never happen, because all `MakeEven` implementations\n+///         // ensure that `make_even` returns something even.\n+///         unsafe { std::hint::unreachable_unchecked() };\n+///     }\n /// }\n /// ```\n ///\n@@ -2053,55 +2054,55 @@ mod type_keyword {}\n /// #![deny(unsafe_op_in_unsafe_fn)]\n ///\n /// trait Indexable {\n-///   const LEN: usize;\n+///     const LEN: usize;\n ///\n-///   /// # Safety\n-///   ///\n-///   /// The caller must ensure that `idx < LEN`.\n-///   unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n+///     /// # Safety\n+///     ///\n+///     /// The caller must ensure that `idx < LEN`.\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32;\n /// }\n ///\n /// // The implementation for `i32` doesn't need to do any contract reasoning.\n /// impl Indexable for i32 {\n-///   const LEN: usize = 1;\n+///     const LEN: usize = 1;\n ///\n-///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n-///     debug_assert_eq!(idx, 0);\n-///     *self\n-///   }\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         debug_assert_eq!(idx, 0);\n+///         *self\n+///     }\n /// }\n ///\n /// // The implementation for arrays exploits the function contract to\n /// // make use of `get_unchecked` on slices and avoid a run-time check.\n /// impl Indexable for [i32; 42] {\n-///   const LEN: usize = 42;\n+///     const LEN: usize = 42;\n ///\n-///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n-///     // SAFETY: As per this trait's documentation, the caller ensures\n-///     // that `idx < 42`.\n-///     unsafe { *self.get_unchecked(idx) }\n-///   }\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 42`.\n+///         unsafe { *self.get_unchecked(idx) }\n+///     }\n /// }\n ///\n /// // The implementation for the never type declares a length of 0,\n /// // which means `idx_unchecked` can never be called.\n /// impl Indexable for ! {\n-///   const LEN: usize = 0;\n+///     const LEN: usize = 0;\n ///\n-///   unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n-///     // SAFETY: As per this trait's documentation, the caller ensures\n-///     // that `idx < 0`, which is impossible, so this is dead code.\n-///     unsafe { std::hint::unreachable_unchecked() }\n-///   }\n+///     unsafe fn idx_unchecked(&self, idx: usize) -> i32 {\n+///         // SAFETY: As per this trait's documentation, the caller ensures\n+///         // that `idx < 0`, which is impossible, so this is dead code.\n+///         unsafe { std::hint::unreachable_unchecked() }\n+///     }\n /// }\n ///\n /// fn use_indexable<I: Indexable>(x: I, idx: usize) -> i32 {\n-///   if idx < I::LEN {\n-///     // SAFETY: We have checked that `idx < I::LEN`.\n-///     unsafe { x.idx_unchecked(idx) }\n-///   } else {\n-///     panic!(\"index out-of-bounds\")\n-///   }\n+///     if idx < I::LEN {\n+///         // SAFETY: We have checked that `idx < I::LEN`.\n+///         unsafe { x.idx_unchecked(idx) }\n+///     } else {\n+///         panic!(\"index out-of-bounds\")\n+///     }\n /// }\n /// ```\n ///\n@@ -2115,11 +2116,11 @@ mod type_keyword {}\n /// is not implicitly an unsafe block.) For that purpose it can make use of the contract that all\n /// its callers must uphold -- the fact that `idx < LEN`.\n ///\n-/// Formally speaking, an `unsafe fn` in a trait is a function with extra\n-/// *preconditions* (such as `idx < LEN`), whereas an `unsafe trait` can declare\n-/// that some of its functions have extra *postconditions* (such as returning an\n-/// even integer). If a trait needs a function with both extra precondition and\n-/// extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.\n+/// Formally speaking, an `unsafe fn` in a trait is a function with *preconditions* that go beyond\n+/// those encoded by the argument types (such as `idx < LEN`), whereas an `unsafe trait` can declare\n+/// that some of its functions have *postconditions* that go beyond those encoded in the return type\n+/// (such as returning an even integer). If a trait needs a function with both extra precondition\n+/// and extra postcondition, then it needs an `unsafe fn` in an `unsafe trait`.\n ///\n /// [`extern`]: keyword.extern.html\n /// [`trait`]: keyword.trait.html"}]}