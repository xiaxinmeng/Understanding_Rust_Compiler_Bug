{"sha": "5156fbdc74cbf9902a96bafd27775f4764d5bfde", "node_id": "C_kwDOAAsO6NoAKDUxNTZmYmRjNzRjYmY5OTAyYTk2YmFmZDI3Nzc1ZjQ3NjRkNWJmZGU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-09T21:31:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-09T21:31:56Z"}, "message": "Rollup merge of #105453 - scottmcm:vecdeque_from_iter, r=the8472\n\nMake `VecDeque::from_iter` O(1) from `vec(_deque)::IntoIter`\n\nAs suggested in https://github.com/rust-lang/rust/pull/105046#issuecomment-1330371695 by\nr? ``@the8472``\n\n`Vec` & `VecDeque`'s `IntoIter`s own the allocations, and even if advanced can be turned into `VecDeque`s in O(1).\n\nThis is just a specialization, not an API or doc commitment, so I don't think it needs an FCP.", "tree": {"sha": "30555bb7714e26c66e1334ca6739ce4f90811a4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30555bb7714e26c66e1334ca6739ce4f90811a4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5156fbdc74cbf9902a96bafd27775f4764d5bfde", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjk6lMCRBK7hj4Ov3rIwAAX+QIAHiytGjHqO/q4vxOTyGUYNLs\nYfQSLEvrS1fQtcSQ2eWcY1hdj+8WGcG83OFIuNWLbNuQU4ySh7HEBhcgHZFfWMhO\n9OU10uqwDWoB/6i3HTJaKGnn46LqIg3JEMKofbPQ+c1+bSX3R81YjD2h6r9l3WCF\nHe+Ed2xSmZi1K+v8MJ9eBEK7D9+nh4GYeMbuBDHgGb5IhhC4F//O+QqTA2F/Azhj\nsyQpXdVngsEobYyzAvFIb9ZEOSHccinLNoRx/8ciMewWuOAPaWYcorR7P5rjU4AD\nLCRX2MjENLeIF9fLPMclO2zPYdcQRdC6gfrWM0wc7657OWFptME55hvyIHJtN9I=\n=mXE3\n-----END PGP SIGNATURE-----\n", "payload": "tree 30555bb7714e26c66e1334ca6739ce4f90811a4a\nparent c44326e8b5b42be207d12713d594660d0f19c739\nparent 6648134434fe4ac69132852e6d58f15578bfc022\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670621516 +0100\ncommitter GitHub <noreply@github.com> 1670621516 +0100\n\nRollup merge of #105453 - scottmcm:vecdeque_from_iter, r=the8472\n\nMake `VecDeque::from_iter` O(1) from `vec(_deque)::IntoIter`\n\nAs suggested in https://github.com/rust-lang/rust/pull/105046#issuecomment-1330371695 by\nr? ``@the8472``\n\n`Vec` & `VecDeque`'s `IntoIter`s own the allocations, and even if advanced can be turned into `VecDeque`s in O(1).\n\nThis is just a specialization, not an API or doc commitment, so I don't think it needs an FCP.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5156fbdc74cbf9902a96bafd27775f4764d5bfde", "html_url": "https://github.com/rust-lang/rust/commit/5156fbdc74cbf9902a96bafd27775f4764d5bfde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5156fbdc74cbf9902a96bafd27775f4764d5bfde/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c44326e8b5b42be207d12713d594660d0f19c739", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44326e8b5b42be207d12713d594660d0f19c739", "html_url": "https://github.com/rust-lang/rust/commit/c44326e8b5b42be207d12713d594660d0f19c739"}, {"sha": "6648134434fe4ac69132852e6d58f15578bfc022", "url": "https://api.github.com/repos/rust-lang/rust/commits/6648134434fe4ac69132852e6d58f15578bfc022", "html_url": "https://github.com/rust-lang/rust/commit/6648134434fe4ac69132852e6d58f15578bfc022"}], "stats": {"total": 150, "additions": 139, "deletions": 11}, "files": [{"sha": "e54880e8652305b7f173d08f48aae0b18276212d", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=5156fbdc74cbf9902a96bafd27775f4764d5bfde", "patch": "@@ -25,6 +25,10 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(super) fn new(inner: VecDeque<T, A>) -> Self {\n         IntoIter { inner }\n     }\n+\n+    pub(super) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        self.inner\n+    }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]"}, {"sha": "4b9bd74d3924f49a93abb03a3e56b645566de6cf", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=5156fbdc74cbf9902a96bafd27775f4764d5bfde", "patch": "@@ -55,6 +55,10 @@ use self::spec_extend::SpecExtend;\n \n mod spec_extend;\n \n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -586,6 +590,38 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }\n     }\n \n+    /// Creates a `VecDeque` from a raw allocation, when the initialized\n+    /// part of that allocation forms a *contiguous* subslice thereof.\n+    ///\n+    /// For use by `vec::IntoIter::into_vecdeque`\n+    ///\n+    /// # Safety\n+    ///\n+    /// All the usual requirements on the allocated memory like in\n+    /// `Vec::from_raw_parts_in`, but takes a *range* of elements that are\n+    /// initialized rather than only supporting `0..len`.  Requires that\n+    /// `initialized.start` \u2264 `initialized.end` \u2264 `capacity`.\n+    #[inline]\n+    pub(crate) unsafe fn from_contiguous_raw_parts_in(\n+        ptr: *mut T,\n+        initialized: Range<usize>,\n+        capacity: usize,\n+        alloc: A,\n+    ) -> Self {\n+        debug_assert!(initialized.start <= initialized.end);\n+        debug_assert!(initialized.end <= capacity);\n+\n+        // SAFETY: Our safety precondition guarantees the range length won't wrap,\n+        // and that the allocation is valid for use in `RawVec`.\n+        unsafe {\n+            VecDeque {\n+                head: initialized.start,\n+                len: initialized.end.unchecked_sub(initialized.start),\n+                buf: RawVec::from_raw_parts_in(ptr, capacity, alloc),\n+            }\n+        }\n+    }\n+\n     /// Provides a reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n@@ -2699,18 +2735,8 @@ impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for VecDeque<T> {\n-    #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n-        // Since converting is O(1) now, might as well re-use that logic\n-        // (including things like the `vec::IntoIter`\u2192`Vec` specialization)\n-        // especially as that could save us some monomorphiziation work\n-        // if one uses the same iterators (like slice ones) with both.\n-        return from_iter_via_vec(iter.into_iter());\n-\n-        #[inline]\n-        fn from_iter_via_vec<U>(iter: impl Iterator<Item = U>) -> VecDeque<U> {\n-            Vec::from_iter(iter).into()\n-        }\n+        SpecFromIter::spec_from_iter(iter.into_iter())\n     }\n }\n "}, {"sha": "7650492ebdad1500c4167bfcc69f6f53998bb35c", "filename": "library/alloc/src/collections/vec_deque/spec_from_iter.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs?ref=5156fbdc74cbf9902a96bafd27775f4764d5bfde", "patch": "@@ -0,0 +1,33 @@\n+use super::{IntoIter, VecDeque};\n+\n+/// Specialization trait used for `VecDeque::from_iter`\n+pub(super) trait SpecFromIter<T, I> {\n+    fn spec_from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for VecDeque<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_from_iter(iterator: I) -> Self {\n+        // Since converting is O(1) now, just re-use the `Vec` logic for\n+        // anything where we can't do something extra-special for `VecDeque`,\n+        // especially as that could save us some monomorphiziation work\n+        // if one uses the same iterators (like slice ones) with both.\n+        crate::vec::Vec::from_iter(iterator).into()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, crate::vec::IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: crate::vec::IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}"}, {"sha": "6bcde6d899ce81776fe8dc55c20d528daec84472", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=5156fbdc74cbf9902a96bafd27775f4764d5bfde", "patch": "@@ -1,6 +1,8 @@\n #[cfg(not(no_global_oom_handling))]\n use super::AsVecIntoIter;\n use crate::alloc::{Allocator, Global};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::collections::VecDeque;\n use crate::raw_vec::RawVec;\n use core::array;\n use core::fmt;\n@@ -132,6 +134,33 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(crate) fn forget_remaining_elements(&mut self) {\n         self.ptr = self.end;\n     }\n+\n+    #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n+    pub(crate) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        // Keep our `Drop` impl from dropping the elements and the allocator\n+        let mut this = ManuallyDrop::new(self);\n+\n+        // SAFETY: This allocation originally came from a `Vec`, so it passes\n+        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n+        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // Taking `alloc` is ok because nothing else is going to look at it,\n+        // since our `Drop` impl isn't going to run so there's no more code.\n+        unsafe {\n+            let buf = this.buf.as_ptr();\n+            let initialized = if T::IS_ZST {\n+                // All the pointers are the same for ZSTs, so it's fine to\n+                // say that they're all at the beginning of the \"allocation\".\n+                0..this.len()\n+            } else {\n+                this.ptr.sub_ptr(buf)..this.end.sub_ptr(buf)\n+            };\n+            let cap = this.cap;\n+            let alloc = ManuallyDrop::take(&mut this.alloc);\n+            VecDeque::from_contiguous_raw_parts_in(buf, initialized, cap, alloc)\n+        }\n+    }\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]"}, {"sha": "0b8f5281b785cab4af103238d5125bc1660f358c", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156fbdc74cbf9902a96bafd27775f4764d5bfde/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=5156fbdc74cbf9902a96bafd27775f4764d5bfde", "patch": "@@ -1736,3 +1736,39 @@ fn test_resize_keeps_reserved_space_from_item() {\n     d.resize(1, v);\n     assert_eq!(d[0].capacity(), 1234);\n }\n+\n+#[test]\n+fn test_collect_from_into_iter_keeps_allocation() {\n+    let mut v = Vec::with_capacity(13);\n+    v.extend(0..7);\n+    check(v.as_ptr(), v.last().unwrap(), v.into_iter());\n+\n+    let mut v = VecDeque::with_capacity(13);\n+    v.extend(0..7);\n+    check(&v[0], &v[v.len() - 1], v.into_iter());\n+\n+    fn check(buf: *const i32, last: *const i32, mut it: impl Iterator<Item = i32>) {\n+        assert_eq!(it.next(), Some(0));\n+        assert_eq!(it.next(), Some(1));\n+\n+        let mut v: VecDeque<i32> = it.collect();\n+        assert_eq!(v.capacity(), 13);\n+        assert_eq!(v.as_slices().0.as_ptr(), buf.wrapping_add(2));\n+        assert_eq!(&v[v.len() - 1] as *const _, last);\n+\n+        assert_eq!(v.as_slices(), ([2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(7);\n+        assert_eq!(v.as_slices(), ([7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(8);\n+        assert_eq!(v.as_slices(), ([8, 7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+\n+        // Now that we've adding thing in place of the two that we removed from\n+        // the front of the iterator, we're back to matching the buffer pointer.\n+        assert_eq!(v.as_slices().0.as_ptr(), buf);\n+        assert_eq!(&v[v.len() - 1] as *const _, last);\n+\n+        v.push_front(9);\n+        assert_eq!(v.as_slices(), ([9].as_slice(), [8, 7, 2, 3, 4, 5, 6].as_slice()));\n+        assert_eq!(v.capacity(), 13);\n+    }\n+}"}]}