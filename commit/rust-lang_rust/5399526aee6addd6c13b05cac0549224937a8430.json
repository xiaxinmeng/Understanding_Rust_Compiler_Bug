{"sha": "5399526aee6addd6c13b05cac0549224937a8430", "node_id": "C_kwDOAAsO6NoAKDUzOTk1MjZhZWU2YWRkZDZjMTNiMDVjYWMwNTQ5MjI0OTM3YTg0MzA", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-28T10:43:51Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-11-26T19:35:32Z"}, "message": "Rewrite LLVM's archive writer in Rust\n\nThis allows it to be used by other codegen backends", "tree": {"sha": "fc74ee1efde51522a3a45cc710f1723290cf5f56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc74ee1efde51522a3a45cc710f1723290cf5f56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5399526aee6addd6c13b05cac0549224937a8430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5399526aee6addd6c13b05cac0549224937a8430", "html_url": "https://github.com/rust-lang/rust/commit/5399526aee6addd6c13b05cac0549224937a8430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5399526aee6addd6c13b05cac0549224937a8430/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "982798faa761cba750b4fd1dde6d412d8d65ab00", "url": "https://api.github.com/repos/rust-lang/rust/commits/982798faa761cba750b4fd1dde6d412d8d65ab00", "html_url": "https://github.com/rust-lang/rust/commit/982798faa761cba750b4fd1dde6d412d8d65ab00"}], "stats": {"total": 231, "additions": 5, "deletions": 226}, "files": [{"sha": "3b406036c356e9e3023964f049184a2d1f0121f5", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5399526aee6addd6c13b05cac0549224937a8430/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5399526aee6addd6c13b05cac0549224937a8430/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5399526aee6addd6c13b05cac0549224937a8430", "patch": "@@ -19,11 +19,6 @@ version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.7.2\"\n@@ -324,7 +319,6 @@ dependencies = [\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"cranelift-codegen\",\n  \"cranelift-frontend\",\n  \"cranelift-jit\","}, {"sha": "0fdd5de118ccb10cb4db0776c5ca9c69b19cc07f", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5399526aee6addd6c13b05cac0549224937a8430/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5399526aee6addd6c13b05cac0549224937a8430/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=5399526aee6addd6c13b05cac0549224937a8430", "patch": "@@ -18,7 +18,6 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\""}, {"sha": "5a29bc18def549cd035bb0a1144b5cab54addef4", "filename": "src/archive.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5399526aee6addd6c13b05cac0549224937a8430/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5399526aee6addd6c13b05cac0549224937a8430/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=5399526aee6addd6c13b05cac0549224937a8430", "patch": "@@ -1,35 +1,15 @@\n-//! Creation of ar archives like for the lib and staticlib crate type\n-\n-use std::collections::BTreeMap;\n-use std::fs::File;\n-use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n-use object::read::archive::ArchiveFile;\n-use object::{Object, ObjectSymbol, ReadCache};\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive { archive_index: usize, file_range: (u64, u64) },\n-    File(PathBuf),\n-}\n-\n pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        Box::new(ArArchiveBuilder {\n-            sess,\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -40,200 +20,6 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _tmpdir: &Path,\n         _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n-}\n-\n-pub(crate) struct ArArchiveBuilder<'a> {\n-    sess: &'a Session,\n-    use_gnu_style_archive: bool,\n-    no_builtin_ranlib: bool,\n-\n-    src_archives: Vec<File>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(Vec<u8>, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n-        let archive = ArchiveFile::parse(&read_cache).unwrap();\n-        let archive_index = self.src_archives.len();\n-\n-        for entry in archive.members() {\n-            let entry = entry.map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            let file_name = String::from_utf8(entry.name().to_vec())\n-                .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n-                ));\n-            }\n-        }\n-\n-        self.src_archives.push(read_cache.into_inner());\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        enum BuilderKind {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-        }\n-\n-        let sess = self.sess;\n-\n-        let mut symbol_table = BTreeMap::new();\n-\n-        let mut entries = Vec::new();\n-\n-        for (mut entry_name, entry) in self.entries {\n-            // FIXME only read the symbol table of the object files to avoid having to keep all\n-            // object files in memory at once, or read them twice.\n-            let data = match entry {\n-                ArchiveEntry::FromArchive { archive_index, file_range } => {\n-                    // FIXME read symbols from symtab\n-                    let src_read_cache = &mut self.src_archives[archive_index];\n-\n-                    src_read_cache.seek(io::SeekFrom::Start(file_range.0)).unwrap();\n-                    let mut data = std::vec::from_elem(0, usize::try_from(file_range.1).unwrap());\n-                    src_read_cache.read_exact(&mut data).unwrap();\n-\n-                    data\n-                }\n-                ArchiveEntry::File(file) => std::fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\n-                        \"error while reading object file during archive building: {}\",\n-                        err\n-                    ));\n-                }),\n-            };\n-\n-            if !self.no_builtin_ranlib {\n-                if symbol_table.contains_key(&entry_name) {\n-                    // The ar crate can't handle creating a symbol table in case of multiple archive\n-                    // members with the same name. Work around this by prepending a number until we\n-                    // get a unique name.\n-                    for i in 1.. {\n-                        let new_name = format!(\"{}_\", i)\n-                            .into_bytes()\n-                            .into_iter()\n-                            .chain(entry_name.iter().copied())\n-                            .collect::<Vec<_>>();\n-                        if !symbol_table.contains_key(&new_name) {\n-                            entry_name = new_name;\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                match object::File::parse(&*data) {\n-                    Ok(object) => {\n-                        symbol_table.insert(\n-                            entry_name.to_vec(),\n-                            object\n-                                .symbols()\n-                                .filter_map(|symbol| {\n-                                    if symbol.is_undefined() || symbol.is_local() {\n-                                        None\n-                                    } else {\n-                                        symbol.name().map(|name| name.as_bytes().to_vec()).ok()\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>(),\n-                        );\n-                    }\n-                    Err(err) => {\n-                        let err = err.to_string();\n-                        if err == \"Unknown file magic\" {\n-                            // Not an object file; skip it.\n-                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n-                            // Nested archive file; skip it.\n-                        } else {\n-                            sess.fatal(&format!(\n-                                \"error parsing `{}` during archive creation: {}\",\n-                                String::from_utf8_lossy(&entry_name),\n-                                err\n-                            ));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            entries.push((entry_name, data));\n-        }\n-\n-        let mut builder = if self.use_gnu_style_archive {\n-            BuilderKind::Gnu(\n-                ar::GnuBuilder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    entries.iter().map(|(name, _)| name.clone()).collect(),\n-                    ar::GnuSymbolTableFormat::Size32,\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        } else {\n-            BuilderKind::Bsd(\n-                ar::Builder::new(\n-                    File::create(output).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\n-                            \"error opening destination during archive building: {}\",\n-                            err\n-                        ));\n-                    }),\n-                    symbol_table,\n-                )\n-                .unwrap(),\n-            )\n-        };\n-\n-        let any_members = !entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, data) in entries.into_iter() {\n-            let header = ar::Header::new(entry_name, data.len() as u64);\n-            match builder {\n-                BuilderKind::Bsd(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-                BuilderKind::Gnu(ref mut builder) => builder.append(&header, &mut &*data).unwrap(),\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        if self.no_builtin_ranlib {\n-            let ranlib = crate::toolchain::get_toolchain_binary(self.sess, \"ranlib\");\n-\n-            // Run ranlib to be able to link the archive\n-            let status = std::process::Command::new(ranlib)\n-                .arg(output)\n-                .status()\n-                .expect(\"Couldn't run ranlib\");\n-\n-            if !status.success() {\n-                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-            }\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}]}