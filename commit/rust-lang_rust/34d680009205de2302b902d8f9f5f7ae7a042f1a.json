{"sha": "34d680009205de2302b902d8f9f5f7ae7a042f1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDY4MDAwOTIwNWRlMjMwMmI5MDJkOGY5ZjVmN2FlN2EwNDJmMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-22T00:12:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-22T00:12:47Z"}, "message": "auto merge of #20104 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "2b7eb92a4d5a0d997871020964fe539390737dd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b7eb92a4d5a0d997871020964fe539390737dd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a", "html_url": "https://github.com/rust-lang/rust/commit/34d680009205de2302b902d8f9f5f7ae7a042f1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d680009205de2302b902d8f9f5f7ae7a042f1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bdcfd64629930c09b942025e242e51e784c447d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bdcfd64629930c09b942025e242e51e784c447d", "html_url": "https://github.com/rust-lang/rust/commit/1bdcfd64629930c09b942025e242e51e784c447d"}, {"sha": "fb7c08876e7b29c1b9d57df905f3ee0deec46aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7c08876e7b29c1b9d57df905f3ee0deec46aa1", "html_url": "https://github.com/rust-lang/rust/commit/fb7c08876e7b29c1b9d57df905f3ee0deec46aa1"}], "stats": {"total": 4479, "additions": 2266, "deletions": 2213}, "files": [{"sha": "9a924916ec8615a3b1ee285468b50ff822ba9547", "filename": "mk/docs.mk", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -216,36 +216,6 @@ endef\n $(foreach docname,$(DOCS),$(eval $(call DEF_DOC,$(docname))))\n \n \n-# Localized documentation\n-\n-# FIXME: I (huonw) haven't actually been able to test properly, since\n-# e.g. (by default) I'm doing an out-of-tree build (#12763), but even\n-# adjusting for that, the files are too old(?) and are rejected by\n-# po4a.\n-#\n-# As such, I've attempted to get it working as much as possible (and\n-# switching from pandoc to rustdoc), but preserving the old behaviour\n-# (e.g. only running on the guide)\n-.PHONY: l10n-mds\n-l10n-mds: $(D)/po4a.conf \\\n-\t\t$(foreach lang,$(L10N_LANG),$(D)/po/$(lang)/*.md.po)\n-\t$(warning WARNING: localized documentation is experimental)\n-\tpo4a --copyright-holder=\"The Rust Project Developers\" \\\n-\t\t--package-name=\"Rust\" \\\n-\t\t--package-version=\"$(CFG_RELEASE)\" \\\n-\t\t-M UTF-8 -L UTF-8 \\\n-\t\t$(D)/po4a.conf\n-\n-define DEF_L10N_DOC\n-DOC_L10N_TARGETS += doc/l10n/$(1)/$(2).html\n-doc/l10n/$(1)/$(2).html: l10n-mds $$(HTML_DEPS) $$(RUSTDOC_DEPS_$(2))\n-\t@$$(call E, rustdoc: $$@)\n-\t$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) doc/l10n/$(1)/$(2).md\n-endef\n-\n-$(foreach lang,$(L10N_LANGS),$(eval $(call DEF_L10N_DOC,$(lang),guide)))\n-\n-\n ######################################################################\n # Rustdoc (libstd/extra)\n ######################################################################\n@@ -294,7 +264,3 @@ endif\n \n docs: $(DOC_TARGETS)\n compiler-docs: $(COMPILER_DOC_TARGETS)\n-\n-docs-l10n: $(DOC_L10N_TARGETS)\n-\n-.PHONY: docs-l10n"}, {"sha": "1a122572e434c4c7a05f3c906209735fcbdab964", "filename": "mk/tests.mk", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -74,21 +74,6 @@ endif\n TEST_LOG_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n TEST_OK_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).ok\n \n-TEST_RATCHET_FILE=tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4)-metrics.json\n-TEST_RATCHET_NOISE_PERCENT=10.0\n-\n-# Whether to ratchet or merely save benchmarks\n-ifdef CFG_RATCHET_BENCH\n-CRATE_TEST_EXTRA_ARGS= \\\n-  --test $(TEST_BENCH) \\\n-  --ratchet-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) \\\n-  --ratchet-noise-percent $(TEST_RATCHET_NOISE_PERCENT)\n-else\n-CRATE_TEST_EXTRA_ARGS= \\\n-  --test $(TEST_BENCH) \\\n-  --save-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4))\n-endif\n-\n # If we're sharding the testsuite between parallel testers,\n # pass this argument along to the compiletest and crate test\n # invocations.\n@@ -455,7 +440,6 @@ $$(call TEST_OK_FILE,$(1),$(2),$(3),$(4)): \\\n \t$$(Q)touch tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n \t$$(Q)$(CFG_ADB) pull $(CFG_ADB_TEST_DIR)/check-stage$(1)-T-$(2)-H-$(3)-$(4).log tmp/\n \t$$(Q)$(CFG_ADB) shell rm $(CFG_ADB_TEST_DIR)/check-stage$(1)-T-$(2)-H-$(3)-$(4).log\n-\t$$(Q)$(CFG_ADB) pull $(CFG_ADB_TEST_DIR)/$$(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) tmp/\n \t@if grep -q \"result: ok\" tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).tmp; \\\n \tthen \\\n \t\trm tmp/check-stage$(1)-T-$(2)-H-$(3)-$(4).tmp; \\\n@@ -697,7 +681,6 @@ CTEST_ARGS$(1)-T-$(2)-H-$(3)-$(4) := \\\n         $$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3)) \\\n         --src-base $$(S)src/test/$$(CTEST_SRC_BASE_$(4))/ \\\n         --build-base $(3)/test/$$(CTEST_BUILD_BASE_$(4))/ \\\n-        --ratchet-metrics $(call TEST_RATCHET_FILE,$(1),$(2),$(3),$(4)) \\\n         --mode $$(CTEST_MODE_$(4)) \\\n \t$$(CTEST_RUNTOOL_$(4))\n "}, {"sha": "567734b0dab7b2b73f5b1397d5e6f3877e115dec", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1609,7 +1609,7 @@ fn _arm_exec_compiled_test(config: &Config,\n                 stderr_out.as_slice());\n \n     ProcRes {\n-        status: process::ExitStatus(exitcode),\n+        status: process::ProcessExit::ExitStatus(exitcode),\n         stdout: stdout_out,\n         stderr: stderr_out,\n         cmdline: cmdline"}, {"sha": "3b12ffe8f11e1bf25151fe09760763ef079960ad", "filename": "src/doc/README.md", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2FREADME.md?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -6,12 +6,6 @@\n document converter, is required to generate docs as HTML from Rust's\n source code.\n \n-[po4a](http://po4a.alioth.debian.org/) is required for generating translated\n-docs from the master (English) docs.\n-\n-[GNU gettext](http://www.gnu.org/software/gettext/) is required for managing\n-the translation data.\n-\n ## Building\n \n To generate all the docs, just run `make docs` from the root of the repository.\n@@ -44,43 +38,3 @@ The syntax for pandoc flavored markdown can be found at:\n A nice quick reference (for non-pandoc markdown) is at:\n \n - http://kramdown.gettalong.org/quickref.html\n-\n-## Notes for translators\n-\n-Notice: The procedure described below is a work in progress. We are working on\n-translation system but the procedure contains some manual operations for now.\n-\n-To start the translation for a new language, see `po4a.conf` at first.\n-\n-To generate `.pot` and `.po` files, do something like:\n-\n-~~~~\n-po4a --copyright-holder=\"The Rust Project Developers\" \\\n-    --package-name=\"Rust\" \\\n-    --package-version=\"0.13.0\" \\\n-    -M UTF-8 -L UTF-8 \\\n-    src/doc/po4a.conf\n-~~~~\n-\n-(the version number must be changed if it is not `0.13.0` now.)\n-\n-Now you can translate documents with `.po` files, commonly used with gettext. If\n-you are not familiar with gettext-based translation, please read the online\n-manual linked from http://www.gnu.org/software/gettext/ . We use UTF-8 as the\n-file encoding of `.po` files.\n-\n-When you want to make a commit, do the command below before staging your\n-change:\n-\n-~~~~\n-for f in src/doc/po/**/*.po; do\n-    msgattrib --translated $f -o $f.strip\n-    if [ -e $f.strip ]; then\n-       mv $f.strip $f\n-    else\n-       rm $f\n-    fi\n-done\n-~~~~\n-\n-This removes untranslated entries from `.po` files to save disk space."}, {"sha": "bf750ecaa8f673acd63f36e7822feb6c0c33465f", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -324,7 +324,7 @@ fn main() {\n     let f = Foo { x: y }; // -+ f goes into scope\n     // stuff              //  |\n                           //  |\n-}                         // -+ f & y go out of scope\n+}                         // -+ f and y go out of scope\n ```\n \n Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n@@ -342,7 +342,7 @@ fn main() {\n         let y = &5i;          // ---+ y goes into scope\n         let f = Foo { x: y }; // ---+ f goes into scope\n         x = &f.x;             //  | | error here\n-    }                         // ---+ f & y go out of scope\n+    }                         // ---+ f and y go out of scope\n                               //  |\n     println!(\"{}\", x);        //  |\n }                             // -+ x goes out of scope\n@@ -395,7 +395,7 @@ struct Wheel {\n }\n \n fn main() {\n-    let car = Car { name: \"DeLorian\".to_string() };\n+    let car = Car { name: \"DeLorean\".to_string() };\n \n     for _ in range(0u, 4) {\n         Wheel { size: 360, owner: car };\n@@ -431,7 +431,7 @@ struct Wheel {\n }\n \n fn main() {\n-    let car = Car { name: \"DeLorian\".to_string() };\n+    let car = Car { name: \"DeLorean\".to_string() };\n \n     let car_owner = Rc::new(car);\n "}, {"sha": "1cd100e15980719f1ab5392a17de7e55c4db1d2c", "filename": "src/doc/guide.md", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -31,7 +31,6 @@ below.)\n \n If you're on Windows, please download either the [32-bit\n installer](https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.exe)\n-\n or the [64-bit\n installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.exe)\n and run it.\n@@ -1170,7 +1169,7 @@ enum StringResult {\n     ErrorReason(String),\n }\n ```\n-Where a `StringResult` is either an `StringOK`, with the result of a computation, or an\n+Where a `StringResult` is either a `StringOK`, with the result of a computation, or an\n `ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n `enum`s are actually very useful and are even part of the standard library.\n \n@@ -1192,7 +1191,7 @@ fn respond(greeting: &str) -> StringResult {\n ```\n \n Notice that we need both the enum name and the variant name: `StringResult::StringOK`, but\n-we didn't need to with `Ordering`, we just said `Greater` rather than `Ordering::Greater`.\n+we didn't need to with `Ordering` \u2013 we just said `Greater` rather than `Ordering::Greater`.\n There's a reason: the Rust prelude imports the variants of `Ordering` as well as the enum\n itself. We can use the `use` keyword to do something similar with `StringResult`:\n \n@@ -1223,16 +1222,16 @@ now, rather than the full `StringResult::StringOK`. Importing variants can be co\n also cause name conflicts, so do this with caution. It's considered good style to rarely import\n variants for this reason.\n \n-As you can see `enum`s with values are quite a powerful tool for data representation,\n-and can be even more useful when they're generic across types. But before we get to\n-generics, let's talk about how to use them with pattern matching, a tool that will\n+As you can see, `enum`s with values are quite a powerful tool for data representation,\n+and can be even more useful when they're generic across types. Before we get to generics,\n+though, let's talk about how to use them with pattern matching, a tool that will\n let us deconstruct this sum type (the type theory term for enums) in a very elegant\n way and avoid all these messy `if`/`else`s.\n \n # Match\n \n Often, a simple `if`/`else` isn't enough, because you have more than two\n-possible options. And `else` conditions can get incredibly complicated. So\n+possible options. Also, `else` conditions can get incredibly complicated, so\n what's the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n@@ -1251,25 +1250,25 @@ match x {\n }\n ```\n \n-`match` takes an expression, and then branches based on its value. Each 'arm' of\n+`match` takes an expression and then branches based on its value. Each 'arm' of\n the branch is of the form `val => expression`. When the value matches, that arm's\n expression will be evaluated. It's called `match` because of the term 'pattern\n-matching,' which `match` is an implementation of.\n+matching', which `match` is an implementation of.\n \n So what's the big advantage here? Well, there are a few. First of all, `match`\n-enforces 'exhaustiveness checking.' Do you see that last arm, the one with the\n+enforces 'exhaustiveness checking'. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n ```text\n error: non-exhaustive patterns: `_` not covered\n ```\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values. For example,\n-`6i`. But without the `_`, there is no arm that could match, and so Rust refuses\n-to compile. `_` is sort of like a catch-all arm. If none of the other arms match,\n-the arm with `_` will. And since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will now compile.\n+integer, Rust knows that it can have a number of different values \u2013 for example,\n+`6i`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n+to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n+the arm with `_` will, and since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will compile successfully.\n \n `match` statements also destructure enums, as well. Remember this code from the\n section on enums?\n@@ -1350,14 +1349,14 @@ fn main() {\n ```\n \n That is how you can get and use the values contained in `enum`s.\n-It can also allow us to treat errors or unexpected computations, for example, a\n-function that is not guaranteed to be able to compute a result (an `int` here),\n+It can also allow us to handle errors or unexpected computations; for example, a\n+function that is not guaranteed to be able to compute a result (an `int` here)\n could return an `OptionalInt`, and we would handle that value with a `match`.\n As you can see, `enum` and `match` used together are quite useful!\n \n-`match` is also an expression, which means we can use it on the right\n-hand side of a `let` binding or directly where an expression is\n-used. We could also implement the previous line like this:\n+`match` is also an expression, which means we can use it on the right-hand\n+side of a `let` binding or directly where an expression is used. We could\n+also implement the previous line like this:\n \n ```{rust}\n fn cmp(a: int, b: int) -> Ordering {\n@@ -1389,7 +1388,7 @@ two main looping constructs: `for` and `while`.\n \n The `for` loop is used to loop a particular number of times. Rust's `for` loops\n work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C style\" `for` loop:\n+loop doesn't look like this \"C-style\" `for` loop:\n \n ```{c}\n for (x = 0; x < 10; x++) {\n@@ -1424,7 +1423,7 @@ In our example, `range` is a function that takes a start and an end position,\n and gives an iterator over those values. The upper bound is exclusive, though,\n so our loop will print `0` through `9`, not `10`.\n \n-Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n+Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n developers.\n \n@@ -1455,7 +1454,7 @@ If you need an infinite loop, you may be tempted to write this:\n while true {\n ```\n \n-Rust has a dedicated keyword, `loop`, to handle this case:\n+However, Rust has a dedicated keyword, `loop`, to handle this case:\n \n ```{rust,ignore}\n loop {\n@@ -1465,7 +1464,7 @@ Rust's control-flow analysis treats this construct differently than a\n `while true`, since we know that it will always loop. The details of what\n that _means_ aren't super important to understand at this stage, but in\n general, the more information we can give to the compiler, the better it\n-can do with safety and code generation. So you should always prefer\n+can do with safety and code generation, so you should always prefer\n `loop` when you plan to loop infinitely.\n \n ## Ending iteration early\n@@ -1484,7 +1483,7 @@ while !done {\n ```\n \n We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n-when we should skip out of the loop. Rust has two keywords to help us with\n+when we should exit out of the loop. Rust has two keywords to help us with\n modifying iteration: `break` and `continue`.\n \n In this case, we can write the loop in a better way with `break`:\n@@ -1499,10 +1498,10 @@ loop {\n }\n ```\n \n-We now loop forever with `loop`, and use `break` to break out early.\n+We now loop forever with `loop` and use `break` to break out early.\n \n `continue` is similar, but instead of ending the loop, goes to the next\n-iteration: This will only print the odd numbers:\n+iteration. This will only print the odd numbers:\n \n ```{rust}\n for x in range(0i, 10i) {\n@@ -1519,8 +1518,8 @@ Both `continue` and `break` are valid in both kinds of loops.\n Strings are an important concept for any programmer to master. Rust's string\n handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That said, Rust's strings\n-also work differently than in some other systems languages, such as C.\n+tricky, and strings are a re-sizable data structure. That being said, Rust's\n+strings also work differently than in some other systems languages, such as C.\n \n Let's dig into the details. A **string** is a sequence of Unicode scalar values\n encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n@@ -1793,22 +1792,22 @@ fn main() {\n }\n ```\n \n-We had to match each time, to see if we had a value or not. In this case,\n-though, we _know_ that `x` has a `Value`. But `match` forces us to handle\n+We had to match each time to see if we had a value or not. In this case,\n+though, we _know_ that `x` has a `Value`, but `match` forces us to handle\n the `missing` case. This is what we want 99% of the time, but sometimes, we\n know better than the compiler.\n \n Likewise, `read_line()` does not return a line of input. It _might_ return a\n-line of input. It might also fail to do so. This could happen if our program\n+line of input, though it might also fail to do so. This could happen if our program\n isn't running in a terminal, but as part of a cron job, or some other context\n where there's no standard input. Because of this, `read_line` returns a type\n very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n `IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n-Until then, you can think of it as being the same thing, just for any type, not\n-just `int`s.\n+Until then, you can think of it as being the same thing, just for any type \u2013\n+not just `int`s.\n \n Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n-same thing as our `match` statement, but assuming that we have a valid value.\n+same thing as our `match` statement but assumes that we have a valid value.\n We then call `expect()` on the result, which will terminate our program if we\n don't have a valid value. In this case, if we can't get input, our program\n doesn't work, so we're okay with that. In most cases, we would want to handle\n@@ -1852,7 +1851,7 @@ fn main() {\n }\n ```\n \n-Sometimes, this makes things more readable. Sometimes, less. Use your judgment\n+Sometimes, this makes things more readable \u2013 sometimes, less. Use your judgement\n here.\n \n That's all you need to get basic input from the standard input! It's not too\n@@ -1972,10 +1971,8 @@ You can find that page [here](std/index.html). There's a lot of information on\n that page, but the best part is the search bar. Right up at the top, there's\n a box that you can enter in a search term. The search is pretty primitive\n right now, but is getting better all the time. If you type 'random' in that\n-box, the page will update to [this\n-one](std/index.html?search=random). The very first\n-result is a link to\n-[std::rand::random](std/rand/fn.random.html). If we\n+box, the page will update to [this one](std/index.html?search=random). The very\n+first result is a link to [`std::rand::random`](std/rand/fn.random.html). If we\n click on that result, we'll be taken to its documentation page.\n \n This page shows us a few things: the type signature of the function, some\n@@ -2039,7 +2036,7 @@ rand::random::<int>();\n ```\n \n This says \"please give me a random `int` value.\" We can change our code to use\n-this hint...\n+this hint:\n \n ```{rust,no_run}\n use std::io;\n@@ -2380,7 +2377,7 @@ fn cmp(a: uint, b: uint) -> Ordering {\n }\n ```\n \n-We use a `match` to either give us the `uint` inside of the `Option`, or we\n+We use a `match` to either give us the `uint` inside of the `Option`, or else\n print an error message and return. Let's give this a shot:\n \n ```bash\n@@ -2398,8 +2395,8 @@ Uh, what? But we did!\n \n ... actually, we didn't. See, when you get a line of input from `stdin()`,\n you get all the input. Including the `\\n` character from you pressing Enter.\n-So, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a number,\n-there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+Therefore, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n \n@@ -2465,16 +2462,16 @@ out that I guessed 76. Run the program a few times, and verify that guessing\n the number works, as well as guessing a number too small.\n \n The Rust compiler helped us out quite a bit there! This technique is called\n-\"lean on the compiler,\" and it's often useful when working on some code. Let\n+\"lean on the compiler\", and it's often useful when working on some code. Let\n the error messages help guide you towards the correct types.\n \n Now we've got most of the game working, but we can only make one guess. Let's\n change that by adding loops!\n \n ## Looping\n \n-As we already discussed, the `loop` keyword gives us an infinite loop. So\n-let's add that in:\n+As we already discussed, the `loop` keyword gives us an infinite loop.\n+Let's add that in:\n \n ```{rust,no_run}\n use std::io;\n@@ -2780,12 +2777,11 @@ $ cargo run\n Hello, world!\n ```\n \n-Excellent! So, we already have a single crate here: our `src/main.rs` is a crate.\n+Excellent! We already have a single crate here: our `src/main.rs` is a crate.\n Everything in that file is in the crate root. A crate that generates an executable\n defines a `main` function inside its root, as we've done here.\n \n-Let's define a new module inside our crate. Edit `src/main.rs` to look\n-like this:\n+Let's define a new module inside our crate. Edit `src/main.rs` to look like this:\n \n ```\n fn main() {\n@@ -2803,7 +2799,7 @@ We now have a module named `hello` inside of our crate root. Modules use\n `snake_case` naming, like functions and variable bindings.\n \n Inside the `hello` module, we've defined a `print_hello` function. This will\n-also print out our hello world message. Modules allow you to split up your\n+also print out our \"hello world\" message. Modules allow you to split up your\n program into nice neat boxes of functionality, grouping common things together,\n and keeping different things apart. It's kinda like having a set of shelves:\n a place for everything and everything in its place.\n@@ -2963,7 +2959,7 @@ You'll get a warning if you use something marked unstable.\n \n You may have noticed an exclamation point in the `warn` attribute declaration.\n The `!` in this attribute means that this attribute applies to the enclosing\n-item, rather than to the item that follows the attribute. So this `warn`\n+item, rather than to the item that follows the attribute. This `warn`\n attribute declaration applies to the enclosing crate itself, rather than\n to whatever item statement follows it:\n \n@@ -3003,9 +2999,9 @@ Hello, world!\n Great. Rust's infrastructure supports tests in two sorts of places, and they're\n for two kinds of tests: you include **unit test**s inside of the crate itself,\n and you place **integration test**s inside a `tests` directory. \"Unit tests\"\n-are small tests that test one focused unit, \"integration tests\" tests multiple\n-units in integration. That said, this is a social convention, they're no different\n-in syntax. Let's make a `tests` directory:\n+are small tests that test one focused unit; \"integration tests\" test multiple\n+units in integration. That being said, this is a social convention \u2013 they're no\n+different in syntax. Let's make a `tests` directory:\n \n ```{bash,ignore}\n $ mkdir tests\n@@ -3085,7 +3081,7 @@ test foo ... FAILED\n \n Now we're getting somewhere. Remember when we talked about naming our tests\n with good names? This is why. Here, it says 'test foo' because we called our\n-test 'foo.' If we had given it a good name, it'd be more clear which test\n+test 'foo'. If we had given it a good name, it'd be more clear which test\n failed, especially as we accumulate more tests.\n \n ```text\n@@ -3156,7 +3152,7 @@ our tests, it sets things up so that `cfg(test)` is true. But we want to only\n include `main` when it's _not_ true. So we use `not` to negate things:\n `cfg(not(test))` will only compile our code when the `cfg(test)` is false.\n \n-With this attribute we won't get the warning (even\n+With this attribute, we won't get the warning (even\n though `src/main.rs` gets recompiled this time):\n \n ```bash\n@@ -3200,15 +3196,15 @@ error: aborting due to previous error\n Build failed, waiting for other jobs to finish...\n Could not compile `testing`.\n \n-To learn more, run the command again with --verbose.\n+To learn more, run the command again with `--verbose`.\n ```\n \n Rust can't find this function. That makes sense, as we didn't write it yet!\n \n In order to share this code with our tests, we'll need to make a library crate.\n This is also just good software design: as we mentioned before, it's a good idea\n to put most of your functionality into a library crate, and have your executable\n-crate use that library. This allows for code re-use.\n+crate use that library. This allows for code reuse.\n \n To do that, we'll need to make a new module. Make a new file, `src/lib.rs`,\n and put this in it:\n@@ -3282,8 +3278,8 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n Great! One test passed. We've got an integration test showing that our public\n method works, but maybe we want to test some of the internal logic as well.\n While this function is simple, if it were more complicated, you can imagine\n-we'd need more tests. So let's break it up into two helper functions, and\n-write some unit tests to test those.\n+we'd need more tests. Let's break it up into two helper functions and write\n+some unit tests to test those.\n \n Change your `src/lib.rs` to look like this:\n \n@@ -3532,7 +3528,7 @@ error: cannot borrow immutable local variable `x` as mutable\n ```\n \n We don't want a mutable reference to immutable data! This error message uses a\n-term we haven't talked about yet, 'borrow.' We'll get to that in just a moment.\n+term we haven't talked about yet, 'borrow'. We'll get to that in just a moment.\n \n This simple example actually illustrates a lot of Rust's power: Rust has\n prevented us, at compile time, from breaking our own rules. Because Rust's\n@@ -3653,9 +3649,10 @@ all of Rust. Let's see this syntax in action:\n fn foo(x: &int) -> &int { x }\n \n {\n-    let x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of the integer, which is memory on the stack.\n+    let x = 5i;\n \n-    // privilege 2: you may lend that resource, to as many borrowers as you'd like\n+    // privilege 2: you may lend that resource to as many borrowers as you like\n     let y = &x;\n     let z = &x;\n \n@@ -3665,10 +3662,11 @@ fn foo(x: &int) -> &int { x }\n }\n \n {\n-    let mut x = 5i; // x is the owner of this integer, which is memory on the stack.\n+    // x is the owner of this integer, which is memory on the stack.\n+    let mut x = 5i;\n \n-    let y = &mut x; // privilege 3: you may lend that resource to a single borrower,\n-                    // mutably\n+    // privilege 3: you may lend that resource to a single borrower, mutably\n+    let y = &mut x;\n }\n ```\n \n@@ -3684,7 +3682,7 @@ This last requirement can seem odd, but it also makes sense. If you have to\n return something, and you've lent it to someone, they need to give it back to\n you for you to give it back! If we didn't, then the owner could deallocate\n the memory, and the person we've loaned it out to would have a pointer to\n-invalid memory. This is called a 'dangling pointer.'\n+invalid memory. This is called a 'dangling pointer'.\n \n Let's re-examine the error that led us to talk about all of this, which was a\n violation of the restrictions placed on owners who lend something out mutably.\n@@ -3807,8 +3805,8 @@ an integer `5` and makes `x` a pointer to it:\n ```\n \n The great thing about boxes is that we don't have to manually free this\n-allocation! Instead, when `x` reaches the end of its lifetime -- in this case,\n-when it goes out of scope at the end of the block -- Rust `free`s `x`. This\n+allocation! Instead, when `x` reaches the end of its lifetime \u2013 in this case,\n+when it goes out of scope at the end of the block \u2013 Rust `free`s `x`. This\n isn't because Rust has a garbage collector (it doesn't). Instead, by tracking\n the ownership and lifetime of a variable (with a little help from you, the\n programmer), the compiler knows precisely when it is no longer used.\n@@ -3873,12 +3871,12 @@ Sometimes you need a variable that is referenced from multiple places\n (immutably!), lasting as long as any of those places, and disappearing when it\n is no longer referenced. For instance, in a graph-like data structure, a node\n might be referenced from all of its neighbors. In this case, it is not possible\n-for the compiler to determine ahead of time when the value can be freed -- it\n+for the compiler to determine ahead of time when the value can be freed \u2013 it\n needs a little run-time support.\n \n Rust's **Rc** type provides shared ownership of a dynamically allocated value\n that is automatically freed at the end of its last owner's lifetime. (`Rc`\n-stands for 'reference counted,' referring to the way these library types are\n+stands for 'reference counted', referring to the way these library types are\n implemented.) This provides more flexibility than single-owner boxes, but has\n some runtime overhead.\n \n@@ -4300,7 +4298,7 @@ This line is more interesting. Here, we call our function, `twice`, and we pass\n it two arguments: an integer, `5`, and our closure, `square`. This is just like\n passing any other two variable bindings to a function, but if you've never\n worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables, one is an int, and one is a function.\"\n+passing two variables: one is an int, and one is a function.\"\n \n Next, let's look at how `twice` is defined:\n \n@@ -4336,7 +4334,7 @@ fn twice(x: int, f: |int| -> int) -> int {\n ```\n \n Since our closure is named `f`, we can call it just like we called our closures\n-before. And we pass in our `x` argument to each one. Hence 'twice.'\n+before, and we pass in our `x` argument to each one, hence the name `twice`.\n \n If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n \n@@ -4807,7 +4805,7 @@ enum Result<H, N> {\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for 'type,' and that we use `E` for 'error'. Rust doesn't care, however.\n \n The `Result<T, E>` type is intended to\n be used to return the result of a computation, and to have the ability to\n@@ -5212,7 +5210,7 @@ fn main() {\n \n The names don't actually change to this, it's just for illustration. But\n as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched.' The downside is that we have two copies of\n+hence 'statically dispatched'. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n \n # Tasks\n@@ -5412,7 +5410,7 @@ fn main() {\n }\n ```\n \n-You can have the macros expanded like this: `rustc print.rs --pretty=expanded` \u2013 which will\n+You can have the macros expanded like this: `rustc print.rs --pretty=expanded`, which will\n give us this huge result:\n \n ```{rust,ignore}\n@@ -5498,7 +5496,6 @@ We covered a lot of ground here. When you've mastered everything in this Guide,\n you will have a firm grasp of basic Rust development. There's a whole lot more\n out there, we've just covered the surface. There's tons of topics that you can\n dig deeper into, and we've built specialized guides for many of them. To learn\n-more, dig into the [full documentation\n-index](index.html).\n+more, dig into the [full documentation index](index.html).\n \n Happy hacking!"}, {"sha": "80f8b748814cb3955c7449862bd62e15deade9b1", "filename": "src/doc/po4a.conf", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1bdcfd64629930c09b942025e242e51e784c447d/src%2Fdoc%2Fpo4a.conf", "raw_url": "https://github.com/rust-lang/rust/raw/1bdcfd64629930c09b942025e242e51e784c447d/src%2Fdoc%2Fpo4a.conf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo4a.conf?ref=1bdcfd64629930c09b942025e242e51e784c447d", "patch": "@@ -1,28 +0,0 @@\n-# Add here a list of target languages; po4a will automatically\n-# generates .po for them and build .md when translated, eg:\n-# [po4a_langs] es fr it pt_BR\n-[po4a_langs] ja\n-[po4a_paths] doc/po/$master.pot $lang:src/doc/po/$lang/$master.po\n-\n-# Add here below all source documents to be translated\n-[type: text] src/doc/complement-bugreport.md $lang:doc/l10n/$lang/complement-bugreport.md\n-[type: text] src/doc/complement-design-faq.md $lang:doc/l10n/$lang/complement-design-faq.md\n-[type: text] src/doc/complement-lang-faq.md $lang:doc/l10n/$lang/complement-lang-faq.md\n-[type: text] src/doc/complement-project-faq.md $lang:doc/l10n/$lang/complement-project-faq.md\n-[type: text] src/doc/guide-container.md $lang:doc/l10n/$lang/guide-container.md\n-[type: text] src/doc/guide-ffi.md $lang:doc/l10n/$lang/guide-ffi.md\n-[type: text] src/doc/guide-ownership.md $lang:doc/l10n/$lang/guide-ownership.md\n-[type: text] src/doc/guide-macros.md $lang:doc/l10n/$lang/guide-macros.md\n-[type: text] src/doc/guide-plugin.md $lang:doc/l10n/$lang/guide-plugin.md\n-[type: text] src/doc/guide-pointers.md $lang:doc/l10n/$lang/guide-pointers.md\n-[type: text] src/doc/guide-strings.md $lang:doc/l10n/$lang/guide-strings.md\n-[type: text] src/doc/guide-tasks.md $lang:doc/l10n/$lang/guide-tasks.md\n-[type: text] src/doc/guide-testing.md $lang:doc/l10n/$lang/guide-testing.md\n-[type: text] src/doc/guide-unsafe.md $lang:doc/l10n/$lang/guide-unsafe.md\n-[type: text] src/doc/guide-crates.md $lang:doc/l10n/$lang/guide-crates.md\n-[type: text] src/doc/guide-error-handling.md $lang:doc/l10n/$lang/guide-error-handling.md\n-[type: text] src/doc/guide.md $lang:doc/l10n/$lang/guide.md\n-[type: text] src/doc/index.md $lang:doc/l10n/$lang/index.md\n-[type: text] src/doc/intro.md $lang:doc/l10n/$lang/intro.md\n-[type: text] src/doc/rust.md $lang:doc/l10n/$lang/rust.md\n-[type: text] src/doc/rustdoc.md $lang:doc/l10n/$lang/rustdoc.md"}, {"sha": "722230d37557cf9559a406330ff2c77bbd6d3ad4", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -518,7 +518,7 @@ This last example is different because it is not possible to use the suffix\n syntax with a floating point literal ending in a period. `2.f64` would attempt\n to call a method named `f64` on `2`.\n \n-##### Boolean literals\n+#### Boolean literals\n \n The two values of the boolean type are written `true` and `false`.\n \n@@ -934,7 +934,7 @@ kinds of view items:\n \n ```{.ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit as ident )\n+crate_name: ident | ( string_lit \"as\" ident )\n ```\n \n An _`extern crate` declaration_ specifies a dependency on an external crate."}, {"sha": "128d75468e6f4239274d463943b91f784b7ca863", "filename": "src/doc/rust.css", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1,5 +1,5 @@\n /**\n- * Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+ * Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n  * file at the top-level directory of this distribution and at\n  * http://rust-lang.org/COPYRIGHT.\n  * With elements taken from Bootstrap v3.0.2 (MIT licensed).\n@@ -209,7 +209,6 @@ pre {\n code {\n     padding: 0 2px;\n     color: #8D1A38;\n-    white-space: pre-wrap;\n }\n pre code {\n     padding: 0;"}, {"sha": "893c9d250b7237cae7fa3aff45f0de81f3ce985e", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 317, "deletions": 72, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,8 +10,62 @@\n \n #![stable]\n \n-//! Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n-//! between tasks.\n+//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n+//!\n+//! The `Arc<T>` type provides shared ownership of an immutable value. Destruction is\n+//! deterministic, and will occur as soon as the last owner is gone. It is marked as `Send` because\n+//! it uses atomic reference counting.\n+//!\n+//! If you do not need thread-safety, and just need shared ownership, consider the [`Rc<T>`\n+//! type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but does not use atomics, making it\n+//! both thread-unsafe as well as significantly faster when updating the reference count.\n+//!\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n+//! `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but will return `None` if the value\n+//! has already been dropped.\n+//!\n+//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n+//! `Arc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//!\n+//! # Examples\n+//!\n+//! Sharing some immutable data between tasks:\n+//!\n+//! ```\n+//! use std::sync::Arc;\n+//! use std::thread::Thread;\n+//!\n+//! let five = Arc::new(5i);\n+//!\n+//! for i in range(0u, 10) {\n+//!     let five = five.clone();\n+//!\n+//!     Thread::spawn(move || {\n+//!         println!(\"{}\", five);\n+//!     }).detach();\n+//! }\n+//! ```\n+//!\n+//! Sharing mutable data safely between tasks with a `Mutex`:\n+//!\n+//! ```\n+//! use std::sync::{Arc, Mutex};\n+//! use std::thread::Thread;\n+//!\n+//! let five = Arc::new(Mutex::new(5i));\n+//!\n+//! for _ in range(0u, 10) {\n+//!     let five = five.clone();\n+//!\n+//!     Thread::spawn(move || {\n+//!         let mut number = five.lock();\n+//!\n+//!         *number += 1;\n+//!\n+//!         println!(\"{}\", *number); // prints 6\n+//!     }).detach();\n+//! }\n+//! ```\n \n use core::atomic;\n use core::borrow::BorrowFrom;\n@@ -33,9 +87,8 @@ use heap::deallocate;\n ///\n /// # Example\n ///\n-/// In this example, a large vector of floats is shared between several tasks.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// task.\n+/// In this example, a large vector of floats is shared between several tasks. With simple pipes,\n+/// without `Arc`, a copy would have to be made for each task.\n ///\n /// ```rust\n /// use std::sync::Arc;\n@@ -66,8 +119,8 @@ pub struct Arc<T> {\n \n /// A weak pointer to an `Arc`.\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n+/// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n@@ -83,7 +136,15 @@ struct ArcInner<T> {\n }\n \n impl<T: Sync + Send> Arc<T> {\n-    /// Creates an atomically reference counted wrapper.\n+    /// Constructs a new `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn new(data: T) -> Arc<T> {\n@@ -97,11 +158,17 @@ impl<T: Sync + Send> Arc<T> {\n         Arc { _ptr: unsafe { mem::transmute(x) } }\n     }\n \n-    /// Downgrades a strong pointer to a weak pointer.\n+    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n     ///\n-    /// Weak pointers will not keep the data alive. Once all strong references\n-    /// to the underlying data have been dropped, the data itself will be\n-    /// destroyed.\n+    /// let weak_five = five.downgrade();\n+    /// ```\n     #[experimental = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n@@ -113,11 +180,10 @@ impl<T: Sync + Send> Arc<T> {\n impl<T> Arc<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed\n-        // that the inner pointer is valid. Furthermore, we know that the\n-        // `ArcInner` structure itself is `Sync` because the inner data is\n-        // `Sync` as well, so we're ok loaning out an immutable pointer to\n-        // these contents.\n+        // This unsafety is ok because while this arc is alive we're guaranteed that the inner\n+        // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n+        // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n+        // to these contents.\n         unsafe { &*self._ptr }\n     }\n }\n@@ -132,24 +198,30 @@ pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::Seq\n #[experimental]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n \n-#[unstable = \"waiting on stability of Clone\"]\n+#[stable]\n impl<T> Clone for Arc<T> {\n-    /// Duplicate an atomically reference counted wrapper.\n+    /// Makes a clone of the `Arc<T>`.\n+    ///\n+    /// This increases the strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n     ///\n-    /// The resulting two `Arc` objects will point to the same underlying data\n-    /// object. However, one of the `Arc` objects can be sent to another task,\n-    /// allowing them to share the underlying data.\n+    /// five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the\n-        // original reference prevents other threads from erroneously deleting\n-        // the object.\n+        // Using a relaxed ordering is alright here, as knowledge of the original reference\n+        // prevents other threads from erroneously deleting the object.\n         //\n-        // As explained in the [Boost documentation][1], Increasing the\n-        // reference counter can always be done with memory_order_relaxed: New\n-        // references to an object can only be formed from an existing\n-        // reference, and passing an existing reference from one thread to\n-        // another must already provide any required synchronization.\n+        // As explained in the [Boost documentation][1], Increasing the reference counter can\n+        // always be done with memory_order_relaxed: New references to an object can only be formed\n+        // from an existing reference, and passing an existing reference from one thread to another\n+        // must already provide any required synchronization.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         self.inner().strong.fetch_add(1, atomic::Relaxed);\n@@ -172,26 +244,33 @@ impl<T> Deref<T> for Arc<T> {\n }\n \n impl<T: Send + Sync + Clone> Arc<T> {\n-    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n-    /// the reference count is one (no sharing is possible).\n+    /// Make a mutable reference from the given `Arc<T>`.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n+    /// the reference count is greater than one.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::new(5i);\n+    ///\n+    /// let mut_five = five.make_unique();\n+    /// ```\n     #[inline]\n     #[experimental]\n     pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as\n-        // a weak reference, so we only clone if there is an\n-        // additional reference of either kind.\n+        // Note that we hold a strong reference, which also counts as a weak reference, so we only\n+        // clone if there is an additional reference of either kind.\n         if self.inner().strong.load(atomic::SeqCst) != 1 ||\n            self.inner().weak.load(atomic::SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n+        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n+        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n+        // this point, and we required the Arc itself to be `mut`, so we're returning the only\n+        // possible reference to the inner data.\n         let inner = unsafe { &mut *self._ptr };\n         &mut inner.data\n     }\n@@ -200,38 +279,59 @@ impl<T: Send + Sync + Clone> Arc<T> {\n #[unsafe_destructor]\n #[experimental = \"waiting on stability of Drop\"]\n impl<T: Sync + Send> Drop for Arc<T> {\n+    /// Drops the `Arc<T>`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference count becomes zero\n+    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n+        // it is guaranteed to be zeroed after the first if it's run more than once)\n         if self._ptr.is_null() { return }\n \n-        // Because `fetch_sub` is already atomic, we do not need to synchronize\n-        // with other threads unless we are going to delete the object. This\n-        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n+        // unless we are going to delete the object. This same logic applies to the below\n+        // `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, atomic::Release) != 1 { return }\n \n-        // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data. Because it is marked `Release`, the\n-        // decreasing of the reference count synchronizes with this `Acquire`\n-        // fence. This means that use of the data happens before decreasing\n-        // the reference count, which happens before this fence, which\n-        // happens before the deletion of the data.\n+        // This fence is needed to prevent reordering of use of the data and deletion of the data.\n+        // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n+        // this `Acquire` fence. This means that use of the data happens before decreasing the\n+        // reference count, which happens before this fence, which happens before the deletion of\n+        // the data.\n         //\n         // As explained in the [Boost documentation][1],\n         //\n-        // It is important to enforce any possible access to the object in\n-        // one thread (through an existing reference) to *happen before*\n-        // deleting the object in a different thread. This is achieved by a\n-        // \"release\" operation after dropping a reference (any access to the\n-        // object through this reference must obviously happened before),\n-        // and an \"acquire\" operation before deleting the object.\n+        // > It is important to enforce any possible access to the object in one thread (through an\n+        // > existing reference) to *happen before* deleting the object in a different thread. This\n+        // > is achieved by a \"release\" operation after dropping a reference (any access to the\n+        // > object through this reference must obviously happened before), and an \"acquire\"\n+        // > operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         atomic::fence(atomic::Acquire);\n \n-        // Destroy the data at this time, even though we may not free the box\n-        // allocation itself (there may still be weak pointers lying around).\n+        // Destroy the data at this time, even though we may not free the box allocation itself\n+        // (there may still be weak pointers lying around).\n         unsafe { drop(ptr::read(&self.inner().data)); }\n \n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n@@ -244,14 +344,26 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Weak<T> {\n-    /// Attempts to upgrade this weak reference to a strong reference.\n+    /// Upgrades a weak reference to a strong reference.\n+    ///\n+    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n+    ///\n+    /// Returns `None` if there were no strong references and the data was destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n     ///\n-    /// This method will not upgrade this reference if the strong reference count has already\n-    /// reached 0, but if there are still other active strong references this function will return\n-    /// a new strong reference to the data.\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// let weak_five = five.downgrade();\n+    ///\n+    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// ```\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 is must never be above 0.\n+        // We use a CAS loop to increment the strong count instead of a fetch_add because once the\n+        // count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n             let n = inner.strong.load(atomic::SeqCst);\n@@ -270,6 +382,19 @@ impl<T: Sync + Send> Weak<T> {\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak<T>`.\n+    ///\n+    /// This increases the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let weak_five = Arc::new(5i).downgrade();\n+    ///\n+    /// weak_five.clone();\n+    /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         // See comments in Arc::clone() for why this is relaxed\n@@ -281,13 +406,37 @@ impl<T: Sync + Send> Clone for Weak<T> {\n #[unsafe_destructor]\n #[experimental = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Drop for Weak<T> {\n+    /// Drops the `Weak<T>`.\n+    ///\n+    /// This will decrement the weak reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    ///     drop(weak_five); // explict drop\n+    /// }\n+    /// {\n+    ///     let five = Arc::new(5i);\n+    ///     let weak_five = five.downgrade();\n+    ///\n+    ///     // stuff\n+    ///\n+    /// } // implicit drop\n+    /// ```\n     fn drop(&mut self) {\n         // see comments above for why this check is here\n         if self._ptr.is_null() { return }\n \n-        // If we find out that we were the last weak pointer, then its time to\n-        // deallocate the data entirely. See the discussion in Arc::drop() about\n-        // the memory orderings\n+        // If we find out that we were the last weak pointer, then its time to deallocate the data\n+        // entirely. See the discussion in Arc::drop() about the memory orderings\n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n             unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n@@ -298,18 +447,114 @@ impl<T: Sync + Send> Drop for Weak<T> {\n \n #[unstable = \"waiting on PartialEq\"]\n impl<T: PartialEq> PartialEq for Arc<T> {\n+    /// Equality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are equal if their inner value are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five == Arc::new(5i);\n+    /// ```\n     fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n+\n+    /// Inequality for two `Arc<T>`s.\n+    ///\n+    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five != Arc::new(5i);\n+    /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n #[unstable = \"waiting on PartialOrd\"]\n impl<T: PartialOrd> PartialOrd for Arc<T> {\n+    /// Partial comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five.partial_cmp(&Arc::new(5i));\n+    /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n+\n+    /// Less-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five < Arc::new(5i);\n+    /// ```\n     fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n+\n+    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five <= Arc::new(5i);\n+    /// ```\n     fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n-    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n+\n+    /// Greater-than comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five > Arc::new(5i);\n+    /// ```\n     fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n+\n+    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5i);\n+    ///\n+    /// five >= Arc::new(5i);\n+    /// ```\n+    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }\n #[unstable = \"waiting on Ord\"]\n impl<T: Ord> Ord for Arc<T> {"}, {"sha": "5fd234192c515f9f879e580748d9c9f149140244", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -22,6 +22,7 @@ use core::option::Option;\n use core::raw::TraitObject;\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n+use core::ops::{Deref, DerefMut};\n \n /// A value that represents the global exchange heap. This is the default\n /// place that the `box` keyword allocates into when no place is supplied.\n@@ -57,7 +58,7 @@ impl<T> Default for Box<[T]> {\n     fn default() -> Box<[T]> { box [] }\n }\n \n-#[unstable]\n+#[stable]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a copy of the owned box.\n     #[inline]\n@@ -147,6 +148,14 @@ impl fmt::Show for Box<Any+'static> {\n     }\n }\n \n+impl<Sized? T> Deref<T> for Box<T> {\n+    fn deref(&self) -> &T { &**self }\n+}\n+\n+impl<Sized? T> DerefMut<T> for Box<T> {\n+    fn deref_mut(&mut self) -> &mut T { &mut **self }\n+}\n+\n #[cfg(test)]\n mod test {\n     #[test]\n@@ -193,4 +202,10 @@ mod test {\n         let s = format!(\"{}\", b);\n         assert_eq!(s, \"&Any\");\n     }\n+\n+    #[test]\n+    fn deref() {\n+        fn homura<T: Deref<i32>>(_: T) { }\n+        homura(box 765i32);\n+    }\n }"}, {"sha": "dfa55848c90dadf65bd4bb8ed596b55e3c550115", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -168,12 +168,12 @@ struct RcBox<T> {\n \n /// An immutable reference-counted pointer type.\n ///\n-/// See the [module level documentation](../index.html) for more.\n+/// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n+    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n+    // type via Deref\n     _ptr: *mut RcBox<T>,\n     _nosend: marker::NoSend,\n     _noshare: marker::NoSync\n@@ -193,11 +193,9 @@ impl<T> Rc<T> {\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n-                // there is an implicit weak pointer owned by all the\n-                // strong pointers, which ensures that the weak\n-                // destructor never frees the allocation while the\n-                // strong destructor is running, even if the weak\n-                // pointer is stored inside the strong one.\n+                // there is an implicit weak pointer owned by all the strong pointers, which\n+                // ensures that the weak destructor never frees the allocation while the strong\n+                // destructor is running, even if the weak pointer is stored inside the strong one.\n                 _ptr: transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n@@ -341,11 +339,10 @@ impl<T: Clone> Rc<T> {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n+        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n+        // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n+        // possible reference to the inner value.\n         let inner = unsafe { &mut *self._ptr };\n         &mut inner.value\n     }\n@@ -399,8 +396,8 @@ impl<T> Drop for Rc<T> {\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n \n-                    // remove the implicit \"strong weak\" pointer now\n-                    // that we've destroyed the contents.\n+                    // remove the implicit \"strong weak\" pointer now that we've destroyed the\n+                    // contents.\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n@@ -413,7 +410,7 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n-#[unstable = \"Clone is unstable.\"]\n+#[stable]\n impl<T> Clone for Rc<T> {\n     /// Makes a clone of the `Rc<T>`.\n     ///\n@@ -687,8 +684,8 @@ impl<T> Drop for Weak<T> {\n         unsafe {\n             if !self._ptr.is_null() {\n                 self.dec_weak();\n-                // the weak count starts at 1, and will only go to\n-                // zero if all the strong pointers have disappeared.\n+                // the weak count starts at 1, and will only go to zero if all the strong pointers\n+                // have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(self._ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())"}, {"sha": "0840e8ec881cd0bde575913f6167d63e5b84cc46", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -239,7 +239,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+    pub fn iter(&self) -> Items<T> {\n         Items { iter: self.data.iter() }\n     }\n \n@@ -280,8 +280,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.top(), Some(&5i));\n     ///\n     /// ```\n-    pub fn top<'a>(&'a self) -> Option<&'a T> {\n-        if self.is_empty() { None } else { Some(&self.data[0]) }\n+    pub fn top(&self) -> Option<&T> {\n+        self.data.get(0)\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating.\n@@ -392,9 +392,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n+        let old_len = self.len();\n         self.data.push(item);\n-        let new_len = self.len() - 1;\n-        self.siftup(0, new_len);\n+        self.siftup(0, old_len);\n     }\n \n     /// Pushes an item onto a queue then pops the greatest item off the queue in\n@@ -415,10 +415,16 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n-        if !self.is_empty() && *self.top().unwrap() > item {\n-            swap(&mut item, &mut self.data[0]);\n-            self.siftdown(0);\n+        match self.data.get_mut(0) {\n+            None => return item,\n+            Some(top) => if *top > item {\n+                swap(&mut item, top);\n+            } else {\n+                return item;\n+            },\n         }\n+\n+        self.siftdown(0);\n         item\n     }\n \n@@ -465,7 +471,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    pub fn into_vec(self) -> Vec<T> { let BinaryHeap{data: v} = self; v }\n+    pub fn into_vec(self) -> Vec<T> { self.data }\n \n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n@@ -482,15 +488,14 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// ```\n-    pub fn into_sorted_vec(self) -> Vec<T> {\n-        let mut q = self;\n-        let mut end = q.len();\n+    pub fn into_sorted_vec(mut self) -> Vec<T> {\n+        let mut end = self.len();\n         while end > 1 {\n             end -= 1;\n-            q.data.swap(0, end);\n-            q.siftdown_range(0, end)\n+            self.data.swap(0, end);\n+            self.siftdown_range(0, end)\n         }\n-        q.into_vec()\n+        self.into_vec()\n     }\n \n     // The implementations of siftup and siftdown use unsafe blocks in\n@@ -566,21 +571,21 @@ impl<T: Ord> BinaryHeap<T> {\n }\n \n /// `BinaryHeap` iterator.\n-pub struct Items <'a, T:'a> {\n+pub struct Items<'a, T: 'a> {\n     iter: slice::Items<'a, T>,\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(&'a T)> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n@@ -627,8 +632,7 @@ impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n \n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n-        let vec: Vec<T> = iter.collect();\n-        BinaryHeap::from_vec(vec)\n+        BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n@@ -822,20 +826,20 @@ mod tests {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n+        let mut heap = BinaryHeap::<int>::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n     fn test_empty_top() {\n-        let empty: BinaryHeap<int> = BinaryHeap::new();\n+        let empty = BinaryHeap::<int>::new();\n         assert!(empty.top().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n-        heap.replace(5).is_none();\n+        let mut heap = BinaryHeap::<int>::new();\n+        assert!(heap.replace(5).is_none());\n     }\n \n     #[test]"}, {"sha": "17dbf8a2cae9ecf6e6e096a6e7595b10903b2610", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -851,6 +851,7 @@ impl Extend<bool> for Bitv {\n     }\n }\n \n+#[stable]\n impl Clone for Bitv {\n     #[inline]\n     fn clone(&self) -> Bitv {"}, {"sha": "86c7def49b197e002ca3be7dca31f9b7311c71a9", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -390,6 +390,7 @@ impl<K, V> Node<K, V> {\n }\n \n // FIXME(gereeter) Write an efficient clone_from\n+#[stable]\n impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     fn clone(&self) -> Node<K, V> {\n         let mut ret = if self.is_leaf() {"}, {"sha": "e4328a3cb202bfc6e6e5432c02825d255c7ce45d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -448,30 +448,6 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> Sub<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a - b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2]);\n-    /// ```\n-    fn sub(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -493,30 +469,6 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitXor<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a ^ b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,4]);\n-    /// ```\n-    fn bitxor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -538,30 +490,6 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitAnd<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![2,3,4].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a & b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![2,3]);\n-    /// ```\n-    fn bitand(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n@@ -583,30 +511,6 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord + Clone> BitOr<BTreeSet<T>,BTreeSet<T>> for BTreeSet<T> {\n-    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let a: BTreeSet<int> = vec![1,2,3].into_iter().collect();\n-    /// let b: BTreeSet<int> = vec![3,4,5].into_iter().collect();\n-    ///\n-    /// let result: BTreeSet<int> = a | b;\n-    /// let result_vec: Vec<int> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1,2,3,4,5]);\n-    /// ```\n-    fn bitor(&self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///"}, {"sha": "d3c1a0f81a3367678b548c36ca016ae41437c874", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -758,6 +758,7 @@ impl<A: Ord> Ord for DList<A> {\n     }\n }\n \n+#[stable]\n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n         self.iter().map(|x| x.clone()).collect()"}, {"sha": "bb762f4fb4e408819287522e43141d47442b16d3", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -183,60 +183,24 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn sub(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitand(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n-    fn bitxor(&self, e: &EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}"}, {"sha": "aa0e33248fcc1575e4a539cb9dbb2ad69c51b5ab", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -48,6 +48,7 @@ pub struct RingBuf<T> {\n     ptr: *mut T\n }\n \n+#[stable]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n         self.iter().map(|t| t.clone()).collect()"}, {"sha": "bb03575b3ac271043173bb0c1ea9b77396a80c07", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -51,7 +51,7 @@\n \n #![doc(primitive = \"str\")]\n \n-pub use self::MaybeOwned::*;\n+use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n@@ -842,7 +842,7 @@ mod tests {\n     use core::iter::AdditiveIterator;\n     use super::{eq_slice, from_utf8, is_utf8, is_utf16, raw};\n     use super::truncate_utf16_at_nul;\n-    use super::{Owned, Slice};\n+    use super::MaybeOwned::{Owned, Slice};\n \n     #[test]\n     fn test_eq_slice() {"}, {"sha": "db59424cedd64c9b77104fed882fa29d85cd7017", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -26,7 +26,8 @@ use core::raw::Slice as RawSlice;\n \n use slice::CloneSliceExt;\n use str;\n-use str::{CharRange, CowString, FromStr, StrAllocating, Owned};\n+use str::{CharRange, CowString, FromStr, StrAllocating};\n+use str::MaybeOwned::Owned;\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -512,6 +513,11 @@ impl String {\n     #[inline]\n     #[stable = \"function just renamed from push_char\"]\n     pub fn push(&mut self, ch: char) {\n+        if (ch as u32) < 0x80 {\n+            self.vec.push(ch as u8);\n+            return;\n+        }\n+\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n         self.vec.reserve(4);\n@@ -856,43 +862,14 @@ impl<'a, S: Str> Equiv<S> for String {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n #[experimental = \"waiting on Add stabilization\"]\n-impl<S: Str> Add<S, String> for String {\n-    /// Concatenates `self` and `other` as a new mutable `String`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let string1 = \"foo\".to_string();\n-    /// let string2 = \"bar\".to_string();\n-    /// let string3 = string1 + string2;\n-    /// assert_eq!(string3, \"foobar\".to_string());\n-    /// ```\n-    fn add(&self, other: &S) -> String {\n-        let mut s = String::from_str(self.as_slice());\n-        s.push_str(other.as_slice());\n-        return s;\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl<'a> Add<&'a str, String> for String {\n     fn add(mut self, other: &str) -> String {\n         self.push_str(other);\n         self\n     }\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-impl<'a> Add<String, String> for &'a str {\n-    fn add(self, mut other: String) -> String {\n-        other.push_str(self);\n-        other\n-    }\n-}\n-\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1408,6 +1385,41 @@ mod tests {\n         });\n     }\n \n+    const REPETITIONS: u64 = 10_000;\n+\n+    #[bench]\n+    fn bench_push_str_one_byte(b: &mut Bencher) {\n+        b.bytes = REPETITIONS;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push_str(\"a\")\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_char_one_byte(b: &mut Bencher) {\n+        b.bytes = REPETITIONS;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push('a')\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_char_two_bytes(b: &mut Bencher) {\n+        b.bytes = REPETITIONS * 2;\n+        b.iter(|| {\n+            let mut r = String::new();\n+            for _ in range(0, REPETITIONS) {\n+                r.push('\u00e2')\n+            }\n+        });\n+    }\n+\n     #[bench]\n     fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n         let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\"}, {"sha": "b82c7e4cba27b5ed0c44804637989b93933f0ef8", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -53,6 +53,7 @@ use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n use core::hash::{mod, Hash};\n+use core::iter::repeat;\n use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n@@ -411,6 +412,33 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n+    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    ///\n+    /// Calls either `extend()` or `truncate()` depending on whether `new_len`\n+    /// is larger than the current value of `len()` or not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec![\"hello\"];\n+    /// vec.resize(3, \"world\");\n+    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    ///\n+    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// vec.resize(2, 0);\n+    /// assert_eq!(vec, vec![1, 2]);\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting for dust to settle\"]\n+    pub fn resize(&mut self, new_len: uint, value: T) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend(repeat(value).take(new_len - len));\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n+\n     /// Partitions a vector based on a predicate.\n     ///\n     /// Clones the elements of the vector, partitioning them into two `Vec<T>`s\n@@ -442,7 +470,7 @@ impl<T: Clone> Vec<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { self.as_slice().to_vec() }\n \n@@ -1334,20 +1362,6 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Clone, Sized? V: AsSlice<T>> Add<V, Vec<T>> for Vec<T> {\n-    #[inline]\n-    fn add(&self, rhs: &V) -> Vec<T> {\n-        let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n-        res.push_all(self.as_slice());\n-        res.push_all(rhs.as_slice());\n-        res\n-    }\n-}\n-\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n     #[inline]\n     fn add(mut self, rhs: &[T]) -> Vec<T> {\n@@ -1356,15 +1370,6 @@ impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n     }\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove impl after a snapshot\n-impl<'a, T: Clone> Add<Vec<T>, Vec<T>> for &'a [T] {\n-    #[inline]\n-    fn add(self, mut rhs: Vec<T>) -> Vec<T> {\n-        rhs.push_all(self);\n-        rhs\n-    }\n-}\n-\n #[unsafe_destructor]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {"}, {"sha": "e85a132ed363f5a2e6c85dceef701117913118ef", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -25,7 +25,7 @@ use option::Option;\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n-            #[unstable = \"waiting for Clone to stabilize\"]\n+            #[stable]\n             impl<T:Copy> Clone for [T, ..$N] {\n                 fn clone(&self) -> [T, ..$N] {\n                     *self\n@@ -115,4 +115,3 @@ array_impls! {\n     20 21 22 23 24 25 26 27 28 29\n     30 31 32\n }\n-"}, {"sha": "9bbcf67773ebbc966bc9081ea1bde77e0dbf34de", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -137,6 +137,7 @@ pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n+#[stable]\n impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {"}, {"sha": "b45424a5eed3f7d4209e62880fd653eed298cbe5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -164,7 +164,7 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n-#[unstable = \"likely to be renamed; otherwise stable\"]\n+#[stable]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n     noshare: marker::NoSync,\n@@ -208,7 +208,7 @@ impl<T:Copy> Cell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `Clone` trait to become stable\"]\n+#[stable]\n impl<T:Copy> Clone for Cell<T> {\n     fn clone(&self) -> Cell<T> {\n         Cell::new(self.get())\n@@ -231,7 +231,7 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n-#[unstable = \"likely to be renamed; otherwise stable\"]\n+#[stable]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n     borrow: Cell<BorrowFlag>,\n@@ -256,7 +256,7 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n-    #[unstable = \"recently renamed per RFC 430\"]\n+    #[stable]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n         // compiler statically verifies that it is not currently borrowed.\n@@ -275,7 +275,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable = \"may be renamed, depending on global conventions\"]\n+    #[unstable = \"may be renamed or removed\"]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -291,7 +291,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n-    #[unstable]\n+    #[stable]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n             Some(ptr) => ptr,\n@@ -305,7 +305,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable = \"may be renamed, depending on global conventions\"]\n+    #[unstable = \"may be renamed or removed\"]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -321,7 +321,7 @@ impl<T> RefCell<T> {\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n-    #[unstable]\n+    #[stable]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n             Some(ptr) => ptr,\n@@ -341,7 +341,7 @@ impl<T> RefCell<T> {\n     }\n }\n \n-#[unstable = \"waiting for `Clone` to become stable\"]\n+#[stable]\n impl<T: Clone> Clone for RefCell<T> {\n     fn clone(&self) -> RefCell<T> {\n         RefCell::new(self.borrow().clone())\n@@ -400,7 +400,7 @@ impl<'b> Clone for BorrowRef<'b> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n+#[stable]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -456,7 +456,7 @@ impl<'b> BorrowRefMut<'b> {\n }\n \n /// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n-#[unstable]\n+#[stable]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -517,7 +517,7 @@ impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n /// is not recommended to access its fields directly, `get` should be used\n /// instead.\n #[lang=\"unsafe\"]\n-#[unstable = \"this type may be renamed in the future\"]\n+#[stable]\n pub struct UnsafeCell<T> {\n     /// Wrapped value\n     ///\n@@ -539,22 +539,16 @@ impl<T> UnsafeCell<T> {\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n-    ///\n-    /// This function is unsafe as the pointer returned is an unsafe pointer and\n-    /// no guarantees are made about the aliasing of the pointers being handed\n-    /// out in this or other tasks.\n     #[inline]\n-    #[unstable = \"conventions around acquiring an inner reference are still \\\n-                  under development\"]\n-    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n+    #[stable]\n+    pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n     /// This function is unsafe because there is no guarantee that this or other\n     /// tasks are currently inspecting the inner value.\n     #[inline]\n-    #[unstable = \"conventions around the name `unwrap` are still under \\\n-                  development\"]\n+    #[stable]\n     pub unsafe fn into_inner(self) -> T { self.value }\n \n     /// Deprecated, use into_inner() instead"}, {"sha": "686ccf6f1a2513c25e2c7dfd5aa2265d11b90ccb", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -19,13 +19,15 @@\n //! explicitly, by convention implementing the `Clone` trait and calling\n //! the `clone` method.\n \n-#![unstable]\n+#![stable]\n \n use kinds::Sized;\n \n /// A common trait for cloning an object.\n+#[stable]\n pub trait Clone {\n     /// Returns a copy of the value.\n+    #[stable]\n     fn clone(&self) -> Self;\n \n     /// Perform copy-assignment from `source`.\n@@ -34,12 +36,13 @@ pub trait Clone {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[experimental = \"this function is mostly unused\"]\n+    #[unstable = \"this function rarely unused\"]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n     }\n }\n \n+#[stable]\n impl<'a, Sized? T> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n@@ -48,6 +51,7 @@ impl<'a, Sized? T> Clone for &'a T {\n \n macro_rules! clone_impl {\n     ($t:ty) => {\n+        #[stable]\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]\n@@ -95,4 +99,3 @@ extern_fn_clone! { A, B, C, D, E }\n extern_fn_clone! { A, B, C, D, E, F }\n extern_fn_clone! { A, B, C, D, E, F, G }\n extern_fn_clone! { A, B, C, D, E, F, G, H }\n-"}, {"sha": "ab6b0986c686df72b92a04b0aa93a2faa7d06cf6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -195,6 +195,7 @@ impl Writer for SipState {\n     }\n }\n \n+#[stable]\n impl Clone for SipState {\n     #[inline]\n     fn clone(&self) -> SipState {"}, {"sha": "950c47c636987082964acdc9c679c0da12994cac", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -222,7 +222,7 @@ extern \"rust-intrinsic\" {\n     /// Both types must have the same size and alignment, and this guarantee\n     /// is enforced at compile-time.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// use std::mem;\n@@ -253,14 +253,20 @@ extern \"rust-intrinsic\" {\n     /// integer, since the conversion would throw away aliasing information.\n     pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n \n-    /// Copies data from one location to another.\n-    ///\n-    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may *not* overlap.\n     ///\n     /// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n     ///\n-    /// # Example\n+    /// # Safety\n+    ///\n+    /// Beyond requiring that both regions of memory be allocated, it is Undefined Behaviour\n+    /// for source and destination to overlap. Care must also be taken with the ownership of\n+    /// `src` and `dst`. This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n+    ///\n+    /// # Examples\n     ///\n     /// A safe swap function:\n     ///\n@@ -284,22 +290,22 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    ///\n-    /// # Safety Note\n-    ///\n-    /// If the source and destination overlap then the behavior of this\n-    /// function is undefined.\n     #[unstable]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n-    /// Copies data from one location to another.\n-    ///\n-    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n     /// `copy_memory` is semantically equivalent to C's `memmove`.\n     ///\n-    /// # Example\n+    /// # Safety\n+    ///\n+    /// Care must be taken with the ownership of `src` and `dst`.\n+    /// This method semantically moves the values of `src` into `dst`.\n+    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n+    /// from being dropped or used.\n+    ///\n+    /// # Examples\n     ///\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///"}, {"sha": "b592d1db274f63ec9b5dc37a7c2d2056250ae426", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1386,6 +1386,7 @@ pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     I: Clone + Iterator<A>,\n     F: Clone + FnMut(A) -> B,\n@@ -1460,6 +1461,7 @@ pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, I, P> Clone for Filter<A, I, P> where\n     I: Clone + Iterator<A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1518,6 +1520,7 @@ pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B>\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     I: Clone + Iterator<A>,\n     F: Clone + FnMut(A) -> Option<B>,\n@@ -1693,6 +1696,7 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     I: Clone + Iterator<A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1736,6 +1740,7 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     I: Clone + Iterator<A>,\n     P: Clone + FnMut(&A) -> bool,\n@@ -1911,6 +1916,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     I: Clone + Iterator<A>,\n     St: Clone,\n@@ -1955,6 +1961,7 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     I: Clone + Iterator<A>,\n     U: Clone + Iterator<B>,\n@@ -2115,6 +2122,7 @@ pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n     I: Clone + Iterator<A>,\n     F: Clone + FnMut(&A),\n@@ -2222,6 +2230,7 @@ pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<A, St, F> Clone for Unfold<A, St, F> where\n     F: Clone + FnMut(&mut St) -> Option<A>,\n     St: Clone,"}, {"sha": "b0f46e3d68c908a1850962274d83ba5007f03945", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -91,7 +91,8 @@ pub trait Sync for Sized? {\n /// implemented using unsafe code. In that case, you may want to embed\n /// some of the marker types below into your type.\n pub mod marker {\n-    use super::Copy;\n+    use super::{Copy,Sized};\n+    use clone::Clone;\n \n     /// A marker type whose type parameter `T` is considered to be\n     /// covariant with respect to the type itself. This is (typically)\n@@ -131,10 +132,13 @@ pub mod marker {\n     /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n     /// for some lifetime `'a`, but not the other way around).\n     #[lang=\"covariant_type\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantType<T>;\n+    #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct CovariantType<Sized? T>;\n \n-    impl<T> Copy for CovariantType<T> {}\n+    impl<Sized? T> Copy for CovariantType<T> {}\n+    impl<Sized? T> Clone for CovariantType<T> {\n+        fn clone(&self) -> CovariantType<T> { *self }\n+    }\n \n     /// A marker type whose type parameter `T` is considered to be\n     /// contravariant with respect to the type itself. This is (typically)\n@@ -176,10 +180,13 @@ pub mod marker {\n     /// function requires arguments of type `T`, it must also accept\n     /// arguments of type `U`, hence such a conversion is safe.\n     #[lang=\"contravariant_type\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantType<T>;\n+    #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct ContravariantType<Sized? T>;\n \n-    impl<T> Copy for ContravariantType<T> {}\n+    impl<Sized? T> Copy for ContravariantType<T> {}\n+    impl<Sized? T> Clone for ContravariantType<T> {\n+        fn clone(&self) -> ContravariantType<T> { *self }\n+    }\n \n     /// A marker type whose type parameter `T` is considered to be\n     /// invariant with respect to the type itself. This is (typically)\n@@ -203,10 +210,13 @@ pub mod marker {\n     /// never written, but in fact `Cell` uses unsafe code to achieve\n     /// interior mutability.\n     #[lang=\"invariant_type\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantType<T>;\n+    #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct InvariantType<Sized? T>;\n \n-    impl<T> Copy for InvariantType<T> {}\n+    impl<Sized? T> Copy for InvariantType<T> {}\n+    impl<Sized? T> Clone for InvariantType<T> {\n+        fn clone(&self) -> InvariantType<T> { *self }\n+    }\n \n     /// As `CovariantType`, but for lifetime parameters. Using\n     /// `CovariantLifetime<'a>` indicates that it is ok to substitute\n@@ -252,11 +262,9 @@ pub mod marker {\n     /// and this pointer is itself stored in an inherently mutable\n     /// location (such as a `Cell`).\n     #[lang=\"invariant_lifetime\"]\n-    #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    #[deriving(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct InvariantLifetime<'a>;\n \n-    impl<'a> Copy for InvariantLifetime<'a> {}\n-\n     /// A type which is considered \"not sendable\", meaning that it cannot\n     /// be safely sent between tasks, even if it is owned. This is\n     /// typically embedded in other types, such as `Gc`, to ensure that"}, {"sha": "9b6622a7127d5de26b2e20c4b9f44566cbac6cd1", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -107,7 +107,6 @@ pub mod default;\n \n pub mod any;\n pub mod atomic;\n-pub mod bool;\n pub mod borrow;\n pub mod cell;\n pub mod char;\n@@ -120,15 +119,11 @@ pub mod result;\n pub mod simd;\n pub mod slice;\n pub mod str;\n-pub mod tuple;\n pub mod hash;\n-// FIXME #15320: primitive documentation needs top-level modules, this\n-// should be `core::tuple::unit`.\n-#[path = \"tuple/unit.rs\"]\n-pub mod unit;\n pub mod fmt;\n \n // note: does not need to be public\n+mod tuple;\n mod array;\n \n #[doc(hidden)]"}, {"sha": "91c5e4163f9e598ded24217da81749c648309a81", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,9 +10,8 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n-#![unstable]\n+#![stable]\n #![doc(primitive = \"int\")]\n \n #[cfg(target_word_size = \"32\")] int_module! { int, 32 }\n #[cfg(target_word_size = \"64\")] int_module! { int, 64 }\n-"}, {"sha": "522eab9180c86bce7bc2c85d575ccb143c922630", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -24,13 +24,12 @@ pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-#[unstable]\n+#[stable]\n pub const MIN: $T = (-1 as $T) << (BITS - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-#[unstable]\n+#[stable]\n pub const MAX: $T = !MIN;\n \n ) }\n-"}, {"sha": "35739f68da9697af17efd96a5321b23afc112a56", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,8 +10,7 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n-#![unstable]\n+#![stable]\n #![doc(primitive = \"uint\")]\n \n uint_module! { uint, int, ::int::BITS }\n-"}, {"sha": "82eca0d46598204a08f0aa63ce0f447207f76f10", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -18,10 +18,9 @@ pub const BITS : uint = $bits;\n #[unstable]\n pub const BYTES : uint = ($bits / 8);\n \n-#[unstable]\n+#[stable]\n pub const MIN: $T = 0 as $T;\n-#[unstable]\n+#[stable]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n ) }\n-"}, {"sha": "e752fd11ee5b27fe41194cf02cdec9cb241c8204", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -92,46 +92,6 @@ pub trait Drop {\n /// struct Foo;\n ///\n /// impl Add<Foo, Foo> for Foo {\n-///     fn add(&self, _rhs: &Foo) -> Foo {\n-///       println!(\"Adding!\");\n-///       *self\n-///   }\n-/// }\n-///\n-/// fn main() {\n-///   Foo + Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"add\"]\n-pub trait Add<Sized? RHS,Result> for Sized? {\n-    /// The method for the `+` operator\n-    fn add(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! add_impl {\n-    ($($t:ty)*) => ($(\n-        impl Add<$t, $t> for $t {\n-            #[inline]\n-            fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Add` trait is used to specify the functionality of `+`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n-/// calling `add`, and therefore, `main` prints `Adding!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Add<Foo, Foo> for Foo {\n ///     fn add(self, _rhs: Foo) -> Foo {\n ///       println!(\"Adding!\");\n ///       self\n@@ -142,14 +102,12 @@ macro_rules! add_impl {\n ///   Foo + Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"add\"]\n pub trait Add<RHS, Result> {\n     /// The method for the `+` operator\n     fn add(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n@@ -173,46 +131,6 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Sub<Foo, Foo> for Foo {\n-///     fn sub(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Subtracting!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo - Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"sub\"]\n-pub trait Sub<Sized? RHS, Result> for Sized? {\n-    /// The method for the `-` operator\n-    fn sub(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! sub_impl {\n-    ($($t:ty)*) => ($(\n-        impl Sub<$t, $t> for $t {\n-            #[inline]\n-            fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Sub` trait is used to specify the functionality of `-`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n-/// calling `sub`, and therefore, `main` prints `Subtracting!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Sub<Foo, Foo> for Foo {\n ///     fn sub(self, _rhs: Foo) -> Foo {\n ///         println!(\"Subtracting!\");\n ///         self\n@@ -223,14 +141,12 @@ macro_rules! sub_impl {\n ///     Foo - Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"sub\"]\n pub trait Sub<RHS, Result> {\n     /// The method for the `-` operator\n     fn sub(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n@@ -254,46 +170,6 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Mul<Foo, Foo> for Foo {\n-///     fn mul(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Multiplying!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo * Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"mul\"]\n-pub trait Mul<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `*` operator\n-    fn mul(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! mul_impl {\n-    ($($t:ty)*) => ($(\n-        impl Mul<$t, $t> for $t {\n-            #[inline]\n-            fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Mul` trait is used to specify the functionality of `*`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n-/// calling `mul`, and therefore, `main` prints `Multiplying!`.\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Mul<Foo, Foo> for Foo {\n ///     fn mul(self, _rhs: Foo) -> Foo {\n ///         println!(\"Multiplying!\");\n ///         self\n@@ -304,14 +180,12 @@ macro_rules! mul_impl {\n ///     Foo * Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"mul\"]\n pub trait Mul<RHS, Result> {\n     /// The method for the `*` operator\n     fn mul(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n@@ -335,46 +209,6 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Div<Foo, Foo> for Foo {\n-///     fn div(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Dividing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo / Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"div\"]\n-pub trait Div<Sized? RHS, Result> for Sized? {\n-    /// The method for the `/` operator\n-    fn div(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! div_impl {\n-    ($($t:ty)*) => ($(\n-        impl Div<$t, $t> for $t {\n-            #[inline]\n-            fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Div` trait is used to specify the functionality of `/`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n-/// calling `div`, and therefore, `main` prints `Dividing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Div<Foo, Foo> for Foo {\n ///     fn div(self, _rhs: Foo) -> Foo {\n ///         println!(\"Dividing!\");\n ///         self\n@@ -385,14 +219,12 @@ macro_rules! div_impl {\n ///     Foo / Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"div\"]\n pub trait Div<RHS, Result> {\n     /// The method for the `/` operator\n     fn div(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n@@ -416,60 +248,6 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// struct Foo;\n ///\n /// impl Rem<Foo, Foo> for Foo {\n-///     fn rem(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Remainder-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo % Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"rem\"]\n-pub trait Rem<Sized? RHS, Result>  for Sized? {\n-    /// The method for the `%` operator\n-    fn rem(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_impl {\n-    ($($t:ty)*) => ($(\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n-        }\n-    )*)\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! rem_float_impl {\n-    ($t:ty, $fmod:ident) => {\n-        impl Rem<$t, $t> for $t {\n-            #[inline]\n-            fn rem(&self, other: &$t) -> $t {\n-                extern { fn $fmod(a: $t, b: $t) -> $t; }\n-                unsafe { $fmod(*self, *other) }\n-            }\n-        }\n-    }\n-}\n-\n-/// The `Rem` trait is used to specify the functionality of `%`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n-/// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Rem<Foo, Foo> for Foo {\n ///     fn rem(self, _rhs: Foo) -> Foo {\n ///         println!(\"Remainder-ing!\");\n ///         self\n@@ -480,14 +258,12 @@ macro_rules! rem_float_impl {\n ///     Foo % Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"rem\"]\n pub trait Rem<RHS, Result> {\n     /// The method for the `%` operator\n     fn rem(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n@@ -497,7 +273,6 @@ macro_rules! rem_impl {\n     )*)\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n@@ -721,46 +496,6 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitAnd<Foo, Foo> for Foo {\n-///     fn bitand(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise And-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo & Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitand\"]\n-pub trait BitAnd<Sized? RHS, Result> for Sized? {\n-    /// The method for the `&` operator\n-    fn bitand(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitand_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitAnd<$t, $t> for $t {\n-            #[inline]\n-            fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitAnd` trait is used to specify the functionality of `&`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n-/// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitAnd<Foo, Foo> for Foo {\n ///     fn bitand(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise And-ing!\");\n ///         self\n@@ -771,14 +506,12 @@ macro_rules! bitand_impl {\n ///     Foo & Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS, Result> {\n     /// The method for the `&` operator\n     fn bitand(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n@@ -802,46 +535,6 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitOr<Foo, Foo> for Foo {\n-///     fn bitor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Or-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo | Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitor\"]\n-pub trait BitOr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `|` operator\n-    fn bitor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitOr<$t,$t> for $t {\n-            #[inline]\n-            fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitOr` trait is used to specify the functionality of `|`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n-/// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitOr<Foo, Foo> for Foo {\n ///     fn bitor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Or-ing!\");\n ///         self\n@@ -852,14 +545,12 @@ macro_rules! bitor_impl {\n ///     Foo | Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitor\"]\n pub trait BitOr<RHS, Result> {\n     /// The method for the `|` operator\n     fn bitor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n@@ -883,46 +574,6 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl BitXor<Foo, Foo> for Foo {\n-///     fn bitxor(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Bitwise Xor-ing!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo ^ Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"bitxor\"]\n-pub trait BitXor<Sized? RHS, Result> for Sized? {\n-    /// The method for the `^` operator\n-    fn bitxor(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! bitxor_impl {\n-    ($($t:ty)*) => ($(\n-        impl BitXor<$t, $t> for $t {\n-            #[inline]\n-            fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `BitXor` trait is used to specify the functionality of `^`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n-/// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl BitXor<Foo, Foo> for Foo {\n ///     fn bitxor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Xor-ing!\");\n ///         self\n@@ -933,14 +584,12 @@ macro_rules! bitxor_impl {\n ///     Foo ^ Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS, Result> {\n     /// The method for the `^` operator\n     fn bitxor(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n@@ -964,48 +613,6 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl Shl<Foo, Foo> for Foo {\n-///     fn shl(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting left!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo << Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shl\"]\n-pub trait Shl<Sized? RHS, Result> for Sized? {\n-    /// The method for the `<<` operator\n-    fn shl(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shl_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shl<uint, $t> for $t {\n-            #[inline]\n-            fn shl(&self, other: &uint) -> $t {\n-                (*self) << (*other)\n-            }\n-        }\n-    )*)\n-}\n-\n-/// The `Shl` trait is used to specify the functionality of `<<`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n-/// calling `shl`, and therefore, `main` prints `Shifting left!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shl<Foo, Foo> for Foo {\n ///     fn shl(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting left!\");\n ///         self\n@@ -1016,14 +623,12 @@ macro_rules! shl_impl {\n ///     Foo << Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shl\"]\n pub trait Shl<RHS, Result> {\n     /// The method for the `<<` operator\n     fn shl(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n@@ -1049,46 +654,6 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// struct Foo;\n ///\n /// impl Shr<Foo, Foo> for Foo {\n-///     fn shr(&self, _rhs: &Foo) -> Foo {\n-///         println!(\"Shifting right!\");\n-///         *self\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     Foo >> Foo;\n-/// }\n-/// ```\n-// NOTE(stage0): Remove trait after a snapshot\n-#[cfg(stage0)]\n-#[lang=\"shr\"]\n-pub trait Shr<Sized? RHS, Result> for Sized? {\n-    /// The method for the `>>` operator\n-    fn shr(&self, rhs: &RHS) -> Result;\n-}\n-\n-// NOTE(stage0): Remove macro after a snapshot\n-#[cfg(stage0)]\n-macro_rules! shr_impl {\n-    ($($t:ty)*) => ($(\n-        impl Shr<uint, $t> for $t {\n-            #[inline]\n-            fn shr(&self, other: &uint) -> $t { (*self) >> (*other) }\n-        }\n-    )*)\n-}\n-\n-/// The `Shr` trait is used to specify the functionality of `>>`.\n-///\n-/// # Example\n-///\n-/// A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n-/// calling `shr`, and therefore, `main` prints `Shifting right!`.\n-///\n-/// ```\n-/// struct Foo;\n-///\n-/// impl Shr<Foo, Foo> for Foo {\n ///     fn shr(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting right!\");\n ///         self\n@@ -1099,14 +664,12 @@ macro_rules! shr_impl {\n ///     Foo >> Foo;\n /// }\n /// ```\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n #[lang=\"shr\"]\n pub trait Shr<RHS, Result> {\n     /// The method for the `>>` operator\n     fn shr(self, rhs: RHS) -> Result;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {"}, {"sha": "8adbba8b94b87492f3d16cded48167159bda36b0", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -819,6 +819,7 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n \n impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n \n+#[stable]\n impl<'a, A> Clone for Iter<'a, A> {\n     fn clone(&self) -> Iter<'a, A> {\n         Iter { inner: self.inner.clone() }"}, {"sha": "b226d4a6de45d1e5e0e6665a6910e21558db048f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -97,13 +97,20 @@ use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n use cmp::Ordering::{Less, Equal, Greater};\n \n-pub use intrinsics::copy_memory;\n+// FIXME #19649: instrinsic docs don't render, so these have no docs :(\n+\n+#[unstable]\n pub use intrinsics::copy_nonoverlapping_memory;\n+\n+#[unstable]\n+pub use intrinsics::copy_memory;\n+\n+#[experimental = \"uncertain about naming and semantics\"]\n pub use intrinsics::set_memory;\n \n-/// Create a null pointer.\n+/// Creates a null raw pointer.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::ptr;\n@@ -115,9 +122,9 @@ pub use intrinsics::set_memory;\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n-/// Create an unsafe mutable null pointer.\n+/// Creates a null mutable raw pointer.\n ///\n-/// # Example\n+/// # Examples\n ///\n /// ```\n /// use std::ptr;\n@@ -129,16 +136,26 @@ pub fn null<T>() -> *const T { 0 as *const T }\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n-/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n+/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be `0`.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it will not drop the contents of `dst`,\n+/// and may be used to create invalid instances of `T`.\n #[inline]\n #[experimental = \"uncertain about naming and semantics\"]\n #[allow(experimental)]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n-/// Swap the values at two mutable locations of the same type, without\n-/// deinitialising either. They may overlap.\n+/// Swaps the values at two mutable locations of the same type, without\n+/// deinitialising either. They may overlap, unlike `mem::swap` which is otherwise\n+/// equivalent.\n+///\n+/// # Safety\n+///\n+/// This is only unsafe because it accepts a raw pointer.\n #[inline]\n #[unstable]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n@@ -156,16 +173,31 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     mem::forget(tmp);\n }\n \n-/// Replace the value at a mutable location with a new one, returning the old\n-/// value, without deinitialising either.\n+/// Replaces the value at `dest` with `src`, returning the old\n+/// value, without dropping either.\n+///\n+/// # Safety\n+///\n+/// This is only unsafe because it accepts a raw pointer.\n+/// Otherwise, this operation is identical to `mem::replace`.\n #[inline]\n #[unstable]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(mem::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n-/// Reads the value from `*src` and returns it.\n+/// Reads the value from `src` without dropping it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n #[inline(always)]\n #[unstable]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -174,8 +206,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n-/// Reads the value from `*src` and nulls it out.\n-/// This currently prevents destructors from executing.\n+/// Reads the value from `src` and nulls it out without dropping it.\n+///\n+/// # Safety\n+///\n+/// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n #[experimental]\n #[allow(experimental)]\n@@ -189,12 +224,17 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n-/// Unsafely overwrite a memory location with the given value without destroying\n+/// Overwrites a memory location with the given value without reading or dropping\n /// the old value.\n ///\n-/// This operation is unsafe because it does not destroy the previous value\n-/// contained at the location `dst`. This could leak allocations or resources,\n-/// so care must be taken to previously deallocate the value at `dst`.\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this operation is unsafe because it does\n+/// not drop the contents of `dst`. This could leak allocations or resources,\n+/// so care must be taken not to overwrite an object that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwritting memory\n+/// that has previously been `read` from.\n #[inline]\n #[unstable]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -203,39 +243,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n pub trait RawPtr<T> {\n-    /// Returns the null pointer.\n+    /// Returns a null raw pointer.\n     fn null() -> Self;\n \n-    /// Returns true if the pointer is equal to the null pointer.\n+    /// Returns true if the pointer is null.\n     fn is_null(&self) -> bool;\n \n-    /// Returns true if the pointer is not equal to the null pointer.\n+    /// Returns true if the pointer is not null.\n     fn is_not_null(&self) -> bool { !self.is_null() }\n \n-    /// Returns the value of this pointer (ie, the address it points to)\n+    /// Returns the address of the pointer.\n     fn to_uint(&self) -> uint;\n \n     /// Returns `None` if the pointer is null, or else returns a reference to the\n     /// value wrapped in `Some`.\n     ///\n-    /// # Safety Notes\n+    /// # Safety\n     ///\n     /// While this method and its mutable counterpart are useful for null-safety,\n     /// it is important to note that this is still an unsafe operation because\n     /// the returned value could be pointing to invalid memory.\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n \n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n+    /// Calculates the offset from a pointer. `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The offset must be in-bounds of the object, or one-byte-past-the-end. Otherwise\n+    /// `offset` invokes Undefined Behaviour, regardless of whether the pointer is used.\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Methods on mutable raw pointers\n pub trait RawMutPtr<T>{\n     /// Returns `None` if the pointer is null, or else returns a mutable reference\n-    /// to the value wrapped in `Some`. As with `as_ref`, this is unsafe because\n-    /// it cannot verify the validity of the returned pointer.\n+    /// to the value wrapped in `Some`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with `as_ref`, this is unsafe because it cannot verify the validity\n+    /// of the returned pointer.\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n }\n \n@@ -340,13 +388,15 @@ impl<T> Equiv<*const T> for *mut T {\n     }\n }\n \n+#[stable]\n impl<T> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n+#[stable]\n impl<T> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -451,4 +501,3 @@ impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }\n-"}, {"sha": "efc92429afdf1e5f7b0717b70f37de03b5cdbfa2", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -781,7 +781,7 @@ iterator!{struct Items -> *const T, &'a T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n \n-#[experimental = \"needs review\"]\n+#[stable]\n impl<'a, T> Clone for Items<'a, T> {\n     fn clone(&self) -> Items<'a, T> { *self }\n }\n@@ -893,6 +893,7 @@ pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+#[stable]\n impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n     fn clone(&self) -> Splits<'a, T, P> {\n         Splits {\n@@ -1550,4 +1551,3 @@ impl_int_slice! { u16,  i16 }\n impl_int_slice! { u32,  i32 }\n impl_int_slice! { u64,  i64 }\n impl_int_slice! { uint, int }\n-"}, {"sha": "89aed1487924227970786e3c82cd2a9ab37e823e", "filename": "src/libcore/tuple.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -62,12 +62,10 @@\n //! assert_eq!(d, (0u32, 0.0f32));\n //! ```\n \n-#![doc(primitive = \"tuple\")]\n #![stable]\n \n #[unstable = \"this is just a documentation module and should not be part \\\n               of the public api\"]\n-pub use unit;\n \n use clone::Clone;\n use cmp::*;\n@@ -126,7 +124,7 @@ macro_rules! tuple_impls {\n                 )+\n             }\n \n-            #[unstable = \"waiting for Clone to stabilize\"]\n+            #[stable]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(e!(self.$idx.clone()),)+)\n@@ -328,4 +326,3 @@ tuple_impls! {\n         (val11, ref11, mut11, 11) -> L\n     }\n }\n-", "previous_filename": "src/libcore/tuple/mod.rs"}, {"sha": "fddd49c8d88f3d81794b0287ced9a23db9988bf1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -37,7 +37,7 @@ use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Context, LintPass, LintArray};\n \n use std::{cmp, slice};\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast, ast_map};\n@@ -1157,9 +1157,9 @@ impl LintPass for UnusedParens {\n             ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n             ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n             ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchNormal => (head, \"`match` head expression\", true),\n-                ast::MatchIfLetDesugar => (head, \"`if let` head expression\", true),\n-                ast::MatchWhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n             },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),"}, {"sha": "323b084afdc32b77b606fb763a2dec03de7dcfb8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -23,7 +23,7 @@ use plugin::load::PluginMetadata;\n use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;"}, {"sha": "e5dae926db950fd8398cc2458a98b302e2263c6b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1478,6 +1478,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         if abi == abi::RustIntrinsic {\n             encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n         }\n+        encode_attributes(rbml_w, &*nitem.attrs);\n+        let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));\n+        encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n       }\n       ast::ForeignItemStatic(_, mutbl) => {\n@@ -1488,6 +1491,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n+        encode_attributes(rbml_w, &*nitem.attrs);\n+        let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));\n+        encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n       }"}, {"sha": "bc34b0b45e96fbf599dba7eebd07a6f797bdd15f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -228,7 +228,7 @@ use util::fs;\n \n use std::c_str::ToCStr;\n use std::cmp;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::{HashMap, HashSet};\n use std::io::fs::PathExtensions;\n use std::io;"}, {"sha": "ce63c467822db76b070ba7b18f2691e668ab4006", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -55,7 +55,103 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         None => {}\n     }\n     let pos = w.tell().unwrap();\n-    enc_sty(w, cx, &t.sty);\n+\n+    match t.sty {\n+        ty::ty_bool => mywrite!(w, \"b\"),\n+        ty::ty_char => mywrite!(w, \"c\"),\n+        ty::ty_int(t) => {\n+            match t {\n+                ast::TyI => mywrite!(w, \"i\"),\n+                ast::TyI8 => mywrite!(w, \"MB\"),\n+                ast::TyI16 => mywrite!(w, \"MW\"),\n+                ast::TyI32 => mywrite!(w, \"ML\"),\n+                ast::TyI64 => mywrite!(w, \"MD\")\n+            }\n+        }\n+        ty::ty_uint(t) => {\n+            match t {\n+                ast::TyU => mywrite!(w, \"u\"),\n+                ast::TyU8 => mywrite!(w, \"Mb\"),\n+                ast::TyU16 => mywrite!(w, \"Mw\"),\n+                ast::TyU32 => mywrite!(w, \"Ml\"),\n+                ast::TyU64 => mywrite!(w, \"Md\")\n+            }\n+        }\n+        ty::ty_float(t) => {\n+            match t {\n+                ast::TyF32 => mywrite!(w, \"Mf\"),\n+                ast::TyF64 => mywrite!(w, \"MF\"),\n+            }\n+        }\n+        ty::ty_enum(def, ref substs) => {\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal,\n+                                       ref bounds }) => {\n+            mywrite!(w, \"x[\");\n+            enc_trait_ref(w, cx, &principal.0);\n+            enc_existential_bounds(w, cx, bounds);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_tup(ref ts) => {\n+            mywrite!(w, \"T[\");\n+            for t in ts.iter() { enc_ty(w, cx, *t); }\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n+        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::ty_rptr(r, mt) => {\n+            mywrite!(w, \"&\");\n+            enc_region(w, cx, r);\n+            enc_mt(w, cx, mt);\n+        }\n+        ty::ty_vec(t, sz) => {\n+            mywrite!(w, \"V\");\n+            enc_ty(w, cx, t);\n+            mywrite!(w, \"/\");\n+            match sz {\n+                Some(n) => mywrite!(w, \"{}|\", n),\n+                None => mywrite!(w, \"|\"),\n+            }\n+        }\n+        ty::ty_str => {\n+            mywrite!(w, \"v\");\n+        }\n+        ty::ty_closure(ref f) => {\n+            mywrite!(w, \"f\");\n+            enc_closure_ty(w, cx, &**f);\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            mywrite!(w, \"F\");\n+            enc_bare_fn_ty(w, cx, f);\n+        }\n+        ty::ty_infer(_) => {\n+            cx.diag.handler().bug(\"cannot encode inference variable types\");\n+        }\n+        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n+            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n+        }\n+        ty::ty_struct(def, ref substs) => {\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_unboxed_closure(def, region, ref substs) => {\n+            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n+            enc_region(w, cx, region);\n+            enc_substs(w, cx, substs);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ty_err => {\n+            mywrite!(w, \"e\");\n+        }\n+        ty::ty_open(_) => {\n+            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n+        }\n+    }\n+\n     let end = w.tell().unwrap();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {\n@@ -214,105 +310,6 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n     }\n }\n \n-fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n-                     st: &ty::sty<'tcx>) {\n-    match *st {\n-        ty::ty_bool => mywrite!(w, \"b\"),\n-        ty::ty_char => mywrite!(w, \"c\"),\n-        ty::ty_int(t) => {\n-            match t {\n-                ast::TyI => mywrite!(w, \"i\"),\n-                ast::TyI8 => mywrite!(w, \"MB\"),\n-                ast::TyI16 => mywrite!(w, \"MW\"),\n-                ast::TyI32 => mywrite!(w, \"ML\"),\n-                ast::TyI64 => mywrite!(w, \"MD\")\n-            }\n-        }\n-        ty::ty_uint(t) => {\n-            match t {\n-                ast::TyU => mywrite!(w, \"u\"),\n-                ast::TyU8 => mywrite!(w, \"Mb\"),\n-                ast::TyU16 => mywrite!(w, \"Mw\"),\n-                ast::TyU32 => mywrite!(w, \"Ml\"),\n-                ast::TyU64 => mywrite!(w, \"Md\")\n-            }\n-        }\n-        ty::ty_float(t) => {\n-            match t {\n-                ast::TyF32 => mywrite!(w, \"Mf\"),\n-                ast::TyF64 => mywrite!(w, \"MF\"),\n-            }\n-        }\n-        ty::ty_enum(def, ref substs) => {\n-            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_trait(box ty::TyTrait { ref principal,\n-                                       ref bounds }) => {\n-            mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &principal.0);\n-            enc_existential_bounds(w, cx, bounds);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_tup(ref ts) => {\n-            mywrite!(w, \"T[\");\n-            for t in ts.iter() { enc_ty(w, cx, *t); }\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_uniq(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n-        ty::ty_rptr(r, mt) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, r);\n-            enc_mt(w, cx, mt);\n-        }\n-        ty::ty_vec(t, sz) => {\n-            mywrite!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            mywrite!(w, \"/\");\n-            match sz {\n-                Some(n) => mywrite!(w, \"{}|\", n),\n-                None => mywrite!(w, \"|\"),\n-            }\n-        }\n-        ty::ty_str => {\n-            mywrite!(w, \"v\");\n-        }\n-        ty::ty_closure(ref f) => {\n-            mywrite!(w, \"f\");\n-            enc_closure_ty(w, cx, &**f);\n-        }\n-        ty::ty_bare_fn(ref f) => {\n-            mywrite!(w, \"F\");\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::ty_infer(_) => {\n-            cx.diag.handler().bug(\"cannot encode inference variable types\");\n-        }\n-        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n-            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n-        }\n-        ty::ty_struct(def, ref substs) => {\n-            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_unboxed_closure(def, region, ref substs) => {\n-            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_region(w, cx, region);\n-            enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n-        }\n-        ty::ty_err => {\n-            mywrite!(w, \"e\");\n-        }\n-        ty::ty_open(_) => {\n-            cx.diag.handler().bug(\"unexpected type in enc_sty (ty_open)\");\n-        }\n-    }\n-}\n-\n fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),"}, {"sha": "e1c5906f0fb83f5d49f33959a89b806697f5e60b", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -48,4 +48,8 @@ impl CFG {\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n+\n+    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+        self.graph.depth_traverse(self.entry).any(|node| node.id == id)\n+    }\n }"}, {"sha": "9a94eb97931466727b8b81cb16f2e5647240be1c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -307,7 +307,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        ast::MatchIfLetDesugar => {\n+                        ast::MatchSource::IfLetDesugar { .. } => {\n                             if printed_if_let_err {\n                                 // we already printed an irrefutable if-let pattern error.\n                                 // We don't want two, that's just confusing.\n@@ -321,15 +321,15 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             }\n                         },\n \n-                        ast::MatchWhileLetDesugar => {\n+                        ast::MatchSource::WhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n-                        ast::MatchNormal => {\n+                        ast::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n                     }"}, {"sha": "62f1a30f8e746dbc0fa34555e46e6d802a1cf1ff", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -28,7 +28,7 @@ use syntax::visit::{mod, Visitor};\n use syntax::{ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n-use std::collections::hash_map::Vacant;\n+use std::collections::hash_map::Entry::Vacant;\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "06e6ef30f74dacadc64ff42e6d1f5e6a3443498d", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -34,6 +34,7 @@\n \n use std::fmt::{Formatter, Error, Show};\n use std::uint;\n+use std::collections::BitvSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -288,6 +289,40 @@ impl<N,E> Graph<N,E> {\n             }\n         }\n     }\n+\n+    pub fn depth_traverse<'a>(&'a self, start: NodeIndex) -> DepthFirstTraversal<'a, N, E>  {\n+        DepthFirstTraversal {\n+            graph: self,\n+            stack: vec![start],\n+            visited: BitvSet::new()\n+        }\n+    }\n+}\n+\n+pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n+    graph: &'g Graph<N, E>,\n+    stack: Vec<NodeIndex>,\n+    visited: BitvSet\n+}\n+\n+impl<'g, N, E> Iterator<&'g N> for DepthFirstTraversal<'g, N, E> {\n+    fn next(&mut self) -> Option<&'g N> {\n+        while let Some(idx) = self.stack.pop() {\n+            if !self.visited.insert(idx.node_id()) {\n+                continue;\n+            }\n+            self.graph.each_outgoing_edge(idx, |_, e| -> bool {\n+                if !self.visited.contains(&e.target().node_id()) {\n+                    self.stack.push(e.target());\n+                }\n+                true\n+            });\n+\n+            return Some(self.graph.node_data(idx));\n+        }\n+\n+        return None;\n+    }\n }\n \n pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where"}, {"sha": "64bfd1388026d38345c61f386070b11cf62358d4", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -90,8 +90,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                b.repr(self.get_ref().infcx.tcx));\n \n         // Consider coercing the subtype to a DST\n-        let unsize = self.unpack_actual_value(a, |sty_a| {\n-            self.coerce_unsized(a, sty_a, b)\n+        let unsize = self.unpack_actual_value(a, |a| {\n+            self.coerce_unsized(a, b)\n         });\n         if unsize.is_ok() {\n             return unsize;\n@@ -105,14 +105,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::ty_ptr(mt_b) => {\n                 match mt_b.ty.sty {\n                     ty::ty_str => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_ptr(a, sty_a, b, ast::MutImmutable)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_ptr(a, b, ast::MutImmutable)\n                         });\n                     }\n \n                     ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_object(a, sty_a, b, mt_b.mutbl)\n+                        let result = self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_object(a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -122,8 +122,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n \n                     _ => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_unsafe_ptr(a, sty_a, b, mt_b.mutbl)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n@@ -132,14 +132,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::ty_rptr(_, mt_b) => {\n                 match mt_b.ty.sty {\n                     ty::ty_str => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_pointer(a, b, ast::MutImmutable)\n                         });\n                     }\n \n                     ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_object(a, sty_a, b, mt_b.mutbl)\n+                        let result = self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_object(a, b, mt_b.mutbl)\n                         });\n \n                         match result {\n@@ -149,8 +149,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     }\n \n                     _ => {\n-                        return self.unpack_actual_value(a, |sty_a| {\n-                            self.coerce_borrowed_pointer(a, sty_a, b, mt_b.mutbl)\n+                        return self.unpack_actual_value(a, |a| {\n+                            self.coerce_borrowed_pointer(a, b, mt_b.mutbl)\n                         });\n                     }\n                 };\n@@ -160,16 +160,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     store: ty::RegionTraitStore(..),\n                     ..\n                 }) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_borrowed_fn(a, sty_a, b)\n+                return self.unpack_actual_value(a, |a| {\n+                    self.coerce_borrowed_fn(a, b)\n                 });\n             }\n \n             _ => {}\n         }\n \n-        self.unpack_actual_value(a, |sty_a| {\n-            match *sty_a {\n+        self.unpack_actual_value(a, |a| {\n+            match a.sty {\n                 ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercible to any closure type.\n                     //\n@@ -194,20 +194,19 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n-        F: FnOnce(&ty::sty<'tcx>) -> T,\n+        F: FnOnce(Ty<'tcx>) -> T,\n     {\n-        f(&self.get_ref().infcx.shallow_resolve(a).sty)\n+        f(self.get_ref().infcx.shallow_resolve(a))\n     }\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n                                    a: Ty<'tcx>,\n-                                   sty_a: &ty::sty<'tcx>,\n                                    b: Ty<'tcx>,\n                                    mutbl_b: ast::Mutability)\n                                    -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n         // If we have a parameter of type `&M T_a` and the value\n@@ -220,7 +219,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n \n-        let inner_ty = match *sty_a {\n+        let inner_ty = match a.sty {\n             ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n             ty::ty_rptr(_, mt_a) => mt_a.ty,\n             _ => {\n@@ -245,11 +244,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n                       a: Ty<'tcx>,\n-                      sty_a: &ty::sty<'tcx>,\n                       b: Ty<'tcx>)\n                       -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_unsized(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n         // Note, we want to avoid unnecessary unsizing. We don't want to coerce to\n@@ -259,11 +257,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sub = Sub(self.get_ref().clone());\n \n-        let sty_b = &b.sty;\n-        match (sty_a, sty_b) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, mt_b.ty) {\n                         Some((ty, kind)) => {\n                             if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n                                 return Err(ty::terr_mutability);\n@@ -288,8 +285,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 })\n             }\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, mt_b.ty) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, mt_b.ty) {\n                         Some((ty, kind)) => {\n                             if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n                                 return Err(ty::terr_mutability);\n@@ -311,8 +308,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 })\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(t_a, sty_a, t_b) {\n+                self.unpack_actual_value(t_a, |a| {\n+                    match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n@@ -336,15 +333,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n                  ty_a: Ty<'tcx>,\n-                 sty_a: &ty::sty<'tcx>,\n+                 a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n                  -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n+        debug!(\"unsize_ty(a={}, ty_b={})\", a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n \n-        self.unpack_actual_value(ty_b, |sty_b|\n-            match (sty_a, sty_b) {\n+        self.unpack_actual_value(ty_b, |b|\n+            match (&a.sty, &b.sty) {\n                 (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n                     let ty = ty::mk_vec(tcx, t_a, None);\n                     Some((ty, ty::UnsizeLength(len)))\n@@ -412,44 +409,41 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     fn coerce_borrowed_object(&self,\n                               a: Ty<'tcx>,\n-                              sty_a: &ty::sty<'tcx>,\n                               b: Ty<'tcx>,\n                               b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n-               a.repr(tcx), sty_a,\n+        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={})\",\n+               a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        self.coerce_object(a, sty_a, b, b_mutbl,\n+        self.coerce_object(a, b, b_mutbl,\n                            |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n \n     fn coerce_unsafe_object(&self,\n                             a: Ty<'tcx>,\n-                            sty_a: &ty::sty<'tcx>,\n                             b: Ty<'tcx>,\n                             b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={}, b={}, b_mutbl={})\",\n-               a.repr(tcx), sty_a,\n+        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={})\",\n+               a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n-        self.coerce_object(a, sty_a, b, b_mutbl,\n+        self.coerce_object(a, b, b_mutbl,\n                            |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoUnsafe(b_mutbl, None))\n     }\n \n     fn coerce_object<F, G>(&self,\n                            a: Ty<'tcx>,\n-                           sty_a: &ty::sty<'tcx>,\n                            b: Ty<'tcx>,\n                            b_mutbl: ast::Mutability,\n                            mk_ty: F,\n@@ -459,7 +453,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        match *sty_a {\n+        match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n@@ -483,14 +477,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     pub fn coerce_borrowed_fn(&self,\n                               a: Ty<'tcx>,\n-                              sty_a: &ty::sty<'tcx>,\n                               b: Ty<'tcx>)\n                               -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_borrowed_fn(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n-        match *sty_a {\n+        match a.sty {\n             ty::ty_bare_fn(ref f) => {\n                 self.coerce_from_bare_fn(a, f, b)\n             }\n@@ -504,7 +497,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     ///  `proc`.\n     fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n-        self.unpack_actual_value(b, |sty_b| {\n+        self.unpack_actual_value(b, |b| {\n \n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                    a.repr(self.get_ref().infcx.tcx), b.repr(self.get_ref().infcx.tcx));\n@@ -513,7 +506,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 return self.subtype(a, b);\n             }\n \n-            let fn_ty_b = match *sty_b {\n+            let fn_ty_b = match b.sty {\n                 ty::ty_closure(ref f) => (*f).clone(),\n                 _ => return self.subtype(a, b)\n             };\n@@ -531,15 +524,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     pub fn coerce_unsafe_ptr(&self,\n                              a: Ty<'tcx>,\n-                             sty_a: &ty::sty<'tcx>,\n                              b: Ty<'tcx>,\n                              mutbl_b: ast::Mutability)\n                              -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n+        debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n+               a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n \n-        let mt_a = match *sty_a {\n+        let mt_a = match a.sty {\n             ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => mt,\n             _ => {\n                 return self.subtype(a, b);"}, {"sha": "a8bf7546559fdf3835388ce4fc11af17d2bd1251", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n-use std::collections::hash_map;\n+use std::collections::hash_map::{mod, Entry};\n \n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n@@ -67,8 +67,8 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n         }\n \n         match self.freshen_map.entry(key) {\n-            hash_map::Occupied(entry) => *entry.get(),\n-            hash_map::Vacant(entry) => {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n                 let index = self.freshen_count;\n                 self.freshen_count += 1;\n                 let t = ty::mk_infer(self.infcx.tcx, freshener(index));"}, {"sha": "3e55f6fa896bb6960bb93e0dc5dbbc76fcb9f6f9", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -26,7 +26,7 @@ use session::config;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n-use std::collections::hash_map::Vacant;\n+use std::collections::hash_map::Entry::Vacant;\n use std::io::{mod, File};\n use std::os;\n use std::sync::atomic;"}, {"sha": "d793f49efe5e8cf640d608d99cdf4261015816d3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -43,7 +43,8 @@ struct Annotator {\n impl Annotator {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: F) where\n+    fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n+                   attrs: &Vec<Attribute>, f: F) where\n         F: FnOnce(&mut Annotator),\n     {\n         match attr::find_stability(attrs.as_slice()) {\n@@ -60,7 +61,9 @@ impl Annotator {\n                 }\n             }\n             None => {\n-                self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                if use_parent {\n+                    self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                }\n                 f(self);\n             }\n         }\n@@ -69,11 +72,24 @@ impl Annotator {\n \n impl<'v> Visitor<'v> for Annotator {\n     fn visit_item(&mut self, i: &Item) {\n-        self.annotate(i.id, &i.attrs, |v| visit::walk_item(v, i));\n+        // FIXME (#18969): the following is a hack around the fact\n+        // that we cannot currently annotate the stability of\n+        // `deriving`.  Basically, we do *not* allow stability\n+        // inheritance on trait implementations, so that derived\n+        // implementations appear to be unannotated. This then allows\n+        // derived implementations to be automatically tagged with the\n+        // stability of the trait. This is WRONG, but expedient to get\n+        // libstd stabilized for the 1.0 release.\n+        let use_parent = match i.node {\n+            ast::ItemImpl(_, _, Some(_), _, _) => false,\n+            _ => true,\n+        };\n+\n+        self.annotate(i.id, use_parent, &i.attrs, |v| visit::walk_item(v, i));\n \n         if let ast::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n-                self.annotate(id, &i.attrs, |_| {})\n+                self.annotate(id, true, &i.attrs, |_| {})\n             });\n         }\n     }\n@@ -82,7 +98,7 @@ impl<'v> Visitor<'v> for Annotator {\n                 _: &'v Block, _: Span, _: NodeId) {\n         if let FkMethod(_, _, meth) = fk {\n             // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, &meth.attrs, |_| {});\n+            self.annotate(meth.id, true, &meth.attrs, |_| {});\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n@@ -101,15 +117,21 @@ impl<'v> Visitor<'v> for Annotator {\n \n             TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n         };\n-        self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n+        self.annotate(id, true, attrs, |v| visit::walk_trait_item(v, t));\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n-        self.annotate(var.node.id, &var.node.attrs, |v| visit::walk_variant(v, var, g))\n+        self.annotate(var.node.id, true, &var.node.attrs,\n+                      |v| visit::walk_variant(v, var, g))\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n-        self.annotate(s.node.id, &s.node.attrs, |v| visit::walk_struct_field(v, s));\n+        self.annotate(s.node.id, true, &s.node.attrs,\n+                      |v| visit::walk_struct_field(v, s));\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n+        self.annotate(i.id, true, &i.attrs, |_| {});\n     }\n }\n \n@@ -123,7 +145,8 @@ impl Index {\n             },\n             parent: None\n         };\n-        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, |v| visit::walk_crate(v, krate));\n+        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs,\n+                           |v| visit::walk_crate(v, krate));\n         annotator.index\n     }\n }\n@@ -135,16 +158,29 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     match ty::trait_item_of_item(tcx, id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n                 if trait_method_id != id => {\n-            lookup(tcx, trait_method_id)\n-        }\n-        _ if is_local(id) => {\n-            tcx.stability.borrow().local.get(&id.node).cloned()\n-        }\n-        _ => {\n-            let stab = csearch::get_stability(&tcx.sess.cstore, id);\n-            let mut index = tcx.stability.borrow_mut();\n-            (*index).extern_cache.insert(id, stab.clone());\n-            stab\n+            return lookup(tcx, trait_method_id)\n         }\n+        _ => {}\n     }\n+\n+    let item_stab = if is_local(id) {\n+        tcx.stability.borrow().local.get(&id.node).cloned()\n+    } else {\n+        let stab = csearch::get_stability(&tcx.sess.cstore, id);\n+        let mut index = tcx.stability.borrow_mut();\n+        (*index).extern_cache.insert(id, stab.clone());\n+        stab\n+    };\n+\n+    item_stab.or_else(|| {\n+        if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n+            // FIXME (#18969): for the time being, simply use the\n+            // stability of the trait to determine the stability of any\n+            // unmarked impls for it. See FIXME above for more details.\n+\n+            lookup(tcx, trait_id)\n+        } else {\n+            None\n+        }\n+    })\n }"}, {"sha": "72e4eb5d1d63478843221fddd6d6c2e64d5f6aa2", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@ use middle::infer::InferCtxt;\n use middle::mem_categorization::Typer;\n use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::default::Default;\n use std::rc::Rc;\n use syntax::ast;"}, {"sha": "50a6fb9d0ca3f88f4a45a7da831d8aa580a6ca78", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -77,7 +77,8 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use collections::enum_set::{EnumSet, CLike};\n-use std::collections::hash_map::{HashMap, Occupied, Vacant};\n+use std::collections::hash_map::HashMap;\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n@@ -2851,45 +2852,18 @@ impl TypeContents {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n-    fn bitor(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits | other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n     fn bitor(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n-    fn bitand(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::BitAnd<TypeContents, TypeContents> for TypeContents {\n     fn bitand(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n-    fn sub(&self, other: &TypeContents) -> TypeContents {\n-        TypeContents {bits: self.bits & !other.bits}\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl ops::Sub<TypeContents, TypeContents> for TypeContents {\n     fn sub(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}"}, {"sha": "d69ae96d07eca21907c1b617bb05132d84af33e7", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -82,10 +82,6 @@ pub trait TypeFolder<'tcx> {\n         super_fold_trait_ref(self, t)\n     }\n \n-    fn fold_sty(&mut self, sty: &ty::sty<'tcx>) -> ty::sty<'tcx> {\n-        super_fold_sty(self, sty)\n-    }\n-\n     fn fold_substs(&mut self,\n                    substs: &subst::Substs<'tcx>)\n                    -> subst::Substs<'tcx> {\n@@ -260,12 +256,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::sty<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty<'tcx> {\n-        folder.fold_sty(self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         folder.fold_trait_ref(self)\n@@ -521,9 +511,55 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                t: Ty<'tcx>)\n+                                                ty: Ty<'tcx>)\n                                                 -> Ty<'tcx> {\n-    let sty = t.sty.fold_with(this);\n+    let sty = match ty.sty {\n+        ty::ty_uniq(typ) => {\n+            ty::ty_uniq(typ.fold_with(this))\n+        }\n+        ty::ty_ptr(ref tm) => {\n+            ty::ty_ptr(tm.fold_with(this))\n+        }\n+        ty::ty_vec(typ, sz) => {\n+            ty::ty_vec(typ.fold_with(this), sz)\n+        }\n+        ty::ty_open(typ) => {\n+            ty::ty_open(typ.fold_with(this))\n+        }\n+        ty::ty_enum(tid, ref substs) => {\n+            ty::ty_enum(tid, substs.fold_with(this))\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+            ty::ty_trait(box ty::TyTrait {\n+                principal: (*principal).fold_with(this),\n+                bounds: bounds.fold_with(this),\n+            })\n+        }\n+        ty::ty_tup(ref ts) => {\n+            ty::ty_tup(ts.fold_with(this))\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(f.fold_with(this))\n+        }\n+        ty::ty_closure(ref f) => {\n+            ty::ty_closure(box f.fold_with(this))\n+        }\n+        ty::ty_rptr(r, ref tm) => {\n+            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n+        }\n+        ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did, substs.fold_with(this))\n+        }\n+        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n+            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n+        }\n+        ty::ty_bool | ty::ty_char | ty::ty_str |\n+        ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+        ty::ty_err | ty::ty_infer(_) |\n+        ty::ty_param(..) => {\n+            ty.sty.clone()\n+        }\n+    };\n     ty::mk_t(this.tcx(), sty)\n }\n \n@@ -601,58 +637,6 @@ pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sty: &ty::sty<'tcx>)\n-                                                 -> ty::sty<'tcx> {\n-    match *sty {\n-        ty::ty_uniq(typ) => {\n-            ty::ty_uniq(typ.fold_with(this))\n-        }\n-        ty::ty_ptr(ref tm) => {\n-            ty::ty_ptr(tm.fold_with(this))\n-        }\n-        ty::ty_vec(typ, sz) => {\n-            ty::ty_vec(typ.fold_with(this), sz)\n-        }\n-        ty::ty_open(typ) => {\n-            ty::ty_open(typ.fold_with(this))\n-        }\n-        ty::ty_enum(tid, ref substs) => {\n-            ty::ty_enum(tid, substs.fold_with(this))\n-        }\n-        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-            ty::ty_trait(box ty::TyTrait {\n-                principal: (*principal).fold_with(this),\n-                bounds: bounds.fold_with(this),\n-            })\n-        }\n-        ty::ty_tup(ref ts) => {\n-            ty::ty_tup(ts.fold_with(this))\n-        }\n-        ty::ty_bare_fn(ref f) => {\n-            ty::ty_bare_fn(f.fold_with(this))\n-        }\n-        ty::ty_closure(ref f) => {\n-            ty::ty_closure(box f.fold_with(this))\n-        }\n-        ty::ty_rptr(r, ref tm) => {\n-            ty::ty_rptr(r.fold_with(this), tm.fold_with(this))\n-        }\n-        ty::ty_struct(did, ref substs) => {\n-            ty::ty_struct(did, substs.fold_with(this))\n-        }\n-        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n-            ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n-        }\n-        ty::ty_bool | ty::ty_char | ty::ty_str |\n-        ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-        ty::ty_err | ty::ty_infer(_) |\n-        ty::ty_param(..) => {\n-            (*sty).clone()\n-        }\n-    }\n-}\n-\n pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                          trait_store: ty::TraitStore)\n                                                          -> ty::TraitStore {"}, {"sha": "0652645907bc87ad057f8a081f61af841855a53c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -33,7 +33,7 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};"}, {"sha": "85a06125e23ab6665cbaca06229437e0005f092c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -93,8 +93,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               ast::ExprMethodCall(..) => {\n                 explain_span(cx, \"method call\", expr.span)\n               },\n-              ast::ExprMatch(_, _, ast::MatchIfLetDesugar) => explain_span(cx, \"if let\", expr.span),\n-              ast::ExprMatch(_, _, ast::MatchWhileLetDesugar) => {\n+              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) =>\n+                  explain_span(cx, \"if let\", expr.span),\n+              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) => {\n                   explain_span(cx, \"while let\", expr.span)\n               },\n               ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n@@ -452,7 +453,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_vec(t, sz) => {\n             let inner_str = ty_to_string(cx, t);\n             match sz {\n-                Some(n) => format!(\"[{}, ..{}]\", inner_str, n),\n+                Some(n) => format!(\"[{}; {}]\", inner_str, n),\n                 None => format!(\"[{}]\", inner_str),\n             }\n         }\n@@ -532,7 +533,13 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n-                strs[0][1 .. strs[0].len() - (strs[0].ends_with(\",)\") as uint+1)],\n+                if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n+                    strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n+                } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n+                    strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n+                } else {\n+                    strs[0][]\n+                },\n                 if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n     } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))"}, {"sha": "6944c733456f6bc919c552a1d4b9fdc4182bbdf9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -480,7 +480,7 @@ pub fn list_metadata(sess: &Session, path: &Path,\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n pub fn monitor<F:FnOnce()+Send>(f: F) {\n-    static STACK_SIZE: uint = 32000000; // 32MB\n+    static STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n     let (tx, rx) = channel();\n     let w = io::ChanWriter::new(tx);"}, {"sha": "ac8d5d1e977b585c9c0fa4bbf4591f43ab26320d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -90,7 +90,7 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{mod, Visitor};\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cell::{Cell, RefCell};\n use std::mem::replace;\n use std::rc::{Rc, Weak};"}, {"sha": "ca1e0d7de72102c169943d62aa17e1716123b3f0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -38,6 +38,7 @@ use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n+use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n@@ -1306,47 +1307,33 @@ pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     }\n }\n \n-struct CheckForNestedReturnsVisitor {\n+struct FindNestedReturn {\n     found: bool,\n-    in_return: bool\n }\n \n-impl CheckForNestedReturnsVisitor {\n-    fn explicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: false }\n-    }\n-    fn implicit() -> CheckForNestedReturnsVisitor {\n-        CheckForNestedReturnsVisitor { found: false, in_return: true }\n+impl FindNestedReturn {\n+    fn new() -> FindNestedReturn {\n+        FindNestedReturn { found: false }\n     }\n }\n \n-impl<'v> Visitor<'v> for CheckForNestedReturnsVisitor {\n+impl<'v> Visitor<'v> for FindNestedReturn {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprRet(..) => {\n-                if self.in_return {\n-                    self.found = true;\n-                } else {\n-                    self.in_return = true;\n-                    visit::walk_expr(self, e);\n-                    self.in_return = false;\n-                }\n+                self.found = true;\n             }\n             _ => visit::walk_expr(self, e)\n         }\n     }\n }\n \n-fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n-    match tcx.map.find(id) {\n+fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n+    let blk = match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_item(&mut explicit, &*i);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n             }\n@@ -1356,11 +1343,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::ProvidedMethod(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1380,11 +1363,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &**m);\n-                            visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                            explicit.found || implicit.found\n+                            blk\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n@@ -1398,24 +1377,58 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n                 ast::ExprClosure(_, _, _, ref blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n-                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_expr(&mut explicit, e);\n-                    visit::walk_expr_opt(&mut implicit, &blk.expr);\n-                    explicit.found || implicit.found\n+                    blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n             }\n         }\n-\n-        Some(ast_map::NodeVariant(..)) | Some(ast_map::NodeStructCtor(..)) => false,\n+        Some(ast_map::NodeVariant(..)) |\n+        Some(ast_map::NodeStructCtor(..)) => return (ast::DUMMY_NODE_ID, None),\n \n         // glue, shims, etc\n-        None if id == ast::DUMMY_NODE_ID => false,\n+        None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n         _ => tcx.sess.bug(format!(\"unexpected variant in has_nested_returns: {}\",\n                                   tcx.map.path_to_string(id)).as_slice())\n+    };\n+\n+    (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n+}\n+\n+// Checks for the presence of \"nested returns\" in a function.\n+// Nested returns are when the inner expression of a return expression\n+// (the 'expr' in 'return expr') contains a return expression. Only cases\n+// where the outer return is actually reachable are considered. Implicit\n+// returns from the end of blocks are considered as well.\n+//\n+// This check is needed to handle the case where the inner expression is\n+// part of a larger expression that may have already partially-filled the\n+// return slot alloca. This can cause errors related to clean-up due to\n+// the clobbering of the existing value in the return slot.\n+fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n+    for n in cfg.graph.depth_traverse(cfg.entry) {\n+        match tcx.map.find(n.id) {\n+            Some(ast_map::NodeExpr(ex)) => {\n+                if let ast::ExprRet(Some(ref ret_expr)) = ex.node {\n+                    let mut visitor = FindNestedReturn::new();\n+                    visit::walk_expr(&mut visitor, &**ret_expr);\n+                    if visitor.found {\n+                        return true;\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeBlock(blk)) if blk.id == blk_id => {\n+                let mut visitor = FindNestedReturn::new();\n+                visit::walk_expr_opt(&mut visitor, &blk.expr);\n+                if visitor.found {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n     }\n+\n+    return false;\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1454,7 +1467,12 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         ty::FnDiverging => false\n     };\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n-    let nested_returns = has_nested_returns(ccx.tcx(), id);\n+    let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n+    let nested_returns = if let Some(ref cfg) = cfg {\n+        has_nested_returns(ccx.tcx(), cfg, blk_id)\n+    } else {\n+        false\n+    };\n \n     let mut fcx = FunctionContext {\n           llfn: llfndecl,\n@@ -1473,7 +1491,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n-          scopes: RefCell::new(Vec::new())\n+          scopes: RefCell::new(Vec::new()),\n+          cfg: cfg\n     };\n \n     if has_env {"}, {"sha": "61f27bcfa7ad384e217ef6ee02216abefb6b53c9", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -18,6 +18,7 @@ use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n+use middle::cfg;\n use middle::def;\n use middle::infer;\n use middle::lang_items::LangItem;\n@@ -262,6 +263,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Cleanup scopes.\n     pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+\n+    pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {"}, {"sha": "135e192a2fd49d59c3f04d2362b4940a5a9ae3b1", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -112,8 +112,17 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if dest != expr::Ignore {\n         let block_ty = node_id_type(bcx, b.id);\n+\n         if b.expr.is_none() || type_is_zero_size(bcx.ccx(), block_ty) {\n             dest = expr::Ignore;\n+        } else if b.expr.is_some() {\n+            // If the block has an expression, but that expression isn't reachable,\n+            // don't save into the destination given, ignore it.\n+            if let Some(ref cfg) = bcx.fcx.cfg {\n+                if !cfg.node_is_reachable(b.expr.as_ref().unwrap().id) {\n+                    dest = expr::Ignore;\n+                }\n+            }\n         }\n     }\n \n@@ -277,6 +286,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"iterator type is {}, datum type is {}\",\n            ppaux::ty_to_string(bcx.tcx(), iterator_type),\n            ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n+\n     let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n \n     // Create our basic blocks and set up our loop cleanups.\n@@ -356,6 +366,8 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        llpayload,\n                                        binding_cleanup_scope_id);\n \n+    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n+\n     // Codegen the body.\n     body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n     body_bcx_out ="}, {"sha": "51e3a83f81f5a90c6b9e7c07dff3913a71630b7c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 123, "deletions": 72, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -182,7 +182,6 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n-use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -334,7 +333,7 @@ impl<'tcx> TypeMap<'tcx> {\n         // mut ptr (*mut)       -> {*mut :pointee-uid:}\n         // unique ptr (~)       -> {~ :pointee-uid:}\n         // @-ptr (@)            -> {@ :pointee-uid:}\n-        // sized vec ([T, ..x]) -> {[:size:] :element-uid:}\n+        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n         // unsized vec ([T])    -> {[] :element-uid:}\n         // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n         // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n@@ -679,12 +678,8 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    repr: FunctionDebugContextRepr,\n-}\n-\n-enum FunctionDebugContextRepr {\n-    DebugInfo(Box<FunctionDebugContextData>),\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -694,13 +689,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match self.repr {\n-            DebugInfo(box ref data) => data,\n-            DebugInfoDisabled => {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionWithoutDebugInfo => {\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -844,6 +839,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -852,11 +849,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n-        let var_ident = path1.node;\n-\n-        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -865,10 +861,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n+                                      Referenced variable location is not an alloca!\");\n+        }\n+\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident,\n+                      var_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -981,7 +982,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_type = match binding.trmode {\n+    let var_access = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -998,27 +999,31 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_type,\n+                  var_access,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n+    let def_map = &bcx.tcx().def_map;\n+    let scope_metadata = bcx\n+                         .fcx\n+                         .debug_context\n+                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .fn_metadata;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    let def_map = &cx.tcx().def_map;\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1027,28 +1032,72 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                    Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n+            let counter = &bcx\n+                          .fcx\n+                          .debug_context\n+                          .get_ref(bcx.ccx(), span)\n+                          .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      path1.node,\n-                      llarg.ty,\n+                      var_ident.node,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llarg.val },\n+                      DirectVariable { alloca: datum.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n+/// Creates debug information for the given for-loop variable.\n+///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// loop variable in `bcx.fcx.lllocals`.\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let def_map = &bcx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n+            Some(datum) => datum,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    format!(\"no entry in lllocals table for {}\",\n+                            node_id).as_slice());\n+            }\n+        };\n+\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n+        }\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      var_ident.node,\n+                      datum.ty,\n+                      scope_metadata,\n+                      DirectVariable { alloca: datum.val },\n+                      LocalVariable,\n+                      span);\n+    })\n+}\n+\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -1117,13 +1166,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context.repr {\n-        DebugInfoDisabled => return,\n-        FunctionWithoutDebugInfo => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        DebugInfo(box ref function_debug_context) => {\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1160,8 +1209,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context.repr {\n-        DebugInfo(box ref data) => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1179,7 +1228,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext { repr: DebugInfoDisabled };\n+        return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1189,7 +1238,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1199,7 +1248,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n             match item.node {\n@@ -1216,9 +1265,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1257,9 +1304,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1280,7 +1325,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1289,7 +1334,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let loc = span_start(cx, span);\n@@ -1356,22 +1401,23 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n+    let scope_map = create_scope_map(cx,\n+                                     fn_decl.inputs.as_slice(),\n+                                     &*top_level_block,\n+                                     fn_metadata,\n+                                     fn_ast_id);\n+\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap::new()),\n+        scope_map: RefCell::new(scope_map),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    populate_scope_map(cx,\n-                       fn_decl.inputs.as_slice(),\n-                       &*top_level_block,\n-                       fn_metadata,\n-                       fn_ast_id,\n-                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3134,8 +3180,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context.repr {\n-        DebugInfo(_) => false,\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n         _ => true\n     }\n }\n@@ -3169,12 +3215,14 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn populate_scope_map(cx: &CrateContext,\n-                      args: &[ast::Arg],\n-                      fn_entry_block: &ast::Block,\n-                      fn_metadata: DISubprogram,\n-                      fn_ast_id: ast::NodeId,\n-                      scope_map: &mut NodeMap<DIScope>) {\n+fn create_scope_map(cx: &CrateContext,\n+                    args: &[ast::Arg],\n+                    fn_entry_block: &ast::Block,\n+                    fn_metadata: DISubprogram,\n+                    fn_ast_id: ast::NodeId)\n+                 -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap::new();\n+\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3200,11 +3248,14 @@ fn populate_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   scope_map,\n+                   &mut scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n+    return scope_map;\n+\n+\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3440,7 +3491,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3526,7 +3577,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3543,7 +3594,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3568,7 +3619,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n \n@@ -3752,7 +3803,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match optional_length {\n                 Some(len) => {\n-                    output.push_str(format!(\", ..{}\", len).as_slice());\n+                    output.push_str(format!(\"; {}\", len).as_slice());\n                 }\n                 None => { /* nothing to do */ }\n             };"}, {"sha": "81892e5fa83219923b1b7a58cfffd6f45d5ca7e6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -926,7 +926,29 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n-            controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            // Check to see if the return expression itself is reachable.\n+            // This can occur when the inner expression contains a return\n+            let reachable = if let Some(ref cfg) = bcx.fcx.cfg {\n+                cfg.node_is_reachable(expr.id)\n+            } else {\n+                true\n+            };\n+\n+            if reachable {\n+                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            } else {\n+                // If it's not reachable, just translate the inner expression\n+                // directly. This avoids having to manage a return slot when\n+                // it won't actually be used anyway.\n+                if let &Some(ref x) = ex {\n+                    bcx = trans_into(bcx, &**x, Ignore);\n+                }\n+                // Mark the end of the block as unreachable. Once we get to\n+                // a return expression, there's no more we should be doing\n+                // after this.\n+                Unreachable(bcx);\n+                bcx\n+            }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)"}, {"sha": "35ffa8ace406f50b4f11a593e494d9f3cc65cde5", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,7 +21,7 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n use std::cmp;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::{Span, Spanned};\n@@ -238,7 +238,8 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              expr: &ast::Expr,\n                              discrim: &ast::Expr,\n                              arms: &[ast::Arm],\n-                             expected: Expectation<'tcx>) {\n+                             expected: Expectation<'tcx>,\n+                             match_src: ast::MatchSource) {\n     let tcx = fcx.ccx.tcx;\n \n     let discrim_ty = fcx.infcx().next_ty_var();\n@@ -290,12 +291,27 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n             ty::mk_err()\n         } else {\n+            let (origin, expected, found) = match match_src {\n+                /* if-let construct without an else block */\n+                ast::MatchSource::IfLetDesugar { contains_else_clause }\n+                if !contains_else_clause => (\n+                    infer::IfExpressionWithNoElse(expr.span),\n+                    bty,\n+                    result_ty,\n+                ),\n+                _ => (\n+                    infer::MatchExpressionArm(expr.span, arm.body.span),\n+                    result_ty,\n+                    bty,\n+                ),\n+            };\n+\n             infer::common_supertype(\n                 fcx.infcx(),\n-                infer::MatchExpressionArm(expr.span, arm.body.span),\n-                true, // result_ty is \"expected\" here\n-                result_ty,\n-                bty\n+                origin,\n+                true,\n+                expected,\n+                found,\n             )\n         }\n     });"}, {"sha": "092260523670745db03f5c5442c27371a7ab82f8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -261,44 +261,43 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     // Find the expected input/output types (if any). Substitute\n     // fresh bound regions for any bound regions we find in the\n     // expected types so as to avoid capture.\n-    let expected_sty = expected.map_to_option(fcx, |x| Some((*x).clone()));\n-    let (expected_sig,\n-         expected_onceness,\n-         expected_bounds) = {\n-        match expected_sty {\n-            Some(ty::ty_closure(ref cenv)) => {\n-                let (sig, _) =\n-                    ty::replace_late_bound_regions(\n-                        tcx,\n-                        &cenv.sig,\n-                        |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n-                let onceness = match (&store, &cenv.store) {\n-                    // As the closure type and onceness go, only three\n-                    // combinations are legit:\n-                    //      once closure\n-                    //      many closure\n-                    //      once proc\n-                    // If the actual and expected closure type disagree with\n-                    // each other, set expected onceness to be always Once or\n-                    // Many according to the actual type. Otherwise, it will\n-                    // yield either an illegal \"many proc\" or a less known\n-                    // \"once closure\" in the error message.\n-                    (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n-                    (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n-                        cenv.onceness,\n-                    (&ty::UniqTraitStore, _) => ast::Once,\n-                    (&ty::RegionTraitStore(..), _) => ast::Many,\n-                };\n-                (Some(sig), onceness, cenv.bounds)\n-            }\n-            _ => {\n-                // Not an error! Means we're inferring the closure type\n-                let region = fcx.infcx().next_region_var(\n-                    infer::AddrOfRegion(expr.span));\n-                let bounds = ty::region_existential_bound(region);\n-                let onceness = ast::Many;\n-                (None, onceness, bounds)\n-            }\n+    let expected_cenv = expected.map_to_option(fcx, |ty| match ty.sty {\n+        ty::ty_closure(ref cenv) => Some(cenv),\n+        _ => None\n+    });\n+    let (expected_sig, expected_onceness, expected_bounds) = match expected_cenv {\n+        Some(cenv) => {\n+            let (sig, _) =\n+                ty::replace_late_bound_regions(\n+                    tcx,\n+                    &cenv.sig,\n+                    |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n+            let onceness = match (&store, &cenv.store) {\n+                // As the closure type and onceness go, only three\n+                // combinations are legit:\n+                //      once closure\n+                //      many closure\n+                //      once proc\n+                // If the actual and expected closure type disagree with\n+                // each other, set expected onceness to be always Once or\n+                // Many according to the actual type. Otherwise, it will\n+                // yield either an illegal \"many proc\" or a less known\n+                // \"once closure\" in the error message.\n+                (&ty::UniqTraitStore, &ty::UniqTraitStore) |\n+                (&ty::RegionTraitStore(..), &ty::RegionTraitStore(..)) =>\n+                    cenv.onceness,\n+                (&ty::UniqTraitStore, _) => ast::Once,\n+                (&ty::RegionTraitStore(..), _) => ast::Many,\n+            };\n+            (Some(sig), onceness, cenv.bounds)\n+        }\n+        _ => {\n+            // Not an error! Means we're inferring the closure type\n+            let region = fcx.infcx().next_region_var(\n+                infer::AddrOfRegion(expr.span));\n+            let bounds = ty::region_existential_bound(region);\n+            let onceness = ast::Many;\n+            (None, onceness, bounds)\n         }\n     };\n "}, {"sha": "cd9a09efe082bc1dafb34f12bdd4ceb82c102c45", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -2042,7 +2042,7 @@ fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n-    match *structure_of(fcx, callee.span, callee_type) {\n+    match structurally_resolved_type(fcx, callee.span, callee_type).sty {\n         ty::ty_bare_fn(_) | ty::ty_closure(_) => return false,\n         _ => {}\n     }\n@@ -2717,10 +2717,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(t),\n         ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-            let opt_ty = expected.map_to_option(fcx, |sty| {\n-                match *sty {\n-                    ty::ty_int(i) => Some(ty::mk_mach_int(i)),\n-                    ty::ty_uint(i) => Some(ty::mk_mach_uint(i)),\n+            let opt_ty = expected.map_to_option(fcx, |ty| {\n+                match ty.sty {\n+                    ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(ty::mk_mach_uint(ast::TyU8)),\n                     ty::ty_ptr(..) => Some(ty::mk_mach_uint(ast::TyU)),\n                     ty::ty_bare_fn(..) => Some(ty::mk_mach_uint(ast::TyU)),\n@@ -2732,9 +2731,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         ast::LitFloat(_, t) => ty::mk_mach_float(t),\n         ast::LitFloatUnsuffixed(_) => {\n-            let opt_ty = expected.map_to_option(fcx, |sty| {\n-                match *sty {\n-                    ty::ty_float(i) => Some(ty::mk_mach_float(i)),\n+            let opt_ty = expected.map_to_option(fcx, |ty| {\n+                match ty.sty {\n+                    ty::ty_float(_) => Some(ty),\n                     _ => None\n                 }\n             });\n@@ -2910,7 +2909,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let fn_ty = fcx.expr_ty(f);\n \n         // Extract the function signature from `in_fty`.\n-        let fn_sty = structure_of(fcx, f.span, fn_ty);\n+        let fn_ty = structurally_resolved_type(fcx, f.span, fn_ty);\n \n         // This is the \"default\" function signature, used in case of error.\n         // In that case, we check each argument against \"error\" in order to\n@@ -2921,7 +2920,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             variadic: false\n         });\n \n-        let fn_sig = match *fn_sty {\n+        let fn_sig = match fn_ty.sty {\n             ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n             ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n             _ => {\n@@ -3655,9 +3654,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected_inner = expected.map(fcx, |sty| {\n+        let expected_inner = expected.map(fcx, |ty| {\n             match unop {\n-                ast::UnUniq => match *sty {\n+                ast::UnUniq => match ty.sty {\n                     ty::ty_uniq(ty) => {\n                         ExpectHasType(ty)\n                     }\n@@ -3746,9 +3745,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n         let expected = expected.only_has_type();\n-        let hint = expected.map(fcx, |sty| {\n-            match *sty { ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n-                         _ => NoExpectation }\n+        let hint = expected.map(fcx, |ty| {\n+            match ty.sty {\n+                ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n+                _ => NoExpectation\n+            }\n         });\n         let lvalue_pref = match mutbl {\n             ast::MutMutable => PreferMutLvalue,\n@@ -3918,8 +3919,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprMatch(ref discrim, ref arms, _) => {\n-        _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected);\n+      ast::ExprMatch(ref discrim, ref arms, match_src) => {\n+        _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected, match_src);\n       }\n       ast::ExprClosure(_, opt_kind, ref decl, ref body) => {\n           closure::check_expr_closure(fcx, expr, opt_kind, &**decl, &**body, expected);\n@@ -4037,9 +4038,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprTup(ref elts) => {\n         let expected = expected.only_has_type();\n-        let flds = expected.map_to_option(fcx, |sty| {\n-            match *sty {\n-                ty::ty_tup(ref flds) => Some((*flds).clone()),\n+        let flds = expected.map_to_option(fcx, |ty| {\n+            match ty.sty {\n+                ty::ty_tup(ref flds) => Some(flds[]),\n                 _ => None\n             }\n         });\n@@ -4304,20 +4305,20 @@ impl<'tcx> Expectation<'tcx> {\n     }\n \n     fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n-        F: FnOnce(&ty::sty<'tcx>) -> Expectation<'tcx>\n+        F: FnOnce(Ty<'tcx>) -> Expectation<'tcx>\n     {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n+            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n         }\n     }\n \n     fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n-        F: FnOnce(&ty::sty<'tcx>) -> Option<O>,\n+        F: FnOnce(Ty<'tcx>) -> Option<O>,\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n+            ExpectCastableToType(ty) | ExpectHasType(ty) => unpack(ty),\n         }\n     }\n }\n@@ -5320,12 +5321,6 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     ty\n }\n \n-// Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span, typ: Ty<'tcx>)\n-                        -> &'tcx ty::sty<'tcx> {\n-    &structurally_resolved_type(fcx, sp, typ).sty\n-}\n-\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "8e70b8ff0da50c84f4fae9932eb432131f901756", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -135,7 +135,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::{RefCell};\n-use std::collections::hash_map::{Vacant, Occupied};\n+use std::collections::hash_map::Entry::{Vacant, Occupied};\n \n use self::RepeatingScope::Repeating;\n use self::SubjectNode::Subject;"}, {"sha": "24d7bf5031e46c8a6687c86dbf82cd6ac70ad446", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -17,7 +17,7 @@ use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable, super_fold_ty};\n use util::ppaux::Repr;\n \n use std::collections::HashSet;\n@@ -368,8 +368,8 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n \n                 self.binding_count -= 1;\n             }\n-            ref sty => {\n-                self.fold_sty(sty);\n+            _ => {\n+                super_fold_ty(self, t);\n             }\n         }\n "}, {"sha": "ac688784f926cb3996b794a548818b36e9ea68a2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -163,33 +163,24 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             };\n             let mut tmp = Vec::new();\n             for child in m.items.iter_mut() {\n-                let inner = match child.inner {\n-                    ModuleItem(ref mut m) => m,\n+                match child.inner {\n+                    ModuleItem(..) => {}\n                     _ => continue,\n-                };\n+                }\n                 let prim = match PrimitiveType::find(child.attrs.as_slice()) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n                 primitives.push(prim);\n-                let mut i = Item {\n+                tmp.push(Item {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n-                    attrs: Vec::new(),\n-                    visibility: None,\n+                    attrs: child.attrs.clone(),\n+                    visibility: Some(ast::Public),\n                     stability: None,\n                     def_id: ast_util::local_def(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n-                };\n-                // Push one copy to get indexed for the whole crate, and push a\n-                // another copy in the proper location which will actually get\n-                // documented. The first copy will also serve as a redirect to\n-                // the other copy.\n-                tmp.push(i.clone());\n-                i.visibility = Some(ast::Public);\n-                i.attrs = child.attrs.clone();\n-                inner.items.push(i);\n-\n+                });\n             }\n             m.items.extend(tmp.into_iter());\n         }"}, {"sha": "efec620bca758ee6e2e794fb62e28fad54d077b0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -35,7 +35,7 @@\n pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;"}, {"sha": "182c83d805c2dc2f946f6e4b7ee34fe0d1b06a31", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -34,7 +34,7 @@ extern crate \"test\" as testing;\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::io::File;\n use std::io;\n use std::rc::Rc;"}, {"sha": "3181e28a1211b11a2f0c605790cad81526748c33", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -2012,7 +2012,6 @@ macro_rules! read_primitive {\n \n impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n-        debug!(\"read_nil\");\n         expect!(self.pop(), Null)\n     }\n \n@@ -2030,7 +2029,6 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n     fn read_f64(&mut self) -> DecodeResult<f64> {\n-        debug!(\"read_f64\");\n         match self.pop() {\n             Json::I64(f) => Ok(f as f64),\n             Json::U64(f) => Ok(f as f64),\n@@ -2049,7 +2047,6 @@ impl ::Decoder<DecoderError> for Decoder {\n     }\n \n     fn read_bool(&mut self) -> DecodeResult<bool> {\n-        debug!(\"read_bool\");\n         expect!(self.pop(), Boolean)\n     }\n \n@@ -2067,22 +2064,19 @@ impl ::Decoder<DecoderError> for Decoder {\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n-        debug!(\"read_str\");\n         expect!(self.pop(), String)\n     }\n \n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str],\n                                mut f: F) -> DecodeResult<T>\n         where F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n-        debug!(\"read_enum_variant(names={})\", names);\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n@@ -2122,49 +2116,44 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_enum_variant_arg<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n         F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n-        debug!(\"read_enum_struct_variant(names={})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n \n     fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                         name: &str,\n+                                         _name: &str,\n                                          idx: uint,\n                                          f: F)\n                                          -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+    fn read_struct<T, F>(&mut self, _name: &str, _len: uint, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = try!(f(self));\n         self.pop();\n         Ok(value)\n     }\n \n     fn read_struct_field<T, F>(&mut self,\n                                name: &str,\n-                               idx: uint,\n+                               _idx: uint,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n         let value = match obj.remove(&name.to_string()) {\n@@ -2189,7 +2178,6 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_tuple()\");\n         self.read_seq(move |d, len| {\n             if len == tuple_len {\n                 f(d)\n@@ -2202,18 +2190,16 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T, F>(&mut self,\n-                               name: &str,\n+                               _name: &str,\n                                len: uint,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(len, f)\n     }\n \n@@ -2223,14 +2209,12 @@ impl ::Decoder<DecoderError> for Decoder {\n                                    -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n     fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n         F: FnMut(&mut Decoder, bool) -> DecodeResult<T>,\n     {\n-        debug!(\"read_option()\");\n         match self.pop() {\n             Json::Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n@@ -2240,7 +2224,6 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n-        debug!(\"read_seq()\");\n         let array = try!(expect!(self.pop(), Array));\n         let len = array.len();\n         for v in array.into_iter().rev() {\n@@ -2249,17 +2232,15 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_seq_elt<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n     {\n-        debug!(\"read_map()\");\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n         for (key, value) in obj.into_iter() {\n@@ -2269,17 +2250,15 @@ impl ::Decoder<DecoderError> for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_key<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_val<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n \n@@ -2441,9 +2420,7 @@ mod tests {\n     use super::ParserError::*;\n     use super::DecoderError::*;\n     use super::JsonEvent::*;\n-    use super::ParserState::*;\n     use super::StackElement::*;\n-    use super::InternalStackElement::*;\n     use super::{PrettyEncoder, Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Encoder, Decoder};\n     use std::{i64, u64, f32, f64, io};\n@@ -2678,8 +2655,6 @@ mod tests {\n     }\n \n     fn with_str_writer<F>(f: F) -> string::String where F: FnOnce(&mut io::Writer){\n-        use std::str;\n-\n         let mut m = Vec::new();\n         f(&mut m as &mut io::Writer);\n         string::String::from_utf8(m).unwrap()\n@@ -2756,9 +2731,9 @@ mod tests {\n     fn test_write_char() {\n         check_encoder_for_simple!('a', \"\\\"a\\\"\");\n         check_encoder_for_simple!('\\t', \"\\\"\\\\t\\\"\");\n-        check_encoder_for_simple!('\\u00a0', \"\\\"\\u00a0\\\"\");\n-        check_encoder_for_simple!('\\uabcd', \"\\\"\\uabcd\\\"\");\n-        check_encoder_for_simple!('\\U0010ffff', \"\\\"\\U0010ffff\\\"\");\n+        check_encoder_for_simple!('\\u{00a0}', \"\\\"\\u{00a0}\\\"\");\n+        check_encoder_for_simple!('\\u{abcd}', \"\\\"\\u{abcd}\\\"\");\n+        check_encoder_for_simple!('\\u{10ffff}', \"\\\"\\u{10ffff}\\\"\");\n     }\n \n     #[test]"}, {"sha": "5dd76047779a0eb45c86d5ba45a4f2bf03aad69c", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 21, "deletions": 65, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -24,9 +24,9 @@\n /// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         const FLAG_A       = 0x00000001,\n-///         const FLAG_B       = 0x00000010,\n-///         const FLAG_C       = 0x00000100,\n+///         const FLAG_A       = 0b00000001,\n+///         const FLAG_B       = 0b00000010,\n+///         const FLAG_C       = 0b00000100,\n ///         const FLAG_ABC     = FLAG_A.bits\n ///                            | FLAG_B.bits\n ///                            | FLAG_C.bits,\n@@ -50,8 +50,8 @@\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         const FLAG_A   = 0x00000001,\n-///         const FLAG_B   = 0x00000010,\n+///         const FLAG_A   = 0b00000001,\n+///         const FLAG_B   = 0b00000010,\n ///     }\n /// }\n ///\n@@ -205,17 +205,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the union of the two sets of flags.\n-            #[inline]\n-            fn bitor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits | other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the union of the two sets of flags.\n             #[inline]\n@@ -224,17 +213,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the left flags, but with all the right flags toggled.\n-            #[inline]\n-            fn bitxor(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits ^ other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitXor<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n@@ -243,17 +221,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the intersection between the two sets of flags.\n-            #[inline]\n-            fn bitand(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n@@ -262,17 +229,6 @@ macro_rules! bitflags {\n             }\n         }\n \n-        // NOTE(stage0): Remove impl after a snapshot\n-        #[cfg(stage0)]\n-        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n-            /// Returns the set difference of the two sets of flags.\n-            #[inline]\n-            fn sub(&self, other: &$BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & !other.bits }\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n         impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n@@ -325,10 +281,10 @@ mod tests {\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n         flags Flags: u32 {\n-            const FlagA       = 0x00000001,\n+            const FlagA       = 0b00000001,\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const FlagB       = 0x00000010,\n-            const FlagC       = 0x00000100,\n+            const FlagB       = 0b00000010,\n+            const FlagC       = 0b00000100,\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n@@ -346,33 +302,33 @@ mod tests {\n \n     #[test]\n     fn test_bits(){\n-        assert_eq!(Flags::empty().bits(), 0x00000000);\n-        assert_eq!(FlagA.bits(), 0x00000001);\n-        assert_eq!(FlagABC.bits(), 0x00000111);\n+        assert_eq!(Flags::empty().bits(), 0b00000000);\n+        assert_eq!(FlagA.bits(), 0b00000001);\n+        assert_eq!(FlagABC.bits(), 0b00000111);\n \n-        assert_eq!(AnotherSetOfFlags::empty().bits(), 0x00);\n+        assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n         assert_eq!(AnotherFlag.bits(), !0_i8);\n     }\n \n     #[test]\n     fn test_from_bits() {\n         assert!(Flags::from_bits(0) == Some(Flags::empty()));\n-        assert!(Flags::from_bits(0x1) == Some(FlagA));\n-        assert!(Flags::from_bits(0x10) == Some(FlagB));\n-        assert!(Flags::from_bits(0x11) == Some(FlagA | FlagB));\n-        assert!(Flags::from_bits(0x1000) == None);\n+        assert!(Flags::from_bits(0b1) == Some(FlagA));\n+        assert!(Flags::from_bits(0b10) == Some(FlagB));\n+        assert!(Flags::from_bits(0b11) == Some(FlagA | FlagB));\n+        assert!(Flags::from_bits(0b1000) == None);\n \n         assert!(AnotherSetOfFlags::from_bits(!0_i8) == Some(AnotherFlag));\n     }\n \n     #[test]\n     fn test_from_bits_truncate() {\n         assert!(Flags::from_bits_truncate(0) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0x1) == FlagA);\n-        assert!(Flags::from_bits_truncate(0x10) == FlagB);\n-        assert!(Flags::from_bits_truncate(0x11) == (FlagA | FlagB));\n-        assert!(Flags::from_bits_truncate(0x1000) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0x1001) == FlagA);\n+        assert!(Flags::from_bits_truncate(0b1) == FlagA);\n+        assert!(Flags::from_bits_truncate(0b10) == FlagB);\n+        assert!(Flags::from_bits_truncate(0b11) == (FlagA | FlagB));\n+        assert!(Flags::from_bits_truncate(0b1000) == Flags::empty());\n+        assert!(Flags::from_bits_truncate(0b1001) == FlagA);\n \n         assert!(AnotherSetOfFlags::from_bits_truncate(0_i8) == AnotherSetOfFlags::empty());\n     }"}, {"sha": "bbaab5ee3db8fbb7e0c61b86da43ca5f4283ac58", "filename": "src/libstd/bool.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,6 +11,5 @@\n //! The boolean type\n \n #![doc(primitive = \"bool\")]\n-#![unstable = \"this module is purely for documentation and it will likely be \\\n-               removed from the public api\"]\n+#![stable]\n ", "previous_filename": "src/libcore/bool.rs"}, {"sha": "8149864afd405e4ac79783805b48aa231f55350e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-pub use self::Entry::*;\n+use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n@@ -30,18 +30,20 @@ use option::Option::{Some, None};\n use result::Result;\n use result::Result::{Ok, Err};\n \n-use super::table;\n use super::table::{\n+    mod,\n     Bucket,\n-    Empty,\n     EmptyBucket,\n-    Full,\n     FullBucket,\n     FullBucketImm,\n     FullBucketMut,\n     RawTable,\n     SafeHash\n };\n+use super::table::BucketState::{\n+    Empty,\n+    Full,\n+};\n \n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -379,7 +381,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n             assert!(probe.index() != idx_end);\n \n             let full_bucket = match probe.peek() {\n-                table::Empty(bucket) => {\n+                Empty(bucket) => {\n                     // Found a hole!\n                     let b = bucket.put(old_hash, old_key, old_val);\n                     // Now that it's stolen, just read the value's pointer\n@@ -390,7 +392,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n                                .into_mut_refs()\n                                .1;\n                 },\n-                table::Full(bucket) => bucket\n+                Full(bucket) => bucket\n             };\n \n             let probe_ib = full_bucket.index() - full_bucket.distance();\n@@ -1470,7 +1472,7 @@ mod test_map {\n     use prelude::*;\n \n     use super::HashMap;\n-    use super::{Occupied, Vacant};\n+    use super::Entry::{Occupied, Vacant};\n     use hash;\n     use iter::{range_inclusive, range_step_inclusive};\n     use cell::RefCell;"}, {"sha": "f587669d3dacd5e967aa9d9e38e97a4b1ff4afa9", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -17,7 +17,7 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n+use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n@@ -250,8 +250,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems { iter: self.map.keys() }\n+    pub fn iter<'a>(&'a self) -> Iter<'a, T> {\n+        Iter { iter: self.map.keys() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n@@ -275,10 +275,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// }\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(self) -> SetMoveItems<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        SetMoveItems { iter: self.map.into_iter().map(first) }\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n \n     /// Visit the values representing the difference.\n@@ -304,14 +304,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n-        fn filter<'a, T, S, H>((other, elt): (&HashSet<T, H>, &'a T)) -> Option<&'a T> where\n-            T: Eq + Hash<S>, H: Hasher<S>\n-        {\n-            if !other.contains(elt) { Some(elt) } else { None }\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> {\n+        Difference {\n+            iter: self.iter(),\n+            other: other,\n         }\n-\n-        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the symmetric difference.\n@@ -336,8 +333,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> SymDifferenceItems<'a, T, H> {\n-        SymDifferenceItems { iter: self.difference(other).chain(other.difference(self)) }\n+        -> SymmetricDifference<'a, T, H> {\n+        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n     /// Visit the values representing the intersection.\n@@ -358,14 +355,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n-        fn filter<'a, T, S, H>((other, elt): (&HashSet<T, H>, &'a T)) -> Option<&'a T> where\n-            T: Eq + Hash<S>, H: Hasher<S>\n-        {\n-            if other.contains(elt) { Some(elt) } else { None }\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> {\n+        Intersection {\n+            iter: self.iter(),\n+            other: other,\n         }\n-\n-        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the union.\n@@ -386,8 +380,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> UnionItems<'a, T, H> {\n-        UnionItems { iter: self.iter().chain(other.difference(self)) }\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> {\n+        Union { iter: self.iter().chain(other.difference(self)) }\n     }\n \n     /// Return the number of elements in the set\n@@ -625,12 +619,12 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n }\n \n /// HashSet iterator\n-pub struct SetItems<'a, K: 'a> {\n+pub struct Iter<'a, K: 'a> {\n     iter: Keys<'a, K, ()>\n }\n \n /// HashSet move iterator\n-pub struct SetMoveItems<K> {\n+pub struct IntoIter<K> {\n     iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n }\n \n@@ -639,34 +633,38 @@ pub struct Drain<'a, K: 'a> {\n     iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n-// `Repeat` is used to feed the filter closure an explicit capture\n-// of a reference to the other set\n-/// Set operations iterator, used directly for intersection and difference\n-pub struct SetAlgebraItems<'a, T: 'a, H: 'a> {\n-    iter: FilterMap<\n-        (&'a HashSet<T, H>, &'a T),\n-        &'a T,\n-        Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n-        for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n-    >\n+/// Intersection iterator\n+pub struct Intersection<'a, T: 'a, H: 'a> {\n+    // iterator of the first set\n+    iter: Iter<'a, T>,\n+    // the second set\n+    other: &'a HashSet<T, H>,\n+}\n+\n+/// Difference iterator\n+pub struct Difference<'a, T: 'a, H: 'a> {\n+    // iterator of the first set\n+    iter: Iter<'a, T>,\n+    // the second set\n+    other: &'a HashSet<T, H>,\n }\n \n /// Symmetric difference iterator.\n-pub struct SymDifferenceItems<'a, T: 'a, H: 'a> {\n-    iter: Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>>\n+pub struct SymmetricDifference<'a, T: 'a, H: 'a> {\n+    iter: Chain<Difference<'a, T, H>, Difference<'a, T, H>>\n }\n \n /// Set union iterator.\n-pub struct UnionItems<'a, T: 'a, H: 'a> {\n-    iter: Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>>\n+pub struct Union<'a, T: 'a, H: 'a> {\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, H>>\n }\n \n-impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n+impl<'a, K> Iterator<&'a K> for Iter<'a, K> {\n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<K> Iterator<K> for SetMoveItems<K> {\n+impl<K> Iterator<K> for IntoIter<K> {\n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n@@ -676,17 +674,56 @@ impl<'a, K: 'a> Iterator<K> for Drain<'a, K> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+impl<'a, T, S, H> Iterator<&'a T> for Intersection<'a, T, H>\n+    where T: Eq + Hash<S>, H: Hasher<S>\n+{\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match self.iter.next() {\n+                None => return None,\n+                Some(elt) => if self.other.contains(elt) {\n+                    return Some(elt)\n+                },\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper)\n+    }\n+}\n+\n+impl<'a, T, S, H> Iterator<&'a T> for Difference<'a, T, H>\n+    where T: Eq + Hash<S>, H: Hasher<S>\n+{\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match self.iter.next() {\n+                None => return None,\n+                Some(elt) => if !self.other.contains(elt) {\n+                    return Some(elt)\n+                },\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper)\n+    }\n }\n \n-impl<'a, T, H> Iterator<&'a T> for SymDifferenceItems<'a, T, H> {\n+impl<'a, T, S, H> Iterator<&'a T> for SymmetricDifference<'a, T, H>\n+    where T: Eq + Hash<S>, H: Hasher<S>\n+{\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<'a, T, H> Iterator<&'a T> for UnionItems<'a, T, H> {\n+impl<'a, T, S, H> Iterator<&'a T> for Union<'a, T, H>\n+    where T: Eq + Hash<S>, H: Hasher<S>\n+{\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }"}, {"sha": "ce7dbd8ea5ecb10b3c9250b3c374acba0fc06cce", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-pub use self::BucketState::*;\n+use self::BucketState::*;\n \n use clone::Clone;\n use cmp;"}, {"sha": "55f5662dbd897274b489c897fe19289342736643", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -628,7 +628,7 @@ impl<T: Send> Sender<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n@@ -756,7 +756,7 @@ impl<T: Send> SyncSender<T> {\n     }\n }\n \n-#[unstable]\n+#[stable]\n impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }"}, {"sha": "4d8c7d67b8c2ea15f36ac9b090c94595c123d5d5", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -200,7 +200,7 @@ mod test {\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n pub mod dl {\n-    pub use self::Rtld::*;\n+    use self::Rtld::*;\n \n     use prelude::*;\n     use c_str::CString;"}, {"sha": "3a18b0dc1b525b495cb968a8b3dba01f2a13a7d4", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -132,6 +132,7 @@ impl ChanWriter {\n     }\n }\n \n+#[stable]\n impl Clone for ChanWriter {\n     fn clone(&self) -> ChanWriter {\n         ChanWriter { tx: self.tx.clone() }"}, {"sha": "36dd549235698e5c2f59c2c0e310b602837046fc", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -104,7 +104,7 @@ pub struct StdinReader {\n     inner: Arc<Mutex<BufferedReader<StdReader>>>,\n }\n \n-/// A guard for exlusive access to `StdinReader`'s internal `BufferedReader`.\n+/// A guard for exclusive access to `StdinReader`'s internal `BufferedReader`.\n pub struct StdinReaderGuard<'a> {\n     inner: MutexGuard<'a, BufferedReader<StdReader>>,\n }"}, {"sha": "c2b4d5a1fa98241d776a68db3e15e279d242d404", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -23,6 +23,56 @@ use sync::atomic;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::io::TempDir;\n+///\n+/// {\n+///     // create a temporary directory\n+///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///         Ok(dir) => dir,\n+///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n+///     };\n+///\n+///     // get the path of the temporary directory without affecting the wrapper\n+///     let tmppath = tmpdir.path();\n+///\n+///     println!(\"The path of temporary directory is {}\", tmppath.display());\n+///\n+///     // the temporary directory is automatically removed when tmpdir goes\n+///     // out of scope at the end of the block\n+/// }\n+/// {\n+///     // create a temporary directory, this time using a custom path\n+///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"mysuffix\") {\n+///         Ok(dir) => dir,\n+///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n+///     };\n+///\n+///     // get the path of the temporary directory and disable automatic deletion in the wrapper\n+///     let tmppath = tmpdir.into_inner();\n+///\n+///     println!(\"The path of the not-so-temporary directory is {}\", tmppath.display());\n+///\n+///     // the temporary directory is not removed here\n+///     // because the directory is detached from the wrapper\n+/// }\n+/// {\n+///     // create a temporary directory\n+///     let tmpdir = match TempDir::new(\"mysuffix\") {\n+///         Ok(dir) => dir,\n+///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n+///     };\n+///\n+///     // close the temporary directory manually and check the result\n+///     match tmpdir.close() {\n+///         Ok(_) => println!(\"success!\"),\n+///         Err(e) => panic!(\"couldn't remove temporary directory: {}\", e)\n+///     };\n+/// }\n+/// ```\n pub struct TempDir {\n     path: Option<Path>,\n     disarmed: bool"}, {"sha": "8274baeacfad8378bb798da295f24f0982d4c7ee", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -135,7 +135,6 @@ extern crate libc;\n // NB: These reexports are in the order they should be listed in rustdoc\n \n pub use core::any;\n-pub use core::bool;\n pub use core::borrow;\n pub use core::cell;\n pub use core::clone;\n@@ -150,10 +149,6 @@ pub use core::mem;\n pub use core::ptr;\n pub use core::raw;\n pub use core::simd;\n-pub use core::tuple;\n-// FIXME #15320: primitive documentation needs top-level modules, this\n-// should be `std::tuple::unit`.\n-pub use core::unit;\n pub use core::result;\n pub use core::option;\n \n@@ -243,6 +238,12 @@ pub mod comm;\n pub mod rt;\n mod failure;\n \n+// Documentation for primitive types\n+\n+mod bool;\n+mod unit;\n+mod tuple;\n+\n // A curious inner-module that's not exported that contains the binding\n // 'std' so that macro-expanded references to std::error and such\n // can be resolved within libstd."}, {"sha": "951627b26cad90b5ec8dd03ab53a59acc5bc1a28", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,6 +21,9 @@ use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n+use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n+use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n+use num::strconv::SignFormat::SignNeg;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -252,7 +255,7 @@ impl FloatMath for f32 {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -265,7 +268,7 @@ pub fn to_string(num: f32) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n+        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -279,8 +282,7 @@ pub fn to_str_hex(num: f32) -> String {\n #[inline]\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n+    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n /// Converts a float to a string with exactly the number of\n@@ -294,7 +296,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -309,7 +311,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -325,7 +327,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n+        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -341,7 +343,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n+        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "7cc94b9ebbbcb9b8b4f2937cd40e8e8a22843372", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,6 +20,9 @@ use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n+use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n+use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n+use num::strconv::SignFormat::SignNeg;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -260,7 +263,7 @@ impl FloatMath for f64 {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -273,7 +276,7 @@ pub fn to_string(num: f64) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n+        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -287,8 +290,7 @@ pub fn to_str_hex(num: f64) -> String {\n #[inline]\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n+    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n /// Converts a float to a string with exactly the number of\n@@ -302,7 +304,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -317,7 +319,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n+        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -333,7 +335,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n+        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -349,7 +351,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n #[experimental = \"may be removed or relocated\"]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n+        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "9ccb1544fdc6614d2c0a8f0a95ac6104baf7d45c", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n-#![unstable]\n+#![stable]\n #![doc(primitive = \"int\")]\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "b3e4dd52f89cb9d5ccc9e69297a6f368741e2c20", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,9 +12,9 @@\n \n #![allow(missing_docs)]\n \n-pub use self::ExponentFormat::*;\n-pub use self::SignificantDigits::*;\n-pub use self::SignFormat::*;\n+use self::ExponentFormat::*;\n+use self::SignificantDigits::*;\n+use self::SignFormat::*;\n \n use char::{mod, Char};\n use num::{mod, Int, Float, FPNaN, FPInfinite, ToPrimitive};"}, {"sha": "cd000b3098bff4f6a7953a7d282299105144efc5", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n-#![unstable]\n+#![stable]\n #![doc(primitive = \"uint\")]\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "258e8964a9fdfb57437bae146c9baef8a4d69813", "filename": "src/libstd/os.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -28,9 +28,9 @@\n #![allow(non_snake_case)]\n #![allow(unused_imports)]\n \n-pub use self::MemoryMapKind::*;\n-pub use self::MapOption::*;\n-pub use self::MapError::*;\n+use self::MemoryMapKind::*;\n+use self::MapOption::*;\n+use self::MapError::*;\n \n use clone::Clone;\n use error::{FromError, Error};\n@@ -1617,8 +1617,8 @@ mod tests {\n         use result::Result::{Ok, Err};\n \n         let chunk = match os::MemoryMap::new(16, &[\n-            os::MapReadable,\n-            os::MapWritable\n+            os::MapOption::MapReadable,\n+            os::MapOption::MapWritable\n         ]) {\n             Ok(chunk) => chunk,\n             Err(msg) => panic!(\"{}\", msg)\n@@ -1660,10 +1660,10 @@ mod tests {\n         file.write_u8(0);\n \n         let chunk = MemoryMap::new(size / 2, &[\n-            MapReadable,\n-            MapWritable,\n-            MapFd(get_fd(&file)),\n-            MapOffset(size / 2)\n+            MapOption::MapReadable,\n+            MapOption::MapWritable,\n+            MapOption::MapFd(get_fd(&file)),\n+            MapOption::MapOffset(size / 2)\n         ]).unwrap();\n         assert!(chunk.len > 0);\n "}, {"sha": "c2c17103554ce608e1abba4cfa9d8c2ef0d99c2c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@\n \n //! Windows file path handling\n \n-pub use self::PathPrefix::*;\n+use self::PathPrefix::*;\n \n use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n@@ -1117,6 +1117,7 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n mod tests {\n     use prelude::*;\n     use super::*;\n+    use super::PathPrefix::*;\n     use super::parse_prefix;\n \n     macro_rules! t {"}, {"sha": "f77627711a71f8a1793069c12f6abe4b57c5b301", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -81,9 +81,9 @@\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n #[doc(no_inline)] pub use str::{StrAllocating, UnicodeStrPrelude};\n-#[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n-#[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n-#[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n+#[doc(no_inline)] pub use core::prelude::{Tuple1, Tuple2, Tuple3, Tuple4};\n+#[doc(no_inline)] pub use core::prelude::{Tuple5, Tuple6, Tuple7, Tuple8};\n+#[doc(no_inline)] pub use core::prelude::{Tuple9, Tuple10, Tuple11, Tuple12};\n #[doc(no_inline)] pub use slice::AsSlice;\n #[doc(no_inline)] pub use slice::{VectorVector, PartialEqSliceExt};\n #[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};"}, {"sha": "c590c0f575ee639053d000769f8c75bcc65fb8eb", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -45,7 +45,7 @@\n //!     so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n //!     However, this means that `/dev/urandom` can yield somewhat predictable randomness\n //!     if the entropy pool is very small, such as immediately after first booting.\n-//!     Linux 3,17 added `getrandom(2)` system call which solves the issue: it blocks if entropy\n+//!     Linux 3.17 added the `getrandom(2)` system call which solves the issue: it blocks if entropy\n //!     pool is not initialized yet, but it does not block once initialized.\n //!     `OsRng` tries to use `getrandom(2)` if available, and use `/dev/urandom` fallback if not.\n //!     If an application does not have `getrandom` and likely to be run soon after first booting,\n@@ -126,7 +126,7 @@\n //! > Is it to your advantage to switch your choice?\n //!\n //! The rather unintuitive answer is that you will have a 2/3 chance of winning if\n-//! you switch and a 1/3 chance of winning of you don't, so it's better to switch.\n+//! you switch and a 1/3 chance of winning if you don't, so it's better to switch.\n //!\n //! This program will simulate the game show and with large enough simulation steps\n //! it will indeed confirm that it is better to switch."}, {"sha": "68c99b12758556fae7a597a583032d696d2623e9", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -170,7 +170,6 @@ mod imp {\n     extern crate libc;\n \n     use io::{IoResult};\n-    use kinds::marker;\n     use mem;\n     use os;\n     use rand::Rng;"}, {"sha": "b1f268597c7ad99fb83df15edd9f7d6a2d652183", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -44,12 +44,10 @@ pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\"))]\n mod imp {\n-    use core::prelude::*;\n+    use prelude::*;\n \n-    use boxed::Box;\n-    use vec::Vec;\n-    use string::String;\n     use mem;\n+    use slice;\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -98,7 +96,12 @@ mod imp {\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         Vec::from_fn(argc as uint, |i| {\n-            String::from_raw_buf(*argv.offset(i as int)).into_bytes()\n+            let arg = *argv.offset(i as int);\n+            let mut len = 0u;\n+            while *arg.offset(len as int) != 0 {\n+                len += 1u;\n+            }\n+            slice::from_raw_buf(&arg, len).to_vec()\n         })\n     }\n "}, {"sha": "382f6875b281d01c3c788659978862f17608a381", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::SocketStatus::*;\n-pub use self::InAddr::*;\n+use self::SocketStatus::*;\n+use self::InAddr::*;\n \n use alloc::arc::Arc;\n use libc::{mod, c_char, c_int};"}, {"sha": "983d0e5fa1486b1de52656a47f3035015aee4c9d", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -105,7 +105,7 @@ use sys_common::backtrace::*;\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n #[inline(never)]\n pub fn write(w: &mut Writer) -> IoResult<()> {\n-    use iter::{Iterator, range};\n+    use iter::{IteratorExt, range};\n     use result;\n     use slice::SliceExt;\n \n@@ -117,7 +117,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n     // couple of tasks panic simultaneously\n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n     let _g = unsafe { LOCK.lock() };\n \n     try!(writeln!(w, \"stack backtrace:\"));"}, {"sha": "348b7cfad334ebf78aaca12cf65ff273662131be", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -19,6 +19,7 @@ use prelude::*;\n use sys::{mod, timer, retry, c, set_nonblocking, wouldblock};\n use sys::fs::{fd_t, FileDesc};\n use sys_common::net::*;\n+use sys_common::net::SocketStatus::*;\n use sys_common::{eof, mkerr_libc};\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {"}, {"sha": "5c99ad1e0ce223eeed6462ed42822a5f085e2f8f", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,6 +21,7 @@ use sys::{set_nonblocking, wouldblock};\n use sys;\n use sys_common;\n use sys_common::net;\n+use sys_common::net::SocketStatus::Readable;\n \n pub use sys_common::net::TcpStream;\n \n@@ -124,7 +125,7 @@ impl TcpAcceptor {\n                 fd => return Ok(TcpStream::new(fd as sock_t)),\n             }\n             try!(net::await(&[self.fd(), self.inner.reader.fd()],\n-                       deadline, net::Readable));\n+                       deadline, Readable));\n         }\n \n         Err(sys_common::eof())"}, {"sha": "fe393b81e3d9a0a0f4194d3df54e1e28a08600c1", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -46,7 +46,7 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n-pub use self::Req::*;\n+use self::Req::*;\n \n use libc;\n use mem;"}, {"sha": "7e4dd768aa975f8ef6f3a4bb8921037906acfb47", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,7 +20,7 @@\n //! Other than that, the implementation is pretty straightforward in terms of\n //! the other two implementations of timers with nothing *that* new showing up.\n \n-pub use self::Req::*;\n+use self::Req::*;\n \n use libc;\n use ptr;"}, {"sha": "f7351c9580f2fbecfb35891fe46e1772eba3ea5a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -287,21 +287,6 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration,Duration> for Duration {\n-    fn add(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs + rhs.secs;\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Duration> for Duration {\n     fn add(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n@@ -314,21 +299,6 @@ impl Add<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Duration,Duration> for Duration {\n-    fn sub(&self, rhs: &Duration) -> Duration {\n-        let mut secs = self.secs - rhs.secs;\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Duration, Duration> for Duration {\n     fn sub(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -341,19 +311,6 @@ impl Sub<Duration, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Mul<i32,Duration> for Duration {\n-    fn mul(&self, rhs: &i32) -> Duration {\n-        // Multiply nanoseconds as i64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as i64 * *rhs as i64;\n-        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n-        let secs = self.secs * *rhs as i64 + extra_secs;\n-        Duration { secs: secs, nanos: nanos as i32 }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Mul<i32, Duration> for Duration {\n     fn mul(self, rhs: i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -364,27 +321,6 @@ impl Mul<i32, Duration> for Duration {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Div<i32,Duration> for Duration {\n-    fn div(&self, rhs: &i32) -> Duration {\n-        let mut secs = self.secs / *rhs as i64;\n-        let carry = self.secs - secs * *rhs as i64;\n-        let extra_nanos = carry * NANOS_PER_SEC as i64 / *rhs as i64;\n-        let mut nanos = self.nanos / *rhs + extra_nanos as i32;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Div<i32, Duration> for Duration {\n     fn div(self, rhs: i32) -> Duration {\n         let mut secs = self.secs / rhs as i64;"}, {"sha": "5cd60d6e153ea0cf4bcd42f95b1d65bff8dc19a1", "filename": "src/libstd/tuple.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on tuples\n+//!\n+//! To access a single element of a tuple one can use the following\n+//! methods:\n+//!\n+//! * `valN` - returns a value of _N_-th element\n+//! * `refN` - returns a reference to _N_-th element\n+//! * `mutN` - returns a mutable reference to _N_-th element\n+//!\n+//! Indexing starts from zero, so `val0` returns first value, `val1`\n+//! returns second value, and so on. In general, a tuple with _S_\n+//! elements provides aforementioned methods suffixed with numbers\n+//! from `0` to `S-1`. Traits which contain these methods are\n+//! implemented for tuples with up to 12 elements.\n+//!\n+//! If every type inside a tuple implements one of the following\n+//! traits, then a tuple itself also implements it.\n+//!\n+//! * `Clone`\n+//! * `PartialEq`\n+//! * `Eq`\n+//! * `PartialOrd`\n+//! * `Ord`\n+//! * `Default`\n+//!\n+//! # Examples\n+//!\n+//! Using methods:\n+//!\n+//! ```\n+//! #[allow(deprecated)]\n+//! # fn main() {\n+//! let pair = (\"pi\", 3.14f64);\n+//! assert_eq!(pair.val0(), \"pi\");\n+//! assert_eq!(pair.val1(), 3.14f64);\n+//! # }\n+//! ```\n+//!\n+//! Using traits implemented for tuples:\n+//!\n+//! ```\n+//! use std::default::Default;\n+//!\n+//! let a = (1i, 2i);\n+//! let b = (3i, 4i);\n+//! assert!(a != b);\n+//!\n+//! let c = b.clone();\n+//! assert!(b == c);\n+//!\n+//! let d : (u32, f32) = Default::default();\n+//! assert_eq!(d, (0u32, 0.0f32));\n+//! ```\n+\n+#![doc(primitive = \"tuple\")]\n+#![stable]"}, {"sha": "012b175b031f15ce0174fcf02dfd81e7a0f7ace1", "filename": "src/libstd/unit.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n #![doc(primitive = \"unit\")]\n-#![unstable = \"this module is purely for documentation and it will likely be \\\n-               removed from the public api\"]\n+#![stable]\n \n //! The `()` type, sometimes called \"unit\" or \"nil\".\n //!", "previous_filename": "src/libcore/tuple/unit.rs"}, {"sha": "a294706ef2c10ff67131e4cbb6b517367592b97a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -32,7 +32,6 @@ pub use self::LitIntType::*;\n pub use self::LocalSource::*;\n pub use self::Mac_::*;\n pub use self::MacStmtStyle::*;\n-pub use self::MatchSource::*;\n pub use self::MetaItem_::*;\n pub use self::Method_::*;\n pub use self::Mutability::*;\n@@ -760,9 +759,9 @@ pub struct QPath {\n \n #[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum MatchSource {\n-    MatchNormal,\n-    MatchIfLetDesugar,\n-    MatchWhileLetDesugar,\n+    Normal,\n+    IfLetDesugar { contains_else_clause: bool },\n+    WhileLetDesugar,\n }\n \n #[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]"}, {"sha": "c726e17a8fa653e678a6010cc2b2900f0570ee88", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -48,30 +48,12 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<BytePos, BytePos> for BytePos {\n-    fn add(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<BytePos, BytePos> for BytePos {\n     fn add(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<BytePos, BytePos> for BytePos {\n-    fn sub(&self, rhs: &BytePos) -> BytePos {\n-        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<BytePos, BytePos> for BytePos {\n     fn sub(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() - rhs.to_uint()) as u32)\n@@ -83,30 +65,12 @@ impl Pos for CharPos {\n     fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<CharPos,CharPos> for CharPos {\n-    fn add(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() + rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<CharPos, CharPos> for CharPos {\n     fn add(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<CharPos,CharPos> for CharPos {\n-    fn sub(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(self.to_uint() - rhs.to_uint())\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<CharPos, CharPos> for CharPos {\n     fn sub(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() - rhs.to_uint())"}, {"sha": "aefbb2a1feab365e0d0629a76fb24feecf7731fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -490,7 +490,7 @@ impl<'a> ExtCtxt<'a> {\n \n     /// Returns a `Folder` for deeply expanding all macros in a AST node.\n     pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n-        expand::MacroExpander { cx: self }\n+        expand::MacroExpander::new(self)\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])"}, {"sha": "9d4992f7453d0ab638982fa8756b6db6f6a43c23", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -868,7 +868,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n-        self.expr(span, ast::ExprMatch(arg, arms, ast::MatchNormal))\n+        self.expr(span, ast::ExprMatch(arg, arms, ast::MatchSource::Normal))\n     }\n \n     fn expr_if(&self, span: Span, cond: P<ast::Expr>,"}, {"sha": "b10ae7a09db17a7c518eeb557e2a6e37a8c412c7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -15,6 +15,7 @@ use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n use ast;\n+use ast_util::path_to_ident;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n@@ -37,6 +38,30 @@ enum Either<L,R> {\n     Right(R)\n }\n \n+pub fn expand_type(t: P<ast::Ty>,\n+                   fld: &mut MacroExpander,\n+                   impl_ty: Option<P<ast::Ty>>)\n+                   -> P<ast::Ty> {\n+    debug!(\"expanding type {} with impl_ty {}\", t, impl_ty);\n+    let t = match (t.node.clone(), impl_ty) {\n+        // Expand uses of `Self` in impls to the concrete type.\n+        (ast::Ty_::TyPath(ref path, _), Some(ref impl_ty)) => {\n+            let path_as_ident = path_to_ident(path);\n+            // Note unhygenic comparison here. I think this is correct, since\n+            // even though `Self` is almost just a type parameter, the treatment\n+            // for this expansion is as if it were a keyword.\n+            if path_as_ident.is_some() &&\n+               path_as_ident.unwrap().name == token::special_idents::type_self.name {\n+                impl_ty.clone()\n+            } else {\n+                t\n+            }\n+        }\n+        _ => t\n+    };\n+    fold::noop_fold_ty(t, fld)\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -97,7 +122,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // `match <expr> { ... }`\n             let arms = vec![pat_arm, break_arm];\n             let match_expr = fld.cx.expr(span,\n-                                         ast::ExprMatch(expr, arms, ast::MatchWhileLetDesugar));\n+                                    ast::ExprMatch(expr, arms, ast::MatchSource::WhileLetDesugar));\n \n             // `[opt_ident]: loop { ... }`\n             let loop_block = fld.cx.block_expr(match_expr);\n@@ -158,6 +183,8 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 arms\n             };\n \n+            let contains_else_clause = elseopt.is_some();\n+\n             // `_ => [<elseopt> | ()]`\n             let else_arm = {\n                 let pat_under = fld.cx.pat_wild(span);\n@@ -170,7 +197,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             arms.extend(else_if_arms.into_iter());\n             arms.push(else_arm);\n \n-            let match_expr = fld.cx.expr(span, ast::ExprMatch(expr, arms, ast::MatchIfLetDesugar));\n+            let match_expr = fld.cx.expr(span,\n+                                         ast::ExprMatch(expr, arms,\n+                                                ast::MatchSource::IfLetDesugar {\n+                                                    contains_else_clause: contains_else_clause,\n+                                                }));\n             fld.fold_expr(match_expr)\n         }\n \n@@ -1059,6 +1090,14 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n+    // The type of the impl currently being expanded.\n+    current_impl_type: Option<P<ast::Ty>>,\n+}\n+\n+impl<'a, 'b> MacroExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>) -> MacroExpander<'a, 'b> {\n+        MacroExpander { cx: cx, current_impl_type: None }\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -1071,7 +1110,14 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        expand_item(item, self)\n+        let prev_type = self.current_impl_type.clone();\n+        if let ast::Item_::ItemImpl(_, _, _, ref ty, _) = item.node {\n+            self.current_impl_type = Some(ty.clone());\n+        }\n+\n+        let result = expand_item(item, self);\n+        self.current_impl_type = prev_type;\n+        result\n     }\n \n     fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n@@ -1094,6 +1140,11 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_method(method, self)\n     }\n \n+    fn fold_ty(&mut self, t: P<ast::Ty>) -> P<ast::Ty> {\n+        let impl_type = self.current_impl_type.clone();\n+        expand_type(t, self, impl_type)\n+    }\n+\n     fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n@@ -1138,9 +1189,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n-    let mut expander = MacroExpander {\n-        cx: &mut cx,\n-    };\n+    let mut expander = MacroExpander::new(&mut cx);\n \n     for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n         let name = format!(\"<{} macros>\", token::get_ident(crate_name))"}, {"sha": "95c7fcc564af8ad3465ff56c09668744985d70d8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -654,6 +654,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n                     \"\"  => \"Show\",\n+                    \"?\" => \"Show\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\",\n                     \"o\" => \"Octal\","}, {"sha": "f0392912878ff5c8f5aba57e64a62347361d0042", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,7 +21,7 @@ use ast::{Ident, Mrk, Name, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having"}, {"sha": "bc639c32380f5eb040250122ed7663dc9e41dd86", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -98,7 +98,7 @@ use ptr::P;\n use std::mem;\n use std::rc::Rc;\n use std::collections::HashMap;\n-use std::collections::hash_map::{Vacant, Occupied};\n+use std::collections::hash_map::Entry::{Vacant, Occupied};\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has\n // a nonempty body."}, {"sha": "378dbba07fa69536e43976a896cba1a51983506f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -106,30 +106,6 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n-    fn add(&self, other: &LockstepIterSize) -> LockstepIterSize {\n-        match *self {\n-            LisUnconstrained => other.clone(),\n-            LisContradiction(_) => self.clone(),\n-            LisConstraint(l_len, l_id) => match *other {\n-                LisUnconstrained => self.clone(),\n-                LisContradiction(_) => other.clone(),\n-                LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n-                LisConstraint(r_len, r_id) => {\n-                    let l_n = token::get_ident(l_id);\n-                    let r_n = token::get_ident(r_id);\n-                    LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                              '{}' has {} items, but '{}' has {}\",\n-                                              l_n, l_len, r_n, r_len).to_string())\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n     fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n         match self {"}, {"sha": "19af118b190517d57591b43021ea101c8400af05", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -41,7 +41,7 @@ use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n-use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchNormal};\n+use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n@@ -1545,7 +1545,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::OpenDelim(token::Bracket));\n             let t = self.parse_ty_sum();\n \n-            // Parse the `, ..e` in `[ int, ..e ]`\n+            // Parse the `; e` in `[ int; e ]`\n             // where `e` is a const expression\n             let t = match self.maybe_parse_fixed_vstore() {\n                 None => TyVec(t),\n@@ -1713,6 +1713,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             self.bump();\n             Some(self.parse_expr())\n+        } else if self.check(&token::Semi) {\n+            self.bump();\n+            Some(self.parse_expr())\n         } else {\n             None\n         }\n@@ -2259,6 +2262,12 @@ impl<'a> Parser<'a> {\n                         let count = self.parse_expr();\n                         self.expect(&token::CloseDelim(token::Bracket));\n                         ex = ExprRepeat(first_expr, count);\n+                    } else if self.check(&token::Semi) {\n+                        // Repeating vector syntax: [ 0; 512 ]\n+                        self.bump();\n+                        let count = self.parse_expr();\n+                        self.expect(&token::CloseDelim(token::Bracket));\n+                        ex = ExprRepeat(first_expr, count);\n                     } else if self.check(&token::Comma) {\n                         // Vector with two or more elements.\n                         self.bump();\n@@ -3111,7 +3120,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.span.hi;\n         self.bump();\n-        return self.mk_expr(lo, hi, ExprMatch(discriminant, arms, MatchNormal));\n+        return self.mk_expr(lo, hi, ExprMatch(discriminant, arms, MatchSource::Normal));\n     }\n \n     pub fn parse_arm(&mut self) -> Arm {"}, {"sha": "a9717a526ad9db6cb28327ec56cc97d5df7c0e25", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -755,7 +755,7 @@ impl<'a> State<'a> {\n             ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n-                try!(word(&mut self.s, \", ..\"));\n+                try!(word(&mut self.s, \"; \"));\n                 try!(self.print_expr(&**v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -1531,8 +1531,7 @@ impl<'a> State<'a> {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_expr(&**element));\n-                try!(word(&mut self.s, \",\"));\n-                try!(word(&mut self.s, \"..\"));\n+                try!(self.word_space(\";\"));\n                 try!(self.print_expr(&**count));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());"}, {"sha": "41146cded704c281779f9e925f66c0a76c6e7ddc", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,7 +11,7 @@\n #![allow(missing_docs)]\n \n use std::collections::hash_map;\n-use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::fmt::Show;\n use std::hash::Hash;\n use std::io;"}, {"sha": "dfa9b9242740ef278c438566584ff2337b1635cf", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -97,29 +97,6 @@ impl Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Add<Duration, Timespec> for Timespec {\n-    fn add(&self, other: &Duration) -> Timespec {\n-        let d_sec = other.num_seconds();\n-        // It is safe to unwrap the nanoseconds, because there cannot be\n-        // more than one second left, which fits in i64 and in i32.\n-        let d_nsec = (*other - Duration::seconds(d_sec))\n-                     .num_nanoseconds().unwrap() as i32;\n-        let mut sec = self.sec + d_sec;\n-        let mut nsec = self.nsec + d_nsec;\n-        if nsec >= NSEC_PER_SEC {\n-            nsec -= NSEC_PER_SEC;\n-            sec += 1;\n-        } else if nsec < 0 {\n-            nsec += NSEC_PER_SEC;\n-            sec -= 1;\n-        }\n-        Timespec::new(sec, nsec)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Add<Duration, Timespec> for Timespec {\n     fn add(self, other: Duration) -> Timespec {\n         let d_sec = other.num_seconds();\n@@ -140,17 +117,6 @@ impl Add<Duration, Timespec> for Timespec {\n     }\n }\n \n-// NOTE(stage0): Remove impl after a snapshot\n-#[cfg(stage0)]\n-impl Sub<Timespec, Duration> for Timespec {\n-    fn sub(&self, other: &Timespec) -> Duration {\n-        let sec = self.sec - other.sec;\n-        let nsec = self.nsec - other.nsec;\n-        Duration::seconds(sec) + Duration::nanoseconds(nsec as i64)\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n impl Sub<Timespec, Duration> for Timespec {\n     fn sub(self, other: Timespec) -> Duration {\n         let sec = self.sec - other.sec;"}, {"sha": "c3cdf4acba15080d24f77fb04c6c943b7cfa6282", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -1,3 +1,12 @@\n+S 2014-12-20 8443b09\n+  freebsd-x86_64 004f54dce86faeebc15abf92c8742634b53987e6\n+  linux-i386 3daf531aed03f5769402f2fef852377e2838db98\n+  linux-x86_64 4f3c8b092dd4fe159d6f25a217cf62e0e899b365\n+  macos-i386 2a3e647b9c400505bd49cfe56091e866c83574ca\n+  macos-x86_64 5e730efc34d79a33f464a87686c10eace0760a2e\n+  winnt-i386 8ea056043de82096d5ce5abc98c8c74ebac7e77d\n+  winnt-x86_64 9804100dafae9b64a76e0ea7e1be157719dae151\n+\n S 2014-12-15 1b97cd3\n   freebsd-x86_64 a5d7ff81ec04e01e64dc201c7aa2d875ebd0cbbb\n   linux-i386 47e13c2f1d26a0d13e593e0881a80ca103aa7b2e"}, {"sha": "d97a2e3cda129d9da850ae0acf5507ff21b3c033", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -28,7 +28,7 @@ impl<T> Foo {\n pub struct Parser<T>;\n impl<T: std::iter::Iterator<char>> Parser<T> {\n     fn in_doctype(&mut self) {\n-        static DOCTYPEPattern: [char, ..6] = ['O', 'C', 'T', 'Y', 'P', 'E'];\n+        static DOCTYPEPattern: [char; 6] = ['O', 'C', 'T', 'Y', 'P', 'E'];\n     }\n }\n "}, {"sha": "75cf864ce49612a00d48e336c4dd12ef8d03fd8e", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -37,20 +37,20 @@ fn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n }\n \n struct Noise2DContext {\n-    rgradients: [Vec2, ..256],\n-    permutations: [i32, ..256],\n+    rgradients: [Vec2; 256],\n+    permutations: [i32; 256],\n }\n \n impl Noise2DContext {\n     fn new() -> Noise2DContext {\n         let mut rng = StdRng::new().unwrap();\n \n-        let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }, ..256];\n+        let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }; 256];\n         for x in rgradients.iter_mut() {\n             *x = random_gradient(&mut rng);\n         }\n \n-        let mut permutations = [0i32, ..256];\n+        let mut permutations = [0i32; 256];\n         for (i, x) in permutations.iter_mut().enumerate() {\n             *x = i as i32;\n         }\n@@ -65,7 +65,7 @@ impl Noise2DContext {\n         self.rgradients[(idx & 255) as uint]\n     }\n \n-    fn get_gradients(&self, x: f32, y: f32) -> ([Vec2, ..4], [Vec2, ..4]) {\n+    fn get_gradients(&self, x: f32, y: f32) -> ([Vec2; 4], [Vec2; 4]) {\n         let x0f = x.floor();\n         let y0f = y.floor();\n         let x1f = x0f + 1.0;\n@@ -102,7 +102,7 @@ impl Noise2DContext {\n \n fn main() {\n     let symbols = [' ', '\u2591', '\u2592', '\u2593', '\u2588', '\u2588'];\n-    let mut pixels = [0f32, ..256*256];\n+    let mut pixels = [0f32; 256*256];\n     let n2d = Noise2DContext::new();\n \n     for _ in range(0u, 100) {"}, {"sha": "723b2b722d7e12258380e0594f9418367cf29975", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -64,14 +64,14 @@ fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n }\n \n struct P {\n-    p: [i32, .. 16],\n+    p: [i32; 16],\n }\n \n impl Copy for P {}\n \n struct Perm {\n-    cnt: [i32, .. 16],\n-    fact: [u32, .. 16],\n+    cnt: [i32; 16],\n+    fact: [u32; 16],\n     n: u32,\n     permcount: u32,\n     perm: P,\n@@ -81,21 +81,21 @@ impl Copy for Perm {}\n \n impl Perm {\n     fn new(n: u32) -> Perm {\n-        let mut fact = [1, .. 16];\n+        let mut fact = [1; 16];\n         for i in range(1, n as uint + 1) {\n             fact[i] = fact[i - 1] * i as u32;\n         }\n         Perm {\n-            cnt: [0, .. 16],\n+            cnt: [0; 16],\n             fact: fact,\n             n: n,\n             permcount: 0,\n-            perm: P { p: [0, .. 16 ] }\n+            perm: P { p: [0; 16 ] }\n         }\n     }\n \n     fn get(&mut self, mut idx: i32) -> P {\n-        let mut pp = [0u8, .. 16];\n+        let mut pp = [0u8; 16];\n         self.permcount = idx as u32;\n         for (i, place) in self.perm.p.iter_mut().enumerate() {\n             *place = i as i32 + 1;"}, {"sha": "eb18cfdaed3ad73bfc6b92ddab96c9880416a6ff", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -64,7 +64,7 @@ const ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n \n const NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n \n-static IUB: [AminoAcid, ..15] = [\n+static IUB: [AminoAcid;15] = [\n     AminoAcid { c: 'a' as u8, p: 0.27 },\n     AminoAcid { c: 'c' as u8, p: 0.12 },\n     AminoAcid { c: 'g' as u8, p: 0.12 },\n@@ -82,7 +82,7 @@ static IUB: [AminoAcid, ..15] = [\n     AminoAcid { c: 'Y' as u8, p: 0.02 },\n ];\n \n-static HOMO_SAPIENS: [AminoAcid, ..4] = [\n+static HOMO_SAPIENS: [AminoAcid;4] = [\n     AminoAcid { c: 'a' as u8, p: 0.3029549426680 },\n     AminoAcid { c: 'c' as u8, p: 0.1979883004921 },\n     AminoAcid { c: 'g' as u8, p: 0.1975473066391 },\n@@ -148,8 +148,8 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n     }\n }\n \n-fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n-    let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n+fn make_lookup(a: &[AminoAcid]) -> [AminoAcid;LOOKUP_SIZE] {\n+    let mut lookup = [ NULL_AMINO_ACID;LOOKUP_SIZE ];\n     let mut j = 0;\n     for (i, slot) in lookup.iter_mut().enumerate() {\n         while a[j].p < (i as f32) {\n@@ -162,7 +162,7 @@ fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n \n struct RandomFasta<'a, W:'a> {\n     seed: u32,\n-    lookup: [AminoAcid, ..LOOKUP_SIZE],\n+    lookup: [AminoAcid;LOOKUP_SIZE],\n     out: &'a mut W,\n }\n \n@@ -193,7 +193,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n     fn make(&mut self, n: uint) -> IoResult<()> {\n         let lines = n / LINE_LEN;\n         let chars_left = n % LINE_LEN;\n-        let mut buf = [0, ..LINE_LEN + 1];\n+        let mut buf = [0;LINE_LEN + 1];\n \n         for _ in range(0, lines) {\n             for i in range(0u, LINE_LEN) {"}, {"sha": "2de61cf3572c92c8cce0926f142df7ce48ff7e82", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -89,7 +89,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n     -> std::io::IoResult<()>\n {\n     try!(wr.write(header.as_bytes()));\n-    let mut line = [0u8, .. LINE_LENGTH + 1];\n+    let mut line = [0u8; LINE_LENGTH + 1];\n     while n > 0 {\n         let nb = min(LINE_LENGTH, n);\n         for i in range(0, nb) {"}, {"sha": "8521e2216e93f607f4bd24836f5a3ea5fd011f1b", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -46,10 +46,10 @@ use std::string::String;\n use std::slice;\n use std::sync::{Arc, Future};\n \n-static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n+static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;\n \n-static OCCURRENCES: [&'static str, ..5] = [\n+static OCCURRENCES: [&'static str;5] = [\n     \"GGT\",\n     \"GGTA\",\n     \"GGTATT\","}, {"sha": "dab67331120a9d6508477095c79c9891d30d2d13", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -45,7 +45,7 @@ const SOLAR_MASS: f64 = 4.0 * PI * PI;\n const YEAR: f64 = 365.24;\n const N_BODIES: uint = 5;\n \n-static BODIES: [Planet, ..N_BODIES] = [\n+static BODIES: [Planet;N_BODIES] = [\n     // Sun\n     Planet {\n         x: 0.0, y: 0.0, z: 0.0,\n@@ -102,7 +102,7 @@ struct Planet {\n \n impl Copy for Planet {}\n \n-fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: int) {\n+fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: int) {\n     for _ in range(0, steps) {\n         let mut b_slice = bodies.as_mut_slice();\n         loop {\n@@ -135,7 +135,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: int) {\n     }\n }\n \n-fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n+fn energy(bodies: &[Planet;N_BODIES]) -> f64 {\n     let mut e = 0.0;\n     let mut bodies = bodies.iter();\n     loop {\n@@ -155,7 +155,7 @@ fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n     e\n }\n \n-fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n+fn offset_momentum(bodies: &mut [Planet;N_BODIES]) {\n     let mut px = 0.0;\n     let mut py = 0.0;\n     let mut pz = 0.0;"}, {"sha": "d746ec1dbabd555ca940a4765dbb7def04526db0", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -50,17 +50,17 @@ use std::ptr::{copy_memory};\n use std::io::{IoResult, EndOfFile};\n \n struct Tables {\n-    table8: [u8, ..1 << 8],\n-    table16: [u16, ..1 << 16]\n+    table8: [u8;1 << 8],\n+    table16: [u16;1 << 16]\n }\n \n impl Tables {\n     fn new() -> Tables {\n-        let mut table8 = [0, ..1 << 8];\n+        let mut table8 = [0;1 << 8];\n         for (i, v) in table8.iter_mut().enumerate() {\n             *v = Tables::computed_cpl8(i as u8);\n         }\n-        let mut table16 = [0, ..1 << 16];\n+        let mut table16 = [0;1 << 16];\n         for (i, v) in table16.iter_mut().enumerate() {\n             *v = table8[i & 255] as u16 << 8 |\n                  table8[i >> 8]  as u16;"}, {"sha": "5fb7e2c3a84989b9095fece1f3675c352a09dc51", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -46,7 +46,7 @@ impl Sudoku {\n         return Sudoku { grid: g }\n     }\n \n-    pub fn from_vec(vec: &[[u8, ..9], ..9]) -> Sudoku {\n+    pub fn from_vec(vec: &[[u8;9];9]) -> Sudoku {\n         let g = Vec::from_fn(9u, |i| {\n             Vec::from_fn(9u, |j| { vec[i][j] })\n         });\n@@ -198,7 +198,7 @@ impl Colors {\n     }\n }\n \n-static DEFAULT_SUDOKU: [[u8, ..9], ..9] = [\n+static DEFAULT_SUDOKU: [[u8;9];9] = [\n          /* 0    1    2    3    4    5    6    7    8    */\n   /* 0 */  [0u8, 4u8, 0u8, 6u8, 0u8, 0u8, 0u8, 3u8, 2u8],\n   /* 1 */  [0u8, 0u8, 8u8, 0u8, 2u8, 0u8, 0u8, 0u8, 0u8],\n@@ -212,7 +212,7 @@ static DEFAULT_SUDOKU: [[u8, ..9], ..9] = [\n ];\n \n #[cfg(test)]\n-static DEFAULT_SOLUTION: [[u8, ..9], ..9] = [\n+static DEFAULT_SOLUTION: [[u8;9];9] = [\n          /* 0    1    2    3    4    5    6    7    8    */\n   /* 0 */  [1u8, 4u8, 9u8, 6u8, 7u8, 5u8, 8u8, 3u8, 2u8],\n   /* 1 */  [5u8, 3u8, 8u8, 1u8, 2u8, 9u8, 7u8, 4u8, 6u8],"}, {"sha": "2e0f2a174c606575242e7b3fc4bad62cb40152b7", "filename": "src/test/compile-fail/better-expected.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let x: [int ..3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `..`\n+    let x: [int 3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, `;`, or `]`, found `3`\n }"}, {"sha": "f0d42bb9ac115de19b410801e8a53c457cd399f3", "filename": "src/test/compile-fail/borrowck-for-loop-correct-cmt-for-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,7 +11,7 @@\n // Issue #16205.\n \n struct Foo {\n-    a: [Box<int>, ..3],\n+    a: [Box<int>; 3],\n }\n \n fn main() {"}, {"sha": "b6b46fadb13dae444559ffddb0dea65141e5c3ff", "filename": "src/test/compile-fail/coercion-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that we forbid coercion from `[T, ..n]` to `&[T]`\n+// Tests that we forbid coercion from `[T; n]` to `&[T]`\n \n fn main() {\n-    let _: &[int] = [0i]; //~ERROR: mismatched types: expected `&[int]`, found `[int, ..1]`\n+    let _: &[int] = [0i]; //~ERROR: mismatched types: expected `&[int]`, found `[int; 1]`\n }"}, {"sha": "b359744183418b3f0ceaee3e3961f5b8d0278d32", "filename": "src/test/compile-fail/const-cast-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static a: [u8, ..3] = ['h' as u8, 'i' as u8, 0 as u8];\n+static a: [u8; 3] = ['h' as u8, 'i' as u8, 0 as u8];\n static b: *const i8 = &a as *const i8; //~ ERROR mismatched types\n \n fn main() {"}, {"sha": "c77ae25e0cf519db4ff4c5a8fa95d9dd8b054228", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,9 +20,9 @@ trait Bar {}\n pub fn main() {\n     // With a vec of ints.\n     let f1 = Fat { ptr: [1, 2, 3] };\n-    let f2: &Fat<[int, ..3]> = &f1;\n+    let f2: &Fat<[int; 3]> = &f1;\n     let f3: &Fat<[uint]> = f2;\n-    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int, ..3]>`\n+    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int; 3]>`\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}, {"sha": "6eb650e97811786065d054b8e208b480126fbca5", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,7 +21,7 @@ impl Bar for Foo {}\n pub fn main() {\n     // With a vec of ints.\n     let f1 = Fat { ptr: [1, 2, 3] };\n-    let f2: &Fat<[int, ..3]> = &f1;\n+    let f2: &Fat<[int; 3]> = &f1;\n     let f3: &mut Fat<[int]> = f2; //~ ERROR mismatched types\n \n     // With a trait."}, {"sha": "b0bd517637464891a47ab5826900c13b325b9057", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,7 +21,7 @@ impl Bar for Foo {}\n fn baz<'a>() {\n     // With a vec of ints.\n     let f1 = Fat { ptr: [1, 2, 3] };\n-    let f2: &Fat<[int, ..3]> = &f1; //~ ERROR `f1` does not live long enough\n+    let f2: &Fat<[int; 3]> = &f1; //~ ERROR `f1` does not live long enough\n     let f3: &'a Fat<[int]> = f2;\n \n     // With a trait."}, {"sha": "783a32d63028a9bb0492605e92b1938041c06c5c", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -17,6 +17,6 @@ struct Fat<Sized? T> {\n pub fn main() {\n     // With a vec of ints.\n     let f1: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n-    let f2: &Fat<[int, ..3]> = f1;\n-    //~^ ERROR mismatched types: expected `&Fat<[int, ..3]>`, found `&Fat<[int]>`\n+    let f2: &Fat<[int; 3]> = f1;\n+    //~^ ERROR mismatched types: expected `&Fat<[int; 3]>`, found `&Fat<[int]>`\n }"}, {"sha": "0833a74f1daf95f40033f642d8200e02b79ceefa", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -18,7 +18,7 @@ struct Fat<Sized? T> {\n }\n \n pub fn main() {\n-    let f: Fat<[int, ..3]> = Fat { ptr: [5i, 6, 7] };\n+    let f: Fat<[int; 3]> = Fat { ptr: [5i, 6, 7] };\n     let g: &Fat<[int]> = &f;\n     let h: &Fat<Fat<[int]>> = &Fat { ptr: *g };\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented"}, {"sha": "a9dda771b7ff8b72cdf0c9d8f87985838961c30a", "filename": "src/test/compile-fail/huge-array-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,5 +11,5 @@\n // error-pattern: too big for the current\n \n fn main() {\n-   let fat : [u8, ..(1<<61)+(1<<31)] = [0, ..(1u64<<61) as uint +(1u64<<31) as uint];\n+   let fat : [u8; (1<<61)+(1<<31)] = [0; (1u64<<61) as uint +(1u64<<31) as uint];\n }"}, {"sha": "029e9651cb3cdd34c65ce848c94d59e930856608", "filename": "src/test/compile-fail/huge-array.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: ..1518599999\n+// error-pattern:; 1518599999\n \n fn generic<T: Copy>(t: T) {\n-    let s: [T, ..1518600000] = [t, ..1518600000];\n+    let s: [T; 1518600000] = [t; 1518600000];\n }\n \n fn main() {\n-    let x: [u8, ..1518599999] = [0, ..1518599999];\n-    generic::<[u8, ..1518599999]>(x);\n+    let x: [u8; 1518599999] = [0; 1518599999];\n+    generic::<[u8; 1518599999]>(x);\n }"}, {"sha": "7c7a75abf3fc79705388cac0078d6b56df7afecd", "filename": "src/test/compile-fail/huge-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,10 +14,10 @@\n \n #[cfg(target_word_size = \"32\")]\n fn main() {\n-    let big: Option<[u32, ..(1<<29)-1]> = None;\n+    let big: Option<[u32; (1<<29)-1]> = None;\n }\n \n #[cfg(target_word_size = \"64\")]\n fn main() {\n-    let big: Option<[u32, ..(1<<45)-1]> = None;\n+    let big: Option<[u32; (1<<45)-1]> = None;\n }"}, {"sha": "5c72c7388a9ee2d34f187885a87f97f8149fe462", "filename": "src/test/compile-fail/issue-13359.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,8 +14,8 @@ fn bar(_s: u32) { }\n \n fn main() {\n     foo(1*(1 as int));\n-    //~^ ERROR: mismatched types: expected `i16`, found `int` (expected `i16`, found `int`)\n+    //~^ ERROR: mismatched types: expected `i16`, found `int` (expected i16, found int)\n \n     bar(1*(1 as uint));\n-    //~^ ERROR: mismatched types: expected `u32`, found `uint` (expected `u32`, found `uint`)\n+    //~^ ERROR: mismatched types: expected `u32`, found `uint` (expected u32, found uint)\n }"}, {"sha": "a0a7660428d4106815906f0d7561c58802b01df7", "filename": "src/test/compile-fail/issue-13446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,7 +13,7 @@\n \n // error-pattern: mismatched types\n \n-static VEC: [u32, ..256] = vec!();\n+static VEC: [u32; 256] = vec!();\n \n fn main() {}\n "}, {"sha": "ef7d3d4d158d9fdcb202c4e0a0944acf10f7d13c", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = [1,2];\n     let y = match x {\n         [] => None,\n-        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7t, ..0]`\n+        //~^ ERROR types: expected `[_#0i; 2]`, found `[_#7t; 0]`\n         //         (expected array of 2 elements, found array of 0 elements)\n         [a,_] => Some(a)\n     };"}, {"sha": "157280b1719ad2ca3a096f0c0692667b11421236", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@ fn main() {\n   let x = [1,2];\n   let y = match x {\n     [] => None,\n-//~^ ERROR types: expected `[_, ..2]`, found `[_, ..0]`\n+//~^ ERROR types: expected `[_; 2]`, found `[_; 0]`\n //         (expected array of 2 elements, found array of 0 elements)\n     [a,_] => Some(a)\n   };"}, {"sha": "5166d84a0254362f12a0503a282ad3f79440936a", "filename": "src/test/compile-fail/issue-14845.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,15 +10,15 @@\n \n \n struct X {\n-    a: [u8, ..1]\n+    a: [u8; 1]\n }\n \n fn main() {\n     let x = X { a: [0] };\n     let _f = &x.a as *mut u8;\n-    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, ..1]`\n+    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8; 1]`\n \n     let local = [0u8];\n     let _v = &local as *mut u8;\n-    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8, ..1]`\n+    //~^ ERROR mismatched types: expected `*mut u8`, found `&[u8; 1]`\n }"}, {"sha": "4adb3f041a3f4254b2d971fed405c6829b7c8da0", "filename": "src/test/compile-fail/issue-17252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,10 +11,10 @@\n static FOO: uint = FOO; //~ ERROR recursive constant\n \n fn main() {\n-    let _x: [u8, ..FOO]; // caused stack overflow prior to fix\n+    let _x: [u8; FOO]; // caused stack overflow prior to fix\n     let _y: uint = 1 + {\n         static BAR: uint = BAR; //~ ERROR recursive constant\n-        let _z: [u8, ..BAR]; // caused stack overflow prior to fix\n+        let _z: [u8; BAR]; // caused stack overflow prior to fix\n         1\n     };\n }"}, {"sha": "e5da5c5504ef3e1b728113a85abac6d621494bb7", "filename": "src/test/compile-fail/issue-17441.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let _foo = &[1u, 2] as [uint];\n-    //~^ ERROR cast to unsized type: `&[uint, ..2]` as `[uint]`\n+    //~^ ERROR cast to unsized type: `&[uint; 2]` as `[uint]`\n     //~^^ HELP consider using an implicit coercion to `&[uint]` instead\n     let _bar = box 1u as std::fmt::Show;\n     //~^ ERROR cast to unsized type: `Box<uint>` as `core::fmt::Show`\n@@ -19,6 +19,6 @@ fn main() {\n     //~^ ERROR cast to unsized type: `uint` as `core::fmt::Show`\n     //~^^ HELP consider using a box or reference as appropriate\n     let _quux = [1u, 2] as [uint];\n-    //~^ ERROR cast to unsized type: `[uint, ..2]` as `[uint]`\n+    //~^ ERROR cast to unsized type: `[uint; 2]` as `[uint]`\n     //~^^ HELP consider using a box or reference as appropriate\n }"}, {"sha": "8aa5fdf1c4d21fb3256996dbf5e92ea5b10942d6", "filename": "src/test/compile-fail/issue-17718-borrow-interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -15,7 +15,7 @@ static B: &'static uint = &A.a;\n static C: &'static uint = &(A.a);\n //~^ ERROR: cannot refer to the interior of another static\n \n-static D: [uint, ..1] = [1];\n+static D: [uint; 1] = [1];\n static E: uint = D[0];\n //~^ ERROR: cannot refer to other statics by value\n static F: &'static uint = &D[0];"}, {"sha": "fafe6377397a39343a3367d3dc465a984395a77d", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,6 +11,6 @@\n const TUP: (uint,) = (42,);\n \n fn main() {\n-    let a: [int, ..TUP.1];\n+    let a: [int; TUP.1];\n     //~^ ERROR expected constant expr for array length: tuple index out of bounds\n }"}, {"sha": "95965ca35f944ed593fc3abe3f4fbef788855a8b", "filename": "src/test/compile-fail/issue-19244-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,6 +12,6 @@ struct MyStruct { field: uint }\n const STRUCT: MyStruct = MyStruct { field: 42 };\n \n fn main() {\n-    let a: [int, ..STRUCT.nonexistent_field];\n+    let a: [int; STRUCT.nonexistent_field];\n     //~^ ERROR expected constant expr for array length: nonexistent struct field\n }"}, {"sha": "0f1dbfa349277f215bccab001534fb8111bf4d88", "filename": "src/test/compile-fail/issue-19991.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test if the sugared if-let construct correctly prints \"missing an else clause\" when an else\n+// clause does not exist, instead of the unsympathetic \"match arms have incompatible types\"\n+\n+fn main() {\n+    if let Some(homura) = Some(\"madoka\") { //~ ERROR missing an else clause: expected `()`\n+        765i32\n+    };\n+}"}, {"sha": "3343e92252f8e4926e5de54b196221115bef095c", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&str, ..1]` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&str; 1]` does not implement any method in scope named `bind`\n }"}, {"sha": "1c5fd9be1bd4d24d1d3c26804aff580f60199f6c", "filename": "src/test/compile-fail/issue-4517.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,8 +11,8 @@\n fn bar(int_param: int) {}\n \n fn main() {\n-    let foo: [u8, ..4] = [1u8, ..4u];\n+    let foo: [u8; 4] = [1u8; 4u];\n     bar(foo);\n-    //~^ ERROR mismatched types: expected `int`, found `[u8, ..4]`\n+    //~^ ERROR mismatched types: expected `int`, found `[u8; 4]`\n     //         (expected int, found vector)\n }"}, {"sha": "573d847cbe3b88cbce5ee7fcd1ec5785343b4a65", "filename": "src/test/compile-fail/issue-9957.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-9957.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fissue-9957.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9957.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,5 +11,5 @@\n pub extern crate core; //~ ERROR: `pub` visibility is not allowed\n \n fn main() {\n-    pub use std::bool; //~ ERROR: imports in functions are never reachable\n+    pub use std::uint; //~ ERROR: imports in functions are never reachable\n }"}, {"sha": "19373c806f14d4da979f7c787e3c19d7292f13c1", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     println!(\"{}\", Test);\n \n     let mut f = File::open(&Path::new(\"something.txt\"));\n-    let mut buff = [0u8, ..16];\n+    let mut buff = [0u8; 16];\n     match f.read(&mut buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n         Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),"}, {"sha": "0b095ff6f820dbc5b68863a89730bf13734cd699", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test moving array structures, e.g. `[T, ..3]` as well as moving\n+// Test moving array structures, e.g. `[T; 3]` as well as moving\n // elements in and out of such arrays.\n //\n // Note also that the `test_move_array_then_overwrite` tests represent\n@@ -18,14 +18,14 @@ pub struct D { d: int }\n impl Drop for D { fn drop(&mut self) { } }\n \n #[rustc_move_fragments]\n-pub fn test_move_array_via_return(a: [D, ..3]) -> [D, ..3] {\n+pub fn test_move_array_via_return(a: [D; 3]) -> [D; 3] {\n     //~^ ERROR                  assigned_leaf_path: `$(local a)`\n     //~| ERROR                     moved_leaf_path: `$(local a)`\n     return a;\n }\n \n #[rustc_move_fragments]\n-pub fn test_move_array_into_recv(a: [D, ..3], recv: &mut [D, ..3]) {\n+pub fn test_move_array_into_recv(a: [D; 3], recv: &mut [D; 3]) {\n     //~^ ERROR                 parent_of_fragments: `$(local recv)`\n     //~| ERROR                  assigned_leaf_path: `$(local a)`\n     //~| ERROR                     moved_leaf_path: `$(local a)`\n@@ -34,7 +34,7 @@ pub fn test_move_array_into_recv(a: [D, ..3], recv: &mut [D, ..3]) {\n }\n \n #[rustc_move_fragments]\n-pub fn test_extract_array_elem(a: [D, ..3], i: uint) -> D {\n+pub fn test_extract_array_elem(a: [D; 3], i: uint) -> D {\n     //~^ ERROR                 parent_of_fragments: `$(local a)`\n     //~| ERROR                  assigned_leaf_path: `$(local i)`\n     //~| ERROR                     moved_leaf_path: `$(local a).[]`\n@@ -43,7 +43,7 @@ pub fn test_extract_array_elem(a: [D, ..3], i: uint) -> D {\n }\n \n #[rustc_move_fragments]\n-pub fn test_overwrite_array_elem(mut a: [D, ..3], i: uint, d: D) {\n+pub fn test_overwrite_array_elem(mut a: [D; 3], i: uint, d: D) {\n     //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n     //~| ERROR                  assigned_leaf_path: `$(local i)`\n     //~| ERROR                  assigned_leaf_path: `$(local d)`\n@@ -59,7 +59,7 @@ pub fn test_overwrite_array_elem(mut a: [D, ..3], i: uint, d: D) {\n // See RFC PR 320 for more discussion.\n \n #[rustc_move_fragments]\n-pub fn test_move_array_then_overwrite_elem1(mut a: [D, ..3], i: uint, recv: &mut [D, ..3], d: D) {\n+pub fn test_move_array_then_overwrite_elem1(mut a: [D; 3], i: uint, recv: &mut [D; 3], d: D) {\n     //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n     //~| ERROR                 parent_of_fragments: `$(local recv)`\n     //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n@@ -76,8 +76,8 @@ pub fn test_move_array_then_overwrite_elem1(mut a: [D, ..3], i: uint, recv: &mut\n }\n \n #[rustc_move_fragments]\n-pub fn test_move_array_then_overwrite_elem2(mut a: [D, ..3], i: uint, j: uint,\n-                                            recv: &mut [D, ..3], d1: D, d2: D) {\n+pub fn test_move_array_then_overwrite_elem2(mut a: [D; 3], i: uint, j: uint,\n+                                            recv: &mut [D; 3], d1: D, d2: D) {\n     //~^^ ERROR                parent_of_fragments: `$(local mut a)`\n     //~| ERROR                 parent_of_fragments: `$(local recv)`\n     //~| ERROR                  assigned_leaf_path: `$(local recv).*`"}, {"sha": "d8d84e558a947ff734d4afa1b1b8283766eda956", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -89,7 +89,7 @@ fn f100() {\n \n fn f110() {\n     let x = vec!(\"hi\".to_string());\n-    let _y = [x.into_iter().next().unwrap(), ..1];\n+    let _y = [x.into_iter().next().unwrap(); 1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n "}, {"sha": "a1dc2ab2041a5ea0e6199746b0fd47da449d43e3", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,6 +11,6 @@\n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n-    [State::ST_NULL, ..(State::ST_WHITESPACE as uint)];\n+    [State::ST_NULL; (State::ST_WHITESPACE as uint)];\n     //~^ ERROR expected constant integer for repeat count, found non-constant expression\n }"}, {"sha": "85d734ddaf2b9fab308f3616a8a8e2a9faecea0f", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     fn bar(n: int) {\n-        let _x: [int, ..n];\n+        let _x: [int; n];\n         //~^ ERROR expected constant expr for array length: non-constant path in constant expr\n     }\n }"}, {"sha": "2e063e5237c44a4ad67c30a3ae96d639f5d06efe", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     fn bar(n: uint) {\n-        let _x = [0, ..n]; //~ ERROR expected constant integer for repeat count, found variable\n+        let _x = [0; n]; //~ ERROR expected constant integer for repeat count, found variable\n     }\n }"}, {"sha": "d35e3ad3c55b02769e6cdf2d932bbcc5edf177bf", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@\n \n struct Foo {\n     first: bool,\n-    second: Option<[uint, ..4]>\n+    second: Option<[uint; 4]>\n }\n \n enum Color {"}, {"sha": "5c0aba42b9683221374078f66c47d8a707eae9ae", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -33,7 +33,7 @@ struct Oof<T, S> {\n fn main() {\n     let foo = Foo { bar: [1u8, 2, 3, 4, 5], baz: 10i32 };\n     unsafe {\n-        let oof: Oof<[u8, .. 5], i32> = mem::transmute(foo);\n+        let oof: Oof<[u8; 5], i32> = mem::transmute(foo);\n         println!(\"{} {}\", oof.rab[], oof.zab);\n     }\n }"}, {"sha": "0a8420c19c33f2cbc0b3199d610ac5482e8c8476", "filename": "src/test/compile-fail/removed-syntax-fixed-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-fixed-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type v = [int * 3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `*`\n+type v = [int * 3]; //~ ERROR expected one of `(`, `+`, `,`, `::`, `;`, or `]`, found `*`"}, {"sha": "30302bbd16ef8e0387083285bba38b5c39f43647", "filename": "src/test/compile-fail/removed-syntax-mut-vec-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,5 +11,5 @@\n fn f() {\n     let v = [mut 1, 2, 3, 4];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `!`, `,`, `.`, `::`, `]`, `{`, or an operator, found `1`\n+    //~^^ ERROR expected one of `!`, `,`, `.`, `::`, `;`, `]`, `{`, or an operator, found `1`\n }"}, {"sha": "9c6056bd72a1c1c8f4c04119b5b966618c2c9b5a", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,4 +10,4 @@\n \n type v = [mut int];\n     //~^  ERROR expected identifier, found keyword `mut`\n-    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, or `]`, found `int`\n+    //~^^ ERROR expected one of `(`, `+`, `,`, `::`, `;`, or `]`, found `int`"}, {"sha": "d3126cf44d1b152fcd01e39cfcd1f1bc09283832", "filename": "src/test/compile-fail/repeat-to-run-dtor-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat-to-run-dtor-twice.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -24,6 +24,6 @@ impl Drop for Foo {\n \n fn main() {\n     let a = Foo { x: 3 };\n-    let _ = [ a, ..5 ];\n+    let _ = [ a; 5 ];\n     //~^ ERROR the trait `core::kinds::Copy` is not implemented for the type `Foo`\n }"}, {"sha": "3b0ef0c293af75c260e724a1195c3d2e3913862b", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,18 +12,18 @@\n \n fn main() {\n     let n = 1;\n-    let a = [0, ..n]; //~ ERROR expected constant integer for repeat count, found variable\n-    let b = [0, ..()];\n+    let a = [0; n]; //~ ERROR expected constant integer for repeat count, found variable\n+    let b = [0; ()];\n //~^ ERROR expected constant integer for repeat count, found non-constant expression\n //~^^ ERROR: expected `uint`, found `()`\n-    let c = [0, ..true]; //~ ERROR expected positive integer for repeat count, found boolean\n+    let c = [0; true]; //~ ERROR expected positive integer for repeat count, found boolean\n     //~^ ERROR: expected `uint`, found `bool`\n-    let d = [0, ..0.5]; //~ ERROR expected positive integer for repeat count, found float\n+    let d = [0; 0.5]; //~ ERROR expected positive integer for repeat count, found float\n     //~^ ERROR: expected `uint`, found `_`\n-    let e = [0, ..\"foo\"]; //~ ERROR expected positive integer for repeat count, found string\n+    let e = [0; \"foo\"]; //~ ERROR expected positive integer for repeat count, found string\n     //~^ ERROR: expected `uint`, found `&'static str`\n-    let f = [0, ..-4];\n+    let f = [0; -4];\n     //~^ ERROR expected positive integer for repeat count, found negative integer\n-    let f = [0u, ..-1];\n+    let f = [0u; -1];\n     //~^ ERROR expected positive integer for repeat count, found negative integer\n }"}, {"sha": "ff84ed5bf0cd499d72000663407b3c3d0c994faa", "filename": "src/test/compile-fail/static-vec-repeat-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,7 +10,7 @@\n \n fn foo() -> int { 23 }\n \n-static a: [int, ..2] = [foo(), ..2];\n+static a: [int; 2] = [foo(); 2];\n //~^ ERROR: function calls in constants are limited to struct and enum constructors\n \n fn main() {}"}, {"sha": "2286c0e75bd9dcc22393e9fea52f5db052188c81", "filename": "src/test/compile-fail/transmute-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,7 +20,7 @@ unsafe fn g<T>(x: (T, int)) {\n     let _: int = transmute(x);  //~ ERROR cannot transmute\n }\n \n-unsafe fn h<T>(x: [T, ..10]) {\n+unsafe fn h<T>(x: [T; 10]) {\n     let _: int = transmute(x);  //~ ERROR cannot transmute\n }\n "}, {"sha": "c5109ce473e9efebbcd5e191792769ca976758ce", "filename": "src/test/compile-fail/vector-cast-weirdness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,20 +12,20 @@\n // presence of the `_` type shorthand notation.\n \n struct X {\n-    y: [u8, ..2],\n+    y: [u8; 2],\n }\n \n fn main() {\n     let x1 = X { y: [0, 0] };\n \n     let p1: *const u8 = &x1.y as *const _;  //~ ERROR mismatched types\n-    let t1: *const [u8, ..2] = &x1.y as *const _;\n-    let h1: *const [u8, ..2] = &x1.y as *const [u8, ..2];\n+    let t1: *const [u8; 2] = &x1.y as *const _;\n+    let h1: *const [u8; 2] = &x1.y as *const [u8; 2];\n \n     let mut x1 = X { y: [0, 0] };\n \n     let p1: *mut u8 = &mut x1.y as *mut _;  //~ ERROR mismatched types\n-    let t1: *mut [u8, ..2] = &mut x1.y as *mut _;\n-    let h1: *mut [u8, ..2] = &mut x1.y as *mut [u8, ..2];\n+    let t1: *mut [u8; 2] = &mut x1.y as *mut _;\n+    let h1: *mut [u8; 2] = &mut x1.y as *mut [u8; 2];\n }\n "}, {"sha": "19a82ee5e67b3f5a702dfbf4e02b78ad0d6af303", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// gdb-command:print x\n+// gdb-check:$1 = 400\n+// gdb-command:print y\n+// gdb-check:$2 = 401.5\n+// gdb-command:print z\n+// gdb-check:$3 = true\n+// gdb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// gdb-command:print/x _i8\n+// gdb-check:$4 = 0x6f\n+// gdb-command:print/x _u8\n+// gdb-check:$5 = 0x70\n+// gdb-command:print _i16\n+// gdb-check:$6 = -113\n+// gdb-command:print _u16\n+// gdb-check:$7 = 114\n+// gdb-command:print _i32\n+// gdb-check:$8 = -115\n+// gdb-command:print _u32\n+// gdb-check:$9 = 116\n+// gdb-command:print _i64\n+// gdb-check:$10 = -117\n+// gdb-command:print _u64\n+// gdb-check:$11 = 118\n+// gdb-command:print _f32\n+// gdb-check:$12 = 119.5\n+// gdb-command:print _f64\n+// gdb-check:$13 = 120.5\n+// gdb-command:continue\n+\n+// MORE COMPLEX CASE\n+// gdb-command:print v1\n+// gdb-check:$14 = 80000\n+// gdb-command:print x1\n+// gdb-check:$15 = 8000\n+// gdb-command:print *y1\n+// gdb-check:$16 = 80001.5\n+// gdb-command:print z1\n+// gdb-check:$17 = false\n+// gdb-command:print *x2\n+// gdb-check:$18 = -30000\n+// gdb-command:print y2\n+// gdb-check:$19 = -300001.5\n+// gdb-command:print *z2\n+// gdb-check:$20 = true\n+// gdb-command:print v2\n+// gdb-check:$21 = 854237.5\n+// gdb-command:continue\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:type format add --format hex char\n+// lldb-command:type format add --format hex 'unsigned char'\n+\n+// lldb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// lldb-command:print x\n+// lldb-check:[...]$0 = 400\n+// lldb-command:print y\n+// lldb-check:[...]$1 = 401.5\n+// lldb-command:print z\n+// lldb-check:[...]$2 = true\n+// lldb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// lldb-command:print _i8\n+// lldb-check:[...]$3 = 0x6f\n+// lldb-command:print _u8\n+// lldb-check:[...]$4 = 0x70\n+// lldb-command:print _i16\n+// lldb-check:[...]$5 = -113\n+// lldb-command:print _u16\n+// lldb-check:[...]$6 = 114\n+// lldb-command:print _i32\n+// lldb-check:[...]$7 = -115\n+// lldb-command:print _u32\n+// lldb-check:[...]$8 = 116\n+// lldb-command:print _i64\n+// lldb-check:[...]$9 = -117\n+// lldb-command:print _u64\n+// lldb-check:[...]$10 = 118\n+// lldb-command:print _f32\n+// lldb-check:[...]$11 = 119.5\n+// lldb-command:print _f64\n+// lldb-check:[...]$12 = 120.5\n+// lldb-command:continue\n+\n+// MORE COMPLEX CASE\n+// lldb-command:print v1\n+// lldb-check:[...]$13 = 80000\n+// lldb-command:print x1\n+// lldb-check:[...]$14 = 8000\n+// lldb-command:print *y1\n+// lldb-check:[...]$15 = 80001.5\n+// lldb-command:print z1\n+// lldb-check:[...]$16 = false\n+// lldb-command:print *x2\n+// lldb-check:[...]$17 = -30000\n+// lldb-command:print y2\n+// lldb-check:[...]$18 = -300001.5\n+// lldb-command:print *z2\n+// lldb-check:[...]$19 = true\n+// lldb-command:print v2\n+// lldb-check:[...]$20 = 854237.5\n+// lldb-command:continue\n+\n+\n+struct Struct {\n+    x: i16,\n+    y: f32,\n+    z: bool\n+}\n+\n+fn main() {\n+\n+    let s = Struct {\n+        x: 400,\n+        y: 401.5,\n+        z: true\n+    };\n+\n+    for &Struct { x, y, z } in [s].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let tuple: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64) =\n+        (0x6f, 0x70, -113, 114, -115, 116, -117, 118, 119.5, 120.5);\n+\n+    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in [tuple].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let more_complex: (i32, &Struct, Struct, Box<f64>) =\n+        (80000,\n+         &Struct {\n+            x: 8000,\n+            y: 80001.5,\n+            z: false\n+         },\n+         Struct {\n+            x: -30000,\n+            y: -300001.5,\n+            z: true\n+         },\n+         box 854237.5);\n+\n+    for &(v1,\n+          &Struct { x: x1, y: ref y1, z: z1 },\n+          Struct { x: ref x2, y: y2, z: ref z2 },\n+          box v2) in [more_complex].iter() {\n+        zzz(); // #break\n+    }\n+}\n+\n+fn zzz() {()}"}, {"sha": "786868f6b89ddab084dbce06cb0117fd821d42f9", "filename": "src/test/debuginfo/evec-in-struct.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fevec-in-struct.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -53,28 +53,28 @@\n #![allow(unused_variables)]\n \n struct NoPadding1 {\n-    x: [u32, ..3],\n+    x: [u32; 3],\n     y: i32,\n-    z: [f32, ..2]\n+    z: [f32; 2]\n }\n \n struct NoPadding2 {\n-    x: [u32, ..3],\n-    y: [[u32, ..2], ..2]\n+    x: [u32; 3],\n+    y: [[u32; 2]; 2]\n }\n \n struct StructInternalPadding {\n-    x: [i16, ..2],\n-    y: [i64, ..2]\n+    x: [i16; 2],\n+    y: [i64; 2]\n }\n \n struct SingleVec {\n-    x: [i16, ..5]\n+    x: [i16; 5]\n }\n \n struct StructPaddedAtEnd {\n-    x: [i64, ..2],\n-    y: [i16, ..2]\n+    x: [i64; 2],\n+    y: [i16; 2]\n }\n \n fn main() {"}, {"sha": "7636ffdb07dcd6a02a54e656d3db53d5a5a9bd75", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10381)\n-// ignore-test: Not sure what is going on here --pcwalton\n // min-lldb-version: 310\n \n // compile-flags:-g"}, {"sha": "41dee642feacd9c4886d83e8e073a4523ac49e6a", "filename": "src/test/debuginfo/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scopes-in-block-expression.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -450,7 +450,7 @@ fn main() {\n         sentinel();\n \n         val\n-    }, ..10];\n+    }; 10];\n \n     zzz(); // #break\n     sentinel();\n@@ -491,7 +491,7 @@ fn main() {\n     sentinel();\n \n     // index expression\n-    let a_vector = [10i, ..20];\n+    let a_vector = [10i; 20];\n     let _ = a_vector[{\n         zzz(); // #break\n         sentinel();"}, {"sha": "8cc0fdabfc2e7b73cb7465dcaaf0b73597edd198", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -143,7 +143,7 @@ fn main() {\n         value: 2,\n     };\n \n-    let vec_unique: [UniqueNode<f32>, ..1] = [UniqueNode {\n+    let vec_unique: [UniqueNode<f32>; 1] = [UniqueNode {\n         next: Val {\n             val: box UniqueNode {\n                 next: Empty,"}, {"sha": "286c44667c5b46cdbfcf2ac4a246ceb4d2dcfaa9", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -99,10 +99,10 @@\n \n // VECTORS\n // gdb-command:whatis fixed_size_vec1\n-// gdb-check:type = struct ([type-names::Struct1, ..3], i16)\n+// gdb-check:type = struct ([type-names::Struct1; 3], i16)\n \n // gdb-command:whatis fixed_size_vec2\n-// gdb-check:type = struct ([uint, ..3], i16)\n+// gdb-check:type = struct ([uint; 3], i16)\n \n // gdb-command:whatis slice1\n // gdb-check:type = struct &[uint]"}, {"sha": "00c93653cf411892b4c4e7e7526ae36d4f5dbbc5", "filename": "src/test/debuginfo/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fdebuginfo%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -30,7 +30,7 @@\n \n #![allow(unused_variables)]\n \n-static mut VECT: [i32, ..3] = [1, 2, 3];\n+static mut VECT: [i32; 3] = [1, 2, 3];\n \n fn main() {\n     let a = [1i, 2, 3];"}, {"sha": "1774edd3f76e2bc88bf0e71796d79bded267cdd6", "filename": "src/test/pretty/blank-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fpretty%2Fblank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fpretty%2Fblank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblank-lines.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // pp-exact\n-fn f() -> [int, ..3] {\n+fn f() -> [int; 3] {\n     let picard = 0;\n \n     let data = 1;"}, {"sha": "974af1e6f3e108992f2a04178062ea9a46be60dd", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,26 +21,26 @@\n \n // #4264 fixed-length vector types\n \n-pub fn foo(_: [int, ..(3 as uint)]) { }\n+pub fn foo(_: [int; (3 as uint)]) { }\n \n pub fn bar() {\n     const FOO: uint = ((5u as uint) - (4u as uint) as uint);\n-    let _: [(), ..(FOO as uint)] = ([(() as ())] as [(), ..1]);\n+    let _: [(); (FOO as uint)] = ([(() as ())] as [(); 1]);\n \n-    let _: [(), ..(1u as uint)] = ([(() as ())] as [(), ..1]);\n+    let _: [(); (1u as uint)] = ([(() as ())] as [(); 1]);\n \n     let _ =\n-        (((&((([(1i as int), (2 as int), (3 as int)] as [int, ..3])) as\n-                [int, ..3]) as &[int, ..3]) as *const _ as *const [int, ..3])\n-            as *const [int, ..(3u as uint)] as *const [int, ..3]);\n+        (((&((([(1i as int), (2 as int), (3 as int)] as [int; 3])) as\n+                [int; 3]) as &[int; 3]) as *const _ as *const [int; 3]) as\n+            *const [int; (3u as uint)] as *const [int; 3]);\n \n     (match (() as ()) {\n          () => {\n              #[inline]\n              #[allow(dead_code)]\n              static __STATIC_FMTSTR: &'static [&'static str] =\n-                 (&([(\"test\" as &'static str)] as [&'static str, ..1]) as\n-                     &'static [&'static str, ..1]);\n+                 (&([(\"test\" as &'static str)] as [&'static str; 1]) as\n+                     &'static [&'static str; 1]);\n \n \n \n@@ -57,9 +57,9 @@\n                                                                                                                                                                 &'static [&'static str]),\n                                                                                                                                                             (&([]\n                                                                                                                                                                   as\n-                                                                                                                                                                  [core::fmt::Argument<'_>, ..0])\n+                                                                                                                                                                  [core::fmt::Argument<'_>; 0])\n                                                                                                                                                                 as\n-                                                                                                                                                                &[core::fmt::Argument<'_>, ..0]))\n+                                                                                                                                                                &[core::fmt::Argument<'_>; 0]))\n                                                                                       as\n                                                                                       core::fmt::Arguments<'_>)\n                                                                                     as\n@@ -68,18 +68,17 @@\n          }\n      } as collections::string::String);\n }\n-pub type Foo = [int, ..(3u as uint)];\n+pub type Foo = [int; (3u as uint)];\n pub struct Bar {\n-    pub x: [int, ..(3u as uint)],\n+    pub x: [int; (3u as uint)],\n }\n-pub struct TupleBar([int, ..(4u as uint)]);\n-pub enum Baz { BazVariant([int, ..(5u as uint)]), }\n+pub struct TupleBar([int; (4u as uint)]);\n+pub enum Baz { BazVariant([int; (5u as uint)]), }\n pub fn id<T>(x: T) -> T { (x as T) }\n pub fn use_id() {\n     let _ =\n-        ((id::<[int, ..(3u as uint)]> as\n-             fn([int, ..3]) -> [int, ..3])(([(1 as int), (2 as int),\n-                                             (3 as int)] as [int, ..3])) as\n-            [int, ..3]);\n+        ((id::<[int; (3u as uint)]> as\n+             fn([int; 3]) -> [int; 3])(([(1 as int), (2 as int), (3 as int)]\n+                                           as [int; 3])) as [int; 3]);\n }\n fn main() { }"}, {"sha": "7d0fc2d7fe503e618f2e300873d10bd4b86d753d", "filename": "src/test/run-make/no-stack-check/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,6 +20,6 @@ extern {\n #[no_stack_check]\n pub unsafe fn foo() {\n     // Make sure we use the stack\n-    let x: [u8, ..50] = [0, ..50];\n+    let x: [u8; 50] = [0; 50];\n     black_box(x.as_ptr());\n }"}, {"sha": "2b6e7240d6fa857edf8a0e2a26dfb6e7d258124e", "filename": "src/test/run-make/no-stack-check/flag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Fno-stack-check%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Fno-stack-check%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-stack-check%2Fflag.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -19,6 +19,6 @@ extern {\n \n pub unsafe fn foo() {\n     // Make sure we use the stack\n-    let x: [u8, ..50] = [0, ..50];\n+    let x: [u8; 50] = [0; 50];\n     black_box(x.as_ptr());\n }"}, {"sha": "fd112034f40c50d3f53be37539e919fde84369d1", "filename": "src/test/run-make/target-specs/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -21,7 +21,7 @@ trait Sized { }\n fn start(_main: *const u8, _argc: int, _argv: *const *const u8) -> int { 0 }\n \n extern {\n-    fn _foo() -> [u8, ..16];\n+    fn _foo() -> [u8; 16];\n }\n \n fn _main() {"}, {"sha": "717ca3ff9feccb24bd9d289a2e7dfa4e9af20eb1", "filename": "src/test/run-pass/cast-in-array-size.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-in-array-size.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,8 +13,8 @@\n const SIZE: int = 25;\n \n fn main() {\n-    let _a: [bool, ..1 as uint];\n-    let _b: [int, ..SIZE as uint] = [1, ..SIZE as uint];\n-    let _c: [bool, ..'\\n' as uint] = [true, ..'\\n' as uint];\n-    let _d: [bool, ..true as uint] = [true, ..true as uint];\n+    let _a: [bool; 1 as uint];\n+    let _b: [int; SIZE as uint] = [1; SIZE as uint];\n+    let _c: [bool; '\\n' as uint] = [true; '\\n' as uint];\n+    let _d: [bool; true as uint] = [true; true as uint];\n }"}, {"sha": "6e2cfedf9ec3ebed8eabf9d6a166043bf8ec3a17", "filename": "src/test/run-pass/check-static-slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-slice.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,11 +11,11 @@\n // Check that the various ways of getting to a reference to a vec (both sized\n // and unsized) work properly.\n \n-const aa: [int, ..3] = [1, 2, 3];\n-const ab: &'static [int, ..3] = &aa;\n+const aa: [int; 3] = [1, 2, 3];\n+const ab: &'static [int; 3] = &aa;\n const ac: &'static [int] = ab;\n const ad: &'static [int] = &aa;\n-const ae: &'static [int, ..3] = &[1, 2, 3];\n+const ae: &'static [int; 3] = &[1, 2, 3];\n const af: &'static [int] = &[1, 2, 3];\n \n static ca: int = aa[0];"}, {"sha": "71312fb387845b54f5bf18f5cb129fc2c4420f86", "filename": "src/test/run-pass/const-autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static A: [u8, ..1] = ['h' as u8];\n+static A: [u8; 1] = ['h' as u8];\n static B: u8 = (&A)[0];\n-static C: &'static &'static &'static &'static [u8, ..1] = & & & &A;\n+static C: &'static &'static &'static &'static [u8; 1] = & & & &A;\n static D: u8 = (&C)[0];\n \n pub fn main() {"}, {"sha": "4c8124d28a24157c02dbe6669849294674cce707", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@ enum E { V1(int), V0 }\n const C: &'static [E] = &[E::V0, E::V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];\n-const D: &'static [E, ..2] = &[E::V0, E::V1(0xDEADBEE)];\n+const D: &'static [E; 2] = &[E::V0, E::V1(0xDEADBEE)];\n static D0: E = C[0];\n static D1: E = C[1];\n "}, {"sha": "6eb5c2dab38ba17fa680da8e14ccc31705d16292", "filename": "src/test/run-pass/const-enum-vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum E { V1(int), V0 }\n-static C: [E, ..3] = [E::V0, E::V1(0xDEADBEE), E::V0];\n+static C: [E; 3] = [E::V0, E::V1(0xDEADBEE), E::V0];\n \n pub fn main() {\n     match C[1] {"}, {"sha": "6317c2eec1801b34bf2a678a2c797fb43cc8108e", "filename": "src/test/run-pass/const-expr-in-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-fixed-length-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,6 +14,6 @@\n pub fn main() {\n \n     const FOO: uint = 2;\n-    let _v: [int, ..FOO*3];\n+    let _v: [int; FOO*3];\n \n }"}, {"sha": "d692f3a87e457b385f956ccb62d0aae6e599803e", "filename": "src/test/run-pass/const-expr-in-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-expr-in-vec-repeat.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,6 +13,6 @@\n pub fn main() {\n \n     const FOO: uint = 2;\n-    let _v = [0i, ..FOO*3*2/2];\n+    let _v = [0i; FOO*3*2/2];\n \n }"}, {"sha": "0819e0becbf9564cb1ac9738cc04147a65167182", "filename": "src/test/run-pass/const-fields-and-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fields-and-indexing.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const x : [int, ..4] = [1,2,3,4];\n+const x : [int; 4] = [1,2,3,4];\n static p : int = x[2];\n const y : &'static [int] = &[1,2,3,4];\n static q : int = y[2];"}, {"sha": "e8081005d4a8ff4695ddc124e364ea86305fc53a", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type Big = [u64, ..8];\n+type Big = [u64; 8];\n struct Pair<'a> { a: int, b: &'a Big }\n const x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n const y: &'static Pair<'static> = &Pair {a: 15, b: x};"}, {"sha": "d6f0296619ab4e7ff62ab4ff97af53964390d71a", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,8 +10,8 @@\n \n use std::{str, string};\n \n-const A: [u8, ..2] = ['h' as u8, 'i' as u8];\n-const B: &'static [u8, ..2] = &A;\n+const A: [u8; 2] = ['h' as u8, 'i' as u8];\n+const B: &'static [u8; 2] = &A;\n const C: *const u8 = B as *const u8;\n \n pub fn main() {"}, {"sha": "26874b9f9d52dfc1744b9db85931e1f30216241c", "filename": "src/test/run-pass/const-vecs-and-slices.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static x : [int, ..4] = [1,2,3,4];\n+static x : [int; 4] = [1,2,3,4];\n static y : &'static [int] = &[1,2,3,4];\n-static z : &'static [int, ..4] = &[1,2,3,4];\n+static z : &'static [int; 4] = &[1,2,3,4];\n static zz : &'static [int] = &[1,2,3,4];\n \n pub fn main() {"}, {"sha": "3644ca81d5659f784a13c28718cf9c1b10e07774", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -120,7 +120,7 @@ pub fn main() {\n     assert!((*f2)[1] == 2);\n \n     // Nested Box.\n-    let f1 : Box<Fat<[int, ..3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n+    let f1 : Box<Fat<[int; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n     foo(&*f1);\n     let f2 : Box<Fat<[int]>> = f1;\n     foo(&*f2);"}, {"sha": "d436916c279673c30fed5d2f18a05483acf8a69b", "filename": "src/test/run-pass/enum-vec-initializer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-vec-initializer.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -16,9 +16,9 @@ const BAR:uint = Flopsy::Bunny as uint;\n const BAR2:uint = BAR;\n \n pub fn main() {\n-    let _v = [0i, .. Flopsy::Bunny as uint];\n-    let _v = [0i, .. BAR];\n-    let _v = [0i, .. BAR2];\n+    let _v = [0i;  Flopsy::Bunny as uint];\n+    let _v = [0i;  BAR];\n+    let _v = [0i;  BAR2];\n     const BAR3:uint = BAR2;\n-    let _v = [0i, .. BAR3];\n+    let _v = [0i;  BAR3];\n }"}, {"sha": "28b5f781b5cfd7d962cd5d6b434e8adf35ac58f9", "filename": "src/test/run-pass/evec-internal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fevec-internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fevec-internal.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,16 +13,16 @@\n // Doesn't work; needs a design decision.\n \n pub fn main() {\n-    let x : [int, ..5] = [1,2,3,4,5];\n-    let _y : [int, ..5] = [1,2,3,4,5];\n+    let x : [int; 5] = [1,2,3,4,5];\n+    let _y : [int; 5] = [1,2,3,4,5];\n     let mut z = [1,2,3,4,5];\n     z = x;\n     assert_eq!(z[0], 1);\n     assert_eq!(z[4], 5);\n \n-    let a : [int, ..5] = [1,1,1,1,1];\n-    let b : [int, ..5] = [2,2,2,2,2];\n-    let c : [int, ..5] = [2,2,2,2,3];\n+    let a : [int; 5] = [1,1,1,1,1];\n+    let b : [int; 5] = [2,2,2,2,2];\n+    let c : [int; 5] = [2,2,2,2,3];\n \n     log(debug, a);\n "}, {"sha": "38d1093762432652df59625ee5e8fddebe155a7d", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,25 +10,27 @@\n \n #![feature(macro_rules)]\n \n-use std::num::strconv as s;\n+use std::num::strconv::ExponentFormat::{ExpBin, ExpDec};\n+use std::num::strconv::SignificantDigits::DigMax;\n+use std::num::strconv::SignFormat::{SignAll, SignNeg};\n use std::num::strconv::float_to_str_common as to_string;\n \n macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } });\n \n pub fn main() {\n     // Basic usage\n-    t!(to_string(1.2345678e-5f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n+    t!(to_string(1.2345678e-5f64, 10u, true, SignNeg, DigMax(6), ExpDec, false),\n              \"1.234568e-5\");\n \n     // Hexadecimal output\n-    t!(to_string(7.281738281250e+01f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(7.281738281250e+01f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n               \"+1.2345p+6\");\n-    t!(to_string(-1.777768135071e-02f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(-1.777768135071e-02f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n              \"-1.2345p-6\");\n \n     // Some denormals\n-    t!(to_string(4.9406564584124654e-324f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(4.9406564584124654e-324f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1074\");\n-    t!(to_string(2.2250738585072009e-308f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n+    t!(to_string(2.2250738585072009e-308f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1022\");\n }"}, {"sha": "e24731546edfe3cc035a3e2fe8c2e38424fd82a3", "filename": "src/test/run-pass/huge-largest-array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,10 +12,10 @@ use std::mem::size_of;\n \n #[cfg(target_word_size = \"32\")]\n pub fn main() {\n-    assert_eq!(size_of::<[u8, ..(1 << 31) - 1]>(), (1 << 31) - 1);\n+    assert_eq!(size_of::<[u8; (1 << 31) - 1]>(), (1 << 31) - 1);\n }\n \n #[cfg(target_word_size = \"64\")]\n pub fn main() {\n-    assert_eq!(size_of::<[u8, ..(1 << 47) - 1]>(), (1 << 47) - 1);\n+    assert_eq!(size_of::<[u8; (1 << 47) - 1]>(), (1 << 47) - 1);\n }"}, {"sha": "f3e15562b6dc99a92d1f46173518f3aa861ebacf", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -60,6 +60,7 @@ pub fn main() {\n     t!(format!(\"{}\", 10i), \"10\");\n     t!(format!(\"{}\", 10i), \"10\");\n     t!(format!(\"{}\", 10u), \"10\");\n+    t!(format!(\"{:?}\", true), \"true\");\n     t!(format!(\"{:o}\", 10u), \"12\");\n     t!(format!(\"{:x}\", 10u), \"a\");\n     t!(format!(\"{:X}\", 10u), \"A\");"}, {"sha": "549a70f19e334fb166149f2cee556d6b55523ec5", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,22 +12,22 @@\n \n trait Foo {}\n impl Foo for int {}\n-fn foo(_: [&Foo, ..2]) {}\n+fn foo(_: [&Foo; 2]) {}\n fn foos(_: &[&Foo]) {}\n fn foog<T>(_: &[T], _: &[T]) {}\n \n-fn bar(_: [Box<Foo>, ..2]) {}\n+fn bar(_: [Box<Foo>; 2]) {}\n fn bars(_: &[Box<Foo>]) {}\n \n fn main() {\n-    let x: [&Foo, ..2] = [&1i, &2i];\n+    let x: [&Foo; 2] = [&1i, &2i];\n     foo(x);\n     foo([&1i, &2i]);\n \n     let r = &1i;\n-    let x: [&Foo, ..2] = [r, ..2];\n+    let x: [&Foo; 2] = [r; 2];\n     foo(x);\n-    foo([&1i, ..2]);\n+    foo([&1i; 2]);\n \n     let x: &[&Foo] = &[&1i, &2i];\n     foos(x);\n@@ -37,7 +37,7 @@ fn main() {\n     let r = &1i;\n     foog(x, &[r]);\n \n-    let x: [Box<Foo>, ..2] = [box 1i, box 2i];\n+    let x: [Box<Foo>; 2] = [box 1i, box 2i];\n     bar(x);\n     bar([box 1i, box 2i]);\n \n@@ -49,16 +49,16 @@ fn main() {\n     foog(x, &[box 1i]);\n \n     struct T<'a> {\n-        t: [&'a (Foo+'a), ..2]\n+        t: [&'a (Foo+'a); 2]\n     }\n     let _n = T {\n         t: [&1i, &2i]\n     };\n     let r = &1i;\n     let _n = T {\n-        t: [r, ..2]\n+        t: [r; 2]\n     };\n-    let x: [&Foo, ..2] = [&1i, &2i];\n+    let x: [&Foo; 2] = [&1i, &2i];\n     let _n = T {\n         t: x\n     };\n@@ -70,11 +70,11 @@ fn main() {\n         t: &[&1i, &2i]\n     };\n     let r = &1i;\n-    let r: [&Foo, ..2] = [r, ..2];\n+    let r: [&Foo; 2] = [r; 2];\n     let _n = F {\n         t: &r\n     };\n-    let x: [&Foo, ..2] = [&1i, &2i];\n+    let x: [&Foo; 2] = [&1i, &2i];\n     let _n = F {\n         t: &x\n     };\n@@ -85,7 +85,7 @@ fn main() {\n     let _n = M {\n         t: &[box 1i, box 2i]\n     };\n-    let x: [Box<Foo>, ..2] = [box 1i, box 2i];\n+    let x: [Box<Foo>; 2] = [box 1i, box 2i];\n     let _n = M {\n         t: &x\n     };"}, {"sha": "329ab7c921dda3ebe476af0fb67d00ba0e6d6e3f", "filename": "src/test/run-pass/issue-13259-windows-tcb-trash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13259-windows-tcb-trash.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -27,7 +27,7 @@ mod imp {\n     }\n \n     pub fn test() {\n-        let mut buf: [u16, ..50] = [0, ..50];\n+        let mut buf: [u16; 50] = [0; 50];\n         let ret = unsafe {\n             FormatMessageW(0x1000, 0 as *mut c_void, 1, 0x400,\n                            buf.as_mut_ptr(), buf.len() as u32, 0 as *const c_void)"}, {"sha": "81b6892b0f97ac4f97922a6125b02c11c82a6f44", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,9 +12,9 @@ use std::u8;\n \n const NUM: uint = u8::BITS as uint;\n \n-struct MyStruct { nums: [uint, ..8] }\n+struct MyStruct { nums: [uint; 8] }\n \n \n fn main() {\n-    let _s = MyStruct { nums: [0, ..NUM] };\n+    let _s = MyStruct { nums: [0; NUM] };\n }"}, {"sha": "f62a45277b22a29c1b7c0923dd9edc96f94d3402", "filename": "src/test/run-pass/issue-13837.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13837.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static TEST_VALUE : *const [int, ..2] = 0x1234 as *const [int, ..2];\n+static TEST_VALUE : *const [int; 2] = 0x1234 as *const [int; 2];\n \n fn main() {}"}, {"sha": "d815620c9694d7f4fede8925019fd7f671e467c9", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let args = os::args();\n     if args.len() > 1 {\n         let mut out = stdio::stdout();\n-        out.write(&['a' as u8, ..128 * 1024]).unwrap();\n+        out.write(&['a' as u8; 128 * 1024]).unwrap();\n     } else {\n         let out = Command::new(args[0].as_slice()).arg(\"child\").output();\n         let out = out.unwrap();"}, {"sha": "e66788a2c003779d020a725b2c6f51725bf17c5e", "filename": "src/test/run-pass/issue-15673.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15673.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,6 +10,6 @@\n \n use std::iter::AdditiveIterator;\n fn main() {\n-    let x: [u64, ..3] = [1, 2, 3];\n+    let x: [u64; 3] = [1, 2, 3];\n     assert_eq!(6, range(0, 3).map(|i| x[i]).sum());\n }"}, {"sha": "b2abf2d2b1a9c60238af56ad651827f953f8092a", "filename": "src/test/run-pass/issue-17302.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-17302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-17302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17302.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static mut DROPPED: [bool, ..2] = [false, false];\n+static mut DROPPED: [bool; 2] = [false, false];\n \n struct A(uint);\n struct Foo { _a: A, _b: int }"}, {"sha": "827e6a10abdfd12fcc064c1adb26f963cd44237b", "filename": "src/test/run-pass/issue-17877.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17877.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n fn main() {\n-    assert_eq!(match [0u8, ..1024] {\n+    assert_eq!(match [0u8; 1024] {\n         _ => 42u,\n     }, 42u);\n \n-    assert_eq!(match [0u8, ..1024] {\n+    assert_eq!(match [0u8; 1024] {\n         [1, _..] => 0u,\n         [0, _..] => 1u,\n         _ => 2u"}, {"sha": "f61530c741851e1c0d33180c1bae5523082832ff", "filename": "src/test/run-pass/issue-18425.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-18425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18425.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,5 +12,5 @@\n // expression with a count of 1 and a non-Copy element type.\n \n fn main() {\n-    let _ = [box 1u, ..1];\n+    let _ = [box 1u; 1];\n }"}, {"sha": "3ee5ce9bff93a089ffeb34a59e3cd50cf16939a0", "filename": "src/test/run-pass/issue-19244.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-19244.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-19244.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19244.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,8 +13,8 @@ const STRUCT: MyStruct = MyStruct { field: 42 };\n const TUP: (uint,) = (43,);\n \n fn main() {\n-    let a = [0i, ..STRUCT.field];\n-    let b = [0i, ..TUP.0];\n+    let a = [0i; STRUCT.field];\n+    let b = [0i; TUP.0];\n \n     assert!(a.len() == 42);\n     assert!(b.len() == 43);"}, {"sha": "23400859e54f1daa7cb464123bf7f6a845ff157c", "filename": "src/test/run-pass/issue-19811-escape-unicode.rs", "status": "renamed", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19811-escape-unicode.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,5 +9,9 @@\n // except according to those terms.\n \n fn main() {\n-    let [_, ..,] = [(), ()]; //~ ERROR unexpected token: `]`\n+    let mut escaped = String::from_str(\"\");\n+    for c in '\\u{10401}'.escape_unicode() {\n+        escaped.push(c);\n+    }\n+    assert_eq!(\"\\\\u{10401}\", escaped);\n }", "previous_filename": "src/test/compile-fail/trailing-comma-array-repeat.rs"}, {"sha": "d653843ba059044b5bc10f09b2d702cef2e6cc48", "filename": "src/test/run-pass/issue-20091.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20091.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows currently windows requires UTF-8 for spawning processes\n+\n+use std::io::Command;\n+use std::os;\n+\n+fn main() {\n+    if os::args().len() == 1 {\n+        assert!(Command::new(os::self_exe_name().unwrap()).arg(b\"\\xff\")\n+                        .status().unwrap().success())\n+    }\n+}"}, {"sha": "f87eb46d553b77446686cbafb353285a0a40fcda", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -63,7 +63,7 @@ fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr)\n                    -> Vec<Vec<square>> {\n     let mut input: &mut io::Reader = &mut input;\n     let mut grid = Vec::new();\n-    let mut line = [0, ..10];\n+    let mut line = [0; 10];\n     input.read(&mut line);\n     let mut row = Vec::new();\n     for c in line.iter() {"}, {"sha": "8a39676ca17ac44a40e7266c1523e41800e53872", "filename": "src/test/run-pass/issue-3656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3656.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -16,7 +16,7 @@ extern crate libc;\n use libc::{c_uint, uint32_t, c_void};\n \n pub struct KEYGEN {\n-    hash_algorithm: [c_uint, ..2],\n+    hash_algorithm: [c_uint; 2],\n     count: uint32_t,\n     salt: *const c_void,\n     salt_size: uint32_t,"}, {"sha": "43948ef4a45c52d7834ba37760862b0f589978ab", "filename": "src/test/run-pass/issue-4387.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-4387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-4387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4387.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    let _foo = [0i, ..2*4];\n+    let _foo = [0i; 2*4];\n }"}, {"sha": "7c8940aafbfbe82831d82363cc2a8f2ea8a8b315", "filename": "src/test/run-pass/issue-5688.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-5688.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5688.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,7 +13,7 @@\n \n ...should print &[1, 2, 3] but instead prints something like\n &[4492532864, 24]. It is pretty evident that the compiler messed up\n-with the representation of [int, ..n] and [int] somehow, or at least\n+with the representation of [int; n] and [int] somehow, or at least\n failed to typecheck correctly.\n */\n "}, {"sha": "b936eb322fc5ffc17506cde105d74a5e6dcf449a", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -10,10 +10,10 @@\n \n #![feature(advanced_slice_patterns)]\n \n-fn foo<T: Add<T, T> + Clone>([x, y, z]: [T, ..3]) -> (T, T, T) {\n+fn foo<T: Add<T, T> + Clone>([x, y, z]: [T; 3]) -> (T, T, T) {\n     (x.clone(), x.clone() + y.clone(), x + y + z)\n }\n-fn bar(a: &'static str, b: &'static str) -> [&'static str, ..4] {\n+fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {\n     [a, b, b, a]\n }\n "}, {"sha": "321e22cd19c9268c0dd5dfc0ef44541cfbb4ee78", "filename": "src/test/run-pass/issue-9942.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9942.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    const S: uint = 23 as uint; [0i, ..S]; ()\n+    const S: uint = 23 as uint; [0i; S]; ()\n }"}, {"sha": "ecd7c0458f701a391157fa7203b7ac80b5d8b631", "filename": "src/test/run-pass/macro-invocation-in-count-expr-fixed-array-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -15,5 +15,5 @@ macro_rules! four (\n );\n \n fn main() {\n-    let _x: [u16, ..four!()];\n+    let _x: [u16; four!()];\n }"}, {"sha": "db512adc011646db661cbfa3bd41660648c0d112", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -64,7 +64,7 @@ fn issue_6533() {\n }\n \n fn issue_13626() {\n-    const VAL: [u8, ..1] = [0];\n+    const VAL: [u8; 1] = [0];\n     match [1] {\n         VAL => unreachable!(),\n         _ => ()"}, {"sha": "9ae7f49c75a154f22d97e2a237032b2df6810cb8", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -38,7 +38,7 @@ impl<'a> MyWriter for &'a mut [u8] {\n }\n \n fn main() {\n-    let mut buf = [0_u8, .. 6];\n+    let mut buf = [0_u8; 6];\n \n     {\n         let mut writer = buf.as_mut_slice();"}, {"sha": "fbecb6851b68758dd44ad067850761c22dafde8b", "filename": "src/test/run-pass/method-two-traits-distinguished-via-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -28,7 +28,7 @@ impl<T> B for *const [T] {\n }\n \n fn main() {\n-    let x: [int, ..4] = [1,2,3,4];\n+    let x: [int; 4] = [1,2,3,4];\n     let xptr = x.as_slice() as *const _;\n     xptr.foo();\n }"}, {"sha": "bf926a6c48ace0fcf29841d4c89b69e4f47cf49f", "filename": "src/test/run-pass/mutability-inherits-through-fixed-length-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutability-inherits-through-fixed-length-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n fn test1() {\n-    let mut ints = [0i, ..32];\n+    let mut ints = [0i; 32];\n     ints[0] += 1;\n     assert_eq!(ints[0], 1);\n }\n \n fn test2() {\n-    let mut ints = [0i, ..32];\n+    let mut ints = [0i; 32];\n     for i in ints.iter_mut() { *i += 22; }\n     for i in ints.iter() { assert!(*i == 22); }\n }"}, {"sha": "e06461daed0c93c9afea708e96e195bf276283cc", "filename": "src/test/run-pass/new-style-fixed-length-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static FOO: [int, ..3] = [1, 2, 3];\n+static FOO: [int; 3] = [1, 2, 3];\n \n pub fn main() {\n     println!(\"{} {} {}\", FOO[0], FOO[1], FOO[2]);"}, {"sha": "2660de619e9c775f709159ac750df76c67845c96", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,7 +20,7 @@ use std::{option, mem};\n // trying to get assert failure messages that at least identify which case\n // failed.\n \n-enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n+enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8; 0]) }\n impl<T> E<T> {\n     fn is_none(&self) -> bool {\n         match *self {\n@@ -54,7 +54,7 @@ macro_rules! check_fancy {\n         check_fancy!($e: $T, |ptr| assert!(*ptr == $e));\n     }};\n     ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n-        assert!(E::Nothing::<$T>((), ((), ()), [23i8, ..0]).is_none());\n+        assert!(E::Nothing::<$T>((), ((), ()), [23i8; 0]).is_none());\n         let e = $e;\n         let t_ = E::Thing::<$T>(23, e);\n         match t_.get_ref() {"}, {"sha": "afc22be38b8a48b16b542a642f46a8418cea235e", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@\n \n use std::mem;\n \n-enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n+enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8; 0]) }\n struct S<T>(int, T);\n \n // These are macros so we get useful assert messages."}, {"sha": "a866be43a051473b5b8fcc9fe0921a10b8307414", "filename": "src/test/run-pass/order-drop-with-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,7 +14,7 @@\n // in ORDER matching up to when it ran.\n // Correct order is: matched, inner, outer\n \n-static mut ORDER: [uint, ..3] = [0, 0, 0];\n+static mut ORDER: [uint; 3] = [0, 0, 0];\n static mut INDEX: uint = 0;\n \n struct A;"}, {"sha": "674d0dc86da1cd35900a7e6ba06c0c6548a5551d", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -27,7 +27,7 @@ pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n \n #[no_stack_check]\n fn recurse() {\n-    let buf = [0i, ..10];\n+    let buf = [0i; 10];\n     black_box(buf);\n     recurse();\n }"}, {"sha": "79926776abf4c0284470a080158bf793c993290d", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -28,7 +28,7 @@ pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n \n #[no_stack_check]\n fn recurse() {\n-    let buf = [0i, ..10];\n+    let buf = [0i; 10];\n     black_box(buf);\n     recurse();\n }"}, {"sha": "1594cca89e55b8ada6f50b385afd3922c1f72964", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -22,7 +22,7 @@ use std::os;\n pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n \n fn silent_recurse() {\n-    let buf = [0i, ..1000];\n+    let buf = [0i; 1000];\n     black_box(buf);\n     silent_recurse();\n }"}, {"sha": "004a30220183ed101a9b5b28010625286121a397", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -20,7 +20,7 @@ struct S<T, S> {\n pub fn main() {\n     unsafe {\n         let s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as i32 };\n-        let transd : [u8, .. 9] = mem::transmute(s);\n+        let transd : [u8; 9] = mem::transmute(s);\n         // Don't worry about endianness, the numbers are palindromic.\n         assert!(transd ==\n                    [0xff, 0xff, 0xff, 0xff,\n@@ -29,7 +29,7 @@ pub fn main() {\n \n \n         let s = S { a: 1u8, b: 2u8, c: 0b10000001_10000001 as i16};\n-        let transd : [u8, .. 4] = mem::transmute(s);\n+        let transd : [u8; 4] = mem::transmute(s);\n         // Again, no endianness problems.\n         assert!(transd ==\n                    [1, 2, 0b10000001, 0b10000001]);"}, {"sha": "9e94502a92a6384199380bd85bc708ed62d80cea", "filename": "src/test/run-pass/packed-struct-layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-layout.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -13,7 +13,7 @@ use std::mem;\n #[repr(packed)]\n struct S4 {\n     a: u8,\n-    b: [u8, .. 3],\n+    b: [u8; 3],\n }\n \n #[repr(packed)]\n@@ -25,11 +25,11 @@ struct S5 {\n pub fn main() {\n     unsafe {\n         let s4 = S4 { a: 1, b: [2,3,4] };\n-        let transd : [u8, .. 4] = mem::transmute(s4);\n+        let transd : [u8; 4] = mem::transmute(s4);\n         assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5 { a: 1, b: 0xff_00_00_ff };\n-        let transd : [u8, .. 5] = mem::transmute(s5);\n+        let transd : [u8; 5] = mem::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n         assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }"}, {"sha": "846d51e2e7ecc916e29e1fad89a53541ab5bc610", "filename": "src/test/run-pass/packed-struct-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-size.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,7 +14,7 @@ use std::mem;\n #[repr(packed)]\n struct S4 {\n     a: u8,\n-    b: [u8, .. 3],\n+    b: [u8;  3],\n }\n \n #[repr(packed)]"}, {"sha": "d2121aa775216d221b34ee7776744d263fb06b36", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -22,9 +22,9 @@ struct Foo {\n impl Copy for Foo {}\n \n pub fn main() {\n-    let foos = [Foo { bar: 1, baz: 2 }, .. 10];\n+    let foos = [Foo { bar: 1, baz: 2 }; 10];\n \n-    assert_eq!(mem::size_of::<[Foo, .. 10]>(), 90);\n+    assert_eq!(mem::size_of::<[Foo; 10]>(), 90);\n \n     for i in range(0u, 10) {\n         assert_eq!(foos[i], Foo { bar: 1, baz: 2});"}, {"sha": "c41d678b0f5b702826f1b7e098112bc9a5b37f5d", "filename": "src/test/run-pass/packed-tuple-struct-layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-layout.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,19 +11,19 @@\n use std::mem;\n \n #[repr(packed)]\n-struct S4(u8,[u8, .. 3]);\n+struct S4(u8,[u8; 3]);\n \n #[repr(packed)]\n struct S5(u8,u32);\n \n pub fn main() {\n     unsafe {\n         let s4 = S4(1, [2,3,4]);\n-        let transd : [u8, .. 4] = mem::transmute(s4);\n+        let transd : [u8; 4] = mem::transmute(s4);\n         assert!(transd == [1, 2, 3, 4]);\n \n         let s5 = S5(1, 0xff_00_00_ff);\n-        let transd : [u8, .. 5] = mem::transmute(s5);\n+        let transd : [u8; 5] = mem::transmute(s5);\n         // Don't worry about endianness, the u32 is palindromic.\n         assert!(transd == [1, 0xff, 0, 0, 0xff]);\n     }"}, {"sha": "a0b88ea53c5a4f3d60d54de588ffbeba0e8cd883", "filename": "src/test/run-pass/packed-tuple-struct-size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-tuple-struct-size.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -12,7 +12,7 @@\n use std::mem;\n \n #[repr(packed)]\n-struct S4(u8,[u8, .. 3]);\n+struct S4(u8,[u8;  3]);\n \n #[repr(packed)]\n struct S5(u8, u32);"}, {"sha": "41396ef01bee8def070e284a246f9f2822bd2069", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -18,7 +18,7 @@ struct A {\n \n struct B {\n     v1: int,\n-    v2: [int, ..3],\n+    v2: [int; 3],\n     v3: Vec<int> ,\n     v4: C,\n     v5: Box<C>,"}, {"sha": "a53f1da4ce605ee7a1bdc3bbb8bd115c2ba10732", "filename": "src/test/run-pass/repeat-expr-in-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeat-expr-in-static.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static FOO: [int, ..4] = [32, ..4];\n-static BAR: [int, ..4] = [32, 32, 32, 32];\n+static FOO: [int; 4] = [32; 4];\n+static BAR: [int; 4] = [32, 32, 32, 32];\n \n pub fn main() {\n     assert!(FOO == BAR);"}, {"sha": "0781822cb748203ac502305255d04a561904d0cd", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,8 +11,8 @@\n #![feature(slicing_syntax)]\n \n pub fn main() {\n-    let x = [ [true], ..512 ];\n-    let y = [ 0i, ..1 ];\n+    let x = [ [true]; 512 ];\n+    let y = [ 0i; 1 ];\n \n     print!(\"[\");\n     for xi in x.iter() {"}, {"sha": "3ece042aef0539089096f4209fc202a9fbfb1399", "filename": "src/test/run-pass/self-impl.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fself-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fself-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-impl.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can use `Self` types in impls in the expected way.\n+\n+struct Foo;\n+\n+// Test uses on inherant impl.\n+impl Foo {\n+    fn foo(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+        Foo\n+    }\n+}\n+\n+// Test uses when implementing a trait and with a type parameter.\n+pub struct Baz<X> {\n+    pub f: X,\n+}\n+\n+trait Bar<X> {\n+    fn bar(x: Self, y: &Self, z: Box<Self>) -> Self;\n+}\n+\n+impl Bar<int> for Box<Baz<int>> {\n+    fn bar(_x: Self, _y: &Self, _z: Box<Self>) -> Self {\n+        box Baz { f: 42 }\n+    }\n+}\n+\n+fn main() {\n+    let _: Foo = Foo::foo(Foo, &Foo, box Foo);\n+    let _: Box<Baz<int>> = Bar::bar(box Baz { f: 42 },\n+                                    &box Baz { f: 42 },\n+                                    box box Baz { f: 42 });\n+}"}, {"sha": "c2bd738b8a46bad1371ec7cb34342f03d69b57bb", "filename": "src/test/run-pass/uninit-empty-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -18,6 +18,6 @@ struct Foo;\n pub fn main() {\n     unsafe {\n         let _x: Foo = mem::uninitialized();\n-        let _x: [Foo, ..2] = mem::uninitialized();\n+        let _x: [Foo; 2] = mem::uninitialized();\n     }\n }"}, {"sha": "271f5817c9e79fd0a3c90012fe8bf9f804ae2524", "filename": "src/test/run-pass/unsized3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized3.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -60,7 +60,7 @@ pub fn main() {\n \n     unsafe {\n         struct Foo_<T> {\n-            f: [T, ..3]\n+            f: [T; 3]\n         }\n \n         let data = box Foo_{f: [1i32, 2, 3] };\n@@ -72,7 +72,7 @@ pub fn main() {\n \n         struct Baz_ {\n             f1: uint,\n-            f2: [u8, ..5],\n+            f2: [u8; 5],\n         }\n \n         let data = box Baz_{ f1: 42, f2: ['a' as u8, 'b' as u8, 'c' as u8, 'd' as u8, 'e' as u8] };"}, {"sha": "f8eef98856114a9e1703ba5a044ac2a9b5971377", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -19,7 +19,7 @@ extern {\n }\n \n unsafe fn check<T>(expected: &str, f: |*mut c_char| -> T) {\n-    let mut x = [0 as c_char, ..50];\n+    let mut x = [0 as c_char; 50];\n     f(&mut x[0] as *mut c_char);\n     let res = CString::new(&x[0], false);\n     assert_eq!(expected, res.as_str().unwrap());"}, {"sha": "4a36231e72b0af44aead25b0212a3a96ccdcd056", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n pub fn main() {\n-    // Tests for indexing into box/& [T, ..n]\n-    let x: [int, ..3] = [1, 2, 3];\n-    let mut x: Box<[int, ..3]> = box x;\n+    // Tests for indexing into box/& [T; n]\n+    let x: [int; 3] = [1, 2, 3];\n+    let mut x: Box<[int; 3]> = box x;\n     assert!(x[0] == 1);\n     assert!(x[1] == 2);\n     assert!(x[2] == 3);\n@@ -20,8 +20,8 @@ pub fn main() {\n     assert!(x[1] == 45);\n     assert!(x[2] == 3);\n \n-    let mut x: [int, ..3] = [1, 2, 3];\n-    let x: &mut [int, ..3] = &mut x;\n+    let mut x: [int; 3] = [1, 2, 3];\n+    let x: &mut [int; 3] = &mut x;\n     assert!(x[0] == 1);\n     assert!(x[1] == 2);\n     assert!(x[2] == 3);"}, {"sha": "20e1becd008a52d2215b7068f658b2ad97c40cbb", "filename": "src/test/run-pass/vec-fixed-length.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-fixed-length.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -11,17 +11,17 @@\n use std::mem::size_of;\n \n pub fn main() {\n-    let x: [int, ..4] = [1, 2, 3, 4];\n+    let x: [int; 4] = [1, 2, 3, 4];\n     assert_eq!(x[0], 1);\n     assert_eq!(x[1], 2);\n     assert_eq!(x[2], 3);\n     assert_eq!(x[3], 4);\n \n-    assert_eq!(size_of::<[u8, ..4]>(), 4u);\n+    assert_eq!(size_of::<[u8; 4]>(), 4u);\n \n     // FIXME #10183\n     // FIXME #18069\n     //if cfg!(target_word_size = \"64\") {\n-    //    assert_eq!(size_of::<[u8, ..(1 << 32)]>(), (1u << 32));\n+    //    assert_eq!(size_of::<[u8; (1 << 32)]>(), (1u << 32));\n     //}\n }"}, {"sha": "97a443cb3b8e0fc0c6c55a7165e11b1b7eda03e7", "filename": "src/test/run-pass/vec-repeat-with-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-repeat-with-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvec-repeat-with-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-repeat-with-cast.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let _a = [0i, ..1 as uint]; }\n+pub fn main() { let _a = [0i; 1 as uint]; }"}, {"sha": "fe89c7532eebcc0ad429e6a9af5f2fd17a7e045c", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d680009205de2302b902d8f9f5f7ae7a042f1a/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=34d680009205de2302b902d8f9f5f7ae7a042f1a", "patch": "@@ -14,7 +14,7 @@ use std::rand::{task_rng, Rng, Rand};\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n-static drop_counts: [AtomicUint, .. MAX_LEN] =\n+static drop_counts: [AtomicUint;  MAX_LEN] =\n     // FIXME #5244: AtomicUint is not Copy.\n     [\n         INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,"}]}