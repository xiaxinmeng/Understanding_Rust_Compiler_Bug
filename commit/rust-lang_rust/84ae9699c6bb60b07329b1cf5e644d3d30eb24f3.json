{"sha": "84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YWU5Njk5YzZiYjYwYjA3MzI5YjFjZjVlNjQ0ZDNkMzBlYjI0ZjM=", "commit": {"author": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-05-27T02:41:34Z"}, "committer": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-05-27T03:27:31Z"}, "message": "Prevent Vec::drain_filter from double dropping on panic\n\nFixes: #60977", "tree": {"sha": "e0be1f05eeebfb4dc2b8fe90fdfd3b7e299dfdb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0be1f05eeebfb4dc2b8fe90fdfd3b7e299dfdb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "html_url": "https://github.com/rust-lang/rust/commit/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3/comments", "author": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5187be620c76a313a19b9b596e1bce3a80a345dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5187be620c76a313a19b9b596e1bce3a80a345dd", "html_url": "https://github.com/rust-lang/rust/commit/5187be620c76a313a19b9b596e1bce3a80a345dd"}], "stats": {"total": 172, "additions": 162, "deletions": 10}, "files": [{"sha": "c0967cd374d5e7b7fcae4af085229579b082cce6", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "patch": "@@ -945,6 +945,105 @@ fn drain_filter_complex() {\n     }\n }\n \n+#[test]\n+fn drain_filter_consumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is explictly consumed\n+        drain.for_each(drop);\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n+#[test]\n+fn drain_filter_unconsumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let _drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is dropped without being consumed\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n #[test]\n fn test_reserve_exact() {\n     // This is all the same as test_reserve"}, {"sha": "adc0929fdbed495b384f813a922f7c71059aec4d", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 63, "deletions": 10, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ae9699c6bb60b07329b1cf5e644d3d30eb24f3/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=84ae9699c6bb60b07329b1cf5e644d3d30eb24f3", "patch": "@@ -2120,6 +2120,7 @@ impl<T> Vec<T> {\n             del: 0,\n             old_len,\n             pred: filter,\n+            panic_flag: false,\n         }\n     }\n }\n@@ -2751,6 +2752,7 @@ pub struct DrainFilter<'a, T, F>\n     del: usize,\n     old_len: usize,\n     pred: F,\n+    panic_flag: bool,\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n@@ -2760,21 +2762,34 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n+        struct SetIdxOnDrop<'a> {\n+            idx: &'a mut usize,\n+            new_idx: usize,\n+        }\n+\n+        impl<'a> Drop for SetIdxOnDrop<'a> {\n+            fn drop(&mut self) {\n+                *self.idx = self.new_idx;\n+            }\n+        }\n+\n         unsafe {\n-            while self.idx != self.old_len {\n+            while self.idx < self.old_len {\n                 let i = self.idx;\n-                self.idx += 1;\n                 let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                if (self.pred)(&mut v[i]) {\n+                let mut set_idx = SetIdxOnDrop { new_idx: self.idx, idx: &mut self.idx };\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                set_idx.new_idx += 1;\n+                if drained {\n                     self.del += 1;\n                     return Some(ptr::read(&v[i]));\n-                } else if self.del > 0 {\n+                }\n+                else if self.del > 0 {\n                     let del = self.del;\n                     let src: *const T = &v[i];\n                     let dst: *mut T = &mut v[i - del];\n-                    // This is safe because self.vec has length 0\n-                    // thus its elements will not have Drop::drop\n-                    // called on them in the event of a panic.\n                     ptr::copy_nonoverlapping(src, dst, 1);\n                 }\n             }\n@@ -2792,9 +2807,47 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n-        unsafe {\n-            self.vec.set_len(self.old_len - self.del);\n+        // If the predicate panics, we still need to backshift everything\n+        // down after the last successfully drained element, but no additional\n+        // elements are drained or checked.\n+        struct BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F>,\n+        }\n+\n+        impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    while self.drain.idx < self.drain.old_len {\n+                        let i = self.drain.idx;\n+                        self.drain.idx += 1;\n+                        let v = slice::from_raw_parts_mut(\n+                            self.drain.vec.as_mut_ptr(),\n+                            self.drain.old_len,\n+                        );\n+                        if self.drain.del > 0 {\n+                            let del = self.drain.del;\n+                            let src: *const T = &v[i];\n+                            let dst: *mut T = &mut v[i - del];\n+                            ptr::copy_nonoverlapping(src, dst, 1);\n+                        }\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop {\n+            drain: self\n+        };\n+\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n         }\n     }\n }"}]}