{"sha": "5a7342c3dde43c96a71bc27995030896342761f6", "node_id": "C_kwDOAAsO6NoAKDVhNzM0MmMzZGRlNDNjOTZhNzFiYzI3OTk1MDMwODk2MzQyNzYxZjY", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-03T04:58:22Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-05T00:41:35Z"}, "message": "Stop using `into_iter` in `array::map`", "tree": {"sha": "09b68957ad641e2b8c5c47ca03eda6f3345bbd59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09b68957ad641e2b8c5c47ca03eda6f3345bbd59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7342c3dde43c96a71bc27995030896342761f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7342c3dde43c96a71bc27995030896342761f6", "html_url": "https://github.com/rust-lang/rust/commit/5a7342c3dde43c96a71bc27995030896342761f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7342c3dde43c96a71bc27995030896342761f6/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d3ba5bcbf5c7e13d4ce068d3339710701dd603", "html_url": "https://github.com/rust-lang/rust/commit/50d3ba5bcbf5c7e13d4ce068d3339710701dd603"}], "stats": {"total": 158, "additions": 147, "deletions": 11}, "files": [{"sha": "5ca93d54f876f5b1e72366c49ac53736870a1fc6", "filename": "library/core/src/array/drain.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fdrain.rs?ref=5a7342c3dde43c96a71bc27995030896342761f6", "patch": "@@ -0,0 +1,51 @@\n+use crate::iter::TrustedLen;\n+use crate::mem::ManuallyDrop;\n+use crate::ptr::drop_in_place;\n+use crate::slice;\n+\n+// INVARIANT: It's ok to drop the remainder of the inner iterator.\n+pub(crate) struct Drain<'a, T>(slice::IterMut<'a, T>);\n+\n+pub(crate) fn drain_array_with<T, R, const N: usize>(\n+    array: [T; N],\n+    func: impl for<'a> FnOnce(Drain<'a, T>) -> R,\n+) -> R {\n+    let mut array = ManuallyDrop::new(array);\n+    // SAFETY: Now that the local won't drop it, it's ok to construct the `Drain` which will.\n+    let drain = Drain(array.iter_mut());\n+    func(drain)\n+}\n+\n+impl<T> Drop for Drain<'_, T> {\n+    fn drop(&mut self) {\n+        // SAFETY: By the type invariant, we're allowed to drop all these.\n+        unsafe { drop_in_place(self.0.as_mut_slice()) }\n+    }\n+}\n+\n+impl<T> Iterator for Drain<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        let p: *const T = self.0.next()?;\n+        // SAFETY: The iterator was already advanced, so we won't drop this later.\n+        Some(unsafe { p.read() })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.len();\n+        (n, Some(n))\n+    }\n+}\n+\n+impl<T> ExactSizeIterator for Drain<'_, T> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+}\n+\n+// SAFETY: This is a 1:1 wrapper for a slice iterator, which is also `TrustedLen`.\n+unsafe impl<T> TrustedLen for Drain<'_, T> {}"}, {"sha": "ee340f385431dbc0234c00c05b066f8af5f02a56", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=5a7342c3dde43c96a71bc27995030896342761f6", "patch": "@@ -17,9 +17,12 @@ use crate::ops::{\n };\n use crate::slice::{Iter, IterMut};\n \n+mod drain;\n mod equality;\n mod iter;\n \n+pub(crate) use drain::drain_array_with;\n+\n #[stable(feature = \"array_value_iter\", since = \"1.51.0\")]\n pub use iter::IntoIter;\n \n@@ -513,9 +516,12 @@ impl<T, const N: usize> [T; N] {\n     where\n         F: FnMut(T) -> U,\n     {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n+        drain_array_with(self, |iter| {\n+            let mut iter = iter.map(f);\n+            // SAFETY: we know for certain that this iterator will yield exactly `N`\n+            // items.\n+            unsafe { collect_into_array_unchecked(&mut iter) }\n+        })\n     }\n \n     /// A fallible function `f` applied to each element on array `self` in order to\n@@ -552,9 +558,12 @@ impl<T, const N: usize> [T; N] {\n         R: Try,\n         R::Residual: Residual<[R::Output; N]>,\n     {\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { try_collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n+        drain_array_with(self, |iter| {\n+            let mut iter = iter.map(f);\n+            // SAFETY: we know for certain that this iterator will yield exactly `N`\n+            // items.\n+            unsafe { try_collect_into_array_unchecked(&mut iter) }\n+        })\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -575,11 +584,14 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        let mut iter = IntoIterator::into_iter(self).zip(rhs);\n-\n-        // SAFETY: we know for certain that this iterator will yield exactly `N`\n-        // items.\n-        unsafe { collect_into_array_unchecked(&mut iter) }\n+        drain_array_with(self, |lhs| {\n+            drain_array_with(rhs, |rhs| {\n+                let mut iter = crate::iter::zip(lhs, rhs);\n+                // SAFETY: we know for certain that this iterator will yield exactly `N`\n+                // items.\n+                unsafe { collect_into_array_unchecked(&mut iter) }\n+            })\n+        })\n     }\n \n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`."}, {"sha": "5327e4f813925cdbe40fb3afc1c6a8003e737a65", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7342c3dde43c96a71bc27995030896342761f6/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=5a7342c3dde43c96a71bc27995030896342761f6", "patch": "@@ -700,3 +700,28 @@ fn array_into_iter_rfold() {\n     let s = it.rfold(10, |a, b| 10 * a + b);\n     assert_eq!(s, 10432);\n }\n+\n+#[cfg(not(panic = \"abort\"))]\n+#[test]\n+fn array_map_drops_unmapped_elements_on_panic() {\n+    struct DropCounter<'a>(usize, &'a AtomicUsize);\n+    impl Drop for DropCounter<'_> {\n+        fn drop(&mut self) {\n+            self.1.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    const MAX: usize = 11;\n+    for panic_after in 0..MAX {\n+        let counter = AtomicUsize::new(0);\n+        let a = array::from_fn::<_, 11, _>(|i| DropCounter(i, &counter));\n+        let success = std::panic::catch_unwind(|| {\n+            let _ = a.map(|x| {\n+                assert!(x.0 < panic_after);\n+                assert_eq!(counter.load(Ordering::SeqCst), x.0);\n+            });\n+        });\n+        assert!(success.is_err());\n+        assert_eq!(counter.load(Ordering::SeqCst), MAX);\n+    }\n+}"}, {"sha": "37585371a3222c6a84cc0d99e3717fb136c39b46", "filename": "tests/codegen/array-map.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a7342c3dde43c96a71bc27995030896342761f6/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7342c3dde43c96a71bc27995030896342761f6/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=5a7342c3dde43c96a71bc27995030896342761f6", "patch": "@@ -0,0 +1,48 @@\n+// compile-flags: -C opt-level=3 -C target-cpu=x86-64-v3 -C llvm-args=-x86-asm-syntax=intel --emit=llvm-ir,asm\n+// no-system-llvm\n+// only-x86_64\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+#![feature(array_zip)]\n+\n+// CHECK-LABEL: @short_integer_map\n+#[no_mangle]\n+pub fn short_integer_map(x: [u32; 8]) -> [u32; 8] {\n+    // CHECK: load <8 x i32>\n+    // CHECK: shl <8 x i32>\n+    // CHECK: or <8 x i32>\n+    // CHECK: store <8 x i32>\n+    x.map(|x| 2 * x + 1)\n+}\n+\n+// CHECK-LABEL: @short_integer_zip_map\n+#[no_mangle]\n+pub fn short_integer_zip_map(x: [u32; 8], y: [u32; 8]) -> [u32; 8] {\n+    // CHECK: %[[A:.+]] = load <8 x i32>\n+    // CHECK: %[[B:.+]] = load <8 x i32>\n+    // CHECK: sub <8 x i32> %[[A]], %[[B]]\n+    // CHECK: store <8 x i32>\n+    x.zip(y).map(|(x, y)| x - y)\n+}\n+\n+// This test is checking that LLVM can SRoA away a bunch of the overhead,\n+// like fully moving the iterators to registers.  Notably, previous implementations\n+// of `map` ended up `alloca`ing the whole `array::IntoIterator`, meaning both a\n+// hard-to-eliminate `memcpy` and that the iteration counts needed to be written\n+// out to stack every iteration, even for infallible operations on `Copy` types.\n+//\n+// This is still imperfect, as there's more copies than would be ideal,\n+// but hopefully work like #103830 will improve that in future,\n+// and update this test to be stricter.\n+//\n+// CHECK-LABEL: @long_integer_map\n+#[no_mangle]\n+pub fn long_integer_map(x: [u32; 64]) -> [u32; 64] {\n+    // CHECK: start:\n+    // CHECK-NEXT: alloca [{{64|65}} x i32]\n+    // CHECK-NEXT: alloca [{{64|65}} x i32]\n+    // CHECK-NEXT: alloca %\"core::mem::manually_drop::ManuallyDrop<[u32; 64]>\"\n+    // CHECK-NOT: alloca\n+    x.map(|x| 2 * x + 1)\n+}"}]}