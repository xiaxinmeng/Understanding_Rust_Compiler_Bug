{"sha": "d7a6365b77e171337d4f4220ebdc618965524ecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3YTYzNjViNzdlMTcxMzM3ZDRmNDIyMGViZGM2MTg5NjU1MjRlY2Q=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-17T01:07:49Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-18T16:21:38Z"}, "message": "Rewrite usefulness merging using `SpanSet`\n\n`SpanSet` is heavily inspired from `DefIdForest`.", "tree": {"sha": "cb0d54181b9e67bef53ac29325f04995674d63c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb0d54181b9e67bef53ac29325f04995674d63c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7a6365b77e171337d4f4220ebdc618965524ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a6365b77e171337d4f4220ebdc618965524ecd", "html_url": "https://github.com/rust-lang/rust/commit/d7a6365b77e171337d4f4220ebdc618965524ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7a6365b77e171337d4f4220ebdc618965524ecd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "170fae2c187936498ffdebbbd7e3cad47af31cc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/170fae2c187936498ffdebbbd7e3cad47af31cc9", "html_url": "https://github.com/rust-lang/rust/commit/170fae2c187936498ffdebbbd7e3cad47af31cc9"}], "stats": {"total": 189, "additions": 122, "deletions": 67}, "files": [{"sha": "2c37f7bdb45d87089dab86f994b91015cde4db68", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a6365b77e171337d4f4220ebdc618965524ecd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a6365b77e171337d4f4220ebdc618965524ecd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d7a6365b77e171337d4f4220ebdc618965524ecd", "patch": "@@ -402,7 +402,7 @@ fn report_arm_reachability<'p, 'tcx>(\n             Useful(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Useful(unreachables) => {\n-                let mut unreachables: Vec<_> = unreachables.iter().flatten().copied().collect();\n+                let mut unreachables: Vec<_> = unreachables.iter().collect();\n                 // Emit lints in the order in which they occur in the file.\n                 unreachables.sort_unstable();\n                 for span in unreachables {"}, {"sha": "5af155bd746a30d6f4f6d995174671c62fa2cabd", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 113, "deletions": 64, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d7a6365b77e171337d4f4220ebdc618965524ecd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a6365b77e171337d4f4220ebdc618965524ecd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=d7a6365b77e171337d4f4220ebdc618965524ecd", "patch": "@@ -311,7 +311,6 @@ use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::OnceCell;\n \n use rustc_arena::TypedArena;\n@@ -626,11 +625,81 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n+/// Represents a set of `Span`s closed under the containment relation. That is, if a `Span` is\n+/// contained in the set then all `Span`s contained in it are also implicitly contained in the set.\n+/// In particular this means that when intersecting two sets, taking the intersection of some span\n+/// and one of its subspans returns the subspan, whereas a simple `HashSet` would have returned an\n+/// empty intersection.\n+/// It is assumed that two spans don't overlap without one being contained in the other; in other\n+/// words, that the inclusion structure forms a tree and not a DAG.\n+/// Operations on this do not need to be fast since it's only nonempty in the diagnostic path.\n+#[derive(Debug, Clone, Default)]\n+pub(crate) struct SpanSet {\n+    /// The minimal set of `Span`s required to represent the whole set. If A and B are `Span`s in\n+    /// the `SpanSet`, and A is a descendant of B, then only B will be in `root_spans`.\n+    /// Invariant: the spans are disjoint.\n+    root_spans: Vec<Span>,\n+}\n+\n+impl SpanSet {\n+    /// Creates an empty set.\n+    fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    /// Tests whether the set is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        self.root_spans.is_empty()\n+    }\n+\n+    /// Iterate over the disjoint list of spans at the roots of this set.\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = Span> + Captures<'a> {\n+        self.root_spans.iter().copied()\n+    }\n+\n+    /// Tests whether the set contains a given Span.\n+    fn contains(&self, span: Span) -> bool {\n+        self.iter().any(|root_span| root_span.contains(span))\n+    }\n+\n+    /// Add a span to the set if we know the span has no intersection in this set.\n+    fn push_nonintersecting(&mut self, new_span: Span) {\n+        self.root_spans.push(new_span);\n+    }\n+\n+    fn intersection_mut(&mut self, other: &Self) {\n+        if self.is_empty() || other.is_empty() {\n+            *self = Self::new();\n+            return;\n+        }\n+        // Those that were in `self` but not contained in `other`\n+        let mut leftover = SpanSet::new();\n+        // We keep the elements in `self` that are also in `other`.\n+        self.root_spans.retain(|span| {\n+            let retain = other.contains(*span);\n+            if !retain {\n+                leftover.root_spans.push(*span);\n+            }\n+            retain\n+        });\n+        // We keep the elements in `other` that are also in the original `self`. You might think\n+        // this is not needed because `self` already contains the intersection. But those aren't\n+        // just sets of things. If `self = [a]`, `other = [b]` and `a` contains `b`, then `b`\n+        // belongs in the intersection but we didn't catch it in the filtering above. We look at\n+        // `leftover` instead of the full original `self` to avoid duplicates.\n+        for span in other.iter() {\n+            if leftover.contains(span) {\n+                self.root_spans.push(span);\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx> {\n-    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n-    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n-    Useful(Vec<FxHashSet<Span>>),\n+    /// Pontentially carries a set of sub-branches that have been found to be unreachable. Used\n+    /// only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(SpanSet),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n@@ -640,7 +709,7 @@ impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful(vec![]),\n+            LeaveOutWitness => Useful(Default::default()),\n         }\n     }\n \n@@ -650,58 +719,55 @@ impl<'tcx> Usefulness<'tcx> {\n \n     /// When trying several branches and each returns a `Usefulness`, we need to combine the\n     /// results together.\n-    fn merge(usefulnesses: impl Iterator<Item = (Self, Span)>, column_count: usize) -> Self {\n-        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n-        // they were detected in columns that are not the current one, we want to keep only the\n-        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n-        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n-        // Therefore we don't want to lint that it is unreachable.\n-        //\n+    fn merge(usefulnesses: impl Iterator<Item = (Self, Span)>) -> Self {\n+        // If we have detected some unreachable sub-branches, we only want to keep them when they\n+        // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n+        // in the second branch of the first or-pattern, but not otherwise. Therefore we don't want\n+        // to lint that it is unreachable.\n         // ```\n         // match (true, true) {\n         //     (true, true) => {}\n         //     (false | true, false | true) => {}\n         // }\n         // ```\n-        // If however the sub-branches come from the current column, they come from the inside of\n-        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n-        // to lint that the last `false` is unreachable.\n+        // Here however we _do_ want to lint that the last `false` is unreachable. So we don't want\n+        // to intersect the spans that come directly from the or-pattern, since each branch of the\n+        // or-pattern brings a new disjoint pattern.\n         // ```\n         // match None {\n         //     Some(false) => {}\n         //     None | Some(true | false) => {}\n         // }\n         // ```\n \n-        // We keep track of sub-branches separately depending on whether they come from this column\n-        // or from others.\n-        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n-        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n-        // Whether at least one branch is reachable.\n-        let mut any_is_useful = false;\n+        // Is `None` when no branch was useful. Will often be `Some(Spanset::new())` because the\n+        // sets are only non-empty in the diagnostic path.\n+        let mut unreachables: Option<SpanSet> = None;\n+        // In case of or-patterns we don't want to intersect subpatterns that come from the first\n+        // column. Invariant: contains a list of disjoint spans.\n+        let mut unreachables_this_column = Vec::new();\n \n-        for (u, span) in usefulnesses {\n+        for (u, branch_span) in usefulnesses {\n             match u {\n-                Useful(unreachables) => {\n-                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n-                        // We keep the union of unreachables found in the first column.\n-                        unreachables_this_column.extend(this_column);\n-                        // We keep the intersection of unreachables found in other columns.\n-                        if unreachables_other_columns.is_empty() {\n-                            unreachables_other_columns = other_columns.to_vec();\n-                        } else {\n-                            unreachables_other_columns = unreachables_other_columns\n-                                .into_iter()\n-                                .zip(other_columns)\n-                                .map(|(x, y)| x.intersection(&y).copied().collect())\n-                                .collect();\n+                Useful(spans) if spans.is_empty() => {\n+                    // Hot path: `spans` is only non-empty in the diagnostic path.\n+                    unreachables = Some(SpanSet::new());\n+                }\n+                Useful(spans) => {\n+                    for span in spans.iter() {\n+                        if branch_span.contains(span) {\n+                            unreachables_this_column.push(span)\n                         }\n                     }\n-                    any_is_useful = true;\n-                }\n-                NotUseful => {\n-                    unreachables_this_column.insert(span);\n+                    if let Some(set) = &mut unreachables {\n+                        if !set.is_empty() {\n+                            set.intersection_mut(&spans);\n+                        }\n+                    } else {\n+                        unreachables = Some(spans);\n+                    }\n                 }\n+                NotUseful => unreachables_this_column.push(branch_span),\n                 UsefulWithWitness(_) => {\n                     bug!(\n                         \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n@@ -710,13 +776,13 @@ impl<'tcx> Usefulness<'tcx> {\n             }\n         }\n \n-        if any_is_useful {\n-            let mut unreachables = if unreachables_other_columns.is_empty() {\n-                (0..column_count - 1).map(|_| FxHashSet::default()).collect()\n-            } else {\n-                unreachables_other_columns\n-            };\n-            unreachables.push(unreachables_this_column);\n+        if let Some(mut unreachables) = unreachables {\n+            for span in unreachables_this_column {\n+                // `unreachables` contained no spans from the first column, and\n+                // `unreachables_this_column` contains only disjoint spans. Therefore it is valid\n+                // to call `push_nonintersecting`.\n+                unreachables.push_nonintersecting(span);\n+            }\n             Useful(unreachables)\n         } else {\n             NotUseful\n@@ -752,23 +818,6 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 UsefulWithWitness(new_witnesses)\n             }\n-            Useful(mut unreachables) => {\n-                if !unreachables.is_empty() {\n-                    // When we apply a constructor, there are `arity` columns of the matrix that\n-                    // corresponded to its arguments. All the unreachables found in these columns\n-                    // will, after `apply`, come from the first column. So we take the union of all\n-                    // the corresponding sets and put them in the first column.\n-                    // Note that `arity` may be 0, in which case we just push a new empty set.\n-                    let len = unreachables.len();\n-                    let arity = ctor_wild_subpatterns.len();\n-                    let mut unioned = FxHashSet::default();\n-                    for set in unreachables.drain((len - arity)..) {\n-                        unioned.extend(set)\n-                    }\n-                    unreachables.push(unioned);\n-                }\n-                Useful(unreachables)\n-            }\n             x => x,\n         }\n     }\n@@ -926,7 +975,7 @@ fn is_useful<'p, 'tcx>(\n             }\n             (u, span)\n         });\n-        Usefulness::merge(usefulnesses, v.len())\n+        Usefulness::merge(usefulnesses)\n     } else {\n         v.head_ctor(cx)\n             .split(pcx, Some(hir_id))"}, {"sha": "3e242a797a201b15b355cd19a525517efa8c9d1c", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a6365b77e171337d4f4220ebdc618965524ecd/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a6365b77e171337d4f4220ebdc618965524ecd/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=d7a6365b77e171337d4f4220ebdc618965524ecd", "patch": "@@ -81,7 +81,7 @@ fn main() {\n     match (true, None) {\n         (true, Some(_)) => {}\n         (false, Some(true)) => {}\n-        (true | false, None | Some(true // FIXME: should be unreachable\n+        (true | false, None | Some(true //~ ERROR unreachable\n                                    | false)) => {}\n     }\n     macro_rules! t_or_f {"}, {"sha": "ac0b34c2bd5414922ec8444d7685c86fcef06ca1", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7a6365b77e171337d4f4220ebdc618965524ecd/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7a6365b77e171337d4f4220ebdc618965524ecd/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=d7a6365b77e171337d4f4220ebdc618965524ecd", "patch": "@@ -106,6 +106,12 @@ error: unreachable pattern\n LL |         [true\n    |          ^^^^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:84:36\n+   |\n+LL |         (true | false, None | Some(true\n+   |                                    ^^^^\n+\n error: unreachable pattern\n   --> $DIR/exhaustiveness-unreachable-pattern.rs:100:14\n    |\n@@ -130,5 +136,5 @@ error: unreachable pattern\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 22 previous errors\n "}]}