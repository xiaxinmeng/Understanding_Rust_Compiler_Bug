{"sha": "ac6a77ed951b63aad0133469fb8914d121e156ce", "node_id": "C_kwDOAAsO6NoAKGFjNmE3N2VkOTUxYjYzYWFkMDEzMzQ2OWZiODkxNGQxMjFlMTU2Y2U", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-24T07:42:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-24T07:42:34Z"}, "message": "Rollup merge of #104742 - WaffleLapkin:forbidden-SUPER-deref, r=compiler-errors\n\nMake `deref_into_dyn_supertrait` lint the impl and not the usage\n\nProposed by ``@compiler-errors`` in https://github.com/rust-lang/rust/issues/89460#issuecomment-1320806785\nr? ``@crlf0710``", "tree": {"sha": "7719b4503cdaf32e329e1cbe45c86a6ee8821b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7719b4503cdaf32e329e1cbe45c86a6ee8821b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac6a77ed951b63aad0133469fb8914d121e156ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac6a77ed951b63aad0133469fb8914d121e156ce", "html_url": "https://github.com/rust-lang/rust/commit/ac6a77ed951b63aad0133469fb8914d121e156ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac6a77ed951b63aad0133469fb8914d121e156ce/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a530dce53b93ff8f880ffa3e90d5fc53668ba89", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a530dce53b93ff8f880ffa3e90d5fc53668ba89", "html_url": "https://github.com/rust-lang/rust/commit/2a530dce53b93ff8f880ffa3e90d5fc53668ba89"}, {"sha": "284ce9ed0d18b4582e1d377a501355fa685300fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/284ce9ed0d18b4582e1d377a501355fa685300fd", "html_url": "https://github.com/rust-lang/rust/commit/284ce9ed0d18b4582e1d377a501355fa685300fd"}], "stats": {"total": 54, "additions": 23, "deletions": 31}, "files": [{"sha": "b4210d875104bbe9f473fdbd430d67d28a45095c", "filename": "clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=ac6a77ed951b63aad0133469fb8914d121e156ce", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, implements_trait, is_copy};\n+use clippy_utils::ty::{implements_trait, is_copy};\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n@@ -25,7 +25,7 @@ pub(super) fn check<'tcx>(\n         && let Some(method_id) = typeck.type_dependent_def_id(cloned_call.hir_id)\n         && cx.tcx.trait_of_item(method_id) == Some(iter_id)\n         && let cloned_recv_ty = typeck.expr_ty_adjusted(cloned_recv)\n-        && let Some(iter_assoc_ty) = get_associated_type(cx, cloned_recv_ty, iter_id, \"Item\")\n+        && let Some(iter_assoc_ty) = cx.get_associated_type(cloned_recv_ty, iter_id, \"Item\")\n         && matches!(*iter_assoc_ty.kind(), ty::Ref(_, ty, _) if !is_copy(cx, ty))\n     {\n         if needs_into_iter"}, {"sha": "52a4ff7d1ae4f09aa23e2172f2a89e2bc26f894c", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=ac6a77ed951b63aad0133469fb8914d121e156ce", "patch": "@@ -2,7 +2,7 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait};\n use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, Expr, ExprKind};\n@@ -54,7 +54,7 @@ pub fn check_for_loop_iter(\n                 if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n                 let collection_ty = cx.typeck_results().expr_ty(collection);\n                 if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n-                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+                if let Some(into_iter_item_ty) = cx.get_associated_type(collection_ty, into_iterator_trait_id, \"Item\");\n \n                 if iter_item_ty == into_iter_item_ty;\n                 if let Some(collection_snippet) = snippet_opt(cx, collection.span);"}, {"sha": "8b000cd754cd1352f6ab5219336e659b91593a7a", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=ac6a77ed951b63aad0133469fb8914d121e156ce", "patch": "@@ -2,9 +2,11 @@ use super::implicit_clone::is_clone_like;\n use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n use clippy_utils::visitors::find_all_ret_expressions;\n-use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n+use clippy_utils::{\n+    fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty,\n+};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, Node};\n@@ -18,7 +20,9 @@ use rustc_middle::ty::EarlyBinder;\n use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n-use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use rustc_trait_selection::traits::{\n+    query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause,\n+};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -146,7 +150,7 @@ fn check_addr_of_expr(\n             if_chain! {\n                 if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n                 if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n-                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                if cx.get_associated_type(receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n                 then {\n                     if n_receiver_refs > 0 {\n                         span_lint_and_sugg(\n@@ -341,13 +345,13 @@ fn get_input_traits_and_projections<'tcx>(\n                 if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n-            },\n+            }\n             PredicateKind::Projection(projection_predicate) => {\n                 if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n     (trait_predicates, projection_predicates)\n@@ -462,7 +466,12 @@ fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id:\n \n /// Returns true if the named method can be used to convert the receiver to its \"owned\"\n /// representation.\n-fn is_to_owned_like<'a>(cx: &LateContext<'a>, call_expr: &Expr<'a>, method_name: Symbol, method_def_id: DefId) -> bool {\n+fn is_to_owned_like<'a>(\n+    cx: &LateContext<'a>,\n+    call_expr: &Expr<'a>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+) -> bool {\n     is_clone_like(cx, method_name.as_str(), method_def_id)\n         || is_cow_into_owned(cx, method_name, method_def_id)\n         || is_to_string_on_string_like(cx, call_expr, method_name, method_def_id)\n@@ -490,7 +499,7 @@ fn is_to_string_on_string_like<'a>(\n         && let GenericArgKind::Type(ty) = generic_arg.unpack()\n         && let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref)\n         && let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef)\n-        && (get_associated_type(cx, ty, deref_trait_id, \"Target\") == Some(cx.tcx.types.str_) ||\n+        && (cx.get_associated_type(ty, deref_trait_id, \"Target\") == Some(cx.tcx.types.str_) ||\n             implements_trait(cx, ty, as_ref_trait_id, &[cx.tcx.types.str_.into()])) {\n             true\n         } else {"}, {"sha": "8284dc5c28c0bd3684bde74b25d86d147af43c52", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac6a77ed951b63aad0133469fb8914d121e156ce/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=ac6a77ed951b63aad0133469fb8914d121e156ce", "patch": "@@ -117,24 +117,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n-}\n-\n-/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n-/// Do not invoke without first verifying that the type implements the trait.\n-pub fn get_associated_type<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    trait_id: DefId,\n-    name: &str,\n-) -> Option<Ty<'tcx>> {\n-    cx.tcx\n-        .associated_items(trait_id)\n-        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n-        .and_then(|assoc| {\n-            let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, []));\n-            cx.tcx.try_normalize_erasing_regions(cx.param_env, proj).ok()\n-        })\n+        .and_then(|iter_did| cx.get_associated_type(ty, iter_did, \"Item\"))\n }\n \n /// Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type"}]}