{"sha": "53642eed801d157613de0998cdcf0a3da8c36cb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNjQyZWVkODAxZDE1NzYxM2RlMDk5OGNkY2YwYTNkYThjMzZjYjM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-09T21:48:12Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-11T17:32:41Z"}, "message": "make walk/visit_mac opt-in only\n\nmacros can expand into arbitrary items, exprs, etc. This\nmeans that using a default walker or folder on an AST before\nmacro expansion is complete will miss things (the things that\nthe macros expand into). As a partial fence against this, this\ncommit moves the default traversal of macros into a separate\nprocedure, and makes the default trait implementation signal\nan error. This means that Folders and Visitors can traverse\nmacros if they want to, but they need to explicitly add an\nimpl that calls the walk_mac or fold_mac procedure\n\nThis should prevent problems down the road.", "tree": {"sha": "4d9232bac52072c177895e7de997b5ca00da98d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9232bac52072c177895e7de997b5ca00da98d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53642eed801d157613de0998cdcf0a3da8c36cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53642eed801d157613de0998cdcf0a3da8c36cb3", "html_url": "https://github.com/rust-lang/rust/commit/53642eed801d157613de0998cdcf0a3da8c36cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53642eed801d157613de0998cdcf0a3da8c36cb3/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ad425199b0d89dab275a8c8f6f29a73d316f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ad425199b0d89dab275a8c8f6f29a73d316f70", "html_url": "https://github.com/rust-lang/rust/commit/f1ad425199b0d89dab275a8c8f6f29a73d316f70"}], "stats": {"total": 85, "additions": 71, "deletions": 14}, "files": [{"sha": "0c39cf350a613c02b06e57deacc1f6ede7cfb872", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -14,6 +14,8 @@ use syntax::codemap;\n \n use std::gc::{Gc, GC};\n \n+/// A folder that strips out items that do not belong in the current\n+/// configuration.\n struct Context<'a> {\n     in_cfg: |attrs: &[ast::Attribute]|: 'a -> bool,\n }\n@@ -41,6 +43,9 @@ impl<'a> fold::Folder for Context<'a> {\n     fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n         fold_expr(self, expr)\n     }\n+    fn fold_mac(&mut self, mac: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(mac, self)\n+    }\n }\n \n pub fn strip_items(krate: ast::Crate,"}, {"sha": "499cffa42aac9f124913adb549a0c81175765ffc", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -72,6 +72,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate) -> Plugins {\n     loader.plugins\n }\n \n+// note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a> Visitor<()> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem, _: ()) {\n         match vi.node {\n@@ -109,6 +110,10 @@ impl<'a> Visitor<()> for PluginLoader<'a> {\n             _ => (),\n         }\n     }\n+    fn visit_mac(&mut self, _: &ast::Mac, _:()) {\n+        // bummer... can't see plugins inside macros.\n+        // do nothing.\n+    }\n }\n \n impl<'a> PluginLoader<'a> {"}, {"sha": "de2ecd9a2640488fcf3db7c4d6aa67423498448b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -112,6 +112,7 @@ pub enum Node {\n     NodeLifetime(Gc<Lifetime>),\n }\n \n+/// Represents an entry and its parent Node ID\n /// The odd layout is to bring down the total size.\n #[deriving(Clone)]\n enum MapEntry {\n@@ -184,6 +185,8 @@ impl MapEntry {\n     }\n }\n \n+/// Represents a mapping from Node IDs to AST elements and their parent\n+/// Node IDs\n pub struct Map {\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n@@ -430,6 +433,8 @@ pub trait FoldOps {\n     }\n }\n \n+/// A Folder that walks over an AST and constructs a Node ID Map. Its\n+/// fold_ops argument has the opportunity to replace Node IDs and spans.\n pub struct Ctx<'a, F> {\n     map: &'a Map,\n     /// The node in which we are currently mapping (an item or a method).\n@@ -584,6 +589,10 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n         self.insert(lifetime.id, EntryLifetime(self.parent, box(GC) lifetime));\n         lifetime\n     }\n+\n+    fn fold_mac(&mut self, mac: &Mac) -> Mac {\n+        fold::fold_mac(mac, self)\n+    }\n }\n \n pub fn map_crate<F: FoldOps>(krate: Crate, fold_ops: F) -> (Crate, Map) {"}, {"sha": "084faca02c5b147f298dd47ee48163bc054f811a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -753,7 +753,6 @@ impl Visitor<()> for PatIdentFinder {\n             _ => visit::walk_pat(self, pattern, ())\n         }\n     }\n-\n }\n \n /// find the PatIdent paths in a pattern\n@@ -902,6 +901,9 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n+    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(macro, self)\n+    }\n }\n \n /// A tree-folder that applies every rename in its list to\n@@ -931,6 +933,9 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n             _ => noop_fold_pat(pat, self)\n         }\n     }\n+    fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+        fold::fold_mac(macro, self)\n+    }\n }\n \n // expand a method"}, {"sha": "3e3b57be6e40650ff77c14ed99fc93d30aa37317", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A Folder represents an AST->AST fold; it accepts an AST piece,\n+//! and returns a piece of the same type. So, for instance, macro\n+//! expansion is a Folder that walks over an AST and produces another\n+//! AST.\n+//!\n+//! Note: using a Folder (other than the MacroExpander Folder) on\n+//! an AST before macro expansion is probably a bad idea. For instance,\n+//! a folder renaming item names in a module will miss all of those\n+//! that are created by the expansion of a macro.\n+\n use ast::*;\n use ast;\n use ast_util;\n@@ -299,17 +309,13 @@ pub trait Folder {\n         }\n     }\n \n-    fn fold_mac(&mut self, macro: &Mac) -> Mac {\n-        Spanned {\n-            node: match macro.node {\n-                MacInvocTT(ref p, ref tts, ctxt) => {\n-                    MacInvocTT(self.fold_path(p),\n-                               fold_tts(tts.as_slice(), self),\n-                               ctxt)\n-                }\n-            },\n-            span: self.new_span(macro.span)\n-        }\n+    fn fold_mac(&mut self, _macro: &Mac) -> Mac {\n+        fail!(\"fold_mac disabled by default\");\n+        // NB: see note about macros above.\n+        // if you really want a folder that\n+        // works on macros, use this\n+        // definition in your trait impl:\n+        // fold::fold_mac(_macro, self)\n     }\n \n     fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n@@ -361,6 +367,20 @@ pub trait Folder {\n \n }\n \n+\n+pub fn fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n+    Spanned {\n+        node: match macro.node {\n+            MacInvocTT(ref p, ref tts, ctxt) => {\n+                MacInvocTT(fld.fold_path(p),\n+                           fold_tts(tts.as_slice(), fld),\n+                           ctxt)\n+            }\n+        },\n+        span: fld.new_span(macro.span)\n+    }\n+}\n+\n /* some little folds that probably aren't useful to have in Folder itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n@@ -986,6 +1006,7 @@ mod test {\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use parse::token;\n     use print::pprust;\n+    use fold;\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n@@ -1001,6 +1022,9 @@ mod test {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n+        fn fold_mac(&mut self, macro: &ast::Mac) -> ast::Mac {\n+            fold::fold_mac(macro, self)\n+        }\n     }\n \n     // maybe add to expand.rs..."}, {"sha": "7caaf2f6cc1faccee1c1b98ab774e3b08ef17e1f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53642eed801d157613de0998cdcf0a3da8c36cb3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=53642eed801d157613de0998cdcf0a3da8c36cb3", "patch": "@@ -20,6 +20,10 @@\n //! execute before AST node B, then A is visited first.  The borrow checker in\n //! particular relies on this property.\n //!\n+//! Note: walking an AST before macro expansion is probably a bad idea. For\n+//! instance, a walker looking for item names in a module will miss all of\n+//! those that are created by the expansion of a macro.\n+\n use abi::Abi;\n use ast::*;\n use ast;\n@@ -124,8 +128,13 @@ pub trait Visitor<E: Clone> {\n     fn visit_explicit_self(&mut self, es: &ExplicitSelf, e: E) {\n         walk_explicit_self(self, es, e)\n     }\n-    fn visit_mac(&mut self, macro: &Mac, e: E) {\n-        walk_mac(self, macro, e)\n+    fn visit_mac(&mut self, _macro: &Mac, _e: E) {\n+        fail!(\"visit_mac disabled by default\");\n+        // NB: see note about macros above.\n+        // if you really want a visitor that\n+        // works on macros, use this\n+        // definition in your trait impl:\n+        // visit::walk_mac(self, _macro, _e)\n     }\n     fn visit_path(&mut self, path: &Path, _id: ast::NodeId, e: E) {\n         walk_path(self, path, e)"}]}