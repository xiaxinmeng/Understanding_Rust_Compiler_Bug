{"sha": "20de2ba7596322026501e1b5134c8724224b844e", "node_id": "C_kwDOAAsO6NoAKDIwZGUyYmE3NTk2MzIyMDI2NTAxZTFiNTEzNGM4NzI0MjI0Yjg0NGU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-24T00:49:48Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-24T02:33:35Z"}, "message": "Remove `{Pre,Post}InliningPartitioning`.\n\nI find that these structs obfuscate the code. Removing them and just\npassing the individual fields around makes the `Partition` method\nsignatures a little longer, but makes the data flow much clearer. E.g.\n\n- `codegen_units` is mutable all the way through.\n- `codegen_units`'s length is changed by `merge_codegen_units`, but only\n  the individual elements are changed by `place_inlined_mono_items` and\n  `internalize_symbols`.\n- `roots`, `internalization_candidates`, and `mono_item_placements` are\n  all immutable after creation, and all used by just one of the four\n  methods.", "tree": {"sha": "6eb896583a3ef422f01b1be207dc2b257412acc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb896583a3ef422f01b1be207dc2b257412acc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20de2ba7596322026501e1b5134c8724224b844e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20de2ba7596322026501e1b5134c8724224b844e", "html_url": "https://github.com/rust-lang/rust/commit/20de2ba7596322026501e1b5134c8724224b844e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20de2ba7596322026501e1b5134c8724224b844e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "html_url": "https://github.com/rust-lang/rust/commit/b39b7098eaaf5eb99e2f210ad98307ab310c1eee"}], "stats": {"total": 151, "additions": 64, "deletions": 87}, "files": [{"sha": "362e21eaecd0ab82984d04a3a8df55f288e17ab2", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/20de2ba7596322026501e1b5134c8724224b844e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20de2ba7596322026501e1b5134c8724224b844e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=20de2ba7596322026501e1b5134c8724224b844e", "patch": "@@ -15,9 +15,7 @@ use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::collector::InliningMap;\n-use crate::partitioning::{\n-    MonoItemPlacement, Partition, PostInliningPartitioning, PreInliningPartitioning,\n-};\n+use crate::partitioning::{MonoItemPlacement, Partition};\n \n pub struct DefaultPartitioning;\n \n@@ -26,7 +24,7 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> (Vec<CodegenUnit<'tcx>>, FxHashSet<MonoItem<'tcx>>, FxHashSet<MonoItem<'tcx>>)\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -91,20 +89,15 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n         }\n \n-        PreInliningPartitioning {\n-            codegen_units: codegen_units.into_values().collect(),\n-            roots,\n-            internalization_candidates,\n-        }\n+        (codegen_units.into_values().collect(), roots, internalization_candidates)\n     }\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n         assert!(cx.target_cgu_count >= 1);\n-        let codegen_units = &mut initial_partitioning.codegen_units;\n \n         // Note that at this point in time the `codegen_units` here may not be\n         // in a deterministic order (but we know they're deterministically the\n@@ -201,20 +194,14 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n-        let mut new_partitioning = Vec::new();\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         let mut mono_item_placements = FxHashMap::default();\n \n-        let PreInliningPartitioning {\n-            codegen_units: initial_cgus,\n-            roots,\n-            internalization_candidates,\n-        } = initial_partitioning;\n-\n-        let single_codegen_unit = initial_cgus.len() == 1;\n+        let single_codegen_unit = codegen_units.len() == 1;\n \n-        for old_codegen_unit in initial_cgus {\n+        for old_codegen_unit in codegen_units.iter_mut() {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n@@ -266,14 +253,10 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n                 }\n             }\n \n-            new_partitioning.push(new_codegen_unit);\n+            *old_codegen_unit = new_codegen_unit;\n         }\n \n-        return PostInliningPartitioning {\n-            codegen_units: new_partitioning,\n-            mono_item_placements,\n-            internalization_candidates,\n-        };\n+        return mono_item_placements;\n \n         fn follow_inlining<'tcx>(\n             mono_item: MonoItem<'tcx>,\n@@ -293,14 +276,16 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n-        if partitioning.codegen_units.len() == 1 {\n+        if codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n             // can internalize all candidates, since there is nowhere else they\n             // could be accessed from.\n-            for cgu in &mut partitioning.codegen_units {\n-                for candidate in &partitioning.internalization_candidates {\n+            for cgu in codegen_units {\n+                for candidate in &internalization_candidates {\n                     cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n                 }\n             }\n@@ -317,15 +302,13 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             }\n         });\n \n-        let mono_item_placements = &partitioning.mono_item_placements;\n-\n         // For each internalization candidates in each codegen unit, check if it is\n         // accessed from outside its defining codegen unit.\n-        for cgu in &mut partitioning.codegen_units {\n+        for cgu in codegen_units {\n             let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n \n             for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !partitioning.internalization_candidates.contains(accessee) {\n+                if !internalization_candidates.contains(accessee) {\n                     // This item is no candidate for internalizing, so skip it.\n                     continue;\n                 }"}, {"sha": "dd0a35c4402d37f159361839218eadf27b7986ca", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/20de2ba7596322026501e1b5134c8724224b844e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20de2ba7596322026501e1b5134c8724224b844e/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=20de2ba7596322026501e1b5134c8724224b844e", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> (Vec<CodegenUnit<'tcx>>, FxHashSet<MonoItem<'tcx>>, FxHashSet<MonoItem<'tcx>>)\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -141,24 +141,23 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.merge_codegen_units(cx, initial_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         match self {\n             Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n             }\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n@@ -167,12 +166,17 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        post_inlining_partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.internalize_symbols(cx, post_inlining_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n+                cx,\n+                codegen_units,\n+                mono_item_placements,\n+                internalization_candidates,\n+            ),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n@@ -189,26 +193,29 @@ trait Partition<'tcx> {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> (Vec<CodegenUnit<'tcx>>, FxHashSet<MonoItem<'tcx>>, FxHashSet<MonoItem<'tcx>>)\n     where\n         I: Iterator<Item = MonoItem<'tcx>>;\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx>;\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n \n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     );\n }\n \n@@ -240,52 +247,57 @@ where\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = {\n+    let (mut codegen_units, roots, internalization_candidates) = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n         partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n-    for cgu in &mut initial_partitioning.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &initial_partitioning.codegen_units);\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n-        debug_dump(tcx, \"POST MERGING\", &initial_partitioning.codegen_units);\n+        partitioner.merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n     // monomorphizations have to go into each codegen unit. These additional\n     // monomorphizations can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with `#[inline]`.\n-    let mut post_inlining = {\n+    let mono_item_placements = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n     };\n \n-    for cgu in &mut post_inlining.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING\", &post_inlining.codegen_units);\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(cx, &mut post_inlining);\n+        partitioner.internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n     }\n \n     let instrument_dead_code =\n         tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n \n     if instrument_dead_code {\n         assert!(\n-            post_inlining.codegen_units.len() > 0,\n+            codegen_units.len() > 0,\n             \"There must be at least one CGU that code coverage data can be generated in.\"\n         );\n \n@@ -296,7 +308,7 @@ where\n         // the object file (CGU) containing the dead function stubs is included\n         // in the final binary. This will probably require forcing these\n         // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = post_inlining.codegen_units.iter_mut().collect();\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n         cgus.sort_by_key(|cgu| cgu.size_estimate());\n \n         let dead_code_cgu =\n@@ -307,29 +319,17 @@ where\n             } else {\n                 // If there are no CGUs that have externally linked items,\n                 // then we just pick the first CGU as a fallback.\n-                &mut post_inlining.codegen_units[0]\n+                &mut codegen_units[0]\n             };\n         dead_code_cgu.make_code_coverage_dead_code_cgu();\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results.\n-    let PostInliningPartitioning {\n-        codegen_units: mut result,\n-        mono_item_placements: _,\n-        internalization_candidates: _,\n-    } = post_inlining;\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n-    result.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n \n-    debug_dump(tcx, \"FINAL\", &result);\n-\n-    result\n-}\n-\n-pub struct PreInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+    codegen_units\n }\n \n /// For symbol internalization, we need to know whether a symbol/mono-item is\n@@ -341,12 +341,6 @@ enum MonoItemPlacement {\n     MultipleCgus,\n }\n \n-struct PostInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n     let dump = move || {\n         use std::fmt::Write;"}]}