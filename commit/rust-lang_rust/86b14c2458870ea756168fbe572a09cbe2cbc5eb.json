{"sha": "86b14c2458870ea756168fbe572a09cbe2cbc5eb", "node_id": "C_kwDOAAsO6NoAKDg2YjE0YzI0NTg4NzBlYTc1NjE2OGZiZTU3MmEwOWNiZTJjYmM1ZWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T09:29:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T09:29:46Z"}, "message": "Auto merge of #14705 - HKalbasi:mir, r=lnicola\n\nFix some mir related bugs\n\nfix #14701\nfix #14704", "tree": {"sha": "ea7bc060f81277bba0dc8d96fb0eaafd643f7f8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7bc060f81277bba0dc8d96fb0eaafd643f7f8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86b14c2458870ea756168fbe572a09cbe2cbc5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86b14c2458870ea756168fbe572a09cbe2cbc5eb", "html_url": "https://github.com/rust-lang/rust/commit/86b14c2458870ea756168fbe572a09cbe2cbc5eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86b14c2458870ea756168fbe572a09cbe2cbc5eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "466b4ec547a17cef2a8710b7191af76ac60da99f", "url": "https://api.github.com/repos/rust-lang/rust/commits/466b4ec547a17cef2a8710b7191af76ac60da99f", "html_url": "https://github.com/rust-lang/rust/commit/466b4ec547a17cef2a8710b7191af76ac60da99f"}, {"sha": "38544f56ab284152cc84363b81b0653d39db2990", "url": "https://api.github.com/repos/rust-lang/rust/commits/38544f56ab284152cc84363b81b0653d39db2990", "html_url": "https://github.com/rust-lang/rust/commit/38544f56ab284152cc84363b81b0653d39db2990"}], "stats": {"total": 224, "additions": 164, "deletions": 60}, "files": [{"sha": "611031eb8c41b877e241690191dbf2e52c3953b0", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=86b14c2458870ea756168fbe572a09cbe2cbc5eb", "patch": "@@ -505,6 +505,7 @@ impl ExprCollector<'_> {\n                     .map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n \n                 let prev_is_lowering_generator = mem::take(&mut this.is_lowering_generator);\n+                let prev_try_block_label = this.current_try_block_label.take();\n \n                 let body = this.collect_expr_opt(e.body());\n \n@@ -520,11 +521,11 @@ impl ExprCollector<'_> {\n                 } else {\n                     ClosureKind::Closure\n                 };\n-                this.is_lowering_generator = prev_is_lowering_generator;\n                 let capture_by =\n                     if e.move_token().is_some() { CaptureBy::Value } else { CaptureBy::Ref };\n                 this.is_lowering_generator = prev_is_lowering_generator;\n                 this.current_binding_owner = prev_binding_owner;\n+                this.current_try_block_label = prev_try_block_label;\n                 this.body.exprs[result_expr_id] = Expr::Closure {\n                     args: args.into(),\n                     arg_types: arg_types.into(),"}, {"sha": "5a850f6d57054a0acc87751da5eab07fae1fe903", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=86b14c2458870ea756168fbe572a09cbe2cbc5eb", "patch": "@@ -97,8 +97,22 @@ fn bit_op() {\n     check_number(r#\"const GOAL: u8 = !0 & !(!0 >> 1)\"#, 128);\n     check_number(r#\"const GOAL: i8 = !0 & !(!0 >> 1)\"#, 0);\n     check_number(r#\"const GOAL: i8 = 1 << 7\"#, (1i8 << 7) as i128);\n-    // FIXME: report panic here\n-    check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n+    check_number(r#\"const GOAL: i8 = -1 << 2\"#, (-1i8 << 2) as i128);\n+    check_fail(r#\"const GOAL: i8 = 1 << 8\"#, |e| {\n+        e == ConstEvalError::MirEvalError(MirEvalError::Panic(\"Overflow in Shl\".to_string()))\n+    });\n+}\n+\n+#[test]\n+fn floating_point() {\n+    check_number(\n+        r#\"const GOAL: f64 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f64::to_le_bytes(10.5), true)),\n+    );\n+    check_number(\n+        r#\"const GOAL: f32 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f32::to_le_bytes(10.5), true)),\n+    );\n }\n \n #[test]"}, {"sha": "3ac208666a72617ae3343aa55475155d2555d191", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=86b14c2458870ea756168fbe572a09cbe2cbc5eb", "patch": "@@ -649,6 +649,20 @@ pub enum BinOp {\n     Offset,\n }\n \n+impl BinOp {\n+    fn run_compare<T: PartialEq + PartialOrd>(&self, l: T, r: T) -> bool {\n+        match self {\n+            BinOp::Ge => l >= r,\n+            BinOp::Gt => l > r,\n+            BinOp::Le => l <= r,\n+            BinOp::Lt => l < r,\n+            BinOp::Eq => l == r,\n+            BinOp::Ne => l != r,\n+            x => panic!(\"`run_compare` called on operator {x:?}\"),\n+        }\n+    }\n+}\n+\n impl Display for BinOp {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         f.write_str(match self {"}, {"sha": "7ff68774bc98fa2fc7bb5721fe6888a64c5b060e", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 114, "deletions": 57, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=86b14c2458870ea756168fbe572a09cbe2cbc5eb", "patch": "@@ -48,7 +48,7 @@ macro_rules! from_bytes {\n     ($ty:tt, $value:expr) => {\n         ($ty::from_le_bytes(match ($value).try_into() {\n             Ok(x) => x,\n-            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+            Err(_) => return Err(MirEvalError::TypeError(stringify!(mismatched size in constructing $ty))),\n         }))\n     };\n }\n@@ -797,70 +797,127 @@ impl Evaluator<'_> {\n                     lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n                     rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n                 }\n-                let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n-                let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n-                let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n-                match op {\n-                    BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n-                        let r = match op {\n-                            BinOp::Ge => l128 >= r128,\n-                            BinOp::Gt => l128 > r128,\n-                            BinOp::Le => l128 <= r128,\n-                            BinOp::Lt => l128 < r128,\n-                            BinOp::Eq => l128 == r128,\n-                            BinOp::Ne => l128 != r128,\n-                            _ => unreachable!(),\n-                        };\n-                        let r = r as u8;\n-                        Owned(vec![r])\n+                if let TyKind::Scalar(chalk_ir::Scalar::Float(f)) = ty.kind(Interner) {\n+                    match f {\n+                        chalk_ir::FloatTy::F32 => {\n+                            let l = from_bytes!(f32, lc);\n+                            let r = from_bytes!(f32, rc);\n+                            match op {\n+                                BinOp::Ge\n+                                | BinOp::Gt\n+                                | BinOp::Le\n+                                | BinOp::Lt\n+                                | BinOp::Eq\n+                                | BinOp::Ne => {\n+                                    let r = op.run_compare(l, r) as u8;\n+                                    Owned(vec![r])\n+                                }\n+                                BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {\n+                                    let r = match op {\n+                                        BinOp::Add => l + r,\n+                                        BinOp::Sub => l - r,\n+                                        BinOp::Mul => l * r,\n+                                        BinOp::Div => l / r,\n+                                        _ => unreachable!(),\n+                                    };\n+                                    Owned(r.to_le_bytes().into())\n+                                }\n+                                x => not_supported!(\n+                                    \"invalid binop {x:?} on floating point operators\"\n+                                ),\n+                            }\n+                        }\n+                        chalk_ir::FloatTy::F64 => {\n+                            let l = from_bytes!(f64, lc);\n+                            let r = from_bytes!(f64, rc);\n+                            match op {\n+                                BinOp::Ge\n+                                | BinOp::Gt\n+                                | BinOp::Le\n+                                | BinOp::Lt\n+                                | BinOp::Eq\n+                                | BinOp::Ne => {\n+                                    let r = op.run_compare(l, r) as u8;\n+                                    Owned(vec![r])\n+                                }\n+                                BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {\n+                                    let r = match op {\n+                                        BinOp::Add => l + r,\n+                                        BinOp::Sub => l - r,\n+                                        BinOp::Mul => l * r,\n+                                        BinOp::Div => l / r,\n+                                        _ => unreachable!(),\n+                                    };\n+                                    Owned(r.to_le_bytes().into())\n+                                }\n+                                x => not_supported!(\n+                                    \"invalid binop {x:?} on floating point operators\"\n+                                ),\n+                            }\n+                        }\n                     }\n-                    BinOp::BitAnd\n-                    | BinOp::BitOr\n-                    | BinOp::BitXor\n-                    | BinOp::Add\n-                    | BinOp::Mul\n-                    | BinOp::Div\n-                    | BinOp::Rem\n-                    | BinOp::Sub => {\n-                        let r = match op {\n-                            BinOp::Add => l128.overflowing_add(r128).0,\n-                            BinOp::Mul => l128.overflowing_mul(r128).0,\n-                            BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n-                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n-                            })?,\n-                            BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n-                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n-                            })?,\n-                            BinOp::Sub => l128.overflowing_sub(r128).0,\n-                            BinOp::BitAnd => l128 & r128,\n-                            BinOp::BitOr => l128 | r128,\n-                            BinOp::BitXor => l128 ^ r128,\n-                            _ => unreachable!(),\n-                        };\n+                } else {\n+                    let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n+                    let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n+                    let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n+                    let check_overflow = |r: i128| {\n+                        // FIXME: this is not very correct, and only catches the basic cases.\n                         let r = r.to_le_bytes();\n                         for &k in &r[lc.len()..] {\n                             if k != 0 && (k != 255 || !is_signed) {\n                                 return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n                             }\n                         }\n-                        Owned(r[0..lc.len()].into())\n-                    }\n-                    BinOp::Shl | BinOp::Shr => {\n-                        let shift_amount = if r128 < 0 {\n-                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n-                        } else if r128 > 128 {\n-                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n-                        } else {\n-                            r128 as u8\n-                        };\n-                        let r = match op {\n-                            BinOp::Shl => l128 << shift_amount,\n-                            BinOp::Shr => l128 >> shift_amount,\n-                            _ => unreachable!(),\n-                        };\n-                        Owned(r.to_le_bytes()[0..lc.len()].into())\n+                        Ok(Owned(r[0..lc.len()].into()))\n+                    };\n+                    match op {\n+                        BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n+                            let r = op.run_compare(l128, r128) as u8;\n+                            Owned(vec![r])\n+                        }\n+                        BinOp::BitAnd\n+                        | BinOp::BitOr\n+                        | BinOp::BitXor\n+                        | BinOp::Add\n+                        | BinOp::Mul\n+                        | BinOp::Div\n+                        | BinOp::Rem\n+                        | BinOp::Sub => {\n+                            let r = match op {\n+                                BinOp::Add => l128.overflowing_add(r128).0,\n+                                BinOp::Mul => l128.overflowing_mul(r128).0,\n+                                BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n+                                    MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                                })?,\n+                                BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n+                                    MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                                })?,\n+                                BinOp::Sub => l128.overflowing_sub(r128).0,\n+                                BinOp::BitAnd => l128 & r128,\n+                                BinOp::BitOr => l128 | r128,\n+                                BinOp::BitXor => l128 ^ r128,\n+                                _ => unreachable!(),\n+                            };\n+                            check_overflow(r)?\n+                        }\n+                        BinOp::Shl | BinOp::Shr => {\n+                            let r = 'b: {\n+                                if let Ok(shift_amount) = u32::try_from(r128) {\n+                                    let r = match op {\n+                                        BinOp::Shl => l128.checked_shl(shift_amount),\n+                                        BinOp::Shr => l128.checked_shr(shift_amount),\n+                                        _ => unreachable!(),\n+                                    };\n+                                    if let Some(r) = r {\n+                                        break 'b r;\n+                                    }\n+                                };\n+                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n+                            };\n+                            check_overflow(r)?\n+                        }\n+                        BinOp::Offset => not_supported!(\"offset binop\"),\n                     }\n-                    BinOp::Offset => not_supported!(\"offset binop\"),\n                 }\n             }\n             Rvalue::Discriminant(p) => {"}, {"sha": "7baa7b64268217c165d063aa7c0947a1ddcef2ad", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b14c2458870ea756168fbe572a09cbe2cbc5eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=86b14c2458870ea756168fbe572a09cbe2cbc5eb", "patch": "@@ -132,6 +132,24 @@ fn test() {\n      // ^^^^^^^ error: can't break with a value in this position\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_block_desugaring_inside_closure() {\n+        // regression test for #14701\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try\n+fn test() {\n+    try {\n+        || {\n+            let x = Some(2);\n+            Some(x?)\n+        };\n+    };\n+}\n \"#,\n         );\n     }"}]}