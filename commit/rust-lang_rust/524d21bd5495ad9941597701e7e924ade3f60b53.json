{"sha": "524d21bd5495ad9941597701e7e924ade3f60b53", "node_id": "C_kwDOAAsO6NoAKDUyNGQyMWJkNTQ5NWFkOTk0MTU5NzcwMWU3ZTkyNGFkZTNmNjBiNTM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-28T06:13:56Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-29T23:54:37Z"}, "message": "Overhaul how matches are recorded.\n\nCurrently, matches within a sequence are recorded in a new empty\n`matches` vector. Then when the sequence finishes the matches are merged\ninto the `matches` vector of the parent.\n\nThis commit changes things so that a sequence mp inherits the matches\nmade so far. This means that additional matches from the sequence don't\nneed to be merged into the parent. `push_match` becomes more\ncomplicated, and the current sequence depth needs to be tracked. But\nit's a sizeable performance win because it avoids one or more\n`push_match` calls on every iteration of a sequence.\n\nThe commit also removes `match_hi`, which is no longer necessary.", "tree": {"sha": "a1c50dfac7c6d4ad29df20a15acaa425b85c895c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1c50dfac7c6d4ad29df20a15acaa425b85c895c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/524d21bd5495ad9941597701e7e924ade3f60b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/524d21bd5495ad9941597701e7e924ade3f60b53", "html_url": "https://github.com/rust-lang/rust/commit/524d21bd5495ad9941597701e7e924ade3f60b53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/524d21bd5495ad9941597701e7e924ade3f60b53/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1b140cdb70e1bcdffa9e6671b17fd69ef80c4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b140cdb70e1bcdffa9e6671b17fd69ef80c4f6", "html_url": "https://github.com/rust-lang/rust/commit/a1b140cdb70e1bcdffa9e6671b17fd69ef80c4f6"}], "stats": {"total": 103, "additions": 55, "deletions": 48}, "files": [{"sha": "15eb1635e243e42adb79f50f33a3c7fb2948f827", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/524d21bd5495ad9941597701e7e924ade3f60b53/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/524d21bd5495ad9941597701e7e924ade3f60b53/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=524d21bd5495ad9941597701e7e924ade3f60b53", "patch": "@@ -125,33 +125,23 @@ struct MatcherPos<'tt> {\n     /// The \"dot\" position within the current submatcher, i.e. the index into `tts`.\n     idx: usize,\n \n-    /// This boxed slice has one element per metavar in the *top-level* matcher, even when this\n+    /// This vector ends up with one element per metavar in the *top-level* matcher, even when this\n     /// `MatcherPos` is for a submatcher. Each element records token trees matched against the\n-    /// relevant metavar by the black box parser.\n-    ///\n-    /// In a top-level `MatcherPos` each `NamedMatchVec` will have zero elements before processing\n-    /// and one element after processing; the one element will be a `MatchedSeq` if the\n+    /// relevant metavar by the black box parser. The element will be a `MatchedSeq` if the\n     /// corresponding metavar is within a sequence.\n-    ///\n-    /// In a sequence submatcher each `NamedMatchVec` will have zero elements before processing and\n-    /// any number of elements after processing (as allowed by the sequence's Kleene op, i.e.\n-    /// zero-or-one, zero-or-more, one-or-more). After processing these elements will be merged\n-    /// into the parent `MatcherPos`'s matches (within a `MatchedSeq`).\n-    matches: Box<[Lrc<NamedMatchVec>]>,\n+    matches: Lrc<NamedMatchVec>,\n+\n+    /// The number of sequences this mp is within.\n+    seq_depth: usize,\n \n     /// The position in `matches` of the first metavar in this (sub)matcher. Zero if there are\n     /// no metavars.\n     match_lo: usize,\n \n     /// The position in `matches` of the next metavar to be matched against the source token\n-    /// stream. `match_lo <= match_cur <= match_hi`. Should not be used if there are no metavars,\n-    /// i.e. `match_lo == match_hi`.\n+    /// stream. Should not be used if there are no metavars.\n     match_cur: usize,\n \n-    /// The position in `matches` one past the last metavar in this (sub)matcher. Equal to\n-    /// `match_lo` if there are not metavars.\n-    match_hi: usize,\n-\n     /// This field is only used if we are matching a sequence.\n     sequence: Option<MatcherPosSequence<'tt>>,\n \n@@ -162,50 +152,73 @@ struct MatcherPos<'tt> {\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_>, 112);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_>, 104);\n \n impl<'tt> MatcherPos<'tt> {\n-    fn empty_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n-        if len == 0 {\n-            vec![]\n-        } else {\n-            let empty_matches = Lrc::new(SmallVec::new());\n-            vec![empty_matches; len]\n-        }\n-        .into_boxed_slice()\n-    }\n-\n     fn top_level(matcher: &'tt [TokenTree]) -> Self {\n-        let match_idx_hi = count_metavar_decls(matcher);\n         MatcherPos {\n             tts: matcher,\n             idx: 0,\n-            matches: Self::empty_matches(match_idx_hi),\n+            matches: Lrc::new(smallvec![]),\n+            seq_depth: 0,\n             match_lo: 0,\n             match_cur: 0,\n-            match_hi: match_idx_hi,\n             stack: smallvec![],\n             sequence: None,\n         }\n     }\n \n     fn sequence(parent: Box<MatcherPos<'tt>>, seq: &'tt SequenceRepetition) -> Self {\n-        MatcherPos {\n+        let mut mp = MatcherPos {\n             tts: &seq.tts,\n             idx: 0,\n-            matches: Self::empty_matches(parent.matches.len()),\n+            matches: parent.matches.clone(),\n+            seq_depth: parent.seq_depth,\n             match_lo: parent.match_cur,\n             match_cur: parent.match_cur,\n-            match_hi: parent.match_cur + seq.num_captures,\n             sequence: Some(MatcherPosSequence { parent, seq }),\n             stack: smallvec![],\n+        };\n+        // Start with an empty vec for each metavar within the sequence. Note that `mp.seq_depth`\n+        // must have the parent's depth at this point for these `push_match` calls to work.\n+        for idx in mp.match_lo..mp.match_lo + seq.num_captures {\n+            mp.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n         }\n+        mp.seq_depth += 1;\n+        mp\n     }\n \n     /// Adds `m` as a named match for the `idx`-th metavar.\n     fn push_match(&mut self, idx: usize, m: NamedMatch) {\n-        let matches = Lrc::make_mut(&mut self.matches[idx]);\n-        matches.push(m);\n+        let matches = Lrc::make_mut(&mut self.matches);\n+        match self.seq_depth {\n+            0 => {\n+                // We are not within a sequence. Just append `m`.\n+                assert_eq!(idx, matches.len());\n+                matches.push(m);\n+            }\n+            _ => {\n+                // We are within a sequence. Find the final `MatchedSeq` at the appropriate depth\n+                // and append `m` to its vector.\n+                let mut curr = &mut matches[idx];\n+                for _ in 0..self.seq_depth - 1 {\n+                    match curr {\n+                        MatchedSeq(seq) => {\n+                            let seq = Lrc::make_mut(seq);\n+                            curr = seq.last_mut().unwrap();\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                match curr {\n+                    MatchedSeq(seq) => {\n+                        let seq = Lrc::make_mut(seq);\n+                        seq.push(m);\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -528,11 +541,8 @@ impl<'tt> TtParser<'tt> {\n                     // sequence in `parent`. This allows for the case where the sequence matching\n                     // is finished.\n                     let mut new_mp = sequence.parent.clone();\n-                    for idx in mp.match_lo..mp.match_hi {\n-                        let sub = mp.matches[idx].clone();\n-                        new_mp.push_match(idx, MatchedSeq(sub));\n-                    }\n-                    new_mp.match_cur = mp.match_hi;\n+                    new_mp.matches = mp.matches.clone();\n+                    new_mp.match_cur = mp.match_lo + sequence.seq.num_captures;\n                     new_mp.idx += 1;\n                     self.cur_mps.push(new_mp);\n                 }\n@@ -577,13 +587,10 @@ impl<'tt> TtParser<'tt> {\n         if *token == token::Eof {\n             Some(match eof_mps {\n                 EofMatcherPositions::One(mut eof_mp) => {\n-                    let matches = eof_mp.matches.iter_mut().map(|dv| {\n-                        // Top-level metavars only ever get one match. (Sub-matchers can get\n-                        // multiple matches, which get aggregated into a `MatcherSeq` before being\n-                        // put into the top-level.)\n-                        debug_assert_eq!(dv.len(), 1);\n-                        Lrc::make_mut(dv).pop().unwrap()\n-                    });\n+                    assert_eq!(eof_mp.matches.len(), count_metavar_decls(matcher));\n+                    // Need to take ownership of the matches from within the `Lrc`.\n+                    Lrc::make_mut(&mut eof_mp.matches);\n+                    let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n                     nameize(sess, matcher, matches)\n                 }\n                 EofMatcherPositions::Multiple => {"}]}