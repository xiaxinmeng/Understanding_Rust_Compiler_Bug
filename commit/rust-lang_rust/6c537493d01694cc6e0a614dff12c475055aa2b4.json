{"sha": "6c537493d01694cc6e0a614dff12c475055aa2b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTM3NDkzZDAxNjk0Y2M2ZTBhNjE0ZGZmMTJjNDc1MDU1YWEyYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T16:22:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T16:22:36Z"}, "message": "Auto merge of #49558 - Zoxc:sync-misc, r=michaelwoerister\n\nEven more thread-safety changes\n\nr? @michaelwoerister", "tree": {"sha": "d656ca53d1f26ce7bdd653864a65cf2d83157f35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d656ca53d1f26ce7bdd653864a65cf2d83157f35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c537493d01694cc6e0a614dff12c475055aa2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c537493d01694cc6e0a614dff12c475055aa2b4", "html_url": "https://github.com/rust-lang/rust/commit/6c537493d01694cc6e0a614dff12c475055aa2b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c537493d01694cc6e0a614dff12c475055aa2b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9afed646451175e24964cc76688293cb87ed718c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9afed646451175e24964cc76688293cb87ed718c", "html_url": "https://github.com/rust-lang/rust/commit/9afed646451175e24964cc76688293cb87ed718c"}, {"sha": "006f9b2f5616ad970cb0f5102ec50e02ef2dd379", "url": "https://api.github.com/repos/rust-lang/rust/commits/006f9b2f5616ad970cb0f5102ec50e02ef2dd379", "html_url": "https://github.com/rust-lang/rust/commit/006f9b2f5616ad970cb0f5102ec50e02ef2dd379"}], "stats": {"total": 710, "additions": 425, "deletions": 285}, "files": [{"sha": "663ac5b04f57c5354894892fd214e088b3e052b3", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -632,6 +632,7 @@ define_dep_nodes!( <'tcx>\n     [input] MaybeUnusedTraitImport(DefId),\n     [input] MaybeUnusedExternCrates,\n     [eval_always] StabilityIndex,\n+    [eval_always] AllTraits,\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n     [eval_always] CollectAndPartitionTranslationItems,"}, {"sha": "8ea6eb005a140b0eb105e7fbbc839074fccd2837", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -36,13 +36,13 @@ use rustc_data_structures::indexed_vec::Idx;\n use serialize::UseSpecializedDecodable;\n use std::fmt::Debug;\n use std::ops::Index;\n+use std::sync::atomic::Ordering;\n use syntax::codemap::Span;\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n use ty::subst::{Kind, UnpackedKind};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::captures::Captures;\n-use util::common::CellUsizeExt;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n@@ -473,7 +473,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         V: Canonicalize<'gcx, 'tcx>,\n     {\n-        self.tcx.sess.perf_stats.queries_canonicalized.increment();\n+        self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n \n         Canonicalizer::canonicalize(\n             value,"}, {"sha": "a0cd231bb704d6600e39afca83c86d1347d7e53e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -408,7 +408,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // Seed entry point\n-    if let Some((id, _)) = *tcx.sess.entry_fn.borrow() {\n+    if let Some((id, _, _)) = *tcx.sess.entry_fn.borrow() {\n         worklist.push(id);\n     }\n "}, {"sha": "e7fc8d633c82f8f1909c0847cfa2f3e89e8b1f65", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -94,13 +94,14 @@ pub enum Linkage {\n \n pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let sess = &tcx.sess;\n-    let mut fmts = sess.dependency_formats.borrow_mut();\n+    let mut fmts = FxHashMap();\n     for &ty in sess.crate_types.borrow().iter() {\n         let linkage = calculate_type(tcx, ty);\n         verify_ok(tcx, &linkage);\n         fmts.insert(ty, linkage);\n     }\n     sess.abort_if_errors();\n+    sess.dependency_formats.set(fmts);\n }\n \n fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -222,7 +223,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n-    activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n \n@@ -301,7 +302,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // Our allocator/panic runtime may not have been linked above if it wasn't\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n-    activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n     activate_injected_allocator(sess, &mut ret);\n "}, {"sha": "ebc796466629c23b5e5a05843311608ea8973989", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -63,12 +63,13 @@ pub fn find_entry_point(session: &Session,\n     });\n     if !any_exe {\n         // No need to find a main function\n+        session.entry_fn.set(None);\n         return\n     }\n \n     // If the user wants no main function at all, then stop here.\n     if attr::contains_name(&hir_map.krate().attrs, \"no_main\") {\n-        session.entry_type.set(Some(config::EntryNone));\n+        session.entry_fn.set(None);\n         return\n     }\n \n@@ -153,17 +154,15 @@ fn find_item(item: &Item, ctxt: &mut EntryContext, at_root: bool) {\n }\n \n fn configure_main(this: &mut EntryContext, crate_name: &str) {\n-    if this.start_fn.is_some() {\n-        *this.session.entry_fn.borrow_mut() = this.start_fn;\n-        this.session.entry_type.set(Some(config::EntryStart));\n-    } else if this.attr_main_fn.is_some() {\n-        *this.session.entry_fn.borrow_mut() = this.attr_main_fn;\n-        this.session.entry_type.set(Some(config::EntryMain));\n-    } else if this.main_fn.is_some() {\n-        *this.session.entry_fn.borrow_mut() = this.main_fn;\n-        this.session.entry_type.set(Some(config::EntryMain));\n+    if let Some((node_id, span)) = this.start_fn {\n+        this.session.entry_fn.set(Some((node_id, span, config::EntryStart)));\n+    } else if let Some((node_id, span)) = this.attr_main_fn {\n+        this.session.entry_fn.set(Some((node_id, span, config::EntryMain)));\n+    } else if let Some((node_id, span)) = this.main_fn {\n+        this.session.entry_fn.set(Some((node_id, span, config::EntryMain)));\n     } else {\n         // No main function\n+        this.session.entry_fn.set(None);\n         let mut err = struct_err!(this.session, E0601,\n             \"`main` function not found in crate `{}`\", crate_name);\n         if !this.non_main_fns.is_empty() {"}, {"sha": "077a20315a2afbea668a2327557062740e2a5d2b", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -18,17 +18,17 @@\n use session::Session;\n use syntax::ast;\n \n-use std::cell::Cell;\n+use rustc_data_structures::sync::Once;\n \n pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n     update_limit(sess, krate, &sess.recursion_limit, \"recursion_limit\",\n-                 \"recursion limit\");\n+                 \"recursion limit\", 64);\n     update_limit(sess, krate, &sess.type_length_limit, \"type_length_limit\",\n-                 \"type length limit\");\n+                 \"type length limit\", 1048576);\n }\n \n-fn update_limit(sess: &Session, krate: &ast::Crate, limit: &Cell<usize>,\n-                name: &str, description: &str) {\n+fn update_limit(sess: &Session, krate: &ast::Crate, limit: &Once<usize>,\n+                name: &str, description: &str, default: usize) {\n     for attr in &krate.attrs {\n         if !attr.check_name(name) {\n             continue;\n@@ -45,4 +45,5 @@ fn update_limit(sess: &Session, krate: &ast::Crate, limit: &Cell<usize>,\n                   \"malformed {} attribute, expected #![{}=\\\"N\\\"]\",\n                   description, name);\n     }\n+    limit.set(default);\n }"}, {"sha": "8b6a8fea4cabb1dd10bcd865b6104a2ad77a5b4c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -614,13 +614,11 @@ impl Options {\n \n // The type of entry function, so\n // users can have their own entry\n-// functions that don't start a\n-// scheduler\n+// functions\n #[derive(Copy, Clone, PartialEq)]\n pub enum EntryFnType {\n     EntryMain,\n     EntryStart,\n-    EntryNone,\n }\n \n #[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug)]\n@@ -1861,6 +1859,13 @@ pub fn build_session_options_and_crate_config(\n         );\n     }\n \n+    if debugging_opts.query_threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n+        early_error(\n+            error_format,\n+            \"Optimization fuel is incompatible with multiple query threads\",\n+        );\n+    }\n+\n     if codegen_units == Some(0) {\n         early_error(\n             error_format,"}, {"sha": "8f2043fdfc643bb15220e7f70509f635fee56f10", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 81, "deletions": 129, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -22,11 +22,11 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::{DebugInfoLevel, OutputType};\n use ty::tls;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use util::nodemap::{FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n \n-use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sync::{Lrc, Lock, LockCell, OneThread, Once};\n \n use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder, DiagnosticId};\n@@ -46,15 +46,16 @@ use rustc_back::target::{Target, TargetTriple};\n use rustc_data_structures::flock;\n use jobserver::Client;\n \n+use std;\n use std::cell::{self, Cell, RefCell};\n use std::collections::HashMap;\n use std::env;\n use std::fmt;\n use std::io::Write;\n use std::path::{Path, PathBuf};\n-use std::sync::{Once, ONCE_INIT};\n use std::time::Duration;\n use std::sync::mpsc;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n mod code_stats;\n pub mod config;\n@@ -69,61 +70,64 @@ pub struct Session {\n     pub opts: config::Options,\n     pub parse_sess: ParseSess,\n     /// For a library crate, this is always none\n-    pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n-    pub entry_type: Cell<Option<config::EntryFnType>>,\n-    pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n-    pub derive_registrar_fn: Cell<Option<ast::NodeId>>,\n+    pub entry_fn: Once<Option<(NodeId, Span, config::EntryFnType)>>,\n+    pub plugin_registrar_fn: Once<Option<ast::NodeId>>,\n+    pub derive_registrar_fn: Once<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n     /// The name of the root source file of the crate, in the local file system.\n     /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<PathBuf>,\n     /// The directory the compiler has been executed in plus a flag indicating\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n-    pub lint_store: RefCell<lint::LintStore>,\n-    pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n+\n+    // FIXME: lint_store and buffered_lints are not thread-safe,\n+    // but are only used in a single thread\n+    pub lint_store: OneThread<RefCell<lint::LintStore>>,\n+    pub buffered_lints: OneThread<RefCell<Option<lint::LintBuffer>>>,\n+\n     /// Set of (DiagnosticId, Option<Span>, message) tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: RefCell<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n-    pub plugin_llvm_passes: RefCell<Vec<String>>,\n-    pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n-    pub crate_types: RefCell<Vec<config::CrateType>>,\n-    pub dependency_formats: RefCell<dependency_format::Dependencies>,\n+    pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n+    pub plugin_attributes: OneThread<RefCell<Vec<(String, AttributeType)>>>,\n+    pub crate_types: Once<Vec<config::CrateType>>,\n+    pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n     /// trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: RefCell<Option<CrateDisambiguator>>,\n+    pub crate_disambiguator: Once<CrateDisambiguator>,\n \n-    features: RefCell<Option<feature_gate::Features>>,\n+    features: Once<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n-    pub recursion_limit: Cell<usize>,\n+    pub recursion_limit: Once<usize>,\n \n     /// The maximum length of types during monomorphization.\n-    pub type_length_limit: Cell<usize>,\n+    pub type_length_limit: Once<usize>,\n \n     /// The maximum number of stackframes allowed in const eval\n-    pub const_eval_stack_frame_limit: Cell<usize>,\n+    pub const_eval_stack_frame_limit: usize,\n     /// The maximum number miri steps per constant\n-    pub const_eval_step_limit: Cell<usize>,\n+    pub const_eval_step_limit: usize,\n \n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n-    pub injected_allocator: Cell<Option<CrateNum>>,\n-    pub allocator_kind: Cell<Option<AllocatorKind>>,\n-    pub injected_panic_runtime: Cell<Option<CrateNum>>,\n+    pub injected_allocator: Once<Option<CrateNum>>,\n+    pub allocator_kind: Once<Option<AllocatorKind>>,\n+    pub injected_panic_runtime: Once<Option<CrateNum>>,\n \n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n     /// macro name and definition span in the source crate.\n-    pub imported_macro_spans: RefCell<HashMap<Span, (String, Span)>>,\n+    pub imported_macro_spans: OneThread<RefCell<HashMap<Span, (String, Span)>>>,\n \n-    incr_comp_session: RefCell<IncrCompSession>,\n+    incr_comp_session: OneThread<RefCell<IncrCompSession>>,\n \n     /// A cache of attributes ignored by StableHashingContext\n     pub ignored_attr_names: FxHashSet<Symbol>,\n@@ -135,53 +139,42 @@ pub struct Session {\n     pub perf_stats: PerfStats,\n \n     /// Data about code being compiled, gathered during compilation.\n-    pub code_stats: RefCell<CodeStats>,\n+    pub code_stats: Lock<CodeStats>,\n \n-    next_node_id: Cell<ast::NodeId>,\n+    next_node_id: OneThread<Cell<ast::NodeId>>,\n \n     /// If -zfuel=crate=n is specified, Some(crate).\n     optimization_fuel_crate: Option<String>,\n     /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n-    optimization_fuel_limit: Cell<u64>,\n+    optimization_fuel_limit: LockCell<u64>,\n     /// We're rejecting all further optimizations.\n-    out_of_fuel: Cell<bool>,\n+    out_of_fuel: LockCell<bool>,\n \n     // The next two are public because the driver needs to read them.\n     /// If -zprint-fuel=crate, Some(crate).\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n-    pub print_fuel: Cell<u64>,\n+    pub print_fuel: LockCell<u64>,\n \n     /// Loaded up early on in the initialization of this `Session` to avoid\n     /// false positives about a job server in our environment.\n     pub jobserver_from_env: Option<Client>,\n \n     /// Metadata about the allocators for the current crate being compiled\n-    pub has_global_allocator: Cell<bool>,\n+    pub has_global_allocator: Once<bool>,\n }\n \n pub struct PerfStats {\n-    /// The accumulated time needed for computing the SVH of the crate\n-    pub svh_time: Cell<Duration>,\n-    /// The accumulated time spent on computing incr. comp. hashes\n-    pub incr_comp_hashes_time: Cell<Duration>,\n-    /// The number of incr. comp. hash computations performed\n-    pub incr_comp_hashes_count: Cell<u64>,\n-    /// The number of bytes hashed when computing ICH values\n-    pub incr_comp_bytes_hashed: Cell<u64>,\n     /// The accumulated time spent on computing symbol hashes\n-    pub symbol_hash_time: Cell<Duration>,\n+    pub symbol_hash_time: Lock<Duration>,\n     /// The accumulated time spent decoding def path tables from metadata\n-    pub decode_def_path_tables_time: Cell<Duration>,\n+    pub decode_def_path_tables_time: Lock<Duration>,\n     /// Total number of values canonicalized queries constructed.\n-    pub queries_canonicalized: Cell<usize>,\n-    /// Number of times we canonicalized a value and found that the\n-    /// result had already been canonicalized.\n-    pub canonicalized_values_allocated: Cell<usize>,\n+    pub queries_canonicalized: AtomicUsize,\n     /// Number of times this query is invoked.\n-    pub normalize_ty_after_erasing_regions: Cell<usize>,\n+    pub normalize_ty_after_erasing_regions: AtomicUsize,\n     /// Number of times this query is invoked.\n-    pub normalize_projection_ty: Cell<usize>,\n+    pub normalize_projection_ty: AtomicUsize,\n }\n \n /// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n@@ -209,10 +202,7 @@ impl From<&'static lint::Lint> for DiagnosticMessageId {\n \n impl Session {\n     pub fn local_crate_disambiguator(&self) -> CrateDisambiguator {\n-        match *self.crate_disambiguator.borrow() {\n-            Some(value) => value,\n-            None => bug!(\"accessing disambiguator before initialization\"),\n-        }\n+        *self.crate_disambiguator.get()\n     }\n \n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(\n@@ -539,18 +529,12 @@ impl Session {\n     /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n     /// dependency tracking. Use tcx.features() instead.\n     #[inline]\n-    pub fn features_untracked(&self) -> cell::Ref<feature_gate::Features> {\n-        let features = self.features.borrow();\n-\n-        if features.is_none() {\n-            bug!(\"Access to Session::features before it is initialized\");\n-        }\n-\n-        cell::Ref::map(features, |r| r.as_ref().unwrap())\n+    pub fn features_untracked(&self) -> &feature_gate::Features {\n+        self.features.get()\n     }\n \n     pub fn init_features(&self, features: feature_gate::Features) {\n-        *(self.features.borrow_mut()) = Some(features);\n+        self.features.set(features);\n     }\n \n     /// Calculates the flavor of LTO to use for this compilation.\n@@ -834,52 +818,26 @@ impl Session {\n     }\n \n     pub fn print_perf_stats(&self) {\n-        println!(\n-            \"Total time spent computing SVHs:               {}\",\n-            duration_to_secs_str(self.perf_stats.svh_time.get())\n-        );\n-        println!(\n-            \"Total time spent computing incr. comp. hashes: {}\",\n-            duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get())\n-        );\n-        println!(\n-            \"Total number of incr. comp. hashes computed:   {}\",\n-            self.perf_stats.incr_comp_hashes_count.get()\n-        );\n-        println!(\n-            \"Total number of bytes hashed for incr. comp.:  {}\",\n-            self.perf_stats.incr_comp_bytes_hashed.get()\n-        );\n-        if self.perf_stats.incr_comp_hashes_count.get() != 0 {\n-            println!(\n-                \"Average bytes hashed per incr. comp. HIR node: {}\",\n-                self.perf_stats.incr_comp_bytes_hashed.get()\n-                    / self.perf_stats.incr_comp_hashes_count.get()\n-            );\n-        } else {\n-            println!(\"Average bytes hashed per incr. comp. HIR node: N/A\");\n-        }\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n-            duration_to_secs_str(self.perf_stats.symbol_hash_time.get())\n+            duration_to_secs_str(*self.perf_stats.symbol_hash_time.lock())\n         );\n         println!(\n             \"Total time spent decoding DefPath tables:      {}\",\n-            duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get())\n+            duration_to_secs_str(*self.perf_stats.decode_def_path_tables_time.lock())\n         );\n         println!(\"Total queries canonicalized:                   {}\",\n-                 self.perf_stats.queries_canonicalized.get());\n-        println!(\"Total canonical values interned:               {}\",\n-                 self.perf_stats.canonicalized_values_allocated.get());\n+                 self.perf_stats.queries_canonicalized.load(Ordering::Relaxed));\n         println!(\"normalize_ty_after_erasing_regions:            {}\",\n-                 self.perf_stats.normalize_ty_after_erasing_regions.get());\n+                 self.perf_stats.normalize_ty_after_erasing_regions.load(Ordering::Relaxed));\n         println!(\"normalize_projection_ty:                       {}\",\n-                 self.perf_stats.normalize_projection_ty.get());\n+                 self.perf_stats.normalize_projection_ty.load(Ordering::Relaxed));\n     }\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n     /// This expends fuel if applicable, and records fuel if applicable.\n     pub fn consider_optimizing<T: Fn() -> String>(&self, crate_name: &str, msg: T) -> bool {\n+        assert!(self.query_threads() == 1);\n         let mut ret = true;\n         match self.optimization_fuel_crate {\n             Some(ref c) if c == crate_name => {\n@@ -1109,9 +1067,9 @@ pub fn build_session_(\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n     let optimization_fuel_limit =\n-        Cell::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n+        LockCell::new(sopts.debugging_opts.fuel.as_ref().map(|i| i.1).unwrap_or(0));\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n-    let print_fuel = Cell::new(0);\n+    let print_fuel = LockCell::new(0);\n \n     let working_dir = match env::current_dir() {\n         Ok(dir) => dir,\n@@ -1127,52 +1085,46 @@ pub fn build_session_(\n         opts: sopts,\n         parse_sess: p_s,\n         // For a library crate, this is always none\n-        entry_fn: RefCell::new(None),\n-        entry_type: Cell::new(None),\n-        plugin_registrar_fn: Cell::new(None),\n-        derive_registrar_fn: Cell::new(None),\n+        entry_fn: Once::new(),\n+        plugin_registrar_fn: Once::new(),\n+        derive_registrar_fn: Once::new(),\n         default_sysroot,\n         local_crate_source_file,\n         working_dir,\n-        lint_store: RefCell::new(lint::LintStore::new()),\n-        buffered_lints: RefCell::new(Some(lint::LintBuffer::new())),\n+        lint_store: OneThread::new(RefCell::new(lint::LintStore::new())),\n+        buffered_lints: OneThread::new(RefCell::new(Some(lint::LintBuffer::new()))),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n-        plugin_llvm_passes: RefCell::new(Vec::new()),\n-        plugin_attributes: RefCell::new(Vec::new()),\n-        crate_types: RefCell::new(Vec::new()),\n-        dependency_formats: RefCell::new(FxHashMap()),\n-        crate_disambiguator: RefCell::new(None),\n-        features: RefCell::new(None),\n-        recursion_limit: Cell::new(64),\n-        type_length_limit: Cell::new(1048576),\n-        const_eval_stack_frame_limit: Cell::new(100),\n-        const_eval_step_limit: Cell::new(1_000_000),\n-        next_node_id: Cell::new(NodeId::new(1)),\n-        injected_allocator: Cell::new(None),\n-        allocator_kind: Cell::new(None),\n-        injected_panic_runtime: Cell::new(None),\n-        imported_macro_spans: RefCell::new(HashMap::new()),\n-        incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n+        plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n+        plugin_attributes: OneThread::new(RefCell::new(Vec::new())),\n+        crate_types: Once::new(),\n+        dependency_formats: Once::new(),\n+        crate_disambiguator: Once::new(),\n+        features: Once::new(),\n+        recursion_limit: Once::new(),\n+        type_length_limit: Once::new(),\n+        const_eval_stack_frame_limit: 100,\n+        const_eval_step_limit: 1_000_000,\n+        next_node_id: OneThread::new(Cell::new(NodeId::new(1))),\n+        injected_allocator: Once::new(),\n+        allocator_kind: Once::new(),\n+        injected_panic_runtime: Once::new(),\n+        imported_macro_spans: OneThread::new(RefCell::new(HashMap::new())),\n+        incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         ignored_attr_names: ich::compute_ignored_attr_names(),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n-            svh_time: Cell::new(Duration::from_secs(0)),\n-            incr_comp_hashes_time: Cell::new(Duration::from_secs(0)),\n-            incr_comp_hashes_count: Cell::new(0),\n-            incr_comp_bytes_hashed: Cell::new(0),\n-            symbol_hash_time: Cell::new(Duration::from_secs(0)),\n-            decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n-            queries_canonicalized: Cell::new(0),\n-            canonicalized_values_allocated: Cell::new(0),\n-            normalize_ty_after_erasing_regions: Cell::new(0),\n-            normalize_projection_ty: Cell::new(0),\n+            symbol_hash_time: Lock::new(Duration::from_secs(0)),\n+            decode_def_path_tables_time: Lock::new(Duration::from_secs(0)),\n+            queries_canonicalized: AtomicUsize::new(0),\n+            normalize_ty_after_erasing_regions: AtomicUsize::new(0),\n+            normalize_projection_ty: AtomicUsize::new(0),\n         },\n-        code_stats: RefCell::new(CodeStats::new()),\n+        code_stats: Lock::new(CodeStats::new()),\n         optimization_fuel_crate,\n         optimization_fuel_limit,\n         print_fuel_crate,\n         print_fuel,\n-        out_of_fuel: Cell::new(false),\n+        out_of_fuel: LockCell::new(false),\n         // Note that this is unsafe because it may misinterpret file descriptors\n         // on Unix as jobserver file descriptors. We hopefully execute this near\n         // the beginning of the process though to ensure we don't get false\n@@ -1184,13 +1136,13 @@ pub fn build_session_(\n         // per-process.\n         jobserver_from_env: unsafe {\n             static mut GLOBAL_JOBSERVER: *mut Option<Client> = 0 as *mut _;\n-            static INIT: Once = ONCE_INIT;\n+            static INIT: std::sync::Once = std::sync::ONCE_INIT;\n             INIT.call_once(|| {\n                 GLOBAL_JOBSERVER = Box::into_raw(Box::new(Client::from_env()));\n             });\n             (*GLOBAL_JOBSERVER).clone()\n         },\n-        has_global_allocator: Cell::new(false),\n+        has_global_allocator: Once::new(),\n     };\n \n     sess"}, {"sha": "9f21ea14d0f326bbf30e87e676df094d3a6e94ae", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                     Reveal::UserFacing => ty,\n \n                     Reveal::All => {\n-                        let recursion_limit = self.tcx().sess.recursion_limit.get();\n+                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n                         if self.depth >= recursion_limit {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),\n@@ -566,7 +566,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     found cache entry: in-progress\");\n \n             // But for now, let's classify this as an overflow:\n-            let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+            let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n             let obligation = Obligation::with_depth(cause.clone(),\n                                                     recursion_limit,\n                                                     param_env,\n@@ -848,7 +848,7 @@ fn project_type<'cx, 'gcx, 'tcx>(\n     debug!(\"project(obligation={:?})\",\n            obligation);\n \n-    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+    let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n         selcx.infcx().report_overflow_error(&obligation, true);"}, {"sha": "5e0a4ca3305526fbc3aafcc3252959440066f429", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -109,7 +109,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                     Reveal::UserFacing => ty,\n \n                     Reveal::All => {\n-                        let recursion_limit = self.tcx().sess.recursion_limit.get();\n+                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n                         if self.anon_depth >= recursion_limit {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),"}, {"sha": "51493f26194970403ec4acd389b183d57f9739d5", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -997,7 +997,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n-        let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n+        let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n             self.infcx().report_overflow_error(&stack.obligation, true);\n         }"}, {"sha": "1e5d0753e6932f463ac0ee1c5b631d58f225768f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -50,7 +50,7 @@ use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n use ty::CanonicalTy;\n-use util::nodemap::{NodeMap, DefIdSet, ItemLocalMap};\n+use util::nodemap::{DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n@@ -888,22 +888,12 @@ pub struct GlobalCtxt<'tcx> {\n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n \n-    /// Map from function to the `#[derive]` mode that it's defining. Only used\n-    /// by `proc-macro` crates.\n-    pub derive_macros: RefCell<NodeMap<Symbol>>,\n-\n     stability_interner: Lock<FxHashSet<&'tcx attr::Stability>>,\n \n     pub interpret_interner: InterpretInterner<'tcx>,\n \n     layout_interner: Lock<FxHashSet<&'tcx LayoutDetails>>,\n \n-    /// A vector of every trait accessible in the whole crate\n-    /// (i.e. including those from subcrates). This is used only for\n-    /// error reporting, and so is lazily initialized and generally\n-    /// shouldn't taint the common path (hence the RefCell).\n-    pub all_traits: RefCell<Option<Vec<DefId>>>,\n-\n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n     ///\n@@ -1280,10 +1270,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout,\n             layout_interner: Lock::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n-            derive_macros: RefCell::new(NodeMap()),\n             stability_interner: Lock::new(FxHashSet()),\n             interpret_interner: Default::default(),\n-            all_traits: RefCell::new(None),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n         };"}, {"sha": "35ada4a7227e7d1c16a7bd44fae4ced3dbbc3c67", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -898,7 +898,7 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n \n-    let rec_limit = tcx.sess.recursion_limit.get();\n+    let rec_limit = *tcx.sess.recursion_limit.get();\n     let depth = tcx.layout_depth.get();\n     if depth > rec_limit {\n         tcx.sess.fatal("}, {"sha": "150328f2a6a332361864f7fdd5d8f20d3194bd91", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -586,6 +586,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::all_traits<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching all foreign and local traits\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"fetching all foreign CrateNum instances\")"}, {"sha": "fd26855c94277ca05f59b6da890e69533dc93bc3", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -386,6 +386,11 @@ define_maps! { <'tcx>\n     [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n+    /// A vector of every trait accessible in the whole crate\n+    /// (i.e. including those from subcrates). This is used only for\n+    /// error reporting.\n+    [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n+\n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n         -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n@@ -575,6 +580,10 @@ fn all_crate_nums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::AllCrateNums\n }\n \n+fn all_traits_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::AllTraits\n+}\n+\n fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CollectAndPartitionTranslationItems\n }"}, {"sha": "7323407bab95d444c2da98b4aef98f5650bd362c", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -1124,6 +1124,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n         DepKind::MaybeUnusedExternCrates => { force!(maybe_unused_extern_crates, LOCAL_CRATE); }\n         DepKind::StabilityIndex => { force!(stability_index, LOCAL_CRATE); }\n+        DepKind::AllTraits => { force!(all_traits, LOCAL_CRATE); }\n         DepKind::AllCrateNums => { force!(all_crate_nums, LOCAL_CRATE); }\n         DepKind::ExportedSymbols => { force!(exported_symbols, krate!()); }\n         DepKind::CollectAndPartitionTranslationItems => {"}, {"sha": "bb6aa654c296008015e75ab0dca47e8d9ab127bc", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -10,6 +10,8 @@\n \n #![allow(non_camel_case_types)]\n \n+use rustc_data_structures::sync::Lock;\n+\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::ffi::CString;\n@@ -236,13 +238,14 @@ pub fn to_readable_str(mut val: usize) -> String {\n     groups.join(\"_\")\n }\n \n-pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n+pub fn record_time<T, F>(accu: &Lock<Duration>, f: F) -> T where\n     F: FnOnce() -> T,\n {\n     let start = Instant::now();\n     let rv = f();\n     let duration = start.elapsed();\n-    accu.set(duration + accu.get());\n+    let mut accu = accu.lock();\n+    *accu = *accu + duration;\n     rv\n }\n \n@@ -382,13 +385,3 @@ fn test_to_readable_str() {\n     assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n     assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n }\n-\n-pub trait CellUsizeExt {\n-    fn increment(&self);\n-}\n-\n-impl CellUsizeExt for Cell<usize> {\n-    fn increment(&self) {\n-        self.set(self.get() + 1);\n-    }\n-}"}, {"sha": "3b7d6efbdae1e760694fced946ac9031bd2db2ec", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -29,10 +29,15 @@\n //! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n //! depending on the value of cfg!(parallel_queries).\n \n+use std::collections::HashMap;\n+use std::hash::{Hash, BuildHasher};\n use std::cmp::Ordering;\n+use std::marker::PhantomData;\n use std::fmt::Debug;\n use std::fmt::Formatter;\n use std::fmt;\n+use std;\n+use std::ops::{Deref, DerefMut};\n use owning_ref::{Erased, OwningRef};\n \n cfg_if! {\n@@ -161,6 +166,8 @@ cfg_if! {\n         use parking_lot::Mutex as InnerLock;\n         use parking_lot::RwLock as InnerRwLock;\n \n+        use std::thread;\n+\n         pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n \n         /// This makes locks panic if they are already held.\n@@ -223,6 +230,146 @@ pub fn assert_sync<T: ?Sized + Sync>() {}\n pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n \n+pub trait HashMapExt<K, V> {\n+    /// Same as HashMap::insert, but it may panic if there's already an\n+    /// entry for `key` with a value not equal to `value`\n+    fn insert_same(&mut self, key: K, value: V);\n+}\n+\n+impl<K: Eq + Hash, V: Eq, S: BuildHasher> HashMapExt<K, V> for HashMap<K, V, S> {\n+    fn insert_same(&mut self, key: K, value: V) {\n+        self.entry(key).and_modify(|old| assert!(*old == value)).or_insert(value);\n+    }\n+}\n+\n+/// A type whose inner value can be written once and then will stay read-only\n+// This contains a PhantomData<T> since this type conceptually owns a T outside the Mutex once\n+// initialized. This ensures that Once<T> is Sync only if T is. If we did not have PhantomData<T>\n+// we could send a &Once<Cell<bool>> to multiple threads and call `get` on it to get access\n+// to &Cell<bool> on those threads.\n+pub struct Once<T>(Lock<Option<T>>, PhantomData<T>);\n+\n+impl<T> Once<T> {\n+    /// Creates an Once value which is uninitialized\n+    #[inline(always)]\n+    pub fn new() -> Self {\n+        Once(Lock::new(None), PhantomData)\n+    }\n+\n+    /// Consumes the value and returns Some(T) if it was initialized\n+    #[inline(always)]\n+    pub fn into_inner(self) -> Option<T> {\n+        self.0.into_inner()\n+    }\n+\n+    /// Tries to initialize the inner value to `value`.\n+    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n+    /// otherwise if the inner value was already set it returns `value` back to the caller\n+    #[inline]\n+    pub fn try_set(&self, value: T) -> Option<T> {\n+        let mut lock = self.0.lock();\n+        if lock.is_some() {\n+            return Some(value);\n+        }\n+        *lock = Some(value);\n+        None\n+    }\n+\n+    /// Tries to initialize the inner value to `value`.\n+    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n+    /// otherwise if the inner value was already set it asserts that `value` is equal to the inner\n+    /// value and then returns `value` back to the caller\n+    #[inline]\n+    pub fn try_set_same(&self, value: T) -> Option<T> where T: Eq {\n+        let mut lock = self.0.lock();\n+        if let Some(ref inner) = *lock {\n+            assert!(*inner == value);\n+            return Some(value);\n+        }\n+        *lock = Some(value);\n+        None\n+    }\n+\n+    /// Tries to initialize the inner value to `value` and panics if it was already initialized\n+    #[inline]\n+    pub fn set(&self, value: T) {\n+        assert!(self.try_set(value).is_none());\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure while ensuring that no-one else\n+    /// can access the value in the mean time by holding a lock for the duration of the closure.\n+    /// If the value was already initialized the closure is not called and `false` is returned,\n+    /// otherwise if the value from the closure initializes the inner value, `true` is returned\n+    #[inline]\n+    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> bool {\n+        let mut lock = self.0.lock();\n+        if lock.is_some() {\n+            return false;\n+        }\n+        *lock = Some(f());\n+        true\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n+    /// else can access it. This mean when this is called from multiple threads, multiple\n+    /// closures may concurrently be computing a value which the inner value should take.\n+    /// Only one of these closures are used to actually initialize the value.\n+    /// If some other closure already set the value,\n+    /// we return the value our closure computed wrapped in a `Option`.\n+    /// If our closure set the value, `None` is returned.\n+    /// If the value is already initialized, the closure is not called and `None` is returned.\n+    #[inline]\n+    pub fn init_nonlocking<F: FnOnce() -> T>(&self, f: F) -> Option<T> {\n+        if self.0.lock().is_some() {\n+            None\n+        } else {\n+            self.try_set(f())\n+        }\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n+    /// else can access it. This mean when this is called from multiple threads, multiple\n+    /// closures may concurrently be computing a value which the inner value should take.\n+    /// Only one of these closures are used to actually initialize the value.\n+    /// If some other closure already set the value, we assert that it our closure computed\n+    /// a value equal to the value aready set and then\n+    /// we return the value our closure computed wrapped in a `Option`.\n+    /// If our closure set the value, `None` is returned.\n+    /// If the value is already initialized, the closure is not called and `None` is returned.\n+    #[inline]\n+    pub fn init_nonlocking_same<F: FnOnce() -> T>(&self, f: F) -> Option<T> where T: Eq {\n+        if self.0.lock().is_some() {\n+            None\n+        } else {\n+            self.try_set_same(f())\n+        }\n+    }\n+\n+    /// Tries to get a reference to the inner value, returns `None` if it is not yet initialized\n+    #[inline(always)]\n+    pub fn try_get(&self) -> Option<&T> {\n+        let lock = &*self.0.lock();\n+        if let Some(ref inner) = *lock {\n+            // This is safe since we won't mutate the inner value\n+            unsafe { Some(&*(inner as *const T)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets reference to the inner value, panics if it is not yet initialized\n+    #[inline(always)]\n+    pub fn get(&self) -> &T {\n+        self.try_get().expect(\"value was not set\")\n+    }\n+\n+    /// Gets reference to the inner value, panics if it is not yet initialized\n+    #[inline(always)]\n+    pub fn borrow(&self) -> &T {\n+        self.get()\n+    }\n+}\n+\n impl<T: Copy + Debug> Debug for LockCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n         f.debug_struct(\"LockCell\")\n@@ -439,3 +586,54 @@ impl<T: Clone> Clone for RwLock<T> {\n         RwLock::new(self.borrow().clone())\n     }\n }\n+\n+/// A type which only allows its inner value to be used in one thread.\n+/// It will panic if it is used on multiple threads.\n+#[derive(Copy, Clone, Hash, Debug, Eq, PartialEq)]\n+pub struct OneThread<T> {\n+    #[cfg(parallel_queries)]\n+    thread: thread::ThreadId,\n+    inner: T,\n+}\n+\n+unsafe impl<T> std::marker::Sync for OneThread<T> {}\n+unsafe impl<T> std::marker::Send for OneThread<T> {}\n+\n+impl<T> OneThread<T> {\n+    #[inline(always)]\n+    fn check(&self) {\n+        #[cfg(parallel_queries)]\n+        assert_eq!(thread::current().id(), self.thread);\n+    }\n+\n+    #[inline(always)]\n+    pub fn new(inner: T) -> Self {\n+        OneThread {\n+            #[cfg(parallel_queries)]\n+            thread: thread::current().id(),\n+            inner,\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn into_inner(value: Self) -> T {\n+        value.check();\n+        value.inner\n+    }\n+}\n+\n+impl<T> Deref for OneThread<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        self.check();\n+        &self.inner\n+    }\n+}\n+\n+impl<T> DerefMut for OneThread<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        self.check();\n+        &mut self.inner\n+    }\n+}"}, {"sha": "4071b804def6c4f77f72be1b54f3ec4d816e7187", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -652,10 +652,11 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n \n-    *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n+    let crate_types = collect_crate_types(sess, &krate.attrs);\n+    sess.crate_types.set(crate_types);\n \n     let disambiguator = compute_crate_disambiguator(sess);\n-    *sess.crate_disambiguator.borrow_mut() = Some(disambiguator);\n+    sess.crate_disambiguator.set(disambiguator);\n     rustc_incremental::prepare_session_directory(\n         sess,\n         &crate_name,\n@@ -783,7 +784,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         let features = sess.features_untracked();\n         let cfg = syntax::ext::expand::ExpansionConfig {\n             features: Some(&features),\n-            recursion_limit: sess.recursion_limit.get(),\n+            recursion_limit: *sess.recursion_limit.get(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())"}, {"sha": "34d9f47bac3ddc8d0bbcc6db280d8f1ed459a1b2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -614,6 +614,7 @@ impl<'a> CrateLoader<'a> {\n         });\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n+            self.sess.injected_panic_runtime.set(None);\n             return\n         }\n \n@@ -646,6 +647,7 @@ impl<'a> CrateLoader<'a> {\n         // we just don't need one at all, then we're done here and there's\n         // nothing else to do.\n         if !needs_panic_runtime || runtime_found {\n+            self.sess.injected_panic_runtime.set(None);\n             return\n         }\n \n@@ -812,9 +814,7 @@ impl<'a> CrateLoader<'a> {\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         let has_global_allocator = has_global_allocator(krate);\n-        if has_global_allocator {\n-            self.sess.has_global_allocator.set(true);\n-        }\n+        self.sess.has_global_allocator.set(has_global_allocator);\n \n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n@@ -825,6 +825,8 @@ impl<'a> CrateLoader<'a> {\n             needs_allocator = needs_allocator || data.needs_allocator(self.sess);\n         });\n         if !needs_allocator {\n+            self.sess.injected_allocator.set(None);\n+            self.sess.allocator_kind.set(None);\n             return\n         }\n \n@@ -844,6 +846,8 @@ impl<'a> CrateLoader<'a> {\n             }\n         }\n         if !need_lib_alloc && !need_exe_alloc {\n+            self.sess.injected_allocator.set(None);\n+            self.sess.allocator_kind.set(None);\n             return\n         }\n \n@@ -881,6 +885,7 @@ impl<'a> CrateLoader<'a> {\n         });\n         if global_allocator.is_some() {\n             self.sess.allocator_kind.set(Some(AllocatorKind::Global));\n+            self.sess.injected_allocator.set(None);\n             return\n         }\n \n@@ -924,6 +929,9 @@ impl<'a> CrateLoader<'a> {\n             };\n \n         let allocation_crate_data = exe_allocation_crate_data.or_else(|| {\n+            // No allocator was injected\n+            self.sess.injected_allocator.set(None);\n+\n             if attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n                 // Prefer self as the allocator if there's a collision\n                 return None;"}, {"sha": "22b440eea60efec9e5ffa5606e9a4266f8d69d57", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let has_default_lib_allocator =\n             attr::contains_name(tcx.hir.krate_attrs(), \"default_lib_allocator\");\n-        let has_global_allocator = tcx.sess.has_global_allocator.get();\n+        let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),"}, {"sha": "58ea8d48e97114fb23ac49b6243d8b78fe527aa3", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -194,8 +194,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             param_env,\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n-            stack_limit: tcx.sess.const_eval_stack_frame_limit.get(),\n-            steps_remaining: tcx.sess.const_eval_step_limit.get(),\n+            stack_limit: tcx.sess.const_eval_stack_frame_limit,\n+            steps_remaining: tcx.sess.const_eval_step_limit,\n         }\n     }\n "}, {"sha": "83ef28e4f156cad110a93310e480be7f8be5fecf", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -325,7 +325,7 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut roots = Vec::new();\n \n     {\n-        let entry_fn = tcx.sess.entry_fn.borrow().map(|(node_id, _)| {\n+        let entry_fn = tcx.sess.entry_fn.borrow().map(|(node_id, _, _)| {\n             tcx.hir.local_def_id(node_id)\n         });\n \n@@ -457,7 +457,7 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if recursion_depth > tcx.sess.recursion_limit.get() {\n+    if recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n         if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n@@ -484,7 +484,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // which means that rustc basically hangs.\n     //\n     // Bail out in these cases to avoid that bad user experience.\n-    let type_length_limit = tcx.sess.type_length_limit.get();\n+    let type_length_limit = *tcx.sess.type_length_limit.get();\n     if type_length > type_length_limit {\n         // The instance name is already known to be too long for rustc. Use\n         // `{:.64}` to avoid blasting the user's terminal with thousands of\n@@ -1038,7 +1038,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n     /// the return type of `main`. This is not needed when\n     /// the user writes their own `start` manually.\n     fn push_extra_entry_roots(&mut self) {\n-        if self.tcx.sess.entry_type.get() != Some(config::EntryMain) {\n+        if self.tcx.sess.entry_fn.get().map(|e| e.2) != Some(config::EntryMain) {\n             return\n         }\n "}, {"sha": "181751f1777095670bca7d6fe04d28cf380c3f27", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -92,7 +92,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => {\n                 let entry_def_id =\n-                    tcx.sess.entry_fn.borrow().map(|(id, _)| tcx.hir.local_def_id(id));\n+                    tcx.sess.entry_fn.borrow().map(|(id, _, _)| tcx.hir.local_def_id(id));\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some() ||"}, {"sha": "5f4daf0d568f82c397f3c8aaaa4f63fc3d52472b", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -153,7 +153,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n         span, for_ty, depth, ty\n     );\n \n-    if depth >= tcx.sess.recursion_limit.get() {\n+    if depth >= *tcx.sess.recursion_limit.get() {\n         return Ok(DtorckConstraint {\n             outlives: vec![],\n             dtorck_types: vec![],"}, {"sha": "1857df5717bbac2c773d9e623118530ffd96aa83", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -11,17 +11,14 @@\n use rustc::traits::{Normalized, ObligationCause};\n use rustc::traits::query::NoSolution;\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use rustc::util::common::CellUsizeExt;\n+use std::sync::atomic::Ordering;\n \n crate fn normalize_ty_after_erasing_regions<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {\n     let ParamEnvAnd { param_env, value } = goal;\n-    tcx.sess\n-        .perf_stats\n-        .normalize_ty_after_erasing_regions\n-        .increment();\n+    tcx.sess.perf_stats.normalize_ty_after_erasing_regions.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::dummy();\n         match infcx.at(&cause, param_env).normalize(&value) {"}, {"sha": "8fc00c937e69c18fb393d40e3721ad55e9a481c5", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -13,19 +13,19 @@ use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n                     SelectionContext};\n use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n-use rustc::util::common::CellUsizeExt;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::DUMMY_SP;\n use util;\n+use std::sync::atomic::Ordering;\n \n crate fn normalize_projection_ty<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n ) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);\n \n-    tcx.sess.perf_stats.normalize_projection_ty.increment();\n+    tcx.sess.perf_stats.normalize_projection_ty.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let (\n             ParamEnvAnd {"}, {"sha": "965a34eccb862d1fdbe2879b00f2bd752ce26697", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -157,12 +157,12 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         })\n         .collect();\n \n-    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+    if let Some(id) = *tcx.sess.derive_registrar_fn.get() {\n         let def_id = tcx.hir.local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n-    if let Some(id) = tcx.sess.plugin_registrar_fn.get() {\n+    if let Some(id) = *tcx.sess.plugin_registrar_fn.get() {\n         let def_id = tcx.hir.local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }"}, {"sha": "f501b1739eb9c6437882e1bd4d86442215364654", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -154,13 +154,16 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n     }\n }\n \n-pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n-    target_machine_factory(sess)().unwrap_or_else(|err| {\n+pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachineRef {\n+    target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n         llvm_err(sess.diagnostic(), err).raise()\n     })\n }\n \n-pub fn target_machine_factory(sess: &Session)\n+// If find_features is true this won't access `sess.crate_types` by assuming\n+// that `is_pie_binary` is false. When we discover LLVM target features\n+// `sess.crate_types` is uninitialized so we cannot access it.\n+pub fn target_machine_factory(sess: &Session, find_features: bool)\n     -> Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n {\n     let reloc_model = get_reloc_model(sess);\n@@ -201,7 +204,7 @@ pub fn target_machine_factory(sess: &Session)\n     };\n     let cpu = CString::new(cpu.as_bytes()).unwrap();\n     let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n-    let is_pie_binary = is_pie_binary(sess);\n+    let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n \n     Arc::new(move || {\n@@ -1510,7 +1513,7 @@ fn start_executing_work(tcx: TyCtxt,\n         regular_module_config: modules_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n-        tm_factory: target_machine_factory(tcx.sess),\n+        tm_factory: target_machine_factory(tcx.sess, false),\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),"}, {"sha": "1da6f25fd639a0506daac80ef52e1e0d04359e30", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -518,7 +518,7 @@ pub fn set_link_section(cx: &CodegenCx,\n /// users main function.\n fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n     let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n-        Some((id, span)) => {\n+        Some((id, span, _)) => {\n             (cx.tcx.hir.local_def_id(id), span)\n         }\n         None => return,\n@@ -534,11 +534,11 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n \n     let main_llfn = callee::get_fn(cx, instance);\n \n-    let et = cx.sess().entry_type.get().unwrap();\n+    let et = cx.sess().entry_fn.get().map(|e| e.2);\n     match et {\n-        config::EntryMain => create_entry_fn(cx, span, main_llfn, main_def_id, true),\n-        config::EntryStart => create_entry_fn(cx, span, main_llfn, main_def_id, false),\n-        config::EntryNone => {}    // Do nothing.\n+        Some(config::EntryMain) => create_entry_fn(cx, span, main_llfn, main_def_id, true),\n+        Some(config::EntryStart) => create_entry_fn(cx, span, main_llfn, main_def_id, false),\n+        None => {}    // Do nothing.\n     }\n \n     fn create_entry_fn<'cx>(cx: &'cx CodegenCx,\n@@ -738,7 +738,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: ModuleSource::Translated(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n-            tm: create_target_machine(tcx.sess),\n+            tm: create_target_machine(tcx.sess, false),\n         }),\n         kind: ModuleKind::Metadata,\n     };\n@@ -796,15 +796,15 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         codegen_units.len());\n \n     // Translate an allocator shim, if any\n-    let allocator_module = if let Some(kind) = tcx.sess.allocator_kind.get() {\n+    let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n         unsafe {\n             let llmod_id = \"allocator\";\n             let (llcx, llmod) =\n                 context::create_context_and_module(tcx.sess, llmod_id);\n             let modules = ModuleLlvm {\n                 llmod,\n                 llcx,\n-                tm: create_target_machine(tcx.sess),\n+                tm: create_target_machine(tcx.sess, false),\n             };\n             time(tcx.sess, \"write allocator module\", || {\n                 allocator::trans(tcx, &modules, kind)\n@@ -1261,7 +1261,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let llvm_module = ModuleLlvm {\n                 llcx: cx.llcx,\n                 llmod: cx.llmod,\n-                tm: create_target_machine(cx.sess()),\n+                tm: create_target_machine(cx.sess(), false),\n             };\n \n             ModuleTranslation {"}, {"sha": "fe8a7052bdff7b471e510968ee705781847c7465", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -162,7 +162,7 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n     if sess.target.target.options.is_builtin {\n-        let tm = ::back::write::create_target_machine(sess);\n+        let tm = ::back::write::create_target_machine(sess, false);\n         llvm::LLVMRustSetDataLayoutFromTargetMachine(llmod, tm);\n         llvm::LLVMRustDisposeTargetMachine(tm);\n "}, {"sha": "28311018ee7d7d3e3ecbed32d7042d5239c12fda", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -263,7 +263,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let local_id = cx.tcx.hir.as_local_node_id(def_id);\n     match *cx.sess().entry_fn.borrow() {\n-        Some((id, _)) => {\n+        Some((id, _, _)) => {\n             if local_id == Some(id) {\n                 flags = flags | DIFlags::FlagMainSubprogram;\n             }"}, {"sha": "fa3ecb1cc1199810fe3093a488ba908c3b4b34d5", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -141,7 +141,7 @@ pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n }\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n-    let target_machine = create_target_machine(sess);\n+    let target_machine = create_target_machine(sess, true);\n     target_feature_whitelist(sess)\n         .iter()\n         .filter(|feature| {\n@@ -179,7 +179,7 @@ pub fn print_passes() {\n \n pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     require_inited();\n-    let tm = create_target_machine(sess);\n+    let tm = create_target_machine(sess, true);\n     unsafe {\n         match req {\n             PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),"}, {"sha": "0c6bc9e246bcec79b07f42ecacf7f8412427b642", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -51,7 +51,7 @@ pub mod symbol_names_test;\n /// that actually test that compilation succeeds without\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n-    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n+    if let Some((id, span, _)) = *tcx.sess.entry_fn.borrow() {\n         let main_def_id = tcx.hir.local_def_id(id);\n \n         if tcx.has_attr(main_def_id, \"rustc_error\") {"}, {"sha": "f3b7326b21071793b878b3d854b134a8aa31cdf2", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -244,11 +244,11 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let node_id = tcx.hir.as_local_node_id(def_id);\n \n     if let Some(id) = node_id {\n-        if tcx.sess.plugin_registrar_fn.get() == Some(id) {\n+        if *tcx.sess.plugin_registrar_fn.get() == Some(id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n-        if tcx.sess.derive_registrar_fn.get() == Some(id) {\n+        if *tcx.sess.derive_registrar_fn.get() == Some(id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_derive_registrar_symbol(disambiguator);\n         }"}, {"sha": "a87058d1fa593a8171c3ce44cbdd089c7b7d26c0", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -56,9 +56,9 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n             return Some((self.cur_ty, 0));\n         }\n \n-        if self.steps.len() >= tcx.sess.recursion_limit.get() {\n+        if self.steps.len() >= *tcx.sess.recursion_limit.get() {\n             // We've reached the recursion limit, error gracefully.\n-            let suggested_limit = tcx.sess.recursion_limit.get() * 2;\n+            let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n             let msg = format!(\"reached the recursion limit while auto-dereferencing {:?}\",\n                               self.cur_ty);\n             let error_id = (DiagnosticMessageId::ErrorId(55), Some(self.span), msg.clone());"}, {"sha": "49d0df555fa1de41711bb87582b6a6555bc72f5c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -31,13 +31,18 @@ use rustc_data_structures::sync::Lrc;\n \n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n+pub use self::suggest::TraitInfo;\n \n mod confirm;\n pub mod probe;\n mod suggest;\n \n use self::probe::{IsSuggestion, ProbeScope};\n \n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    suggest::provide(providers);\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise."}, {"sha": "2dbc590bbf72748ff8652decfaadfee6cd5fc721", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -13,6 +13,7 @@\n \n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n+use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -26,12 +27,12 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir;\n use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::TyAdt;\n \n-use std::cell;\n use std::cmp::Ordering;\n \n use super::{MethodError, NoMatchData, CandidateSource};\n@@ -208,6 +209,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // be used exists at all, and the type is an ambiuous numeric type\n                     // ({integer}/{float}).\n                     let mut candidates = all_traits(self.tcx)\n+                        .into_iter()\n                         .filter(|info| {\n                             self.associated_item(info.def_id, item_name, Namespace::Value).is_some()\n                         });\n@@ -519,6 +521,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // implement, by finding ones that have the item name, and are\n         // legal to implement.\n         let mut candidates = all_traits(self.tcx)\n+            .into_iter()\n             .filter(|info| {\n                 // we approximate the coherence rules to only suggest\n                 // traits that are legal to implement by requiring that\n@@ -603,18 +606,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type AllTraitsVec = Vec<DefId>;\n-\n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n     pub def_id: DefId,\n }\n \n-impl TraitInfo {\n-    fn new(def_id: DefId) -> TraitInfo {\n-        TraitInfo { def_id: def_id }\n-    }\n-}\n impl PartialEq for TraitInfo {\n     fn eq(&self, other: &TraitInfo) -> bool {\n         self.cmp(other) == Ordering::Equal\n@@ -638,8 +634,12 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieve all traits in this crate and any dependent crates.\n-pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a> {\n-    if tcx.all_traits.borrow().is_none() {\n+pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<TraitInfo> {\n+    tcx.all_traits(LOCAL_CRATE).iter().map(|&def_id| TraitInfo { def_id }).collect()\n+}\n+\n+/// Compute all traits in this crate and any dependent crates.\n+fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId> {\n         use rustc::hir::itemlikevisit;\n \n         let mut traits = vec![];\n@@ -649,7 +649,7 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n         // meh.\n         struct Visitor<'a, 'tcx: 'a> {\n             map: &'a hir_map::Map<'tcx>,\n-            traits: &'a mut AllTraitsVec,\n+            traits: &'a mut Vec<DefId>,\n         }\n         impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n@@ -676,7 +676,7 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n         // Cross-crate:\n         let mut external_mods = FxHashSet();\n         fn handle_external_def(tcx: TyCtxt,\n-                               traits: &mut AllTraitsVec,\n+                               traits: &mut Vec<DefId>,\n                                external_mods: &mut FxHashSet<DefId>,\n                                def: Def) {\n             let def_id = def.def_id();\n@@ -703,43 +703,16 @@ pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a>\n             handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n         }\n \n-        *tcx.all_traits.borrow_mut() = Some(traits);\n-    }\n-\n-    let borrow = tcx.all_traits.borrow();\n-    assert!(borrow.is_some());\n-    AllTraits {\n-        borrow,\n-        idx: 0,\n-    }\n+    traits\n }\n \n-pub struct AllTraits<'a> {\n-    borrow: cell::Ref<'a, Option<AllTraitsVec>>,\n-    idx: usize,\n-}\n-\n-impl<'a> Iterator for AllTraits<'a> {\n-    type Item = TraitInfo;\n-\n-    fn next(&mut self) -> Option<TraitInfo> {\n-        let AllTraits { ref borrow, ref mut idx } = *self;\n-        // ugh.\n-        borrow.as_ref().unwrap().get(*idx).map(|info| {\n-            *idx += 1;\n-            TraitInfo::new(*info)\n-        })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.borrow.as_ref().unwrap().len() - self.idx;\n-        (len, Some(len))\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    providers.all_traits = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Lrc::new(compute_all_traits(tcx))\n     }\n }\n \n-impl<'a> ExactSizeIterator for AllTraits<'a> {}\n-\n-\n struct UsePlacementFinder<'a, 'tcx: 'a, 'gcx: 'tcx> {\n     target_module: ast::NodeId,\n     span: Option<Span>,"}, {"sha": "da0b616b17373ff1377d89bce3a51ceabede676a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -730,6 +730,7 @@ fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: De\n }\n \n pub fn provide(providers: &mut Providers) {\n+    method::provide(providers);\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n@@ -1127,10 +1128,10 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = fcx.tcx.lang_items().termination() {\n-        if let Some((id, _)) = *fcx.tcx.sess.entry_fn.borrow() {\n+        if let Some((id, _, entry_type)) = *fcx.tcx.sess.entry_fn.borrow() {\n             if id == fn_id {\n-                match fcx.sess().entry_type.get() {\n-                    Some(config::EntryMain) => {\n+                match entry_type {\n+                    config::EntryMain => {\n                         let substs = fcx.tcx.mk_substs(iter::once(Kind::from(ret_ty)));\n                         let trait_ref = ty::TraitRef::new(term_id, substs);\n                         let return_ty_span = decl.output.span();\n@@ -1141,7 +1142,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             traits::Obligation::new(\n                                 cause, param_env, trait_ref.to_predicate()));\n                     },\n-                    _ => {},\n+                    config::EntryStart => {},\n                 }\n             }\n         }"}, {"sha": "4b66939963ed0a37add319284a78a58ae130fb4e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -288,12 +288,10 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    if let Some((id, sp)) = *tcx.sess.entry_fn.borrow() {\n-        match tcx.sess.entry_type.get() {\n-            Some(config::EntryMain) => check_main_fn_ty(tcx, id, sp),\n-            Some(config::EntryStart) => check_start_fn_ty(tcx, id, sp),\n-            Some(config::EntryNone) => {}\n-            None => bug!(\"entry function without a type\")\n+    if let Some((id, sp, entry_type)) = *tcx.sess.entry_fn.borrow() {\n+        match entry_type {\n+            config::EntryMain => check_main_fn_ty(tcx, id, sp),\n+            config::EntryStart => check_start_fn_ty(tcx, id, sp),\n         }\n     }\n }"}]}