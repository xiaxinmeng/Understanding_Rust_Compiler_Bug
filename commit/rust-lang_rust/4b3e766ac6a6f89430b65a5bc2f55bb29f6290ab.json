{"sha": "4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiM2U3NjZhYzZhNmY4OTQzMGI2NWE1YmMyZjU1YmIyOWY2MjkwYWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-07-31T23:10:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-01T19:17:32Z"}, "message": "Remove the pipes compiler\n\nThe pipes compiler produced data types that encoded efficient and safe\nbounded message passing protocols between two endpoints. It was also\ncapable of producing unbounded protocols.\n\nIt was useful research but was arguably done before its proper time.\n\nI am removing it for the following reasons:\n\n* In practice we used it only for producing the `oneshot` and `stream`\n  unbounded protocols and all communication in Rust use those.\n* The interface between the proto! macro and the standard library\n  has a large surface area and was difficult to maintain through\n  language and library changes.\n* It is now written in an old dialect of Rust and generates code\n  which would likely be considered non-idiomatic.\n* Both the compiler and the runtime are difficult to understand,\n  and likewise the relationship between the generated code and\n  the library is hard to understand. Debugging is difficult.\n* The new scheduler implements `stream` and `oneshot` by hand\n  in a way that will be significantly easier to maintain.\n\nThis shouldn't be taken as an indication that 'channel protocols'\nfor Rust are not worth pursuing again in the future.", "tree": {"sha": "2f02d8a7f30c9998912d9278eefbc8cf3ec4ee29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f02d8a7f30c9998912d9278eefbc8cf3ec4ee29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "html_url": "https://github.com/rust-lang/rust/commit/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "html_url": "https://github.com/rust-lang/rust/commit/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed"}], "stats": {"total": 2372, "additions": 3, "deletions": 2369}, "files": [{"sha": "90e1c7db91a5060c74403ec422d8ecbe83b6a84f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "patch": "@@ -81,8 +81,8 @@ pub enum SyntaxExtension {\n     // An IdentTT is a macro that has an\n     // identifier in between the name of the\n     // macro and the argument. Currently,\n-    // the only examples of this are\n-    // macro_rules! and proto!\n+    // the only examples of this is\n+    // macro_rules!\n \n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n@@ -197,8 +197,6 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders.insert(intern(&\"module_path\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_mod));\n-    syntax_expanders.insert(intern(&\"proto\"),\n-                            builtin_item_tt(ext::pipes::expand_proto));\n     syntax_expanders.insert(intern(&\"asm\"),\n                             builtin_normal_tt(ext::asm::expand_asm));\n     syntax_expanders.insert("}, {"sha": "eb8b01c427dcb80f8cb8d3ecb128842ae2dd5de6", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Functions for building ASTs, without having to fuss with spans.\n-//\n-// To start with, it will be use dummy spans, but it might someday do\n-// something smarter.\n-\n-use ast::ident;\n-use ast;\n-use codemap::span;\n-\n-use std::vec;\n-\n-// Transitional reexports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use ext;\n-    pub use parse;\n-}\n-\n-pub fn path(ids: ~[ident], span: span) -> ast::Path {\n-    ast::Path { span: span,\n-                 global: false,\n-                 idents: ids,\n-                 rp: None,\n-                 types: ~[] }\n-}\n-\n-pub fn path_global(ids: ~[ident], span: span) -> ast::Path {\n-    ast::Path { span: span,\n-                 global: true,\n-                 idents: ids,\n-                 rp: None,\n-                 types: ~[] }\n-}\n-\n-pub trait append_types {\n-    fn add_ty(&self, ty: ast::Ty) -> ast::Path;\n-    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path;\n-}\n-\n-impl append_types for ast::Path {\n-    fn add_ty(&self, ty: ast::Ty) -> ast::Path {\n-        ast::Path {\n-            types: vec::append_one(self.types.clone(), ty),\n-            .. (*self).clone()\n-        }\n-    }\n-\n-    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path {\n-        ast::Path {\n-            types: vec::append(self.types.clone(), tys),\n-            .. (*self).clone()\n-        }\n-    }\n-}"}, {"sha": "adf10215cb56636ef995845e1e8bc70fdcb5ace8", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Correctness for protocols\n-\n-/*\n-\n-This section of code makes sure the protocol is likely to generate\n-correct code. The correctness criteria include:\n-\n-  * No protocols transition to states that don't exist.\n-  * Messages step to states with the right number of type parameters.\n-\n-In addition, this serves as a lint pass. Lint warns for the following\n-things.\n-\n-  * States with no messages, it's better to step to !.\n-\n-It would also be nice to warn about unreachable states, but the\n-visitor infrastructure for protocols doesn't currently work well for\n-that.\n-\n-*/\n-\n-use ast;\n-use codemap::span;\n-use ext::base::ExtCtxt;\n-use ext::pipes::proto::{state, protocol, next_state};\n-use ext::pipes::proto;\n-\n-impl proto::visitor<(), (), ()> for @ExtCtxt {\n-    fn visit_proto(&self, _proto: protocol, _states: &[()]) { }\n-\n-    fn visit_state(&self, state: state, _m: &[()]) {\n-        let messages = &*state.messages;\n-        if messages.len() == 0 {\n-            self.span_warn(\n-                state.span, // use a real span!\n-                fmt!(\"state %s contains no messages, \\\n-                      consider stepping to a terminal state instead\",\n-                      state.name))\n-        }\n-    }\n-\n-    fn visit_message(&self, name: @str, _span: span, _tys: &[ast::Ty],\n-                     this: state, next: Option<next_state>) {\n-        match next {\n-          Some(ref next_state) => {\n-            let proto = this.proto;\n-            if !proto.has_state(next_state.state) {\n-                // This should be a span fatal, but then we need to\n-                // track span information.\n-                self.span_err(\n-                    proto.get_state(next_state.state).span,\n-                    fmt!(\"message %s steps to undefined state, %s\",\n-                         name, next_state.state));\n-            }\n-            else {\n-                let next = proto.get_state(next_state.state);\n-\n-                if next.generics.ty_params.len() != next_state.tys.len() {\n-                    self.span_err(\n-                        next.span, // use a real span\n-                        fmt!(\"message %s target (%s) \\\n-                              needs %u type parameters, but got %u\",\n-                             name, next.name,\n-                             next.generics.ty_params.len(),\n-                             next_state.tys.len()));\n-                }\n-            }\n-          }\n-          None => ()\n-        }\n-    }\n-}"}, {"sha": "b080a730f3e29b0a912c015ebd0283a4260783ee", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,106 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-\n-Liveness analysis for protocols. This is useful for a lot of possible\n-optimizations.\n-\n-This analysis computes the \"co-live\" relationship between\n-states. Co-live is defined inductively as follows.\n-\n-1. u is co-live with v if u can transition to v in one message.\n-\n-2. u is co-live with v if there exists a w such that u and w are\n-co-live, w and v are co-live, and u and w have the same direction.\n-\n-This relationship approximates when it is safe to store two states in\n-the same memory location. If there is no u such u is co-live with\n-itself, then the protocol is bounded.\n-\n-(These assertions could use proofs)\n-\n-In addition, this analysis does reachability, to warn when we have\n-useless states.\n-\n-The algorithm is a fixpoint computation. For each state, we initialize\n-a bitvector containing whether it is co-live with each other state. At\n-first we use rule (1) above to set each vector. Then we iterate\n-updating the states using rule (2) until there are no changes.\n-\n-*/\n-\n-use ext::base::ExtCtxt;\n-use ext::pipes::proto::{protocol_};\n-\n-use extra::bitv::Bitv;\n-\n-pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n-    debug!(\"initializing colive analysis\");\n-    let num_states = proto.num_states();\n-    let mut colive: ~[~Bitv] = do proto.states.iter().transform() |state| {\n-        let mut bv = ~Bitv::new(num_states, false);\n-        for state.reachable |s| {\n-            bv.set(s.id, true);\n-        }\n-        bv\n-    }.collect();\n-\n-    let mut i = 0;\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-        debug!(\"colive iteration %?\", i);\n-        let mut new_colive = ~[];\n-        foreach (i, this_colive) in colive.iter().enumerate() {\n-            let mut result = this_colive.clone();\n-            let this = proto.get_state_by_id(i);\n-            for this_colive.ones |j| {\n-                let next = proto.get_state_by_id(j);\n-                if this.dir == next.dir {\n-                    changed = result.union(colive[j]) || changed;\n-                }\n-            }\n-            new_colive.push(result)\n-        }\n-        colive = new_colive;\n-        i += 1;\n-    }\n-\n-    debug!(\"colive analysis complete\");\n-\n-    // Determine if we're bounded\n-    let mut self_live = ~[];\n-    foreach (i, bv) in colive.iter().enumerate() {\n-        if bv.get(i) {\n-            self_live.push(proto.get_state_by_id(i))\n-        }\n-    }\n-\n-    if self_live.len() > 0 {\n-        let states = self_live.map(|s| s.name).connect(\" \");\n-\n-        debug!(\"protocol %s is unbounded due to loops involving: %s\",\n-               proto.name,\n-               states);\n-\n-        // Someday this will be configurable with a warning\n-        //cx.span_warn(empty_span(),\n-        //              fmt!(\"protocol %s is unbounded due to loops \\\n-        //                    involving these states: %s\",\n-        //                   *proto.name,\n-        //                   states));\n-\n-        proto.bounded = Some(false);\n-    } else {\n-        debug!(\"protocol %s is bounded. yay!\", proto.name);\n-        proto.bounded = Some(true);\n-    }\n-}"}, {"sha": "b8a0da8fe8fb7cab20afa8b4daf9b0afbb9caf3e", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,84 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Implementation of proto! extension.\n-\n-This is frequently called the pipe compiler. It handles code such as...\n-\n-~~~\n-proto! pingpong (\n-    ping: send {\n-        ping -> pong\n-    }\n-    pong: recv {\n-        pong -> ping\n-    }\n-)\n-~~~\n-\n-There are several components:\n-\n- * The parser (libsyntax/ext/pipes/parse_proto.rs)\n-   * Responsible for building an AST from a protocol specification.\n-\n- * The checker (libsyntax/ext/pipes/check.rs)\n-   * Basic correctness checking for protocols (i.e. no undefined states, etc.)\n-\n- * The analyzer (libsyntax/ext/pipes/liveness.rs)\n-   * Determines whether the protocol is bounded or unbounded.\n-\n- * The compiler (libsynatx/ext/pipes/pipec.rs)\n-   * Generates a Rust AST from the protocol AST and the results of analysis.\n-\n-There is more documentation in each of the files referenced above.\n-\n-FIXME (#3072) - This is still incomplete.\n-\n-*/\n-\n-use ast;\n-use codemap::span;\n-use ext::base;\n-use ext::base::ExtCtxt;\n-use ext::pipes::parse_proto::proto_parser;\n-use ext::pipes::pipec::gen_init;\n-use ext::pipes::proto::visit;\n-use parse::lexer::{new_tt_reader, reader};\n-use parse::parser::Parser;\n-\n-pub mod ast_builder;\n-pub mod parse_proto;\n-pub mod pipec;\n-pub mod proto;\n-pub mod check;\n-pub mod liveness;\n-\n-\n-pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n-                    tt: ~[ast::token_tree]) -> base::MacResult {\n-    let sess = cx.parse_sess();\n-    let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n-                               None,\n-                               tt.clone());\n-    let rdr = tt_rdr as @reader;\n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n-\n-    let proto = rust_parser.parse_proto(cx.str_of(id));\n-\n-    // check for errors\n-    visit(proto, cx);\n-\n-    // do analysis\n-    liveness::analyze(proto, cx);\n-\n-    // compile\n-    base::MRItem(proto.compile(cx))\n-}"}, {"sha": "e5219721594c9ce8e86039d6ef98983bc29514c5", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,124 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Parsing pipes protocols from token trees.\n-\n-use ast_util;\n-use ext::pipes::proto::*;\n-use parse::common::SeqSep;\n-use parse::parser;\n-use parse::token;\n-use parse::token::{interner_get};\n-\n-pub trait proto_parser {\n-    fn parse_proto(&self, id: @str) -> protocol;\n-    fn parse_state(&self, proto: protocol);\n-    fn parse_message(&self, state: state);\n-}\n-\n-impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, id: @str) -> protocol {\n-        let proto = protocol(id, *self.span);\n-\n-        self.parse_seq_to_before_end(\n-            &token::EOF,\n-            SeqSep {\n-                sep: None,\n-                trailing_sep_allowed: false,\n-            },\n-            |this| this.parse_state(proto)\n-        );\n-\n-        return proto;\n-    }\n-\n-    fn parse_state(&self, proto: protocol) {\n-        let id = self.parse_ident();\n-        let name = interner_get(id.name);\n-\n-        self.expect(&token::COLON);\n-        let dir = match (*self.token).clone() {\n-            token::IDENT(n, _) => interner_get(n.name),\n-            _ => fail!()\n-        };\n-        self.bump();\n-        let dir = match dir.as_slice() {\n-          \"send\" => send,\n-          \"recv\" => recv,\n-          _ => fail!()\n-        };\n-\n-        let generics = if *self.token == token::LT {\n-            self.parse_generics()\n-        } else {\n-            ast_util::empty_generics()\n-        };\n-\n-        let state = proto.add_state_poly(name, id, dir, generics);\n-\n-        // parse the messages\n-        self.parse_unspanned_seq(\n-            &token::LBRACE,\n-            &token::RBRACE,\n-            SeqSep {\n-                sep: Some(token::COMMA),\n-                trailing_sep_allowed: true,\n-            },\n-            |this| this.parse_message(state)\n-        );\n-    }\n-\n-    fn parse_message(&self, state: state) {\n-        let mname = interner_get(self.parse_ident().name);\n-\n-        let args = if *self.token == token::LPAREN {\n-            self.parse_unspanned_seq(\n-                &token::LPAREN,\n-                &token::RPAREN,\n-                SeqSep {\n-                    sep: Some(token::COMMA),\n-                    trailing_sep_allowed: true,\n-                },\n-                |p| p.parse_ty(false)\n-            )\n-        }\n-        else { ~[] };\n-\n-        self.expect(&token::RARROW);\n-\n-        let next = match *self.token {\n-          token::IDENT(_, _) => {\n-            let name = interner_get(self.parse_ident().name);\n-            let ntys = if *self.token == token::LT {\n-                self.parse_unspanned_seq(\n-                    &token::LT,\n-                    &token::GT,\n-                    SeqSep {\n-                        sep: Some(token::COMMA),\n-                        trailing_sep_allowed: true,\n-                    },\n-                    |p| p.parse_ty(false)\n-                )\n-            }\n-            else { ~[] };\n-            Some(next_state {state: name, tys: ntys})\n-          }\n-          token::NOT => {\n-            // -> !\n-            self.bump();\n-            None\n-          }\n-          _ => self.fatal(\"invalid next state\")\n-        };\n-\n-        state.add_message(mname, *self.span, args, next);\n-\n-    }\n-}"}, {"sha": "02aef13a3a8293b1add6e4e44e4cb6e7c88a9eee", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "removed", "additions": 0, "deletions": 467, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,467 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A protocol compiler for Rust.\n-\n-use ast;\n-use codemap::{dummy_sp, spanned};\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::pipes::ast_builder::{append_types, path};\n-use ext::pipes::ast_builder::{path_global};\n-use ext::pipes::proto::*;\n-use ext::quote::rt::*;\n-use opt_vec;\n-use opt_vec::OptVec;\n-\n-use std::vec;\n-\n-pub trait gen_send {\n-    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty;\n-}\n-\n-pub trait to_type_decls {\n-    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n-                         dir: direction) -> ~[@ast::item];\n-}\n-\n-pub trait gen_init {\n-    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty;\n-    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n-    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n-}\n-\n-impl gen_send for message {\n-    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item {\n-        debug!(\"pipec: gen_send\");\n-        let name = self.name();\n-\n-        match *self {\n-          message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n-            debug!(\"pipec: next state exists\");\n-            let next = this.proto.get_state(next_state.state);\n-            assert!(next_state.tys.len() ==\n-                next.generics.ty_params.len());\n-            let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n-            let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                .transform(|(n, t)|\n-                    cx.arg(span, (*n).clone(), (*t).clone())).collect();\n-\n-            let pipe_ty = cx.ty_path(\n-                path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)), None);\n-            let args_ast = vec::append(\n-                ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n-                args_ast);\n-\n-            let mut body = ~\"{\\n\";\n-            body.push_str(fmt!(\"use super::%s;\\n\", name));\n-            body.push_str(\"let mut pipe = pipe;\\n\");\n-\n-            if this.proto.is_bounded() {\n-                let (sp, rp) = match (this.dir, next.dir) {\n-                  (send, send) => (~\"c\", ~\"s\"),\n-                  (send, recv) => (~\"s\", ~\"c\"),\n-                  (recv, send) => (~\"s\", ~\"c\"),\n-                  (recv, recv) => (~\"c\", ~\"s\")\n-                };\n-\n-                body.push_str(\"let mut b = pipe.reuse_buffer();\\n\");\n-                body.push_str(fmt!(\"let %s = ::std::pipes::SendPacketBuffered(\\\n-                                    &mut (b.buffer.data.%s));\\n\",\n-                                    sp,\n-                                    next.name));\n-                body.push_str(fmt!(\"let %s = ::std::pipes::RecvPacketBuffered(\\\n-                                   &mut (b.buffer.data.%s));\\n\",\n-                                   rp,\n-                                   next.name));\n-            }\n-            else {\n-                let pat = match (this.dir, next.dir) {\n-                  (send, send) => \"(s, c)\",\n-                  (send, recv) => \"(c, s)\",\n-                  (recv, send) => \"(c, s)\",\n-                  (recv, recv) => \"(s, c)\"\n-                };\n-\n-                body.push_str(fmt!(\"let %s = ::std::pipes::entangle();\\n\", pat));\n-            }\n-            body.push_str(fmt!(\"let message = %s(%s);\\n\",\n-                                name,\n-                                vec::append_one(arg_names.map(|x| cx.str_of(*x)), @\"s\")\n-                                                         .connect(\", \")));\n-\n-            if !try {\n-                body.push_str(fmt!(\"::std::pipes::send(pipe, message);\\n\"));\n-                // return the new channel\n-                body.push_str(\"c }\");\n-            }\n-            else {\n-                body.push_str(fmt!(\"if ::std::pipes::send(pipe, message) {\\n \\\n-                                  ::std::pipes::rt::make_some(c) \\\n-                              } else { ::std::pipes::rt::make_none() } }\"));\n-            }\n-\n-            let body = cx.parse_expr(body.to_managed());\n-\n-            let mut rty = cx.ty_path(path(~[next.data_name()],\n-                                          span)\n-                                     .add_tys(next_state.tys.clone()), None);\n-            if try {\n-                rty = cx.ty_option(rty);\n-            }\n-\n-            let name = if try {cx.ident_of(~\"try_\" + name)} else {cx.ident_of(name)};\n-\n-            cx.item_fn_poly(dummy_sp(),\n-                            name,\n-                            args_ast,\n-                            rty,\n-                            self.get_generics(),\n-                            cx.blk_expr(body))\n-          }\n-\n-            message(ref _id, span, ref tys, this, None) => {\n-                debug!(\"pipec: no next state\");\n-                let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n-\n-                let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(n, t)|\n-                        cx.arg(span, cx.ident_of(*n), (*t).clone())).collect();\n-\n-                let args_ast = vec::append(\n-                    ~[cx.arg(span,\n-                             cx.ident_of(\"pipe\"),\n-                             cx.ty_path(\n-                                 path(~[this.data_name()], span)\n-                                 .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params)), None))],\n-                    args_ast);\n-\n-                let message_args = if arg_names.len() == 0 {\n-                    ~\"\"\n-                }\n-                else {\n-                    ~\"(\" + arg_names.map(|x| (*x).clone()).connect(\", \") + \")\"\n-                };\n-\n-                let mut body = ~\"{ \";\n-                body.push_str(fmt!(\"use super::%s;\\n\", name));\n-                body.push_str(fmt!(\"let message = %s%s;\\n\", name, message_args));\n-\n-                if !try {\n-                    body.push_str(fmt!(\"::std::pipes::send(pipe, message);\\n\"));\n-                    body.push_str(\" }\");\n-                } else {\n-                    body.push_str(fmt!(\"if ::std::pipes::send(pipe, message) \\\n-                                        { \\\n-                                      ::std::pipes::rt::make_some(()) \\\n-                                  } else { \\\n-                                    ::std::pipes::rt::make_none() \\\n-                                  } }\"));\n-                }\n-\n-                let body = cx.parse_expr(body.to_managed());\n-\n-                let name = if try {cx.ident_of(~\"try_\" + name)} else {cx.ident_of(name)};\n-\n-                cx.item_fn_poly(dummy_sp(),\n-                                name,\n-                                args_ast,\n-                                if try {\n-                                    cx.ty_option(cx.ty_nil())\n-                                } else {\n-                                    cx.ty_nil()\n-                                },\n-                                self.get_generics(),\n-                                cx.blk_expr(body))\n-            }\n-          }\n-        }\n-\n-    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty {\n-        cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), None)\n-    }\n-}\n-\n-impl to_type_decls for state {\n-    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item] {\n-        debug!(\"pipec: to_type_decls\");\n-        // This compiles into two different type declarations. Say the\n-        // state is called ping. This will generate both `ping` and\n-        // `ping_message`. The first contains data that the user cares\n-        // about. The second is the same thing, but extended with a\n-        // next packet pointer, which is used under the covers.\n-\n-        let name = self.data_name();\n-\n-        let mut items_msg = ~[];\n-\n-        foreach m in self.messages.iter() {\n-            let message(name, span, tys, this, next) = (*m).clone();\n-\n-            let tys = match next {\n-              Some(ref next_state) => {\n-                let next = this.proto.get_state((next_state.state));\n-                let next_name = cx.str_of(next.data_name());\n-\n-                let dir = match this.dir {\n-                  send => \"server\",\n-                  recv => \"client\"\n-                };\n-\n-                vec::append_one(tys,\n-                                cx.ty_path(\n-                                    path(~[cx.ident_of(dir),\n-                                           cx.ident_of(next_name)], span)\n-                                    .add_tys(next_state.tys.clone()), None))\n-              }\n-              None => tys\n-            };\n-\n-            let v = cx.variant(span, cx.ident_of(name), tys);\n-\n-            items_msg.push(v);\n-        }\n-\n-        ~[\n-            cx.item_enum_poly(\n-                self.span,\n-                name,\n-                ast::enum_def { variants: items_msg },\n-                cx.strip_bounds(&self.generics)\n-            )\n-        ]\n-    }\n-\n-    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n-                         dir: direction) -> ~[@ast::item] {\n-        debug!(\"pipec: to_endpoint_decls\");\n-        let dir = match dir {\n-          send => (*self).dir,\n-          recv => (*self).dir.reverse()\n-        };\n-        let mut items = ~[];\n-\n-        {\n-            foreach m in self.messages.mut_iter() {\n-                if dir == send {\n-                    items.push(m.gen_send(cx, true));\n-                    items.push(m.gen_send(cx, false));\n-                }\n-            }\n-        }\n-\n-        if !self.proto.is_bounded() {\n-            items.push(\n-                cx.item_ty_poly(\n-                    self.span,\n-                    self.data_name(),\n-                    cx.ty_path(\n-                        path_global(~[cx.ident_of(\"std\"),\n-                                      cx.ident_of(\"pipes\"),\n-                                      cx.ident_of(dir.to_str() + \"Packet\")],\n-                             dummy_sp())\n-                        .add_ty(cx.ty_path(\n-                            path(~[cx.ident_of(\"super\"),\n-                                   self.data_name()],\n-                                 dummy_sp())\n-                            .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params)), None)), None),\n-                    cx.strip_bounds(&self.generics)));\n-        }\n-        else {\n-            items.push(\n-                cx.item_ty_poly(\n-                    self.span,\n-                    self.data_name(),\n-                    cx.ty_path(\n-                        path_global(~[cx.ident_of(\"std\"),\n-                                      cx.ident_of(\"pipes\"),\n-                                      cx.ident_of(dir.to_str()\n-                                                  + \"PacketBuffered\")],\n-                             dummy_sp())\n-                        .add_tys(~[cx.ty_path(\n-                            path(~[cx.ident_of(\"super\"),\n-                                   self.data_name()],\n-                                        dummy_sp())\n-                            .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params)), None),\n-                                   self.proto.buffer_ty_path(cx)]), None),\n-                    cx.strip_bounds(&self.generics)));\n-        };\n-        items\n-    }\n-}\n-\n-impl gen_init for protocol {\n-    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item {\n-        let ext_cx = cx;\n-\n-        debug!(\"gen_init\");\n-        let start_state = self.states[0];\n-\n-        let body = if !self.is_bounded() {\n-            quote_expr!( ::std::pipes::entangle() )\n-        }\n-        else {\n-            self.gen_init_bounded(ext_cx)\n-        };\n-\n-        cx.parse_item(fmt!(\"pub fn init%s() -> (server::%s, client::%s)\\\n-                            { pub use std::pipes::HasBuffer; %s }\",\n-                           start_state.generics.to_source(),\n-                           start_state.to_ty(cx).to_source(),\n-                           start_state.to_ty(cx).to_source(),\n-                           body.to_source()).to_managed())\n-    }\n-\n-    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n-        ext_cx.expr_struct(\n-            dummy_sp(),\n-            path(~[ext_cx.ident_of(\"__Buffer\")],\n-                 dummy_sp()),\n-            self.states.iter().transform(|s| {\n-                let fty = s.to_ty(ext_cx);\n-                ext_cx.field_imm(dummy_sp(),\n-                                 ext_cx.ident_of(s.name),\n-                                 quote_expr!(\n-                                     ::std::pipes::mk_packet::<$fty>()\n-                                 ))\n-            }).collect())\n-    }\n-\n-    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n-        debug!(\"gen_init_bounded\");\n-        let buffer_fields = self.gen_buffer_init(ext_cx);\n-        let buffer = quote_expr!(~::std::pipes::Buffer {\n-            header: ::std::pipes::BufferHeader(),\n-            data: $buffer_fields,\n-        });\n-\n-        let entangle_body = ext_cx.expr_blk(\n-            ext_cx.blk(\n-                dummy_sp(),\n-                self.states.iter().transform(\n-                    |s| ext_cx.parse_stmt(\n-                        fmt!(\"data.%s.set_buffer(buffer)\",\n-                             s.name).to_managed())).collect(),\n-                Some(ext_cx.parse_expr(fmt!(\n-                    \"::std::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n-                    self.states[0].name).to_managed()))));\n-\n-        quote_expr!({\n-            let buffer = $buffer;\n-            do ::std::pipes::entangle_buffer(buffer) |buffer, data| {\n-                $entangle_body\n-            }\n-        })\n-    }\n-\n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty {\n-        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        foreach s in self.states.iter() {\n-            foreach tp in s.generics.ty_params.iter() {\n-                match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push((*tp).clone()),\n-                  _ => ()\n-                }\n-            }\n-        }\n-\n-        cx.ty_path(path(~[cx.ident_of(\"super\"),\n-                          cx.ident_of(\"__Buffer\")],\n-                        self.span)\n-                   .add_tys(cx.ty_vars_global(&params)), None)\n-    }\n-\n-    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n-        let ext_cx = cx;\n-        let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        let fields = do self.states.iter().transform |s| {\n-            foreach tp in s.generics.ty_params.iter() {\n-                match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push((*tp).clone()),\n-                  _ => ()\n-                }\n-            }\n-\n-            let ty = s.to_ty(cx);\n-            let fty = quote_ty!( ::std::pipes::Packet<$ty> );\n-\n-            @spanned {\n-                node: ast::struct_field_ {\n-                    kind: ast::named_field(cx.ident_of(s.name),\n-                                           ast::inherited),\n-                    id: cx.next_id(),\n-                    ty: fty,\n-                    attrs: ~[],\n-                },\n-                span: dummy_sp()\n-            }\n-        }.collect();\n-\n-        let generics = Generics {\n-            lifetimes: opt_vec::Empty,\n-            ty_params: params\n-        };\n-\n-        cx.item_struct_poly(\n-            dummy_sp(),\n-            cx.ident_of(\"__Buffer\"),\n-            ast::struct_def {\n-                fields: fields,\n-                ctor_id: None\n-            },\n-            cx.strip_bounds(&generics))\n-    }\n-\n-    fn compile(&self, cx: @ExtCtxt) -> @ast::item {\n-        let mut items = ~[self.gen_init(cx)];\n-        let mut client_states = ~[];\n-        let mut server_states = ~[];\n-\n-        foreach s in self.states.iter() {\n-            items.push_all_move(s.to_type_decls(cx));\n-\n-            client_states.push_all_move(s.to_endpoint_decls(cx, send));\n-            server_states.push_all_move(s.to_endpoint_decls(cx, recv));\n-        }\n-\n-        if self.is_bounded() {\n-            items.push(self.gen_buffer_type(cx))\n-        }\n-\n-        items.push(cx.item_mod(self.span,\n-                               cx.ident_of(\"client\"),\n-                               ~[], ~[],\n-                               client_states));\n-        items.push(cx.item_mod(self.span,\n-                               cx.ident_of(\"server\"),\n-                               ~[], ~[],\n-                               server_states));\n-\n-        // XXX: Would be nice if our generated code didn't violate\n-        // Rust coding conventions\n-        let allows = cx.attribute(\n-            self.span,\n-            cx.meta_list(self.span,\n-                         @\"allow\",\n-                         ~[cx.meta_word(self.span, @\"non_camel_case_types\"),\n-                           cx.meta_word(self.span, @\"unused_mut\")]));\n-        cx.item_mod(self.span, cx.ident_of(self.name), ~[allows], ~[], items)\n-    }\n-}"}, {"sha": "5d2ebb68b8a0d7e1959a9adf75d5fedb0c9ee5f0", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use codemap::span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::pipes::ast_builder::{append_types, path};\n-\n-#[deriving(Eq)]\n-pub enum direction { send, recv }\n-\n-impl ToStr for direction {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-          send => ~\"Send\",\n-          recv => ~\"Recv\"\n-        }\n-    }\n-}\n-\n-impl direction {\n-    pub fn reverse(&self) -> direction {\n-        match *self {\n-          send => recv,\n-          recv => send\n-        }\n-    }\n-}\n-\n-#[deriving(Clone)]\n-pub struct next_state {\n-    state: @str,\n-    tys: ~[ast::Ty],\n-}\n-\n-// name, span, data, current state, next state\n-#[deriving(Clone)]\n-pub struct message(@str, span, ~[ast::Ty], state, Option<next_state>);\n-\n-impl message {\n-    pub fn name(&mut self) -> @str {\n-        match *self {\n-          message(id, _, _, _, _) => id\n-        }\n-    }\n-\n-    pub fn span(&mut self) -> span {\n-        match *self {\n-          message(_, span, _, _, _) => span\n-        }\n-    }\n-\n-    /// Return the type parameters actually used by this message\n-    pub fn get_generics(&self) -> ast::Generics {\n-        match *self {\n-          message(_, _, _, this, _) => this.generics.clone()\n-        }\n-    }\n-}\n-\n-pub type state = @state_;\n-\n-pub struct state_ {\n-    id: uint,\n-    name: @str,\n-    ident: ast::ident,\n-    span: span,\n-    dir: direction,\n-    generics: ast::Generics,\n-    messages: @mut ~[message],\n-    proto: protocol\n-}\n-\n-impl state_ {\n-    pub fn add_message(@self,\n-                       name: @str,\n-                       span: span,\n-                       data: ~[ast::Ty],\n-                       next: Option<next_state>) {\n-        self.messages.push(message(name, span, data, self,\n-                                   next));\n-    }\n-\n-    pub fn filename(&self) -> ~str {\n-        self.proto.filename()\n-    }\n-\n-    pub fn data_name(&self) -> ast::ident {\n-        self.ident\n-    }\n-\n-    /// Returns the type that is used for the messages.\n-    pub fn to_ty(&self, cx: @ExtCtxt) -> ast::Ty {\n-        cx.ty_path\n-            (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)), None)\n-    }\n-\n-    /// Iterate over the states that can be reached in one message\n-    /// from this state.\n-    pub fn reachable(&self, f: &fn(state) -> bool) -> bool {\n-        foreach m in self.messages.iter() {\n-            match *m {\n-              message(_, _, _, _, Some(next_state { state: ref id, _ })) => {\n-                let state = self.proto.get_state((*id));\n-                if !f(state) { return false; }\n-              }\n-              _ => ()\n-            }\n-        }\n-        return true;\n-    }\n-}\n-\n-pub type protocol = @mut protocol_;\n-\n-pub fn protocol(name: @str, span: span) -> protocol {\n-    @mut protocol_(name, span)\n-}\n-\n-pub fn protocol_(name: @str, span: span) -> protocol_ {\n-    protocol_ {\n-        name: name,\n-        span: span,\n-        states: @mut ~[],\n-        bounded: None\n-    }\n-}\n-\n-pub struct protocol_ {\n-    name: @str,\n-    span: span,\n-    states: @mut ~[state],\n-\n-    bounded: Option<bool>,\n-}\n-\n-impl protocol_ {\n-    /// Get a state.\n-    pub fn get_state(&self, name: &str) -> state {\n-        let mut i = self.states.iter();\n-        *i.find_(|i| name == i.name).get()\n-    }\n-\n-    pub fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n-\n-    pub fn has_state(&self, name: &str) -> bool {\n-        self.states.iter().find_(|i| name == i.name).is_some()\n-    }\n-\n-    pub fn filename(&self) -> ~str {\n-        ~\"proto://\" + self.name\n-    }\n-\n-    pub fn num_states(&self) -> uint {\n-        let states = &mut *self.states;\n-        states.len()\n-    }\n-\n-    pub fn has_ty_params(&self) -> bool {\n-        foreach s in self.states.iter() {\n-            if s.generics.ty_params.len() > 0 {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    pub fn is_bounded(&self) -> bool {\n-        let bounded = self.bounded.get();\n-        bounded\n-    }\n-}\n-\n-impl protocol_ {\n-    pub fn add_state_poly(@mut self,\n-                          name: @str,\n-                          ident: ast::ident,\n-                          dir: direction,\n-                          generics: ast::Generics)\n-                          -> state {\n-        let messages = @mut ~[];\n-        let states = &mut *self.states;\n-\n-        let state = @state_ {\n-            id: states.len(),\n-            name: name,\n-            ident: ident,\n-            span: self.span,\n-            dir: dir,\n-            generics: generics,\n-            messages: messages,\n-            proto: self\n-        };\n-\n-        states.push(state);\n-        state\n-    }\n-}\n-\n-pub trait visitor<Tproto, Tstate, Tmessage> {\n-    fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n-    fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(&self, name: @str, spane: span, tys: &[ast::Ty],\n-                     this: state, next: Option<next_state>) -> Tmessage;\n-}\n-\n-pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n-    proto: protocol, visitor: V) -> Tproto {\n-\n-    let states: ~[Tstate] = do proto.states.iter().transform |&s| {\n-        let messages: ~[Tmessage] = do s.messages.iter().transform |m| {\n-            let message(name, span, tys, this, next) = (*m).clone();\n-            visitor.visit_message(name, span, tys, this, next)\n-        }.collect();\n-        visitor.visit_state(s, messages)\n-    }.collect();\n-    visitor.visit_proto(proto, states)\n-}"}, {"sha": "4e7b0612e6446069825e968b41808cd1cc54ba5f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "patch": "@@ -683,7 +683,7 @@ fn expand_tts(cx: @ExtCtxt,\n     // the site the string literal occurred, which was in a source file\n     // _other_ than the one the user has control over. For example, an\n     // error in a quote from the protocol compiler, invoked in user code\n-    // using proto! for example, will be attributed to the pipec.rs file in\n+    // using macro_rules! for example, will be attributed to the macro_rules.rs file in\n     // libsyntax, which the user might not even have source to (unless they\n     // happen to have a compiler on hand). Over all, the phase distinction\n     // just makes quotes \"hard to attribute\". Possibly this could be fixed"}, {"sha": "f39351bf91f08b2d46cd7df3f4733b38c82621ed", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=4b3e766ac6a6f89430b65a5bc2f55bb29f6290ab", "patch": "@@ -78,7 +78,5 @@ pub mod ext {\n     pub mod auto_encode;\n     pub mod source_util;\n \n-    pub mod pipes;\n-\n     pub mod trace_macros;\n }"}, {"sha": "27cd34c5199a17b831a8154af07360ef01c4993c", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test creates a bunch of tasks that simultaneously send to each\n-// other in a ring. The messages should all be basically\n-// independent. It's designed to hammer the global kernel lock, so\n-// that things will look really good once we get that lock out of the\n-// message path.\n-\n-// This version uses automatically compiled channel contracts.\n-\n-extern mod extra;\n-\n-use extra::future;\n-use extra::time;\n-use std::cell::Cell;\n-use std::io;\n-use std::os;\n-use std::pipes::recv;\n-use std::uint;\n-use std::util;\n-\n-proto! ring (\n-    num:send {\n-        num(uint) -> num\n-    }\n-)\n-\n-fn thread_ring(i: uint,\n-               count: uint,\n-               num_chan: ring::client::num,\n-               num_port: ring::server::num) {\n-    let mut num_chan = Some(num_chan);\n-    let mut num_port = Some(num_port);\n-    // Send/Receive lots of messages.\n-    for uint::range(0, count) |j| {\n-        //error!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = util::replace(&mut num_chan, None);\n-        let num_port2 = util::replace(&mut num_port, None);\n-        num_chan = Some(ring::client::num(num_chan2.unwrap(), i * j));\n-        let port = num_port2.unwrap();\n-        match recv(port) {\n-          ring::num(_n, p) => {\n-            //log(error, _n);\n-            num_port = Some(p);\n-          }\n-        }\n-    };\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"100\", ~\"10000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"100\", ~\"1000\"]\n-    } else {\n-        args.clone()\n-    };\n-\n-    let num_tasks = uint::from_str(args[1]).get();\n-    let msg_per_task = uint::from_str(args[2]).get();\n-\n-    let (num_port, num_chan) = ring::init();\n-    let num_chan = Cell::new(num_chan);\n-\n-    let start = time::precise_time_s();\n-\n-    // create the ring\n-    let mut futures = ~[];\n-\n-    for uint::range(1u, num_tasks) |i| {\n-        //error!(\"spawning %?\", i);\n-        let (num_port, new_chan) = ring::init();\n-        let num_chan2 = Cell::new(num_chan.take());\n-        let num_port = Cell::new(num_port);\n-        let new_future = do future::spawn || {\n-            let num_chan = num_chan2.take();\n-            let num_port1 = num_port.take();\n-            thread_ring(i, msg_per_task, num_chan, num_port1)\n-        };\n-        futures.push(new_future);\n-        num_chan.put_back(new_chan);\n-    };\n-\n-    // do our iteration\n-    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n-\n-    // synchronize\n-    foreach f in futures.mut_iter() {\n-        let _ = f.get();\n-    }\n-\n-    let stop = time::precise_time_s();\n-\n-    // all done, report stats.\n-    let num_msgs = num_tasks * msg_per_task;\n-    let elapsed = (stop - start);\n-    let rate = (num_msgs as float) / elapsed;\n-\n-    printfln!(\"Sent %? messages in %? seconds\", num_msgs, elapsed);\n-    printfln!(\"  %? messages / second\", rate);\n-    printfln!(\"  %? \u03bcs / message\", 1000000. / rate);\n-}"}, {"sha": "b11daeef12f51a48c0ef6998d9af7560fbe736ad", "filename": "src/test/bench/pingpong.rs", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,210 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Compare bounded and unbounded protocol performance.\n-\n-// xfail-pretty\n-\n-extern mod extra;\n-\n-use extra::time::precise_time_s;\n-use std::cell::Cell;\n-use std::io;\n-use std::os;\n-use std::pipes::*;\n-use std::task;\n-\n-proto! pingpong (\n-    ping: send {\n-        ping -> pong\n-    }\n-\n-    pong: recv {\n-        pong -> ping\n-    }\n-)\n-\n-proto! pingpong_unbounded (\n-    ping: send {\n-        ping -> pong\n-    }\n-\n-    pong: recv {\n-        pong -> ping\n-    }\n-\n-    you_will_never_catch_me: send {\n-        never_ever_ever -> you_will_never_catch_me\n-    }\n-)\n-\n-// This stuff should go in libcore::pipes\n-macro_rules! move_it (\n-    { $x:expr } => { let t = *ptr::to_unsafe_ptr(&($x)); t }\n-)\n-\n-macro_rules! follow (\n-    {\n-        $($message:path($($x: ident),+) -> $next:ident $e:expr)+\n-    } => (\n-        |m| match m {\n-            $(Some($message($($x,)* next)) => {\n-                let $next = next;\n-                $e })+\n-                _ => { fail!() }\n-        }\n-    );\n-\n-    {\n-        $($message:path -> $next:ident $e:expr)+\n-    } => (\n-        |m| match m {\n-            $(Some($message(next)) => {\n-                let $next = next;\n-                $e })+\n-                _ => { fail!() }\n-        }\n-    )\n-)\n-\n-\n-/** Spawn a task to provide a service.\n-\n-It takes an initialization function that produces a send and receive\n-endpoint. The send endpoint is returned to the caller and the receive\n-endpoint is passed to the new task.\n-\n-*/\n-pub fn spawn_service<T:Send,Tb:Send>(\n-            init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n-                                  SendPacketBuffered<T, Tb>),\n-            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n-        -> SendPacketBuffered<T, Tb> {\n-    let (server, client) = init();\n-\n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell::new(server);\n-    do task::spawn {\n-        service(server.take());\n-    }\n-\n-    client\n-}\n-\n-/** Like `spawn_service_recv`, but for protocols that start in the\n-receive state.\n-\n-*/\n-pub fn spawn_service_recv<T:Send,Tb:Send>(\n-        init: extern fn() -> (SendPacketBuffered<T, Tb>,\n-                              RecvPacketBuffered<T, Tb>),\n-        service: ~fn(v: SendPacketBuffered<T, Tb>))\n-        -> RecvPacketBuffered<T, Tb> {\n-    let (server, client) = init();\n-\n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell::new(server);\n-    do task::spawn {\n-        service(server.take())\n-    }\n-\n-    client\n-}\n-\n-fn switch<T:Send,Tb:Send,U>(endp: std::pipes::RecvPacketBuffered<T, Tb>,\n-                              f: &fn(v: Option<T>) -> U)\n-                              -> U {\n-    f(std::pipes::try_recv(endp))\n-}\n-\n-// Here's the benchmark\n-\n-fn bounded(count: uint) {\n-    use pingpong::*;\n-\n-    let mut ch = do spawn_service(init) |ch| {\n-        let mut count = count;\n-        let mut ch = ch;\n-        while count > 0 {\n-            ch = switch(ch, follow! (\n-                ping -> next { server::pong(next) }\n-            ));\n-\n-            count -= 1;\n-        }\n-    };\n-\n-    let mut count = count;\n-    while count > 0 {\n-        let ch_ = client::ping(ch);\n-\n-        ch = switch(ch_, follow! (\n-            pong -> next { next }\n-        ));\n-\n-        count -= 1;\n-    }\n-}\n-\n-fn unbounded(count: uint) {\n-    use pingpong_unbounded::*;\n-\n-    let mut ch = do spawn_service(init) |ch| {\n-        let mut count = count;\n-        let mut ch = ch;\n-        while count > 0 {\n-            ch = switch(ch, follow! (\n-                ping -> next { server::pong(next) }\n-            ));\n-\n-            count -= 1;\n-        }\n-    };\n-\n-    let mut count = count;\n-    while count > 0 {\n-        let ch_ = client::ping(ch);\n-\n-        ch = switch(ch_, follow! (\n-            pong -> next { next }\n-        ));\n-\n-        count -= 1;\n-    }\n-}\n-\n-fn timeit(f: &fn()) -> float {\n-    let start = precise_time_s();\n-    f();\n-    let stop = precise_time_s();\n-    stop - start\n-}\n-\n-fn main() {\n-    let count = if os::getenv(\"RUST_BENCH\").is_some() {\n-        250000\n-    } else {\n-        100\n-    };\n-    let bounded = do timeit { bounded(count) };\n-    let unbounded = do timeit { unbounded(count) };\n-\n-    printfln!(\"count: %?\\n\", count);\n-    printfln!(\"bounded:   %? s\\t(%? \u03bcs/message)\",\n-              bounded, bounded * 1000000. / (count as float));\n-    printfln!(\"unbounded: %? s\\t(%? \u03bcs/message)\",\n-              unbounded, unbounded * 1000000. / (count as float));\n-\n-    printfln!(\"\\n\\\n-               bounded is %?%% faster\",\n-              (unbounded - bounded) / bounded * 100.);\n-}"}, {"sha": "b0ddccf28944b05425614f90ac9330c6c709edcd", "filename": "src/test/run-pass/issue-2834.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2834.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test case for issue #2843.\n-//\n-\n-proto! streamp (\n-    open:send<T:Send> {\n-        data(T) -> open<T>\n-    }\n-)\n-\n-fn rendezvous() {\n-    let (s, c) = streamp::init();\n-    let streams: ~[streamp::client::open<int>] = ~[c];\n-\n-    error!(\"%?\", streams[0]);\n-}\n-\n-pub fn main() {\n-    //os::getenv(\"FOO\");\n-    rendezvous();\n-}"}, {"sha": "10a19d62bd97b97922fbcf7a78c57cc1bb519554", "filename": "src/test/run-pass/issue-2930.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-proto! stream (\n-    Stream:send<T:Send> {\n-        send(T) -> Stream<T>\n-    }\n-)\n-\n-pub fn main() {\n-    let (_bp, bc) = stream::init();\n-\n-    stream::client::send(bc, ~\"abc\");\n-}"}, {"sha": "11c43b9390198a85f64a6fe2ab29ff7a947789f8", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,115 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// An example of the bank protocol from eholk's blog post.\n-//\n-// http://theincredibleholk.wordpress.com/2012/07/06/rusty-pipes/\n-\n-use std::pipes;\n-use std::pipes::try_recv;\n-use std::ptr;\n-\n-pub type username = ~str;\n-pub type password = ~str;\n-pub type money = float;\n-pub type amount = float;\n-\n-proto! bank (\n-    login:send {\n-        login(::username, ::password) -> login_response\n-    }\n-\n-    login_response:recv {\n-        ok -> connected,\n-        invalid -> login\n-    }\n-\n-    connected:send {\n-        deposit(::money) -> connected,\n-        withdrawal(::amount) -> withdrawal_response\n-    }\n-\n-    withdrawal_response:recv {\n-        money(::money) -> connected,\n-        insufficient_funds -> connected\n-    }\n-)\n-\n-fn switch<T:Send,U>(endp: pipes::RecvPacket<T>,\n-                    f: &fn(v: Option<T>) -> U) -> U {\n-    f(pipes::try_recv(endp))\n-}\n-\n-macro_rules! follow (\n-    {\n-        $($message:path$(($($x: ident),+))||* -> $next:ident $e:expr)+\n-    } => (\n-        |m| match m {\n-          $(Some($message($($($x,)+)* next)) => {\n-            let $next = next;\n-            $e })+\n-          _ => { fail!() }\n-        }\n-    );\n-)\n-\n-fn client_follow(bank: bank::client::login) {\n-    use bank::*;\n-\n-    let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n-    let bank = switch(bank, follow! (\n-        ok -> connected { connected }\n-        invalid -> _next { fail!(\"bank closed the connected\") }\n-    ));\n-\n-    let bank = client::deposit(bank, 100.00);\n-    let bank = client::withdrawal(bank, 50.00);\n-    switch(bank, follow! (\n-        money(m) -> _next {\n-            println(~\"Yay! I got money!\");\n-        }\n-        insufficient_funds -> _next {\n-            fail!(\"someone stole my money\")\n-        }\n-    ));\n-}\n-\n-fn bank_client(bank: bank::client::login) {\n-    use bank::*;\n-\n-    let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n-    let bank = match try_recv(bank) {\n-      Some(ok(connected)) => {\n-        connected\n-      }\n-      Some(invalid(_)) => { fail!(\"login unsuccessful\") }\n-      None => { fail!(\"bank closed the connection\") }\n-    };\n-\n-    let bank = client::deposit(bank, 100.00);\n-    let bank = client::withdrawal(bank, 50.00);\n-    match try_recv(bank) {\n-      Some(money(*)) => {\n-        println(~\"Yay! I got money!\");\n-      }\n-      Some(insufficient_funds(_)) => {\n-        fail!(\"someone stole my money\")\n-      }\n-      None => {\n-        fail!(\"bank closed the connection\")\n-      }\n-    }\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "42cd4081eda10aeadead5e4c630e78c7fc1c48cf", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,60 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Make sure that we can detect when one end of the pipe is closed.\n-\n-// xfail-win32\n-// xfail-test needs sleep\n-\n-extern mod extra;\n-use extra::timer::sleep;\n-use extra::uv;\n-\n-use std::cell::Cell;\n-use std::pipes::{try_recv, recv};\n-use std::task;\n-\n-proto! oneshot (\n-    waiting:send {\n-        signal -> !\n-    }\n-)\n-\n-pub fn main() {\n-    let iotask = &uv::global_loop::get();\n-\n-    let (port, chan) = oneshot::init();\n-    let port = Cell::new(port);\n-    do spawn {\n-        match try_recv(port.take()) {\n-          Some(*) => { fail!() }\n-          None => { }\n-        }\n-    }\n-\n-    sleep(iotask, 100);\n-\n-    task::spawn_unlinked(failtest);\n-}\n-\n-// Make sure the right thing happens during failure.\n-fn failtest() {\n-    let (p, c) = oneshot::init();\n-\n-    do task::spawn_with(c) |_c| {\n-        fail!();\n-    }\n-\n-    error!(\"%?\", recv(p));\n-    // make sure we get killed if we missed it in the receive.\n-    loop { task::yield() }\n-}"}, {"sha": "a61aad2e55c7a63710e8ec845a8ac1724efcd409", "filename": "src/test/run-pass/pipe-peek.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,31 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::pipes;\n-\n-proto! oneshot (\n-    waiting:send {\n-        signal -> !\n-    }\n-)\n-\n-pub fn main() {\n-    let (p, c) = oneshot::init();\n-    let mut p = p;\n-    let mut c = c;\n-\n-    assert!(!pipes::peek(&mut p));\n-\n-    oneshot::client::signal(c);\n-\n-    assert!(pipes::peek(&mut p));\n-}"}, {"sha": "ab17607c4d7d56866cd60d416f6abfe391acede6", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,126 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Ping-pong is a bounded protocol. This is place where I can\n-// experiment with what code the compiler should generate for bounded\n-// protocols.\n-\n-use std::cell::Cell;\n-use std::task;\n-\n-// This was generated initially by the pipe compiler, but it's been\n-// modified in hopefully straightforward ways.\n-\n-mod pingpong {\n-    use std::pipes;\n-    use std::pipes::*;\n-    use std::ptr;\n-\n-    pub struct Packets {\n-        ping: Packet<ping>,\n-        pong: Packet<pong>,\n-    }\n-\n-    pub fn init() -> (server::ping, client::ping) {\n-        let buffer = ~Buffer {\n-            header: BufferHeader(),\n-            data: Packets {\n-                ping: mk_packet::<ping>(),\n-                pong: mk_packet::<pong>()\n-            }\n-        };\n-        do pipes::entangle_buffer(buffer) |buffer, data| {\n-            data.ping.set_buffer(buffer);\n-            data.pong.set_buffer(buffer);\n-            ptr::to_mut_unsafe_ptr(&mut (data.ping))\n-        }\n-    }\n-    pub struct ping(server::pong);\n-    pub struct pong(client::ping);\n-    pub mod client {\n-        use std::pipes;\n-        use std::pipes::*;\n-        use std::ptr;\n-\n-        pub fn ping(mut pipe: ping) -> pong {\n-            {\n-                let mut b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(&mut b.buffer.data.pong);\n-                let c = RecvPacketBuffered(&mut b.buffer.data.pong);\n-                let message = ::pingpong::ping(s);\n-                send(pipe, message);\n-                c\n-            }\n-        }\n-        pub type ping = pipes::SendPacketBuffered<::pingpong::ping,\n-                                                  ::pingpong::Packets>;\n-        pub type pong = pipes::RecvPacketBuffered<::pingpong::pong,\n-                                                  ::pingpong::Packets>;\n-    }\n-    pub mod server {\n-        use std::pipes;\n-        use std::pipes::*;\n-        use std::ptr;\n-\n-        pub type ping = pipes::RecvPacketBuffered<::pingpong::ping,\n-        ::pingpong::Packets>;\n-        pub fn pong(mut pipe: pong) -> ping {\n-            {\n-                let mut b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(&mut b.buffer.data.ping);\n-                let c = RecvPacketBuffered(&mut b.buffer.data.ping);\n-                let message = ::pingpong::pong(s);\n-                send(pipe, message);\n-                c\n-            }\n-        }\n-        pub type pong = pipes::SendPacketBuffered<::pingpong::pong,\n-                                                  ::pingpong::Packets>;\n-    }\n-}\n-\n-mod test {\n-    use std::pipes::recv;\n-    use pingpong::{ping, pong};\n-\n-    pub fn client(chan: ::pingpong::client::ping) {\n-        use pingpong::client;\n-\n-        let chan = client::ping(chan); return;\n-        error!(\"Sent ping\");\n-        let pong(_chan) = recv(chan);\n-        error!(\"Received pong\");\n-    }\n-\n-    pub fn server(chan: ::pingpong::server::ping) {\n-        use pingpong::server;\n-\n-        let ping(chan) = recv(chan); return;\n-        error!(\"Received ping\");\n-        let _chan = server::pong(chan);\n-        error!(\"Sent pong\");\n-    }\n-}\n-\n-pub fn main() {\n-    let (server_, client_) = ::pingpong::init();\n-    let client_ = Cell::new(client_);\n-    let server_ = Cell::new(server_);\n-    do task::spawn {\n-        let client__ = client_.take();\n-        test::client(client__);\n-    };\n-    do task::spawn {\n-        let server__ = server_.take();\n-        test::server(server__);\n-    };\n-}"}, {"sha": "a4268f9456b30b06d3b072742191181eb9311133", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,65 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// An example to make sure the protocol parsing syntax extension works.\n-\n-use std::cell::Cell;\n-use std::option;\n-use std::task;\n-\n-proto! pingpong (\n-    ping:send {\n-        ping -> pong\n-    }\n-\n-    pong:recv {\n-        pong -> ping\n-    }\n-)\n-\n-mod test {\n-    use std::pipes::recv;\n-    use pingpong::{ping, pong};\n-\n-    pub fn client(chan: ::pingpong::client::ping) {\n-        use pingpong::client;\n-\n-        let chan = client::ping(chan);\n-        error!(~\"Sent ping\");\n-        let pong(_chan) = recv(chan);\n-        error!(~\"Received pong\");\n-    }\n-\n-    pub fn server(chan: ::pingpong::server::ping) {\n-        use pingpong::server;\n-\n-        let ping(chan) = recv(chan);\n-        error!(~\"Received ping\");\n-        let _chan = server::pong(chan);\n-        error!(~\"Sent pong\");\n-    }\n-}\n-\n-pub fn main() {\n-    let (server_, client_) = pingpong::init();\n-    let client_ = Cell::new(client_);\n-    let server_ = Cell::new(server_);\n-\n-    do task::spawn {\n-        let client__ = client_.take();\n-        test::client(client__);\n-    };\n-    do task::spawn {\n-        let server__ = server_.take();\n-        test::server(server__);\n-    };\n-}"}, {"sha": "65e0537dfb70440ce4256245aab59f4cfcba840c", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,179 +0,0 @@\n-// xfail-fast\n-// xfail-test\n-\n-// XFAIL'd because this is going to be revamped, and it's not compatible as\n-// written with the new mutability rules.\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Examples from Eric's internship final presentation.\n-//\n-// Code is easier to write in emacs, and it's good to be sure all the\n-// code samples compile (or not) as they should.\n-\n-use double_buffer::client::*;\n-use double_buffer::give_buffer;\n-use std::comm::Selectable;\n-\n-macro_rules! select_if (\n-    {\n-        $index:expr,\n-        $count:expr,\n-        $port:path => [\n-            $($message:path$(($($x: ident),+))dont_type_this*\n-              -> $next:ident $e:expr),+\n-        ],\n-        $( $ports:path => [\n-            $($messages:path$(($($xs: ident),+))dont_type_this*\n-              -> $nexts:ident $es:expr),+\n-        ], )*\n-    } => {\n-        if $index == $count {\n-            match std::pipes::try_recv($port) {\n-              $(Some($message($($($x,)+)* next)) => {\n-                let $next = next;\n-                $e\n-              })+\n-              _ => fail!()\n-            }\n-        } else {\n-            select_if!(\n-                $index,\n-                $count + 1,\n-                $( $ports => [\n-                    $($messages$(($($xs),+))dont_type_this*\n-                      -> $nexts $es),+\n-                ], )*\n-            )\n-        }\n-    };\n-\n-    {\n-        $index:expr,\n-        $count:expr,\n-    } => {\n-        fail!()\n-    }\n-)\n-\n-macro_rules! select (\n-    {\n-        $( $port:path => {\n-            $($message:path$(($($x: ident),+))dont_type_this*\n-              -> $next:ident $e:expr),+\n-        } )+\n-    } => ({\n-        let index = std::comm::selecti([$(($port).header()),+]);\n-        select_if!(index, 0, $( $port => [\n-            $($message$(($($x),+))dont_type_this* -> $next $e),+\n-        ], )+)\n-    })\n-)\n-\n-// Types and protocols\n-pub struct Buffer {\n-    foo: (),\n-\n-}\n-\n-impl Drop for Buffer {\n-    fn drop(&self) {}\n-}\n-\n-proto! double_buffer (\n-    acquire:send {\n-        request -> wait_buffer\n-    }\n-\n-    wait_buffer:recv {\n-        give_buffer(::Buffer) -> release\n-    }\n-\n-    release:send {\n-        release(::Buffer) -> acquire\n-    }\n-)\n-\n-// Code examples\n-fn render(_buffer: &Buffer) {\n-    // A dummy function.\n-}\n-\n-fn draw_frame(+channel: double_buffer::client::acquire) {\n-    let channel = request(channel);\n-    select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-                release(channel, buffer)\n-            }\n-        }\n-    );\n-}\n-\n-fn draw_two_frames(+channel: double_buffer::client::acquire) {\n-    let channel = request(channel);\n-    let channel = select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-                release(channel, buffer)\n-            }\n-        }\n-    );\n-    let channel = request(channel);\n-    select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-                release(channel, buffer)\n-            }\n-        }\n-    );\n-}\n-\n-#[cfg(bad1)]\n-fn draw_two_frames_bad1(+channel: double_buffer::client::acquire) {\n-    let channel = request(channel);\n-    select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-            }\n-        }\n-    );\n-    let channel = request(channel);\n-    select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-                release(channel, buffer)\n-            }\n-        }\n-    );\n-}\n-\n-#[cfg(bad2)]\n-fn draw_two_frames_bad2(+channel: double_buffer::client::acquire) {\n-    let channel = request(channel);\n-    select! (\n-        channel => {\n-            give_buffer(buffer) -> channel {\n-                render(&buffer);\n-                release(channel, buffer);\n-                render(&buffer);\n-                release(channel, buffer);\n-            }\n-        }\n-    );\n-}\n-\n-pub fn main() { }"}, {"sha": "cb126017247bc4d2979ccdb785d9ccbc1f729ad0", "filename": "src/test/run-pass/pipe-select-macro.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-select-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-select-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select-macro.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME #7303: xfail-test\n-\n-// Protocols\n-proto! foo (\n-    foo:recv {\n-        do_foo -> foo\n-    }\n-)\n-\n-proto! bar (\n-    bar:recv {\n-        do_bar(int) -> barbar,\n-        do_baz(bool) -> bazbar,\n-    }\n-\n-    barbar:send {\n-        rebarbar -> bar,\n-    }\n-\n-    bazbar:send {\n-        rebazbar -> bar\n-    }\n-)\n-\n-fn macros() {\n-    include!(\"select-macro.rs\");\n-}\n-\n-// Code\n-fn test(+foo: foo::client::foo, +bar: bar::client::bar) {\n-    use bar::do_baz;\n-\n-    select! (\n-        foo => {\n-            foo::do_foo -> _next {\n-            }\n-        }\n-\n-        bar => {\n-            bar::do_bar(x) -> _next {\n-                info!(\"%?\", x)\n-            },\n-\n-            do_baz(b) -> _next {\n-                if b { info!(\"true\") } else { info!(\"false\") }\n-            }\n-        }\n-    )\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "d9e887fcee8bfb8e691b39215564f4f75050bb6f", "filename": "src/test/run-pass/pipe-select.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,134 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty\n-// xfail-win32\n-// xfail-test needs sleep\n-\n-extern mod extra;\n-use extra::timer::sleep;\n-use extra::uv;\n-\n-use std::cell::Cell;\n-use std::pipes::*;\n-use std::pipes;\n-use std::task;\n-\n-proto! oneshot (\n-    waiting:send {\n-        signal -> !\n-    }\n-)\n-\n-proto! stream (\n-    Stream:send<T:Send> {\n-        send(T) -> Stream<T>\n-    }\n-)\n-\n-pub fn spawn_service<T:Send,Tb:Send>(\n-            init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n-                                  SendPacketBuffered<T, Tb>),\n-            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n-        -> SendPacketBuffered<T, Tb> {\n-    let (server, client) = init();\n-\n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell::new(server);\n-    do task::spawn {\n-        service(server.take());\n-    }\n-\n-    client\n-}\n-\n-pub fn main() {\n-    use oneshot::client::*;\n-    use stream::client::*;\n-\n-    let iotask = &uv::global_loop::get();\n-\n-    let c = spawn_service(stream::init, |p| {\n-        error!(\"waiting for pipes\");\n-        let stream::send(x, p) = recv(p);\n-        error!(\"got pipes\");\n-        let (left, right) : (oneshot::server::waiting,\n-                             oneshot::server::waiting)\n-            = x;\n-        error!(\"selecting\");\n-        let (i, _, _) = select(~[left, right]);\n-        error!(\"selected\");\n-        assert_eq!(i, 0);\n-\n-        error!(\"waiting for pipes\");\n-        let stream::send(x, _) = recv(p);\n-        error!(\"got pipes\");\n-        let (left, right) : (oneshot::server::waiting,\n-                             oneshot::server::waiting)\n-            = x;\n-        error!(\"selecting\");\n-        let (i, m, _) = select(~[left, right]);\n-        error!(\"selected %?\", i);\n-        if m.is_some() {\n-            assert_eq!(i, 1);\n-        }\n-    });\n-\n-    let (p1, c1) = oneshot::init();\n-    let (p2, _c2) = oneshot::init();\n-\n-    let c = send(c, (p1, p2));\n-\n-    sleep(iotask, 100);\n-\n-    signal(c1);\n-\n-    let (p1, _c1) = oneshot::init();\n-    let (p2, c2) = oneshot::init();\n-\n-    send(c, (p1, p2));\n-\n-    sleep(iotask, 100);\n-\n-    signal(c2);\n-\n-    test_select2();\n-}\n-\n-fn test_select2() {\n-    let (ap, ac) = stream::init();\n-    let (bp, bc) = stream::init();\n-\n-    stream::client::send(ac, 42);\n-\n-    match pipes::select2(ap, bp) {\n-      Left(*) => { }\n-      Right(*) => { fail!() }\n-    }\n-\n-    stream::client::send(bc, ~\"abc\");\n-\n-    error!(\"done with first select2\");\n-\n-    let (ap, ac) = stream::init();\n-    let (bp, bc) = stream::init();\n-\n-    stream::client::send(bc, ~\"abc\");\n-\n-    match pipes::select2(ap, bp) {\n-      Left(*) => { fail!() }\n-      Right(*) => { }\n-    }\n-\n-    stream::client::send(ac, 42);\n-}"}, {"sha": "4475a16a63bb7d0b66d4a33baf2b58ba48ab2489", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=7daea7c9c107238ba7bfc2e9f0e8955d42ad71ed", "patch": "@@ -1,65 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test needs sleep\n-// xfail-win32 #7999\n-\n-extern mod extra;\n-\n-use extra::timer::sleep;\n-use extra::uv;\n-use std::cell::Cell;\n-use std::pipes::*;\n-use std::pipes;\n-use std::task;\n-\n-proto! oneshot (\n-    waiting:send {\n-        signal -> !\n-    }\n-)\n-\n-\n-/** Spawn a task to provide a service.\n-\n-It takes an initialization function that produces a send and receive\n-endpoint. The send endpoint is returned to the caller and the receive\n-endpoint is passed to the new task.\n-\n-*/\n-pub fn spawn_service<T:Send,Tb:Send>(\n-            init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n-                                  SendPacketBuffered<T, Tb>),\n-            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n-        -> SendPacketBuffered<T, Tb> {\n-    let (server, client) = init();\n-\n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell::new(server);\n-    do task::spawn {\n-        service(server.take());\n-    }\n-\n-    client\n-}\n-\n-pub fn main() {\n-    use oneshot::client::*;\n-\n-    let c = spawn_service(oneshot::init, |p| { recv(p); });\n-\n-    let iotask = &uv::global_loop::get();\n-    sleep(iotask, 500);\n-\n-    signal(c);\n-}"}]}