{"sha": "d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "node_id": "C_kwDOAAsO6NoAKGQ2YzRkZTBmYjIyZmU4ZjNjYzVhMjdlOTRiNmI2ZDg4ZmI1MDRhOTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T07:13:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T07:13:45Z"}, "message": "Auto merge of #104861 - nnethercote:attr-cleanups, r=petrochenkov\n\nAttribute cleanups\n\nBest reviewed one commit at a time.\n\nr? `@petrochenkov`", "tree": {"sha": "daeb506f5cabec0a0b7f16f5a4a5e65fd723b7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daeb506f5cabec0a0b7f16f5a4a5e65fd723b7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "html_url": "https://github.com/rust-lang/rust/commit/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "744a97b98c3f2722e1a43486c05203b04e499e21", "url": "https://api.github.com/repos/rust-lang/rust/commits/744a97b98c3f2722e1a43486c05203b04e499e21", "html_url": "https://github.com/rust-lang/rust/commit/744a97b98c3f2722e1a43486c05203b04e499e21"}, {"sha": "ba1751a201190930a16ef20e6f7021c785d3891d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1751a201190930a16ef20e6f7021c785d3891d", "html_url": "https://github.com/rust-lang/rust/commit/ba1751a201190930a16ef20e6f7021c785d3891d"}], "stats": {"total": 538, "additions": 231, "deletions": 307}, "files": [{"sha": "6a2f1f0c5749c8be36891cbcbb1b1322b517102f", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -479,20 +479,10 @@ pub struct Crate {\n     pub is_placeholder: bool,\n }\n \n-/// Possible values inside of compile-time attribute lists.\n-///\n-/// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub enum NestedMetaItem {\n-    /// A full MetaItem, for recursive meta items.\n-    MetaItem(MetaItem),\n-    /// A literal.\n-    ///\n-    /// E.g., `\"foo\"`, `64`, `true`.\n-    Lit(MetaItemLit),\n-}\n-\n-/// A spanned compile-time attribute item.\n+/// A semantic representation of a meta item. A meta item is a slightly\n+/// restricted form of an attribute -- it can only contain expressions in\n+/// certain leaf positions, rather than arbitrary token streams -- that is used\n+/// for most built-in attributes.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -502,25 +492,39 @@ pub struct MetaItem {\n     pub span: Span,\n }\n \n-/// A compile-time attribute item.\n-///\n-/// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n+/// The meta item kind, containing the data after the initial path.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n-    /// E.g., `test` as in `#[test]`.\n+    /// E.g., `#[test]`, which lacks any arguments after `test`.\n     Word,\n+\n     /// List meta item.\n     ///\n-    /// E.g., `derive(..)` as in `#[derive(..)]`.\n+    /// E.g., `#[derive(..)]`, where the field represents the `..`.\n     List(Vec<NestedMetaItem>),\n+\n     /// Name value meta item.\n     ///\n-    /// E.g., `feature = \"foo\"` as in `#[feature = \"foo\"]`.\n+    /// E.g., `#[feature = \"foo\"]`, where the field represents the `\"foo\"`.\n     NameValue(MetaItemLit),\n }\n \n+/// Values inside meta item lists.\n+///\n+/// E.g., each of `Clone`, `Copy` in `#[derive(Clone, Copy)]`.\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub enum NestedMetaItem {\n+    /// A full MetaItem, for recursive meta items.\n+    MetaItem(MetaItem),\n+\n+    /// A literal.\n+    ///\n+    /// E.g., `\"foo\"`, `64`, `true`.\n+    Lit(MetaItemLit),\n+}\n+\n /// A block (`{ .. }`).\n ///\n /// E.g., `{ .. }` as in `fn foo() { .. }`.\n@@ -2570,17 +2574,10 @@ impl<D: Decoder> Decodable<D> for AttrId {\n     }\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct AttrItem {\n-    pub path: Path,\n-    pub args: AttrArgs,\n-    pub tokens: Option<LazyAttrTokenStream>,\n-}\n-\n /// A list of attributes.\n pub type AttrVec = ThinVec<Attribute>;\n \n-/// Metadata associated with an item.\n+/// A syntax-level representation of an attribute.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n@@ -2591,12 +2588,6 @@ pub struct Attribute {\n     pub span: Span,\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct NormalAttr {\n-    pub item: AttrItem,\n-    pub tokens: Option<LazyAttrTokenStream>,\n-}\n-\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n@@ -2608,6 +2599,19 @@ pub enum AttrKind {\n     DocComment(CommentKind, Symbol),\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct NormalAttr {\n+    pub item: AttrItem,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub struct AttrItem {\n+    pub path: Path,\n+    pub args: AttrArgs,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n /// `TraitRef`s appear in impls.\n ///\n /// Resolution maps each `TraitRef`'s `ref_id` to its defining trait; that's all"}, {"sha": "057cc26b5799e7eff82d0d6b7ad30eade281be53", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 54, "deletions": 117, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1,18 +1,17 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{DelimArgs, LitKind, MetaItemLit};\n-use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Path, PathSegment};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n+use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n+use crate::ast::{Path, PathSegment, StrStyle, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n use std::cell::Cell;\n@@ -223,11 +222,7 @@ impl AttrItem {\n     }\n \n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        Some(MetaItem {\n-            path: self.path.clone(),\n-            kind: MetaItemKind::from_attr_args(&self.args)?,\n-            span,\n-        })\n+        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n@@ -329,26 +324,13 @@ impl Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, str_span)\n+    mk_name_value_item(ident, LitKind::Str(str, ast::StrStyle::Cooked), str_span)\n }\n \n-pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = MetaItemLit::from_lit_kind(lit_kind, lit_span);\n+pub fn mk_name_value_item(ident: Ident, kind: LitKind, lit_span: Span) -> MetaItem {\n+    let lit = MetaItemLit { token_lit: kind.to_token_lit(), kind, span: lit_span };\n     let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n-}\n-\n-pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n-}\n-\n-pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n-}\n-\n-pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    NestedMetaItem::MetaItem(mk_word_item(ident))\n+    MetaItem { path: Path::from_ident(ident), kind: MetaItemKind::NameValue(lit), span }\n }\n \n pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n@@ -406,21 +388,58 @@ pub fn mk_attr_from_item(\n     span: Span,\n ) -> Attribute {\n     Attribute {\n-        kind: AttrKind::Normal(P(ast::NormalAttr { item, tokens })),\n+        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n         id: g.mk_attr_id(),\n         style,\n         span,\n     }\n }\n \n-/// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Empty;\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn mk_attr_name_value_str(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    name: Symbol,\n+    val: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let lit = LitKind::Str(val, StrStyle::Cooked).to_token_lit();\n+    let expr = P(Expr {\n+        id: DUMMY_NODE_ID,\n+        kind: ExprKind::Lit(lit),\n+        span,\n+        attrs: AttrVec::new(),\n+        tokens: None,\n+    });\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n+    mk_attr(g, style, path, args, span)\n }\n \n-/// Returns an outer attribute with the given value and span.\n-pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n+pub fn mk_attr_nested_word(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    outer: Symbol,\n+    inner: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n+        Token::from_ast_ident(Ident::new(inner, span)),\n+        Spacing::Alone,\n+    )]);\n+    let outer_ident = Ident::new(outer, span);\n+    let path = Path::from_ident(outer_ident);\n+    let attr_args = AttrArgs::Delimited(DelimArgs {\n+        dspan: DelimSpan::from_single(span),\n+        delim: MacDelimiter::Parenthesis,\n+        tokens: inner_tokens,\n+    });\n+    mk_attr(g, style, path, attr_args, span)\n }\n \n pub fn mk_doc_comment(\n@@ -438,23 +457,6 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n }\n \n impl MetaItem {\n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        let mut idents = vec![];\n-        let mut last_pos = BytePos(0_u32);\n-        for (i, segment) in self.path.segments.iter().enumerate() {\n-            let is_first = i == 0;\n-            if !is_first {\n-                let mod_sep_span =\n-                    Span::new(last_pos, segment.ident.span.lo(), segment.ident.span.ctxt(), None);\n-                idents.push(TokenTree::token_alone(token::ModSep, mod_sep_span));\n-            }\n-            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident), Spacing::Alone));\n-            last_pos = segment.ident.span.hi();\n-        }\n-        idents.extend(self.kind.token_trees(self.span));\n-        idents\n-    }\n-\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n@@ -526,62 +528,6 @@ impl MetaItemKind {\n         }\n     }\n \n-    pub fn attr_args(&self, span: Span) -> AttrArgs {\n-        match self {\n-            MetaItemKind::Word => AttrArgs::Empty,\n-            MetaItemKind::NameValue(lit) => {\n-                let expr = P(ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    kind: ast::ExprKind::Lit(lit.token_lit.clone()),\n-                    span: lit.span,\n-                    attrs: ast::AttrVec::new(),\n-                    tokens: None,\n-                });\n-                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tts = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tts.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tts.extend(item.token_trees())\n-                }\n-                AttrArgs::Delimited(DelimArgs {\n-                    dspan: DelimSpan::from_single(span),\n-                    delim: MacDelimiter::Parenthesis,\n-                    tokens: TokenStream::new(tts),\n-                })\n-            }\n-        }\n-    }\n-\n-    fn token_trees(&self, span: Span) -> Vec<TokenTree> {\n-        match self {\n-            MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(lit) => {\n-                vec![\n-                    TokenTree::token_alone(token::Eq, span),\n-                    TokenTree::Token(lit.to_token(), Spacing::Alone),\n-                ]\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tokens = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tokens.push(TokenTree::token_alone(token::Comma, span));\n-                    }\n-                    tokens.extend(item.token_trees())\n-                }\n-                vec![TokenTree::Delimited(\n-                    DelimSpan::from_single(span),\n-                    Delimiter::Parenthesis,\n-                    TokenStream::new(tokens),\n-                )]\n-            }\n-        }\n-    }\n-\n     fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n         let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n@@ -620,7 +566,7 @@ impl MetaItemKind {\n             }) => MetaItemKind::list_from_tokens(tokens.clone()),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n-                ast::ExprKind::Lit(token_lit) => {\n+                ExprKind::Lit(token_lit) => {\n                     // Turn failures to `None`, we'll get parse errors elsewhere.\n                     MetaItemLit::from_token_lit(token_lit, expr.span)\n                         .ok()\n@@ -659,15 +605,6 @@ impl NestedMetaItem {\n         }\n     }\n \n-    fn token_trees(&self) -> Vec<TokenTree> {\n-        match self {\n-            NestedMetaItem::MetaItem(item) => item.token_trees(),\n-            NestedMetaItem::Lit(lit) => {\n-                vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n-            }\n-        }\n-    }\n-\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n     where\n         I: Iterator<Item = TokenTree>,"}, {"sha": "1d6e7914f3a5c8d0395de312564765bc7dbcb688", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -206,22 +206,6 @@ impl MetaItemLit {\n         token::Lit::from_token(token)\n             .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n-\n-    /// Attempts to create a meta item literal from a `LitKind`.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> MetaItemLit {\n-        MetaItemLit { token_lit: kind.to_token_lit(), kind, span }\n-    }\n-\n-    /// Losslessly convert a meta item literal into a token.\n-    pub fn to_token(&self) -> Token {\n-        let kind = match self.token_lit.kind {\n-            token::Bool => token::Ident(self.token_lit.symbol, false),\n-            _ => token::Literal(self.token_lit),\n-        };\n-        Token::new(kind, self.span)\n-    }\n }\n \n fn strip_underscores(symbol: Symbol) -> Symbol {"}, {"sha": "82912a733d55222ca2a29b324eb0f106934054ae", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1606,16 +1606,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `#[allow(unreachable_code)]`\n-        let attr = {\n-            // `allow(unreachable_code)`\n-            let allow = {\n-                let allow_ident = Ident::new(sym::allow, self.lower_span(span));\n-                let uc_ident = Ident::new(sym::unreachable_code, self.lower_span(span));\n-                let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                attr::mk_list_item(allow_ident, vec![uc_nested])\n-            };\n-            attr::mk_attr_outer(&self.tcx.sess.parse_sess.attr_id_generator, allow)\n-        };\n+        let attr = attr::mk_attr_nested_word(\n+            &self.tcx.sess.parse_sess.attr_id_generator,\n+            AttrStyle::Outer,\n+            sym::allow,\n+            sym::unreachable_code,\n+            self.lower_span(span),\n+        );\n         let attrs: AttrVec = thin_vec![attr];\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`"}, {"sha": "eb9c841d80c16b05a74f3f0e7be3404b5c59a974", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -912,7 +912,7 @@ fn validate_generic_param_order(\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        validate_attr::check_meta(&self.session.parse_sess, attr);\n+        validate_attr::check_attr(&self.session.parse_sess, attr);\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {"}, {"sha": "ebe55a4b7718331a86c5b3dede461c11eeb9d6e7", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -19,7 +19,7 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n-use rustc_span::{BytePos, FileName, Span};\n+use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n \n use rustc_ast::attr::AttrIdGenerator;\n use std::borrow::Cow;\n@@ -120,17 +120,20 @@ pub fn print_crate<'a>(\n         // of the feature gate, so we fake them up here.\n \n         // `#![feature(prelude_import)]`\n-        let pi_nested = attr::mk_nested_word_item(Ident::with_dummy_span(sym::prelude_import));\n-        let list = attr::mk_list_item(Ident::with_dummy_span(sym::feature), vec![pi_nested]);\n-        let fake_attr = attr::mk_attr_inner(g, list);\n+        let fake_attr = attr::mk_attr_nested_word(\n+            g,\n+            ast::AttrStyle::Inner,\n+            sym::feature,\n+            sym::prelude_import,\n+            DUMMY_SP,\n+        );\n         s.print_attribute(&fake_attr);\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n         if edition == Edition::Edition2015 {\n             // `#![no_std]`\n-            let no_std_meta = attr::mk_word_item(Ident::with_dummy_span(sym::no_std));\n-            let fake_attr = attr::mk_attr_inner(g, no_std_meta);\n+            let fake_attr = attr::mk_attr_word(g, ast::AttrStyle::Inner, sym::no_std, DUMMY_SP);\n             s.print_attribute(&fake_attr);\n         }\n     }\n@@ -1713,9 +1716,9 @@ impl<'a> State<'a> {\n             where_clause: ast::WhereClause {\n                 has_where_token: false,\n                 predicates: Vec::new(),\n-                span: rustc_span::DUMMY_SP,\n+                span: DUMMY_SP,\n             },\n-            span: rustc_span::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n         let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };\n         self.print_fn(decl, header, name, &generics);"}, {"sha": "460175ed2ac84bb35abb7d29181ac418ecb5cd61", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -95,9 +95,7 @@ fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span\n         body,\n     }));\n \n-    let special = sym::rustc_std_internal_symbol;\n-    let special = cx.meta_word(span, special);\n-    let attrs = thin_vec![cx.attribute(special)];\n+    let attrs = thin_vec![cx.attr_word(sym::rustc_std_internal_symbol, span)];\n \n     let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n     cx.stmt_item(sig_span, item)"}, {"sha": "bd415901ae34dc7d900b818ba5fd965bc509d89e", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1,5 +1,4 @@\n use rustc_ast::{\n-    attr,\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n@@ -118,10 +117,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.cx.item(\n                 self.span,\n                 Ident::empty(),\n-                thin_vec![self.cx.attribute(attr::mk_list_item(\n-                    Ident::new(sym::allow, self.span),\n-                    vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))],\n+                thin_vec![self.cx.attr_nested_word(sym::allow, sym::unused_imports, self.span)],\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec!["}, {"sha": "4e4cafc71823aef1ed384ff4e76de0efad11c815", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -37,10 +37,10 @@ impl MultiItemModifier for Expander {\n         _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n-        let attr = &ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(\n+        validate_attr::check_builtin_meta_item(\n             &ecx.sess.parse_sess,\n-            attr,\n+            &meta_item,\n+            ast::AttrStyle::Outer,\n             sym::cfg_accessible,\n             template,\n         );"}, {"sha": "fa5a45730ac7afd8379eb696f2ef7098df42d389", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1,7 +1,7 @@\n use crate::cfg_eval::cfg_eval;\n \n use rustc_ast as ast;\n-use rustc_ast::{attr, token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{token, GenericParamKind, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -33,34 +33,36 @@ impl MultiItemModifier for Expander {\n             ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n                 let template =\n                     AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-                let attr =\n-                    attr::mk_attr_outer(&sess.parse_sess.attr_id_generator, meta_item.clone());\n-                validate_attr::check_builtin_attribute(\n+                validate_attr::check_builtin_meta_item(\n                     &sess.parse_sess,\n-                    &attr,\n+                    &meta_item,\n+                    ast::AttrStyle::Outer,\n                     sym::derive,\n                     template,\n                 );\n \n-                let mut resolutions: Vec<_> = attr\n-                    .meta_item_list()\n-                    .unwrap_or_default()\n-                    .into_iter()\n-                    .filter_map(|nested_meta| match nested_meta {\n-                        NestedMetaItem::MetaItem(meta) => Some(meta),\n-                        NestedMetaItem::Lit(lit) => {\n-                            // Reject `#[derive(\"Debug\")]`.\n-                            report_unexpected_meta_item_lit(sess, &lit);\n-                            None\n-                        }\n-                    })\n-                    .map(|meta| {\n-                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                        report_path_args(sess, &meta);\n-                        meta.path\n-                    })\n-                    .map(|path| (path, dummy_annotatable(), None, self.0))\n-                    .collect();\n+                let mut resolutions = match &meta_item.kind {\n+                    MetaItemKind::List(list) => {\n+                        list.iter()\n+                            .filter_map(|nested_meta| match nested_meta {\n+                                NestedMetaItem::MetaItem(meta) => Some(meta),\n+                                NestedMetaItem::Lit(lit) => {\n+                                    // Reject `#[derive(\"Debug\")]`.\n+                                    report_unexpected_meta_item_lit(sess, &lit);\n+                                    None\n+                                }\n+                            })\n+                            .map(|meta| {\n+                                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the\n+                                // paths.\n+                                report_path_args(sess, &meta);\n+                                meta.path.clone()\n+                            })\n+                            .map(|path| (path, dummy_annotatable(), None, self.0))\n+                            .collect()\n+                    }\n+                    _ => vec![],\n+                };\n \n                 // Do not configure or clone items unless necessary.\n                 match &mut resolutions[..] {"}, {"sha": "23b96d4176d3a27391d2d5d80491eae91b2b719e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_clone(\n         _ => cx.span_bug(span, \"`#[derive(Clone)]` on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "f861d47ed408e45fc02ecc6e7c75f76357d47a83", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -5,7 +5,7 @@ use crate::deriving::path_std;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use thin_vec::thin_vec;\n \n@@ -18,11 +18,11 @@ pub fn expand_deriving_eq(\n     is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n-    let inline = cx.meta_word(span, sym::inline);\n-    let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n-    let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n-    let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = thin_vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n+    let attrs = thin_vec![\n+        cx.attr_word(sym::inline, span),\n+        cx.attr_nested_word(sym::doc, sym::hidden, span),\n+        cx.attr_word(sym::no_coverage, span)\n+    ];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "96d18c7afb924c56a6fb6d949a414cbfead310ae", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -15,8 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n     is_const: bool,\n ) {\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "7f95551fc483a6bd69c4386a30191617581ec77e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -68,8 +68,7 @@ pub fn expand_deriving_partial_eq(\n \n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "5c4e5b7f8167500c1fd16a51b43d2a099e6548f5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -19,8 +19,7 @@ pub fn expand_deriving_partial_ord(\n     let ret_ty =\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "e4e2435848dd2c46c1fedd0c83fa7129fe904c78", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_default(\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n-    let inline = cx.meta_word(span, sym::inline);\n-    let attrs = thin_vec![cx.attribute(inline)];\n+    let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),"}, {"sha": "7fcaf0b436b9079742bd0261455ae0d613b9ad2f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -718,7 +718,7 @@ impl<'a> TraitDef<'a> {\n         let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n-        let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n+        let attr = cx.attr_word(sym::automatically_derived, self.span);\n         let attrs = thin_vec![attr];\n         let opt_trait_ref = Some(trait_ref);\n "}, {"sha": "13fdd4fa68c43cd1e70c3683c6ed6db7a5cd7e12", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -188,7 +188,7 @@ fn inject_impl_of_structural_trait(\n             .cloned(),\n     );\n     // Mark as `automatically_derived` to avoid some silly lints.\n-    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n+    attrs.push(cx.attr_word(sym::automatically_derived, span));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "0817aed037ef814aab672a3f132da1b57f2c865b", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -115,9 +115,7 @@ impl AllocFnFactory<'_, '_> {\n     }\n \n     fn attrs(&self) -> AttrVec {\n-        let special = sym::rustc_std_internal_symbol;\n-        let special = self.cx.meta_word(self.span, special);\n-        thin_vec![self.cx.attribute(special)]\n+        thin_vec![self.cx.attr_word(sym::rustc_std_internal_symbol, self.span)]\n     }\n \n     fn arg_ty("}, {"sha": "ece660cf6f64506fd55ce481e369efcf0e98f6c8", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1,6 +1,3 @@\n-use std::mem;\n-\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n@@ -13,6 +10,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n+use std::mem;\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -365,14 +363,8 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n             cx.expr_array_ref(span, decls),\n         )\n         .map(|mut i| {\n-            let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n-            i.attrs.push(cx.attribute(attr));\n-\n-            let deprecated_attr = attr::mk_nested_word_item(Ident::new(sym::deprecated, span));\n-            let allow_deprecated_attr =\n-                attr::mk_list_item(Ident::new(sym::allow, span), vec![deprecated_attr]);\n-            i.attrs.push(cx.attribute(allow_deprecated_attr));\n-\n+            i.attrs.push(cx.attr_word(sym::rustc_proc_macro_decls, span));\n+            i.attrs.push(cx.attr_nested_word(sym::allow, sym::deprecated, span));\n             i\n         });\n "}, {"sha": "f73f20c84a39d145911dbff56883d1dca807e565", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -52,7 +52,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                thin_vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+                thin_vec![cx.attr_word(sym::macro_use, span)],\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -79,7 +79,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        thin_vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        thin_vec![cx.attr_word(sym::prelude_import, span)],\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "3bcb60478efbc58db96665ce497c42373806fac3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -2,7 +2,6 @@\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n@@ -47,11 +46,7 @@ pub fn expand_test_case(\n             tokens: None,\n         };\n         item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n-        item.attrs.push(ecx.attribute(attr::mk_name_value_item_str(\n-            Ident::new(sym::rustc_test_marker, sp),\n-            test_path_symbol,\n-            sp,\n-        )));\n+        item.attrs.push(ecx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, sp));\n         item\n     });\n \n@@ -241,16 +236,9 @@ pub fn expand_test_or_bench(\n         Ident::new(item.ident.name, sp),\n         thin_vec![\n             // #[cfg(test)]\n-            cx.attribute(attr::mk_list_item(\n-                Ident::new(sym::cfg, attr_sp),\n-                vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n-            )),\n+            cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n             // #[rustc_test_marker = \"test_case_sort_key\"]\n-            cx.attribute(attr::mk_name_value_item_str(\n-                Ident::new(sym::rustc_test_marker, attr_sp),\n-                test_path_symbol,\n-                attr_sp,\n-            )),\n+            cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n         ]\n         .into(),\n         // const $ident: test::TestDescAndFn ="}, {"sha": "b5bce9278a907311d22e90493dba96dff9aee7b2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -185,13 +185,12 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n-                    let allow_ident = Ident::new(sym::allow, self.def_site);\n-                    let dc_nested =\n-                        attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n-                    let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n-                    let allow_dead_code = attr::mk_attr_outer(\n+                    let allow_dead_code = attr::mk_attr_nested_word(\n                         &self.sess.parse_sess.attr_id_generator,\n-                        allow_dead_code_item,\n+                        ast::AttrStyle::Outer,\n+                        sym::allow,\n+                        sym::dead_code,\n+                        self.def_site,\n                     );\n                     let attrs = attrs\n                         .into_iter()\n@@ -309,8 +308,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     );\n \n     // #[rustc_main]\n-    let main_meta = ecx.meta_word(sp, sym::rustc_main);\n-    let main_attr = ecx.attribute(main_meta);\n+    let main_attr = ecx.attr_word(sym::rustc_main, sp);\n \n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));"}, {"sha": "83812631c2ff729067e39df9480dc9a0916502eb", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{Attribute, MetaItem};\n+use rustc_ast::{AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -8,8 +8,13 @@ use rustc_span::Symbol;\n pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n     // All the built-in macro attributes are \"words\" at the moment.\n     let template = AttributeTemplate { word: true, ..Default::default() };\n-    let attr = ecx.attribute(meta_item.clone());\n-    validate_attr::check_builtin_attribute(&ecx.sess.parse_sess, &attr, name, template);\n+    validate_attr::check_builtin_meta_item(\n+        &ecx.sess.parse_sess,\n+        &meta_item,\n+        AttrStyle::Outer,\n+        name,\n+        template,\n+    );\n }\n \n /// Emit a warning if the item is annotated with the given attribute. This is used to diagnose when"}, {"sha": "c978297295d4003420c0b978c5b4222e3b0097e8", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -579,8 +579,6 @@ impl<'a> ExtCtxt<'a> {\n         attrs: ast::AttrVec,\n         kind: ast::ItemKind,\n     ) -> P<ast::Item> {\n-        // FIXME: Would be nice if our generated code didn't violate\n-        // Rust coding conventions\n         P(ast::Item {\n             ident: name,\n             attrs,\n@@ -618,11 +616,23 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n     }\n \n-    pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n-        attr::mk_attr_outer(&self.sess.parse_sess.attr_id_generator, mi)\n+    // Builds `#[name]`.\n+    pub fn attr_word(&self, name: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_word(g, ast::AttrStyle::Outer, name, span)\n     }\n \n-    pub fn meta_word(&self, sp: Span, w: Symbol) -> ast::MetaItem {\n-        attr::mk_word_item(Ident::new(w, sp))\n+    // Builds `#[name = val]`.\n+    //\n+    // Note: `span` is used for both the identifer and the value.\n+    pub fn attr_name_value_str(&self, name: Symbol, val: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_name_value_str(g, ast::AttrStyle::Outer, name, val, span)\n+    }\n+\n+    // Builds `#[outer(inner)]`.\n+    pub fn attr_nested_word(&self, outer: Symbol, inner: Symbol, span: Span) -> ast::Attribute {\n+        let g = &self.sess.parse_sess.attr_id_generator;\n+        attr::mk_attr_nested_word(g, ast::AttrStyle::Outer, outer, inner, span)\n     }\n }"}, {"sha": "e799fa404f6fd127465d6e5c0bf8d571e55e745b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -1644,7 +1644,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         let mut span: Option<Span> = None;\n         while let Some(attr) = attrs.next() {\n             rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n-            validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n+            validate_attr::check_attr(&self.cx.sess.parse_sess, attr);\n \n             let current_span = if let Some(sp) = span { sp.to(attr.span) } else { attr.span };\n             span = Some(current_span);"}, {"sha": "72402a200907afcd0387bca0687f8e0511ddb0f6", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -10,9 +10,9 @@ use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::{AttributeTemplate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::lint::builtin::ILL_FORMED_ATTRIBUTE_INPUT;\n use rustc_session::parse::ParseSess;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n-pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n+pub fn check_attr(sess: &ParseSess, attr: &Attribute) {\n     if attr.is_doc_comment() {\n         return;\n     }\n@@ -115,25 +115,34 @@ pub fn check_builtin_attribute(\n     name: Symbol,\n     template: AttributeTemplate,\n ) {\n-    // Some special attributes like `cfg` must be checked\n-    // before the generic check, so we skip them here.\n-    let should_skip = |name| name == sym::cfg;\n-\n     match parse_meta(sess, attr) {\n-        Ok(meta) => {\n-            if !should_skip(name) && !is_attr_template_compatible(&template, &meta.kind) {\n-                emit_malformed_attribute(sess, attr, name, template);\n-            }\n-        }\n+        Ok(meta) => check_builtin_meta_item(sess, &meta, attr.style, name, template),\n         Err(mut err) => {\n             err.emit();\n         }\n     }\n }\n \n+pub fn check_builtin_meta_item(\n+    sess: &ParseSess,\n+    meta: &MetaItem,\n+    style: ast::AttrStyle,\n+    name: Symbol,\n+    template: AttributeTemplate,\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+\n+    if !should_skip(name) && !is_attr_template_compatible(&template, &meta.kind) {\n+        emit_malformed_attribute(sess, style, meta.span, name, template);\n+    }\n+}\n+\n fn emit_malformed_attribute(\n     sess: &ParseSess,\n-    attr: &Attribute,\n+    style: ast::AttrStyle,\n+    span: Span,\n     name: Symbol,\n     template: AttributeTemplate,\n ) {\n@@ -147,7 +156,7 @@ fn emit_malformed_attribute(\n     let mut msg = \"attribute must be of the form \".to_owned();\n     let mut suggestions = vec![];\n     let mut first = true;\n-    let inner = if attr.style == ast::AttrStyle::Inner { \"!\" } else { \"\" };\n+    let inner = if style == ast::AttrStyle::Inner { \"!\" } else { \"\" };\n     if template.word {\n         first = false;\n         let code = format!(\"#{}[{}]\", inner, name);\n@@ -172,12 +181,12 @@ fn emit_malformed_attribute(\n         suggestions.push(code);\n     }\n     if should_warn(name) {\n-        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, attr.span, ast::CRATE_NODE_ID, &msg);\n+        sess.buffer_lint(&ILL_FORMED_ATTRIBUTE_INPUT, span, ast::CRATE_NODE_ID, &msg);\n     } else {\n         sess.span_diagnostic\n-            .struct_span_err(attr.span, &error_msg)\n+            .struct_span_err(span, &error_msg)\n             .span_suggestions(\n-                attr.span,\n+                span,\n                 if suggestions.len() == 1 {\n                     \"must be of the form\"\n                 } else {\n@@ -196,7 +205,7 @@ pub fn emit_fatal_malformed_builtin_attribute(\n     name: Symbol,\n ) -> ! {\n     let template = BUILTIN_ATTRIBUTE_MAP.get(&name).expect(\"builtin attr defined\").template;\n-    emit_malformed_attribute(sess, attr, name, template);\n+    emit_malformed_attribute(sess, attr.style, attr.span, name, template);\n     // This is fatal, otherwise it will likely cause a cascade of other errors\n     // (and an error here is expected to be very rare).\n     FatalError.raise()"}, {"sha": "cf28b0255d17db4c611ea55cf461be1a51fbc1c1", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -9,5 +9,7 @@ macro_rules! foo { () => () }\n fn main() {\n     foo::<T>!(); //~ ERROR generic arguments in macro path\n     foo::<>!(); //~ ERROR generic arguments in macro path\n-    m!(Default<>); //~ ERROR unexpected generic arguments in path\n+    m!(Default<>);\n+    //~^ ERROR unexpected generic arguments in path\n+    //~^^ ERROR generic arguments in macro path\n }"}, {"sha": "7023ef8cd1c33a43ad91d03e37b3da9c7026b288", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "patch": "@@ -16,5 +16,11 @@ error: unexpected generic arguments in path\n LL |     m!(Default<>);\n    |               ^^\n \n-error: aborting due to 3 previous errors\n+error: generic arguments in macro path\n+  --> $DIR/macro-ty-params.rs:12:15\n+   |\n+LL |     m!(Default<>);\n+   |               ^^\n+\n+error: aborting due to 4 previous errors\n "}]}