{"sha": "fbb6275f4fd6cf774e1789fabfacae7248c45021", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYjYyNzVmNGZkNmNmNzc0ZTE3ODlmYWJmYWNhZTcyNDhjNDUwMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-09T07:30:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-09T07:30:14Z"}, "message": "Auto merge of #53108 - RalfJung:mutex, r=alexcrichton\n\nclarify partially initialized Mutex issues\n\nUsing a `sys_common::mutex::Mutex` without calling `init` is dangerous, and yet there are some places that do this. I tried to find all of them and add an appropriate comment about reentrancy.\n\nI found two places where (I think) reentrancy can actually occur, and was not able to come up with an argument for why this is okay. Someone who knows `io::lazy` and/or `sys_common::at_exit_imp` should have a careful look at this.", "tree": {"sha": "f66469baf6a3a33dad86eb02c203c66115a816bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f66469baf6a3a33dad86eb02c203c66115a816bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbb6275f4fd6cf774e1789fabfacae7248c45021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb6275f4fd6cf774e1789fabfacae7248c45021", "html_url": "https://github.com/rust-lang/rust/commit/fbb6275f4fd6cf774e1789fabfacae7248c45021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbb6275f4fd6cf774e1789fabfacae7248c45021/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76b69a604ee0d70be1edfa2828c769dc1b148d13", "url": "https://api.github.com/repos/rust-lang/rust/commits/76b69a604ee0d70be1edfa2828c769dc1b148d13", "html_url": "https://github.com/rust-lang/rust/commit/76b69a604ee0d70be1edfa2828c769dc1b148d13"}, {"sha": "25db84206b681731960d88558bc53640fe117b09", "url": "https://api.github.com/repos/rust-lang/rust/commits/25db84206b681731960d88558bc53640fe117b09", "html_url": "https://github.com/rust-lang/rust/commit/25db84206b681731960d88558bc53640fe117b09"}], "stats": {"total": 44, "additions": 38, "deletions": 6}, "files": [{"sha": "4fb367fb6ba524147e9a1806d02eab4759a8d0b6", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -15,6 +15,7 @@ use sys_common;\n use sys_common::mutex::Mutex;\n \n pub struct Lazy<T> {\n+    // We never call `lock.init()`, so it is UB to attempt to acquire this mutex reentrantly!\n     lock: Mutex,\n     ptr: Cell<*mut Arc<T>>,\n     init: fn() -> Arc<T>,\n@@ -26,7 +27,9 @@ const fn done<T>() -> *mut Arc<T> { 1_usize as *mut _ }\n unsafe impl<T> Sync for Lazy<T> {}\n \n impl<T: Send + Sync + 'static> Lazy<T> {\n-    pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n+    /// Safety: `init` must not call `get` on the variable that is being\n+    /// initialized.\n+    pub const unsafe fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n         Lazy {\n             lock: Mutex::new(),\n             ptr: Cell::new(ptr::null_mut()),\n@@ -48,6 +51,7 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         }\n     }\n \n+    // Must only be called with `lock` held\n     unsafe fn init(&'static self) -> Arc<T> {\n         // If we successfully register an at exit handler, then we cache the\n         // `Arc` allocation in our own internal box (it will get deallocated by\n@@ -60,6 +64,9 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n             };\n             drop(Box::from_raw(ptr))\n         });\n+        // This could reentrantly call `init` again, which is a problem\n+        // because our `lock` allows reentrancy!\n+        // That's why `new` is unsafe and requires the caller to ensure no reentrancy happens.\n         let ret = (self.init)();\n         if registered.is_ok() {\n             self.ptr.set(Box::into_raw(Box::new(ret.clone())));"}, {"sha": "1f256f518c7ce083585f57b74ddccbfb95912b04", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -197,12 +197,13 @@ pub struct StdinLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new(stdin_init);\n+    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = unsafe { Lazy::new(stdin_init) };\n     return Stdin {\n         inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n     };\n \n     fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> {\n+        // This must not reentrantly access `INSTANCE`\n         let stdin = match stdin_raw() {\n             Ok(stdin) => Maybe::Real(stdin),\n             _ => Maybe::Fake\n@@ -396,12 +397,13 @@ pub struct StdoutLock<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n     static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>\n-        = Lazy::new(stdout_init);\n+        = unsafe { Lazy::new(stdout_init) };\n     return Stdout {\n         inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n     };\n \n     fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> {\n+        // This must not reentrantly access `INSTANCE`\n         let stdout = match stdout_raw() {\n             Ok(stdout) => Maybe::Real(stdout),\n             _ => Maybe::Fake,\n@@ -531,12 +533,14 @@ pub struct StderrLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new(stderr_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> =\n+        unsafe { Lazy::new(stderr_init) };\n     return Stderr {\n         inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n     };\n \n     fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {\n+        // This must not reentrantly access `INSTANCE`\n         let stderr = match stderr_raw() {\n             Ok(stderr) => Maybe::Real(stderr),\n             _ => Maybe::Fake,"}, {"sha": "c3c033dfbc739c4dcafcc57d153841d5739603da", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -80,6 +80,8 @@ mod imp {\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n+    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n+    // acquire this mutex reentrantly!\n     static LOCK: Mutex = Mutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {"}, {"sha": "1d447de11343c071de9983911ae6be098b4e716e", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -25,8 +25,10 @@ unsafe impl Sync for Mutex {}\n #[allow(dead_code)] // sys isn't exported yet\n impl Mutex {\n     pub const fn new() -> Mutex {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n+        // Might be moved to a different address, so it is better to avoid\n+        // initialization of potentially opaque OS data before it landed.\n+        // Be very careful using this newly constructed `Mutex`, reentrant\n+        // locking is undefined behavior until `init` is called!\n         Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]"}, {"sha": "08c3e1549784395c59bd924267e26c78f0ea6b1f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -33,6 +33,8 @@ use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n+// We never call `ENV_LOCK.init()`, so it is UB to attempt to\n+// acquire this mutex reentrantly!\n static ENV_LOCK: Mutex = Mutex::new();\n \n "}, {"sha": "76e5df2c8654ae6d6ba91fce1abcf6e74829cd7f", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -23,6 +23,8 @@ type Queue = Vec<Box<dyn FnBox()>>;\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n+// We never call `LOCK.init()`, so it is UB to attempt to\n+// acquire this mutex reentrantly!\n static LOCK: Mutex = Mutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n@@ -61,6 +63,7 @@ pub fn cleanup() {\n             if !queue.is_null() {\n                 let queue: Box<Queue> = Box::from_raw(queue);\n                 for to_run in *queue {\n+                    // We are not holding any lock, so reentrancy is fine.\n                     to_run();\n                 }\n             }\n@@ -72,6 +75,8 @@ pub fn push(f: Box<dyn FnBox()>) -> bool {\n     unsafe {\n         let _guard = LOCK.lock();\n         if init() {\n+            // We are just moving `f` around, not calling it.\n+            // There is no possibility of reentrancy here.\n             (*QUEUE).push(f);\n             true\n         } else {"}, {"sha": "c6d531c7a1ac59cbb3b641ea96fc645a3b2f6d2d", "filename": "src/libstd/sys_common/mutex.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -24,11 +24,17 @@ impl Mutex {\n     ///\n     /// Behavior is undefined if the mutex is moved after it is\n     /// first used with any of the functions below.\n+    /// Also, until `init` is called, behavior is undefined if this\n+    /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n+    /// are called by the thread currently holding the lock.\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n     /// Prepare the mutex for use.\n     ///\n     /// This should be called once the mutex is at a stable memory address.\n+    /// If called, this must be the very first thing that happens to the mutex.\n+    /// Calling it in parallel with or after any operation (including another\n+    /// `init()`) is undefined behavior.\n     #[inline]\n     pub unsafe fn init(&mut self) { self.0.init() }\n "}, {"sha": "bb72cb0930a7f59508870aac5866e7cc4d85f2ca", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -161,6 +161,8 @@ impl StaticKey {\n         // Additionally a 0-index of a tls key hasn't been seen on windows, so\n         // we just simplify the whole branch.\n         if imp::requires_synchronized_create() {\n+            // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n+            // acquire this mutex reentrantly!\n             static INIT_LOCK: Mutex = Mutex::new();\n             let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);"}, {"sha": "61c6084a25023897c4aa27fec6d6745cc4982e6c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb6275f4fd6cf774e1789fabfacae7248c45021/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=fbb6275f4fd6cf774e1789fabfacae7248c45021", "patch": "@@ -940,6 +940,8 @@ pub struct ThreadId(u64);\n impl ThreadId {\n     // Generate a new unique thread ID.\n     fn new() -> ThreadId {\n+        // We never call `GUARD.init()`, so it is UB to attempt to\n+        // acquire this mutex reentrantly!\n         static GUARD: mutex::Mutex = mutex::Mutex::new();\n         static mut COUNTER: u64 = 0;\n "}]}