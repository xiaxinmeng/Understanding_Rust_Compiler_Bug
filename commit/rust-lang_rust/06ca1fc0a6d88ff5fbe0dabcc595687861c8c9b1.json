{"sha": "06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Y2ExZmMwYTZkODhmZjVmYmUwZGFiY2M1OTU2ODc4NjFjOGM5YjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-01T09:13:54Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-18T13:06:39Z"}, "message": "lint on binding-names that are too similar", "tree": {"sha": "596b7e439533711943c48d0955658d33080ec20f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/596b7e439533711943c48d0955658d33080ec20f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "html_url": "https://github.com/rust-lang/rust/commit/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075040b03488b35ae1ed01cbb38fb716f85d4f93", "url": "https://api.github.com/repos/rust-lang/rust/commits/075040b03488b35ae1ed01cbb38fb716f85d4f93", "html_url": "https://github.com/rust-lang/rust/commit/075040b03488b35ae1ed01cbb38fb716f85d4f93"}], "stats": {"total": 293, "additions": 245, "deletions": 48}, "files": [{"sha": "844408df23c3c0429d64af94595eab6a0cc065b1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -23,6 +23,7 @@ regex_macros = { version = \"0.1.33\", optional = true }\n semver = \"0.2.1\"\n toml = \"0.1\"\n unicode-normalization = \"0.1\"\n+strsim = \"0.4.0\"\n \n [dev-dependencies]\n compiletest_rs = \"0.1.0\""}, {"sha": "2ee4dfc5e6cf5eee407ea73e55a05e25ed65c0ae", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -119,6 +119,7 @@ name\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                                 | allow   | The name is re-bound without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)                     | warn    | defining a method that should be implementing a std trait\n+[similar_names](https://github.com/Manishearth/rust-clippy/wiki#similar_names)                                       | warn    | similarly named items and bindings\n [single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                           | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                               | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead"}, {"sha": "f04ad1d214ae3c9a9be30bdc5bb110845df7539b", "filename": "src/consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -82,7 +82,7 @@ impl Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n+            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => ls == rs && l_sty == r_sty,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked(),\n@@ -145,8 +145,8 @@ impl Hash for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => {\n-                if lsty == rsty {\n+            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => {\n+                if l_sty == r_sty {\n                     Some(ls.cmp(rs))\n                 } else {\n                     None\n@@ -354,6 +354,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n+\n     fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n         where F: Fn(Constant, Constant) -> Option<Constant>\n     {"}, {"sha": "ef6b1f3a2b9fc9998096e3446732945d3987d225", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -31,6 +31,9 @@ extern crate unicode_normalization;\n // for semver check in attrs.rs\n extern crate semver;\n \n+// for levensthein distance\n+extern crate strsim;\n+\n // for regex checking\n extern crate regex_syntax;\n \n@@ -84,6 +87,7 @@ pub mod needless_features;\n pub mod needless_update;\n pub mod new_without_default;\n pub mod no_effect;\n+pub mod non_expressive_names;\n pub mod open_options;\n pub mod overflow_check_conditional;\n pub mod panic;\n@@ -200,6 +204,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n     reg.register_late_lint_pass(box print::PrintLint);\n     reg.register_late_lint_pass(box vec::UselessVec);\n+    reg.register_early_lint_pass(box non_expressive_names::SimilarNames(1));\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n     reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass::default());\n@@ -326,6 +331,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         needless_update::NEEDLESS_UPDATE,\n         new_without_default::NEW_WITHOUT_DEFAULT,\n         no_effect::NO_EFFECT,\n+        non_expressive_names::SIMILAR_NAMES,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         panic::PANIC_PARAMS,"}, {"sha": "944dcaeb006e6cf642e5919e7bcf1bf10e581025", "filename": "src/non_expressive_names.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -0,0 +1,150 @@\n+use rustc::lint::*;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::ast::*;\n+use syntax::visit::{self, FnKind};\n+use utils::{span_note_and_lint, in_macro};\n+use strsim::levenshtein;\n+\n+/// **What it does:** This lint warns about names that are very similar and thus confusing\n+///\n+/// **Why is this bad?** It's hard to distinguish between names that differ only by a single character\n+///\n+/// **Known problems:** None?\n+///\n+/// **Example:** `checked_exp` and `checked_expr`\n+declare_lint! {\n+    pub SIMILAR_NAMES,\n+    Warn,\n+    \"similarly named items and bindings\"\n+}\n+\n+pub struct SimilarNames(pub usize);\n+\n+impl LintPass for SimilarNames {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SIMILAR_NAMES)\n+    }\n+}\n+\n+struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n+    names: Vec<(InternedString, Span)>,\n+    cx: &'a EarlyContext<'b>,\n+    limit: usize,\n+}\n+\n+const WHITELIST: &'static [&'static str] = &[\n+    \"lhs\", \"rhs\",\n+];\n+\n+struct SimilarNamesNameVisitor<'a, 'b: 'a, 'c: 'b>(&'a mut SimilarNamesLocalVisitor<'b, 'c>);\n+\n+impl<'v, 'a, 'b, 'c> visit::Visitor<'v> for SimilarNamesNameVisitor<'a, 'b, 'c> {\n+    fn visit_pat(&mut self, pat: &'v Pat) {\n+        if let PatKind::Ident(_, id, _) = pat.node {\n+            self.check_name(id.span, id.node.name);\n+        }\n+        visit::walk_pat(self, pat);\n+    }\n+}\n+\n+impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n+    fn check_name(&mut self, span: Span, name: Name) {\n+        if in_macro(self.0.cx, span) {\n+            return;\n+        }\n+        let interned_name = name.as_str();\n+        if interned_name.chars().any(char::is_uppercase) {\n+            return;\n+        }\n+        if interned_name.chars().count() < 3 {\n+            return;\n+        }\n+        for &allow in WHITELIST {\n+            if interned_name == allow {\n+                return;\n+            }\n+            if interned_name.len() <= allow.len() {\n+                continue;\n+            }\n+            // allow_*\n+            let allow_start = allow.chars().chain(Some('_'));\n+            if interned_name.chars().zip(allow_start).all(|(l, r)| l == r) {\n+                return;\n+            }\n+            // *_allow\n+            let allow_end = Some('_').into_iter().chain(allow.chars());\n+            if interned_name.chars().rev().zip(allow_end.rev()).all(|(l, r)| l == r) {\n+                return;\n+            }\n+        }\n+        for &(ref existing_name, sp) in &self.0.names {\n+            let dist = levenshtein(&interned_name, &existing_name);\n+            // equality is caught by shadow lints\n+            if dist == 0 {\n+                continue;\n+            }\n+            // if they differ enough it's all good\n+            if dist > self.0.limit {\n+                continue;\n+            }\n+            // are we doing stuff like `for item in items`?\n+            if interned_name.starts_with(&**existing_name) ||\n+               existing_name.starts_with(&*interned_name) ||\n+               interned_name.ends_with(&**existing_name) ||\n+               existing_name.ends_with(&*interned_name) {\n+                continue;\n+            }\n+            if dist == 1 {\n+                // are we doing stuff like a_bar, b_bar, c_bar?\n+                if interned_name.chars().next() != existing_name.chars().next() && interned_name.chars().nth(1) == Some('_') {\n+                    continue;\n+                }\n+                // are we doing stuff like foo_x, foo_y, foo_z?\n+                if interned_name.chars().rev().next() != existing_name.chars().rev().next() && interned_name.chars().rev().nth(1) == Some('_') {\n+                    continue;\n+                }\n+            }\n+            span_note_and_lint(self.0.cx, SIMILAR_NAMES, span, \"binding's name is too similar to existing binding\", sp, \"existing binding defined here\");\n+            return;\n+        }\n+        self.0.names.push((interned_name, span));\n+    }\n+}\n+\n+impl<'v, 'a, 'b> visit::Visitor<'v> for SimilarNamesLocalVisitor<'a, 'b> {\n+    fn visit_local(&mut self, local: &'v Local) {\n+        SimilarNamesNameVisitor(self).visit_local(local)\n+    }\n+    fn visit_block(&mut self, blk: &'v Block) {\n+        // ensure scoping rules work\n+        let n = self.names.len();\n+        visit::walk_block(self, blk);\n+        self.names.truncate(n);\n+    }\n+    fn visit_arm(&mut self, arm: &'v Arm) {\n+        let n = self.names.len();\n+        // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n+        SimilarNamesNameVisitor(self).visit_pat(&arm.pats[0]);\n+        self.names.truncate(n);\n+    }\n+    fn visit_item(&mut self, _: &'v Item) {\n+        // do nothing\n+    }\n+}\n+\n+impl EarlyLintPass for SimilarNames {\n+    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, blk: &Block, _: Span, _: NodeId) {\n+        let mut visitor = SimilarNamesLocalVisitor {\n+            names: Vec::new(),\n+            cx: cx,\n+            limit: self.0,\n+        };\n+        // initialize with function arguments\n+        for arg in &decl.inputs {\n+            visit::walk_pat(&mut SimilarNamesNameVisitor(&mut visitor), &arg.pat);\n+        }\n+        // walk all other bindings\n+        visit::walk_block(&mut visitor, blk);\n+    }\n+}"}, {"sha": "1dc1f55b773fc88c6eb2322bed7a44ca1524fe25", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -638,16 +638,16 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n         Lt,\n         Le,\n     };\n-    let (rel, lhs2, rhs2) = match op {\n+    let (rel, normalized_lhs, normalized_rhs) = match op {\n         BiLt => (Rel::Lt, lhs, rhs),\n         BiLe => (Rel::Le, lhs, rhs),\n         BiGt => (Rel::Lt, rhs, lhs),\n         BiGe => (Rel::Le, rhs, lhs),\n         _ => return None,\n     };\n \n-    let lx = detect_extreme_expr(cx, lhs2);\n-    let rx = detect_extreme_expr(cx, rhs2);\n+    let lx = detect_extreme_expr(cx, normalized_lhs);\n+    let rx = detect_extreme_expr(cx, normalized_rhs);\n \n     Some(match rel {\n         Rel::Lt => {"}, {"sha": "bc7bc358a9c0159a730ca08b9f953085518c5a01", "filename": "src/utils/hir.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -67,24 +67,24 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(lmut, ref le), &ExprAddrOf(rmut, ref re)) => lmut == rmut && self.eq_expr(le, re),\n+            (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n             (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n-            (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n-                lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n             (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n-            (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-                !self.ignore_fn && self.eq_expr(lfun, rfun) && self.eq_exprs(largs, rargs)\n+            (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n+                !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             }\n             (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n-            (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-                lfident.node == rfident.node && self.eq_expr(lfexp, rfexp)\n+            (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n+                l_f_ident.node == r_f_ident.node && self.eq_expr(l_f_exp, r_f_exp)\n             }\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n@@ -101,25 +101,25 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             }\n-            (&ExprMethodCall(ref lname, ref ltys, ref largs),\n-             &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+            (&ExprMethodCall(ref l_name, ref l_tys, ref l_args),\n+             &ExprMethodCall(ref r_name, ref r_tys, ref r_args)) => {\n                 // TODO: tys\n-                !self.ignore_fn && lname.node == rname.node && ltys.is_empty() && rtys.is_empty() &&\n-                self.eq_exprs(largs, rargs)\n+                !self.ignore_fn && l_name.node == r_name.node && l_tys.is_empty() && r_tys.is_empty() &&\n+                self.eq_exprs(l_args, r_args)\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n-                both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n+            (&ExprPath(ref l_qself, ref l_subpath), &ExprPath(ref r_qself, ref r_subpath)) => {\n+                both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n             }\n-            (&ExprStruct(ref lpath, ref lf, ref lo), &ExprStruct(ref rpath, ref rf, ref ro)) => {\n-                self.eq_path(lpath, rpath) &&\n+            (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n+                self.eq_path(l_path, r_path) &&\n                     both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                     over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n-            (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n+            (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n-            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => lop == rop && self.eq_expr(le, re),\n+            (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n@@ -179,16 +179,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n-            (&TyVec(ref lvec), &TyVec(ref rvec)) => self.eq_ty(lvec, rvec),\n+            (&TyVec(ref l_vec), &TyVec(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyFixedLengthVec(ref lt, ref ll), &TyFixedLengthVec(ref rt, ref rl)) => {\n                 self.eq_ty(lt, rt) && self.eq_expr(ll, rl)\n             }\n-            (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && self.eq_ty(&*lmut.ty, &*rmut.ty),\n-            (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n-                lrmut.mutbl == rrmut.mutbl && self.eq_ty(&*lrmut.ty, &*rrmut.ty)\n+            (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n+            (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n+                l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n-                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(lpath, rpath)\n+            (&TyPath(ref lq, ref l_path), &TyPath(ref rq, ref r_path)) => {\n+                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(l_path, r_path)\n             }\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,"}, {"sha": "de303a35f17304199c9aaaba42d075121fd4ef59", "filename": "src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -102,8 +102,8 @@ macro_rules! if_let_chain {\n \n /// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n /// isn't).\n-pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n-    sp1.expn_id != sp2.expn_id\n+pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n+    rhs.expn_id != lhs.expn_id\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {"}, {"sha": "3660fb41919051ed07c51112497176972b70877f", "filename": "tests/compile-fail/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fapprox_const.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #[deny(approx_constant)]\n-#[allow(unused, shadow_unrelated)]\n+#[allow(unused, shadow_unrelated, similar_names)]\n fn main() {\n     let my_e = 2.7182; //~ERROR approximate value of `f{32, 64}::E` found\n     let almost_e = 2.718; //~ERROR approximate value of `f{32, 64}::E` found"}, {"sha": "8454a471513dfe1b8585c5ca2ea9ec6682ace32c", "filename": "tests/compile-fail/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdrop_ref.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(drop_ref)]\n-#![allow(toplevel_ref_arg)]\n+#![allow(toplevel_ref_arg, similar_names)]\n \n use std::mem::drop;\n "}, {"sha": "b111439ba51052f1c289096b151fe17a2519980d", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -88,7 +88,7 @@ impl Unrelated {\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity)]\n+#[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity, similar_names)]\n fn main() {\n     const MAX_LEN: usize = 42;\n "}, {"sha": "4fd0203b91282efed1e250d7f378cc37b6b55b6c", "filename": "tests/compile-fail/len_zero.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -92,38 +92,38 @@ fn main() {\n         println!(\"Nor should this!\");\n     }\n \n-    let hie = HasIsEmpty;\n-    if hie.len() == 0 {\n+    let has_is_empty = HasIsEmpty;\n+    if has_is_empty.len() == 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION hie.is_empty()\n+        //~|SUGGESTION has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    if hie.len() != 0 {\n+    if has_is_empty.len() != 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION !hie.is_empty()\n+        //~|SUGGESTION !has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    if hie.len() > 0 {\n+    if has_is_empty.len() > 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION !hie.is_empty()\n+        //~|SUGGESTION !has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    assert!(!hie.is_empty());\n+    assert!(!has_is_empty.is_empty());\n \n-    let wie : &WithIsEmpty = &Wither;\n-    if wie.len() == 0 {\n+    let with_is_empty: &WithIsEmpty = &Wither;\n+    if with_is_empty.len() == 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION wie.is_empty()\n+        //~|SUGGESTION with_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    assert!(!wie.is_empty());\n+    assert!(!with_is_empty.is_empty());\n \n-    let hwie = HasWrongIsEmpty;\n-    if hwie.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n+    let has_wrong_is_empty = HasWrongIsEmpty;\n+    if has_wrong_is_empty.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n         println!(\"Or this!\");\n     }\n }"}, {"sha": "b1a8f6cf77671284a4a4c320ce48a0dadf588d06", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -286,6 +286,7 @@ fn or_fun_call() {\n     //~|SUGGESTION btree.entry(42).or_insert_with(String::new);\n }\n \n+#[allow(similar_names)]\n fn main() {\n     use std::io;\n "}, {"sha": "a9a06f4234f48997ba76ec04b87f24d18e260236", "filename": "tests/compile-fail/non_expressive_names.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1/tests%2Fcompile-fail%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnon_expressive_names.rs?ref=06ca1fc0a6d88ff5fbe0dabcc595687861c8c9b1", "patch": "@@ -0,0 +1,37 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let specter: i32;\n+    let spectre: i32;\n+\n+    let apple: i32; //~ NOTE: existing binding defined here\n+    let bpple: i32; //~ ERROR: name is too similar\n+    let cpple: i32; //~ ERROR: name is too similar\n+\n+    let a_bar: i32;\n+    let b_bar: i32;\n+    let c_bar: i32;\n+\n+    let foo_x: i32;\n+    let foo_y: i32;\n+\n+    let rhs: i32;\n+    let lhs: i32;\n+\n+    let bla_rhs: i32;\n+    let bla_lhs: i32;\n+\n+    let blubrhs: i32; //~ NOTE: existing binding defined here\n+    let blublhs: i32; //~ ERROR: name is too similar\n+\n+    let blubx: i32; //~ NOTE: existing binding defined here\n+    let bluby: i32; //~ ERROR: name is too similar\n+\n+    let cake: i32; //~ NOTE: existing binding defined here\n+    let caked: i32; //~ NOTE: existing binding defined here\n+    let cakes: i32; //~ ERROR: name is too similar\n+    let coke: i32; //~ ERROR: name is too similar\n+}"}]}