{"sha": "7101ce9127d805e602ea3fa75d5bbea4bf1e5dce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMDFjZTkxMjdkODA1ZTYwMmVhM2ZhNzVkNWJiZWE0YmYxZTVkY2U=", "commit": {"author": {"name": "oli", "email": "oli@uhura.edef.eu", "date": "2020-10-26T13:04:52Z"}, "committer": {"name": "oli", "email": "oli@uhura.edef.eu", "date": "2020-10-26T13:04:52Z"}, "message": "Deduplicate span and dbg_scope adjustment", "tree": {"sha": "9d2a75896980b69bd704591cc1e11bcc2be5e859", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d2a75896980b69bd704591cc1e11bcc2be5e859"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce", "html_url": "https://github.com/rust-lang/rust/commit/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce/comments", "author": null, "committer": null, "parents": [{"sha": "f8aae504692295095454fa221c2ca1a7a46fb3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8aae504692295095454fa221c2ca1a7a46fb3c5", "html_url": "https://github.com/rust-lang/rust/commit/f8aae504692295095454fa221c2ca1a7a46fb3c5"}], "stats": {"total": 37, "additions": 19, "deletions": 18}, "files": [{"sha": "4e0396a15a6466f341efbb4260b70b4eb443567d", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7101ce9127d805e602ea3fa75d5bbea4bf1e5dce/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=7101ce9127d805e602ea3fa75d5bbea4bf1e5dce", "patch": "@@ -83,10 +83,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n \n     fn dbg_loc(&self, source_info: mir::SourceInfo) -> Option<Bx::DILocation> {\n+        let (dbg_scope, inlined_at, span) = self.adjusted_span_and_dbg_scope(source_info)?;\n+        Some(self.cx.dbg_loc(dbg_scope, inlined_at, span))\n+    }\n+\n+    fn adjusted_span_and_dbg_scope(\n+        &self,\n+        source_info: mir::SourceInfo,\n+    ) -> Option<(Bx::DIScope, Option<Bx::DILocation>, Span)> {\n         let span = self.adjust_span_for_debugging(source_info.span);\n         let scope = &self.debug_context.as_ref()?.scopes[source_info.scope];\n-        let dbg_scope = scope.adjust_dbg_scope_for_span(self.cx, span);\n-        Some(self.cx.dbg_loc(dbg_scope, scope.inlined_at, span))\n+        Some((scope.adjust_dbg_scope_for_span(self.cx, span), scope.inlined_at, span))\n     }\n \n     /// In order to have a good line stepping behavior in debugger, we overwrite debug\n@@ -148,18 +155,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let name = kw::Invalid;\n                 let decl = &self.mir.local_decls[local];\n                 let dbg_var = if full_debug_info {\n-                    self.debug_context.as_ref().map(|debug_context| {\n-                        // FIXME(eddyb) is this `+ 1` needed at all?\n-                        let kind = VariableKind::ArgumentVariable(arg_index + 1);\n+                    self.adjusted_span_and_dbg_scope(decl.source_info).map(\n+                        |(dbg_scope, _, span)| {\n+                            // FIXME(eddyb) is this `+ 1` needed at all?\n+                            let kind = VariableKind::ArgumentVariable(arg_index + 1);\n \n-                        let arg_ty = self.monomorphize(&decl.ty);\n+                            let arg_ty = self.monomorphize(&decl.ty);\n \n-                        let span = self.adjust_span_for_debugging(decl.source_info.span);\n-                        let scope = &debug_context.scopes[decl.source_info.scope];\n-                        let dbg_scope = scope.adjust_dbg_scope_for_span(self.cx, span);\n-\n-                        self.cx.create_dbg_var(name, arg_ty, dbg_scope, kind, span)\n-                    })\n+                            self.cx.create_dbg_var(name, arg_ty, dbg_scope, kind, span)\n+                        },\n+                    )\n                 } else {\n                     None\n                 };\n@@ -313,15 +318,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n         for var in &self.mir.var_debug_info {\n             let dbg_scope_and_span = if full_debug_info {\n-                self.debug_context.as_ref().map(|debug_context| {\n-                    let span = self.adjust_span_for_debugging(var.source_info.span);\n-                    let scope = &debug_context.scopes[var.source_info.scope];\n-                    (scope.adjust_dbg_scope_for_span(self.cx, span), span)\n-                })\n+                self.adjusted_span_and_dbg_scope(var.source_info)\n             } else {\n                 None\n             };\n-            let dbg_var = dbg_scope_and_span.map(|(dbg_scope, span)| {\n+            let dbg_var = dbg_scope_and_span.map(|(dbg_scope, _, span)| {\n                 let place = var.place;\n                 let var_ty = self.monomorphized_place_ty(place.as_ref());\n                 let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg"}]}