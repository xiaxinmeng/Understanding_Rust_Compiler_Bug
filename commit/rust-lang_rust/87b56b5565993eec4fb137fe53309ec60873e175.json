{"sha": "87b56b5565993eec4fb137fe53309ec60873e175", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YjU2YjU1NjU5OTNlZWM0ZmIxMzdmZTUzMzA5ZWM2MDg3M2UxNzU=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-11T18:09:54Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-15T22:35:27Z"}, "message": "Allow `[a, b, ..., c]` transcription patterns in MBE.", "tree": {"sha": "c830a5a9b3936ad7daf91e06eae947bb8fe57175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c830a5a9b3936ad7daf91e06eae947bb8fe57175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b56b5565993eec4fb137fe53309ec60873e175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b56b5565993eec4fb137fe53309ec60873e175", "html_url": "https://github.com/rust-lang/rust/commit/87b56b5565993eec4fb137fe53309ec60873e175", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b56b5565993eec4fb137fe53309ec60873e175/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2f9b150529384e29db337bcdd37a72b797f6aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f9b150529384e29db337bcdd37a72b797f6aae", "html_url": "https://github.com/rust-lang/rust/commit/d2f9b150529384e29db337bcdd37a72b797f6aae"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "2a0e7859b10ac1aede517aebc4ae39441554041a", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/87b56b5565993eec4fb137fe53309ec60873e175/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b56b5565993eec4fb137fe53309ec60873e175/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=87b56b5565993eec4fb137fe53309ec60873e175", "patch": "@@ -92,19 +92,21 @@ type match_result = option::t[arb_depth[matchable]];\n type selector = fn(&matchable) -> match_result ;\n \n fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n-    -> {fixed: [@expr], rep: option::t[@expr]} {\n+    -> {pre: [@expr], rep: option::t[@expr], post: [@expr]} {\n     let idx: uint = 0u;\n+    let res = none;\n     for elt: @expr  in elts {\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n               ast::mac_ellipsis. {\n-                let last = ivec::len(elts) - 1u;\n-                if idx != last {\n-                    cx.span_fatal(m.span, \"ellipses must occur last\");\n+                if res != none {\n+                    cx.span_fatal(m.span, \"only one ellipsis allowed\");\n                 }\n-                ret {fixed: ivec::slice(elts, 0u, last - 1u),\n-                     rep: some(elts.(last - 1u))};\n+                res = some({pre: ivec::slice(elts, 0u, idx - 1u),\n+                            rep: some(elts.(idx - 1u)),\n+                            post: ivec::slice(elts, idx + 1u,\n+                                              ivec::len(elts))});\n               }\n               _ { }\n             }\n@@ -113,7 +115,10 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n         }\n         idx += 1u;\n     }\n-    ret {fixed: elts, rep: none};\n+    ret alt res {\n+      some(val) { val }\n+      none. { {pre: elts, rep: none, post: ~[]} }\n+    }\n }\n \n fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &[T]) ->\n@@ -275,8 +280,8 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     recur: fn(&@expr) -> @expr , exprs: [@expr])\n     -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n-      {fixed: fixed, rep: repeat_me_maybe} {\n-        let res = ivec::map(recur, fixed);\n+      {pre: pre, rep: repeat_me_maybe, post: post} {\n+        let res = ivec::map(recur, pre);\n         alt repeat_me_maybe {\n           none. {}\n           some(repeat_me) {\n@@ -324,6 +329,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             }\n           }\n         }\n+        res += ivec::map(recur, post);\n         ret res;\n       }\n     }\n@@ -440,14 +446,25 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n           expr_path(p_pth) { p_t_s_r_path(cx, p_pth, s, b); }\n           expr_vec(p_elts, _, _) {\n             alt elts_to_ell(cx, p_elts) {\n-              {fixed: fixed, rep: some(repeat_me)} {\n-                if(ivec::len(fixed) > 0u) {\n-                    p_t_s_r_actual_vector(cx, fixed, true, s, b);\n+              {pre: pre, rep: some(repeat_me), post: post} {\n+                p_t_s_r_length(cx, ivec::len(pre) + ivec::len(post),\n+                               true, s, b);\n+                if(ivec::len(pre) > 0u) {\n+                    p_t_s_r_actual_vector(cx, pre, true, s, b);\n+                }\n+                p_t_s_r_ellipses(cx, repeat_me, ivec::len(pre), s, b);\n+\n+                if(ivec::len(post) > 0u) {\n+                    cx.span_unimpl(e.span,\n+                                   \"matching after `...` not yet supported\");\n                 }\n-                p_t_s_r_ellipses(cx, repeat_me, ivec::len(fixed), s, b);\n               }\n-              {fixed: fixed, rep: none.} {\n-                p_t_s_r_actual_vector(cx, fixed, false, s, b);\n+              {pre: pre, rep: none., post: post} {\n+                if post != ~[] {\n+                    cx.bug(\"elts_to_ell provided an invalid result\");\n+                }\n+                p_t_s_r_length(cx, ivec::len(pre), false, s, b);\n+                p_t_s_r_actual_vector(cx, pre, false, s, b);\n               }\n             }\n           }\n@@ -606,17 +623,17 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n               compose_sels(s, bind select(cx, repeat_me, offset, _)), b);\n }\n \n-fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n-                         s: &selector, b: &binders) {\n-    fn len_select(cx: &ext_ctxt, m: &matchable, repeat_after: bool, len: uint)\n+\n+fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n+                  b: &binders) {\n+    fn len_select(cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint)\n         -> match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _, _) {\n                     let actual_len = ivec::len(arg_elts);\n-                    if (repeat_after && actual_len >= len)\n-                        || actual_len == len {\n+                    if (at_least && actual_len >= len) || actual_len == len {\n                         some(leaf(match_exact))\n                     } else { none }\n                   }\n@@ -627,10 +644,11 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n             }\n     }\n     b.literal_ast_matchers +=\n-        ~[compose_sels(s, bind len_select(cx, _, repeat_after,\n-                                          ivec::len(elts)))];\n-\n+        ~[compose_sels(s, bind len_select(cx, _, at_least, len))];\n+}\n \n+fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n+                         s: &selector, b: &binders) {\n     let idx: uint = 0u;\n     while idx < ivec::len(elts) {\n         fn select(cx: &ext_ctxt, m: &matchable, idx: uint) -> match_result {\n@@ -678,7 +696,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                 alt mac.node {\n                   mac_invoc(pth, invoc_arg, body) {\n                     alt path_to_ident(pth) {\n-                      some(id) { \n+                      some(id) {\n                         alt macro_name {\n                           none. { macro_name = some(id); }\n                           some(other_id) {"}, {"sha": "72b37557102240007fd560d045738daf42c7f1d8", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87b56b5565993eec4fb137fe53309ec60873e175/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b56b5565993eec4fb137fe53309ec60873e175/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=87b56b5565993eec4fb137fe53309ec60873e175", "patch": "@@ -43,4 +43,9 @@ fn main() {\n \n     assert (#transcr_mixed[10, 5, 4, 3, 2, 1] == 210);\n \n+    #macro[[#surround[pre, [xs, ...], post],\n+            [pre, xs, ..., post]]];\n+\n+    assert (#surround[1, [2,3,4], 5] == [1,2,3,4,5]);\n+\n }\n\\ No newline at end of file"}]}