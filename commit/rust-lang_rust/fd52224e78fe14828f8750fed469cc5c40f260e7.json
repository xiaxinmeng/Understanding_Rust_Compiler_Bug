{"sha": "fd52224e78fe14828f8750fed469cc5c40f260e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNTIyMjRlNzhmZTE0ODI4Zjg3NTBmZWQ0NjljYzVjNDBmMjYwZTc=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-20T13:20:54Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-09-24T19:03:55Z"}, "message": "Remove dead code from librustc", "tree": {"sha": "97f5021c1d6eec93e20e99365b5808773c27ee89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f5021c1d6eec93e20e99365b5808773c27ee89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd52224e78fe14828f8750fed469cc5c40f260e7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd52224e78fe14828f8750fed469cc5c40f260e7", "html_url": "https://github.com/rust-lang/rust/commit/fd52224e78fe14828f8750fed469cc5c40f260e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd52224e78fe14828f8750fed469cc5c40f260e7/comments", "author": null, "committer": null, "parents": [{"sha": "5bcc154dffb0aa58eef270f9e7396ec440101ca5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bcc154dffb0aa58eef270f9e7396ec440101ca5", "html_url": "https://github.com/rust-lang/rust/commit/5bcc154dffb0aa58eef270f9e7396ec440101ca5"}], "stats": {"total": 545, "additions": 1, "deletions": 544}, "files": [{"sha": "633248562a5538f5c099ae1bdb54f6e5abf3f598", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -397,13 +397,6 @@ pub fn get_cc_prog(sess: &Session) -> String {\n     }.to_string()\n }\n \n-pub fn get_ar_prog(sess: &Session) -> String {\n-    match sess.opts.cg.ar {\n-        Some(ref ar) => (*ar).clone(),\n-        None => \"ar\".to_string()\n-    }\n-}\n-\n pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}"}, {"sha": "20842beae16d55b510503d266b09e3ded29eed82", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -114,7 +114,6 @@ register_diagnostics!(\n     E0102,\n     E0103,\n     E0104,\n-    E0105,\n     E0106,\n     E0107,\n     E0108,\n@@ -152,7 +151,6 @@ register_diagnostics!(\n     E0144,\n     E0145,\n     E0146,\n-    E0147,\n     E0148,\n     E0151,\n     E0152,"}, {"sha": "f40d6d47281c16bcdb6d37a036572603ba67baff", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -662,30 +662,6 @@ impl tr for MethodOrigin {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding vtable_res\n-\n-pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                         rbml_w: &mut Encoder,\n-                         dr: &typeck::vtable_res) {\n-    // can't autogenerate this code because automatic code of\n-    // ty::t doesn't work, and there is no way (atm) to have\n-    // hand-written encoding routines combine with auto-generated\n-    // ones. perhaps we should fix this.\n-    encode_vec_per_param_space(\n-        rbml_w, dr,\n-        |rbml_w, param_tables| encode_vtable_param_res(ecx, rbml_w,\n-                                                       param_tables))\n-}\n-\n-pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n-                     rbml_w: &mut Encoder,\n-                     param_tables: &typeck::vtable_param_res) {\n-    rbml_w.emit_from_vec(param_tables.as_slice(), |rbml_w, vtable_origin| {\n-        Ok(encode_vtable_origin(ecx, rbml_w, vtable_origin))\n-    }).unwrap()\n-}\n-\n pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n                                    kind: ty::UnboxedClosureKind) {\n     use serialize::Encoder;\n@@ -714,55 +690,6 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n     }).unwrap()\n }\n \n-pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                            rbml_w: &mut Encoder,\n-                            vtable_origin: &typeck::vtable_origin) {\n-    use serialize::Encoder;\n-\n-    rbml_w.emit_enum(\"vtable_origin\", |rbml_w| {\n-        match *vtable_origin {\n-          typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n-            rbml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    Ok(rbml_w.emit_def_id(def_id))\n-                });\n-                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n-                    Ok(rbml_w.emit_substs(ecx, substs))\n-                });\n-                rbml_w.emit_enum_variant_arg(2u, |rbml_w| {\n-                    Ok(encode_vtable_res(ecx, rbml_w, vtable_res))\n-                })\n-            })\n-          }\n-          typeck::vtable_param(pn, bn) => {\n-            rbml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    pn.encode(rbml_w)\n-                });\n-                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n-                    rbml_w.emit_uint(bn)\n-                })\n-            })\n-          }\n-          typeck::vtable_unboxed_closure(def_id) => {\n-              rbml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n-                                       2u,\n-                                       1u,\n-                                       |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    Ok(rbml_w.emit_def_id(def_id))\n-                })\n-              })\n-          }\n-          typeck::vtable_error => {\n-            rbml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_rbml_w| {\n-                Ok(())\n-            })\n-          }\n-        }\n-    }).unwrap()\n-}\n-\n pub trait vtable_decoder_helpers {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut Self| -> T)"}, {"sha": "d3d6e7508f0775052e2cf7339e2e3abe18c91484", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -16,7 +16,6 @@ use middle::cfg;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n-use middle::def;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty;\n@@ -386,11 +385,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn is_subscope_of(&self, r_sub: ast::NodeId, r_sup: ast::NodeId)\n-                          -> bool {\n-        self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n-    }\n-\n     pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n@@ -404,82 +398,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> mc::cmt {\n-        match self.mc().cat_expr_unadjusted(expr) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_expr_autoderefd(&self,\n-                               expr: &ast::Expr,\n-                               adj: &ty::AutoAdjustment)\n-                               -> mc::cmt {\n-        let r = match *adj {\n-            ty::AdjustDerefRef(\n-                ty::AutoDerefRef {\n-                    autoderefs: autoderefs, ..}) => {\n-                self.mc().cat_expr_autoderefd(expr, autoderefs)\n-            }\n-            ty::AdjustAddEnv(..) => {\n-                // no autoderefs\n-                self.mc().cat_expr_unadjusted(expr)\n-            }\n-        };\n-\n-        match r {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span,\n-                                       \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_def(&self,\n-                   id: ast::NodeId,\n-                   span: Span,\n-                   ty: ty::t,\n-                   def: def::Def)\n-                   -> mc::cmt {\n-        match self.mc().cat_def(id, span, ty, def) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(span, \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_captured_var(&self,\n-                            closure_id: ast::NodeId,\n-                            closure_span: Span,\n-                            upvar_def: def::Def)\n-                            -> mc::cmt {\n-        // Create the cmt for the variable being borrowed, from the\n-        // caller's perspective\n-        let var_id = upvar_def.def_id().node;\n-        let var_ty = ty::node_id_to_type(self.tcx, var_id);\n-        self.cat_def(closure_id, closure_span, var_ty, upvar_def)\n-    }\n-\n-    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n-        Rc::new(mc::cmt_ {\n-            cat: mc::cat_discr(cmt.clone(), match_id),\n-            mutbl: cmt.mutbl.inherit(),\n-            ..*cmt\n-        })\n-    }\n-\n-    pub fn cat_pattern(&self,\n-                       cmt: mc::cmt,\n-                       pat: &ast::Pat,\n-                       op: |mc::cmt, &ast::Pat|) {\n-        let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n-        assert!(r.is_ok());\n-    }\n-\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,"}, {"sha": "d8597c08b454c470d0d0050ca27963638ee70c29", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -568,22 +568,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         }\n     }\n \n-    pub fn each_path_moved_by(&self,\n-                              id: ast::NodeId,\n-                              f: |&Move, &LoanPath| -> bool)\n-                              -> bool {\n-        /*!\n-         * Iterates through each path moved by `id`\n-         */\n-\n-        self.dfcx_moves.each_gen_bit(id, |index| {\n-            let move = self.move_data.moves.borrow();\n-            let move = move.get(index);\n-            let moved_path = move.path;\n-            f(move, &*self.move_data.path_loan_path(moved_path))\n-        })\n-    }\n-\n     pub fn kind_of_move_of_path(&self,\n                                 id: ast::NodeId,\n                                 loan_path: &Rc<LoanPath>)\n@@ -665,13 +649,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         })\n     }\n \n-    pub fn is_assignee(&self,\n-                       id: ast::NodeId)\n-                       -> bool {\n-        //! True if `id` is the id of the LHS of an assignment\n-        self.move_data.assignee_ids.borrow().iter().any(|x| x == &id)\n-    }\n-\n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n                               loan_path: &Rc<LoanPath>,"}, {"sha": "f5d4ece3bcccf859ff39983f1005ef8f113ceccd", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -355,17 +355,6 @@ pub fn check_freevar_bounds(cx: &Context, fn_span: Span, sp: Span, ty: ty::t,\n     });\n }\n \n-pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n-                               bounds: ty::BuiltinBounds) {\n-    check_builtin_bounds(cx, ty, bounds, |missing| {\n-        span_err!(cx.tcx.sess, sp, E0147,\n-            \"cannot pack type `{}`, which does not fulfill `{}`, as a trait bounded by {}\",\n-            ty_to_string(cx.tcx, ty),\n-            missing.user_string(cx.tcx),\n-            bounds.user_string(cx.tcx));\n-    });\n-}\n-\n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents({})={}\",\n            ty_to_string(cx.tcx, ty),"}, {"sha": "3b831dd6847a1b07414a10ce06654a5df736cfce", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -735,10 +735,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    pub fn cat_deref_obj<N:ast_node>(&self, node: &N, base_cmt: cmt) -> cmt {\n-        self.cat_deref_common(node, base_cmt, 0, ty::mk_nil(), false)\n-    }\n-\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt,"}, {"sha": "b55678e3a5078ca08dc9dff83cc6506cd252db5e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -195,11 +195,6 @@ impl Substs {\n         }\n     }\n \n-    pub fn with_method_from(self, substs: &Substs) -> Substs {\n-        self.with_method(Vec::from_slice(substs.types.get_slice(FnSpace)),\n-                         Vec::from_slice(substs.regions().get_slice(FnSpace)))\n-    }\n-\n     pub fn with_method(self,\n                        m_types: Vec<ty::t>,\n                        m_regions: Vec<ty::Region>)\n@@ -292,15 +287,6 @@ impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T:Clone> VecPerParamSpace<T> {\n-    pub fn push_all(&mut self, space: ParamSpace, values: &[T]) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        for t in values.iter() {\n-            self.push(space, t.clone());\n-        }\n-    }\n-}\n-\n impl<T> VecPerParamSpace<T> {\n     fn limits(&self, space: ParamSpace) -> (uint, uint) {\n         match space {\n@@ -348,14 +334,6 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n-        let mut result = VecPerParamSpace::empty();\n-        for t in t.into_iter() {\n-            result.push(space(&t), t);\n-        }\n-        result\n-    }\n-\n     /// Appends `value` to the vector associated with `space`.\n     ///\n     /// Unlike the `push` method in `Vec`, this should not be assumed\n@@ -435,12 +413,6 @@ impl<T> VecPerParamSpace<T> {\n         &self.get_slice(space)[index]\n     }\n \n-    pub fn get_mut<'a>(&'a mut self,\n-                       space: ParamSpace,\n-                       index: uint) -> &'a mut T {\n-        &mut self.get_mut_slice(space)[index]\n-    }\n-\n     pub fn iter<'a>(&'a self) -> Items<'a,T> {\n         self.content.iter()\n     }\n@@ -476,30 +448,6 @@ impl<T> VecPerParamSpace<T> {\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n-    pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        /*!\n-         * Executes the map but in reverse order. For hacky reasons, we rely\n-         * on this in table.\n-         *\n-         * FIXME(#5527) -- order of eval becomes irrelevant with newer\n-         * trait reform, which features an idempotent algorithm that\n-         * can be run to a fixed point\n-         */\n-\n-        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();\n-\n-        // NB: Calling foo.rev().map().rev() causes the calls to map\n-        // to occur in the wrong order. This was somewhat surprising\n-        // to me, though it makes total sense.\n-        fns.reverse();\n-\n-        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();\n-        selfs.reverse();\n-        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();\n-        tys.reverse();\n-        VecPerParamSpace::new(tys, selfs, fns)\n-    }\n-\n     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n         // FIXME (#15418): this does two traversals when in principle\n         // one would suffice.  i.e. change to use `move_iter`."}, {"sha": "12a2815cfef3488a8f1143fc786d680be7b4278d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -21,7 +21,6 @@ use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::foreign;\n use middle::ty;\n-use middle::typeck;\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -285,37 +284,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-// Used to identify cached monomorphized functions\n-#[deriving(PartialEq, Eq, Hash)]\n-pub struct MonoParamId {\n-    pub subst: ty::t,\n-}\n-\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<ty::t>\n }\n-\n-pub fn make_vtable_id(_ccx: &CrateContext,\n-                      origin: &typeck::vtable_origin)\n-                      -> MonoId {\n-    match origin {\n-        &typeck::vtable_static(impl_id, ref substs, _) => {\n-            MonoId {\n-                def: impl_id,\n-                params: substs.types.clone()\n-            }\n-        }\n-\n-        &typeck::vtable_unboxed_closure(def_id) => {\n-            MonoId {\n-                def: def_id,\n-                params: subst::VecPerParamSpace::empty(),\n-            }\n-        }\n-\n-        // can't this be checked at the callee?\n-        _ => fail!(\"make_vtable_id needs vtable_static\")\n-    }\n-}"}, {"sha": "f1499cb91663ff4a2f3d482a3ab940dbfc56c871", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -1915,13 +1915,6 @@ pub fn fold_ty(cx: &ctxt, t0: t, fldop: |t| -> t) -> t {\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n-                           -> t {\n-    ty_fold::RegionFolder::general(cx,\n-                                   |r| { fldr(r); r },\n-                                   |t| { fldt(t); t }).fold_ty(ty)\n-}\n-\n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: uint,\n@@ -3551,58 +3544,6 @@ pub fn unsize_ty(cx: &ctxt,\n     }\n }\n \n-impl AutoRef {\n-    pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n-        match *self {\n-            ty::AutoPtr(r, m, None) => ty::AutoPtr(f(r), m, None),\n-            ty::AutoPtr(r, m, Some(ref a)) => ty::AutoPtr(f(r), m, Some(box a.map_region(f))),\n-            ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n-            ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n-            ty::AutoUnsafe(m, None) => ty::AutoUnsafe(m, None),\n-            ty::AutoUnsafe(m, Some(ref a)) => ty::AutoUnsafe(m, Some(box a.map_region(f))),\n-        }\n-    }\n-}\n-\n-pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n-                                            origin: &typeck::MethodOrigin)\n-                                            -> VecPerParamSpace<TypeParameterDef>\n-                                            where T: mc::Typer<'tcx> {\n-    match *origin {\n-        typeck::MethodStatic(did) => {\n-            ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n-        }\n-        typeck::MethodStaticUnboxedClosure(did) => {\n-            let def_id = typer.unboxed_closures()\n-                              .borrow()\n-                              .find(&did)\n-                              .expect(\"method_call_type_param_defs: didn't \\\n-                                       find unboxed closure\")\n-                              .kind\n-                              .trait_did(typer.tcx());\n-            lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n-        }\n-        typeck::MethodTypeParam(typeck::MethodParam{\n-            trait_ref: ref trait_ref,\n-            method_num: n_mth,\n-            ..\n-        }) |\n-        typeck::MethodTraitObject(typeck::MethodObject{\n-                trait_ref: ref trait_ref,\n-                method_num: n_mth,\n-                ..\n-        }) => {\n-            match ty::trait_item(typer.tcx(), trait_ref.def_id, n_mth) {\n-                ty::MethodTraitItem(method) => method.generics.types.clone(),\n-                ty::TypeTraitItem(_) => {\n-                    typer.tcx().sess.bug(\"method_call_type_param_defs() \\\n-                                          called on associated type\")\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().find(&expr.id) {\n         Some(&def) => def,\n@@ -3821,22 +3762,6 @@ pub fn impl_or_trait_item_idx(id: ast::Ident, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.ident() == id)\n }\n \n-/// Returns a vector containing the indices of all type parameters that appear\n-/// in `ty`.  The vector may contain duplicates.  Probably should be converted\n-/// to a bitset or some other representation.\n-pub fn param_tys_in_type(ty: t) -> Vec<ParamTy> {\n-    let mut rslt = Vec::new();\n-    walk_ty(ty, |ty| {\n-        match get(ty).sty {\n-          ty_param(p) => {\n-            rslt.push(p);\n-          }\n-          _ => ()\n-        }\n-    });\n-    rslt\n-}\n-\n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n@@ -4706,17 +4631,6 @@ pub fn is_tuple_struct(cx: &ctxt, did: ast::DefId) -> bool {\n     !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n }\n \n-pub fn lookup_struct_field(cx: &ctxt,\n-                           parent: ast::DefId,\n-                           field_id: ast::DefId)\n-                        -> field_ty {\n-    let r = lookup_struct_fields(cx, parent);\n-    match r.iter().find(|f| f.id.node == field_id.node) {\n-        Some(t) => t.clone(),\n-        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n-    }\n-}\n-\n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)"}, {"sha": "2359f9d72d2b734ac7b779cdd66378ea68b617f0", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -77,17 +77,3 @@ pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n       }\n     }\n }\n-\n-pub fn coerce_with_fn(fcx: &FnCtxt,\n-                      sp: Span,\n-                      expected: ty::t,\n-                      expr: &ast::Expr,\n-                      handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n-    let expr_ty = fcx.expr_ty(expr);\n-    match fcx.mk_assignty(expr, expr_ty, expected) {\n-      result::Ok(()) => { /* ok */ }\n-      result::Err(ref err) => {\n-        handle_err(sp, expected, expr_ty, err);\n-      }\n-    }\n-}"}, {"sha": "821cf629d835c489f52caf5a4bc54a358eebddde", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -1901,18 +1901,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn method_ty_substs(&self, id: ast::NodeId) -> subst::Substs {\n-        match self.inh.method_map.borrow().find(&MethodCall::expr(id)) {\n-            Some(method) => method.substs.clone(),\n-            None => {\n-                self.tcx().sess.bug(\n-                    format!(\"no method entry for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_string(id),\n-                            self.tag()).as_slice());\n-            }\n-        }\n-    }\n-\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::ItemSubsts|) {\n@@ -1984,18 +1972,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    pub fn report_mismatched_return_types(&self,\n-                                          sp: Span,\n-                                          e: ty::t,\n-                                          a: ty::t,\n-                                          err: &ty::type_err) {\n-        // Derived error\n-        if ty::type_is_error(e) || ty::type_is_error(a) {\n-            return;\n-        }\n-        self.infcx().report_mismatched_types(sp, e, a, err)\n-    }\n-\n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n                                    e: ty::t,\n@@ -4663,24 +4639,6 @@ impl Repr for Expectation {\n     }\n }\n \n-pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n-    if !type_is_uint(fcx, sp, t) {\n-        fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected `uint` type, found `{}`\",\n-                    actual)\n-        }, t, None);\n-    }\n-}\n-\n-pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n-    if !type_is_integral(fcx, sp, t) {\n-        fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected integral type, found `{}`\",\n-                    actual)\n-        }, t, None);\n-    }\n-}\n-\n pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n@@ -5602,51 +5560,6 @@ pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_integral(typ_s);\n-}\n-\n-pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_uint(typ_s);\n-}\n-\n-pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_scalar(typ_s);\n-}\n-\n-pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_char(typ_s);\n-}\n-\n-pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_bare_fn(typ_s);\n-}\n-\n-pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_floating_point(typ_s);\n-}\n-\n-pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_unsafe_ptr(typ_s);\n-}\n-\n-pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_region_ptr(typ_s);\n-}\n-\n-pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n-}\n-\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "85fe0a42c49d3330dcc185a4b6c5e2274bf0a25f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -213,26 +213,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n     repeating_scope: ast::NodeId,\n }\n \n-/// When entering a function, we can derive relationships from the\n-/// signature between various regions and type parameters. Consider\n-/// a function like:\n-///\n-///     fn foo<'a, A>(x: &'a A) { ... }\n-///\n-/// Here, we can derive that `A` must outlive `'a`, because otherwise\n-/// the caller would be illegal. We record this by storing a series of\n-/// pairs (in this case, `('a, A)`). These pairs will be consulted\n-/// later during regionck.\n-///\n-/// In the case of nested fns, additional relationships may be\n-/// derived.  The result is a link list walking up the stack (hence\n-/// the `previous` field).\n-#[deriving(Clone)]\n-pub struct RegionSubParamConstraints<'a> {\n-    pairs: Vec<(ty::Region, ty::ParamTy)>,\n-    previous: Option<&'a RegionSubParamConstraints<'a>>,\n-}\n-\n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long"}, {"sha": "61ff86afcec3f0745e974c8d3fb065c743c9b0c4", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -25,17 +25,6 @@ use syntax::codemap::Span;\n use util::ppaux::UserString;\n use util::ppaux::Repr;\n \n-/// When reporting an error about a failed trait obligation, it's nice\n-/// to include some context indicating why we were checking that\n-/// obligation in the first place. The span is often enough but\n-/// sometimes it's not. Currently this enum is a bit of a hack and I\n-/// suspect it should be carried in the obligation or more deeply\n-/// integrated somehow.\n-pub enum ErrorReportingContext {\n-    GenericContext,\n-    ImplSupertraitCheck,\n-}\n-\n pub fn check_object_cast(fcx: &FnCtxt,\n                          cast_expr: &ast::Expr,\n                          source_expr: &ast::Expr,"}, {"sha": "f734aa09e4a126743a1d4dd162fc6fb15bd0388c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -22,7 +22,6 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::vtable_res;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux::Repr;\n@@ -67,17 +66,6 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_object_cast_map();\n }\n \n-pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n-                        span: Span,\n-                        vtable_res: &vtable_res)\n-                        -> vtable_res {\n-    let errors = Cell::new(false); // nobody cares\n-    let mut resolver = Resolver::from_infcx(infcx,\n-                                            &errors,\n-                                            ResolvingImplRes(span));\n-    vtable_res.resolve_in(&mut resolver)\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Writerback context. This visitor walks the AST, checking the\n // fn-specific tables to find references to types or regions. It\n@@ -413,10 +401,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n            reason: ResolveReason)\n            -> Resolver<'cx, 'tcx>\n     {\n-        Resolver { infcx: fcx.infcx(),\n-                   tcx: fcx.tcx(),\n-                   writeback_errors: &fcx.writeback_errors,\n-                   reason: reason }\n+        Resolver::from_infcx(fcx.infcx(), &fcx.writeback_errors, reason)\n     }\n \n     fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,"}, {"sha": "d1b754155f8c7a63689abb504864e94ab139371b", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -66,12 +66,6 @@ pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n-#[deriving(PartialEq,Clone)]\n-pub struct Bounds<T> {\n-    pub lb: Bound<T>,\n-    pub ub: Bound<T>\n-}\n-\n pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\""}, {"sha": "008ca6c0771655bb523e534a18558fb26468adab", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -525,17 +525,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn max_regions(&self,\n-                       a: Region,\n-                       b: Region)\n-                       -> Option<Region>\n-    {\n-        match self.glb_concrete_regions(a, b) {\n-            Ok(r) => Some(r),\n-            Err(_) => None\n-        }\n-    }\n-\n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n         match *self.values.borrow() {\n             None => {"}, {"sha": "0a4fd90765c039b4808f5e2bb46708e8216b15c0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd52224e78fe14828f8750fed469cc5c40f260e7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fd52224e78fe14828f8750fed469cc5c40f260e7", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::check::regionmanip;\n-use middle::typeck::infer;\n \n use std::rc::Rc;\n use syntax::abi;\n@@ -1181,14 +1180,6 @@ impl Repr for ast::FloatTy {\n     }\n }\n \n-impl<T:Repr> Repr for infer::Bounds<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"({} <= {})\",\n-                self.lb.repr(tcx),\n-                self.ub.repr(tcx))\n-    }\n-}\n-\n impl Repr for ty::ExplicitSelfCategory {\n     fn repr(&self, _: &ctxt) -> String {\n         explicit_self_category_to_str(self).to_string()"}]}