{"sha": "164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NDYxOWE4Y2ZlNmQzNzZkMjViZDNhNmE5YTVmMjg1NmM4ZGU2NGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-20T22:21:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-20T22:21:53Z"}, "message": "Auto merge of #38499 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 29 pull requests\n\n- Successful merges: #37761, #38006, #38131, #38150, #38158, #38171, #38208, #38215, #38236, #38245, #38289, #38302, #38315, #38346, #38388, #38395, #38398, #38418, #38432, #38451, #38463, #38468, #38470, #38471, #38472, #38478, #38486, #38493, #38498\n- Failed merges: #38271, #38483", "tree": {"sha": "d8e0dfb4fc85d0b7e5d1ce431f46d5494845d163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8e0dfb4fc85d0b7e5d1ce431f46d5494845d163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "html_url": "https://github.com/rust-lang/rust/commit/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3038f30f96fe366e910f9a02521c5a06e5cdc653", "url": "https://api.github.com/repos/rust-lang/rust/commits/3038f30f96fe366e910f9a02521c5a06e5cdc653", "html_url": "https://github.com/rust-lang/rust/commit/3038f30f96fe366e910f9a02521c5a06e5cdc653"}, {"sha": "d5f1c6e67cea5e50de2def2f171f5cf7424ea054", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f1c6e67cea5e50de2def2f171f5cf7424ea054", "html_url": "https://github.com/rust-lang/rust/commit/d5f1c6e67cea5e50de2def2f171f5cf7424ea054"}], "stats": {"total": 4141, "additions": 2615, "deletions": 1526}, "files": [{"sha": "d01ec07b4244e665b076c540969ecc5b22d6f9f7", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.15.0\n+CFG_RELEASE_NUM=1.16.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release"}, {"sha": "01a19a0cca862dd797f44ff1458ba5f1894b590e", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -87,6 +87,7 @@ dependencies = [\n name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n+ \"build_helper 0.1.0\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\","}, {"sha": "9cab6c423f5f98d1df57071a9d2019ea72a0db43", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -25,6 +25,8 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n+#![deny(warnings)]\n+\n extern crate bootstrap;\n \n use std::env;"}, {"sha": "a53bbe22eb94cbd9a2c5adfe2cdb20dec667d0dc", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,8 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n+#![deny(warnings)]\n+\n extern crate bootstrap;\n \n use std::env;"}, {"sha": "89d297760e2864c8345b876d87112be2fb5c2998", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -81,7 +81,7 @@ def verify(path, sha_path, verbose):\n     with open(path, \"rb\") as f:\n         found = hashlib.sha256(f.read()).hexdigest()\n     with open(sha_path, \"r\") as f:\n-        expected, _ = f.readline().split()\n+        expected = f.readline().split()[0]\n     verified = found == expected\n     if not verified:\n         print(\"invalid checksum:\\n\"\n@@ -146,7 +146,7 @@ class RustBuild(object):\n     def download_stage0(self):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, self.stage0_rustc_date())\n-        cargo_cache = os.path.join(cache_dst, self.stage0_cargo_date())\n+        cargo_cache = os.path.join(cache_dst, self.stage0_cargo_rev())\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n         if not os.path.exists(cargo_cache):\n@@ -179,21 +179,17 @@ def download_stage0(self):\n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n             self.print_what_it_means_to_bootstrap()\n-            channel = self.stage0_cargo_channel()\n-            filename = \"cargo-{}-{}.tar.gz\".format(channel, self.build)\n-            url = \"https://static.rust-lang.org/cargo-dist/\" + self.stage0_cargo_date()\n+            filename = \"cargo-nightly-{}.tar.gz\".format(self.build)\n+            url = \"https://s3.amazonaws.com/rust-lang-ci/cargo-builds/\" + self.stage0_cargo_rev()\n             tarball = os.path.join(cargo_cache, filename)\n             if not os.path.exists(tarball):\n                 get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n             unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n             with open(self.cargo_stamp(), 'w') as f:\n-                f.write(self.stage0_cargo_date())\n+                f.write(self.stage0_cargo_rev())\n \n-    def stage0_cargo_date(self):\n-        return self._cargo_date\n-\n-    def stage0_cargo_channel(self):\n-        return self._cargo_channel\n+    def stage0_cargo_rev(self):\n+        return self._cargo_rev\n \n     def stage0_rustc_date(self):\n         return self._rustc_date\n@@ -217,7 +213,7 @@ def cargo_out_of_date(self):\n         if not os.path.exists(self.cargo_stamp()) or self.clean:\n             return True\n         with open(self.cargo_stamp(), 'r') as f:\n-            return self.stage0_cargo_date() != f.read()\n+            return self.stage0_cargo_rev() != f.read()\n \n     def bin_root(self):\n         return os.path.join(self.build_dir, self.build, \"stage0\")\n@@ -469,7 +465,7 @@ def main():\n \n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n-    rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n+    rb._cargo_rev = data['cargo']\n \n     start_time = time()\n "}, {"sha": "e7b0afeb8ce630447d596704c771aa8656922cc9", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,6 +13,8 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n+extern crate build_helper;\n+\n use std::collections::HashSet;\n use std::env;\n use std::fmt;\n@@ -543,7 +545,7 @@ pub fn distcheck(build: &Build) {\n     build.run(&mut cmd);\n     build.run(Command::new(\"./configure\")\n                      .current_dir(&dir));\n-    build.run(Command::new(\"make\")\n+    build.run(Command::new(build_helper::make(&build.config.build))\n                      .arg(\"check\")\n                      .current_dir(&dir));\n }"}, {"sha": "6b86e537b7d22098e8e2b2e47e1a77e8a04acd2f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -113,6 +113,7 @@ pub struct Target {\n #[derive(RustcDecodable, Default)]\n struct TomlConfig {\n     build: Option<Build>,\n+    install: Option<Install>,\n     llvm: Option<Llvm>,\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n@@ -135,6 +136,12 @@ struct Build {\n     python: Option<String>,\n }\n \n+/// TOML representation of various global install decisions.\n+#[derive(RustcDecodable, Default, Clone)]\n+struct Install {\n+    prefix: Option<String>,\n+}\n+\n /// TOML representation of how the LLVM build is configured.\n #[derive(RustcDecodable, Default)]\n struct Llvm {\n@@ -258,6 +265,10 @@ impl Config {\n         set(&mut config.submodules, build.submodules);\n         set(&mut config.vendor, build.vendor);\n \n+        if let Some(ref install) = toml.install {\n+            config.prefix = install.prefix.clone();\n+        }\n+\n         if let Some(ref llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => {\n@@ -275,6 +286,7 @@ impl Config {\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n         }\n+\n         if let Some(ref rust) = toml.rust {\n             set(&mut config.rust_debug_assertions, rust.debug_assertions);\n             set(&mut config.rust_debuginfo, rust.debuginfo);"}, {"sha": "5fc095137c793e0101d102ae64b22790ed3a29bd", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -100,6 +100,14 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n+# =============================================================================\n+# General install configuration options\n+# =============================================================================\n+[install]\n+\n+# Instead of installing to /usr/local, install to this path instead.\n+#prefix = \"/path/to/install\"\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "6e3174ed2f6d00cc6939c9f61f96414fe9634dd2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -346,8 +346,14 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n }\n \n /// Creates the `rust-src` installer component and the plain source tarball\n-pub fn rust_src(build: &Build) {\n+pub fn rust_src(build: &Build, host: &str) {\n     println!(\"Dist src\");\n+\n+    if host != build.config.build {\n+        println!(\"\\tskipping, not a build host\");\n+        return\n+    }\n+\n     let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n     let name = format!(\"rust-src-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-image\", name));"}, {"sha": "b2412fbb3c84400310798a96175d79862a4b6b18", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -280,7 +280,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n \n         Flags {\n             verbose: m.opt_count(\"v\"),\n-            stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            stage: stage,\n             keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n             build: m.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()"}, {"sha": "665e0c67b7f6c1153bb32104d799449d74a0ef04", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -64,6 +64,8 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n+#![deny(warnings)]\n+\n extern crate build_helper;\n extern crate cmake;\n extern crate filetime;\n@@ -721,7 +723,8 @@ impl Build {\n     fn llvm_filecheck(&self, target: &str) -> PathBuf {\n         let target_config = self.config.target_config.get(target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.parent().unwrap().join(exe(\"FileCheck\", target))\n+            let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n+            Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", target))\n         } else {\n             let base = self.llvm_out(&self.config.build).join(\"build\");\n             let exe = exe(\"FileCheck\", target);"}, {"sha": "0d83a79cf32d96c3a815007352711039298449e3", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -66,7 +66,7 @@ tidy:\n check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n-\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-gnu\n+\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n \n \n .PHONY: dist"}, {"sha": "5d543419fc9b6a78b8331728caf46d2f02e31aa3", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -143,7 +143,7 @@ pub fn check(build: &mut Build) {\n     // Externally configured LLVM requires FileCheck to exist\n     let filecheck = build.llvm_filecheck(&build.config.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n-        panic!(\"filecheck executable {:?} does not exist\", filecheck);\n+        panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n     for target in build.config.target.iter() {"}, {"sha": "c5898c1119a670d31ae710f31afb78152aca780c", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -267,16 +267,18 @@ pub fn build_rules(build: &Build) -> Rules {\n         // nothing to do for debuginfo tests\n     } else if build.config.build.contains(\"apple\") {\n         rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .default(true)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-lldb\", \"debuginfo\"));\n     } else {\n         rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n+             .default(true)\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").host(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n@@ -455,7 +457,7 @@ pub fn build_rules(build: &Build) -> Rules {\n     for (krate, path, default) in krates(\"test_shim\") {\n         rules.doc(&krate.doc_step, path)\n              .dep(|s| s.name(\"libtest\"))\n-             .default(default && build.config.docs)\n+             .default(default && build.config.compiler_docs)\n              .run(move |s| doc::test(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"rustc-main\") {\n@@ -496,7 +498,7 @@ pub fn build_rules(build: &Build) -> Rules {\n     rules.dist(\"dist-src\", \"src\")\n          .default(true)\n          .host(true)\n-         .run(move |_| dist::rust_src(build));\n+         .run(move |s| dist::rust_src(build, s.target));\n     rules.dist(\"dist-docs\", \"src/doc\")\n          .default(true)\n          .dep(|s| s.name(\"default:doc\"))\n@@ -820,7 +822,16 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             let hosts = if self.build.flags.host.len() > 0 {\n                 &self.build.flags.host\n             } else {\n-                &self.build.config.host\n+                if kind == Kind::Dist {\n+                    // For 'dist' steps we only distribute artifacts built from\n+                    // the build platform, so only consider that in the hosts\n+                    // array.\n+                    // NOTE: This relies on the fact that the build triple is\n+                    // always placed first, as done in `config.rs`.\n+                    &self.build.config.host[..1]\n+                } else {\n+                    &self.build.config.host\n+                }\n             };\n             let targets = if self.build.flags.target.len() > 0 {\n                 &self.build.flags.target"}, {"sha": "d0d588f46a7549a9402f404b395aebe0a2868dde", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -47,6 +47,8 @@ pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n         None\n     } else if target.contains(\"musl\") {\n         Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"openbsd\") {\n+        Some(PathBuf::from(\"ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -61,6 +63,16 @@ pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n     }\n }\n \n+pub fn make(host: &str) -> PathBuf {\n+    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n+        host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n+        host.contains(\"openbsd\") {\n+        PathBuf::from(\"gmake\")\n+    } else {\n+        PathBuf::from(\"make\")\n+    }\n+}\n+\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,"}, {"sha": "8c2c8d2a9db5a352bf9b9d444efab6fffa7135de", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -28,15 +28,23 @@ docker \\\n mkdir -p $HOME/.cargo\n mkdir -p $root_dir/obj\n \n+args=\n+if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n+    args=\"$args --env SCCACHE_BUCKET=$SCCACHE_BUCKET\"\n+    args=\"$args --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\"\n+    args=\"$args --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\"\n+else\n+    mkdir -p $HOME/.cache/sccache\n+    args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\"\n+fi\n+\n exec docker \\\n   run \\\n   --volume \"$root_dir:/checkout:ro\" \\\n   --volume \"$root_dir/obj:/checkout/obj\" \\\n   --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n-  --env SCCACHE_BUCKET=$SCCACHE_BUCKET \\\n-  --env AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n-  --env AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \\\n+  $args \\\n   --env CARGO_HOME=/cargo \\\n   --env LOCAL_USER_ID=`id -u` \\\n   --volume \"$HOME/.cargo:/cargo\" \\"}, {"sha": "2c3db87d9fb1fdd716f22aa489483e44a983ea34", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,7 +12,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   ccache \\\n   libssl-dev \\\n   sudo \\\n-  xz-utils\n+  xz-utils \\\n+  pkg-config\n \n ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\"}, {"sha": "b5a91a170d8ed478b71b0bedf1a4cfde5d600a20", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1731,7 +1731,8 @@ of an item to see whether it should be allowed or not. This is where privacy\n warnings are generated, or otherwise \"you used a private item of another module\n and weren't allowed to.\"\n \n-By default, everything in Rust is *private*, with one exception. Enum variants\n+By default, everything in Rust is *private*, with two exceptions: Associated\n+items in a `pub` Trait are public by default; Enum variants\n in a `pub` enum are also public by default. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n "}, {"sha": "60b7875a97c84dd0cb01acadadda12371ce58abe", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -151,7 +151,7 @@ fn main() {\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n \n     run(&mut cmd);\n-    let mut make = Command::new(\"make\");\n+    let mut make = Command::new(build_helper::make(&host));\n     make.current_dir(&build_dir)\n         .arg(\"build_lib_static\");\n "}, {"sha": "34674e3a0bd3098da987525b68812ba805970817", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -74,53 +74,89 @@ pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n-/// An iterator over a BTreeSet's items.\n+/// An iterator over a `BTreeSet`'s items.\n+///\n+/// This structure is created by the [`iter`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`iter`]: struct.BTreeSet.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     iter: Keys<'a, T, ()>,\n }\n \n-/// An owning iterator over a BTreeSet's items.\n+/// An owning iterator over a `BTreeSet`'s items.\n+///\n+/// This structure is created by the `into_iter` method on [`BTreeSet`]\n+/// [`BTreeSet`] (provided by the `IntoIterator` trait).\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     iter: ::btree_map::IntoIter<T, ()>,\n }\n \n-/// An iterator over a sub-range of BTreeSet's items.\n+/// An iterator over a sub-range of `BTreeSet`'s items.\n+///\n+/// This structure is created by the [`range`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`range`]: struct.BTreeSet.html#method.range\n pub struct Range<'a, T: 'a> {\n     iter: ::btree_map::Range<'a, T, ()>,\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n+///\n+/// This structure is created by the [`difference`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`difference`]: struct.BTreeSet.html#method.difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n+///\n+/// This structure is created by the [`symmetric_difference`] method on\n+/// [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n+///\n+/// This structure is created by the [`intersection`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`intersection`]: struct.BTreeSet.html#method.intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n+///\n+/// This structure is created by the [`union`] method on [`BTreeSet`].\n+///\n+/// [`BTreeSet`]: struct.BTreeSet.html\n+/// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {\n-    /// Makes a new BTreeSet with a reasonable choice of B.\n+    /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n     /// # Examples\n     ///\n@@ -137,21 +173,32 @@ impl<T: Ord> BTreeSet<T> {\n }\n \n impl<T> BTreeSet<T> {\n-    /// Gets an iterator over the BTreeSet's contents.\n+    /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set_iter = set.iter();\n+    /// assert_eq!(set_iter.next(), Some(&1));\n+    /// assert_eq!(set_iter.next(), Some(&2));\n+    /// assert_eq!(set_iter.next(), Some(&3));\n+    /// assert_eq!(set_iter.next(), None);\n+    /// ```\n     ///\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n+    /// Values returned by the iterator are returned in ascending order:\n     ///\n-    /// let v: Vec<_> = set.iter().cloned().collect();\n-    /// assert_eq!(v, [1, 2, 3, 4]);\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<usize> = [3, 1, 2].iter().cloned().collect();\n+    /// let mut set_iter = set.iter();\n+    /// assert_eq!(set_iter.next(), Some(&1));\n+    /// assert_eq!(set_iter.next(), Some(&2));\n+    /// assert_eq!(set_iter.next(), Some(&3));\n+    /// assert_eq!(set_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {"}, {"sha": "b5e6669220535282c1694e44c79264c970e62540", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1496,10 +1496,10 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n /// The algorithm identifies strictly descending and non-descending subsequences, which are called\n /// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n /// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n-/// satisfied, for every `i` in `0 .. runs.len() - 2`:\n+/// satisfied:\n ///\n-/// 1. `runs[i].len > runs[i + 1].len`\n-/// 2. `runs[i].len > runs[i + 1].len + runs[i + 2].len`\n+/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n+/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut compare: F)"}, {"sha": "99c407e5273eae922249ca45ee325e9c8f2028cd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -501,6 +501,8 @@ impl<T, E> Result<T, E> {\n \n     /// Returns an iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -512,6 +514,8 @@ impl<T, E> Result<T, E> {\n     /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -520,6 +524,8 @@ impl<T, E> Result<T, E> {\n \n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -535,6 +541,8 @@ impl<T, E> Result<T, E> {\n     /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -848,6 +856,8 @@ impl<T, E> IntoIterator for Result<T, E> {\n \n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n+    /// The iterator yields one value if the result is [`Ok`], otherwise none.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -861,6 +871,8 @@ impl<T, E> IntoIterator for Result<T, E> {\n     /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, []);\n     /// ```\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n         IntoIter { inner: self.ok() }\n@@ -893,8 +905,13 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n \n /// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n ///\n+/// The iterator yields one value if the result is [`Ok`], otherwise none.\n+///\n+/// Created by [`Result::iter`].\n+///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html\n+/// [`Result::iter`]: enum.Result.html#method.iter\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n@@ -934,8 +951,11 @@ impl<'a, T> Clone for Iter<'a, T> {\n \n /// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n ///\n+/// Created by [`Result::iter_mut`].\n+///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html\n+/// [`Result::iter_mut`]: enum.Result.html#method.iter_mut\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n@@ -968,9 +988,12 @@ impl<'a, T> FusedIterator for IterMut<'a, T> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n \n-/// An iterator over the value in a [`Ok`] variant of a [`Result`]. This struct is\n-/// created by the [`into_iter`] method on [`Result`][`Result`] (provided by\n-/// the [`IntoIterator`] trait).\n+/// An iterator over the value in a [`Ok`] variant of a [`Result`].\n+///\n+/// The iterator yields one value if the result is [`Ok`], otherwise none.\n+///\n+/// This struct is created by the [`into_iter`] method on\n+/// [`Result`][`Result`] (provided by the [`IntoIterator`] trait).\n ///\n /// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html"}, {"sha": "e0a49e2ae45d0b895af72f3018d6276e00106125", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -33,6 +33,7 @@\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n+use borrow::Borrow;\n use cmp::Ordering::{self, Less, Equal, Greater};\n use cmp;\n use fmt;\n@@ -100,15 +101,17 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize>\n-        where Self::Item: Ord;\n+    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize>\n+        where Self::Item: Borrow<Q>,\n+              Q: Ord;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn binary_search_by<'a, F>(&'a self, f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> Ordering;\n     #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, f: F) -> Result<usize, usize>\n+    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord;\n+              B: Borrow<Q>,\n+              Q: Ord;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len(&self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -493,8 +496,8 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[m-n..]\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        self.binary_search_by(|p| p.cmp(x))\n+    fn binary_search<Q: ?Sized>(&self, x: &Q) -> Result<usize, usize> where T: Borrow<Q>, Q: Ord {\n+        self.binary_search_by(|p| p.borrow().cmp(x))\n     }\n \n     #[inline]\n@@ -522,11 +525,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,\n-              B: Ord\n+              B: Borrow<Q>,\n+              Q: Ord\n     {\n-        self.binary_search_by(|k| f(k).cmp(b))\n+        self.binary_search_by(|k| f(k).borrow().cmp(b))\n     }\n }\n "}, {"sha": "d2b94db689bc45c63b3bd1de3049739c45736e6e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -418,7 +418,7 @@ to see something like:\n \n     Hir(foo) -> Collect(bar)\n     Collect(bar) -> TypeckItemBody(bar)\n-    \n+\n That first edge looks suspicious to you. So you set\n `RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n then observe the backtrace. Voila, bug fixed!\n@@ -440,6 +440,4 @@ To achieve this, the HIR map will detect if the def-id originates in\n an inlined node and add a dependency to a suitable `MetaData` node\n instead. If you are reading a HIR node and are not sure if it may be\n inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n-whether the node is inlined or not and do the right thing.  You can\n-also use `tcx.map.is_inlined_def_id()` and\n-`tcx.map.is_inlined_node_id()` to test.\n+whether the node is inlined or not and do the right thing."}, {"sha": "f6a22e47cf21278051fd3f11fc5ab474cab25303", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -40,7 +40,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n@@ -51,7 +50,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(impl_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n             self.visitor.visit_impl_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "1655c716b6bfa59dac2c36c52420a055b115e29d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1236,6 +1236,23 @@ struct Foo<'a, T: 'a> {\n     foo: &'a T\n }\n ```\n+\n+To see why this is important, consider the case where `T` is itself a reference\n+(e.g., `T = &str`). If we don't include the restriction that `T: 'a`, the\n+following code would be perfectly legal:\n+\n+```compile_fail,E0309\n+struct Foo<'a, T> {\n+    foo: &'a T\n+}\n+\n+fn main() {\n+    let v = \"42\".to_string();\n+    let f = Foo{foo: &v};\n+    drop(v);\n+    println!(\"{}\", f.foo); // but we've already dropped v!\n+}\n+```\n \"##,\n \n E0310: r##\""}, {"sha": "cbf162cc1366ef0401a061f1a7506c39ecea898c", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -120,9 +120,7 @@ impl fmt::Debug for DefId {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                if let Some(def_path) = tcx.opt_def_path(*self) {\n-                    write!(f, \" => {}\", def_path.to_string(tcx))?;\n-                }\n+                write!(f, \" => {}\", tcx.def_path(*self).to_string(tcx))?;\n             }\n             Ok(())\n         })?;"}, {"sha": "186d6f626509fd0b0daf5f37ddeefa42d516ab1a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -365,7 +365,6 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n     visitor.visit_id(macro_def.id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n-    walk_opt_name(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n "}, {"sha": "e8c3492705a3f95da1e4886b661479e9748a27c6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -433,13 +433,19 @@ impl<'a> LoweringContext<'a> {\n                           segment: &PathSegment,\n                           param_mode: ParamMode)\n                           -> hir::PathSegment {\n-        let parameters = match segment.parameters {\n-            PathParameters::AngleBracketed(ref data) => {\n-                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                hir::AngleBracketedParameters(data)\n+        let parameters = if let Some(ref parameters) = segment.parameters {\n+            match **parameters {\n+                PathParameters::AngleBracketed(ref data) => {\n+                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                    hir::AngleBracketedParameters(data)\n+                }\n+                PathParameters::Parenthesized(ref data) => {\n+                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                }\n             }\n-            PathParameters::Parenthesized(ref data) =>\n-                hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        } else {\n+            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n+            hir::AngleBracketedParameters(data)\n         };\n \n         hir::PathSegment {\n@@ -987,8 +993,6 @@ impl<'a> LoweringContext<'a> {\n             attrs: self.lower_attrs(&m.attrs),\n             id: m.id,\n             span: m.span,\n-            imported_from: m.imported_from.map(|x| x.name),\n-            allow_internal_unstable: m.allow_internal_unstable,\n             body: m.body.clone().into(),\n         }\n     }"}, {"sha": "45988886a608a30ff7ede1d35d39ca5096d63270", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -11,7 +11,6 @@\n use super::*;\n \n use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n@@ -47,8 +46,6 @@ impl<'ast> NodeCollector<'ast> {\n     pub fn extend(krate: &'ast Crate,\n                   parent: &'ast InlinedItem,\n                   parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n                   map: Vec<MapEntry<'ast>>)\n                   -> NodeCollector<'ast> {\n         let mut collector = NodeCollector {\n@@ -58,7 +55,6 @@ impl<'ast> NodeCollector<'ast> {\n             ignore_nested_items: true\n         };\n \n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n         collector.insert_entry(parent_node, RootInlinedParent(parent));\n \n         collector"}, {"sha": "256aee342a3fc448f83637f02a78d7401df22c3f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 212, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -9,12 +9,7 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-\n-use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-\n-use middle::cstore::InlinedItem;\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -23,9 +18,6 @@ use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n-    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n-    // crate.\n-    hir_crate: Option<&'a hir::Crate>,\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n@@ -40,43 +32,16 @@ pub struct MacroInvocationData {\n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n-            hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n             visit_macro_invoc: None,\n         }\n     }\n \n-    pub fn extend(parent_node: NodeId,\n-                  parent_def_path: DefPath,\n-                  parent_def_id: DefId,\n-                  definitions: &'a mut Definitions)\n-                  -> Self {\n-        let mut collector = DefCollector::new(definitions);\n-\n-        assert_eq!(parent_def_path.krate, parent_def_id.krate);\n-        let root_path = Box::new(InlinedRootPath {\n-            data: parent_def_path.data,\n-            def_id: parent_def_id,\n-        });\n-\n-        let def = collector.create_def(parent_node, DefPathData::InlinedRoot(root_path));\n-        collector.parent_def = Some(def);\n-\n-        collector\n-    }\n-\n     pub fn collect_root(&mut self) {\n         let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n-\n-        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-    }\n-\n-    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n-        self.hir_crate = Some(krate);\n-        ii.visit(self);\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n@@ -114,16 +79,6 @@ impl<'a> DefCollector<'a> {\n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let hir::ExprClosure(..) = expr.node {\n-            return;\n-        }\n-\n-        self.create_def(expr.id, DefPathData::Initializer);\n-    }\n-\n     fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -324,169 +279,3 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n     }\n }\n-\n-// We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n-        // note however that we override `visit_body` below\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_body(&mut self, id: hir::ExprId) {\n-        if let Some(krate) = self.hir_crate {\n-            self.visit_expr(krate.expr(id));\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'ast hir::Item) {\n-        debug!(\"visit_item: {:?}\", i);\n-\n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n-                DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n-            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n-                DefPathData::TypeNs(i.name.as_str()),\n-            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n-                DefPathData::ValueNs(i.name.as_str()),\n-            hir::ItemUse(..) => DefPathData::Misc,\n-        };\n-        let def = self.create_def(i.id, def_data);\n-\n-        self.with_parent(def, |this| {\n-            match i.node {\n-                hir::ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        let variant_def_index =\n-                            this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.as_str()));\n-\n-                        this.with_parent(variant_def_index, |this| {\n-                            for field in v.node.data.fields() {\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(field.name.as_str()));\n-                            }\n-                            if let Some(ref expr) = v.node.disr_expr {\n-                                this.visit_hir_const_integer(expr);\n-                            }\n-                        });\n-                    }\n-                }\n-                hir::ItemStruct(ref struct_def, _) |\n-                hir::ItemUnion(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n-                    }\n-\n-                    for field in struct_def.fields() {\n-                        this.create_def(field.id, DefPathData::Field(field.name.as_str()));\n-                    }\n-                }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n-        let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.name.as_str()));\n-\n-        self.with_parent(def, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n-        });\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name.as_str()));\n-        }\n-\n-        intravisit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n-        let def_data = match ti.node {\n-            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n-                DefPathData::ValueNs(ti.name.as_str()),\n-            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_trait_item(this, ti);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n-        let def_data = match ii.node {\n-            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.name.as_str()),\n-            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ii.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_impl_item(this, ii);\n-        });\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n-            self.visit_hir_const_integer(count);\n-        }\n-\n-        if let hir::ExprClosure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n-            self.visit_hir_const_integer(length);\n-        }\n-        if let hir::TyImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name.as_str()));\n-    }\n-}"}, {"sha": "4f64670f482796bde55b37dda9a0d31df0bf0817", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 127, "deletions": 80, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,22 +8,119 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! For each definition, we track the following data.  A definition\n+//! here is defined somewhat circularly as \"something with a def-id\",\n+//! but it generally corresponds to things like structs, enums, etc.\n+//! There are also some rather random cases (like const initializer\n+//! expressions) that are mostly just leftovers.\n+\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n-/// The definition table containing node definitions\n+/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n+/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n+/// stores the DefIndex of its parent.\n+/// There is one DefPathTable for each crate.\n+#[derive(Clone)]\n+pub struct DefPathTable {\n+    index_to_key: Vec<DefKey>,\n+    key_to_index: FxHashMap<DefKey, DefIndex>,\n+}\n+\n+impl DefPathTable {\n+    fn insert(&mut self, key: DefKey) -> DefIndex {\n+        let index = DefIndex::new(self.index_to_key.len());\n+        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+        self.index_to_key.push(key.clone());\n+        self.key_to_index.insert(key, index);\n+        index\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.index_to_key[index.as_usize()].clone()\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n+        self.key_to_index.get(key).cloned()\n+    }\n+\n+    #[inline(always)]\n+    pub fn contains_key(&self, key: &DefKey) -> bool {\n+        self.key_to_index.contains_key(key)\n+    }\n+\n+    pub fn retrace_path(&self,\n+                        path_data: &[DisambiguatedDefPathData])\n+                        -> Option<DefIndex> {\n+        let root_key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+\n+        let root_index = self.key_to_index\n+                             .get(&root_key)\n+                             .expect(\"no root key?\")\n+                             .clone();\n+\n+        debug!(\"retrace_path: root_index={:?}\", root_index);\n+\n+        let mut index = root_index;\n+        for data in path_data {\n+            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n+            debug!(\"retrace_path: key={:?}\", key);\n+            match self.key_to_index.get(&key) {\n+                Some(&i) => index = i,\n+                None => return None,\n+            }\n+        }\n+\n+        Some(index)\n+    }\n+}\n+\n+\n+impl Encodable for DefPathTable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.index_to_key.encode(s)\n+    }\n+}\n+\n+impl Decodable for DefPathTable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n+        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n+        let key_to_index = index_to_key.iter()\n+                                       .enumerate()\n+                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n+                                       .collect();\n+        Ok(DefPathTable {\n+            index_to_key: index_to_key,\n+            key_to_index: key_to_index,\n+        })\n+    }\n+}\n+\n+\n+/// The definition table containing node definitions.\n+/// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n+/// mapping from NodeIds to local DefIds.\n #[derive(Clone)]\n pub struct Definitions {\n-    data: Vec<DefData>,\n-    key_map: FxHashMap<DefKey, DefIndex>,\n-    node_map: NodeMap<DefIndex>,\n+    table: DefPathTable,\n+    node_to_def_index: NodeMap<DefIndex>,\n+    def_index_to_node: Vec<ast::NodeId>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -50,19 +147,6 @@ pub struct DisambiguatedDefPathData {\n     pub disambiguator: u32\n }\n \n-/// For each definition, we track the following data.  A definition\n-/// here is defined somewhat circularly as \"something with a def-id\",\n-/// but it generally corresponds to things like structs, enums, etc.\n-/// There are also some rather random cases (like const initializer\n-/// expressions) that are mostly just leftovers.\n-#[derive(Clone, Debug)]\n-pub struct DefData {\n-    pub key: DefKey,\n-\n-    /// Local ID within the HIR.\n-    pub node_id: ast::NodeId,\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n     /// the path leading from the crate root to the item\n@@ -77,12 +161,11 @@ impl DefPath {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: CrateNum,\n+    pub fn make<FN>(krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n     {\n-        let mut krate = start_krate;\n         let mut data = vec![];\n         let mut index = Some(start_index);\n         loop {\n@@ -95,13 +178,6 @@ impl DefPath {\n                     assert!(key.parent.is_none());\n                     break;\n                 }\n-                DefPathData::InlinedRoot(ref p) => {\n-                    assert!(key.parent.is_none());\n-                    assert!(!p.def_id.is_local());\n-                    data.extend(p.data.iter().cloned().rev());\n-                    krate = p.def_id.krate;\n-                    break;\n-                }\n                 _ => {\n                     data.push(key.disambiguated_data);\n                     index = key.parent;\n@@ -144,40 +220,13 @@ impl DefPath {\n     }\n }\n \n-/// Root of an inlined item. We track the `DefPath` of the item within\n-/// the original crate but also its def-id. This is kind of an\n-/// augmented version of a `DefPath` that includes a `DefId`. This is\n-/// all sort of ugly but the hope is that inlined items will be going\n-/// away soon anyway.\n-///\n-/// Some of the constraints that led to the current approach:\n-///\n-/// - I don't want to have a `DefId` in the main `DefPath` because\n-///   that gets serialized for incr. comp., and when reloaded the\n-///   `DefId` is no longer valid. I'd rather maintain the invariant\n-///   that every `DefId` is valid, and a potentially outdated `DefId` is\n-///   represented as a `DefPath`.\n-///   - (We don't serialize def-paths from inlined items, so it's ok to have one here.)\n-/// - We need to be able to extract the def-id from inline items to\n-///   make the symbol name. In theory we could retrace it from the\n-///   data, but the metadata doesn't have the required indices, and I\n-///   don't want to write the code to create one just for this.\n-/// - It may be that we don't actually need `data` at all. We'll have\n-///   to see about that.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct InlinedRootPath {\n-    pub data: Vec<DisambiguatedDefPathData>,\n-    pub def_id: DefId,\n-}\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n     /// The crate root (marker)\n     CrateRoot,\n-    /// An inlined root\n-    InlinedRoot(Box<InlinedRootPath>),\n \n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n@@ -219,23 +268,30 @@ impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {\n         Definitions {\n-            data: vec![],\n-            key_map: FxHashMap(),\n-            node_map: NodeMap(),\n+            table: DefPathTable {\n+                index_to_key: vec![],\n+                key_to_index: FxHashMap(),\n+            },\n+            node_to_def_index: NodeMap(),\n+            def_index_to_node: vec![],\n         }\n     }\n \n+    pub fn def_path_table(&self) -> &DefPathTable {\n+        &self.table\n+    }\n+\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n-        self.data.len()\n+        self.def_index_to_node.len()\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.data[index.as_usize()].key.clone()\n+        self.table.def_key(index)\n     }\n \n     pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n-        self.key_map.get(&key).cloned()\n+        self.table.def_index_for_def_key(&key)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n@@ -248,7 +304,7 @@ impl Definitions {\n     }\n \n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_map.get(&node).cloned()\n+        self.node_to_def_index.get(&node).cloned()\n     }\n \n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n@@ -261,8 +317,8 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.data.len());\n-            Some(self.data[def_id.index.as_usize()].node_id)\n+            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n+            Some(self.def_index_to_node[def_id.index.as_usize()])\n         } else {\n             None\n         }\n@@ -277,16 +333,13 @@ impl Definitions {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n \n-        assert!(!self.node_map.contains_key(&node_id),\n+        assert!(!self.node_to_def_index.contains_key(&node_id),\n                 \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n                 node_id,\n                 data,\n-                self.data[self.node_map[&node_id].as_usize()]);\n+                self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert!(parent.is_some() ^ match data {\n-            DefPathData::CrateRoot | DefPathData::InlinedRoot(_) => true,\n-            _ => false,\n-        });\n+        assert!(parent.is_some() ^ (data == DefPathData::CrateRoot));\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match.\n@@ -298,20 +351,18 @@ impl Definitions {\n             }\n         };\n \n-        while self.key_map.contains_key(&key) {\n+        while self.table.contains_key(&key) {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = DefIndex::new(self.data.len());\n-        self.data.push(DefData { key: key.clone(), node_id: node_id });\n-        debug!(\"create_def_with_parent: node_map[{:?}] = {:?}\", node_id, index);\n-        self.node_map.insert(node_id, index);\n-        debug!(\"create_def_with_parent: key_map[{:?}] = {:?}\", key, index);\n-        self.key_map.insert(key, index);\n-\n+        let index = self.table.insert(key);\n+        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n+        self.node_to_def_index.insert(node_id, index);\n+        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n+        self.def_index_to_node.push(node_id);\n \n         index\n     }\n@@ -333,7 +384,6 @@ impl DefPathData {\n \n             Impl |\n             CrateRoot |\n-            InlinedRoot(_) |\n             Misc |\n             ClosureExpr |\n             StructCtor |\n@@ -360,9 +410,6 @@ impl DefPathData {\n             // note that this does not show up in user printouts\n             CrateRoot => \"{{root}}\",\n \n-            // note that this does not show up in user printouts\n-            InlinedRoot(_) => \"{{inlined-root}}\",\n-\n             Impl => \"{{impl}}\",\n             Misc => \"{{?}}\",\n             ClosureExpr => \"{{closure}}\","}, {"sha": "4546f6d8c27e6b64674c9fd166d8498de791c3db", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,7 +13,7 @@ use self::MapEntry::*;\n use self::collector::NodeCollector;\n pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n-                            DisambiguatedDefPathData, InlinedRootPath};\n+                            DisambiguatedDefPathData};\n \n use dep_graph::{DepGraph, DepNode};\n \n@@ -221,22 +221,14 @@ pub struct Map<'ast> {\n     /// plain old integers.\n     map: RefCell<Vec<MapEntry<'ast>>>,\n \n-    definitions: RefCell<Definitions>,\n+    definitions: Definitions,\n \n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n-\n-    /// All def-indices that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n-        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n-    }\n-\n     pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n         id >= self.local_node_id_watermark\n     }\n@@ -262,7 +254,6 @@ impl<'ast> Map<'ast> {\n                     EntryItem(_, item) => {\n                         assert_eq!(id, item.id);\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -278,7 +269,6 @@ impl<'ast> Map<'ast> {\n \n                     EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -392,12 +382,16 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.borrow().len()\n+        self.definitions.len()\n+    }\n+\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_key(def_id.index)\n+        self.definitions.def_key(def_id.index)\n     }\n \n     pub fn def_path_from_id(&self, id: NodeId) -> Option<DefPath> {\n@@ -408,11 +402,11 @@ impl<'ast> Map<'ast> {\n \n     pub fn def_path(&self, def_id: DefId) -> DefPath {\n         assert!(def_id.is_local());\n-        self.definitions.borrow().def_path(def_id.index)\n+        self.definitions.def_path(def_id.index)\n     }\n \n     pub fn def_index_for_def_key(&self, def_key: DefKey) -> Option<DefIndex> {\n-        self.definitions.borrow().def_index_for_def_key(def_key)\n+        self.definitions.def_index_for_def_key(def_key)\n     }\n \n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n@@ -423,11 +417,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n-        self.definitions.borrow().opt_local_def_id(node)\n+        self.definitions.opt_local_def_id(node)\n     }\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n-        self.definitions.borrow().as_local_node_id(def_id)\n+        self.definitions.as_local_node_id(def_id)\n     }\n \n     fn entry_count(&self) -> usize {\n@@ -930,42 +924,29 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = NodeId::new(map.len());\n-    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n-        definitions: RefCell::new(definitions),\n+        definitions: definitions,\n         local_node_id_watermark: local_node_id_watermark,\n-        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n-                              parent_def_path: DefPath,\n-                              parent_def_id: DefId,\n                               ii: InlinedItem,\n                               ii_parent_id: NodeId)\n                               -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n     let ii = map.forest.inlined_items.alloc(ii);\n \n-    let defs = &mut *map.definitions.borrow_mut();\n-    let mut def_collector = DefCollector::extend(ii_parent_id,\n-                                                 parent_def_path.clone(),\n-                                                 parent_def_id,\n-                                                 defs);\n-    def_collector.walk_item(ii, map.krate());\n-\n     let mut collector = NodeCollector::extend(map.krate(),\n                                               ii,\n                                               ii_parent_id,\n-                                              parent_def_path,\n-                                              parent_def_id,\n                                               mem::replace(&mut *map.map.borrow_mut(), vec![]));\n     ii.visit(&mut collector);\n     *map.map.borrow_mut() = collector.map;"}, {"sha": "f52ee35e1757306ae0605e1dd774db9d770398b4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -475,8 +475,6 @@ pub struct MacroDef {\n     pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Name>,\n-    pub allow_internal_unstable: bool,\n     pub body: HirVec<TokenTree>,\n }\n "}, {"sha": "9f9c6fd87aa856f590c83daa3d5c46a0198be2e9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -25,7 +25,7 @@\n use hir::def::{self, Def};\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::{Definitions, DefKey};\n+use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n@@ -336,12 +336,12 @@ pub trait CrateStore<'tcx> {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex>;\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey;\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId>;\n+    fn def_key(&self, def: DefId) -> DefKey;\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -442,12 +442,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n-        None\n-    }\n \n     // impl info\n     fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n@@ -508,8 +502,15 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path_data: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n+        None\n+    }\n+\n+    fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }\n+    fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }"}, {"sha": "f45e86f2f4b9615d32aae1b8c51fb41adf328ff2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -302,9 +302,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n-        }\n+        self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n \n@@ -373,9 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.check_missing_stability(md.id, md.span);\n-        }\n+        self.check_missing_stability(md.id, md.span);\n     }\n }\n "}, {"sha": "36a887e062273b719d31edaa1311fba38432fa2c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -136,6 +136,8 @@ pub struct PerfStats {\n     pub incr_comp_bytes_hashed: Cell<u64>,\n     // The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n+    // The accumulated time spent decoding def path tables from metadata\n+    pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n impl Session {\n@@ -501,6 +503,8 @@ impl Session {\n                  self.perf_stats.incr_comp_hashes_count.get());\n         println!(\"Total time spent computing symbol hashes:      {}\",\n                  duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n+        println!(\"Total time spent decoding DefPath tables:      {}\",\n+                 duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get()));\n     }\n }\n \n@@ -635,6 +639,7 @@ pub fn build_session_(sopts: config::Options,\n             incr_comp_hashes_count: Cell::new(0),\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n+            decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n     };"}, {"sha": "ab8c552d561f6100dc4cde5e5ccd5af1b4fe5788", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -458,11 +458,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err\n     }\n \n+\n+    /// Get the parent trait chain start\n+    fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(\n+                    &data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => Some(format!(\"{}\", parent_trait_ref.0.self_ty())),\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n+\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n                 if let ObligationCauseCode::CompareImplMethodObligation {\n@@ -487,14 +504,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 return;\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-\n-                                let mut err = struct_span_err!(self.tcx.sess, span, E0277,\n-                                    \"the trait bound `{}` is not satisfied\",\n-                                    trait_ref.to_predicate());\n-                                err.span_label(span, &format!(\"the trait `{}` is not implemented \\\n-                                                               for `{}`\",\n-                                                              trait_ref,\n-                                                              trait_ref.self_ty()));\n+                                let (post_message, pre_message) = match self.get_parent_trait_ref(\n+                                    &obligation.cause.code)\n+                                {\n+                                    Some(t) => {\n+                                        (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n+                                    }\n+                                    None => (String::new(), String::new()),\n+                                };\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess,\n+                                    span,\n+                                    E0277,\n+                                    \"the trait bound `{}` is not satisfied{}\",\n+                                    trait_ref.to_predicate(),\n+                                    post_message);\n+                                err.span_label(span,\n+                                               &format!(\"{}the trait `{}` is not \\\n+                                                         implemented for `{}`\",\n+                                                        pre_message,\n+                                                        trait_ref,\n+                                                        trait_ref.self_ty()));\n \n                                 // Try to report a help message\n "}, {"sha": "f24ff98035532222905e7e32733d8f3d1f5b498a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -15,9 +15,9 @@ use session::Session;\n use middle;\n use hir::TraitMap;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as ast_map;\n-use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n+use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n@@ -627,50 +627,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a def-key `key` and a crate `krate`, finds the def-index\n-    /// that `krate` assigned to `key`. This `DefIndex` will always be\n-    /// relative to `krate`.\n-    ///\n-    /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n-                                 -> Option<DefIndex> {\n-        if krate == LOCAL_CRATE {\n-            self.map.def_index_for_def_key(key)\n-        } else {\n-            self.sess.cstore.def_index_for_def_key(krate, key)\n-        }\n-    }\n-\n     pub fn retrace_path(self,\n                         krate: CrateNum,\n                         path_data: &[DisambiguatedDefPathData])\n                         -> Option<DefId> {\n         debug!(\"retrace_path(path={:?}, krate={:?})\", path_data, self.crate_name(krate));\n \n-        let root_key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n-\n-        let root_index = self.def_index_for_def_key(krate, root_key)\n-                             .expect(\"no root key?\");\n-\n-        debug!(\"retrace_path: root_index={:?}\", root_index);\n-\n-        let mut index = root_index;\n-        for data in path_data {\n-            let key = DefKey { parent: Some(index), disambiguated_data: data.clone() };\n-            debug!(\"retrace_path: key={:?}\", key);\n-            match self.def_index_for_def_key(krate, key) {\n-                Some(i) => index = i,\n-                None => return None,\n-            }\n+        if krate == LOCAL_CRATE {\n+            self.map\n+                .definitions()\n+                .def_path_table()\n+                .retrace_path(path_data)\n+                .map(|def_index| DefId { krate: krate, index: def_index })\n+        } else {\n+            self.sess.cstore.retrace_path(krate, path_data)\n         }\n-\n-        Some(DefId { krate: krate, index: index })\n     }\n \n     pub fn type_parameter_def(self,\n@@ -762,11 +733,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  trait_map: TraitMap,\n+                                  resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n-                                  freevars: FreevarMap,\n-                                 maybe_unused_trait_imports: NodeSet,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n@@ -790,7 +759,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            trait_map: trait_map,\n+            trait_map: resolutions.trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -802,8 +771,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            freevars: RefCell::new(freevars),\n-            maybe_unused_trait_imports: maybe_unused_trait_imports,\n+            freevars: RefCell::new(resolutions.freevars),\n+            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),"}, {"sha": "0e4c14029e9b9860b3cc86942ab023c7c0ad96d2", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -160,11 +160,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.push_krate_path(buffer, def_id.krate);\n             }\n \n-            DefPathData::InlinedRoot(ref root_path) => {\n-                assert!(key.parent.is_none());\n-                self.push_item_path(buffer, root_path.def_id);\n-            }\n-\n             DefPathData::Impl => {\n                 self.push_impl_path(buffer, def_id);\n             }"}, {"sha": "4e175e50194c332d446d80c66e195570a6bdc541", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -17,7 +17,7 @@ pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n-use hir::map as ast_map;\n+use hir::{map as ast_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -112,6 +112,13 @@ pub struct CrateAnalysis<'tcx> {\n     pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n+#[derive(Clone)]\n+pub struct Resolutions {\n+    pub freevars: FreevarMap,\n+    pub trait_map: TraitMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n+}\n+\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n@@ -2241,40 +2248,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Convert a `DefId` into its fully expanded `DefPath` (every\n     /// `DefId` is really just an interned def-path).\n     ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    ///\n-    /// This function is only safe to use when you are sure that the\n-    /// full def-path is accessible. Examples that are known to be\n-    /// safe are local def-ids or items; see `opt_def_path` for more\n-    /// details.\n+    /// Note that if `id` is not local to this crate, the result will\n+    //  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n-        self.opt_def_path(id).unwrap_or_else(|| {\n-            bug!(\"could not load def-path for {:?}\", id)\n-        })\n-    }\n-\n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n-    ///\n-    /// When going across crates, we do not save the full info for\n-    /// every cross-crate def-id, and hence we may not always be able\n-    /// to create a def-path. Therefore, this returns\n-    /// `Option<DefPath>` to cover that possibility. It will always\n-    /// return `Some` for local def-ids, however, as well as for\n-    /// items. The problems arise with \"minor\" def-ids like those\n-    /// associated with a pattern, `impl Trait`, or other internal\n-    /// detail to a fn.\n-    ///\n-    /// Note that if `id` is not local to this crate -- or is\n-    /// inlined into this crate -- the result will be a non-local\n-    /// `DefPath`.\n-    pub fn opt_def_path(self, id: DefId) -> Option<ast_map::DefPath> {\n         if id.is_local() {\n-            Some(self.map.def_path(id))\n+            self.map.def_path(id)\n         } else {\n-            self.sess.cstore.relative_def_path(id)\n+            self.sess.cstore.def_path(id)\n         }\n     }\n "}, {"sha": "13333be66f5701a0dbb4c7123e1da9ab05d20cdd", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -267,6 +267,9 @@ pub struct TargetOptions {\n     /// user-defined libraries.\n     pub post_link_args: Vec<String>,\n \n+    /// Extra arguments to pass to the external assembler (when used)\n+    pub asm_args: Vec<String>,\n+\n     /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults\n     /// to \"generic\".\n     pub cpu: String,\n@@ -394,6 +397,7 @@ impl Default for TargetOptions {\n             ar: option_env!(\"CFG_DEFAULT_AR\").unwrap_or(\"ar\").to_string(),\n             pre_link_args: Vec::new(),\n             post_link_args: Vec::new(),\n+            asm_args: Vec::new(),\n             cpu: \"generic\".to_string(),\n             features: \"\".to_string(),\n             dynamic_linking: false,\n@@ -561,6 +565,7 @@ impl Target {\n         key!(late_link_args, list);\n         key!(post_link_objects, list);\n         key!(post_link_args, list);\n+        key!(asm_args, list);\n         key!(cpu);\n         key!(features);\n         key!(dynamic_linking, bool);\n@@ -723,6 +728,7 @@ impl ToJson for Target {\n         target_option_val!(late_link_args);\n         target_option_val!(post_link_objects);\n         target_option_val!(post_link_args);\n+        target_option_val!(asm_args);\n         target_option_val!(cpu);\n         target_option_val!(features);\n         target_option_val!(dynamic_linking);"}, {"sha": "360933c6b669532457f61cf647dccf7a96813bee", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n-use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n+use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n@@ -20,7 +19,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n@@ -59,13 +58,6 @@ use syntax_ext;\n \n use derive_registrar;\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n-    pub freevars: FreevarMap,\n-    pub trait_map: TraitMap,\n-    pub maybe_unused_trait_imports: NodeSet,\n-}\n-\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -864,11 +856,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map,\n                              hir_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "74df1e52bde43143a7dab39a42aee28611022fc9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -15,10 +15,9 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use abort_on_err;\n-use driver::{self, Resolutions};\n+use {abort_on_err, driver};\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;"}, {"sha": "cbab39c390829422419cbacd3e6bd51320dee7fc", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -138,11 +138,9 @@ fn test_env<F>(source_string: &str,\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map.unwrap(),\n                              ast_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "799cb6c5e3d8c7d56d334fdea26869126accd844", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -66,11 +66,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         def_id,\n                         self.tcx.item_path_str(def_id));\n \n-                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                        def_id,\n-                        self.tcx.item_path_str(def_id));\n-\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n "}, {"sha": "86c40a0208ad340755cb3630c38378d93a177f7d", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -230,18 +230,25 @@ fn main() {\n         }\n     }\n \n+    // OpenBSD has a particular C++ runtime library name\n+    let stdcppname = if target.contains(\"openbsd\") {\n+        \"estdc++\"\n+    } else {\n+        \"stdc++\"\n+    };\n+\n     // C++ runtime library\n     if !target.contains(\"msvc\") {\n         if let Some(s) = env::var_os(\"LLVM_STATIC_STDCPP\") {\n             assert!(!cxxflags.contains(\"stdlib=libc++\"));\n             let path = PathBuf::from(s);\n             println!(\"cargo:rustc-link-search=native={}\",\n                      path.parent().unwrap().display());\n-            println!(\"cargo:rustc-link-lib=static=stdc++\");\n+            println!(\"cargo:rustc-link-lib=static={}\", stdcppname);\n         } else if cxxflags.contains(\"stdlib=libc++\") {\n             println!(\"cargo:rustc-link-lib=c++\");\n         } else {\n-            println!(\"cargo:rustc-link-lib=stdc++\");\n+            println!(\"cargo:rustc-link-lib={}\", stdcppname);\n         }\n     }\n }"}, {"sha": "926c44824ce482393083697b4569d9a8dbbeee16", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -102,8 +102,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n /// ast-map.\n pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     parent_def_path: ast_map::DefPath,\n-                                     parent_did: DefId,\n                                      ast: Ast<'tcx>,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n@@ -120,17 +118,9 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let item_node_id = tcx.sess.next_node_id();\n     let ii = ast_map::map_decoded_item(&tcx.map,\n-                                       parent_def_path,\n-                                       parent_did,\n                                        ii,\n                                        item_node_id);\n \n-    let inlined_did = tcx.map.local_def_id(item_node_id);\n-    let ty = tcx.item_type(orig_did);\n-    let generics = tcx.item_generics(orig_did);\n-    tcx.item_types.borrow_mut().insert(inlined_did, ty);\n-    tcx.generics.borrow_mut().insert(inlined_did, generics);\n-\n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n             TableEntry::TypeRelativeDef(def) => {"}, {"sha": "a9af4118c5957f7266fe05bfdf6252fe58192696", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::middle::cstore::NativeLibrary;\n use rustc::hir::map::Definitions;\n@@ -297,10 +298,14 @@ impl<'a> CrateLoader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode(&metadata)\n+        });\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n-            key_map: metadata.load_key_map(crate_root.index),\n+            def_path_table: def_path_table,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "7ec847d24cfa3fc73823ce1a427550454ef172ba", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -16,7 +16,7 @@ use schema;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate};\n use rustc_back::PanicStrategy;\n@@ -78,7 +78,7 @@ pub struct CrateMetadata {\n     /// hashmap, which gives the reverse mapping.  This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n-    pub key_map: FxHashMap<DefKey, DefIndex>,\n+    pub def_path_table: DefPathTable,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,"}, {"sha": "5c96d7f1826fd28e8664d2e607d83fb57e25f04c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -22,8 +22,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -336,18 +335,20 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).is_no_builtins()\n     }\n \n-    fn def_index_for_def_key(&self,\n-                             cnum: CrateNum,\n-                             def: DefKey)\n-                             -> Option<DefIndex> {\n+    fn retrace_path(&self,\n+                    cnum: CrateNum,\n+                    path: &[DisambiguatedDefPathData])\n+                    -> Option<DefId> {\n         let cdata = self.get_crate_data(cnum);\n-        cdata.key_map.get(&def).cloned()\n+        cdata.def_path_table\n+             .retrace_path(&path)\n+             .map(|index| DefId { krate: cnum, index: index })\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey {\n+    fn def_key(&self, def: DefId) -> DefKey {\n         // Note: loading the def-key (or def-path) for a def-id is not\n         // a *read* of its metadata. This is because the def-id is\n         // really just an interned shorthand for a def-path, which is the\n@@ -357,7 +358,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n-    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+    fn def_path(&self, def: DefId) -> DefPath {\n         // See `Note` above in `def_key()` for why this read is\n         // commented out:\n         //\n@@ -418,8 +419,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n-            imported_from: None, // FIXME\n-            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n             attrs: attrs,\n             body: body,\n         })"}, {"sha": "853a49dffc7b5ec71010c455a28194a022076d34", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,12 +12,9 @@\n \n use astencode::decode_inlined_item;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n-use index::Index;\n use schema::*;\n \n-use rustc::hir::map as hir_map;\n-use rustc::hir::map::{DefKey, DefPathData};\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n@@ -456,14 +453,6 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(pos).decode(self)\n     }\n \n-    /// Go through each item in the metadata and create a map from that\n-    /// item's def-key to the item's DefIndex.\n-    pub fn load_key_map(&self, index: LazySeq<Index>) -> FxHashMap<DefKey, DefIndex> {\n-        index.iter_enumerated(self.raw_bytes())\n-            .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n-            .collect()\n-    }\n-\n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n@@ -543,9 +532,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n-        item.def_key\n-            .decode(self)\n+    fn item_name(&self, item_index: DefIndex) -> ast::Name {\n+        self.def_key(item_index)\n             .disambiguated_data\n             .data\n             .get_opt_name()\n@@ -578,7 +566,7 @@ impl<'a, 'tcx> CrateMetadata {\n         ty::TraitDef::new(self.local_def_id(item_id),\n                           data.unsafety,\n                           data.paren_sugar,\n-                          self.def_path(item_id).unwrap().deterministic_hash(tcx))\n+                          self.def_path(item_id).deterministic_hash(tcx))\n     }\n \n     fn get_variant(&self,\n@@ -594,12 +582,12 @@ impl<'a, 'tcx> CrateMetadata {\n \n         (ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(item),\n+            name: self.item_name(index),\n             fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(&f),\n+                    name: self.item_name(index),\n                     vis: f.visibility\n                 }\n             }).collect(),\n@@ -771,7 +759,7 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(&self.entry(child_index)),\n+                                    name: self.item_name(child_index),\n                                 });\n                             }\n                         }\n@@ -783,7 +771,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     _ => {}\n                 }\n \n-                let def_key = child.def_key.decode(self);\n+                let def_key = self.def_key(child_index);\n                 if let (Some(def), Some(name)) =\n                     (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n                     callback(def::Export {\n@@ -839,12 +827,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if self.is_proc_macro(id) { return None; }\n         let item_doc = self.entry(id);\n         let item_did = self.local_def_id(id);\n-        let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n-        let mut parent_def_path = self.def_path(id).unwrap();\n-        parent_def_path.data.pop();\n         item_doc.ast.map(|ast| {\n             let ast = ast.decode(self);\n-            decode_inlined_item(self, tcx, parent_def_path, parent_def_id, ast, item_did)\n+            decode_inlined_item(self, tcx, ast, item_did)\n         })\n     }\n \n@@ -889,7 +874,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n-            let def_key = item.def_key.decode(self);\n+            let def_key = self.def_key(id);\n             (self.local_def_id(def_key.parent.unwrap()),\n              def_key.disambiguated_data.data.get_opt_name().unwrap())\n         };\n@@ -966,7 +951,7 @@ impl<'a, 'tcx> CrateMetadata {\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n         let mut item = self.entry(node_id);\n-        let def_key = item.def_key.decode(self);\n+        let def_key = self.def_key(node_id);\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n@@ -977,7 +962,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id)\n             .children\n             .decode(self)\n-            .map(|index| self.item_name(&self.entry(index)))\n+            .map(|index| self.item_name(index))\n             .collect()\n     }\n \n@@ -1039,7 +1024,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_trait_of_item(&self, id: DefIndex) -> Option<DefId> {\n-        self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n+        self.def_key(id).parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n@@ -1085,7 +1070,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n         let entry = self.entry(id);\n         match entry.kind {\n-            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            EntryKind::MacroDef(macro_def) => (self.item_name(id), macro_def.decode(self)),\n             _ => bug!(),\n         }\n     }\n@@ -1138,32 +1123,14 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n-        debug!(\"def_key: id={:?}\", id);\n-        if self.is_proc_macro(id) {\n-            let name = self.proc_macros.as_ref().unwrap()[id.as_usize() - 1].0;\n-            hir_map::DefKey {\n-                parent: Some(CRATE_DEF_INDEX),\n-                disambiguated_data: hir_map::DisambiguatedDefPathData {\n-                    data: hir_map::DefPathData::MacroDef(name.as_str()),\n-                    disambiguator: 0,\n-                },\n-            }\n-        } else {\n-            self.entry(id).def_key.decode(self)\n-        }\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.def_path_table.def_key(index)\n     }\n \n-    // Returns the path leading to the thing with this `id`. Note that\n-    // some def-ids don't wind up in the metadata, so `def_path` sometimes\n-    // returns `None`\n-    pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n+    // Returns the path leading to the thing with this `id`.\n+    pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(id={:?})\", id);\n-        if self.is_proc_macro(id) || self.maybe_entry(id).is_some() {\n-            Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n-        } else {\n-            None\n-        }\n+        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n     }\n \n     /// Imports the codemap from an external crate into the codemap of the crate"}, {"sha": "cf032013ac962976117a497cd3f9f0c41cd391ab", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -16,6 +16,7 @@ use rustc::middle::cstore::{InlinedItemRef, LinkMeta};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary};\n use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -233,13 +234,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// For every DefId that we create a metadata item for, we include a\n-    /// serialized copy of its DefKey, which allows us to recreate a path.\n-    fn encode_def_key(&mut self, def_id: DefId) -> Lazy<hir::map::DefKey> {\n-        let tcx = self.tcx;\n-        self.lazy(&tcx.map.def_key(def_id))\n-    }\n-\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         let tcx = self.tcx;\n         self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n@@ -276,7 +270,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Variant(self.lazy(&data)),\n             visibility: enum_vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n@@ -315,7 +308,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Mod(self.lazy(&data)),\n             visibility: vis.simplify(),\n             span: self.lazy(&md.inner),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n                 tcx.map.local_def_id(item_id.id).index\n@@ -396,7 +388,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Field,\n             visibility: field.vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -430,7 +421,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Struct(self.lazy(&data)),\n             visibility: struct_vis.simplify(),\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -497,7 +487,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: trait_item.vis.simplify(),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -587,7 +576,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: impl_item.vis.simplify(),\n             span: self.lazy(&ast_item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -750,7 +738,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: item.vis.simplify(),\n             span: self.lazy(&item.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemForeignMod(ref fm) => {\n@@ -858,14 +845,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n-        let def_id = self.tcx.map.local_def_id(macro_def.id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n             })),\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&macro_def.span),\n-            def_key: self.encode_def_key(def_id),\n \n             attributes: self.encode_attributes(&macro_def.attrs),\n             children: LazySeq::empty(),\n@@ -967,7 +952,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: kind,\n             visibility: nitem.vis.simplify(),\n             span: self.lazy(&nitem.span),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n             stability: self.encode_stability(def_id),\n@@ -1050,7 +1034,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Type,\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1079,7 +1062,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             kind: EntryKind::Closure(self.lazy(&data)),\n             visibility: ty::Visibility::Public,\n             span: self.lazy(&tcx.def_span(def_id)),\n-            def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),\n             stability: None,\n@@ -1179,6 +1161,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n+\n+    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n+        let definitions = self.tcx.map.definitions();\n+        self.lazy(definitions.def_path_table())\n+    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n@@ -1276,6 +1263,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n+        // Encode DefPathTable\n+        i = self.position();\n+        let def_path_table = self.encode_def_path_table();\n+        let def_path_table_bytes = self.position() - i;\n+\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1321,6 +1313,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n+            def_path_table: def_path_table,\n             impls: impls,\n             exported_symbols: exported_symbols,\n             index: index,\n@@ -1343,6 +1336,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"           index bytes: {}\", index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);"}, {"sha": "0b6606a00d3c041174759b55f50f5f27c036be39", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -179,6 +179,7 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -202,7 +203,6 @@ pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: ty::Visibility,\n     pub span: Lazy<Span>,\n-    pub def_key: Lazy<hir::map::DefKey>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,\n     pub stability: Option<Lazy<attr::Stability>>,"}, {"sha": "bc150b847786f2c08531e847d08061b2f9600d3d", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -171,7 +171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if path.segments.iter().any(|segment| segment.parameters.is_some()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n@@ -275,7 +275,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if !path.segments.iter().all(|segment| segment.parameters.is_none()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }"}, {"sha": "cd2a2767979144fdcb3272a5205ef71128f8d196", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 84, "deletions": 78, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -16,7 +16,8 @@\n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -28,7 +29,7 @@ use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n@@ -45,24 +46,24 @@ use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n@@ -73,15 +74,15 @@ struct LegacyMacroImports {\n     reexports: Vec<(Name, Span)>,\n }\n \n-impl<'b> Resolver<'b> {\n+impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n-        where T: ToNameBinding<'b>,\n+    fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+        where T: ToNameBinding<'a>,\n     {\n-        let binding = def.to_name_binding();\n-        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n-            self.report_conflict(parent, name, ns, old_binding, &binding);\n+        let binding = def.to_name_binding(self.arenas);\n+        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+            self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n \n@@ -102,7 +103,7 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = item.ident.name;\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -157,8 +158,8 @@ impl<'b> Resolver<'b> {\n                         }\n \n                         let subclass = SingleImport {\n-                            target: binding.name,\n-                            source: source.name,\n+                            target: binding,\n+                            source: source,\n                             result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                         };\n                         self.add_import_directive(\n@@ -187,13 +188,13 @@ impl<'b> Resolver<'b> {\n \n                         for source_item in source_items {\n                             let node = source_item.node;\n-                            let (module_path, name, rename) = {\n+                            let (module_path, ident, rename) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n-                                    let rename = node.rename.unwrap_or(node.name).name;\n-                                    (module_path.clone(), node.name.name, rename)\n+                                    let rename = node.rename.unwrap_or(node.name);\n+                                    (module_path.clone(), node.name, rename)\n                                 } else {\n-                                    let name = match module_path.last() {\n-                                        Some(ident) => ident.name,\n+                                    let ident = match module_path.last() {\n+                                        Some(&ident) => ident,\n                                         None => {\n                                             resolve_error(\n                                                 self,\n@@ -205,13 +206,13 @@ impl<'b> Resolver<'b> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.map(|i| i.name).unwrap_or(name);\n-                                    (module_path.to_vec(), name, rename)\n+                                    let rename = node.rename.unwrap_or(ident);\n+                                    (module_path.to_vec(), ident, rename)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: name,\n+                                source: ident,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                             };\n                             let id = source_item.node.id;\n@@ -238,8 +239,8 @@ impl<'b> Resolver<'b> {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n                 let module = self.get_extern_crate_root(crate_id);\n-                let binding = (module, ty::Visibility::Public, sp, expansion).to_name_binding();\n-                let binding = self.arenas.alloc_name_binding(binding);\n+                let binding =\n+                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     id: item.id,\n                     parent: parent,\n@@ -251,7 +252,7 @@ impl<'b> Resolver<'b> {\n                     expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n-                self.define(parent, name, TypeNS, imported_binding);\n+                self.define(parent, ident, TypeNS, imported_binding);\n                 self.populate_module_if_necessary(module);\n                 self.process_legacy_macro_imports(item, module, expansion);\n             }\n@@ -260,14 +261,14 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Mod(..) => {\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.arenas.alloc_module(ModuleS {\n+                let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n+                    ..ModuleData::new(Some(parent), ModuleKind::Def(def, ident.name))\n                 });\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n \n                 // Descend into the module.\n@@ -280,27 +281,27 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n@@ -311,14 +312,14 @@ impl<'b> Resolver<'b> {\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n+                    self.define(parent, ident, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -332,7 +333,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -350,8 +351,8 @@ impl<'b> Resolver<'b> {\n \n                 // Add all the items within to a new module.\n                 let module =\n-                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -362,29 +363,26 @@ impl<'b> Resolver<'b> {\n     // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n-                                       parent: Module<'b>,\n+                                       parent: Module<'a>,\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n-        let name = variant.node.name.name;\n+        let ident = variant.node.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n-        let parent = self.current_module;\n-        let name = item.ident.name;\n-\n         let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 Def::Fn(self.definitions.local_def_id(item.id))\n@@ -393,8 +391,9 @@ impl<'b> Resolver<'b> {\n                 Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n+        let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n+        self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -413,8 +412,8 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n-        let name = child.name;\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) {\n+        let ident = Ident::with_empty_ctxt(child.name);\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = match def {\n@@ -425,25 +424,25 @@ impl<'b> Resolver<'b> {\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n@@ -455,27 +454,27 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -489,14 +488,15 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n+    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleS {\n+            arenas.alloc_module(ModuleData {\n                 populated: Cell::new(false),\n-                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n+                ..ModuleData::new(None, ModuleKind::Def(Def::Mod(def_id), name))\n             })\n         })\n     }\n@@ -532,7 +532,7 @@ impl<'b> Resolver<'b> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n         for child in self.session.cstore.item_children(module.def_id().unwrap()) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n@@ -542,7 +542,7 @@ impl<'b> Resolver<'b> {\n \n     fn legacy_import_macro(&mut self,\n                            name: Name,\n-                           binding: &'b NameBinding<'b>,\n+                           binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n         self.used_crates.insert(binding.def().def_id().krate);\n@@ -555,7 +555,7 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'b>, expansion: Mark) {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark) {\n         let allow_shadowing = expansion == Mark::root();\n         let legacy_imports = self.legacy_macro_imports(&item.attrs);\n         let cnum = module.def_id().unwrap().krate;\n@@ -574,12 +574,13 @@ impl<'b> Resolver<'b> {\n         }\n \n         if let Some(span) = legacy_imports.import_all {\n-            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding, span, allow_shadowing);\n+            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(ident.name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let ident = Ident::with_empty_ctxt(name);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n                 if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -591,7 +592,8 @@ impl<'b> Resolver<'b> {\n             let krate = module.def_id().unwrap().krate;\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let ident = Ident::with_empty_ctxt(name);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -696,9 +698,13 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => {\n-                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            ItemKind::Mac(ref mac) => {\n+                if mac.node.path.segments.is_empty() {\n+                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                } else {\n+                    self.resolver.define_macro(item, &mut self.legacy_scope);\n+                }\n+                return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,\n@@ -759,7 +765,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n+        self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "f73227681c5e159a1ace316489174e15ac233d27", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 93, "deletions": 133, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::DiagnosticBuilder;\n@@ -774,15 +774,15 @@ enum ModuleKind {\n }\n \n /// One node in the tree of modules.\n-pub struct ModuleS<'a> {\n+pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n     kind: ModuleKind,\n \n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, PathScope, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -794,19 +794,19 @@ pub struct ModuleS<'a> {\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n-    traits: RefCell<Option<Box<[(Name, &'a NameBinding<'a>)]>>>,\n+    traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n }\n \n-pub type Module<'a> = &'a ModuleS<'a>;\n+pub type Module<'a> = &'a ModuleData<'a>;\n \n-impl<'a> ModuleS<'a> {\n+impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n-        ModuleS {\n+        ModuleData {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n@@ -822,9 +822,9 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n+    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n         }\n     }\n \n@@ -859,7 +859,7 @@ impl<'a> ModuleS<'a> {\n     }\n }\n \n-impl<'a> fmt::Debug for ModuleS<'a> {\n+impl<'a> fmt::Debug for ModuleData<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}\", self.def())\n     }\n@@ -875,11 +875,11 @@ pub struct NameBinding<'a> {\n }\n \n pub trait ToNameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a>;\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a>;\n }\n \n-impl<'a> ToNameBinding<'a> for NameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n+impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n+    fn to_name_binding(self, _: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         self\n     }\n }\n@@ -1120,7 +1120,7 @@ pub struct Resolver<'a> {\n }\n \n pub struct ResolverArenas<'a> {\n-    modules: arena::TypedArena<ModuleS<'a>>,\n+    modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n@@ -1130,7 +1130,7 @@ pub struct ResolverArenas<'a> {\n }\n \n impl<'a> ResolverArenas<'a> {\n-    fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n+    fn alloc_module(&'a self, module: ModuleData<'a>) -> Module<'a> {\n         let module = self.modules.alloc(module);\n         if module.def_id().map(|def_id| def_id.is_local()).unwrap_or(true) {\n             self.local_modules.borrow_mut().push(module);\n@@ -1210,10 +1210,10 @@ impl<'a> Resolver<'a> {\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n-        let graph_root = arenas.alloc_module(ModuleS {\n+        let graph_root = arenas.alloc_module(ModuleData {\n             normal_ancestor_id: Some(CRATE_NODE_ID),\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleS::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+            ..ModuleData::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n         });\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1331,44 +1331,44 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS {\n+        self.arenas.alloc_module(ModuleData {\n             normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n             populated: Cell::new(local),\n-            ..ModuleS::new(Some(parent), kind)\n+            ..ModuleData::new(Some(parent), kind)\n         })\n     }\n \n-    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n+    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleData::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n         match binding.kind {\n             NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n                 used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n-                self.add_to_glob_map(directive.id, name);\n-                self.record_use(name, ns, binding, span)\n+                self.add_to_glob_map(directive.id, ident);\n+                self.record_use(ident, ns, binding, span)\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2, legacy } => {\n                 self.ambiguity_errors.push(AmbiguityError {\n-                    span: span, name: name, lexical: false, b1: b1, b2: b2, legacy: legacy,\n+                    span: span, name: ident.name, lexical: false, b1: b1, b2: b2, legacy: legacy,\n                 });\n                 if legacy {\n-                    self.record_use(name, ns, b1, span);\n+                    self.record_use(ident, ns, b1, span);\n                 }\n                 !legacy\n             }\n             _ => false\n         }\n     }\n \n-    fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n+    fn add_to_glob_map(&mut self, id: NodeId, ident: Ident) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(ident.name);\n         }\n     }\n \n@@ -1395,7 +1395,7 @@ impl<'a> Resolver<'a> {\n                                       record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = Ident::with_empty_ctxt(ident.name);\n+            ident = ident.unhygienize();\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1410,8 +1410,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1420,7 +1419,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2190,8 +2189,7 @@ impl<'a> Resolver<'a> {\n                             Def::VariantCtor(_, CtorKind::Const) |\n                             Def::Const(..) if !always_binding => {\n                                 // A unit struct/variant or constant pattern.\n-                                let name = ident.node.name;\n-                                self.record_use(name, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident.node, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2370,9 +2368,9 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             let binding = if let Some(module) = module {\n-                self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident.name, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -2412,7 +2410,7 @@ impl<'a> Resolver<'a> {\n                             });\n                         }\n                     }\n-                    let msg = if module.and_then(ModuleS::def) == self.graph_root.def() {\n+                    let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;\n@@ -2872,72 +2870,64 @@ impl<'a> Resolver<'a> {\n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", name);\n \n-        fn add_trait_info(found_traits: &mut Vec<TraitCandidate>,\n-                          trait_def_id: DefId,\n-                          import_id: Option<NodeId>,\n-                          name: Name) {\n-            debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n-                   trait_def_id,\n-                   name);\n-            found_traits.push(TraitCandidate {\n-                def_id: trait_def_id,\n-                import_id: import_id,\n-            });\n-        }\n-\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((trait_def_id, _)) = self.current_trait_ref {\n             if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                add_trait_info(&mut found_traits, trait_def_id, None, name);\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n             }\n         }\n \n         let mut search_module = self.current_module;\n         loop {\n-            // Look for trait children.\n-            let mut search_in_module = |this: &mut Self, module: Module<'a>| {\n-                let mut traits = module.traits.borrow_mut();\n-                if traits.is_none() {\n-                    let mut collected_traits = Vec::new();\n-                    module.for_each_child(|name, ns, binding| {\n-                        if ns != TypeNS { return }\n-                        if let Def::Trait(_) = binding.def() {\n-                            collected_traits.push((name, binding));\n-                        }\n-                    });\n-                    *traits = Some(collected_traits.into_boxed_slice());\n-                }\n-\n-                for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-                    let trait_def_id = binding.def().def_id();\n-                    if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        let mut import_id = None;\n-                        if let NameBindingKind::Import { directive, .. } = binding.kind {\n-                            let id = directive.id;\n-                            this.maybe_unused_trait_imports.insert(id);\n-                            this.add_to_glob_map(id, trait_name);\n-                            import_id = Some(id);\n-                        }\n-                        add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                    }\n-                }\n-            };\n-            search_in_module(self, search_module);\n+            self.get_traits_in_module_containing_item(name, search_module, &mut found_traits);\n+            match search_module.kind {\n+                ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n+                _ => break,\n+            }\n+        }\n \n-            if let ModuleKind::Block(..) = search_module.kind {\n-                search_module = search_module.parent.unwrap();\n-            } else {\n-                if !search_module.no_implicit_prelude {\n-                    self.prelude.map(|prelude| search_in_module(self, prelude));\n-                }\n-                break;\n+        if let Some(prelude) = self.prelude {\n+            if !search_module.no_implicit_prelude {\n+                self.get_traits_in_module_containing_item(name, prelude, &mut found_traits);\n             }\n         }\n \n         found_traits\n     }\n \n+    fn get_traits_in_module_containing_item(&mut self,\n+                                            name: Name,\n+                                            module: Module,\n+                                            found_traits: &mut Vec<TraitCandidate>) {\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(|name, ns, binding| {\n+                if ns != TypeNS { return }\n+                if let Def::Trait(_) = binding.def() {\n+                    collected_traits.push((name, binding));\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            let trait_def_id = binding.def().def_id();\n+            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                let import_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => {\n+                        self.maybe_unused_trait_imports.insert(directive.id);\n+                        self.add_to_glob_map(directive.id, trait_name);\n+                        Some(directive.id)\n+                    }\n+                    _ => None,\n+                };\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+            }\n+        }\n+    }\n+\n     /// When name resolution fails, this method can be used to look up candidate\n     /// entities with the expected name. It allows filtering them using the\n     /// supplied predicate (which should be used to only accept the types of\n@@ -2960,24 +2950,18 @@ impl<'a> Resolver<'a> {\n                         in_module_is_extern)) = worklist.pop() {\n             self.populate_module_if_necessary(in_module);\n \n-            in_module.for_each_child(|name, ns, name_binding| {\n+            in_module.for_each_child(|ident, ns, name_binding| {\n \n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n-                if name == lookup_name && ns == namespace {\n+                if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let ident = Ident::with_empty_ctxt(name);\n-                        let params = PathParameters::none();\n-                        let segment = PathSegment {\n-                            identifier: ident,\n-                            parameters: params,\n-                        };\n                         let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(segment);\n+                        segms.push(ident.into());\n                         let path = Path {\n                             span: span,\n                             global: false,\n@@ -3000,10 +2984,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(PathSegment {\n-                        identifier: Ident::with_empty_ctxt(name),\n-                        parameters: PathParameters::none(),\n-                    });\n+                    path_segments.push(ident.into());\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3144,13 +3125,13 @@ impl<'a> Resolver<'a> {\n \n     fn report_conflict(&mut self,\n                        parent: Module,\n-                       name: Name,\n+                       ident: Ident,\n                        ns: Namespace,\n                        binding: &NameBinding,\n                        old_binding: &NameBinding) {\n         // Error on the second of two conflicting names\n         if old_binding.span.lo > binding.span.lo {\n-            return self.report_conflict(parent, name, ns, old_binding, binding);\n+            return self.report_conflict(parent, ident, ns, old_binding, binding);\n         }\n \n         let container = match parent.kind {\n@@ -3165,7 +3146,7 @@ impl<'a> Resolver<'a> {\n             false => (\"defined\", \"definition\"),\n         };\n \n-        let span = binding.span;\n+        let (name, span) = (ident.name, binding.span);\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -3187,40 +3168,19 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut err = match (old_binding.is_extern_crate(), binding.is_extern_crate()) {\n-            (true, true) => {\n-                let mut e = struct_span_err!(self.session, span, E0259, \"{}\", msg);\n-                e.span_label(span, &format!(\"`{}` was already imported\", name));\n-                e\n-            },\n-            (true, _) | (_, true) if binding.is_import() && old_binding.is_import() => {\n-                let mut e = struct_span_err!(self.session, span, E0254, \"{}\", msg);\n-                e.span_label(span, &\"already imported\");\n-                e\n-            },\n-            (true, _) | (_, true) => {\n-                let mut e = struct_span_err!(self.session, span, E0260, \"{}\", msg);\n-                e.span_label(span, &format!(\"`{}` already imported\", name));\n-                e\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) => match binding.is_import() && old_binding.is_import() {\n+                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n             _ => match (old_binding.is_import(), binding.is_import()) {\n-                (false, false) => {\n-                    let mut e = struct_span_err!(self.session, span, E0428, \"{}\", msg);\n-                    e.span_label(span, &format!(\"already defined\"));\n-                    e\n-                },\n-                (true, true) => {\n-                    let mut e = struct_span_err!(self.session, span, E0252, \"{}\", msg);\n-                    e.span_label(span, &format!(\"already imported\"));\n-                    e\n-                },\n-                _ => {\n-                    let mut e = struct_span_err!(self.session, span, E0255, \"{}\", msg);\n-                    e.span_label(span, &format!(\"`{}` was already imported\", name));\n-                    e\n-                }\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n             },\n         };\n \n+        err.span_label(span, &format!(\"`{}` already {}\", name, participle));\n         if old_binding.span != syntax_pos::DUMMY_SP {\n             err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }"}, {"sha": "204d1127fc48dc90aba8710e48e5cbda9710bae9", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -19,11 +19,12 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, Ident};\n+use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::Expansion;\n+use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n@@ -138,34 +139,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if def.ident.name == \"macro_rules\" {\n-            self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n-\n-        let invocation = self.invocations[&scope];\n-        let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(invocation.legacy_scope.get()),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n-        });\n-        invocation.legacy_scope.set(LegacyScope::Binding(binding));\n-        self.macro_names.insert(def.ident.name);\n-\n-        if export {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n-            self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n-            });\n-            self.exported_macros.push(def);\n-        }\n-    }\n-\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n@@ -210,9 +183,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, global, span } = *path;\n-        if segments.iter().any(|segment| !segment.parameters.is_empty()) {\n+        if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n-                if segments.last().unwrap().parameters.is_empty() { \"module\" } else { \"macro\" };\n+                if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n             let msg = format!(\"type parameters are not allowed on {}s\", kind);\n             self.session.span_err(path.span, &msg);\n             return Err(Determinacy::Determined);\n@@ -232,7 +205,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n \n             let ext = match self.resolve_path(&path, path_scope, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => Ok(self.get_macro(path_res.base_def)),\n+                PathResult::NonModule(path_res) => match path_res.base_def {\n+                    Def::Err => Err(Determinacy::Determined),\n+                    def @ _ => Ok(self.get_macro(def)),\n+                },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n                 _ => Err(Determinacy::Determined),\n@@ -246,7 +222,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n             Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n-            None => match self.resolve_lexical_macro_path_segment(name, MacroNS, None) {\n+            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 _ => {\n@@ -260,7 +236,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, name, span));\n+            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n         }\n         result\n     }\n@@ -269,7 +245,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              name: Name,\n+                                              ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -278,14 +254,15 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n+            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Ok(binding),\n                     };\n                     match potential_expanded_shadower {\n                         Some(shadower) if shadower.def() != binding.def() => {\n+                            let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n                                 legacy: false,\n@@ -384,10 +361,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(name, MacroNS, Some(span));\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n                 _ => continue,\n@@ -397,9 +374,9 @@ impl<'a> Resolver<'a> {\n                 MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n                 MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n             };\n-            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n-            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", ident, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", ident);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n                 .span_note(legacy_span, &msg1)\n                 .span_note(resolution.span, &msg2)\n                 .emit();\n@@ -443,4 +420,47 @@ impl<'a> Resolver<'a> {\n             expansion.visit_with(def_collector)\n         });\n     }\n+\n+    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+        let tts = match item.node {\n+            ast::ItemKind::Mac(ref mac) => &mac.node.tts,\n+            _ => unreachable!(),\n+        };\n+\n+        if item.ident.name == \"macro_rules\" {\n+            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n+        }\n+\n+        let mark = Mark::from_placeholder_id(item.id);\n+        let invocation = self.invocations[&mark];\n+        invocation.module.set(self.current_module);\n+\n+        let mut def = ast::MacroDef {\n+            ident: item.ident,\n+            attrs: item.attrs.clone(),\n+            id: ast::DUMMY_NODE_ID,\n+            span: item.span,\n+            body: mark_tts(tts, mark),\n+        };\n+\n+        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+            parent: Cell::new(*legacy_scope),\n+            name: def.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+            span: def.span,\n+        }));\n+        self.macro_names.insert(def.ident.name);\n+\n+        if attr::contains_name(&def.attrs, \"macro_export\") {\n+            def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n+            self.exported_macros.push(def);\n+        }\n+    }\n }"}, {"sha": "8bc0bfb41ff753d175bf0a5edb697d13a43e13e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,7 +12,7 @@ use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n+use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n@@ -21,7 +21,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n-use syntax::ast::{Ident, NodeId, Name};\n+use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n@@ -35,8 +35,8 @@ use std::mem;\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n-        target: Name,\n-        source: Name,\n+        target: Ident,\n+        source: Ident,\n         result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n@@ -126,31 +126,32 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, name: Name, ns: Namespace)\n+    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((name, ns))\n+        *module.resolutions.borrow_mut().entry((ident, ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the given namespace.\n-    /// If successful, returns the binding corresponding to the name.\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_name_in_module(&mut self,\n-                                  module: Module<'a>,\n-                                  name: Name,\n-                                  ns: Namespace,\n-                                  ignore_unresolved_invocations: bool,\n-                                  record_used: Option<Span>)\n-                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module(&mut self,\n+                                   module: Module<'a>,\n+                                   ident: Ident,\n+                                   ns: Namespace,\n+                                   ignore_unresolved_invocations: bool,\n+                                   record_used: Option<Span>)\n+                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n+        let ident = ident.unhygienize();\n         self.populate_module_if_necessary(module);\n \n-        let resolution = self.resolution(module, name, ns)\n+        let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n+                    let name = ident.name;\n                     // If we ignore unresolved invocations, we must forbid\n                     // expanded shadowing to avoid time travel.\n                     if ignore_unresolved_invocations &&\n@@ -163,11 +164,11 @@ impl<'a> Resolver<'a> {\n                         });\n                     }\n                 }\n-                if self.record_use(name, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n                 }\n             }\n \n@@ -195,11 +196,11 @@ impl<'a> Resolver<'a> {\n                     Some(module) => module,\n                     None => return Err(Undetermined),\n                 };\n-                let name = match directive.subclass {\n+                let ident = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -221,7 +222,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -273,7 +274,7 @@ impl<'a> Resolver<'a> {\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-                  -> NameBinding<'a> {\n+                  -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -287,7 +288,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        NameBinding {\n+        self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: directive,\n@@ -296,16 +297,18 @@ impl<'a> Resolver<'a> {\n             span: directive.span,\n             vis: vis,\n             expansion: directive.expansion,\n-        }\n+        })\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n-                         -> Result<(), &'a NameBinding<'a>>\n-        where T: ToNameBinding<'a>\n-    {\n-        let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n-        self.update_resolution(module, name, ns, |this, resolution| {\n+    pub fn try_define(&mut self,\n+                      module: Module<'a>,\n+                      ident: Ident,\n+                      ns: Namespace,\n+                      binding: &'a NameBinding<'a>)\n+                      -> Result<(), &'a NameBinding<'a>> {\n+        let ident = ident.unhygienize();\n+        self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n@@ -348,13 +351,14 @@ impl<'a> Resolver<'a> {\n \n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, f: F)\n+                               -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n+            let mut resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -373,7 +377,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.glob_importers.borrow_mut().iter() {\n             if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n@@ -387,7 +391,7 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding);\n             });\n         }\n     }\n@@ -509,15 +513,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n \n+            let parent = directive.parent;\n             match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -532,10 +537,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n-                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n+                    let conflict = this.try_define(parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &this.import(binding, directive);\n-                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        this.report_conflict(parent, target, ns, imported_binding, old_binding);\n                     }\n                 }\n             }\n@@ -565,7 +569,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => return None,\n         };\n \n-        let (name, result) = match directive.subclass {\n+        let (ident, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n@@ -587,8 +591,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(name, ns, binding, directive.span) {\n-                    this.resolution(module, name, ns).borrow_mut().binding =\n+                if this.record_use(ident, ns, binding, directive.span) {\n+                    this.resolution(module, ident, ns).borrow_mut().binding =\n                         Some(this.dummy_binding);\n                 }\n             }\n@@ -597,35 +601,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n \n             return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n-                    if *n == name { return None; } // Never suggest the same name\n+                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                    if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(n),\n+                        NameResolution { binding: Some(_), .. } => Some(&i.name),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(n),\n+                        _ => Some(&i.name),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n-                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                    None => \"\".to_owned(),\n-                };\n+                let lev_suggestion =\n+                    match find_best_match_for_name(names, &ident.name.as_str(), None) {\n+                        Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                        None => \"\".to_owned(),\n+                    };\n                 let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"no `{}` in the root{}\", name, lev_suggestion)\n+                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                 } else {\n-                    format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n+                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n                 Some(msg)\n             } else {\n-                // `resolve_name_in_module` reported a privacy error.\n+                // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n                 None\n             }\n@@ -650,18 +655,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             if ns == TypeNS && binding.is_extern_crate() {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0364), consider declaring with `pub`\",\n-                                   name);\n+                                   ident);\n                 self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n-                                 \"`{}` is private, and cannot be reexported\", name)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                                 \"`{}` is private, and cannot be reexported\", ident)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", ident);\n                 let note_msg =\n-                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n@@ -698,21 +703,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*name, binding))\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((name, ns), binding) in bindings {\n+        for ((ident, ns), binding) in bindings {\n             if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = module.def_id() {\n-            let resolution = PathResolution::new(Def::Mod(did));\n-            self.def_map.insert(directive.id, resolution);\n-        }\n+        self.def_map.insert(directive.id, PathResolution::new(module.def().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n@@ -726,7 +728,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             reexports = mem::replace(&mut self.macro_exports, Vec::new());\n         }\n \n-        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = &mut *resolution.borrow_mut();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -740,7 +742,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     if !def.def_id().is_local() {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n-                    reexports.push(Export { name: name, def: def });\n+                    reexports.push(Export { name: ident.name, def: def });\n                 }\n             }\n \n@@ -750,7 +752,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                        !orig_binding.vis.is_at_least(binding.vis, self) {\n                         let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                            (error E0364), consider declaring its enum as `pub`\",\n-                                          name);\n+                                          ident);\n                         self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n                     }\n                 }"}, {"sha": "de8814f143e04f62b4c07b046a7c5ac0039b01f7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1085,6 +1085,10 @@ fn run_work_multithreaded(sess: &Session,\n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let (pname, mut cmd, _) = get_linker(sess);\n \n+    for arg in &sess.target.target.options.asm_args {\n+        cmd.arg(arg);\n+    }\n+\n     cmd.arg(\"-c\").arg(\"-o\").arg(&outputs.path(OutputType::Object))\n                            .arg(&outputs.temp_path(OutputType::Assembly, None));\n     debug!(\"{:?}\", cmd);"}, {"sha": "94dc9a5fdb48946b308d3f29086044b1ec7bb0e1", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -10,14 +10,13 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n-use rustc::ty;\n+use rustc::ty::{self, layout};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n use common::{self, Block, BlockAndBuilder, CrateContext, FunctionContext, C_null};\n use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind, FunctionDebugContext};\n-use machine;\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n@@ -494,10 +493,15 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 llval\n             };\n \n-            let llclosurety = type_of::type_of(bcx.ccx(), closure_ty);\n+            let layout = bcx.ccx().layout_of(closure_ty);\n+            let offsets = match *layout {\n+                layout::Univariant { ref variant, .. } => &variant.offsets[..],\n+                _ => bug!(\"Closures are only supposed to be Univariant\")\n+            };\n+\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n-                let byte_offset_of_var_in_env =\n-                    machine::llelement_offset(bcx.ccx(), llclosurety, i);\n+                let byte_offset_of_var_in_env = offsets[i].bytes();\n+\n \n                 let ops = unsafe {\n                     [llvm::LLVMRustDIBuilderCreateOpDeref(),"}, {"sha": "265dcada1f810651a76401793644cfb0d17c1261", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -142,20 +142,21 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n         match e {\n             CastError::NeedDeref => {\n+                let error_span = self.span;\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                let mut err = fcx.type_error_struct(self.cast_span,\n+                let mut err = fcx.type_error_struct(error_span,\n                                        |actual| {\n                                            format!(\"casting `{}` as `{}` is invalid\",\n                                                    actual,\n                                                    cast_ty)\n                                        },\n                                        self.expr_ty);\n-                err.span_label(self.expr.span,\n+                err.span_label(error_span,\n                                &format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n                 if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n-                    err.span_label(self.expr.span,\n+                    err.span_help(self.expr.span,\n                                    &format!(\"did you mean `*{}`?\", snippet));\n                 }\n                 err.emit();"}, {"sha": "123516dc89d746fcad14b912ca96e3328c2230d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -2801,7 +2801,7 @@ impl Clean<Item> for doctree::Macro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.tcx.map.local_def_id(self.id),\n+            def_id: self.def_id,\n             inner: MacroItem(Macro {\n                 source: format!(\"macro_rules! {} {{\\n{}}}\",\n                                 name,"}, {"sha": "31e10fbd3b7d3e16ca57628798caceba41d79661", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -233,9 +233,11 @@ pub struct DefaultImpl {\n     pub whence: Span,\n }\n \n+// For Macro we store the DefId instead of the NodeId, since we also create\n+// these imported macro_rules (which only have a DUMMY_NODE_ID).\n pub struct Macro {\n     pub name: Name,\n-    pub id: ast::NodeId,\n+    pub def_id: hir::def_id::DefId,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,"}, {"sha": "835825d31eec98f46e954707fdf3dea03a2e7ff1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -259,10 +259,11 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     let external_html = match ExternalHtml::load(\n-            &matches.opt_strs(\"html-in-header\"), &matches.opt_strs(\"html-before-content\"),\n+            &matches.opt_strs(\"html-in-header\"),\n+            &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\")) {\n         Some(eh) => eh,\n-        None => return 3\n+        None => return 3,\n     };\n     let crate_name = matches.opt_str(\"crate-name\");\n     let playground_url = matches.opt_str(\"playground-url\");"}, {"sha": "c93112657b96db239e9b9528f53754f50108919e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         let macro_exports: Vec<_> =\n-            krate.exported_macros.iter().map(|def| self.visit_macro(def)).collect();\n+            krate.exported_macros.iter().map(|def| self.visit_local_macro(def)).collect();\n         self.module.macros.extend(macro_exports);\n         self.module.is_crate = true;\n     }\n@@ -201,6 +201,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n+                    let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n                     let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n                         LoadedMacro::MacroRules(macro_rules) => macro_rules,\n                         // FIXME(jseyfried): document proc macro reexports\n@@ -210,14 +211,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     // FIXME(jseyfried) merge with `self.visit_macro()`\n                     let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n                     om.macros.push(Macro {\n-                        id: def.id,\n+                        def_id: def_id,\n                         attrs: def.attrs.clone().into(),\n                         name: def.ident.name,\n                         whence: def.span,\n                         matchers: matchers,\n                         stab: self.stability(def.id),\n                         depr: self.deprecation(def.id),\n-                        imported_from: def.imported_from.map(|ident| ident.name),\n+                        imported_from: Some(imported_from),\n                     })\n                 }\n             }\n@@ -513,19 +514,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_macro(&self, def: &hir::MacroDef) -> Macro {\n+    fn visit_local_macro(&self, def: &hir::MacroDef) -> Macro {\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n         let matchers = def.body.chunks(4).map(|arm| arm[0].get_span()).collect();\n \n         Macro {\n-            id: def.id,\n+            def_id: self.cx.tcx.map.local_def_id(def.id),\n             attrs: def.attrs.clone(),\n             name: def.name,\n             whence: def.span,\n             matchers: matchers,\n             stab: self.stability(def.id),\n             depr: self.deprecation(def.id),\n-            imported_from: def.imported_from,\n+            imported_from: None,\n         }\n     }\n }"}, {"sha": "f5e9ec6d89d0f62603bf0fc35700e6e2eb81847d", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use fmt;\n use mem;\n use ops::Range;\n use iter::FusedIterator;\n@@ -370,6 +371,13 @@ impl ExactSizeIterator for EscapeDefault {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDefault {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EscapeDefault { .. }\")\n+    }\n+}\n+\n \n static ASCII_LOWERCASE_MAP: [u8; 256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,"}, {"sha": "b3eba508316981682638773827c3e04d9e5d7a82", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -104,7 +104,7 @@ fn build_libbacktrace(host: &str, target: &str) {\n                 .env(\"AR\", &ar)\n                 .env(\"RANLIB\", format!(\"{} s\", ar.display()))\n                 .env(\"CFLAGS\", cflags));\n-    run(Command::new(\"make\")\n+    run(Command::new(build_helper::make(host))\n                 .current_dir(&build_dir)\n                 .arg(format!(\"INCDIR={}\", src_dir.display()))\n                 .arg(\"-j\").arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));"}, {"sha": "2fa3a9c4844b5502515f14ac07f6c14ee52e7bf8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1276,6 +1276,15 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K: Debug, V: Debug> fmt::Debug for Iter<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n /// HashMap mutable values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n@@ -1285,7 +1294,7 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: table::IntoIter<K, V>,\n+    pub(super) inner: table::IntoIter<K, V>,\n }\n \n /// HashMap keys iterator.\n@@ -1302,6 +1311,15 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K: Debug, V: Debug> fmt::Debug for Keys<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n@@ -1316,10 +1334,19 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K: Debug, V: Debug> fmt::Debug for Values<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n /// HashMap drain iterator.\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: table::Drain<'a, K, V>,\n+    pub(super) inner: table::Drain<'a, K, V>,\n }\n \n /// Mutable HashMap values iterator.\n@@ -1557,6 +1584,18 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K, V> fmt::Debug for IterMut<'a, K, V>\n+    where K: fmt::Debug,\n+          V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.iter())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n@@ -1580,6 +1619,15 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.iter())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n@@ -1649,6 +1697,18 @@ impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K, V> fmt::Debug for ValuesMut<'a, K, V>\n+    where K: fmt::Debug,\n+          V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.inner.iter())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n@@ -1672,6 +1732,18 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K, V> fmt::Debug for Drain<'a, K, V>\n+    where K: fmt::Debug,\n+          V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.inner.iter())\n+            .finish()\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2148,6 +2220,13 @@ impl Default for RandomState {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for RandomState {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"RandomState { .. }\")\n+    }\n+}\n+\n impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n     where K: Eq + Hash + Borrow<Q>,\n           S: BuildHasher,"}, {"sha": "341b050862f5c455520c25d6496c7a264782fb0b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -948,6 +948,15 @@ impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Iter<'a, K> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K: fmt::Debug> fmt::Debug for Iter<'a, K> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n@@ -968,6 +977,16 @@ impl<K> ExactSizeIterator for IntoIter<K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K> FusedIterator for IntoIter<K> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let entries_iter = self.iter.inner.iter().map(|(k, _)| k);\n+        f.debug_list()\n+            .entries(entries_iter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n@@ -988,6 +1007,16 @@ impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Drain<'a, K> {}\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, K: fmt::Debug> fmt::Debug for Drain<'a, K> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let entries_iter = self.iter.inner.iter().map(|(k, _)| k);\n+        f.debug_list()\n+            .entries(entries_iter)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Intersection<'a, T, S> {\n     fn clone(&self) -> Intersection<'a, T, S> {\n@@ -1021,6 +1050,18 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T, S> fmt::Debug for Intersection<'a, T, S>\n+    where T: fmt::Debug + Eq + Hash,\n+          S: BuildHasher,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Intersection<'a, T, S>\n     where T: Eq + Hash,\n@@ -1068,6 +1109,18 @@ impl<'a, T, S> FusedIterator for Difference<'a, T, S>\n {\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T, S> fmt::Debug for Difference<'a, T, S>\n+    where T: fmt::Debug + Eq + Hash,\n+          S: BuildHasher,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n     fn clone(&self) -> SymmetricDifference<'a, T, S> {\n@@ -1097,6 +1150,18 @@ impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>\n {\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T, S> fmt::Debug for SymmetricDifference<'a, T, S>\n+    where T: fmt::Debug + Eq + Hash,\n+          S: BuildHasher,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Union<'a, T, S> {\n     fn clone(&self) -> Union<'a, T, S> {\n@@ -1111,6 +1176,18 @@ impl<'a, T, S> FusedIterator for Union<'a, T, S>\n {\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T, S> fmt::Debug for Union<'a, T, S>\n+    where T: fmt::Debug + Eq + Hash,\n+          S: BuildHasher,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list()\n+            .entries(self.clone())\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Union<'a, T, S>\n     where T: Eq + Hash,"}, {"sha": "2cd9362a65791408f9ece6192f1857b7636e5b56", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -882,6 +882,15 @@ unsafe impl<'a, K: Sync, V: Sync> Sync for IterMut<'a, K, V> {}\n // but Send is the more useful bound\n unsafe impl<'a, K: Send, V: Send> Send for IterMut<'a, K, V> {}\n \n+impl<'a, K: 'a, V: 'a> IterMut<'a, K, V> {\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter {\n+            iter: self.iter.clone(),\n+            elems_left: self.elems_left,\n+        }\n+    }\n+}\n+\n /// Iterator over the entries in a table, consuming the table.\n pub struct IntoIter<K, V> {\n     table: RawTable<K, V>,\n@@ -891,6 +900,15 @@ pub struct IntoIter<K, V> {\n unsafe impl<K: Sync, V: Sync> Sync for IntoIter<K, V> {}\n unsafe impl<K: Send, V: Send> Send for IntoIter<K, V> {}\n \n+impl<K, V> IntoIter<K, V> {\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter {\n+            iter: self.iter.clone(),\n+            elems_left: self.table.size,\n+        }\n+    }\n+}\n+\n /// Iterator over the entries in a table, clearing the table.\n pub struct Drain<'a, K: 'a, V: 'a> {\n     table: Shared<RawTable<K, V>>,\n@@ -901,6 +919,17 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n unsafe impl<'a, K: Sync, V: Sync> Sync for Drain<'a, K, V> {}\n unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}\n \n+impl<'a, K, V> Drain<'a, K, V> {\n+    pub fn iter(&self) -> Iter<K, V> {\n+        unsafe {\n+            Iter {\n+                iter: self.iter.clone(),\n+                elems_left: (**self.table).size,\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n "}, {"sha": "0521f301321a736e08a5392dc1686e5913fb0abc", "filename": "src/libstd/env.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -143,13 +143,27 @@ impl Iterator for Vars {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Vars {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Vars { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for VarsOs {\n     type Item = (OsString, OsString);\n     fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for VarsOs {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"VarsOs { .. }\")\n+    }\n+}\n+\n /// Fetches the environment variable `key` from the current process.\n ///\n /// The returned result is `Ok(s)` if the environment variable is present and is\n@@ -364,6 +378,13 @@ impl<'a> Iterator for SplitPaths<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a> fmt::Debug for SplitPaths<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"SplitPaths { .. }\")\n+    }\n+}\n+\n /// Error type returned from `std::env::join_paths` when paths fail to be\n /// joined.\n #[derive(Debug)]\n@@ -640,6 +661,13 @@ impl DoubleEndedIterator for Args {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Args {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Args { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;\n@@ -657,6 +685,14 @@ impl ExactSizeIterator for ArgsOs {\n impl DoubleEndedIterator for ArgsOs {\n     fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n }\n+\n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for ArgsOs {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ArgsOs { .. }\")\n+    }\n+}\n+\n /// Constants associated with the current target\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub mod consts {"}, {"sha": "176b5f66fc4e8500ff4d9a8eaf8b740bfeddd13f", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -140,7 +140,7 @@ pub struct DirEntry(fs_imp::DirEntry);\n ///             .create(true)\n ///             .open(\"foo.txt\");\n /// ```\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OpenOptions(fs_imp::OpenOptions);\n \n@@ -168,6 +168,7 @@ pub struct FileType(fs_imp::FileType);\n ///\n /// This builder also supports platform-specific options.\n #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+#[derive(Debug)]\n pub struct DirBuilder {\n     inner: fs_imp::DirBuilder,\n     recursive: bool,\n@@ -834,6 +835,21 @@ impl Metadata {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Metadata {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Metadata\")\n+            .field(\"file_type\", &self.file_type())\n+            .field(\"is_dir\", &self.is_dir())\n+            .field(\"is_file\", &self.is_file())\n+            .field(\"permissions\", &self.permissions())\n+            .field(\"modified\", &self.modified())\n+            .field(\"accessed\", &self.accessed())\n+            .field(\"created\", &self.created())\n+            .finish()\n+    }\n+}\n+\n impl AsInner<fs_imp::FileAttr> for Metadata {\n     fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n }"}, {"sha": "143a85ae321846c6c8b4342c32a54f9fe93b5489", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1444,6 +1444,16 @@ pub struct Chain<T, U> {\n     done_first: bool,\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Chain\")\n+            .field(\"t\", &self.first)\n+            .field(\"u\", &self.second)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Read, U: Read> Read for Chain<T, U> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n@@ -1485,6 +1495,7 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n ///\n /// [`take()`]: trait.Read.html#method.take\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Take<T> {\n     inner: T,\n     limit: u64,\n@@ -1602,6 +1613,7 @@ fn read_one_byte(reader: &mut Read) -> Option<Result<u8>> {\n ///\n /// [`bytes()`]: trait.Read.html#method.bytes\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Bytes<R> {\n     inner: R,\n }\n@@ -1623,6 +1635,7 @@ impl<R: Read> Iterator for Bytes<R> {\n /// [chars]: trait.Read.html#method.chars\n #[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n            issue = \"27802\")]\n+#[derive(Debug)]\n pub struct Chars<R> {\n     inner: R,\n }\n@@ -1712,6 +1725,7 @@ impl fmt::Display for CharsError {\n ///\n /// [split]: trait.BufRead.html#method.split\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Split<B> {\n     buf: B,\n     delim: u8,\n@@ -1743,6 +1757,7 @@ impl<B: BufRead> Iterator for Split<B> {\n ///\n /// [lines]: trait.BufRead.html#method.lines\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Lines<B> {\n     buf: B,\n }"}, {"sha": "9d1c8942f8cf80605dab780459dcc69297786470", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -282,6 +282,13 @@ impl Stdin {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Stdin {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Stdin { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -314,6 +321,13 @@ impl<'a> BufRead for StdinLock<'a> {\n     fn consume(&mut self, n: usize) { self.inner.consume(n) }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a> fmt::Debug for StdinLock<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"StdinLock { .. }\")\n+    }\n+}\n+\n /// A handle to the global standard output stream of the current process.\n ///\n /// Each handle shares a global buffer of data to be written to the standard\n@@ -424,6 +438,13 @@ impl Stdout {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Stdout {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Stdout { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n@@ -449,6 +470,13 @@ impl<'a> Write for StdoutLock<'a> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a> fmt::Debug for StdoutLock<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"StdoutLock { .. }\")\n+    }\n+}\n+\n /// A handle to the standard error stream of a process.\n ///\n /// For more information, see the [`io::stderr`] method.\n@@ -545,6 +573,13 @@ impl Stderr {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Stderr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Stderr { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n@@ -570,6 +605,13 @@ impl<'a> Write for StderrLock<'a> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a> fmt::Debug for StderrLock<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"StderrLock { .. }\")\n+    }\n+}\n+\n /// Resets the thread-local stderr handle to the specified writer\n ///\n /// This will replace the current thread's stderr handle, returning the old"}, {"sha": "436511031ef53f777e20eb09cd115ceca67f250a", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(missing_copy_implementations)]\n \n+use fmt;\n use io::{self, Read, Write, ErrorKind, BufRead};\n \n /// Copies the entire contents of a reader into a writer.\n@@ -97,6 +98,13 @@ impl BufRead for Empty {\n     fn consume(&mut self, _n: usize) {}\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Empty {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Empty { .. }\")\n+    }\n+}\n+\n /// A reader which yields one byte over and over and over and over and over and...\n ///\n /// This struct is generally created by calling [`repeat()`][repeat]. Please\n@@ -133,6 +141,13 @@ impl Read for Repeat {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Repeat {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Repeat { .. }\")\n+    }\n+}\n+\n /// A writer which will move data into the void.\n ///\n /// This struct is generally created by calling [`sink()`][sink]. Please\n@@ -165,6 +180,13 @@ impl Write for Sink {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Sink {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Sink { .. }\")\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use io::prelude::*;"}, {"sha": "fc5c6968544e80d22d25b0a0d255ee331a15e86a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -214,6 +214,7 @@\n #![no_std]\n \n #![deny(missing_docs)]\n+#![deny(missing_debug_implementations)]\n \n // Tell the compiler to link to either panic_abort or panic_unwind\n #![needs_panic_runtime]\n@@ -276,6 +277,7 @@\n #![feature(panic_unwind)]\n #![feature(placement_in_syntax)]\n #![feature(prelude_import)]\n+#![feature(pub_restricted)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(repr_simd)]"}, {"sha": "6aab7486004f89e132c65e706a607760554ceed3", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1068,6 +1068,14 @@ impl From<[u8; 16]> for Ipv6Addr {\n     }\n }\n \n+#[stable(feature = \"ipv6_from_segments\", since = \"1.15.0\")]\n+impl From<[u16; 8]> for Ipv6Addr {\n+    fn from(segments: [u16; 8]) -> Ipv6Addr {\n+        let [a, b, c, d, e, f, g, h] = segments;\n+        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n+    }\n+}\n+\n // Tests for this module\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n@@ -1413,10 +1421,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn ipv4_from_u32_slice() {\n+    fn ipv4_from_octets() {\n         assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n     }\n \n+    #[test]\n+    fn ipv6_from_segments() {\n+        let from_u16s = Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677,\n+                                        0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+        let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677,\n+                                0x8899, 0xaabb, 0xccdd, 0xeeff);\n+        assert_eq!(new, from_u16s);\n+    }\n+\n+    #[test]\n+    fn ipv6_from_octets() {\n+        let from_u16s = Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677,\n+                                        0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+        let from_u8s = Ipv6Addr::from([0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n+                                       0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]);\n+        assert_eq!(from_u16s, from_u8s);\n+    }\n+\n     #[test]\n     fn ord() {\n         assert!(Ipv4Addr::new(100, 64, 3, 3) < Ipv4Addr::new(192, 0, 2, 2));"}, {"sha": "cadf87f32b14a6a93b58b7bbd1868cef0b9de794", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use fmt;\n use io::{self, Error, ErrorKind};\n use sys_common::net as net_imp;\n \n@@ -105,6 +106,13 @@ impl Iterator for LookupHost {\n     fn next(&mut self) -> Option<SocketAddr> { self.0.next() }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for LookupHost {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"LookupHost { .. }\")\n+    }\n+}\n+\n /// Resolve the host specified by `host` as a number of `SocketAddr` instances.\n ///\n /// This method may perform a DNS query to resolve `host` and may also inspect"}, {"sha": "63817c9f10f5fbb19892e61759b8e0f30f7858a5", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -76,6 +76,7 @@ pub struct TcpListener(net_imp::TcpListener);\n /// [`incoming`]: struct.TcpListener.html#method.incoming\n /// [`TcpListener`]: struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Incoming<'a> { listener: &'a TcpListener }\n \n impl TcpStream {"}, {"sha": "7c9274d06016180e0bd7c1afab07e185984bd30c", "filename": "src/libstd/os/linux/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -17,6 +17,7 @@\n                               crates.io should be used instead for the correct \\\n                               definitions\")]\n #![allow(deprecated)]\n+#![allow(missing_debug_implementations)]\n \n use os::raw::c_ulong;\n "}, {"sha": "e45af86705582e20647962a8a05c0580d70b8739", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -11,7 +11,7 @@\n //! OS-specific functionality.\n \n #![stable(feature = \"os\", since = \"1.0.0\")]\n-#![allow(missing_docs, bad_style)]\n+#![allow(missing_docs, bad_style, missing_debug_implementations)]\n \n #[cfg(any(target_os = \"redox\", unix))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "cc154f7ab413b4341307d9eb127b91eb696f86f2", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,8 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n+use fmt;\n+\n #[cfg(any(target_os = \"android\",\n           target_os = \"emscripten\",\n           all(target_os = \"linux\", any(target_arch = \"aarch64\",\n@@ -71,6 +73,13 @@ pub enum c_void {\n     #[doc(hidden)] __variant2,\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for c_void {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"c_void\")\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(unused_imports)]\n mod tests {"}, {"sha": "faf4949e86192e2d76ba2cc7199f9a6a7a67ead7", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -14,6 +14,7 @@\n \n use any::Any;\n use cell::UnsafeCell;\n+use fmt;\n use ops::{Deref, DerefMut};\n use panicking;\n use ptr::{Unique, Shared};\n@@ -296,6 +297,15 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_tuple(\"AssertUnwindSafe\")\n+            .field(&self.0)\n+            .finish()\n+    }\n+}\n+\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure"}, {"sha": "e5edea241e1990654e10d0113cc1dae57440363c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -177,6 +177,7 @@ pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n /// panic!(\"Normal panic\");\n /// ```\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n+#[derive(Debug)]\n pub struct PanicInfo<'a> {\n     payload: &'a (Any + Send),\n     location: Location<'a>,\n@@ -256,6 +257,7 @@ impl<'a> PanicInfo<'a> {\n ///\n /// panic!(\"Normal panic\");\n /// ```\n+#[derive(Debug)]\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct Location<'a> {\n     file: &'a str,"}, {"sha": "e15c37aaf24911ac6ade0258109aa5150b084350", "filename": "src/libstd/process.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -114,6 +114,17 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Child {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Child\")\n+            .field(\"stdin\", &self.stdin)\n+            .field(\"stdout\", &self.stdout)\n+            .field(\"stderr\", &self.stderr)\n+            .finish()\n+    }\n+}\n+\n /// A handle to a child process's stdin. This struct is used in the [`stdin`]\n /// field on [`Child`].\n ///\n@@ -149,6 +160,13 @@ impl FromInner<AnonPipe> for ChildStdin {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for ChildStdin {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ChildStdin { .. }\")\n+    }\n+}\n+\n /// A handle to a child process's stdout. This struct is used in the [`stdout`]\n /// field on [`Child`].\n ///\n@@ -183,6 +201,13 @@ impl FromInner<AnonPipe> for ChildStdout {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for ChildStdout {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ChildStdout { .. }\")\n+    }\n+}\n+\n /// A handle to a child process's stderr. This struct is used in the [`stderr`]\n /// field on [`Child`].\n ///\n@@ -217,6 +242,13 @@ impl FromInner<AnonPipe> for ChildStderr {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for ChildStderr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ChildStderr { .. }\")\n+    }\n+}\n+\n /// A process builder, providing fine-grained control\n /// over how a new process should be spawned.\n ///\n@@ -622,6 +654,13 @@ impl FromInner<imp::Stdio> for Stdio {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Stdio {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Stdio { .. }\")\n+    }\n+}\n+\n /// Describes the result of a process after it has terminated.\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"process\", since = \"1.0.0\")]"}, {"sha": "b853e83de5d6cb035b112da1a1fa1d2971db4add", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -59,6 +59,7 @@\n #![unstable(feature = \"rand\", issue = \"0\")]\n \n use cell::RefCell;\n+use fmt;\n use io;\n use mem;\n use rc::Rc;\n@@ -143,6 +144,12 @@ pub struct ThreadRng {\n     rng: Rc<RefCell<ThreadRngInner>>,\n }\n \n+impl fmt::Debug for ThreadRng {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ThreadRng { .. }\")\n+    }\n+}\n+\n /// Retrieve the lazily-initialized thread-local random number\n /// generator, seeded by the system. Intended to be used in method\n /// chaining style, e.g. `thread_rng().gen::<isize>()`."}, {"sha": "b8e83dced8d4b100bae84db8804628bb78bef740", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use fmt;\n use sync::{Mutex, Condvar};\n \n /// A barrier enables multiple threads to synchronize the beginning\n@@ -54,6 +55,13 @@ struct BarrierState {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BarrierWaitResult(bool);\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Barrier {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Barrier { .. }\")\n+    }\n+}\n+\n impl Barrier {\n     /// Creates a new barrier that can block a given number of threads.\n     ///\n@@ -102,6 +110,15 @@ impl Barrier {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for BarrierWaitResult {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"BarrierWaitResult\")\n+            .field(\"is_leader\", &self.is_leader())\n+            .finish()\n+    }\n+}\n+\n impl BarrierWaitResult {\n     /// Returns whether this thread from `wait` is the \"leader thread\".\n     ///"}, {"sha": "8ab30c51b282eb601ffba3f3eefbe3f01847851d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use fmt;\n use sync::atomic::{AtomicUsize, Ordering};\n use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n@@ -239,6 +240,13 @@ impl Condvar {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Condvar {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Condvar { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"condvar_default\", since = \"1.9.0\")]\n impl Default for Condvar {\n     /// Creates a `Condvar` which is ready to be waited on and notified."}, {"sha": "aeeab170deafe9cfdd92324197a2bf14c74ffacd", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -306,6 +306,7 @@ impl<T> !Sync for Receiver<T> { }\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n@@ -317,6 +318,7 @@ pub struct Iter<'a, T: 'a> {\n /// This Iterator will never block the caller in order to wait for data to\n /// become available. Instead, it will return `None`.\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n+#[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n@@ -325,6 +327,7 @@ pub struct TryIter<'a, T: 'a> {\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n+#[derive(Debug)]\n pub struct IntoIter<T> {\n     rx: Receiver<T>\n }"}, {"sha": "f6dbe01d7bdbf05fab89719ccdf962370629ac4f", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -351,6 +351,15 @@ impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T: ?Sized + fmt::Debug> fmt::Debug for MutexGuard<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"MutexGuard\")\n+            .field(\"lock\", &self.__lock)\n+            .finish()\n+    }\n+}\n+\n pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.__lock.inner\n }"}, {"sha": "a9747639aacd797381e8df74d4eb2b44ecbf13a4", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -64,6 +64,7 @@\n // You'll find a few more details in the implementation, but that's the gist of\n // it!\n \n+use fmt;\n use marker;\n use ptr;\n use sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n@@ -103,6 +104,7 @@ unsafe impl Send for Once {}\n /// State yielded to the `call_once_force` method which can be used to query\n /// whether the `Once` was previously poisoned or not.\n #[unstable(feature = \"once_poison\", issue = \"33577\")]\n+#[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n }\n@@ -328,6 +330,13 @@ impl Once {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for Once {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Once { .. }\")\n+    }\n+}\n+\n impl Drop for Finish {\n     fn drop(&mut self) {\n         // Swap out our state with however we finished. We should only ever see"}, {"sha": "0a11c71706b7e45565349fd771619cc8f50598d0", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -362,6 +362,24 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T: fmt::Debug> fmt::Debug for RwLockReadGuard<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RwLockReadGuard\")\n+            .field(\"lock\", &self.__lock)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<'a, T: fmt::Debug> fmt::Debug for RwLockWriteGuard<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RwLockWriteGuard\")\n+            .field(\"lock\", &self.__lock)\n+            .finish()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;"}, {"sha": "14da376efa998831a0d73cfea7eb99ef6fc04c6d", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -30,6 +30,8 @@\n //! inter-dependencies within `std` that will be a challenging goal to\n //! achieve.\n \n+#![allow(missing_debug_implementations)]\n+\n pub use self::imp::*;\n \n #[cfg(target_os = \"redox\")]"}, {"sha": "1ba4a104e515c96cce936e7ced02fcb476718bc9", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 565, "deletions": 26, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -85,6 +85,21 @@ enum AddressKind<'a> {\n }\n \n /// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct SocketAddr {\n@@ -121,6 +136,28 @@ impl SocketAddr {\n     }\n \n     /// Returns true if and only if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), false);\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), true);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         if let AddressKind::Unnamed = self.address() {\n@@ -131,6 +168,29 @@ impl SocketAddr {\n     }\n \n     /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         if let AddressKind::Pathname(path) = self.address() {\n@@ -182,7 +242,7 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::os::unix::net::UnixStream;\n /// use std::io::prelude::*;\n ///\n@@ -212,6 +272,20 @@ impl fmt::Debug for UnixStream {\n \n impl UnixStream {\n     /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         fn inner(path: &Path) -> io::Result<UnixStream> {\n@@ -229,6 +303,20 @@ impl UnixStream {\n     /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n@@ -241,62 +329,159 @@ impl UnixStream {\n     /// object references. Both handles will read and write the same stream of\n     /// data, and options set on one stream will be propogated to the other\n     /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n \n     /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Sets the read timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `read` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`read()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n \n     /// Sets the write timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `write` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`write()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -306,7 +491,19 @@ impl UnixStream {\n     ///\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of `Shutdown`).\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n@@ -382,7 +579,7 @@ impl IntoRawFd for UnixStream {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::thread;\n /// use std::os::unix::net::{UnixStream, UnixListener};\n ///\n@@ -405,9 +602,6 @@ impl IntoRawFd for UnixStream {\n ///         }\n ///     }\n /// }\n-///\n-/// // close the listener socket\n-/// drop(listener);\n /// ```\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixListener(Socket);\n@@ -426,6 +620,20 @@ impl fmt::Debug for UnixListener {\n \n impl UnixListener {\n     /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         fn inner(path: &Path) -> io::Result<UnixListener> {\n@@ -445,8 +653,23 @@ impl UnixListener {\n     /// Accepts a new incoming connection to this listener.\n     ///\n     /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corersponding `UnixStream` and\n+    /// is established. When established, the corersponding [`UnixStream`] and\n     /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n@@ -461,33 +684,102 @@ impl UnixListener {\n     /// The returned `UnixListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n \n     /// Returns an iterator over incoming connections.\n     ///\n-    /// The iterator will never return `None` and will also not yield the\n-    /// peer's `SocketAddr` structure.\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n@@ -525,9 +817,36 @@ impl<'a> IntoIterator for &'a UnixListener {\n     }\n }\n \n-/// An iterator over incoming connections to a `UnixListener`.\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+/// [`UnixListener`]: struct.UnixListener.html\n+///\n+/// # Examples\n ///\n-/// It will never return `None`.\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Debug)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct Incoming<'a> {\n@@ -551,7 +870,7 @@ impl<'a> Iterator for Incoming<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::os::unix::net::UnixDatagram;\n ///\n /// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n@@ -580,6 +899,20 @@ impl fmt::Debug for UnixDatagram {\n \n impl UnixDatagram {\n     /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n         fn inner(path: &Path) -> io::Result<UnixDatagram> {\n@@ -596,6 +929,20 @@ impl UnixDatagram {\n     }\n \n     /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn unbound() -> io::Result<UnixDatagram> {\n         let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -605,6 +952,20 @@ impl UnixDatagram {\n     /// Create an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -613,8 +974,27 @@ impl UnixDatagram {\n \n     /// Connects the socket to the specified address.\n     ///\n-    /// The `send` method may be used to send data to the specified address.\n-    /// `recv` and `recv_from` will only receive data from that address.\n+    /// The [`send()`] method may be used to send data to the specified address.\n+    /// [`recv()`] and [`recv_from()`] will only receive data from that address.\n+    ///\n+    /// [`send()`]: #method.send\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// match sock.connect(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n@@ -631,23 +1011,56 @@ impl UnixDatagram {\n \n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n         self.0.duplicate().map(UnixDatagram)\n     }\n \n     /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the address of this socket's peer.\n     ///\n-    /// The `connect` method will connect the socket to a peer.\n+    /// The [`connect()`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect()`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n@@ -657,6 +1070,19 @@ impl UnixDatagram {\n     ///\n     /// On success, returns the number of bytes read and the address from\n     /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// match sock.recv_from(buf.as_mut_slice()) {\n+    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n+    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n@@ -684,6 +1110,16 @@ impl UnixDatagram {\n     /// Receives data from the socket.\n     ///\n     /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -692,6 +1128,15 @@ impl UnixDatagram {\n     /// Sends data on the socket to the specified address.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n         fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n@@ -716,50 +1161,134 @@ impl UnixDatagram {\n     /// will return an error if the socket has not already been connected.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n     /// Sets the read timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `recv` and `recv_from` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`recv()`] and [`recv_from()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n \n     /// Sets the write timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `send` and `send_to` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`send()`] and [`send_to()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`send()`]: #method.send\n+    /// [`send_to()`]: #method.send_to\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// if let Ok(Some(err)) = sock.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -769,7 +1298,17 @@ impl UnixDatagram {\n     ///\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of `Shutdown`).\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)"}, {"sha": "f4f73646e1b7e088e6d844ac1230b4f430a425ee", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,7 @@\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n use cell::{Cell, UnsafeCell};\n+use fmt;\n use intrinsics;\n use ptr;\n \n@@ -24,6 +25,12 @@ pub struct Key<T> {\n     dtor_running: Cell<bool>,\n }\n \n+impl<T> fmt::Debug for Key<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Key { .. }\")\n+    }\n+}\n+\n unsafe impl<T> ::marker::Sync for Key<T> { }\n \n impl<T> Key<T> {"}, {"sha": "2384d959881a238662648ceb50b59e935844174f", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -18,6 +18,7 @@ use sys::cvt;\n use sys_common::AsInner;\n use sys_common::io::read_to_end_uninitialized;\n \n+#[derive(Debug)]\n pub struct FileDesc {\n     fd: c_int,\n }"}, {"sha": "8b5c0c04276b164882604cf195bedcd30adab4e0", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -66,7 +66,7 @@ pub struct DirEntry {\n     name: Box<[u8]>\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct OpenOptions {\n     // generic\n     read: bool,\n@@ -86,6 +86,7 @@ pub struct FilePermissions { mode: mode_t }\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FileType { mode: mode_t }\n \n+#[derive(Debug)]\n pub struct DirBuilder { mode: mode_t }\n \n impl FileAttr {"}, {"sha": "c410fcd1ee0ed59f0c2533172541f3cd64a89a17", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -58,7 +58,7 @@ pub struct DirEntry {\n     data: c::WIN32_FIND_DATAW,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct OpenOptions {\n     // generic\n     read: bool,\n@@ -79,6 +79,7 @@ pub struct OpenOptions {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions { attrs: c::DWORD }\n \n+#[derive(Debug)]\n pub struct DirBuilder;\n \n impl fmt::Debug for ReadDir {"}, {"sha": "634d6258885e864e7f040233fb883c134e446481", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -23,6 +23,7 @@\n //! `std::sys` from the standard library.\n \n #![allow(missing_docs)]\n+#![allow(missing_debug_implementations)]\n \n use sync::Once;\n use sys;"}, {"sha": "01584979aabaae59c57e769cee73dd8e25e49477", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,6 +13,7 @@\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n use cell::UnsafeCell;\n+use fmt;\n use mem;\n \n /// A thread local storage key which owns its contents.\n@@ -98,6 +99,13 @@ pub struct LocalKey<T: 'static> {\n     init: fn() -> T,\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<T: 'static> fmt::Debug for LocalKey<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"LocalKey { .. }\")\n+    }\n+}\n+\n /// Declare a new thread local storage key of type `std::thread::LocalKey`.\n ///\n /// # Syntax\n@@ -184,7 +192,7 @@ macro_rules! __thread_local_inner {\n #[unstable(feature = \"thread_local_state\",\n            reason = \"state querying was recently added\",\n            issue = \"27716\")]\n-#[derive(Eq, PartialEq, Copy, Clone)]\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n pub enum LocalKeyState {\n     /// All keys are in this state whenever a thread starts. Keys will\n     /// transition to the `Valid` state once the first call to `with` happens\n@@ -313,6 +321,7 @@ impl<T: 'static> LocalKey<T> {\n #[doc(hidden)]\n pub mod os {\n     use cell::{Cell, UnsafeCell};\n+    use fmt;\n     use marker;\n     use ptr;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n@@ -323,6 +332,13 @@ pub mod os {\n         marker: marker::PhantomData<Cell<T>>,\n     }\n \n+    #[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.pad(\"Key { .. }\")\n+        }\n+    }\n+\n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     struct Value<T: 'static> {"}, {"sha": "2a3fb5ec43f2abeb8a33df697a94e382217d7f65", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -217,6 +217,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug)]\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n@@ -587,6 +588,13 @@ impl ThreadId {\n     }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl fmt::Debug for ThreadId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"ThreadId { .. }\")\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////\n@@ -802,6 +810,13 @@ impl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n     fn into_inner(self) -> imp::Thread { self.0.native.unwrap() }\n }\n \n+#[stable(feature = \"std_debug\", since = \"1.15.0\")]\n+impl<T> fmt::Debug for JoinHandle<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"JoinHandle { .. }\")\n+    }\n+}\n+\n fn _assert_sync_and_send() {\n     fn _assert_both<T: Send + Sync>() {}\n     _assert_both::<JoinHandle<()>>();"}, {"sha": "162ce530f17cdb427508b9f39b9e4366dd20adad", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -14,16 +14,19 @@ const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n \n-/// A duration type to represent a span of time, typically used for system\n+/// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n ///\n-/// Each duration is composed of a number of seconds and nanosecond precision.\n+/// Each `Duration` is composed of a number of seconds and nanosecond precision.\n /// APIs binding a system timeout will typically round up the nanosecond\n /// precision if the underlying system does not support that level of precision.\n ///\n-/// Durations implement many common traits, including `Add`, `Sub`, and other\n-/// ops traits. Currently a duration may only be inspected for its number of\n-/// seconds and its nanosecond precision.\n+/// `Duration`s implement many common traits, including [`Add`], [`Sub`], and other\n+/// [`ops`] traits.\n+///\n+/// [`Add`]: ../../std/ops/trait.Add.html\n+/// [`Sub`]: ../../std/ops/trait.Sub.html\n+/// [`ops`]: ../../std/ops/index.html\n ///\n /// # Examples\n ///\n@@ -56,6 +59,14 @@ impl Duration {\n     ///\n     /// This constructor will panic if the carry from the nanoseconds overflows\n     /// the seconds counter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let five_seconds = Duration::new(5, 0);\n+    /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n@@ -66,13 +77,29 @@ impl Duration {\n     }\n \n     /// Creates a new `Duration` from the specified number of seconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let five_seconds = Duration::from_secs(5);\n+    /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn from_secs(secs: u64) -> Duration {\n         Duration { secs: secs, nanos: 0 }\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let five_seconds = Duration::from_millis(5000);\n+    /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn from_millis(millis: u64) -> Duration {\n@@ -81,26 +108,46 @@ impl Duration {\n         Duration { secs: secs, nanos: nanos }\n     }\n \n-    /// Returns the number of whole seconds represented by this duration.\n+    /// Returns the number of whole seconds represented by this `Duration`.\n     ///\n     /// The extra precision represented by this duration is ignored (i.e. extra\n     /// nanoseconds are not represented in the returned value).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let five_seconds = Duration::new(5, 0);\n+    /// assert_eq!(five_seconds.as_secs(), 5);\n+    /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn as_secs(&self) -> u64 { self.secs }\n \n-    /// Returns the nanosecond precision represented by this duration.\n+    /// Returns the nanosecond precision represented by this `Duration`.\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by nanoseconds. The returned number always represents a\n     /// fractional portion of a second (i.e. it is less than one billion).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::time::Duration;\n+    ///\n+    /// let duration = Duration::from_millis(5010);\n+    /// assert_eq!(duration.subsec_nanos(), 10000000);\n+    /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn subsec_nanos(&self) -> u32 { self.nanos }\n \n-    /// Checked duration addition. Computes `self + other`, returning `None`\n+    /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n     /// if overflow occurred.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -136,9 +183,11 @@ impl Duration {\n         }\n     }\n \n-    /// Checked duration subtraction. Computes `self + other`, returning `None`\n+    /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n     /// if the result would be negative or if underflow occurred.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -172,8 +221,10 @@ impl Duration {\n         }\n     }\n \n-    /// Checked duration multiplication. Computes `self * other`, returning\n-    /// `None` if underflow or overflow occurred.\n+    /// Checked `Duration` multiplication. Computes `self * other`, returning\n+    /// [`None`] if overflow occurred.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -207,8 +258,10 @@ impl Duration {\n         }\n     }\n \n-    /// Checked duration division. Computes `self / other`, returning `None`\n-    /// if `other == 0` or the operation results in underflow or overflow.\n+    /// Checked `Duration` division. Computes `self / other`, returning [`None`]\n+    /// if `other == 0`.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///"}, {"sha": "fdd82225b974747990adb31c6a9d8067499011d2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 88, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -47,10 +47,14 @@ impl Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n \n-   /// Maps a string to an identifier with an empty syntax context.\n-   pub fn from_str(s: &str) -> Ident {\n-       Ident::with_empty_ctxt(Symbol::intern(s))\n-   }\n+    /// Maps a string to an identifier with an empty syntax context.\n+    pub fn from_str(s: &str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::intern(s))\n+    }\n+\n+    pub fn unhygienize(&self) -> Ident {\n+        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    }\n }\n \n impl fmt::Debug for Ident {\n@@ -133,12 +137,7 @@ impl Path {\n         Path {\n             span: s,\n             global: false,\n-            segments: vec![\n-                PathSegment {\n-                    identifier: identifier,\n-                    parameters: PathParameters::none()\n-                }\n-            ],\n+            segments: vec![identifier.into()],\n         }\n     }\n }\n@@ -156,7 +155,15 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: PathParameters,\n+    /// The `Option<P<..>>` wrapper is purely a size optimization;\n+    /// `None` is used to represent both `Path` and `Path<>`.\n+    pub parameters: Option<P<PathParameters>>,\n+}\n+\n+impl From<Ident> for PathSegment {\n+    fn from(id: Ident) -> Self {\n+        PathSegment { identifier: id, parameters: None }\n+    }\n }\n \n /// Parameters of a path segment.\n@@ -170,79 +177,8 @@ pub enum PathParameters {\n     Parenthesized(ParenthesizedParameterData),\n }\n \n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        PathParameters::AngleBracketed(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n-            types: P::new(),\n-            bindings: P::new(),\n-        })\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            PathParameters::Parenthesized(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.lifetimes.is_empty(),\n-            PathParameters::Parenthesized(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.types.is_empty(),\n-            PathParameters::Parenthesized(..) => true,\n-        }\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            PathParameters::Parenthesized(ref data) => {\n-                data.inputs.iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-}\n-\n /// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n@@ -254,9 +190,10 @@ pub struct AngleBracketedParameterData {\n     pub bindings: P<[TypeBinding]>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n+impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n+    fn into(self) -> Option<P<PathParameters>> {\n+        let empty = self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty();\n+        if empty { None } else { Some(P(PathParameters::AngleBracketed(self))) }\n     }\n }\n \n@@ -1968,8 +1905,6 @@ pub struct MacroDef {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Ident>,\n-    pub allow_internal_unstable: bool,\n     pub body: Vec<TokenTree>,\n }\n "}, {"sha": "c31bcfbd86992ec7dce23a1647d15d6f9ada2559", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -29,7 +29,6 @@ use symbol::Symbol;\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::HashSet;\n \n thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n@@ -372,16 +371,6 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-pub fn mk_doc_attr_outer(id: AttrId, item: MetaItem, is_sugared_doc: bool) -> Attribute {\n-    Attribute {\n-        id: id,\n-        style: ast::AttrStyle::Outer,\n-        value: item,\n-        is_sugared_doc: is_sugared_doc,\n-        span: DUMMY_SP,\n-    }\n-}\n-\n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n@@ -421,13 +410,6 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<S\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<Symbol> {\n-    items.iter()\n-         .rev()\n-         .find(|mi| mi.check_name(name))\n-         .and_then(|i| i.value_str())\n-}\n-\n /* Higher-level applications */\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n@@ -856,18 +838,6 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &Handler, metas: &[MetaItem]) {\n-    let mut set = HashSet::new();\n-    for meta in metas {\n-        let name = meta.name();\n-\n-        if !set.insert(name.clone()) {\n-            panic!(diagnostic.span_fatal(meta.span,\n-                                         &format!(\"duplicate meta item `{}`\", name)));\n-        }\n-    }\n-}\n-\n \n /// Parse #[repr(...)] forms.\n ///"}, {"sha": "8e63f73fdaa7a1f7c6df130338a472fdcbbf6fe8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -217,8 +217,7 @@ pub trait IdentMacroExpander {\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>,\n-                   attrs: Vec<ast::Attribute>)\n+                   token_tree: Vec<tokenstream::TokenTree>)\n                    -> Box<MacResult+'cx>;\n }\n \n@@ -234,8 +233,7 @@ impl<F> IdentMacroExpander for F\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>,\n-                   _attrs: Vec<ast::Attribute>)\n+                   token_tree: Vec<tokenstream::TokenTree>)\n                    -> Box<MacResult+'cx>\n     {\n         (*self)(cx, sp, ident, token_tree)\n@@ -520,7 +518,6 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n-    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef, export: bool);\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n@@ -544,7 +541,6 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n-    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef, _export: bool) {}\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n "}, {"sha": "c3dc64f91247bed799f59ed813dff72b423217f9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -322,21 +322,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n-                                                      .map(|ident| {\n-            ast::PathSegment {\n-                identifier: ident,\n-                parameters: ast::PathParameters::none(),\n-            }\n-        }).collect();\n-        segments.push(ast::PathSegment {\n-            identifier: last_identifier,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+        let mut segments: Vec<ast::PathSegment> = idents.into_iter().map(Into::into).collect();\n+        let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(P(ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: P::from_vec(types),\n                 bindings: P::from_vec(bindings),\n-            })\n-        });\n+            })))\n+        };\n+        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n         ast::Path {\n             span: sp,\n             global: global,\n@@ -367,13 +363,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n+        let parameters = ast::AngleBracketedParameterData {\n+            lifetimes: lifetimes,\n+            types: P::from_vec(types),\n+            bindings: P::from_vec(bindings),\n+        };\n         path.segments.push(ast::PathSegment {\n             identifier: ident,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: P::from_vec(types),\n-                bindings: P::from_vec(bindings),\n-            })\n+            parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n \n         (ast::QSelf {"}, {"sha": "5d62175fbf23a7af4c44dbf9836ebb499102c086", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -158,7 +158,6 @@ pub struct Invocation {\n \n pub enum InvocationKind {\n     Bang {\n-        attrs: Vec<ast::Attribute>,\n         mac: ast::Mac,\n         ident: Option<Ident>,\n         span: Span,\n@@ -276,7 +275,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n-            expansions[depth - 1].push((mark.as_u32(), expansion));\n+            expansions[depth - 1].push((mark, expansion));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -287,7 +286,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n+                placeholder_expander.add(mark.as_placeholder_id(), expansion);\n             }\n         }\n \n@@ -386,20 +385,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a macro invocation. Returns the result of expansion.\n     fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n-        let (attrs, mac, ident, span) = match invoc.kind {\n-            InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n+        let (mac, ident, span) = match invoc.kind {\n+            InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let Mac_ { path, tts, .. } = mac.node;\n \n-        // Detect use of feature-gated or invalid attributes on macro invoations\n-        // since they will not be detected after macro expansion.\n-        for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess,\n-                                          &self.cx.parse_sess.codemap(),\n-                                          &self.cx.ecfg.features.unwrap());\n-        }\n-\n         let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n@@ -440,7 +431,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n                 });\n \n-                kind.make_from(expander.expand(self.cx, span, ident, marked_tts, attrs))\n+                kind.make_from(expander.expand(self.cx, span, ident, marked_tts))\n             }\n \n             MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n@@ -595,13 +586,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n+        placeholder(expansion_kind, mark.as_placeholder_id())\n     }\n \n-    fn collect_bang(\n-        &mut self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n-    ) -> Expansion {\n-        self.collect(kind, InvocationKind::Bang { attrs: attrs, mac: mac, ident: None, span: span })\n+    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion {\n+        self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n \n     fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n@@ -622,6 +611,16 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n+\n+    // Detect use of feature-gated or invalid attributes on macro invocations\n+    // since they will not be detected after macro expansion.\n+    fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n+        let codemap = &self.cx.parse_sess.codemap();\n+        let features = self.cx.ecfg.features.unwrap();\n+        for attr in attrs.iter() {\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess, codemap, features);\n+        }\n+    }\n }\n \n // These are pretty nasty. Ideally, we would keep the tokens around, linked from\n@@ -660,7 +659,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr).make_expr()\n+            self.check_attributes(&expr.attrs);\n+            self.collect_bang(mac, expr.span, ExpansionKind::Expr).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -671,8 +671,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr)\n-                .make_opt_expr()\n+            self.check_attributes(&expr.attrs);\n+            self.collect_bang(mac, expr.span, ExpansionKind::OptExpr).make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -685,8 +685,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         }\n \n         pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) =>\n-                self.collect_bang(mac, Vec::new(), pat.span, ExpansionKind::Pat).make_pat(),\n+            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, ExpansionKind::Pat).make_pat(),\n             _ => unreachable!(),\n         })\n     }\n@@ -707,8 +706,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }).collect()\n         };\n \n-        let mut placeholder =\n-            self.collect_bang(mac, attrs.into(), stmt.span, ExpansionKind::Stmts).make_stmts();\n+        self.check_attributes(&attrs);\n+        let mut placeholder = self.collect_bang(mac, stmt.span, ExpansionKind::Stmts).make_stmts();\n \n         // If this is a macro invocation with a semicolon, then apply that\n         // semicolon to the final statement produced by expansion.\n@@ -740,18 +739,21 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         match item.node {\n             ast::ItemKind::Mac(..) => {\n-                if match item.node {\n-                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n-                    _ => unreachable!(),\n-                } {\n-                    return SmallVector::one(item);\n-                }\n+                self.check_attributes(&item.attrs);\n+                let is_macro_def = if let ItemKind::Mac(ref mac) = item.node {\n+                    mac.node.path.segments[0].identifier.name == \"macro_rules\"\n+                } else {\n+                    unreachable!()\n+                };\n \n-                item.and_then(|item| match item.node {\n+                item.and_then(|mut item| match item.node {\n+                    ItemKind::Mac(_) if is_macro_def => {\n+                        item.id = Mark::fresh().as_placeholder_id();\n+                        SmallVector::one(P(item))\n+                    }\n                     ItemKind::Mac(mac) => {\n                         self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,\n-                            attrs: item.attrs,\n                             ident: Some(item.ident),\n                             span: item.span,\n                         }).make_items()\n@@ -823,7 +825,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n-                self.collect_bang(mac, attrs, span, ExpansionKind::TraitItems).make_trait_items()\n+                self.check_attributes(&attrs);\n+                self.collect_bang(mac, span, ExpansionKind::TraitItems).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -841,7 +844,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n-                self.collect_bang(mac, attrs, span, ExpansionKind::ImplItems).make_impl_items()\n+                self.check_attributes(&attrs);\n+                self.collect_bang(mac, span, ExpansionKind::ImplItems).make_impl_items()\n             }\n             _ => fold::noop_fold_impl_item(item, self),\n         }\n@@ -854,8 +858,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         };\n \n         match ty.node {\n-            ast::TyKind::Mac(mac) =>\n-                self.collect_bang(mac, Vec::new(), ty.span, ExpansionKind::Ty).make_ty(),\n+            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, ExpansionKind::Ty).make_ty(),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "2af5c2ea9995ef61f20ba390f2efffd5bf043065", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -51,7 +51,11 @@ impl Mark {\n         Mark(id.as_u32())\n     }\n \n-    pub fn as_u32(&self) -> u32 {\n+    pub fn as_placeholder_id(self) -> NodeId {\n+        NodeId::from_u32(self.0)\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n         self.0\n     }\n }\n@@ -115,12 +119,12 @@ impl SyntaxContext {\n         })\n     }\n \n-   /// If `ident` is macro expanded, return the source ident from the macro definition\n-   /// and the mark of the expansion that created the macro definition.\n-   pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n-        let macro_def_ctxt = self.data().prev_ctxt.data();\n-        (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n-   }\n+    /// If `ident` is macro expanded, return the source ident from the macro definition\n+    /// and the mark of the expansion that created the macro definition.\n+    pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n+         let macro_def_ctxt = self.data().prev_ctxt.data();\n+         (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "eb4b6144c8d28ad989d2044710ed2cda42b3f49f", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,9 +12,10 @@ use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n+use ext::hygiene::Mark;\n use fold::*;\n use ptr::P;\n-use symbol::{Symbol, keywords};\n+use symbol::keywords;\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -68,10 +69,6 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     }\n }\n \n-pub fn macro_scope_placeholder() -> Expansion {\n-    placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n-}\n-\n pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n     cx: &'a mut ExtCtxt<'b>,\n@@ -100,11 +97,12 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n-            // Scope placeholder\n-            ast::ItemKind::Mac(_) if item.id == ast::DUMMY_NODE_ID => SmallVector::one(item),\n-            ast::ItemKind::Mac(_) => self.remove(item.id).make_items(),\n-            _ => noop_fold_item(item, self),\n+            ast::ItemKind::Mac(ref mac) if !mac.node.path.segments.is_empty() => {}\n+            ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n+            _ => {}\n         }\n+\n+        noop_fold_item(item, self)\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n@@ -172,10 +170,10 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                // Scope placeholder\n+                // `macro_rules!` macro definition\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n+                    if let ast::ItemKind::Mac(_) = item.node {\n+                        macros.push(Mark::from_placeholder_id(item.id));\n                         return None;\n                     }\n                 }\n@@ -208,33 +206,13 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         let mut module = noop_fold_mod(module, self);\n         module.items = module.items.move_flat_map(|item| match item.node {\n-            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => None, // remove macro definitions\n             _ => Some(item),\n         });\n         module\n     }\n-}\n \n-pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n-    Expansion::Items(SmallVector::one(P(ast::Item {\n-        ident: def.ident,\n-        attrs: def.attrs.clone(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mac(ast::Mac {\n-            span: def.span,\n-            node: ast::Mac_ {\n-                path: ast::Path {\n-                    span: DUMMY_SP,\n-                    global: false,\n-                    segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n-                        parameters: ast::PathParameters::none(),\n-                    }],\n-                },\n-                tts: def.body.clone(),\n-            }\n-        }),\n-        vis: ast::Visibility::Inherited,\n-        span: def.span,\n-    })))\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        mac\n+    }\n }"}, {"sha": "3abd24b50ba9a83baf3473b12d1b5cde2d996eb4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -10,10 +10,9 @@\n \n use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n-use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n-use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n+use ext::base::{NormalTT, TTMacroExpander};\n use ext::expand::{Expansion, ExpansionKind};\n-use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -151,38 +150,6 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     cx.span_fatal(best_fail_spot.substitute_dummy(sp), &best_fail_msg);\n }\n \n-pub struct MacroRulesExpander;\n-impl IdentMacroExpander for MacroRulesExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              span: Span,\n-              ident: ast::Ident,\n-              tts: Vec<tokenstream::TokenTree>,\n-              attrs: Vec<ast::Attribute>)\n-              -> Box<MacResult> {\n-        let export = attr::contains_name(&attrs, \"macro_export\");\n-        let def = ast::MacroDef {\n-            ident: ident,\n-            id: ast::DUMMY_NODE_ID,\n-            span: span,\n-            imported_from: None,\n-            body: tts,\n-            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n-            attrs: attrs,\n-        };\n-\n-        // If keep_macs is true, expands to a MacEager::items instead.\n-        let result = if cx.ecfg.keep_macs {\n-            MacEager::items(placeholders::reconstructed_macro_rules(&def).make_items())\n-        } else {\n-            MacEager::items(placeholders::macro_scope_placeholder().make_items())\n-        };\n-\n-        cx.resolver.add_macro(cx.current_expansion.mark, def, export);\n-        result\n-    }\n-}\n-\n // Note that macro-by-example's input is also matched against a token tree:\n //                   $( $lhs:tt => $rhs:tt );+\n //\n@@ -282,7 +249,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n         valid: valid,\n     });\n \n-    NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n+    NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess, lhs: &TokenTree) -> bool {"}, {"sha": "b3753e3e977e331cf424d382694f2bcd28ff0c34", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -438,7 +438,7 @@ pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut\n         global: global,\n         segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            parameters: fld.fold_path_parameters(parameters),\n+            parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)\n     }"}, {"sha": "b9e6605639ead2c8ff0f8ee61cd0814c5df31738", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -634,12 +634,7 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: vec![\n-                            ast::PathSegment {\n-                                identifier: Ident::from_str(\"a\"),\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        ],\n+                        segments: vec![Ident::from_str(\"a\").into()],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -651,19 +646,10 @@ mod tests {\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n-                            span: sp(0, 6),\n-                            global: true,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"a\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                },\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ]\n-                        }),\n+                        span: sp(0, 6),\n+                        global: true,\n+                        segments: vec![Ident::from_str(\"a\").into(), Ident::from_str(\"b\").into()],\n+                    }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n                    }))\n@@ -772,12 +758,7 @@ mod tests {\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"d\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ],\n+                            segments: vec![Ident::from_str(\"d\").into()],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -795,12 +776,7 @@ mod tests {\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                               ],\n+                               segments: vec![Ident::from_str(\"b\").into()],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -842,12 +818,7 @@ mod tests {\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: vec![\n-                                            ast::PathSegment {\n-                                                identifier: Ident::from_str(\"i32\"),\n-                                                parameters: ast::PathParameters::none(),\n-                                            }\n-                                        ],\n+                                        segments: vec![Ident::from_str(\"i32\").into()],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -890,13 +861,7 @@ mod tests {\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: vec![\n-                                                            ast::PathSegment {\n-                                                                identifier: Ident::from_str(\"b\"),\n-                                                                parameters:\n-                                                                ast::PathParameters::none(),\n-                                                            }\n-                                                        ],\n+                                                        segments: vec![Ident::from_str(\"b\").into()],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "72462b74e686ca60b1f002f220738dd7e55b162f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -1705,12 +1705,11 @@ impl<'a> Parser<'a> {\n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-\n-                ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+                ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: P::from_vec(types),\n                     bindings: P::from_vec(bindings),\n-                })\n+                }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let lo = self.prev_span.lo;\n \n@@ -1727,18 +1726,17 @@ impl<'a> Parser<'a> {\n \n                 let hi = self.prev_span.hi;\n \n-                ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n+                Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n                     span: mk_sp(lo, hi),\n                     inputs: inputs,\n                     output: output_ty,\n-                })\n+                })))\n             } else {\n-                ast::PathParameters::none()\n+                None\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier,\n-                                             parameters: parameters });\n+            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1757,25 +1755,21 @@ impl<'a> Parser<'a> {\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none()\n-                });\n+                segments.push(identifier.into());\n                 return Ok(segments);\n             }\n \n             // Check for a type segment.\n             if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-                let parameters = ast::AngleBracketedParameterData {\n-                    lifetimes: lifetimes,\n-                    types: P::from_vec(types),\n-                    bindings: P::from_vec(bindings),\n-                };\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n-                    parameters: ast::PathParameters::AngleBracketed(parameters),\n+                    parameters: ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: P::from_vec(types),\n+                        bindings: P::from_vec(bindings),\n+                    }.into(),\n                 });\n \n                 // Consumed `a::b::<T,U>`, check for `::` before proceeding\n@@ -1784,10 +1778,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none(),\n-                });\n+                segments.push(identifier.into());\n             }\n         }\n     }\n@@ -1802,10 +1793,7 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                parameters: ast::PathParameters::none()\n-            });\n+            segments.push(identifier.into());\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {"}, {"sha": "22e8391de93ed4910d9fbf988db6e3093392c844", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -2349,7 +2349,9 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+            if let Some(ref parameters) = segment.parameters {\n+                try!(self.print_path_parameters(parameters, colons_before_params))\n+            }\n         }\n \n         Ok(())\n@@ -2373,18 +2375,17 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"::\"));\n         let item_segment = path.segments.last().unwrap();\n         try!(self.print_ident(item_segment.identifier));\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+        match item_segment.parameters {\n+            Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n+            None => Ok(()),\n+        }\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &ast::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()>\n     {\n-        if parameters.is_empty() {\n-            return Ok(());\n-        }\n-\n         if colons_before_params {\n             try!(word(&mut self.s, \"::\"))\n         }"}, {"sha": "4ad760a3cafe4194ca60be1ec28fb9e5c5c12168", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -81,9 +81,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n-            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: ast::Ident::from_str(name),\n-                parameters: ast::PathParameters::none(),\n+            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                ast::Ident::from_str(name).into()\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "7709d3bd1cf1ce27e5bcd1492ac54a34a7ad08b8", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -580,10 +580,7 @@ fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n-        segments: ids.into_iter().map(|identifier| ast::PathSegment {\n-            identifier: identifier,\n-            parameters: ast::PathParameters::none(),\n-        }).collect()\n+        segments: ids.into_iter().map(Into::into).collect(),\n     }\n }\n "}, {"sha": "ad29cb50a84c80221e308b2b381ed08bed08406e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -178,7 +178,6 @@ pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n \n pub fn walk_macro_def<'a, V: Visitor<'a>>(visitor: &mut V, macro_def: &'a MacroDef) {\n     visitor.visit_ident(macro_def.span, macro_def.ident);\n-    walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n@@ -384,7 +383,9 @@ pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n-    visitor.visit_path_parameters(path_span, &segment.parameters);\n+    if let Some(ref parameters) = segment.parameters {\n+        visitor.visit_path_parameters(path_span, parameters);\n+    }\n }\n \n pub fn walk_path_parameters<'a, V>(visitor: &mut V,"}, {"sha": "1381490efa194b3bd7a1e7850aa35c394bae9a30", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -59,14 +59,10 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n \n     impl Result {\n         fn path(&self) -> ast::Path {\n-            let segment = ast::PathSegment {\n-                identifier: self.ident,\n-                parameters: ast::PathParameters::none(),\n-            };\n             ast::Path {\n                 span: self.span,\n                 global: false,\n-                segments: vec![segment],\n+                segments: vec![self.ident.into()],\n             }\n         }\n     }"}, {"sha": "e31b29d5cc1b435270cc4cf9949b7825e0b639f7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -50,8 +50,7 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n-use syntax::ext::tt::macro_rules::MacroRulesExpander;\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n@@ -61,8 +60,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n-\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),"}, {"sha": "187c56d7889ea52a27eb3d424a872f37e0e6558c", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,4 +13,4 @@\n # released on `$date`\n \n rustc: beta-2016-12-16\n-cargo: nightly-2016-11-16\n+cargo: fbeea902d2c9a5be6d99cc35681565d8f7832592"}, {"sha": "b2129902ef9c3bac73fa7389e3cee6d64784610b", "filename": "src/test/compile-fail/E0259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0259.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -15,6 +15,6 @@ extern crate collections;\n \n extern crate libc as collections;\n //~^ ERROR E0259\n-//~| NOTE `collections` was already imported\n+//~| NOTE `collections` already imported\n \n fn main() {}"}, {"sha": "211c0e6f890313130583ac8d7796ddd6a6403a2d", "filename": "src/test/compile-fail/E0277-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0277-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0277-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0277-2.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    bar: Bar\n+}\n+\n+struct Bar {\n+    baz: Baz\n+}\n+\n+struct Baz {\n+    x: *const u8\n+}\n+\n+fn is_send<T: Send>() { }\n+\n+fn main() {\n+    is_send::<Foo>();\n+    //~^ ERROR the trait bound `*const u8: std::marker::Send` is not satisfied in `Foo`\n+    //~| NOTE within `Foo`, the trait `std::marker::Send` is not implemented for `*const u8`\n+    //~| NOTE: `*const u8` cannot be sent between threads safely\n+    //~| NOTE: required because it appears within the type `Baz`\n+    //~| NOTE: required because it appears within the type `Bar`\n+    //~| NOTE: required because it appears within the type `Foo`\n+    //~| NOTE: required by `is_send`\n+}"}, {"sha": "e31fea1e45863205e40132d17162e04a9fbe9e85", "filename": "src/test/compile-fail/E0277.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0277.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2FE0277.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0277.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::path::Path;\n+\n trait Foo {\n     fn bar(&self);\n }\n@@ -16,6 +18,13 @@ fn some_func<T: Foo>(foo: T) {\n     foo.bar();\n }\n \n+fn f(p: Path) { }\n+//~^ ERROR the trait bound `[u8]: std::marker::Sized` is not satisfied in `std::path::Path`\n+//~| NOTE within `std::path::Path`, the trait `std::marker::Sized` is not implemented for `[u8]`\n+//~| NOTE `[u8]` does not have a constant size known at compile-time\n+//~| NOTE required because it appears within the type `std::path::Path`\n+//~| NOTE all local variables must have a statically known size\n+\n fn main() {\n     some_func(5i32);\n     //~^ ERROR the trait bound `i32: Foo` is not satisfied"}, {"sha": "e9df8868a1ed9d56a371b34802f629fda27d9c2c", "filename": "src/test/compile-fail/blind-item-item-shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -12,6 +12,6 @@ mod foo { pub mod foo {  } } //~ NOTE previous definition of `foo` here\n \n use foo::foo;\n //~^ ERROR a module named `foo` has already been defined in this module\n-//~| was already imported\n+//~| `foo` already defined\n \n fn main() {}"}, {"sha": "b98f464c902278443f7ecec8231ea4efc6c6508b", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3038f30f96fe366e910f9a02521c5a06e5cdc653/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038f30f96fe366e910f9a02521c5a06e5cdc653/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=3038f30f96fe366e910f9a02521c5a06e5cdc653", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn illegal_cast<U:?Sized,V:?Sized>(u: *const U) -> *const V\n-{\n-    u as *const V\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-}\n-\n-fn illegal_cast_2<U:?Sized>(u: *const U) -> *const str\n-{\n-    u as *const str\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-}\n-\n-trait Foo { fn foo(&self) {} }\n-impl<T> Foo for T {}\n-\n-trait Bar { fn foo(&self) {} }\n-impl<T> Bar for T {}\n-\n-enum E {\n-    A, B\n-}\n-\n-fn main()\n-{\n-    let f: f32 = 1.2;\n-    let v = 0 as *const u8;\n-    let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n-    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n-    let foo: &Foo = &f;\n-\n-    let _ = v as &u8; //~ ERROR non-scalar\n-    let _ = v as E; //~ ERROR non-scalar\n-    let _ = v as fn(); //~ ERROR non-scalar\n-    let _ = v as (u32,); //~ ERROR non-scalar\n-    let _ = Some(&v) as *const u8; //~ ERROR non-scalar\n-\n-    let _ = v as f32;\n-    //~^ ERROR casting\n-    let _ = main as f64;\n-    //~^ ERROR casting\n-    let _ = &v as usize;\n-    //~^ ERROR casting\n-    //~^^ HELP through a raw pointer first\n-    let _ = f as *const u8;\n-    //~^ ERROR casting\n-    let _ = 3_i32 as bool;\n-    //~^ ERROR cannot cast as `bool` [E0054]\n-    //~| unsupported cast\n-    //~| HELP compare with zero\n-    let _ = E::A as bool;\n-    //~^ ERROR cannot cast as `bool` [E0054]\n-    //~| unsupported cast\n-    //~| HELP compare with zero\n-    let _ = 0x61u32 as char; //~ ERROR only `u8` can be cast\n-\n-    let _ = false as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-    let _ = E::A as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-    let _ = 'a' as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-\n-    let _ = false as *const u8;\n-    //~^ ERROR casting\n-    let _ = E::A as *const u8;\n-    //~^ ERROR casting\n-    let _ = 'a' as *const u8;\n-    //~^ ERROR casting\n-\n-    let _ = 42usize as *const [u8]; //~ ERROR casting\n-    let _ = v as *const [u8]; //~ ERROR cannot cast\n-    let _ = fat_v as *const Foo;\n-    //~^ ERROR the trait bound `[u8]: std::marker::Sized` is not satisfied\n-    //~| NOTE the trait `std::marker::Sized` is not implemented for `[u8]`\n-    //~| NOTE `[u8]` does not have a constant size known at compile-time\n-    //~| NOTE required for the cast to the object type `Foo`\n-    let _ = foo as *const str; //~ ERROR casting\n-    let _ = foo as *mut str; //~ ERROR casting\n-    let _ = main as *mut str; //~ ERROR casting\n-    let _ = &f as *mut f32; //~ ERROR casting\n-    let _ = &f as *const f64; //~ ERROR casting\n-    let _ = fat_sv as usize;\n-    //~^ ERROR casting\n-    //~^^ HELP through a thin pointer first\n-\n-    let a : *const str = \"hello\";\n-    let _ = a as *const Foo;\n-    //~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n-    //~| NOTE the trait `std::marker::Sized` is not implemented for `str`\n-    //~| NOTE `str` does not have a constant size known at compile-time\n-    //~| NOTE required for the cast to the object type `Foo`\n-\n-    // check no error cascade\n-    let _ = main.f as *const u32; //~ no field `f` on type `fn() {main}`\n-\n-    let cf: *const Foo = &0;\n-    let _ = cf as *const [u16];\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-    let _ = cf as *const Bar;\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-\n-    vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n-    //~^ ERROR casting `&{float}` as `f32` is invalid\n-    //~| NOTE cannot cast `&{float}` as `f32`\n-    //~| NOTE did you mean `*s`?\n-}"}, {"sha": "88e804fb8aa0870df57fc4f6e25a2bb07effb47f", "filename": "src/test/compile-fail/issue-19498.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -11,13 +11,13 @@\n use self::A; //~ NOTE previous import of `A` here\n use self::B; //~ NOTE previous import of `B` here\n mod A {} //~ ERROR a module named `A` has already been imported in this module\n-//~| `A` was already imported\n+//~| `A` already imported\n pub mod B {} //~ ERROR a module named `B` has already been imported in this module\n-//~| `B` was already imported\n+//~| `B` already imported\n mod C {\n     use C::D; //~ NOTE previous import of `D` here\n     mod D {} //~ ERROR a module named `D` has already been imported in this module\n-    //~| `D` was already imported\n+    //~| `D` already imported\n }\n \n fn main() {}"}, {"sha": "26bb72b862f2ce888560f9a8cf28e013beeab465", "filename": "src/test/compile-fail/issue-24081.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -15,14 +15,14 @@ use std::ops::Div; //~ NOTE previous import\n use std::ops::Rem; //~ NOTE previous import\n \n type Add = bool; //~ ERROR a trait named `Add` has already been imported in this module\n-//~| was already imported\n+//~| `Add` already imported\n struct Sub { x: f32 } //~ ERROR a trait named `Sub` has already been imported in this module\n-//~| was already imported\n+//~| `Sub` already imported\n enum Mul { A, B } //~ ERROR a trait named `Mul` has already been imported in this module\n-//~| was already imported\n+//~| `Mul` already imported\n mod Div { } //~ ERROR a trait named `Div` has already been imported in this module\n-//~| was already imported\n+//~| `Div` already imported\n trait Rem {  } //~ ERROR a trait named `Rem` has already been imported in this module\n-//~| was already imported\n+//~| `Rem` already imported\n \n fn main() {}"}, {"sha": "56eb5f874cd618fc5d582e7947e92b0596a96e31", "filename": "src/test/compile-fail/issue-38458.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-38458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fissue-38458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38458.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const x: () = {\n+    return; //~ ERROR return statement outside of function body\n+};\n+\n+fn main() {}"}, {"sha": "2083d98e09d310a2da3c446d143f63272edf6d48", "filename": "src/test/compile-fail/resolve-conflict-item-vs-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -13,6 +13,6 @@ use std::mem::transmute;\n \n fn transmute() {}\n //~^ ERROR a value named `transmute` has already been imported in this module\n-//~| was already imported\n+//~| `transmute` already imported\n fn main() {\n }"}, {"sha": "75c665b04a12325392ce0f5eb59bbec3cd113e0d", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-android FIXME #17520\n // ignore-emscripten spawning processes is not supported\n+// ignore-openbsd no support for libbacktrace without filename\n // compile-flags:-g\n \n use std::env;"}, {"sha": "f72be0d7054dbc4311a1f0d98b280ef99a202dfe", "filename": "src/test/ui/mismatched_types/cast-rfc0401.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn illegal_cast<U:?Sized,V:?Sized>(u: *const U) -> *const V\n+{\n+    u as *const V\n+}\n+\n+fn illegal_cast_2<U:?Sized>(u: *const U) -> *const str\n+{\n+    u as *const str\n+}\n+\n+trait Foo { fn foo(&self) {} }\n+impl<T> Foo for T {}\n+\n+trait Bar { fn foo(&self) {} }\n+impl<T> Bar for T {}\n+\n+enum E {\n+    A, B\n+}\n+\n+fn main()\n+{\n+    let f: f32 = 1.2;\n+    let v = 0 as *const u8;\n+    let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n+    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n+    let foo: &Foo = &f;\n+\n+    let _ = v as &u8;\n+    let _ = v as E;\n+    let _ = v as fn();\n+    let _ = v as (u32,);\n+    let _ = Some(&v) as *const u8;\n+\n+    let _ = v as f32;\n+    let _ = main as f64;\n+    let _ = &v as usize;\n+    let _ = f as *const u8;\n+    let _ = 3_i32 as bool;\n+    let _ = E::A as bool;\n+    let _ = 0x61u32 as char;\n+\n+    let _ = false as f32;\n+    let _ = E::A as f32;\n+    let _ = 'a' as f32;\n+\n+    let _ = false as *const u8;\n+    let _ = E::A as *const u8;\n+    let _ = 'a' as *const u8;\n+\n+    let _ = 42usize as *const [u8];\n+    let _ = v as *const [u8];\n+    let _ = fat_v as *const Foo;\n+    let _ = foo as *const str;\n+    let _ = foo as *mut str;\n+    let _ = main as *mut str;\n+    let _ = &f as *mut f32;\n+    let _ = &f as *const f64;\n+    let _ = fat_sv as usize;\n+\n+    let a : *const str = \"hello\";\n+    let _ = a as *const Foo;\n+\n+    // check no error cascade\n+    let _ = main.f as *const u32;\n+\n+    let cf: *const Foo = &0;\n+    let _ = cf as *const [u16];\n+    let _ = cf as *const Bar;\n+\n+    vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+}"}, {"sha": "7fd10f3cb689176f9c23ac53a4c5ee3fee518352", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -0,0 +1,240 @@\n+error: casting `*const U` as `*const V` is invalid\n+  --> $DIR/cast-rfc0401.rs:13:5\n+   |\n+13 |     u as *const V\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: casting `*const U` as `*const str` is invalid\n+  --> $DIR/cast-rfc0401.rs:18:5\n+   |\n+18 |     u as *const str\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: no field `f` on type `fn() {main}`\n+  --> $DIR/cast-rfc0401.rs:75:18\n+   |\n+75 |     let _ = main.f as *const u32;\n+   |                  ^\n+\n+error: non-scalar cast: `*const u8` as `&u8`\n+  --> $DIR/cast-rfc0401.rs:39:13\n+   |\n+39 |     let _ = v as &u8;\n+   |             ^^^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `E`\n+  --> $DIR/cast-rfc0401.rs:40:13\n+   |\n+40 |     let _ = v as E;\n+   |             ^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `fn()`\n+  --> $DIR/cast-rfc0401.rs:41:13\n+   |\n+41 |     let _ = v as fn();\n+   |             ^^^^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `(u32,)`\n+  --> $DIR/cast-rfc0401.rs:42:13\n+   |\n+42 |     let _ = v as (u32,);\n+   |             ^^^^^^^^^^^\n+\n+error: non-scalar cast: `std::option::Option<&*const u8>` as `*const u8`\n+  --> $DIR/cast-rfc0401.rs:43:13\n+   |\n+43 |     let _ = Some(&v) as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `*const u8` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:45:13\n+   |\n+45 |     let _ = v as f32;\n+   |             ^^^^^^^^\n+\n+error: casting `fn() {main}` as `f64` is invalid\n+  --> $DIR/cast-rfc0401.rs:46:13\n+   |\n+46 |     let _ = main as f64;\n+   |             ^^^^^^^^^^^\n+\n+error: casting `&*const u8` as `usize` is invalid\n+  --> $DIR/cast-rfc0401.rs:47:13\n+   |\n+47 |     let _ = &v as usize;\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: cast through a raw pointer first\n+\n+error: casting `f32` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:48:13\n+   |\n+48 |     let _ = f as *const u8;\n+   |             ^^^^^^^^^^^^^^\n+\n+error[E0054]: cannot cast as `bool`\n+  --> $DIR/cast-rfc0401.rs:49:13\n+   |\n+49 |     let _ = 3_i32 as bool;\n+   |             ^^^^^^^^^^^^^ unsupported cast\n+   |\n+   = help: compare with zero instead\n+\n+error[E0054]: cannot cast as `bool`\n+  --> $DIR/cast-rfc0401.rs:50:13\n+   |\n+50 |     let _ = E::A as bool;\n+   |             ^^^^^^^^^^^^ unsupported cast\n+   |\n+   = help: compare with zero instead\n+\n+error: only `u8` can be cast as `char`, not `u32`\n+  --> $DIR/cast-rfc0401.rs:51:13\n+   |\n+51 |     let _ = 0x61u32 as char;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: casting `bool` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:53:13\n+   |\n+53 |     let _ = false as f32;\n+   |             ^^^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `E` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:54:13\n+   |\n+54 |     let _ = E::A as f32;\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `char` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:55:13\n+   |\n+55 |     let _ = 'a' as f32;\n+   |             ^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `bool` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:57:13\n+   |\n+57 |     let _ = false as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: casting `E` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:58:13\n+   |\n+58 |     let _ = E::A as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: casting `char` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:59:13\n+   |\n+59 |     let _ = 'a' as *const u8;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `usize` as `*const [u8]` is invalid\n+  --> $DIR/cast-rfc0401.rs:61:13\n+   |\n+61 |     let _ = 42usize as *const [u8];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot cast thin pointer `*const u8` to fat pointer `*const [u8]`\n+  --> $DIR/cast-rfc0401.rs:62:13\n+   |\n+62 |     let _ = v as *const [u8];\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `&Foo` as `*const str` is invalid\n+  --> $DIR/cast-rfc0401.rs:64:13\n+   |\n+64 |     let _ = foo as *const str;\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: casting `&Foo` as `*mut str` is invalid\n+  --> $DIR/cast-rfc0401.rs:65:13\n+   |\n+65 |     let _ = foo as *mut str;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: casting `fn() {main}` as `*mut str` is invalid\n+  --> $DIR/cast-rfc0401.rs:66:13\n+   |\n+66 |     let _ = main as *mut str;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `&f32` as `*mut f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:67:13\n+   |\n+67 |     let _ = &f as *mut f32;\n+   |             ^^^^^^^^^^^^^^\n+\n+error: casting `&f32` as `*const f64` is invalid\n+  --> $DIR/cast-rfc0401.rs:68:13\n+   |\n+68 |     let _ = &f as *const f64;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `*const [i8]` as `usize` is invalid\n+  --> $DIR/cast-rfc0401.rs:69:13\n+   |\n+69 |     let _ = fat_sv as usize;\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = help: cast through a thin pointer first\n+\n+error: casting `*const Foo` as `*const [u16]` is invalid\n+  --> $DIR/cast-rfc0401.rs:78:13\n+   |\n+78 |     let _ = cf as *const [u16];\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: casting `*const Foo` as `*const Bar` is invalid\n+  --> $DIR/cast-rfc0401.rs:79:13\n+   |\n+79 |     let _ = cf as *const Bar;\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error[E0277]: the trait bound `[u8]: std::marker::Sized` is not satisfied\n+  --> $DIR/cast-rfc0401.rs:63:13\n+   |\n+63 |     let _ = fat_v as *const Foo;\n+   |             ^^^^^ the trait `std::marker::Sized` is not implemented for `[u8]`\n+   |\n+   = note: `[u8]` does not have a constant size known at compile-time\n+   = note: required for the cast to the object type `Foo`\n+\n+error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n+  --> $DIR/cast-rfc0401.rs:72:13\n+   |\n+72 |     let _ = a as *const Foo;\n+   |             ^ the trait `std::marker::Sized` is not implemented for `str`\n+   |\n+   = note: `str` does not have a constant size known at compile-time\n+   = note: required for the cast to the object type `Foo`\n+\n+error: casting `&{float}` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:81:30\n+   |\n+81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+   |                              ^^^^^^^^ cannot cast `&{float}` as `f32`\n+   |\n+help: did you mean `*s`?\n+  --> $DIR/cast-rfc0401.rs:81:30\n+   |\n+81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+   |                              ^\n+\n+error: aborting due to 34 previous errors\n+"}, {"sha": "faf0a0eaa81ee5098e7d0ee18be607e4bec58085", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,3 +8,4 @@ build = \"build.rs\"\n log = \"0.3\"\n env_logger = { version = \"0.3.5\", default-features = false }\n serialize = { path = \"../../libserialize\" }\n+build_helper = { path = \"../../build_helper\" }"}, {"sha": "9e2416fca81aeabdaf7de92140f0f0c592eac192", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164619a8cfe6d376d25bd3a6a9a5f2856c8de64d/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=164619a8cfe6d376d25bd3a6a9a5f2856c8de64d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern crate build_helper;\n+\n use common::Config;\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n@@ -2108,7 +2110,7 @@ actual:\\n\\\n         }\n         self.create_dir_racy(&tmpdir);\n \n-        let mut cmd = Command::new(\"make\");\n+        let mut cmd = Command::new(build_helper::make(&self.config.host));\n         cmd.current_dir(&self.testpaths.file)\n            .env(\"TARGET\", &self.config.target)\n            .env(\"PYTHON\", &self.config.docck_python)\n@@ -2294,7 +2296,18 @@ actual:\\n\\\n                 };\n             }\n             if !found {\n-                panic!(\"ran out of mir dump output to match against\");\n+                let normalize_all = dumped_string.lines()\n+                                                 .map(nocomment_mir_line)\n+                                                 .filter(|l| !l.is_empty())\n+                                                 .collect::<Vec<_>>()\n+                                                 .join(\"\\n\");\n+                panic!(\"ran out of mir dump output to match against.\\n\\\n+                        Did not find expected line: {:?}\\n\\\n+                        Expected:\\n{}\\n\\\n+                        Actual:\\n{}\",\n+                        expected_line,\n+                        expected_content.join(\"\\n\"),\n+                        normalize_all);\n             }\n         }\n     }\n@@ -2439,11 +2452,14 @@ enum TargetLocation {\n }\n \n fn normalize_mir_line(line: &str) -> String {\n-    let no_comments = if let Some(idx) = line.find(\"//\") {\n+    nocomment_mir_line(line).replace(char::is_whitespace, \"\")\n+}\n+\n+fn nocomment_mir_line(line: &str) -> &str {\n+    if let Some(idx) = line.find(\"//\") {\n         let (l, _) = line.split_at(idx);\n-        l\n+        l.trim_right()\n     } else {\n         line\n-    };\n-    no_comments.replace(char::is_whitespace, \"\")\n+    }\n }"}]}