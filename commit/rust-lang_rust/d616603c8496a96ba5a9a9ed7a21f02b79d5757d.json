{"sha": "d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTY2MDNjODQ5NmE5NmJhNWE5YTllZDdhMjFmMDJiNzlkNTc1N2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T11:21:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-02T11:21:26Z"}, "message": "auto merge of #9673 : huonw/rust/macros, r=catamorphism\n\nThat is, only a single expression or item gets parsed, so if there are\r\nany extra tokens (e.g. the start of another item/expression) the user\r\nshould be told, rather than silently dropping them.\r\n\r\nAn example:\r\n\r\n    macro_rules! foo {\r\n        () => {\r\n            println(\"hi\");\r\n            println(\"bye);\r\n        }\r\n    }\r\n\r\nwould expand to just `println(\"hi\")`, which is almost certainly not\r\nwhat the programmer wanted.\r\n\r\nFixes #8012.", "tree": {"sha": "a2b953fb2f855834aa0a1d2e887424e42a2f0004", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2b953fb2f855834aa0a1d2e887424e42a2f0004"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "html_url": "https://github.com/rust-lang/rust/commit/d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d00c9269dce3a7925d7d0bf5edb64b3c6747c6af", "url": "https://api.github.com/repos/rust-lang/rust/commits/d00c9269dce3a7925d7d0bf5edb64b3c6747c6af", "html_url": "https://github.com/rust-lang/rust/commit/d00c9269dce3a7925d7d0bf5edb64b3c6747c6af"}, {"sha": "8284df9e7c3b26897d65935eaa7acee1a956a450", "url": "https://api.github.com/repos/rust-lang/rust/commits/8284df9e7c3b26897d65935eaa7acee1a956a450", "html_url": "https://github.com/rust-lang/rust/commit/8284df9e7c3b26897d65935eaa7acee1a956a450"}], "stats": {"total": 134, "additions": 56, "deletions": 78}, "files": [{"sha": "468e3e5e7f2bf0646ae76bed5e538c0559f4c21c", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "patch": "@@ -39,7 +39,7 @@ pub fn expand_deriving_eq(cx: @ExtCtxt,\n                 ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: true,\n                 combine_substructure: $f\n-            },\n+            }\n         }\n     );\n "}, {"sha": "de0afe23668c1fbb54595fbe2957da678e2fff52", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "patch": "@@ -21,22 +21,47 @@ use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n-use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n+use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n use print;\n \n struct ParserAnyMacro {\n     parser: @Parser,\n }\n \n+impl ParserAnyMacro {\n+    /// Make sure we don't have any tokens left to parse, so we don't\n+    /// silently drop anything. `allow_semi` is so that \"optional\"\n+    /// semilons at the end of normal expressions aren't complained\n+    /// about e.g. the semicolon in `macro_rules! kapow( () => {\n+    /// fail!(); } )` doesn't get picked up by .parse_expr(), but it's\n+    /// allowed to be there.\n+    fn ensure_complete_parse(&self, allow_semi: bool) {\n+        if allow_semi && *self.parser.token == SEMI {\n+            self.parser.bump()\n+        }\n+        if *self.parser.token != EOF {\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n+                              self.parser.this_token_to_str());\n+            self.parser.span_err(*self.parser.span, msg);\n+        }\n+    }\n+}\n+\n impl AnyMacro for ParserAnyMacro {\n     fn make_expr(&self) -> @ast::Expr {\n-        self.parser.parse_expr()\n+        let ret = self.parser.parse_expr();\n+        self.ensure_complete_parse(true);\n+        ret\n     }\n     fn make_item(&self) -> Option<@ast::item> {\n-        self.parser.parse_item(~[])     // no attrs\n+        let ret = self.parser.parse_item(~[]);     // no attrs\n+        self.ensure_complete_parse(false);\n+        ret\n     }\n     fn make_stmt(&self) -> @ast::Stmt {\n-        self.parser.parse_stmt(~[])     // no attrs\n+        let ret = self.parser.parse_stmt(~[]);     // no attrs\n+        self.ensure_complete_parse(true);\n+        ret\n     }\n }\n \n@@ -185,79 +210,6 @@ pub fn add_new_extension(cx: @ExtCtxt,\n       _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n-    // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt,\n-                         sp: Span,\n-                         name: Ident,\n-                         arg: &[ast::token_tree],\n-                         lhses: &[@named_match],\n-                         rhses: &[@named_match])\n-                         -> MacResult {\n-        if cx.trace_macros() {\n-            println!(\"{}! \\\\{ {} \\\\}\",\n-                      cx.str_of(name),\n-                      print::pprust::tt_to_str(\n-                          &ast::tt_delim(@mut arg.to_owned()),\n-                          get_ident_interner()));\n-        }\n-\n-        // Which arm's failure should we report? (the one furthest along)\n-        let mut best_fail_spot = dummy_sp();\n-        let mut best_fail_msg = ~\"internal error: ran no matchers\";\n-\n-        let s_d = cx.parse_sess().span_diagnostic;\n-\n-        for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-            match *lhs {\n-              @matched_nonterminal(nt_matchers(ref mtcs)) => {\n-                // `none` is because we're not interpolating\n-                let arg_rdr = new_tt_reader(\n-                    s_d,\n-                    None,\n-                    arg.to_owned()\n-                ) as @mut reader;\n-                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n-                  success(named_matches) => {\n-                    let rhs = match rhses[i] {\n-                        // okay, what's your transcriber?\n-                        @matched_nonterminal(nt_tt(@ref tt)) => {\n-                            match (*tt) {\n-                                // cut off delimiters; don't parse 'em\n-                                tt_delim(ref tts) => {\n-                                    (*tts).slice(1u,(*tts).len()-1u).to_owned()\n-                                }\n-                                _ => cx.span_fatal(\n-                                    sp, \"macro rhs must be delimited\")\n-                            }\n-                        },\n-                        _ => cx.span_bug(sp, \"bad thing in rhs\")\n-                    };\n-                    // rhs has holes ( `$id` and `$(...)` that need filled)\n-                    let trncbr = new_tt_reader(s_d, Some(named_matches),\n-                                               rhs);\n-                    let p = @Parser(cx.parse_sess(),\n-                                    cx.cfg(),\n-                                    trncbr as @mut reader);\n-\n-                    // Let the context choose how to interpret the result.\n-                    // Weird, but useful for X-macros.\n-                    return MRAny(@ParserAnyMacro {\n-                        parser: p\n-                    } as @AnyMacro);\n-                  }\n-                  failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n-                    best_fail_spot = sp;\n-                    best_fail_msg = (*msg).clone();\n-                  },\n-                  error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n-                }\n-              }\n-              _ => cx.bug(\"non-matcher found in parsed lhses\")\n-            }\n-        }\n-        cx.span_fatal(best_fail_spot, best_fail_msg);\n-    }\n-\n     let exp = @MacroRulesSyntaxExpanderTTFun {\n         name: name,\n         lhses: lhses,"}, {"sha": "615a85c2e7e7170653c2d89e5ce9dc9d486b14ab", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d616603c8496a96ba5a9a9ed7a21f02b79d5757d/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=d616603c8496a96ba5a9a9ed7a21f02b79d5757d", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! ignored_item {\n+    () => {\n+        fn foo() {}\n+        fn bar() {} //~ ERROR macro expansion ignores token `fn`\n+    }\n+}\n+\n+macro_rules! ignored_expr {\n+    () => ( 1, 2 ) //~ ERROR macro expansion ignores token `,`\n+}\n+\n+ignored_item!()\n+\n+fn main() {\n+    ignored_expr!()\n+}"}]}