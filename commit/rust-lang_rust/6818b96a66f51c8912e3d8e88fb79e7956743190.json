{"sha": "6818b96a66f51c8912e3d8e88fb79e7956743190", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MThiOTZhNjZmNTFjODkxMmUzZDhlODhmYjc5ZTc5NTY3NDMxOTA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-11-29T18:12:08Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-11-29T19:19:19Z"}, "message": "extra: json::Encoder should take a &mut io::Writer", "tree": {"sha": "cb0f8cca90afff86aac298d6ed99dfb8f59140a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb0f8cca90afff86aac298d6ed99dfb8f59140a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6818b96a66f51c8912e3d8e88fb79e7956743190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6818b96a66f51c8912e3d8e88fb79e7956743190", "html_url": "https://github.com/rust-lang/rust/commit/6818b96a66f51c8912e3d8e88fb79e7956743190", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6818b96a66f51c8912e3d8e88fb79e7956743190/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9", "html_url": "https://github.com/rust-lang/rust/commit/f7b739c34c8b25ca6c98a97dcd1189063f1bf5e9"}], "stats": {"total": 123, "additions": 62, "deletions": 61}, "files": [{"sha": "1b2165fb4cf863bf0be76c6ad656638ab86853a7", "filename": "src/libextra/json.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=6818b96a66f51c8912e3d8e88fb79e7956743190", "patch": "@@ -84,19 +84,19 @@ fn spaces(n: uint) -> ~str {\n }\n \n /// A structure for implementing serialization to JSON.\n-pub struct Encoder {\n-    priv wr: @mut io::Writer,\n+pub struct Encoder<'self> {\n+    priv wr: &'self mut io::Writer,\n }\n \n-impl Encoder {\n+impl<'self> Encoder<'self> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn init(wr: @mut io::Writer) -> Encoder {\n+    pub fn init<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n }\n \n-impl serialize::Encoder for Encoder {\n+impl<'self> serialize::Encoder for Encoder<'self> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -129,13 +129,13 @@ impl serialize::Encoder for Encoder {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder|) { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'self>|) { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -150,7 +150,7 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n@@ -161,18 +161,18 @@ impl serialize::Encoder for Encoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut Encoder|) {\n+                                f: |&mut Encoder<'self>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut Encoder|) {\n+                                      f: |&mut Encoder<'self>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder|) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n@@ -181,81 +181,81 @@ impl serialize::Encoder for Encoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: |&mut Encoder|) {\n+                         f: |&mut Encoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut Encoder|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder|) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, \"[\");\n         f(self);\n         write!(self.wr, \"]\");\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder|) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'self>|) {\n         write!(self.wr, \":\");\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n-pub struct PrettyEncoder {\n-    priv wr: @mut io::Writer,\n+pub struct PrettyEncoder<'self> {\n+    priv wr: &'self mut io::Writer,\n     priv indent: uint,\n }\n \n-impl PrettyEncoder {\n+impl<'self> PrettyEncoder<'self> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn init(wr: @mut io::Writer) -> PrettyEncoder {\n+    pub fn init<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n         }\n     }\n }\n \n-impl serialize::Encoder for PrettyEncoder {\n+impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -286,15 +286,15 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder|) {\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'self>|) {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         if cnt == 0 {\n             write!(self.wr, \"{}\", escape_str(name));\n         } else {\n@@ -308,7 +308,7 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder|) {\n+                             f: |&mut PrettyEncoder<'self>|) {\n         if idx != 0 {\n             write!(self.wr, \",\\n\");\n         }\n@@ -320,22 +320,22 @@ impl serialize::Encoder for PrettyEncoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut PrettyEncoder|) {\n+                                f: |&mut PrettyEncoder<'self>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut PrettyEncoder|) {\n+                                      f: |&mut PrettyEncoder<'self>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: |&mut PrettyEncoder|) {\n+                   f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -350,7 +350,7 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -360,30 +360,30 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: |&mut PrettyEncoder|) {\n+                         f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder|) {\n+                             f: |&mut PrettyEncoder<'self>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n \n-    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"[]\");\n         } else {\n@@ -395,7 +395,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -405,7 +405,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -417,7 +417,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -427,7 +427,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'self>|) {\n         write!(self.wr, \": \");\n         f(self);\n     }\n@@ -448,22 +448,22 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: @mut io::Writer) {\n+    pub fn to_writer(&self, wr: &mut io::Writer) {\n         let mut encoder = Encoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: @mut io::Writer) {\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n         let mut encoder = PrettyEncoder::init(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n-        let s = @mut MemWriter::new();\n-        self.to_pretty_writer(s as @mut io::Writer);\n+        let mut s = MemWriter::new();\n+        self.to_pretty_writer(&mut s as &mut io::Writer);\n         str::from_utf8(s.inner_ref().as_slice())\n     }\n }"}, {"sha": "ab36defe5221418f28e6aa49114c8e09ef49b9b1", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=6818b96a66f51c8912e3d8e88fb79e7956743190", "patch": "@@ -256,9 +256,9 @@ enum Work<'self, T> {\n     WorkFromTask(&'self Prep<'self>, PortOne<(Exec, T)>),\n }\n \n-fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let writer = @mut MemWriter::new();\n-    let mut encoder = json::Encoder::init(writer as @mut io::Writer);\n+fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n+    let mut writer = MemWriter::new();\n+    let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n     str::from_utf8(writer.inner_ref().as_slice())\n }\n@@ -396,15 +396,15 @@ impl<'self> Prep<'self> {\n         return true;\n     }\n \n-    pub fn exec<T:Send +\n-        Encodable<json::Encoder> +\n+    pub fn exec<'self, T:Send +\n+        Encodable<json::Encoder<'self>> +\n         Decodable<json::Decoder>>(\n             &'self self, blk: proc(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n-    fn exec_work<T:Send +\n-        Encodable<json::Encoder> +\n+    fn exec_work<'self, T:Send +\n+        Encodable<json::Encoder<'self>> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n             &'self self, blk: proc(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n@@ -449,7 +449,7 @@ impl<'self> Prep<'self> {\n }\n \n impl<'self, T:Send +\n-       Encodable<json::Encoder> +\n+       Encodable<json::Encoder<'self>> +\n        Decodable<json::Decoder>>\n     Work<'self, T> { // FIXME(#5121)\n "}, {"sha": "988e9958c2b83fca24eb1a66a2c25a25489a7a46", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6818b96a66f51c8912e3d8e88fb79e7956743190/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6818b96a66f51c8912e3d8e88fb79e7956743190", "patch": "@@ -341,9 +341,10 @@ mod test {\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n \n-    #[cfg(test)] fn to_json_str<E : Encodable<extra::json::Encoder>>(val: @E) -> ~str {\n-        let writer = @mut MemWriter::new();\n-        let mut encoder = extra::json::Encoder::init(writer as @mut io::Writer);\n+    #[cfg(test)]\n+    fn to_json_str<'a, E: Encodable<extra::json::Encoder<'a>>>(val: &E) -> ~str {\n+        let mut writer = MemWriter::new();\n+        let mut encoder = extra::json::Encoder::init(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n         str::from_utf8(*writer.inner_ref())\n     }"}]}