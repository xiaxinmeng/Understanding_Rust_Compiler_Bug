{"sha": "8517ca50103847db6dfb59191aad5e06aa53a3d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MTdjYTUwMTAzODQ3ZGI2ZGZiNTkxOTFhYWQ1ZTA2YWE1M2EzZDI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-12T19:15:37Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-12T19:15:37Z"}, "message": "Merge branch 'master' of github.com:Manishearth/rust-clippy", "tree": {"sha": "e89627c8a04a3056ef098ae355d8d69ac9b8f819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e89627c8a04a3056ef098ae355d8d69ac9b8f819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8517ca50103847db6dfb59191aad5e06aa53a3d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8517ca50103847db6dfb59191aad5e06aa53a3d2", "html_url": "https://github.com/rust-lang/rust/commit/8517ca50103847db6dfb59191aad5e06aa53a3d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8517ca50103847db6dfb59191aad5e06aa53a3d2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dac50c5c2e04545af1149192743b663e7636be", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dac50c5c2e04545af1149192743b663e7636be", "html_url": "https://github.com/rust-lang/rust/commit/b5dac50c5c2e04545af1149192743b663e7636be"}, {"sha": "13a0d5cd9f050ef00037231d57a6e0f44f863d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/13a0d5cd9f050ef00037231d57a6e0f44f863d2c", "html_url": "https://github.com/rust-lang/rust/commit/13a0d5cd9f050ef00037231d57a6e0f44f863d2c"}], "stats": {"total": 1264, "additions": 907, "deletions": 357}, "files": [{"sha": "c2d3b16074cc4f8043e349778d338451ab110bff", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 119 lints included in this crate:\n+There are 120 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -65,6 +65,7 @@ name\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                       | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                 | warn    | a match has overlapping arms\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                               | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                             | warn    | `match` with identical arm bodies\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                             | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                       | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                             | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)"}, {"sha": "7cb0683711a58f495593a1b4d7f111ccccc0b73e", "filename": "src/consts.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -2,21 +2,18 @@\n \n use rustc::lint::LateContext;\n use rustc::middle::const_eval::lookup_const_by_id;\n-use rustc::middle::def::PathResolution;\n-use rustc::middle::def::Def;\n+use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n-use syntax::ptr::P;\n-use std::cmp::PartialOrd;\n use std::cmp::Ordering::{self, Greater, Less, Equal};\n-use std::rc::Rc;\n+use std::cmp::PartialOrd;\n+use std::hash::{Hash, Hasher};\n+use std::mem;\n use std::ops::Deref;\n+use std::rc::Rc;\n+use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy};\n+use syntax::ptr::P;\n \n-use syntax::ast::LitKind;\n-use syntax::ast::LitIntType;\n-use syntax::ast::{UintTy, FloatTy, StrStyle};\n-\n-\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+#[derive(Debug, Copy, Clone)]\n pub enum FloatWidth {\n     Fw32,\n     Fw64,\n@@ -32,14 +29,14 @@ impl From<FloatTy> for FloatWidth {\n     }\n }\n \n-#[derive(Copy, Eq, Debug, Clone, PartialEq)]\n+#[derive(Copy, Eq, Debug, Clone, PartialEq, Hash)]\n pub enum Sign {\n     Plus,\n     Minus,\n }\n \n /// a Lit_-like enum to fold constant `Expr`s into\n-#[derive(Eq, Debug, Clone)]\n+#[derive(Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\"\n     Str(String, StrStyle),\n@@ -101,18 +98,12 @@ impl PartialEq for Constant {\n             (&Constant::Int(lv, _, lneg), &Constant::Int(rv, _, rneg)) => {\n                 lv == rv && lneg == rneg\n             }\n-            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n-                use self::FloatWidth::*;\n-                if match (lw, rw) {\n-                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n+            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n+                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n+                // `Fw32 == Fw64` so don\u2019t compare them\n+                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                    (Ok(l), Ok(r)) => l.eq(&r),\n                     _ => false,\n-                } {\n-                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                        (Ok(l), Ok(r)) => l.eq(&r),\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n                 }\n             }\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n@@ -124,6 +115,46 @@ impl PartialEq for Constant {\n     }\n }\n \n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        match *self {\n+            Constant::Str(ref s, ref k) => {\n+                s.hash(state);\n+                k.hash(state);\n+            }\n+            Constant::Binary(ref b) => {\n+                b.hash(state);\n+            }\n+            Constant::Byte(u) => {\n+                u.hash(state);\n+            }\n+            Constant::Char(c) => {\n+                c.hash(state);\n+            }\n+            Constant::Int(u, _, t) => {\n+                u.hash(state);\n+                t.hash(state);\n+            }\n+            Constant::Float(ref f, _) => {\n+                // don\u2019t use the width here because of PartialEq implementation\n+                if let Ok(f) = f.parse::<f64>() {\n+                    unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n+                }\n+            }\n+            Constant::Bool(b) => {\n+                b.hash(state);\n+            }\n+            Constant::Vec(ref v) | Constant::Tuple(ref v)=> {\n+                v.hash(state);\n+            }\n+            Constant::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n@@ -141,18 +172,10 @@ impl PartialOrd for Constant {\n             (&Constant::Int(ref lv, _, Sign::Minus), &Constant::Int(ref rv, _, Sign::Minus)) => Some(rv.cmp(lv)),\n             (&Constant::Int(_, _, Sign::Minus), &Constant::Int(_, _, Sign::Plus)) => Some(Less),\n             (&Constant::Int(_, _, Sign::Plus), &Constant::Int(_, _, Sign::Minus)) => Some(Greater),\n-            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n-                use self::FloatWidth::*;\n-                if match (lw, rw) {\n-                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n-                    _ => false,\n-                } {\n-                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                        (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n+            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n+                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                    (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n+                    _ => None,\n                 }\n             }\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n@@ -187,8 +210,7 @@ fn constant_not(o: Constant) -> Option<Constant> {\n     use self::Constant::*;\n     match o {\n         Bool(b) => Some(Bool(!b)),\n-        Int(::std::u64::MAX, LitIntType::Signed(_), Sign::Plus) => None,\n-        Int(value, LitIntType::Signed(ity), Sign::Plus) => Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus)),\n+        Int(value, LitIntType::Signed(ity), Sign::Plus) if value != ::std::u64::MAX => Some(Int(value + 1, LitIntType::Signed(ity), Sign::Minus)),\n         Int(0, LitIntType::Signed(ity), Sign::Minus) => Some(Int(1, LitIntType::Signed(ity), Sign::Minus)),\n         Int(value, LitIntType::Signed(ity), Sign::Minus) => Some(Int(value - 1, LitIntType::Signed(ity), Sign::Plus)),\n         Int(value, LitIntType::Unsigned(ity), Sign::Plus) => {"}, {"sha": "e2defe8f3649f687da9a17517dcb787c2027bf05", "filename": "src/copies.rs", "status": "modified", "additions": 182, "deletions": 29, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -1,6 +1,12 @@\n use rustc::lint::*;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n-use utils::{get_parent_expr, in_macro, is_block_equal, is_exp_equal, span_lint, span_note_and_lint};\n+use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n+use syntax::parse::token::InternedString;\n+use syntax::util::small_vector::SmallVector;\n+use utils::{SpanlessEq, SpanlessHash};\n+use utils::{get_parent_expr, in_macro, span_note_and_lint};\n \n /// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n /// `Warn` by default.\n@@ -30,65 +36,121 @@ declare_lint! {\n     \"if with the same *then* and *else* blocks\"\n }\n \n+/// **What it does:** This lint checks for `match` with identical arm bodies.\n+///\n+/// **Why is this bad?** This is probably a copy & paste error.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// match foo {\n+///     Bar => bar(),\n+///     Quz => quz(),\n+///     Baz => bar(), // <= oups\n+/// ```\n+declare_lint! {\n+    pub MATCH_SAME_ARMS,\n+    Warn,\n+    \"`match` with identical arm bodies\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct CopyAndPaste;\n \n impl LintPass for CopyAndPaste {\n     fn get_lints(&self) -> LintArray {\n         lint_array![\n             IFS_SAME_COND,\n-            IF_SAME_THEN_ELSE\n+            IF_SAME_THEN_ELSE,\n+            MATCH_SAME_ARMS\n         ]\n     }\n }\n \n impl LateLintPass for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if !in_macro(cx, expr.span) {\n-            lint_same_then_else(cx, expr);\n-            lint_same_cond(cx, expr);\n+            // skip ifs directly in else, it will be checked in the parent if\n+            if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n+                if else_expr.id == expr.id {\n+                    return;\n+                }\n+            }\n+\n+            let (conds, blocks) = if_sequence(expr);\n+            lint_same_then_else(cx, blocks.as_slice());\n+            lint_same_cond(cx, conds.as_slice());\n+            lint_match_arms(cx, expr);\n         }\n     }\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n-    if let ExprIf(_, ref then_block, Some(ref else_expr)) = expr.node {\n-        if let ExprBlock(ref else_block) = else_expr.node {\n-            if is_block_equal(cx, &then_block, &else_block, false) {\n-                span_lint(cx, IF_SAME_THEN_ELSE, expr.span, \"this if has the same then and else blocks\");\n-            }\n-        }\n+fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n+    let hash : &Fn(&&Block) -> u64 = &|block| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_block(block);\n+        h.finish()\n+    };\n+\n+    let eq : &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool {\n+        SpanlessEq::new(cx).eq_block(lhs, rhs)\n+    };\n+\n+    if let Some((i, j)) = search_same(blocks, hash, eq) {\n+        span_note_and_lint(cx, IF_SAME_THEN_ELSE, j.span, \"this `if` has identical blocks\", i.span, \"same as this\");\n     }\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext, expr: &Expr) {\n-    // skip ifs directly in else, it will be checked in the parent if\n-    if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n-        if else_expr.id == expr.id {\n-            return;\n-        }\n+fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n+    let hash : &Fn(&&Expr) -> u64 = &|expr| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(expr);\n+        h.finish()\n+    };\n+\n+    let eq : &Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool {\n+        SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs)\n+    };\n+\n+    if let Some((i, j)) = search_same(conds, hash, eq) {\n+        span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this `if` has the same condition as a previous if\", i.span, \"same as this\");\n     }\n+}\n \n-    let conds = condition_sequence(expr);\n+/// Implementation if `MATCH_SAME_ARMS`.\n+fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n+    let hash = |arm: &Arm| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(&arm.body);\n+        h.finish()\n+    };\n \n-    for (n, i) in conds.iter().enumerate() {\n-        for j in conds.iter().skip(n+1) {\n-            if is_exp_equal(cx, i, j, true) {\n-                span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n-            }\n+    let eq = |lhs: &Arm, rhs: &Arm| -> bool {\n+        SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n+            // all patterns should have the same bindings\n+            bindings(cx, &lhs.pats[0]) == bindings(cx, &rhs.pats[0])\n+    };\n+\n+    if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n+        if let Some((i, j)) = search_same(&**arms, hash, eq) {\n+            span_note_and_lint(cx, MATCH_SAME_ARMS, j.body.span, \"this `match` has identical arm bodies\", i.body.span, \"same as this\");\n         }\n     }\n }\n \n-/// Return the list of condition expressions in a sequence of `if/else`.\n-/// Eg. would return `[a, b]` for the expression `if a {..} else if b {..}`.\n-fn condition_sequence(mut expr: &Expr) -> Vec<&Expr> {\n-    let mut result = vec![];\n+/// Return the list of condition expressions and the list of blocks in a sequence of `if/else`.\n+/// Eg. would return `([a, b], [c, d, e])` for the expression\n+/// `if a { c } else if b { d } else { e }`.\n+fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n+    let mut conds = SmallVector::zero();\n+    let mut blocks = SmallVector::zero();\n \n-    while let ExprIf(ref cond, _, ref else_expr) = expr.node {\n-        result.push(&**cond);\n+    while let ExprIf(ref cond, ref then_block, ref else_expr) = expr.node {\n+        conds.push(&**cond);\n+        blocks.push(&**then_block);\n \n         if let Some(ref else_expr) = *else_expr {\n             expr = else_expr;\n@@ -98,5 +160,96 @@ fn condition_sequence(mut expr: &Expr) -> Vec<&Expr> {\n         }\n     }\n \n+    // final `else {..}`\n+    if !blocks.is_empty() {\n+        if let ExprBlock(ref block) = expr.node {\n+            blocks.push(&**block);\n+        }\n+    }\n+\n+    (conds, blocks)\n+}\n+\n+/// Return the list of bindings in a pattern.\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n+        match pat.node {\n+            PatBox(ref pat) | PatRegion(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatEnum(_, Some(ref pats)) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatIdent(_, ref ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.node.name.as_str()) {\n+                    v.insert(cx.tcx.pat_ty(pat));\n+                }\n+                if let Some(ref as_pat) = *as_pat {\n+                    bindings_impl(cx, as_pat, map);\n+                }\n+            },\n+            PatStruct(_, ref fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.node.pat, map);\n+                }\n+            }\n+            PatTup(ref fields) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatVec(ref lhs, ref mid, ref rhs) => {\n+                for pat in lhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+                if let Some(ref mid) = *mid {\n+                    bindings_impl(cx, mid, map);\n+                }\n+                for pat in rhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatEnum(..) | PatLit(..) | PatQPath(..) | PatRange(..) | PatWild => (),\n+        }\n+    }\n+\n+    let mut result = HashMap::new();\n+    bindings_impl(cx, pat, &mut result);\n     result\n }\n+\n+fn search_same<T, Hash, Eq>(exprs: &[T],\n+                            hash: Hash,\n+                            eq: Eq) -> Option<(&T, &T)>\n+where Hash: Fn(&T) -> u64,\n+      Eq: Fn(&T, &T) -> bool {\n+    // common cases\n+    if exprs.len() < 2 {\n+        return None;\n+    }\n+    else if exprs.len() == 2 {\n+        return if eq(&exprs[0], &exprs[1]) {\n+            Some((&exprs[0], &exprs[1]))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+\n+    let mut map : HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(o) => {\n+                for o in o.get() {\n+                    if eq(&o, expr) {\n+                        return Some((&o, expr))\n+                    }\n+                }\n+            }\n+            Entry::Vacant(v) => { v.insert(vec![expr]); }\n+        }\n+    }\n+\n+    None\n+}"}, {"sha": "c2f2e956e5e46b55d8f5040e24f8b87423ef4b13", "filename": "src/entry.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -1,8 +1,9 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n-use utils::{get_item_name, is_exp_equal, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::SpanlessEq;\n use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n+use utils::{get_item_name, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n /// `BTreeMap`.\n@@ -89,7 +90,7 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             params.len() == 3,\n             name.node.as_str() == \"insert\",\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n-            is_exp_equal(cx, key, &params[1], false)\n+            SpanlessEq::new(cx).eq_expr(key, &params[1])\n         ], {\n             let help = if sole_expr {\n                 format!(\"{}.entry({}).or_insert({})\","}, {"sha": "fc1cab2cd71460f3f07460291ade54a3672c63c4", "filename": "src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc_front::util as ast_util;\n \n-use utils::{is_exp_equal, span_lint};\n+use utils::{SpanlessEq, span_lint};\n \n /// **What it does:** This lint checks for equal operands to comparison, logical and bitwise,\n /// difference and division binary operators (`==`, `>`, etc., `&&`, `||`, `&`, `|`, `^`, `-` and\n@@ -31,7 +31,7 @@ impl LintPass for EqOp {\n impl LateLintPass for EqOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_valid_operator(op) && is_exp_equal(cx, left, right, true) {\n+            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,\n                           EQ_OP,\n                           e.span,"}, {"sha": "222de03f006c414f8600df52801e2f131b0696a1", "filename": "src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -140,9 +140,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n         }\n     }\n     match (&left.node, &right.node) {\n-        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) => {\n-            check_len_zero(cx, span, &method.node, args, lit, op)\n-        }\n+        (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) |\n         (&ExprMethodCall(ref method, _, ref args), &ExprLit(ref lit)) => {\n             check_len_zero(cx, span, &method.node, args, lit, op)\n         }"}, {"sha": "675dbdd2dd712500ea8acfc76439c26eeb8c4f75", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -196,6 +196,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         collapsible_if::COLLAPSIBLE_IF,\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,\n+        copies::MATCH_SAME_ARMS,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         derive::DERIVE_HASH_NOT_EQ,\n         derive::EXPL_IMPL_CLONE_ON_COPY,"}, {"sha": "9263d65737151fdef2a8be4b1fb5566c1c352736", "filename": "src/methods.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -865,24 +865,23 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(&self, slf: &ExplicitSelf_, allow_value_for_ref: bool) -> bool {\n         match (self, slf) {\n-            (&SelfKind::Value, &SelfValue(_)) => true,\n-            (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n-            (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n-            (&SelfKind::Ref, &SelfValue(_)) => allow_value_for_ref,\n-            (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n-            (&SelfKind::No, &SelfStatic) => true,\n+            (&SelfKind::Value, &SelfValue(_)) |\n+                (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n+                (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n+                (&SelfKind::No, &SelfStatic) => true,\n+            (&SelfKind::Ref, &SelfValue(_)) | (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false,\n         }\n     }\n \n     fn matches_explicit_type(&self, ty: &Ty, allow_value_for_ref: bool) -> bool {\n         match (self, &ty.node) {\n-            (&SelfKind::Value, &TyPath(..)) => true,\n-            (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) => true,\n-            (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n-            (&SelfKind::Ref, &TyPath(..)) => allow_value_for_ref,\n-            (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n+            (&SelfKind::Value, &TyPath(..)) |\n+                (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) |\n+                (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n+            (&SelfKind::Ref, &TyPath(..)) |\n+                (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n             _ => false,\n         }\n     }"}, {"sha": "076e6e385c2ca5f22b32844d4bc27d8272f8a025", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -421,8 +421,7 @@ impl LateLintPass for UsedUnderscoreBinding {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(ref parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) => **rhs == *expr,\n-            ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n             _ => is_used(cx, &parent),\n         }\n     } else {"}, {"sha": "14c2e877919d8559235ff863175526101fc7b2da", "filename": "src/strings.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -7,7 +7,8 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n \n-use utils::{is_exp_equal, match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::SpanlessEq;\n use utils::STRING_PATH;\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n@@ -84,7 +85,7 @@ impl LateLintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(cx, target, left, false) {\n+                            if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n                             }\n                         }\n@@ -113,7 +114,7 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left, false),\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }"}, {"sha": "f8695956f09803ea5c97468a91210998f9a17977", "filename": "src/utils/hir.rs", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -0,0 +1,539 @@\n+use consts::constant;\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use std::hash::{Hash, Hasher, SipHasher};\n+use syntax::ast::Name;\n+use syntax::ptr::P;\n+\n+/// Type used to check whether two ast are the same. This is different from the operator\n+/// `==` on ast types as this operator would compare true equality with ID and span.\n+///\n+/// Note that some expressions kinds are not considered but could be added.\n+pub struct SpanlessEq<'a, 'tcx: 'a> {\n+    /// Context used to evaluate constant expressions.\n+    cx: &'a LateContext<'a, 'tcx>,\n+    /// If is true, never consider as equal expressions containing fonction calls.\n+    ignore_fn: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        SpanlessEq { cx: cx, ignore_fn: false }\n+    }\n+\n+    pub fn ignore_fn(self) -> Self {\n+        SpanlessEq { cx: self.cx, ignore_fn: true }\n+    }\n+\n+    /// Check whether two statements are the same.\n+    pub fn eq_stmt(&self, left: &Stmt, right: &Stmt) -> bool {\n+        match (&left.node, &right.node) {\n+            (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n+                if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+                    // TODO: tys\n+                    l.ty.is_none() && r.ty.is_none() &&\n+                        both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                }\n+                else {\n+                    false\n+                }\n+            }\n+            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) |\n+                (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n+            _ => false,\n+        }\n+    }\n+\n+    /// Check whether two blocks are the same.\n+    pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n+        over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r)) &&\n+            both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+    }\n+\n+    // ok, it\u2019s a big function, but mostly one big match with simples cases\n+    #[allow(cyclomatic_complexity)]\n+    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+        if let (Some(l), Some(r)) = (constant(self.cx, left), constant(self.cx, right)) {\n+            if l == r {\n+                return true;\n+            }\n+        }\n+\n+        match (&left.node, &right.node) {\n+            (&ExprAddrOf(lmut, ref le), &ExprAddrOf(rmut, ref re)) => {\n+                lmut == rmut && self.eq_expr(le, re)\n+            }\n+            (&ExprAgain(li), &ExprAgain(ri)) => {\n+                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+            }\n+            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n+                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+                lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n+                self.eq_block(l, r)\n+            }\n+            (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n+                lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprBreak(li), &ExprBreak(ri)) => {\n+                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+            }\n+            (&ExprBox(ref l), &ExprBox(ref r)) => {\n+                self.eq_expr(l, r)\n+            }\n+            (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n+                !self.ignore_fn &&\n+                    self.eq_expr(lfun, rfun) &&\n+                    self.eq_exprs(largs, rargs)\n+            }\n+            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n+                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n+            }\n+            (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n+                lfident.node == rfident.node && self.eq_expr(lfexp, rfexp)\n+            }\n+            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n+                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n+            }\n+            (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+                self.eq_expr(lc, rc) &&\n+                    self.eq_block(lt, rt) &&\n+                    both(le, re, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+            (&ExprLoop(ref lb, ref ll), &ExprLoop(ref rb, ref rl)) => {\n+                self.eq_block(lb, rb) &&\n+                    both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+\n+            }\n+            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+                ls == rs &&\n+                    self.eq_expr(le, re) &&\n+                    over(la, ra, |l, r| {\n+                        self.eq_expr(&l.body, &r.body) &&\n+                            both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                            over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                    })\n+            }\n+            (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+                // TODO: tys\n+                !self.ignore_fn &&\n+                    lname.node == rname.node &&\n+                    ltys.is_empty() &&\n+                    rtys.is_empty() &&\n+                    self.eq_exprs(largs, rargs)\n+            }\n+            (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n+                both(lb, rb, |l, r| self.eq_expr(l, r)) &&\n+                both(le, re, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n+                self.eq_expr(le, re) && self.eq_expr(ll, rl)\n+            }\n+            (&ExprRet(ref l), &ExprRet(ref r)) => {\n+                both(l, r, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n+                both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n+            }\n+            (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n+            (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n+                li.node == ri.node && self.eq_expr(le, re)\n+            }\n+            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n+                lop == rop && self.eq_expr(le, re)\n+            }\n+            (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n+            (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+                self.eq_expr(lc, rc) &&\n+                    self.eq_block(lb, rb) &&\n+                    both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn eq_exprs(&self, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n+        over(left, right, |l, r| self.eq_expr(l, r))\n+    }\n+\n+    /// Check whether two patterns are the same.\n+    pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n+        match (&left.node, &right.node) {\n+            (&PatBox(ref l), &PatBox(ref r)) => {\n+                self.eq_pat(l, r)\n+            }\n+            (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n+                self.eq_path(lp, rp) &&\n+                    both(la, ra, |l, r| {\n+                        over(l, r, |l, r| self.eq_pat(l, r))\n+                    })\n+            }\n+            (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n+                lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n+                    both(lp, rp, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatLit(ref l), &PatLit(ref r)) => {\n+                self.eq_expr(l, r)\n+            }\n+            (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n+                self.eq_qself(ls, rs) && self.eq_path(lp, rp)\n+            }\n+            (&PatTup(ref l), &PatTup(ref r)) => {\n+                over(l, r, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n+                self.eq_expr(ls, rs) &&\n+                    self.eq_expr(le, re)\n+            }\n+            (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n+                lm == rm && self.eq_pat(le, re)\n+            }\n+            (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n+                over(ls, rs, |l, r| self.eq_pat(l, r)) &&\n+                    over(le, re, |l, r| self.eq_pat(l, r)) &&\n+                    both(li, ri, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatWild, &PatWild) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n+        // The == of idents doesn't work with different contexts,\n+        // we have to be explicit about hygiene\n+        left.global == right.global &&\n+        over(&left.segments,\n+             &right.segments,\n+             |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n+    }\n+\n+    fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n+        left.ty.node == right.ty.node && left.position == right.position\n+    }\n+\n+    fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n+        match (&left.node, &right.node) {\n+            (&TyVec(ref lvec), &TyVec(ref rvec)) => self.eq_ty(lvec, rvec),\n+            (&TyFixedLengthVec(ref lt, ref ll), &TyFixedLengthVec(ref rt, ref rl)) => {\n+                self.eq_ty(lt, rt) && self.eq_expr(ll, rl)\n+            }\n+            (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && self.eq_ty(&*lmut.ty, &*rmut.ty),\n+            (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n+                lrmut.mutbl == rrmut.mutbl && self.eq_ty(&*lrmut.ty, &*rrmut.ty)\n+            }\n+            (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n+                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(lpath, rpath)\n+            }\n+            (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n+            (&TyInfer, &TyInfer) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n+}\n+\n+/// Check if two slices are equal as per `eq_fn`.\n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n+}\n+\n+\n+/// Type used to hash an ast element. This is different from the `Hash` trait on ast types as this\n+/// trait would consider IDs and spans.\n+///\n+/// All expressions kind are hashed, but some might have a weaker hash.\n+pub struct SpanlessHash<'a, 'tcx: 'a> {\n+    /// Context used to evaluate constant expressions.\n+    cx: &'a LateContext<'a, 'tcx>,\n+    s: SipHasher,\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        SpanlessHash { cx: cx, s: SipHasher::new() }\n+    }\n+\n+    pub fn finish(&self) -> u64 {\n+        self.s.finish()\n+    }\n+\n+    pub fn hash_block(&mut self, b: &Block) {\n+        for s in &b.stmts {\n+            self.hash_stmt(s);\n+        }\n+\n+        if let Some(ref e) = b.expr {\n+            self.hash_expr(e);\n+        }\n+\n+        b.rules.hash(&mut self.s);\n+    }\n+\n+    pub fn hash_expr(&mut self, e: &Expr) {\n+        if let Some(e) = constant(self.cx, e) {\n+            return e.hash(&mut self.s);\n+        }\n+\n+        match e.node {\n+            ExprAddrOf(m, ref e) => {\n+                let c: fn(_, _) -> _ = ExprAddrOf;\n+                c.hash(&mut self.s);\n+                m.hash(&mut self.s);\n+                self.hash_expr(e);\n+            }\n+            ExprAgain(i) => {\n+                let c: fn(_) -> _ = ExprAgain;\n+                c.hash(&mut self.s);\n+                if let Some(i) = i {\n+                    self.hash_name(&i.node.name);\n+                }\n+            }\n+            ExprAssign(ref l, ref r) => {\n+                let c: fn(_, _) -> _ = ExprAssign;\n+                c.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprAssignOp(ref o, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprAssignOp;\n+                c.hash(&mut self.s);\n+                o.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprBlock(ref b) => {\n+                let c: fn(_) -> _ = ExprBlock;\n+                c.hash(&mut self.s);\n+                self.hash_block(b);\n+            }\n+            ExprBinary(op, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprBinary;\n+                c.hash(&mut self.s);\n+                op.node.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprBreak(i) => {\n+                let c: fn(_) -> _ = ExprBreak;\n+                c.hash(&mut self.s);\n+                if let Some(i) = i {\n+                    self.hash_name(&i.node.name);\n+                }\n+            }\n+            ExprBox(ref e) => {\n+                let c: fn(_) -> _ = ExprBox;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+            }\n+            ExprCall(ref fun, ref args) => {\n+                let c: fn(_, _) -> _ = ExprCall;\n+                c.hash(&mut self.s);\n+                self.hash_expr(fun);\n+                self.hash_exprs(args);\n+            }\n+            ExprCast(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprCast;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                // TODO: _ty\n+            }\n+            ExprClosure(cap, _, ref b) => {\n+                let c: fn(_, _, _) -> _ = ExprClosure;\n+                c.hash(&mut self.s);\n+                cap.hash(&mut self.s);\n+                self.hash_block(b);\n+            }\n+            ExprField(ref e, ref f) => {\n+                let c: fn(_, _) -> _ = ExprField;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                self.hash_name(&f.node);\n+            }\n+            ExprIndex(ref a, ref i) => {\n+                let c: fn(_, _) -> _ = ExprIndex;\n+                c.hash(&mut self.s);\n+                self.hash_expr(a);\n+                self.hash_expr(i);\n+            }\n+            ExprInlineAsm(_) => {\n+                let c: fn(_) -> _ = ExprInlineAsm;\n+                c.hash(&mut self.s);\n+            }\n+            ExprIf(ref cond, ref t, ref e) => {\n+                let c: fn(_, _, _) -> _ = ExprIf;\n+                c.hash(&mut self.s);\n+                self.hash_expr(cond);\n+                self.hash_block(t);\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprLit(ref l) => {\n+                let c: fn(_) -> _ = ExprLit;\n+                c.hash(&mut self.s);\n+                l.hash(&mut self.s);\n+            },\n+            ExprLoop(ref b, ref i) => {\n+                let c: fn(_, _) -> _ = ExprLoop;\n+                c.hash(&mut self.s);\n+                self.hash_block(b);\n+                if let Some(i) = *i {\n+                    self.hash_name(&i.name);\n+                }\n+            }\n+            ExprMatch(ref e, ref arms, ref s) => {\n+                let c: fn(_, _, _) -> _ = ExprMatch;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+\n+                for arm in arms {\n+                    // TODO: arm.pat?\n+                    if let Some(ref e) = arm.guard {\n+                        self.hash_expr(e);\n+                    }\n+                    self.hash_expr(&arm.body);\n+                }\n+\n+                s.hash(&mut self.s);\n+            }\n+            ExprMethodCall(ref name, ref _tys, ref args) => {\n+                let c: fn(_, _, _) -> _ = ExprMethodCall;\n+                c.hash(&mut self.s);\n+                self.hash_name(&name.node);\n+                self.hash_exprs(args);\n+            }\n+            ExprRange(ref b, ref e) => {\n+                let c: fn(_, _) -> _ = ExprRange;\n+                c.hash(&mut self.s);\n+                if let Some(ref b) = *b {\n+                    self.hash_expr(b);\n+                }\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprRepeat(ref e, ref l) => {\n+                let c: fn(_, _) -> _ = ExprRepeat;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                self.hash_expr(l);\n+            }\n+            ExprRet(ref e) => {\n+                let c: fn(_) -> _ = ExprRet;\n+                c.hash(&mut self.s);\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprPath(ref _qself, ref subpath) => {\n+                let c: fn(_, _) -> _ = ExprPath;\n+                c.hash(&mut self.s);\n+                self.hash_path(subpath);\n+            }\n+            ExprStruct(ref path, ref fields, ref expr) => {\n+                let c: fn(_, _, _) -> _ = ExprStruct;\n+                c.hash(&mut self.s);\n+\n+                self.hash_path(path);\n+\n+                for f in fields {\n+                    self.hash_name(&f.name.node);\n+                    self.hash_expr(&f.expr);\n+                }\n+\n+                if let Some(ref e) = *expr {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprTup(ref tup) => {\n+                let c: fn(_) -> _ = ExprTup;\n+                c.hash(&mut self.s);\n+                self.hash_exprs(tup);\n+            },\n+            ExprTupField(ref le, li) => {\n+                let c: fn(_, _) -> _ = ExprTupField;\n+                c.hash(&mut self.s);\n+\n+                self.hash_expr(le);\n+                li.node.hash(&mut self.s);\n+            }\n+            ExprType(_, _) => {\n+                let c: fn(_, _) -> _ = ExprType;\n+                c.hash(&mut self.s);\n+                // what\u2019s an ExprType anyway?\n+            }\n+            ExprUnary(lop, ref le) => {\n+                let c: fn(_, _) -> _ = ExprUnary;\n+                c.hash(&mut self.s);\n+\n+                lop.hash(&mut self.s);\n+                self.hash_expr(le);\n+            }\n+            ExprVec(ref v) => {\n+                let c: fn(_) -> _ = ExprVec;\n+                c.hash(&mut self.s);\n+\n+                self.hash_exprs(v);\n+            },\n+            ExprWhile(ref cond, ref b, l) => {\n+                let c: fn(_, _, _) -> _ = ExprWhile;\n+                c.hash(&mut self.s);\n+\n+                self.hash_expr(cond);\n+                self.hash_block(b);\n+                if let Some(l) = l {\n+                    self.hash_name(&l.name);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn hash_exprs(&mut self, e: &[P<Expr>]) {\n+        for e in e {\n+            self.hash_expr(e);\n+        }\n+    }\n+\n+    pub fn hash_name(&mut self, n: &Name) {\n+        n.as_str().hash(&mut self.s);\n+    }\n+\n+    pub fn hash_path(&mut self, p: &Path) {\n+        p.global.hash(&mut self.s);\n+        for p in &p.segments {\n+            self.hash_name(&p.identifier.name);\n+        }\n+    }\n+\n+    pub fn hash_stmt(&mut self, b: &Stmt) {\n+        match b.node {\n+            StmtDecl(ref _decl, _) => {\n+                let c: fn(_, _) -> _ = StmtDecl;\n+                c.hash(&mut self.s);\n+                // TODO: decl\n+            }\n+            StmtExpr(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtExpr;\n+                c.hash(&mut self.s);\n+                self.hash_expr(expr);\n+            }\n+            StmtSemi(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtSemi;\n+                c.hash(&mut self.s);\n+                self.hash_expr(expr);\n+            }\n+        }\n+    }\n+}"}, {"sha": "9fd52ff0e9868f2fdf57325ab8980f80322ef7ea", "filename": "src/utils/mod.rs", "status": "renamed", "additions": 2, "deletions": 222, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -1,4 +1,3 @@\n-use consts::constant;\n use reexport::*;\n use rustc::front::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n@@ -15,6 +14,8 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+mod hir;\n+pub use self::hir::{SpanlessEq, SpanlessHash};\n pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n@@ -590,227 +591,6 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-/// Check whether two statements are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_stmt_equal(cx: &LateContext, left: &Stmt, right: &Stmt, ignore_fn: bool) -> bool {\n-    match (&left.node, &right.node) {\n-        (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n-            if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n-                // TODO: tys\n-                l.ty.is_none() && r.ty.is_none() &&\n-                    both(&l.init, &r.init, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-            }\n-            else {\n-                false\n-            }\n-        }\n-        (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n-        (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n-        _ => false,\n-    }\n-}\n-\n-/// Check whether two blocks are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_block_equal(cx: &LateContext, left: &Block, right: &Block, ignore_fn: bool) -> bool {\n-    over(&left.stmts, &right.stmts, |l, r| is_stmt_equal(cx, l, r, ignore_fn)) &&\n-        both(&left.expr, &right.expr, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-}\n-\n-/// Check whether two pattern are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_pat_equal(cx: &LateContext, left: &Pat, right: &Pat, ignore_fn: bool) -> bool {\n-    match (&left.node, &right.node) {\n-        (&PatBox(ref l), &PatBox(ref r)) => {\n-            is_pat_equal(cx, l, r, ignore_fn)\n-        }\n-        (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n-            is_path_equal(lp, rp) &&\n-                both(la, ra, |l, r| {\n-                    over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-                })\n-        }\n-        (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n-            lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n-                both(lp, rp, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatLit(ref l), &PatLit(ref r)) => {\n-            is_exp_equal(cx, l, r, ignore_fn)\n-        }\n-        (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n-            is_qself_equal(ls, rs) && is_path_equal(lp, rp)\n-        }\n-        (&PatTup(ref l), &PatTup(ref r)) => {\n-            over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n-            is_exp_equal(cx, ls, rs, ignore_fn) &&\n-                is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n-            lm == rm && is_pat_equal(cx, le, re, ignore_fn)\n-        }\n-        (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n-            over(ls, rs, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n-                over(le, re, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n-                both(li, ri, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatWild, &PatWild) => true,\n-        _ => false,\n-    }\n-}\n-\n-/// Check whether two expressions are the same. This is different from the operator `==` on\n-/// expression as this operator would compare true equality with ID and span.\n-/// If `ignore_fn` is true, never consider as equal fonction calls.\n-///\n-/// Note that some expression kinds are not considered but could be added.\n-#[allow(cyclomatic_complexity)] // ok, it\u2019s a big function, but mostly one big match with simples cases\n-pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr, ignore_fn: bool) -> bool {\n-    if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n-        if l == r {\n-            return true;\n-        }\n-    }\n-\n-    match (&left.node, &right.node) {\n-        (&ExprAddrOf(ref lmut, ref le), &ExprAddrOf(ref rmut, ref re)) => {\n-            lmut == rmut && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprAgain(li), &ExprAgain(ri)) => {\n-            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-        }\n-        (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n-            is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n-            lo.node == ro.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n-            is_block_equal(cx, l, r, ignore_fn)\n-        }\n-        (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n-            lop.node == rop.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprBreak(li), &ExprBreak(ri)) => {\n-            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-        }\n-        (&ExprBox(ref l), &ExprBox(ref r)) => {\n-            is_exp_equal(cx, l, r, ignore_fn)\n-        }\n-        (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-            !ignore_fn &&\n-                is_exp_equal(cx, lfun, rfun, ignore_fn) &&\n-                is_exps_equal(cx, largs, rargs, ignore_fn)\n-        }\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n-            is_exp_equal(cx, lx, rx, ignore_fn) && is_cast_ty_equal(lt, rt)\n-        }\n-        (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp, ignore_fn)\n-        }\n-        (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n-            is_exp_equal(cx, la, ra, ignore_fn) && is_exp_equal(cx, li, ri, ignore_fn)\n-        }\n-        (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n-            is_exp_equal(cx, lc, rc, ignore_fn) &&\n-                is_block_equal(cx, lt, rt, ignore_fn) &&\n-                both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n-            ls == rs &&\n-                is_exp_equal(cx, le, re, ignore_fn) &&\n-                over(la, ra, |l, r| {\n-                    is_exp_equal(cx, &l.body, &r.body, ignore_fn) &&\n-                        both(&l.guard, &r.guard, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n-                        over(&l.pats, &r.pats, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-                })\n-        }\n-        (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n-            // TODO: tys\n-            !ignore_fn &&\n-                lname.node == rname.node &&\n-                ltys.is_empty() &&\n-                rtys.is_empty() &&\n-                is_exps_equal(cx, largs, rargs, ignore_fn)\n-        }\n-        (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n-            both(lb, rb, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n-            both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n-            is_exp_equal(cx, le, re, ignore_fn) && is_exp_equal(cx, ll, rl, ignore_fn)\n-        }\n-        (&ExprRet(ref l), &ExprRet(ref r)) => {\n-            both(l, r, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n-            both(lqself, rqself, is_qself_equal) && is_path_equal(lsubpath, rsubpath)\n-        }\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup, ignore_fn),\n-        (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n-            li.node == ri.node && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n-            lop == rop && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r, ignore_fn),\n-        (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-            is_exp_equal(cx, lc, rc, ignore_fn) &&\n-                is_block_equal(cx, lb, rb, ignore_fn) &&\n-                both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n-        }\n-        _ => false,\n-    }\n-}\n-\n-fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>], ignore_fn: bool) -> bool {\n-    over(left, right, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-}\n-\n-fn is_path_equal(left: &Path, right: &Path) -> bool {\n-    // The == of idents doesn't work with different contexts,\n-    // we have to be explicit about hygiene\n-    left.global == right.global &&\n-    over(&left.segments,\n-         &right.segments,\n-         |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n-}\n-\n-fn is_qself_equal(left: &QSelf, right: &QSelf) -> bool {\n-    left.ty.node == right.ty.node && left.position == right.position\n-}\n-\n-/// Check if two slices are equal as per `eq_fn`.\n-pub fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n-{\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n-}\n-\n-/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n-pub fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n-{\n-    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n-}\n-\n-fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n-    match (&left.node, &right.node) {\n-        (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n-        (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n-        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n-            lrmut.mutbl == rrmut.mutbl && is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty)\n-        }\n-        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n-            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath)\n-        }\n-        (&TyInfer, &TyInfer) => true,\n-        _ => false,\n-    }\n-}\n-\n /// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {", "previous_filename": "src/utils.rs"}, {"sha": "623f9967bd40a10bfde235f4965741bbc5fe4962", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 78, "deletions": 30, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -5,16 +5,18 @@\n #![allow(let_and_return)]\n #![allow(needless_return)]\n #![allow(unused_variables)]\n-#![deny(if_same_then_else)]\n-#![deny(ifs_same_cond)]\n+#![allow(cyclomatic_complexity)]\n \n+fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n \n+#[deny(if_same_then_else)]\n+#[deny(match_same_arms)]\n fn if_same_then_else() -> &'static str {\n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         foo();\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         foo();\n     }\n \n@@ -26,11 +28,11 @@ fn if_same_then_else() -> &'static str {\n         foo();\n     }\n \n-    let _ = if true { //~ERROR this if has the same then and else blocks\n+    let _ = if true {\n         foo();\n         42\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         foo();\n         42\n     };\n@@ -39,14 +41,14 @@ fn if_same_then_else() -> &'static str {\n         foo();\n     }\n \n-    let _ = if true { //~ERROR this if has the same then and else blocks\n+    let _ = if true {\n         42\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         42\n     };\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         let bar = if true {\n             42\n         }\n@@ -57,7 +59,7 @@ fn if_same_then_else() -> &'static str {\n         while foo() { break; }\n         bar + 1;\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         let bar = if true {\n             42\n         }\n@@ -69,53 +71,99 @@ fn if_same_then_else() -> &'static str {\n         bar + 1;\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n-        match 42 {\n-            42 => (),\n-            a if a > 0 => (),\n-            10...15 => (),\n-            _ => (),\n-        }\n+    if true {\n+        let _ = match 42 {\n+            42 => 1,\n+            a if a > 0 => 2,\n+            10...15 => 3,\n+            _ => 4,\n+        };\n     }\n-    else {\n-        match 42 {\n-            42 => (),\n-            a if a > 0 => (),\n-            10...15 => (),\n-            _ => (),\n-        }\n+    else if false {\n+        foo();\n+    }\n+    else if foo() { //~ERROR this `if` has identical blocks\n+        let _ = match 42 {\n+            42 => 1,\n+            a if a > 0 => 2,\n+            10...15 => 3,\n+            _ => 4,\n+        };\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n         if let Some(a) = Some(42) {}\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         if let Some(a) = Some(42) {}\n     }\n \n-    if true { //~ERROR this if has the same then and else blocks\n+    if true {\n+        if let Some(a) = Some(42) {}\n+    }\n+    else {\n+        if let Some(a) = Some(43) {}\n+    }\n+\n+    let _ = match 42 {\n+        42 => foo(),\n+        51 => foo(), //~ERROR this `match` has identical arm bodies\n+        _ => true,\n+    };\n+\n+    let _ = match Some(42) {\n+        Some(42) => 24,\n+        Some(a) => 24, // bindings are different\n+        None => 0,\n+    };\n+\n+    match (Some(42), Some(42)) {\n+        (Some(a), None) => bar(a),\n+        (None, Some(a)) => bar(a), //~ERROR this `match` has identical arm bodies\n+        _ => (),\n+    }\n+\n+    match (Some(42), Some(\"\")) {\n+        (Some(a), None) => bar(a),\n+        (None, Some(a)) => bar(a), // bindings have different types\n+        _ => (),\n+    }\n+\n+    if true {\n         let foo = \"\";\n         return &foo[0..];\n     }\n-    else {\n+    else if false {\n+        let foo = \"bar\";\n+        return &foo[0..];\n+    }\n+    else { //~ERROR this `if` has identical blocks\n         let foo = \"\";\n         return &foo[0..];\n     }\n }\n \n+#[deny(ifs_same_cond)]\n+#[allow(if_same_then_else)] // all empty blocks\n fn ifs_same_cond() {\n     let a = 0;\n+    let b = false;\n+\n+    if b {\n+    }\n+    else if b { //~ERROR this `if` has the same condition as a previous if\n+    }\n \n     if a == 1 {\n     }\n-    else if a == 1 { //~ERROR this if has the same condition as a previous if\n+    else if a == 1 { //~ERROR this `if` has the same condition as a previous if\n     }\n \n     if 2*a == 1 {\n     }\n     else if 2*a == 2 {\n     }\n-    else if 2*a == 1 { //~ERROR this if has the same condition as a previous if\n+    else if 2*a == 1 { //~ERROR this `if` has the same condition as a previous if\n     }\n     else if a == 1 {\n     }"}, {"sha": "3a4a83af5c6cb145ffa9475d30eb0d5a6b56fad5", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -138,15 +138,15 @@ fn bloo() {\n #[cyclomatic_complexity = \"0\"]\n fn baa() { //~ ERROR: the function has a cyclomatic complexity of 2\n     let x = || match 99 {\n-        0 => true,\n-        1 => false,\n-        2 => true,\n-        4 => true,\n-        6 => true,\n-        9 => true,\n-        _ => false,\n+        0 => 0,\n+        1 => 1,\n+        2 => 2,\n+        4 => 4,\n+        6 => 6,\n+        9 => 9,\n+        _ => 42,\n     };\n-    if x() {\n+    if x() == 42 {\n         println!(\"x\");\n     } else {\n         println!(\"not x\");"}, {"sha": "46d3ff8d5fbd6ef9febfbd03efe66f93f760cb3d", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -101,8 +101,8 @@ fn match_bool() {\n     let test: bool = true;\n \n     match test {  //~ ERROR you seem to be trying to match on a boolean expression\n-        true => (),\n-        false => (),\n+        true => 0,\n+        false => 42,\n     };\n \n     let option = 1;\n@@ -128,9 +128,9 @@ fn match_bool() {\n \n     // Not linted\n     match option {\n-        1 ... 10 => (),\n-        11 ... 20 => (),\n-        _ => (),\n+        1 ... 10 => 1,\n+        11 ... 20 => 2,\n+        _ => 3,\n     };\n }\n "}, {"sha": "67be4243335980bbe4638174f2b538ea41e5231c", "filename": "tests/consts.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8517ca50103847db6dfb59191aad5e06aa53a3d2/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=8517ca50103847db6dfb59191aad5e06aa53a3d2", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::LitKind;\n use syntax::ast::LitIntType;\n use syntax::ast::StrStyle;\n \n-use clippy::consts::{constant_simple, Constant, Sign};\n+use clippy::consts::{constant_simple, Constant, FloatWidth, Sign};\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -76,4 +76,12 @@ fn test_ops() {\n     check(ONE, &binop(BiSub, litone.clone(), litzero.clone()));\n     check(ONE, &binop(BiMul, litone.clone(), litone.clone()));\n     check(ONE, &binop(BiDiv, litone.clone(), litone.clone()));\n+\n+    let half_any = Constant::Float(\"0.5\".into(), FloatWidth::FwAny);\n+    let half32 = Constant::Float(\"0.5\".into(), FloatWidth::Fw32);\n+    let half64 = Constant::Float(\"0.5\".into(), FloatWidth::Fw64);\n+\n+    assert_eq!(half_any, half32);\n+    assert_eq!(half_any, half64);\n+    assert_eq!(half32, half64); // for transitivity\n }"}]}