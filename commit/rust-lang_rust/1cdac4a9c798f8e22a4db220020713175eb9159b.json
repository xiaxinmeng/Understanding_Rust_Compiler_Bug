{"sha": "1cdac4a9c798f8e22a4db220020713175eb9159b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZGFjNGE5Yzc5OGY4ZTIyYTRkYjIyMDAyMDcxMzE3NWViOTE1OWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-10T23:21:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-10T23:21:48Z"}, "message": "Auto merge of #3767 - alexreg:cosmetic-2, r=flip1995\n\nVarious cosmetic improvements\n\nRelated to the larger effort of https://github.com/rust-lang/rust/pull/58036.", "tree": {"sha": "831a918d132bff9be7e1be33db9372ff54f72b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/831a918d132bff9be7e1be33db9372ff54f72b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cdac4a9c798f8e22a4db220020713175eb9159b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cdac4a9c798f8e22a4db220020713175eb9159b", "html_url": "https://github.com/rust-lang/rust/commit/1cdac4a9c798f8e22a4db220020713175eb9159b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cdac4a9c798f8e22a4db220020713175eb9159b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "016d92d6ed5ae8a3785b65aa300768abbc26f818", "url": "https://api.github.com/repos/rust-lang/rust/commits/016d92d6ed5ae8a3785b65aa300768abbc26f818", "html_url": "https://github.com/rust-lang/rust/commit/016d92d6ed5ae8a3785b65aa300768abbc26f818"}, {"sha": "72aeaa891b0966359a2efb09a1917c6aa41b43c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/72aeaa891b0966359a2efb09a1917c6aa41b43c7", "html_url": "https://github.com/rust-lang/rust/commit/72aeaa891b0966359a2efb09a1917c6aa41b43c7"}], "stats": {"total": 1241, "additions": 636, "deletions": 605}, "files": [{"sha": "31b0a98c1ab74f2998e1e20cd058700ff1701f0c", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -191,7 +191,7 @@ pub struct FileChange {\n     pub new_lines: String,\n }\n \n-/// Replace a region in a file delimited by two lines matching regexes.\n+/// Replaces a region in a file delimited by two lines matching regexes.\n ///\n /// `path` is the relative path to the file on which you want to perform the replacement.\n ///\n@@ -225,7 +225,7 @@ where\n     file_change\n }\n \n-/// Replace a region in a text delimited by two lines matching regexes.\n+/// Replaces a region in a text delimited by two lines matching regexes.\n ///\n /// * `text` is the input text on which you want to perform the replacement\n /// * `start` is a `&str` that describes the delimiter line before the region you want to replace."}, {"sha": "fa586ad45c23c6bebde7edf3ac7dc062c4e59a93", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -104,7 +104,7 @@ fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, mod\n     }\n }\n \n-/// Returns false if the number of significant figures in `value` are\n+/// Returns `false` if the number of significant figures in `value` are\n /// less than `min_digits`; otherwise, returns true if `value` is equal\n /// to `constant`, rounded to the number of digits present in `value`.\n fn is_approx_const(constant: f64, value: &str, min_digits: usize) -> bool {"}, {"sha": "9e2a8c451ee1e24fa95c8e10975b02bfe33d6dd9", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,31 +1,32 @@\n+use if_chain::if_chain;\n+use rustc::hir::{Expr, ExprKind};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_tool_lint, lint_array};\n+\n use crate::consts::{constant, Constant};\n-use crate::rustc::hir::{Expr, ExprKind};\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n use crate::syntax::ast::LitKind;\n use crate::utils::{in_macro, is_direct_expn_of, span_help_and_lint};\n-use if_chain::if_chain;\n \n declare_clippy_lint! {\n-    /// **What it does:** Check to call assert!(true/false)\n+    /// **What it does:** Checks for `assert!(true)` and `assert!(false)` calls.\n     ///\n     /// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n     /// panic!() or unreachable!()\n     ///\n     /// **Known problems:** None\n     ///\n     /// **Example:**\n-    /// ```no_run\n-    /// assert!(false);\n+    /// ```rust,ignore\n+    /// assert!(false)\n     /// // or\n-    /// assert!(true);\n+    /// assert!(true)\n     /// // or\n     /// const B: bool = false;\n-    /// assert!(B);\n+    /// assert!(B)\n     /// ```\n     pub ASSERTIONS_ON_CONSTANTS,\n     style,\n-    \"assert!(true/false) will be optimized out by the compiler/should probably be replaced by a panic!() or unreachable!()\"\n+    \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\"\n }\n \n pub struct AssertionsOnConstants;"}, {"sha": "a39685f85ff8d9e0f4a2953bb03f05dd7fd98d3f", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,14 +1,15 @@\n-use crate::utils::{\n-    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n-};\n-use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n+use crate::utils::{\n+    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+};\n+use crate::utils::{higher, sugg};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n     /// patterns.\n@@ -19,9 +20,10 @@ declare_clippy_lint! {\n     /// implementations that differ from the regular `Op` impl.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust\n     /// let mut a = 5;\n-    /// ...\n+    /// let b = 0;\n+    /// // ...\n     /// a = a + b;\n     /// ```\n     pub ASSIGN_OP_PATTERN,\n@@ -36,12 +38,12 @@ declare_clippy_lint! {\n     /// op= b`.\n     ///\n     /// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n-    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n     /// If `a op= a op b` is really the correct behaviour it should be\n     /// written as `a = a op a op b` as it's less confusing.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust\n     /// let mut a = 5;\n     /// ...\n     /// a += a + b;"}, {"sha": "c57b1c5366c4d203ec589bf8e06c52bb11826897", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -70,7 +70,7 @@ declare_clippy_lint! {\n     /// ```\n     pub INEFFECTIVE_BIT_MASK,\n     correctness,\n-    \"expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\"\n+    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n }\n \n declare_clippy_lint! {"}, {"sha": "f16631a5eff69feb70042308b10c8c3e957c064f", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -20,7 +20,7 @@ declare_clippy_lint! {\n     /// ```\n     pub BLOCK_IN_IF_CONDITION_EXPR,\n     style,\n-    \"braces that can be eliminated in conditions, e.g. `if { true } ...`\"\n+    \"braces that can be eliminated in conditions, e.g., `if { true } ...`\"\n }\n \n declare_clippy_lint! {\n@@ -39,7 +39,7 @@ declare_clippy_lint! {\n     /// ```\n     pub BLOCK_IN_IF_CONDITION_STMT,\n     style,\n-    \"complex blocks in conditions, e.g. `if { let x = true; x } ...`\"\n+    \"complex blocks in conditions, e.g., `if { let x = true; x } ...`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "00e0787a927da99b119d55ce60dc3a39d162e73a", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -68,7 +68,7 @@ declare_clippy_lint! {\n     /// ```\n     pub COLLAPSIBLE_IF,\n     style,\n-    \"`if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\"\n+    \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "8d71eb54277746368cfc568384777b44107f7ad7", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -21,27 +21,27 @@ use syntax_pos::symbol::Symbol;\n /// A `LitKind`-like enum to fold constant `Expr`s into.\n #[derive(Debug, Clone)]\n pub enum Constant {\n-    /// a String \"abc\"\n+    /// A `String` (e.g., \"abc\").\n     Str(String),\n-    /// a Binary String b\"abc\"\n+    /// A binary string (e.g., `b\"abc\"`).\n     Binary(Lrc<Vec<u8>>),\n-    /// a single char 'a'\n+    /// A single `char` (e.g., `'a'`).\n     Char(char),\n-    /// an integer's bit representation\n+    /// An integer's bit representation.\n     Int(u128),\n-    /// an f32\n+    /// An `f32`.\n     F32(f32),\n-    /// an f64\n+    /// An `f64`.\n     F64(f64),\n-    /// true or false\n+    /// `true` or `false`.\n     Bool(bool),\n-    /// an array of constants\n+    /// An array of constants.\n     Vec(Vec<Constant>),\n-    /// also an array, but with only one constant, repeated N times\n+    /// Also an array, but with only one constant, repeated N times.\n     Repeat(Box<Constant>, u64),\n-    /// a tuple of constants\n+    /// A tuple of constants.\n     Tuple(Vec<Constant>),\n-    /// a literal with syntax error\n+    /// A literal with syntax error.\n     Err(Symbol),\n }\n \n@@ -53,23 +53,24 @@ impl PartialEq for Constant {\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => l == r,\n             (&Constant::F64(l), &Constant::F64(r)) => {\n-                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n-                // `Fw32 == Fw64` so don\u2019t compare them\n-                // to_bits is required to catch non-matching 0.0, -0.0, and NaNs\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 l.to_bits() == r.to_bits()\n             },\n             (&Constant::F32(l), &Constant::F32(r)) => {\n-                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n-                // `Fw32 == Fw64` so don\u2019t compare them\n-                // to_bits is required to catch non-matching 0.0, -0.0, and NaNs\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n                 f64::from(l).to_bits() == f64::from(r).to_bits()\n             },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => {\n                 l == r\n             },\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            _ => false, // TODO: Are there inter-type equalities?\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n         }\n     }\n }\n@@ -142,12 +143,13 @@ impl Constant {\n                     x => x,\n                 }\n             },\n-            _ => None, // TODO: Are there any useful inter-type orderings?\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n         }\n     }\n }\n \n-/// parse a `LitKind` to a `Constant`\n+/// Parses a `LitKind` to a `Constant`.\n pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n "}, {"sha": "39fc10258078b1ca1f402a56b6d9041199dadc7f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -239,9 +239,9 @@ fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n     }\n }\n \n-/// Return the list of condition expressions and the list of blocks in a\n+/// Returns the list of condition expressions and the list of blocks in a\n /// sequence of `if/else`.\n-/// Eg. would return `([a, b], [c, d, e])` for the expression\n+/// E.g., this returns `([a, b], [c, d, e])` for the expression\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>) {\n     let mut conds = SmallVec::new();\n@@ -272,7 +272,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>)\n     (conds, blocks)\n }\n \n-/// Return the list of bindings in a pattern.\n+/// Returns the list of bindings in a pattern.\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<LocalInternedString, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,"}, {"sha": "62cef778917b984083d1c69f7bda6ca6db06a770", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -90,7 +90,7 @@ declare_deprecated_lint! {\n /// counterparts, so this lint may suggest a change in behavior or the code may not compile.\n declare_deprecated_lint! {\n     pub ASSIGN_OPS,\n-    \"using compound assignment operators (e.g. `+=`) is harmless\"\n+    \"using compound assignment operators (e.g., `+=`) is harmless\"\n }\n \n /// **What it does:** Nothing. This lint has been deprecated."}, {"sha": "0e8d47384f1a4b6825793c29e2a6dde6365e125b", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -257,10 +257,9 @@ fn check_text(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, text: &st\n }\n \n fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n-    /// Checks if a string is camel-case, ie. contains at least two uppercase\n-    /// letter (`Clippy` is\n-    /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded\n-    /// (`IDs` is ok).\n+    /// Checks if a string is camel-case, i.e., contains at least two uppercase\n+    /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n+    /// Plurals are also excluded (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n         if s.starts_with(|c: char| c.is_digit(10)) {\n             return false;"}, {"sha": "01380fd968078dca4fee0e237adbca2990dc1366", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,4 +1,4 @@\n-//! lint on if expressions with an else if, but without a final else branch\n+//! Lint on if expressions with an else if, but without a final else branch.\n \n use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -10,7 +10,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n     /// but without a final `else` branch.\n     ///\n-    /// **Why is this bad?** Some coding guidelines require this (e.g. MISRA-C:2004 Rule 14.10).\n+    /// **Why is this bad?** Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -31,7 +31,7 @@ declare_clippy_lint! {\n     /// } else if x.is_negative() {\n     ///     b();\n     /// } else {\n-    ///     // we don't care about zero\n+    ///     // We don't care about zero.\n     /// }\n     /// ```\n     pub ELSE_IF_WITHOUT_ELSE,"}, {"sha": "903700f1aacb2cb56cbae66e53d61a3f17f7bd22", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     /// ```\n     pub EQ_OP,\n     correctness,\n-    \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n }\n \n declare_clippy_lint! {"}, {"sha": "07909ef587fee27bd0675563a688bb6828520bfe", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,12 +1,13 @@\n-use crate::consts::{constant_simple, Constant};\n-use crate::utils::{in_macro, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::{in_macro, span_lint};\n+\n declare_clippy_lint! {\n-    /// **What it does:** Checks for erasing operations, e.g. `x * 0`.\n+    /// **What it does:** Checks for erasing operations, e.g., `x * 0`.\n     ///\n     /// **Why is this bad?** The whole expression can be replaced by zero.\n     /// This is most likely not the intended outcome and should probably be\n@@ -15,14 +16,15 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust\n+    /// let x = 1;\n     /// 0 / x;\n     /// 0 * x;\n-    /// x & 0\n+    /// x & 0;\n     /// ```\n     pub ERASING_OP,\n     correctness,\n-    \"using erasing operations, e.g. `x * 0` or `y & 0`\"\n+    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "2c6bfae6efe1feb91efcbaf54b84c12e84a24c7b", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::span_lint;\n use rustc::hir::intravisit as visit;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -10,6 +9,8 @@ use rustc::util::nodemap::HirIdSet;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n+use crate::utils::span_lint;\n+\n pub struct Pass {\n     pub too_large_for_stack: u64,\n }\n@@ -67,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         hir_id: HirId,\n     ) {\n-        // If the method is an impl for a trait, don't warn\n+        // If the method is an impl for a trait, don't warn.\n         let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n         let parent_node = cx.tcx.hir().find_by_hir_id(parent_id);\n \n@@ -102,7 +103,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: HirId, _: Span, cmt: &cmt_<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if let Move(DirectRefMove) = mode {\n-                // moved out or in. clearly can't be localized\n+                // Moved out or in. Clearly can't be localized.\n                 self.set.remove(&lid);\n             }\n         }\n@@ -158,20 +159,20 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     ) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n-                // x.foo()\n-                // Used without autodereffing (i.e. x.clone())\n+                // `x.foo()`\n+                // Used without autoderef-ing (i.e., `x.clone()`).\n                 LoanCause::AutoRef |\n \n-                // &x\n-                // foo(&x) where no extra autoreffing is happening\n+                // `&x`\n+                // `foo(&x)` where no extra autoref-ing is happening.\n                 LoanCause::AddrOf |\n \n-                // `match x` can move\n+                // `match x` can move.\n                 LoanCause::MatchDiscriminant => {\n                     self.set.remove(&lid);\n                 }\n \n-                // do nothing for matches, etc. These can't escape\n+                // Do nothing for matches, etc. These can't escape.\n                 _ => {}\n             }\n         }\n@@ -182,8 +183,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n     fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n-        // Large types need to be boxed to avoid stack\n-        // overflows.\n+        // Large types need to be boxed to avoid stack overflows.\n         if ty.is_box() {\n             self.cx.layout_of(ty.boxed_ty()).ok().map_or(0, |l| l.size.bytes()) > self.too_large_for_stack\n         } else {"}, {"sha": "1329e945b370bc76c26a0a0e7666439ac75b2d33", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,11 +1,12 @@\n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n+use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n+\n pub struct EtaPass;\n \n declare_clippy_lint! {\n@@ -19,18 +20,17 @@ declare_clippy_lint! {\n     /// **Known problems:** If creating the closure inside the closure has a side-\n     /// effect then moving the closure creation out will change when that side-\n     /// effect runs.\n-    /// See https://github.com/rust-lang/rust-clippy/issues/1439 for more\n-    /// details.\n+    /// See rust-lang/rust-clippy#1439 for more details.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust,ignore\n     /// xs.map(|x| foo(x))\n     /// ```\n     /// where `foo(_)` is a plain function that takes the exact argument type of\n     /// `x`.\n     pub REDUNDANT_CLOSURE,\n     style,\n-    \"redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\"\n+    \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\"\n }\n \n impl LintPass for EtaPass {"}, {"sha": "90e6102dd844e0cb5dd02f2989616ed91ae0c3d2", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -286,7 +286,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> St\n /// A visitor that looks for reads from a variable.\n struct ReadVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    /// The id of the variable we're looking for.\n+    /// The ID of the variable we're looking for.\n     var: ast::NodeId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n+/// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, _) = parent.node {"}, {"sha": "6d15e37454c46be34482118f640165bfa72502aa", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,13 +1,14 @@\n-use crate::consts::{constant_simple, Constant};\n-use crate::utils::{clip, in_macro, snippet, span_lint, unsext};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n+use crate::consts::{constant_simple, Constant};\n+use crate::utils::{clip, in_macro, snippet, span_lint, unsext};\n+\n declare_clippy_lint! {\n-    /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n+    /// **What it does:** Checks for identity operations, e.g., `x + 0`.\n     ///\n     /// **Why is this bad?** This code can be removed without changing the\n     /// meaning. So it just obscures what's going on. Delete it mercilessly.\n@@ -20,7 +21,7 @@ declare_clippy_lint! {\n     /// ```\n     pub IDENTITY_OP,\n     complexity,\n-    \"using identity operations, e.g. `x + 0` or `y / 1`\"\n+    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "07fcec85863705f480ef3bd7f1c0df867ffe16b1", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n         if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n-                // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]\n+                // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.sty {\n                     let size: u128 = s.assert_usize(cx.tcx).unwrap().into();\n \n@@ -149,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n \n                 utils::span_help_and_lint(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", help_msg);\n             } else {\n-                // Catchall non-range index, i.e. [n] or [n << m]\n+                // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.sty {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.tables, index) {"}, {"sha": "689cd8fd3b05eefd2783af72428cc6523b392e02", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,13 +1,14 @@\n-use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n+use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n     ///\n     /// **Why is this bad?** While there may be places where this is acceptable\n-    /// (e.g. in event streams), in most cases this is simply an error.\n+    /// (e.g., in event streams), in most cases this is simply an error.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -26,7 +27,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for iteration that may be infinite.\n     ///\n     /// **Why is this bad?** While there may be places where this is acceptable\n-    /// (e.g. in event streams), in most cases this is simply an error.\n+    /// (e.g., in event streams), in most cases this is simply an error.\n     ///\n     /// **Known problems:** The code may have a condition to stop iteration, but\n     /// this lint is not clever enough to analyze it.\n@@ -122,8 +123,8 @@ use self::Heuristic::{All, Always, Any, First};\n /// a slice of (method name, number of args, heuristic, bounds) tuples\n /// that will be used to determine whether the method in question\n /// returns an infinite or possibly infinite iterator. The finiteness\n-/// is an upper bound, e.g. some methods can return a possibly\n-/// infinite iterator at worst, e.g. `take_while`.\n+/// is an upper bound, e.g., some methods can return a possibly\n+/// infinite iterator at worst, e.g., `take_while`.\n static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"zip\", 2, All, Infinite),\n     (\"chain\", 2, Any, Infinite),"}, {"sha": "4762ce760c9b3a3b77618001f563c95c83d030e4", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -274,9 +274,9 @@ fn check_len(\n     }\n }\n \n-/// Check if this type has an `is_empty` method.\n+/// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n+    /// Gets an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if item.ident.name == \"is_empty\" {\n@@ -291,7 +291,7 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n         }\n     }\n \n-    /// Check the inherent impl's items for an `is_empty(self)` method.\n+    /// Checks the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n         cx.tcx\n             .inherent_impls(id)"}, {"sha": "4a7f23bc8587fae5187c8917da3bef2718f018bf", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -11,7 +11,7 @@\n #![feature(crate_visibility_modifier)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate fmt_macros;\n #[allow(unused_extern_crates)]\n@@ -407,7 +407,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     );\n     store.register_removed(\n         \"assign_ops\",\n-        \"using compound assignment operators (e.g. `+=`) is harmless\",\n+        \"using compound assignment operators (e.g., `+=`) is harmless\",\n     );\n     store.register_removed(\n         \"if_let_redundant_pattern_matching\","}, {"sha": "4b2ba60090f9d3583db40eff0ce25b71eedc170c", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,5 +1,3 @@\n-use crate::reexport::*;\n-use crate::utils::{last_path_segment, span_lint};\n use matches::matches;\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::*;\n@@ -10,6 +8,9 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use syntax::source_map::Span;\n use syntax::symbol::keywords;\n \n+use crate::reexport::*;\n+use crate::utils::{last_path_segment, span_lint};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for lifetime annotations which can be removed by\n     /// relying on lifetime elision.\n@@ -384,7 +385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n+/// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {"}, {"sha": "5c2ca4b1c9358115db095347bf34f3e2747e6625", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -112,7 +112,7 @@ pub(super) enum Radix {\n }\n \n impl Radix {\n-    /// Return a reasonable digit group size for this radix.\n+    /// Returns a reasonable digit group size for this radix.\n     crate fn suggest_grouping(&self) -> usize {\n         match *self {\n             Radix::Binary | Radix::Hexadecimal => 4,"}, {"sha": "0016625631c70b29007151aeff683ad983353be6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -727,7 +727,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n-                .expect(\"target id can only be missing in the presence of compilation errors\");\n+                .expect(\"target ID can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n                 NeverLoopResult::MayContinueMainLoop\n             } else {\n@@ -953,7 +953,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n     }\n }\n \n-/// Check for for loops that sequentially copy items from one slice-like\n+/// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n@@ -1065,7 +1065,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }\n }\n \n-/// Check for looping over a range and then indexing a sequence with it.\n+/// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n #[allow(clippy::too_many_lines)]\n fn check_for_loop_range<'a, 'tcx>(\n@@ -1413,7 +1413,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n     }\n }\n \n-/// Check for `for` loops over `Option`s and `Results`\n+/// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n@@ -1507,7 +1507,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     }\n }\n \n-/// Check for the `FOR_KV_MAP` lint.\n+/// Checks for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     pat: &'tcx Pat,\n@@ -1673,7 +1673,7 @@ fn check_for_mutation(\n     delegate.mutation_span()\n }\n \n-/// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n@@ -1967,7 +1967,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Return true if the type of expr is one that provides `IntoIterator` impls\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[rustfmt::skip]\n fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n@@ -2022,7 +2022,7 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     }\n }\n \n-/// Return true if expr contains a single break expr without destination label\n+/// Returns `true` if expr contains a single break expr without destination label\n /// and\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n@@ -2102,7 +2102,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Check whether a variable is initialized to zero at the start of a loop.\n+/// Checks whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n     end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n@@ -2336,7 +2336,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n \n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n     if constant(cx, cx.tables, cond).is_some() {\n-        // A pure constant condition (e.g. while false) is not linted.\n+        // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n "}, {"sha": "e7e1df5cffff201855942b4892326f4a9a289401", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -35,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     pub SINGLE_MATCH,\n     style,\n-    \"a match statement with a single nontrivial arm (i.e. where the other arm is `_ => {}`) instead of `if let`\"\n+    \"a match statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n }\n \n declare_clippy_lint! {\n@@ -322,7 +322,7 @@ fn check_single_match_opt_like(\n     ty: Ty<'_>,\n     els: Option<&Expr>,\n ) {\n-    // list of candidate Enums we know will never get any more members\n+    // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n         (&paths::COW, \"Cow::Borrowed\"),\n@@ -335,7 +335,7 @@ fn check_single_match_opt_like(\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n-            // contains any non wildcard patterns? e.g. Err(err)\n+            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n                 return;\n             }\n@@ -354,7 +354,7 @@ fn check_single_match_opt_like(\n }\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    // type of expression == bool\n+    // Type of expression is `bool`.\n     if cx.tables.expr_ty(ex).sty == ty::Bool {\n         span_lint_and_then(\n             cx,\n@@ -639,7 +639,7 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n     }\n }\n \n-/// Get all arms that are unbounded `PatRange`s.\n+/// Gets all arms that are unbounded `PatRange`s.\n fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n@@ -687,7 +687,7 @@ pub struct SpannedRange<T> {\n \n type TypedRanges = Vec<SpannedRange<u128>>;\n \n-/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n+/// Gets all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n /// and other types than\n /// `Uint` and `Int` probably don't make sense.\n fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {"}, {"sha": "d7ab3505765573ec3c7149b5ff36b9e2b36ce9bd", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,12 +1,10 @@\n-use crate::utils::paths;\n-use crate::utils::sugg;\n-use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath,\n-    match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys,\n-    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n-};\n+mod option_map_unwrap_or;\n+mod unnecessary_filter_map;\n+\n+use std::borrow::Cow;\n+use std::fmt;\n+use std::iter;\n+\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n@@ -15,15 +13,19 @@ use rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray,\n use rustc::ty::{self, Predicate, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use std::borrow::Cow;\n-use std::fmt;\n-use std::iter;\n use syntax::ast;\n use syntax::source_map::{BytePos, Span};\n use syntax::symbol::LocalInternedString;\n \n-mod option_map_unwrap_or;\n-mod unnecessary_filter_map;\n+use crate::utils::paths;\n+use crate::utils::sugg;\n+use crate::utils::{\n+    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy, is_expn_of,\n+    is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath,\n+    match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+};\n \n #[derive(Clone)]\n pub struct Pass;\n@@ -55,7 +57,7 @@ declare_clippy_lint! {\n     /// and propagate errors upwards with `try!`.\n     ///\n     /// Even if you want to panic on errors, not all `Error`s implement good\n-    /// messages on display.  Therefore it may be beneficial to look at the places\n+    /// messages on display. Therefore, it may be beneficial to look at the places\n     /// where they may get displayed. Activate this lint to do just that.\n     ///\n     /// **Known problems:** None.\n@@ -399,7 +401,7 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `.clone()` on a ref-counted pointer,\n     /// (`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n-    /// function syntax instead (e.g. `Rc::clone(foo)`).\n+    /// function syntax instead (e.g., `Rc::clone(foo)`).\n     ///\n     /// **Why is this bad?** Calling '.clone()' on an Rc, Arc, or Weak\n     /// can obscure the fact that only the pointer is being cloned, not the underlying\n@@ -458,7 +460,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for string methods that receive a single-character\n-    /// `str` as an argument, e.g. `_.split(\"x\")`.\n+    /// `str` as an argument, e.g., `_.split(\"x\")`.\n     ///\n     /// **Why is this bad?** Performing these methods using a `char` is faster than\n     /// using a `str`.\n@@ -469,7 +471,7 @@ declare_clippy_lint! {\n     /// `_.split(\"x\")` could be `_.split('x')`\n     pub SINGLE_CHAR_PATTERN,\n     perf,\n-    \"using a single-character str where a char could be used, e.g. `_.split(\\\"x\\\")`\"\n+    \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\"\n }\n \n declare_clippy_lint! {\n@@ -1008,7 +1010,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n-    /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_, '_>,\n         name: &str,\n@@ -1057,7 +1059,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         false\n     }\n \n-    /// Check for `*or(foo())`.\n+    /// Checks for `*or(foo())`.\n     #[allow(clippy::too_many_arguments)]\n     fn check_general_case(\n         cx: &LateContext<'_, '_>,\n@@ -1546,7 +1548,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n                     cx,\n                     UNNECESSARY_FOLD,\n                     fold_span,\n-                    // TODO #2371 don't suggest e.g. .any(|x| f(x)) if we can suggest .any(f)\n+                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n                     \"this `.fold` can be written more succinctly using another method\",\n                     \"try\",\n                     sugg,\n@@ -2348,7 +2350,7 @@ impl SelfKind {\n         // Self types in the HIR are desugared to explicit self types. So it will\n         // always be `self:\n         // SomeType`,\n-        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if\n+        // where SomeType can be `Self` or an explicit impl self type (e.g., `Foo` if\n         // the impl is on `Foo`)\n         // Thus, we only need to test equality against the impl self type or if it is\n         // an explicit"}, {"sha": "77aee50c6f872d2bb76200d3a3e85a441032010b", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,10 +1,3 @@\n-use crate::consts::{constant, Constant};\n-use crate::utils::sugg::Sugg;\n-use crate::utils::{\n-    get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal, iter_input_pats,\n-    last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n-};\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir::intravisit::FnKind;\n@@ -16,6 +9,14 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::{ExpnFormat, Span};\n \n+use crate::consts::{constant, Constant};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal, iter_input_pats,\n+    last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint, span_lint_and_then, walk_ptrs_ty,\n+    SpanlessEq,\n+};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for function arguments and let bindings denoted as\n     /// `ref`.\n@@ -31,12 +32,12 @@ declare_clippy_lint! {\n     ///\n     /// **Known problems:** If the argument is dereferenced within the function,\n     /// removing the `ref` will lead to errors. This can be fixed by removing the\n-    /// dereferences, e.g. changing `*x` to `x` within the function.\n+    /// dereferences, e.g., changing `*x` to `x` within the function.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust\n     /// fn foo(ref x: u8) -> bool {\n-    ///     ..\n+    ///     true\n     /// }\n     /// ```\n     pub TOPLEVEL_REF_ARG,\n@@ -99,7 +100,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CMP_OWNED,\n     perf,\n-    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n+    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n }\n \n declare_clippy_lint! {\n@@ -552,7 +553,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n         lint_span,\n         \"this creates an owned instance just for comparison\",\n         |db| {\n-            // this also catches PartialEq implementations that call to_owned\n+            // This also catches `PartialEq` implementations that call `to_owned`.\n             if other_gets_derefed {\n                 db.span_label(lint_span, \"try implementing the comparison without allocating\");\n                 return;\n@@ -590,9 +591,8 @@ fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     }\n }\n \n-/// Test whether an expression is in a macro expansion (e.g. something\n-/// generated by\n-/// `#[derive(...)`] or the like).\n+/// Tests whether an expression is in a macro expansion (e.g., something\n+/// generated by `#[derive(...)]` or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n     expr.span\n         .ctxt()\n@@ -601,7 +601,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n         .map_or(false, |info| matches!(info.format, ExpnFormat::MacroAttribute(_)))\n }\n \n-/// Test whether `def` is a variable defined outside a macro.\n+/// Tests whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir().span(id)),"}, {"sha": "3d41195f34969c624d03f3967964ea9c3293d867", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -194,7 +194,7 @@ impl LintPass for MiscEarly {\n     }\n }\n \n-// Used to find `return` statements or equivalents e.g. `?`\n+// Used to find `return` statements or equivalents e.g., `?`\n struct ReturnVisitor {\n     found_return: bool,\n }"}, {"sha": "f37f72135033737746c049de7c21436e68fb7d85", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -20,7 +20,7 @@ declare_clippy_lint! {\n     /// ```\n     pub MUT_MUT,\n     pedantic,\n-    \"usage of double-mut refs, e.g. `&mut &mut ...`\"\n+    \"usage of double-mut refs, e.g., `&mut &mut ...`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "6e81ecac05fb4b33b4c668f168868af83648f62c", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -33,7 +33,7 @@ declare_clippy_lint! {\n     /// ```\n     pub NEEDLESS_BOOL,\n     complexity,\n-    \"if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\"\n+    \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\"\n }\n \n declare_clippy_lint! {\n@@ -51,7 +51,7 @@ declare_clippy_lint! {\n     /// ```\n     pub BOOL_COMPARISON,\n     complexity,\n-    \"comparing a variable to a boolean, e.g. `if x == true` or `if x != true`\"\n+    \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "15d378bdd7f9e2096609baf9213a329a0bbb1f23", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n             //\n             // * Exclude a type that is specifically bounded by `Borrow`.\n-            // * Exclude a type whose reference also fulfills its bound. (e.g. `std::convert::AsRef`,\n+            // * Exclude a type whose reference also fulfills its bound. (e.g., `std::convert::AsRef`,\n             //   `serde::Serialize`)\n             let (implements_borrow_trait, all_borrowable_trait) = {\n                 let preds = preds"}, {"sha": "7b074f438f4bdd573d62b018b11ade14d6670cb7", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -8,7 +8,7 @@ use crate::utils::{self, paths, span_lint};\n declare_clippy_lint! {\n     /// **What it does:**\n     /// Checks for the usage of negated comparison operators on types which only implement\n-    /// `PartialOrd` (e.g. `f64`).\n+    /// `PartialOrd` (e.g., `f64`).\n     ///\n     /// **Why is this bad?**\n     /// These operators make it easy to forget that the underlying types actually allow not only three"}, {"sha": "9c184e8c54b28edb7e11334dfdef4535ae0abcfb", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,8 +1,9 @@\n-//! Checks for uses of const which the type is not Freeze (Cell-free).\n+//! Checks for uses of const which the type is not `Freeze` (`Cell`-free).\n //!\n //! This lint is **deny** by default.\n \n-use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+use std::ptr;\n+\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n@@ -11,14 +12,15 @@ use rustc::ty::{self, TypeFlags};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;\n-use std::ptr;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use crate::utils::{in_constant, in_macro, is_copy, span_lint_and_then};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for declaration of `const` items which is interior\n-    /// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n+    /// mutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n     ///\n-    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.,\n     /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n     /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n     /// these types in the first place.\n@@ -27,7 +29,7 @@ declare_clippy_lint! {\n     /// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n     ///\n     /// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n-    /// initialized value to downstream `static` items (e.g. the\n+    /// initialized value to downstream `static` items (e.g., the\n     /// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n     /// and this lint should be suppressed.\n     ///\n@@ -51,10 +53,10 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks if `const` items which is interior mutable (e.g.\n-    /// contains a `Cell`, `Mutex`, `AtomicXxxx` etc) has been borrowed directly.\n+    /// **What it does:** Checks if `const` items which is interior mutable (e.g.,\n+    /// contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n     ///\n-    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.,\n     /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n     /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n     /// these types in the first place.\n@@ -108,8 +110,8 @@ impl Source {\n \n fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n-        // an UnsafeCell is !Copy, and an UnsafeCell is also the only type which\n-        // is !Freeze, thus if our type is Copy we can be sure it must be Freeze\n+        // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n+        // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n         // as well.\n         return;\n     }\n@@ -179,7 +181,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n             let item_hir_id = cx.tcx.hir().get_parent_node_by_hir_id(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item_by_hir_id(item_hir_id);\n-            // ensure the impl is an inherent impl.\n+            // Ensure the impl is an inherent impl.\n             if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                 verify_ty_bound(\n@@ -201,13 +203,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                 return;\n             }\n \n-            // make sure it is a const item.\n+            // Make sure it is a const item.\n             match cx.tables.qpath_def(qpath, expr.hir_id) {\n                 Def::Const(_) | Def::AssociatedConst(_) => {},\n                 _ => return,\n             };\n \n-            // climb up to resolve any field access and explicit referencing.\n+            // Climb up to resolve any field access and explicit referencing.\n             let mut cur_expr = expr;\n             let mut dereferenced_expr = expr;\n             let mut needs_check_adjustment = true;\n@@ -219,7 +221,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                 if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find_by_hir_id(parent_id) {\n                     match &parent_expr.node {\n                         ExprKind::AddrOf(..) => {\n-                            // `&e` => `e` must be referenced\n+                            // `&e` => `e` must be referenced.\n                             needs_check_adjustment = false;\n                         },\n                         ExprKind::Field(..) => {\n@@ -260,7 +262,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                         adjustments[i - 1].target\n                     }\n                 } else {\n-                    // No borrow adjustments = the entire const is moved.\n+                    // No borrow adjustments means the entire const is moved.\n                     return;\n                 }\n             } else {"}, {"sha": "7821ad56ccc8e8f75f6d836da17b1560a0e79861", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,19 +1,19 @@\n-use crate::utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n+use rustc_errors::Applicability;\n use syntax::ptr::P;\n \n use crate::utils::paths::*;\n+use crate::utils::sugg::Sugg;\n use crate::utils::{match_def_path, match_type, span_lint_and_then, SpanlessEq};\n-use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for expressions that could be replaced by the question mark operator\n+    /// **What it does:** Checks for expressions that could be replaced by the question mark operator.\n     ///\n-    /// **Why is this bad?** Question mark usage is more idiomatic\n+    /// **Why is this bad?** Question mark usage is more idiomatic.\n     ///\n     /// **Known problems:** None\n     ///\n@@ -48,7 +48,7 @@ impl LintPass for Pass {\n }\n \n impl Pass {\n-    /// Check if the given expression on the given context matches the following structure:\n+    /// Checks if the given expression on the given context matches the following structure:\n     ///\n     /// ```ignore\n     /// if option.is_none() {"}, {"sha": "18dfb963230bd79f54fb0c4f1679d852ca9c5375", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,6 +1,3 @@\n-use crate::utils::sugg::Sugg;\n-use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n-use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -9,6 +6,10 @@ use rustc_errors::Applicability;\n use syntax::ast::RangeLimits;\n use syntax::source_map::Spanned;\n \n+use crate::utils::sugg::Sugg;\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n+use crate::utils::{is_integer_literal, paths, snippet, snippet_opt, span_lint, span_lint_and_then};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n     /// which never terminates.\n@@ -48,15 +49,15 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for exclusive ranges where 1 is added to the\n-    /// upper bound, e.g. `x..(y+1)`.\n+    /// upper bound, e.g., `x..(y+1)`.\n     ///\n     /// **Why is this bad?** The code is more readable with an inclusive range\n     /// like `x..=y`.\n     ///\n     /// **Known problems:** Will add unnecessary pair of parentheses when the\n     /// expression is not wrapped in a pair but starts with a opening parenthesis\n     /// and ends with a closing one.\n-    /// I.e: `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n+    /// I.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -69,7 +70,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for inclusive ranges where 1 is subtracted from\n-    /// the upper bound, e.g. `x..=(y-1)`.\n+    /// the upper bound, e.g., `x..=(y-1)`.\n     ///\n     /// **Why is this bad?** The code is more readable with an exclusive range\n     /// like `x..y`.\n@@ -123,16 +124,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n                 if_chain! {\n-                    // .iter() call\n+                    // `.iter()` call\n                     if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n                     if iter_path.ident.name == \"iter\";\n-                    // range expression in .zip() call: 0..x.len()\n+                    // range expression in `.zip()` call: `0..x.len()`\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n-                    // .len() call\n+                    // `.len()` call\n                     if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n                     if len_path.ident.name == \"len\" && len_args.len() == 1;\n-                    // .iter() and .len() called on same Path\n+                    // `.iter()` and `.len()` called on same `Path`\n                     if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n                     if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n                     if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n@@ -147,7 +148,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         }\n \n-        // exclusive range plus one: x..(y+1)\n+        // exclusive range plus one: `x..(y+1)`\n         if_chain! {\n             if let Some(higher::Range {\n                 start,\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         }\n \n-        // inclusive range minus one: x..=(y-1)\n+        // inclusive range minus one: `x..=(y-1)`\n         if_chain! {\n             if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n             if let Some(y) = y_minus_one(end);\n@@ -213,7 +214,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n-    // No need for walk_ptrs_ty here because step_by moves self, so it\n+    // No need for `walk_ptrs_ty` here because `step_by` moves `self`, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);\n "}, {"sha": "5458fa51c7c07e0611d89997f38bf1429f6ccb38", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n use if_chain::if_chain;\n use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -8,6 +7,8 @@ use syntax::source_map::Span;\n use syntax::visit::FnKind;\n use syntax_pos::BytePos;\n \n+use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for return statements at the end of a block.\n     ///\n@@ -69,7 +70,7 @@ declare_clippy_lint! {\n     /// statement look like a function call.\n     ///\n     /// **Known problems:** The lint currently misses unit return types in types,\n-    /// e.g. the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n     ///\n     /// **Example:**\n     /// ```rust"}, {"sha": "99580affef6783cc8e563c87951d5868c1fc4755", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     /// ```\n     pub SHADOW_SAME,\n     restriction,\n-    \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n+    \"rebinding a name to itself, e.g., `let mut x = &mut x`\"\n }\n \n declare_clippy_lint! {\n@@ -49,7 +49,7 @@ declare_clippy_lint! {\n     /// ```\n     pub SHADOW_REUSE,\n     restriction,\n-    \"rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\"\n+    \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\"\n }\n \n declare_clippy_lint! {"}, {"sha": "888405983fd5129a853ccd80f13d5bb1d9f5e520", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -194,13 +194,13 @@ impl Pass {\n struct VectorInitializationVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n \n-    /// Contains the information\n+    /// Contains the information.\n     vec_alloc: VecAllocation<'tcx>,\n \n-    /// Contains, if found, the slow initialization expression\n+    /// Contains the slow initialization expression, if one was found.\n     slow_expression: Option<InitializationType<'tcx>>,\n \n-    /// true if the initialization of the vector has been found on the visited block\n+    /// `true` if the initialization of the vector has been found on the visited block.\n     initialization_found: bool,\n }\n "}, {"sha": "cd23722bef4f9a8e0d9e6892d4dd8e977456981c", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,11 +1,12 @@\n-use crate::utils::SpanlessEq;\n-use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n+use crate::utils::SpanlessEq;\n+use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for string appends of the form `x = x + y` (without\n     /// `let`!).\n@@ -35,7 +36,7 @@ declare_clippy_lint! {\n     /// `Add` implementation is asymmetric (the other operand need not be `String`,\n     /// but `x` does), while addition as mathematically defined is symmetric, also\n     /// the `String::push_str(_)` function is a perfectly good replacement.\n-    /// Therefore some dislike it and wish not to have it in their code.\n+    /// Therefore, some dislike it and wish not to have it in their code.\n     ///\n     /// That said, other people think that string addition, having a long tradition\n     /// in other languages is actually fine, which is why we decided to make this\n@@ -58,7 +59,7 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for the `as_bytes` method called on string literals\n     /// that contain only ASCII characters.\n     ///\n-    /// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used\n+    /// **Why is this bad?** Byte string literals (e.g., `b\"foo\"`) can be used\n     /// instead. They are shorter but less discoverable than `as_bytes()`.\n     ///\n     /// **Known Problems:** None."}, {"sha": "2c4bfe7358d602ea131a46a65d09adba5bf4f1b0", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     }\n }\n \n-/// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n /// not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`"}, {"sha": "5ad999f7095974e5aef77cd3e6796870126362b4", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,12 +1,9 @@\n #![allow(clippy::default_hash_types)]\n \n-use crate::consts::{constant, Constant};\n-use crate::utils::paths;\n-use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n-    match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathBuffer,\n-};\n+use std::borrow::Cow;\n+use std::cmp::Ordering;\n+use std::collections::BTreeMap;\n+\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n@@ -18,13 +15,18 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n-use std::borrow::Cow;\n-use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::errors::DiagnosticBuilder;\n use syntax::source_map::Span;\n \n+use crate::consts::{constant, Constant};\n+use crate::utils::paths;\n+use crate::utils::{\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n+    match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathBuffer,\n+};\n+\n /// Handles all the linting of funky types\n pub struct TypePass;\n \n@@ -38,15 +40,15 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```rust\n+    /// ```rust,ignore\n     /// struct X {\n     ///     values: Box<Vec<Foo>>,\n     /// }\n     /// ```\n     ///\n     /// Better:\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// struct X {\n     ///     values: Vec<Foo>,\n     /// }\n@@ -99,6 +101,7 @@ declare_clippy_lint! {\n     /// fn x() -> Option<Option<u32>> {\n     ///     None\n     /// }\n+    /// ```\n     pub OPTION_OPTION,\n     complexity,\n     \"usage of `Option<Option<T>>`\"\n@@ -148,13 +151,13 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```rust\n+    /// ```rust,ignore\n     /// fn foo(bar: &Box<T>) { ... }\n     /// ```\n     ///\n     /// Better:\n     ///\n-    /// ```rust\n+    /// ```rust,ignore\n     /// fn foo(bar: &T) { ... }\n     /// ```\n     pub BORROWED_BOX,\n@@ -174,7 +177,7 @@ impl LintPass for TypePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n     fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: HirId) {\n-        // skip trait implementations, see #605\n+        // Skip trait implementations; see issue #605.\n         if let Some(hir::Node::Item(item)) = cx.tcx.hir().find_by_hir_id(cx.tcx.hir().get_parent_item(id)) {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n                 return;\n@@ -213,7 +216,7 @@ fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n     }\n }\n \n-/// Check if `qpath` has last segment with type parameter matching `path`\n+/// Checks if `qpath` has last segment with type parameter matching `path`\n fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n@@ -389,7 +392,7 @@ fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty, is_local: bool, lt:\n                 });\n                 then {\n                     if is_any_trait(inner) {\n-                        // Ignore `Box<Any>` types, see #1884 for details.\n+                        // Ignore `Box<Any>` types; see issue #1884 for details.\n                         return;\n                     }\n \n@@ -698,7 +701,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CAST_PRECISION_LOSS,\n     pedantic,\n-    \"casts that cause loss of precision, e.g. `x as f32` where `x: u64`\"\n+    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n }\n \n declare_clippy_lint! {\n@@ -719,7 +722,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CAST_SIGN_LOSS,\n     pedantic,\n-    \"casts from signed types to unsigned types, e.g. `x as u32` where `x: i32`\"\n+    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n }\n \n declare_clippy_lint! {\n@@ -741,13 +744,13 @@ declare_clippy_lint! {\n     /// ```\n     pub CAST_POSSIBLE_TRUNCATION,\n     pedantic,\n-    \"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n }\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for casts from an unsigned type to a signed type of\n     /// the same size. Performing such a cast is a 'no-op' for the compiler,\n-    /// i.e. nothing is changed at the bit level, and the binary representation of\n+    /// i.e., nothing is changed at the bit level, and the binary representation of\n     /// the value is reinterpreted. This can cause wrapping if the value is too big\n     /// for the target signed type. However, the cast works as defined, so this lint\n     /// is `Allow` by default.\n@@ -764,7 +767,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CAST_POSSIBLE_WRAP,\n     pedantic,\n-    \"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` and `x > i32::MAX`\"\n+    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n }\n \n declare_clippy_lint! {\n@@ -796,7 +799,7 @@ declare_clippy_lint! {\n     /// ```\n     pub CAST_LOSSLESS,\n     complexity,\n-    \"casts using `as` that are known to be lossless, e.g. `x as u64` where `x: u8`\"\n+    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n }\n \n declare_clippy_lint! {\n@@ -812,7 +815,7 @@ declare_clippy_lint! {\n     /// ```\n     pub UNNECESSARY_CAST,\n     complexity,\n-    \"cast to the same type, e.g. `x as i32` where `x: i32`\"\n+    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n }\n \n declare_clippy_lint! {\n@@ -1528,14 +1531,14 @@ declare_clippy_lint! {\n     /// `max < x` are probably mistakes.\n     ///\n     /// **Known problems:** For `usize` the size of the current compile target will\n-    /// be assumed (e.g. 64 bits on 64 bit systems). This means code that uses such\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n     /// a comparison to detect target pointer width will trigger this lint. One can\n     /// use `mem::sizeof` and compare its value or conditional compilation\n     /// attributes\n     /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n     ///\n     /// **Example:**\n-    /// ```ignore\n+    /// ```rust,ignore\n     /// vec.len() <= 0\n     /// 100 > std::i32::MAX\n     /// ```"}, {"sha": "a2fc8bcc4a6e37629813cf028fbc2dc6c873fd23", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,4 +1,3 @@\n-use crate::utils::span_lint_and_sugg;\n use if_chain::if_chain;\n use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Visitor};\n@@ -9,6 +8,8 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax_pos::symbol::keywords::SelfUpper;\n \n+use crate::utils::span_lint_and_sugg;\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n     /// replacement with `Self` is applicable.\n@@ -60,9 +61,9 @@ impl LintPass for UseSelf {\n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n fn span_use_self_lint(cx: &LateContext<'_, '_>, path: &Path) {\n-    // path segments only include actual path, no methods or fields\n+    // Path segments only include actual path, no methods or fields.\n     let last_path_span = path.segments.last().expect(SEGMENTS_MSG).ident.span;\n-    // only take path up to the end of last_path_span\n+    // Only take path up to the end of last_path_span.\n     let span = path.span.with_hi(last_path_span.hi());\n \n     span_lint_and_sugg(\n@@ -149,7 +150,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n \n     // `impl_decl_ty` (of type `hir::Ty`) represents the type declared in the signature.\n     // `impl_ty` (of type `ty:TyS`) is the concrete type that the compiler has determined for\n-    // that declaration.  We use `impl_decl_ty` to see if the type was declared as `Self`\n+    // that declaration. We use `impl_decl_ty` to see if the type was declared as `Self`\n     // and use `impl_ty` to check its concrete type.\n     for (impl_decl_ty, (impl_ty, trait_ty)) in impl_decl.inputs.iter().chain(output_ty).zip(\n         impl_method_sig"}, {"sha": "5b124dd96bf2e46a742efe082a6481efd563a404", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,5 +1,4 @@\n-/// Return the index of the character after the first camel-case component of\n-/// `s`.\n+/// Returns the index of the character after the first camel-case component of `s`.\n pub fn until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n@@ -32,7 +31,7 @@ pub fn until(s: &str) -> usize {\n     }\n }\n \n-/// Return index of the last camel-case component of `s`.\n+/// Returns index of the last camel-case component of `s`.\n pub fn from(s: &str) -> usize {\n     let mut iter = s.char_indices().rev();\n     if let Some((_, first)) = iter.next() {"}, {"sha": "64243203b7ff95922f03bba317b7f67a35e93830", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -10,7 +10,7 @@ use std::{env, fmt, fs, io, path};\n use syntax::{ast, source_map};\n use toml;\n \n-/// Get the configuration file from arguments.\n+/// Gets the configuration file from arguments.\n pub fn file_from_args(\n     args: &[source_map::Spanned<ast::NestedMetaItemKind>],\n ) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {"}, {"sha": "bb4c18ea2bb6a1bfc22a3010f6d2a983df393e81", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -9,7 +9,7 @@ use rustc::lint::LateContext;\n use rustc::{hir, ty};\n use syntax::ast;\n \n-/// Convert a hir binary operator to the corresponding `ast` type.\n+/// Converts a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     match op {\n         hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n@@ -46,7 +46,7 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> Option<Range<'b>> {\n-    /// Find the field named `name` in the field. Always return `Some` for\n+    /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter().find(|field| field.ident.name == name)?.expr;"}, {"sha": "e084ed8224c6484db06696b2b66f81c7ea72742b", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    /// Check whether two statements are the same.\n+    /// Checks whether two statements are the same.\n     pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n@@ -55,7 +55,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    /// Check whether two blocks are the same.\n+    /// Checks whether two blocks are the same.\n     pub fn eq_block(&mut self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n@@ -186,7 +186,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n-    /// Check whether two patterns are the same.\n+    /// Checks whether two patterns are the same.\n     pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n@@ -328,7 +328,7 @@ fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Bin\n     }\n }\n \n-/// Check if the two `Option`s are both `None` or some equal values as per\n+/// Checks if the two `Option`s are both `None` or some equal values as per\n /// `eq_fn`.\n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n where\n@@ -338,7 +338,7 @@ where\n         .map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n-/// Check if two slices are equal as per `eq_fn`.\n+/// Checks if two slices are equal as per `eq_fn`.\n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n where\n     F: FnMut(&X, &X) -> bool,"}, {"sha": "bf94c8a086811f184040be1199b3a19e27d1807a", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,4 +1,25 @@\n-use crate::reexport::*;\n+pub mod attrs;\n+pub mod author;\n+pub mod camel_case;\n+pub mod comparisons;\n+pub mod conf;\n+pub mod constants;\n+mod diagnostics;\n+pub mod higher;\n+mod hir_utils;\n+pub mod inspector;\n+pub mod internal_lints;\n+pub mod paths;\n+pub mod ptr;\n+pub mod sugg;\n+pub mod usage;\n+pub use self::attrs::*;\n+pub use self::diagnostics::*;\n+pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n+\n+use std::borrow::Cow;\n+use std::mem;\n+\n use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n@@ -17,36 +38,16 @@ use rustc::ty::{\n };\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n-use std::borrow::Cow;\n-use std::mem;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::source_map::{Span, DUMMY_SP};\n use syntax::symbol;\n use syntax::symbol::{keywords, Symbol};\n \n-pub mod attrs;\n-pub mod author;\n-pub mod camel_case;\n-pub mod comparisons;\n-pub mod conf;\n-pub mod constants;\n-mod diagnostics;\n-pub mod higher;\n-mod hir_utils;\n-pub mod inspector;\n-pub mod internal_lints;\n-pub mod paths;\n-pub mod ptr;\n-pub mod sugg;\n-pub mod usage;\n-pub use self::attrs::*;\n-pub use self::diagnostics::*;\n-pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n+use crate::reexport::*;\n \n-/// Returns true if the two spans come from differing expansions (i.e. one is\n-/// from a macro and one\n-/// isn't).\n+/// Returns `true` if the two spans come from differing expansions (i.e., one is\n+/// from a macro and one isn't).\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n@@ -88,7 +89,7 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n     }\n }\n \n-/// Returns true if this `expn_info` was expanded by any macro.\n+/// Returns `true` if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().is_some()\n }\n@@ -112,7 +113,7 @@ impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n     }\n }\n \n-/// Check if a `DefId`'s path matches the given absolute type path usage.\n+/// Checks if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -128,7 +129,7 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n     apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n-/// Get the absolute path of `def_id` as a vector of `&str`.\n+/// Gets the absolute path of `def_id` as a vector of `&str`.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -146,15 +147,15 @@ pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str>\n         .collect()\n }\n \n-/// Check if type is struct, enum or union type with given def path.\n+/// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n-/// Check if the method call given in `expr` belongs to given trait.\n+/// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n@@ -165,7 +166,7 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str])\n     }\n }\n \n-/// Check if an expression references a variable of the given name.\n+/// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n@@ -190,7 +191,7 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n     }\n }\n \n-/// Match a `QPath` against a slice of segment string literals.\n+/// Matches a `QPath` against a slice of segment string literals.\n ///\n /// There is also `match_path` if you are dealing with a `rustc::hir::Path` instead of a\n /// `rustc::hir::QPath`.\n@@ -213,7 +214,7 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     }\n }\n \n-/// Match a `Path` against a slice of segment string literals.\n+/// Matches a `Path` against a slice of segment string literals.\n ///\n /// There is also `match_qpath` if you are dealing with a `rustc::hir::QPath` instead of a\n /// `rustc::hir::Path`.\n@@ -237,7 +238,7 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name == *b)\n }\n \n-/// Match a `Path` against a slice of segment string literals, e.g.\n+/// Matches a `Path` against a slice of segment string literals, e.g.\n ///\n /// # Examples\n /// ```rust,ignore\n@@ -251,7 +252,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         .all(|(a, b)| a.ident.name == *b)\n }\n \n-/// Get the definition associated to a path.\n+/// Gets the definition associated to a path.\n pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n     let krate = crates.iter().find(|&&krate| cx.tcx.crate_name(krate) == path[0]);\n@@ -298,7 +299,7 @@ pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId\n     }\n }\n \n-/// Check whether a type implements a trait.\n+/// Checks whether a type implements a trait.\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n@@ -320,7 +321,7 @@ pub fn implements_trait<'a, 'tcx>(\n         .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n }\n \n-/// Get the `hir::TraitRef` of the trait the given method is implemented for\n+/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n ///\n /// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n ///\n@@ -347,20 +348,20 @@ pub fn trait_ref_of_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> Option<Tr\n     None\n }\n \n-/// Check whether this type implements Drop.\n+/// Checks whether this type implements `Drop`.\n pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n         _ => false,\n     }\n }\n \n-/// Resolve the definition of a node from its `HirId`.\n+/// Resolves the definition of a node from its `HirId`.\n pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::Def {\n     cx.tables.qpath_def(qpath, id)\n }\n \n-/// Return the method names and argument list of nested method call expressions that make up\n+/// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`.\n pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&'a [Expr]>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n@@ -383,7 +384,7 @@ pub fn method_calls<'a>(expr: &'a Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&\n     (method_names, arg_lists)\n }\n \n-/// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n+/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n /// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n@@ -408,19 +409,20 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n             return None;\n         }\n     }\n-    matched.reverse(); // reverse `matched`, so that it is in the same order as `methods`\n+    // Reverse `matched` so that it is in the same order as `methods`.\n+    matched.reverse();\n     Some(matched)\n }\n \n-/// Returns true if the provided `def_id` is an entrypoint to a program\n+/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n pub fn is_entrypoint_fn(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n     if let Some((entry_fn_def_id, _)) = cx.tcx.entry_fn(LOCAL_CRATE) {\n         return def_id == entry_fn_def_id;\n     }\n     false\n }\n \n-/// Get the name of the item the expression is in, if available.\n+/// Gets the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n     match cx.tcx.hir().find_by_hir_id(parent_id) {\n@@ -432,7 +434,7 @@ pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// Get the name of a `Pat`, if any\n+/// Gets the name of a `Pat`, if any.\n pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n@@ -458,14 +460,14 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n     }\n }\n \n-/// check if an `Expr` contains a certain name\n+/// Checks if an `Expr` contains a certain name.\n pub fn contains_name(name: Name, expr: &Expr) -> bool {\n     let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n }\n \n-/// Convert a span to a code snippet if available, otherwise use default.\n+/// Converts a span to a code snippet if available, otherwise use default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n /// to convert a given `Span` to a `str`.\n@@ -510,12 +512,12 @@ pub fn snippet_with_macro_callsite<'a, 'b, T: LintContext<'b>>(cx: &T, span: Spa\n     snippet(cx, span.source_callsite(), default)\n }\n \n-/// Convert a span to a code snippet. Returns `None` if not available.\n+/// Converts a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().source_map().span_to_snippet(span).ok()\n }\n \n-/// Convert a span (from a block) to a code snippet if available, otherwise use\n+/// Converts a span (from a block) to a code snippet if available, otherwise use\n /// default.\n /// This trims the code of indentation, except for the first line. Use it for\n /// blocks or block-like\n@@ -612,7 +614,7 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n     }\n }\n \n-/// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n+/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n@@ -656,23 +658,23 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: HirId\n     }\n }\n \n-/// Return the base type for HIR references and pointers.\n+/// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n     match ty.node {\n         TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n         _ => ty,\n     }\n }\n \n-/// Return the base type for references and raw pointers.\n+/// Returns the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n         ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n }\n \n-/// Return the base type for references and raw pointers, and count reference\n+/// Returns the base type for references and raw pointers, and count reference\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n@@ -684,7 +686,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     inner(ty, 0)\n }\n \n-/// Check whether the given expression is a constant literal of the given value.\n+/// Checks whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n     if let ExprKind::Lit(ref spanned) = expr.node {\n@@ -706,7 +708,7 @@ pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n-/// Return the pre-expansion span if is this comes from an expansion of the\n+/// Returns the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n@@ -725,7 +727,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Return the pre-expansion span if is this directly comes from an expansion\n+/// Returns the pre-expansion span if the span directly comes from an expansion\n /// of the macro `name`.\n /// The difference with `is_expn_of` is that in\n /// ```rust,ignore\n@@ -747,19 +749,19 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Convenience function to get the return type of a function\n+/// Convenience function to get the return type of a function.\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n-/// Check if two types are the same.\n+/// Checks if two types are the same.\n ///\n /// This discards any lifetime annotations, too.\n-// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for\n-// <'b> Foo<'b>` but\n-// not for type parameters.\n+//\n+// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` ==\n+// `for <'b> Foo<'b>`, but not for type parameters).\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n     let a = cx.tcx.erase_late_bound_regions(&Binder::bind(a));\n     let b = cx.tcx.erase_late_bound_regions(&Binder::bind(b));\n@@ -768,7 +770,7 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n         .enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n }\n \n-/// Return whether the given type is an `unsafe` function.\n+/// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n@@ -780,7 +782,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_copy_modulo_regions(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n-/// Return whether a pattern is refutable.\n+/// Returns `true` if a pattern is refutable.\n pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n@@ -869,8 +871,8 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n     (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n }\n \n-/// Check if a given expression is a match expression\n-/// expanded from `?` operator or `try` macro.\n+/// Checks if a given expression is a match expression expanded from the `?`\n+/// operator or the `try` macro.\n pub fn is_try<'a>(cx: &'_ LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n     fn is_ok(cx: &'_ LateContext<'_, '_>, arm: &Arm) -> bool {\n         if_chain! {\n@@ -916,7 +918,7 @@ pub fn is_try<'a>(cx: &'_ LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Exp\n     None\n }\n \n-/// Returns true if the lint is allowed in the current context\n+/// Returns `true` if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> bool {\n@@ -960,7 +962,7 @@ pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n     (u << amt) >> amt\n }\n \n-/// Remove block comments from the given Vec of lines\n+/// Removes block comments from the given `Vec` of lines.\n ///\n /// # Examples\n ///"}, {"sha": "72740cee5006a1812c3407957dbaebf71be4ea3d", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -240,13 +240,13 @@ impl<'a> Sugg<'a> {\n         }\n     }\n \n-    /// Add parenthesis to any expression that might need them. Suitable to the\n-    /// `self` argument of\n-    /// a method call (eg. to build `bar.foo()` or `(1 + 2).foo()`).\n+    /// Adds parenthesis to any expression that might need them. Suitable to the\n+    /// `self` argument of a method call\n+    /// (e.g., to build `bar.foo()` or `(1 + 2).foo()`).\n     pub fn maybe_par(self) -> Self {\n         match self {\n             Sugg::NonParen(..) => self,\n-            // (x) and (x).y() both don't need additional parens\n+            // `(x)` and `(x).y()` both don't need additional parens.\n             Sugg::MaybeParen(sugg) => {\n                 if sugg.starts_with('(') && sugg.ends_with(')') {\n                     Sugg::MaybeParen(sugg)\n@@ -282,14 +282,14 @@ impl<'a> std::ops::Not for Sugg<'a> {\n \n /// Helper type to display either `foo` or `(foo)`.\n struct ParenHelper<T> {\n-    /// Whether parenthesis are needed.\n+    /// `true` if parentheses are needed.\n     paren: bool,\n     /// The main thing to display.\n     wrapped: T,\n }\n \n impl<T> ParenHelper<T> {\n-    /// Build a `ParenHelper`.\n+    /// Builds a `ParenHelper`.\n     fn new(paren: bool, wrapped: T) -> Self {\n         Self { paren, wrapped }\n     }\n@@ -305,7 +305,7 @@ impl<T: Display> Display for ParenHelper<T> {\n     }\n }\n \n-/// Build the string for `<op><expr>` adding parenthesis when necessary.\n+/// Builds the string for `<op><expr>` adding parenthesis when necessary.\n ///\n /// For convenience, the operator is taken as a string because all unary\n /// operators have the same\n@@ -314,28 +314,28 @@ pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n-/// Build the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n+/// Builds the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n ///\n /// Precedence of shift operator relative to other arithmetic operation is\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n-    /// Whether the operator is a shift operator `<<` or `>>`.\n+    /// Returns `true` if the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n+    /// Returns `true` if the operator is a arithmetic operator\n+    /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n         matches!(\n             *op,\n             AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n         )\n     }\n \n-    /// Whether the operator `op` needs parenthesis with the operator `other`\n-    /// in the direction\n-    /// `dir`.\n+    /// Returns `true` if the operator `op` needs parenthesis with the operator\n+    /// `other` in the direction `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence()\n             || (other.precedence() == op.precedence()\n@@ -413,10 +413,9 @@ enum Associativity {\n     Right,\n }\n \n-/// Return the associativity/fixity of an operator. The difference with\n-/// `AssocOp::fixity` is that\n-/// an operator can be both left and right associative (such as `+`:\n-/// `a + b + c == (a + b) + c == a + (b + c)`.\n+/// Returns the associativity/fixity of an operator. The difference with\n+/// `AssocOp::fixity` is that an operator can be both left and right associative\n+/// (such as `+`: `a + b + c == (a + b) + c == a + (b + c)`.\n ///\n /// Chained `as` and explicit `:` type coercion never need inner parenthesis so\n /// they are considered\n@@ -433,7 +432,7 @@ fn associativity(op: &AssocOp) -> Associativity {\n     }\n }\n \n-/// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n+/// Converts a `hir::BinOp` to the corresponding assigning binary operator.\n fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n     use syntax::parse::token::BinOpToken::*;\n \n@@ -460,7 +459,7 @@ fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n     })\n }\n \n-/// Convert an `ast::BinOp` to the corresponding assigning binary operator.\n+/// Converts an `ast::BinOp` to the corresponding assigning binary operator.\n fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n     use syntax::ast::BinOpKind::*;\n     use syntax::parse::token::BinOpToken;\n@@ -480,13 +479,13 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n     })\n }\n \n-/// Return the indentation before `span` if there are nothing but `[ \\t]`\n+/// Returns the indentation before `span` if there are nothing but `[ \\t]`\n /// before it on its line.\n fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n     if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n-            // we can mix char and byte positions here because we only consider `[ \\t]`\n+            // We can mix char and byte positions here because we only consider `[ \\t]`.\n             if lo.col == CharPos(pos) {\n                 Some(line[..pos].into())\n             } else {"}, {"sha": "521ddbc08656127f9ff13b68403611f2262f828e", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,15 +1,14 @@\n-use rustc::lint::LateContext;\n-\n use rustc::hir::def::Def;\n use rustc::hir::*;\n+use rustc::lint::LateContext;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::source_map::Span;\n \n-/// Returns a set of mutated local variable ids or None if mutations could not be determined.\n+/// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),"}, {"sha": "51cedfef0f7102a6aad504521fb0691f87ea5fc3", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -106,7 +106,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n     );\n }\n \n-/// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n+/// Returns the item type of the vector (i.e., the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n     if let ty::Adt(_, substs) = ty.sty {\n         substs.type_at(0)"}, {"sha": "82326bf780cfbf726b3835bbba4a014be5e5b938", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -4,7 +4,7 @@\n #![allow(clippy::missing_docs_in_private_items)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate rustc_driver;\n #[allow(unused_extern_crates)]"}, {"sha": "63af1283bcc89a0a8ee9529f769e8b464fc6e9b0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -5,7 +5,7 @@\n #![warn(rust_2018_idioms)]\n \n // FIXME: switch to something more ergonomic here, once available.\n-// (currently there is no way to opt into sysroot crates w/o `extern crate`)\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n #[allow(unused_extern_crates)]\n extern crate rustc_driver;\n #[allow(unused_extern_crates)]"}, {"sha": "10342ed28b5757e94b2db10eb3a168fd878cd561", "filename": "tests/ui/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -48,9 +48,10 @@ fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n fn pred_test() {\n     let v = 3;\n     let sky = \"blue\";\n-    // this is a sneaky case, where the block isn't directly in the condition, but is actually\n-    // inside a closure that the condition is using.  same principle applies.  add some extra\n-    // expressions to make sure linter isn't confused by them.\n+    // This is a sneaky case, where the block isn't directly in the condition,\n+    // but is actually nside a closure that the condition is using.\n+    // The same principle applies -- add some extra expressions to make sure\n+    // linter isn't confused by them.\n     if v == 3\n         && sky == \"blue\"\n         && predicate("}, {"sha": "0876d5db6964152aa585e57f11f4210f90d47909", "filename": "tests/ui/block_in_if_condition.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fblock_in_if_condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fblock_in_if_condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -31,7 +31,7 @@ LL |     if { true } {\n            } ... \n \n error: in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-  --> $DIR/block_in_if_condition.rs:57:17\n+  --> $DIR/block_in_if_condition.rs:58:17\n    |\n LL |               |x| {\n    |  _________________^\n@@ -41,7 +41,7 @@ LL | |             },\n    | |_____________^\n \n error: in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n-  --> $DIR/block_in_if_condition.rs:66:13\n+  --> $DIR/block_in_if_condition.rs:67:13\n    |\n LL |           |x| {\n    |  _____________^\n@@ -51,7 +51,7 @@ LL | |         },\n    | |_________^\n \n error: this boolean expression can be simplified\n-  --> $DIR/block_in_if_condition.rs:76:8\n+  --> $DIR/block_in_if_condition.rs:77:8\n    |\n LL |     if true && x == 3 {\n    |        ^^^^^^^^^^^^^^ help: try: `x == 3`"}, {"sha": "08450ba117645b67b0f17d4845deded8762e9b55", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     (&1u8 as *const u8) as *const u16;\n     (&mut 1u8 as *mut u8) as *mut u16;\n \n-    /* These should be okay */\n+    /* These should be ok */\n \n     // not a pointer type\n     1u8 as u16;"}, {"sha": "089e5cfabe4b912fb6b819fa334d6476862a8455", "filename": "tests/ui/cast_ref_to_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_ref_to_mut.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -2,8 +2,8 @@\n #![allow(clippy::no_effect)]\n \n extern \"C\" {\n-    // NB. Mutability can be easily incorrect in FFI calls, as\n-    // in C, the default are mutable pointers.\n+    // N.B., mutability can be easily incorrect in FFI calls -- as\n+    // in C, the default is mutable pointers.\n     fn ffi(c: *mut u8);\n     fn int_ffi(c: *mut i32);\n }"}, {"sha": "f1a229f3f4faf3a706ee0e721ad6c26b973b6135", "filename": "tests/ui/crashes/ice-2760.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fice-2760.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fice-2760.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2760.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -8,8 +8,7 @@\n /// This should not compile-fail with:\n ///\n ///      error[E0277]: the trait bound `T: Foo` is not satisfied\n-///\n-/// See https://github.com/rust-lang/rust-clippy/issues/2760\n+// See rust-lang/rust-clippy#2760.\n \n trait Foo {\n     type Bar;"}, {"sha": "d44b0fae82001b3824b2a83c8d44e74eddacb0d8", "filename": "tests/ui/crashes/ice-2774.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fice-2774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fice-2774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2774.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,6 +1,6 @@\n use std::collections::HashSet;\n \n-/// See https://github.com/rust-lang/rust-clippy/issues/2774\n+// See rust-lang/rust-clippy#2774.\n \n #[derive(Eq, PartialEq, Debug, Hash)]\n pub struct Bar {\n@@ -11,14 +11,14 @@ pub struct Bar {\n pub struct Foo {}\n \n #[allow(clippy::implicit_hasher)]\n-// This should not cause a 'cannot relate bound region' ICE\n+// This should not cause a \"cannot relate bound region\" ICE.\n pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n     let mut foos = HashSet::new();\n     foos.extend(bars.iter().map(|b| &b.foo));\n }\n \n #[allow(clippy::implicit_hasher)]\n-// Also this should not cause a 'cannot relate bound region' ICE\n+// Also, this should not cause a \"cannot relate bound region\" ICE.\n pub fn add_barfoos_to_foos2(bars: &HashSet<&Bar>) {\n     let mut foos = HashSet::new();\n     foos.extend(bars.iter().map(|b| &b.foo));"}, {"sha": "6d2124c12fe98addb011233f1b737aa6077c341c", "filename": "tests/ui/crashes/used_underscore_binding_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fused_underscore_binding_macro.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -3,7 +3,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-/// Test that we do not lint for unused underscores in a `MacroAttribute`\n+/// Tests that we do not lint for unused underscores in a `MacroAttribute`\n /// expansion\n #[deny(clippy::used_underscore_binding)]\n #[derive(Deserialize)]"}, {"sha": "a8fc06af1d9bdb8f3b50d0d8518e0e1d654fc86e", "filename": "tests/ui/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdlist.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -12,7 +12,7 @@ trait Foo {\n     const BAR: Option<LinkedList<u8>>;\n }\n \n-// ok, we don\u2019t want to warn for implementations, see #605\n+// Ok, we don\u2019t want to warn for implementations; see issue #605.\n impl Foo for LinkedList<u8> {\n     fn foo(_: LinkedList<u8>) {}\n     const BAR: Option<LinkedList<u8>> = None;"}, {"sha": "039ce5d9c423edc8fda2c442870111288873ae34", "filename": "tests/ui/doc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,12 +1,12 @@\n-//! This file tests for the DOC_MARKDOWN lint\n+//! This file tests for the `DOC_MARKDOWN` lint.\n \n #![allow(dead_code)]\n #![warn(clippy::doc_markdown)]\n #![feature(custom_inner_attributes)]\n #![rustfmt::skip]\n \n /// The foo_bar function does _nothing_. See also foo::bar. (note the dot there)\n-/// Markdown is _weird_. I mean _really weird_.  This \\_ is ok. So is `_`. But not Foo::some_fun\n+/// Markdown is _weird_. I mean _really weird_. This \\_ is ok. So is `_`. But not Foo::some_fun\n /// which should be reported only once despite being __doubly bad__.\n /// Here be ::a::global:path.\n /// That's not code ~NotInCodeBlock~.\n@@ -71,7 +71,7 @@ fn main() {\n }\n \n /// ## CamelCaseThing\n-/// Talks about `CamelCaseThing`. Titles should be ignored, see issue #897.\n+/// Talks about `CamelCaseThing`. Titles should be ignored; see issue #897.\n ///\n /// # CamelCaseThing\n ///\n@@ -107,7 +107,7 @@ fn issue883() {\n fn multiline() {\n }\n \n-/** E.g. serialization of an empty list: FooBar\n+/** E.g., serialization of an empty list: FooBar\n ```\n That's in a code block: `PackedNode`\n ```\n@@ -118,7 +118,7 @@ be_sure_we_got_to_the_end_of_it\n fn issue1073() {\n }\n \n-/** E.g. serialization of an empty list: FooBar\n+/** E.g., serialization of an empty list: FooBar\n ```\n That's in a code block: PackedNode\n ```\n@@ -129,7 +129,7 @@ be_sure_we_got_to_the_end_of_it\n fn issue1073_alt() {\n }\n \n-/// Test more than three quotes:\n+/// Tests more than three quotes:\n /// ````\n /// DoNotWarn\n /// ```"}, {"sha": "ae9bb394cb9ac726bcca6129a5e7bb1c3349741d", "filename": "tests/ui/doc.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdoc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fdoc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -1,16 +1,10 @@\n-error: you should put `DOC_MARKDOWN` between ticks in the documentation\n-  --> $DIR/doc.rs:1:29\n-   |\n-LL | //! This file tests for the DOC_MARKDOWN lint\n-   |                             ^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::doc-markdown` implied by `-D warnings`\n-\n error: you should put `foo_bar` between ticks in the documentation\n   --> $DIR/doc.rs:8:9\n    |\n LL | /// The foo_bar function does _nothing_. See also foo::bar. (note the dot there)\n    |         ^^^^^^^\n+   |\n+   = note: `-D clippy::doc-markdown` implied by `-D warnings`\n \n error: you should put `foo::bar` between ticks in the documentation\n   --> $DIR/doc.rs:8:51\n@@ -19,10 +13,10 @@ LL | /// The foo_bar function does _nothing_. See also foo::bar. (note the dot t\n    |                                                   ^^^^^^^^\n \n error: you should put `Foo::some_fun` between ticks in the documentation\n-  --> $DIR/doc.rs:9:84\n+  --> $DIR/doc.rs:9:83\n    |\n-LL | /// Markdown is _weird_. I mean _really weird_.  This /_ is ok. So is `_`. But not Foo::some_fun\n-   |                                                                                    ^^^^^^^^^^^^^\n+LL | /// Markdown is _weird_. I mean _really weird_. This /_ is ok. So is `_`. But not Foo::some_fun\n+   |                                                                                   ^^^^^^^^^^^^^\n \n error: you should put `a::global:path` between ticks in the documentation\n   --> $DIR/doc.rs:11:15\n@@ -115,10 +109,10 @@ LL | /// be_sure_we_got_to_the_end_of_it\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `FooBar` between ticks in the documentation\n-  --> $DIR/doc.rs:110:42\n+  --> $DIR/doc.rs:110:43\n    |\n-LL | /** E.g. serialization of an empty list: FooBar\n-   |                                          ^^^^^^\n+LL | /** E.g., serialization of an empty list: FooBar\n+   |                                           ^^^^^^\n \n error: you should put `BarQuz` between ticks in the documentation\n   --> $DIR/doc.rs:115:5\n@@ -133,10 +127,10 @@ LL | be_sure_we_got_to_the_end_of_it\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you should put `FooBar` between ticks in the documentation\n-  --> $DIR/doc.rs:121:42\n+  --> $DIR/doc.rs:121:43\n    |\n-LL | /** E.g. serialization of an empty list: FooBar\n-   |                                          ^^^^^^\n+LL | /** E.g., serialization of an empty list: FooBar\n+   |                                           ^^^^^^\n \n error: you should put `BarQuz` between ticks in the documentation\n   --> $DIR/doc.rs:126:5\n@@ -186,5 +180,5 @@ error: you should put `mycrate::Collection` between ticks in the documentation\n LL | /// An iterator over mycrate::Collection's values.\n    |                      ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 31 previous errors\n+error: aborting due to 30 previous errors\n "}, {"sha": "ab973e07511375f7c2cbf03d528f7577e490a49d", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -6,51 +6,51 @@\n struct Foo(pub String);\n \n macro_rules! foo {\n-  ($($t:tt)*) => (Foo(format!($($t)*)))\n+    ($($t:tt)*) => (Foo(format!($($t)*)))\n }\n \n fn main() {\n     \"foo\".to_string();\n \n     \"foo\".to_string();\n-    format!(\"{:?}\", \"foo\"); // don't warn about debug\n+    format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n     format!(\"{:8}\", \"foo\");\n     format!(\"{:width$}\", \"foo\", width = 8);\n-    \"foo\".to_string(); // warn when the format makes no difference\n-    \"foo\".to_string(); // warn when the format makes no difference\n+    \"foo\".to_string(); // Warn when the format makes no difference.\n+    \"foo\".to_string(); // Warn when the format makes no difference.\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n     let arg: String = \"\".to_owned();\n     arg.to_string();\n-    format!(\"{:?}\", arg); // don't warn about debug\n+    format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);\n     format!(\"{:width$}\", arg, width = 8);\n-    arg.to_string(); // warn when the format makes no difference\n-    arg.to_string(); // warn when the format makes no difference\n+    arg.to_string(); // Warn when the format makes no difference.\n+    arg.to_string(); // Warn when the format makes no difference.\n     format!(\"foo {}\", arg);\n     format!(\"{} bar\", arg);\n \n-    // we don\u2019t want to warn for non-string args, see #697\n+    // We don\u2019t want to warn for non-string args; see issue #697.\n     format!(\"{}\", 42);\n     format!(\"{:?}\", 42);\n     format!(\"{:+}\", 42);\n     format!(\"foo {}\", 42);\n     format!(\"{} bar\", 42);\n \n-    // we only want to warn about `format!` itself\n+    // We only want to warn about `format!` itself.\n     println!(\"foo\");\n     println!(\"{}\", \"foo\");\n     println!(\"foo {}\", \"foo\");\n     println!(\"{}\", 42);\n     println!(\"foo {}\", 42);\n \n-    // A format! inside a macro should not trigger a warning\n+    // A `format!` inside a macro should not trigger a warning.\n     foo!(\"should not warn\");\n \n-    // precision on string means slicing without panicking on size:\n-    format!(\"{:.1}\", \"foo\"); // could be \"foo\"[..1]\n-    format!(\"{:.10}\", \"foo\"); // could not be \"foo\"[..10]\n+    // Precision on string means slicing without panicking on size.\n+    format!(\"{:.1}\", \"foo\"); // Could be `\"foo\"[..1]`\n+    format!(\"{:.10}\", \"foo\"); // Could not be `\"foo\"[..10]`\n     format!(\"{:.prec$}\", \"foo\", prec = 1);\n     format!(\"{:.prec$}\", \"foo\", prec = 10);\n "}, {"sha": "2ef31f0b9484cf79ba57e7f3ae1ffd7bc22815ce", "filename": "tests/ui/format.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -6,51 +6,51 @@\n struct Foo(pub String);\n \n macro_rules! foo {\n-  ($($t:tt)*) => (Foo(format!($($t)*)))\n+    ($($t:tt)*) => (Foo(format!($($t)*)))\n }\n \n fn main() {\n     format!(\"foo\");\n \n     format!(\"{}\", \"foo\");\n-    format!(\"{:?}\", \"foo\"); // don't warn about debug\n+    format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n     format!(\"{:8}\", \"foo\");\n     format!(\"{:width$}\", \"foo\", width = 8);\n-    format!(\"{:+}\", \"foo\"); // warn when the format makes no difference\n-    format!(\"{:<}\", \"foo\"); // warn when the format makes no difference\n+    format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n+    format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n     let arg: String = \"\".to_owned();\n     format!(\"{}\", arg);\n-    format!(\"{:?}\", arg); // don't warn about debug\n+    format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);\n     format!(\"{:width$}\", arg, width = 8);\n-    format!(\"{:+}\", arg); // warn when the format makes no difference\n-    format!(\"{:<}\", arg); // warn when the format makes no difference\n+    format!(\"{:+}\", arg); // Warn when the format makes no difference.\n+    format!(\"{:<}\", arg); // Warn when the format makes no difference.\n     format!(\"foo {}\", arg);\n     format!(\"{} bar\", arg);\n \n-    // we don\u2019t want to warn for non-string args, see #697\n+    // We don\u2019t want to warn for non-string args; see issue #697.\n     format!(\"{}\", 42);\n     format!(\"{:?}\", 42);\n     format!(\"{:+}\", 42);\n     format!(\"foo {}\", 42);\n     format!(\"{} bar\", 42);\n \n-    // we only want to warn about `format!` itself\n+    // We only want to warn about `format!` itself.\n     println!(\"foo\");\n     println!(\"{}\", \"foo\");\n     println!(\"foo {}\", \"foo\");\n     println!(\"{}\", 42);\n     println!(\"foo {}\", 42);\n \n-    // A format! inside a macro should not trigger a warning\n+    // A `format!` inside a macro should not trigger a warning.\n     foo!(\"should not warn\");\n \n-    // precision on string means slicing without panicking on size:\n-    format!(\"{:.1}\", \"foo\"); // could be \"foo\"[..1]\n-    format!(\"{:.10}\", \"foo\"); // could not be \"foo\"[..10]\n+    // Precision on string means slicing without panicking on size.\n+    format!(\"{:.1}\", \"foo\"); // Could be `\"foo\"[..1]`\n+    format!(\"{:.10}\", \"foo\"); // Could not be `\"foo\"[..10]`\n     format!(\"{:.prec$}\", \"foo\", prec = 1);\n     format!(\"{:.prec$}\", \"foo\", prec = 10);\n "}, {"sha": "7ca63e2fea5186a9f7731f8e1524ee0702382271", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -15,13 +15,13 @@ LL |     format!(\"{}\", \"foo\");\n error: useless use of `format!`\n   --> $DIR/format.rs:19:5\n    |\n-LL |     format!(\"{:+}\", \"foo\"); // warn when the format makes no difference\n+LL |     format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string();`\n \n error: useless use of `format!`\n   --> $DIR/format.rs:20:5\n    |\n-LL |     format!(\"{:<}\", \"foo\"); // warn when the format makes no difference\n+LL |     format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string();`\n \n error: useless use of `format!`\n@@ -33,13 +33,13 @@ LL |     format!(\"{}\", arg);\n error: useless use of `format!`\n   --> $DIR/format.rs:29:5\n    |\n-LL |     format!(\"{:+}\", arg); // warn when the format makes no difference\n+LL |     format!(\"{:+}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string();`\n \n error: useless use of `format!`\n   --> $DIR/format.rs:30:5\n    |\n-LL |     format!(\"{:<}\", arg); // warn when the format makes no difference\n+LL |     format!(\"{:<}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string();`\n \n error: useless use of `format!`"}, {"sha": "0ec933e87847d2ee6ebee32b216276bea9b6f5cb", "filename": "tests/ui/if_same_then_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -232,7 +232,7 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n         return Ok(&foo[0..]);\n     }\n \n-    // false positive if_same_then_else, let(x,y) vs let(y,x), see #3559\n+    // False positive `if_same_then_else`: `let (x, y)` vs. `let (y, x)`; see issue #3559.\n     if true {\n         let foo = \"\";\n         let (x, y) = (1, 2);\n@@ -244,7 +244,7 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n     }\n }\n \n-// Issue #2423. This was causing an ICE\n+// Issue #2423. This was causing an ICE.\n fn func() {\n     if true {\n         f(&[0; 62]);"}, {"sha": "db97c2427f372b23cf366b1673094d240030d533", "filename": "tests/ui/len_zero.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -10,13 +10,13 @@ impl PubOne {\n }\n \n impl PubOne {\n-    // A second impl for this struct - the error span shouldn't mention this\n+    // A second impl for this struct -- the error span shouldn't mention this.\n     pub fn irrelevant(self: &Self) -> bool {\n         false\n     }\n }\n \n-// Identical to PubOne, but with an allow attribute on the impl complaining len\n+// Identical to `PubOne`, but with an `allow` attribute on the impl complaining `len`.\n pub struct PubAllowed;\n \n #[allow(clippy::len_without_is_empty)]\n@@ -26,8 +26,8 @@ impl PubAllowed {\n     }\n }\n \n-// No allow attribute on this impl block, but that doesn't matter - we only require one on the\n-// impl containing len.\n+// No `allow` attribute on this impl block, but that doesn't matter -- we only require one on the\n+// impl containing `len`.\n impl PubAllowed {\n     pub fn irrelevant(self: &Self) -> bool {\n         false\n@@ -38,7 +38,7 @@ struct NotPubOne;\n \n impl NotPubOne {\n     pub fn len(self: &Self) -> isize {\n-        // no error, len is pub but `NotPubOne` is not exported anyway\n+        // No error; `len` is pub but `NotPubOne` is not exported anyway.\n         1\n     }\n }\n@@ -47,7 +47,7 @@ struct One;\n \n impl One {\n     fn len(self: &Self) -> isize {\n-        // no error, len is private, see #1085\n+        // No error; `len` is private; see issue #1085.\n         1\n     }\n }\n@@ -63,7 +63,8 @@ impl PubTraitsToo for One {\n }\n \n trait TraitsToo {\n-    fn len(self: &Self) -> isize; // no error, len is private, see #1085\n+    fn len(self: &Self) -> isize;\n+    // No error; `len` is private; see issue #1085.\n }\n \n impl TraitsToo for One {\n@@ -130,7 +131,7 @@ pub trait Empty {\n }\n \n pub trait InheritingEmpty: Empty {\n-    //must not trigger LEN_WITHOUT_IS_EMPTY\n+    // Must not trigger `LEN_WITHOUT_IS_EMPTY`.\n     fn len(&self) -> isize;\n }\n \n@@ -144,13 +145,13 @@ fn main() {\n \n     let y = One;\n     if y.len() == 0 {\n-        //no error because One does not have .is_empty()\n+        // No error; `One` does not have `.is_empty()`.\n         println!(\"This should not happen either!\");\n     }\n \n     let z: &TraitsToo = &y;\n     if z.len() > 0 {\n-        //no error, because TraitsToo has no .is_empty() method\n+        // No error; `TraitsToo` has no `.is_empty()` method.\n         println!(\"Nor should this!\");\n     }\n \n@@ -171,11 +172,11 @@ fn main() {\n         println!(\"Or this!\");\n     }\n     if has_is_empty.len() > 1 {\n-        // no error\n+        // No error.\n         println!(\"This can happen.\");\n     }\n     if has_is_empty.len() <= 1 {\n-        // no error\n+        // No error.\n         println!(\"This can happen.\");\n     }\n     if 0 == has_is_empty.len() {\n@@ -194,11 +195,11 @@ fn main() {\n         println!(\"Or this!\");\n     }\n     if 1 < has_is_empty.len() {\n-        // no error\n+        // No error.\n         println!(\"This can happen.\");\n     }\n     if 1 >= has_is_empty.len() {\n-        // no error\n+        // No error.\n         println!(\"This can happen.\");\n     }\n     assert!(!has_is_empty.is_empty());\n@@ -211,7 +212,7 @@ fn main() {\n \n     let has_wrong_is_empty = HasWrongIsEmpty;\n     if has_wrong_is_empty.len() == 0 {\n-        //no error as HasWrongIsEmpty does not have .is_empty()\n+        // No error; `HasWrongIsEmpty` does not have `.is_empty()`.\n         println!(\"Or this!\");\n     }\n }\n@@ -220,7 +221,7 @@ fn test_slice(b: &[u8]) {\n     if b.len() != 0 {}\n }\n \n-// this used to ICE\n+// This used to ICE.\n pub trait Foo: Sized {}\n \n pub trait DependsOnFoo: Foo {"}, {"sha": "f2ad0bb9e1e479edc9865f3ace57b2447ccd57f6", "filename": "tests/ui/len_zero.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flen_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flen_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -19,7 +19,7 @@ LL | | }\n    | |_^\n \n error: item `HasIsEmpty` has a public `len` method but a private `is_empty` method\n-  --> $DIR/len_zero.rs:89:1\n+  --> $DIR/len_zero.rs:90:1\n    |\n LL | / impl HasIsEmpty {\n LL | |     pub fn len(self: &Self) -> isize {\n@@ -31,7 +31,7 @@ LL | | }\n    | |_^\n \n error: item `HasWrongIsEmpty` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_zero.rs:118:1\n+  --> $DIR/len_zero.rs:119:1\n    |\n LL | / impl HasWrongIsEmpty {\n LL | |     pub fn len(self: &Self) -> isize {\n@@ -43,93 +43,93 @@ LL | | }\n    | |_^\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:139:8\n+  --> $DIR/len_zero.rs:140:8\n    |\n LL |     if x.len() == 0 {\n    |        ^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `x.is_empty()`\n    |\n    = note: `-D clippy::len-zero` implied by `-D warnings`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:143:8\n+  --> $DIR/len_zero.rs:144:8\n    |\n LL |     if \"\".len() == 0 {}\n    |        ^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `\"\".is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:158:8\n+  --> $DIR/len_zero.rs:159:8\n    |\n LL |     if has_is_empty.len() == 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:161:8\n+  --> $DIR/len_zero.rs:162:8\n    |\n LL |     if has_is_empty.len() != 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:164:8\n+  --> $DIR/len_zero.rs:165:8\n    |\n LL |     if has_is_empty.len() > 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n-  --> $DIR/len_zero.rs:167:8\n+  --> $DIR/len_zero.rs:168:8\n    |\n LL |     if has_is_empty.len() < 1 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to one\n-  --> $DIR/len_zero.rs:170:8\n+  --> $DIR/len_zero.rs:171:8\n    |\n LL |     if has_is_empty.len() >= 1 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:181:8\n+  --> $DIR/len_zero.rs:182:8\n    |\n LL |     if 0 == has_is_empty.len() {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:184:8\n+  --> $DIR/len_zero.rs:185:8\n    |\n LL |     if 0 != has_is_empty.len() {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:187:8\n+  --> $DIR/len_zero.rs:188:8\n    |\n LL |     if 0 < has_is_empty.len() {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n-  --> $DIR/len_zero.rs:190:8\n+  --> $DIR/len_zero.rs:191:8\n    |\n LL |     if 1 <= has_is_empty.len() {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!has_is_empty.is_empty()`\n \n error: length comparison to one\n-  --> $DIR/len_zero.rs:193:8\n+  --> $DIR/len_zero.rs:194:8\n    |\n LL |     if 1 > has_is_empty.len() {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `has_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:207:8\n+  --> $DIR/len_zero.rs:208:8\n    |\n LL |     if with_is_empty.len() == 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `with_is_empty.is_empty()`\n \n error: length comparison to zero\n-  --> $DIR/len_zero.rs:220:8\n+  --> $DIR/len_zero.rs:221:8\n    |\n LL |     if b.len() != 0 {}\n    |        ^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `!b.is_empty()`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_zero.rs:226:1\n+  --> $DIR/len_zero.rs:227:1\n    |\n LL | / pub trait DependsOnFoo: Foo {\n LL | |     fn len(&mut self) -> usize;"}, {"sha": "2cb236fa3bc3843d3303d282d70903e25d8c1859", "filename": "tests/ui/lifetimes.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -5,41 +5,48 @@ fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n \n fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n \n-fn same_lifetime_on_input<'a>(_x: &'a u8, _y: &'a u8) {} // no error, same lifetime on two params\n+// No error; same lifetime on two params.\n+fn same_lifetime_on_input<'a>(_x: &'a u8, _y: &'a u8) {}\n \n-fn only_static_on_input(_x: &u8, _y: &u8, _z: &'static u8) {} // no error, static involved\n+// No error; static involved.\n+fn only_static_on_input(_x: &u8, _y: &u8, _z: &'static u8) {}\n \n fn mut_and_static_input(_x: &mut u8, _y: &'static str) {}\n \n fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n     x\n }\n \n+// No error; multiple input refs.\n fn multiple_in_and_out_1<'a>(x: &'a u8, _y: &'a u8) -> &'a u8 {\n     x\n-} // no error, multiple input refs\n+}\n \n+// No error; multiple input refs.\n fn multiple_in_and_out_2<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n     x\n-} // no error, multiple input refs\n+}\n \n+// No error; static involved.\n fn in_static_and_out<'a>(x: &'a u8, _y: &'static u8) -> &'a u8 {\n     x\n-} // no error, static involved\n+}\n \n+// No error.\n fn deep_reference_1<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n     Ok(x)\n-} // no error\n+}\n \n+// No error; two input refs.\n fn deep_reference_2<'a>(x: Result<&'a u8, &'a u8>) -> &'a u8 {\n     x.unwrap()\n-} // no error, two input refs\n+}\n \n fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n     Ok(x)\n }\n \n-// where clause, but without lifetimes\n+// Where-clause, but without lifetimes.\n fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n where\n     T: Copy,\n@@ -49,25 +56,29 @@ where\n \n type Ref<'r> = &'r u8;\n \n-fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) {} // no error, same lifetime on two params\n+// No error; same lifetime on two params.\n+fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) {}\n \n fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n \n-fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) {} // no error, bounded lifetime\n+// No error; bounded lifetime.\n+fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) {}\n \n+// No error; bounded lifetime.\n fn lifetime_param_4<'a, 'b>(_x: Ref<'a>, _y: &'b u8)\n where\n     'b: 'a,\n {\n-} // no error, bounded lifetime\n+}\n \n struct Lt<'a, I: 'static> {\n     x: &'a I,\n }\n \n+// No error; fn bound references `'a`.\n fn fn_bound<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n where\n-    F: Fn(Lt<'a, I>) -> Lt<'a, I>, // no error, fn bound references 'a\n+    F: Fn(Lt<'a, I>) -> Lt<'a, I>,\n {\n     unreachable!()\n }\n@@ -79,19 +90,20 @@ where\n     unreachable!()\n }\n \n+// No error; see below.\n fn fn_bound_3<'a, F: FnOnce(&'a i32)>(x: &'a i32, f: F) {\n-    // no error, see below\n     f(x);\n }\n \n fn fn_bound_3_cannot_elide() {\n     let x = 42;\n     let p = &x;\n     let mut q = &x;\n-    fn_bound_3(p, |y| q = y); // this will fail if we elides lifetimes of `fn_bound_3`\n+    // This will fail if we elide lifetimes of `fn_bound_3`.\n+    fn_bound_3(p, |y| q = y);\n }\n \n-// no error, multiple input refs\n+// No error; multiple input refs.\n fn fn_bound_4<'a, F: FnOnce() -> &'a ()>(cond: bool, x: &'a (), f: F) -> &'a () {\n     if cond {\n         x\n@@ -109,20 +121,24 @@ impl X {\n         &self.x\n     }\n \n+    // No error; multiple input refs.\n     fn self_and_in_out<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n         &self.x\n-    } // no error, multiple input refs\n+    }\n \n     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n \n-    fn self_and_same_in<'s>(&'s self, _x: &'s u8) {} // no error, same lifetimes on two params\n+    // No error; same lifetimes on two params.\n+    fn self_and_same_in<'s>(&'s self, _x: &'s u8) {}\n }\n \n struct Foo<'a>(&'a u8);\n \n impl<'a> Foo<'a> {\n-    fn self_shared_lifetime(&self, _: &'a u8) {} // no error, lifetime 'a not defined in method\n-    fn self_bound_lifetime<'b: 'a>(&self, _: &'b u8) {} // no error, bounds exist\n+    // No error; lifetime `'a` not defined in method.\n+    fn self_shared_lifetime(&self, _: &'a u8) {}\n+    // No error; bounds exist.\n+    fn self_bound_lifetime<'b: 'a>(&self, _: &'b u8) {}\n }\n \n fn already_elided<'a>(_: &u8, _: &'a u8) -> &'a u8 {\n@@ -133,17 +149,17 @@ fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes (named on the reference, anonymous on Foo)\n+// No warning; two input lifetimes (named on the reference, anonymous on `Foo`).\n fn struct_with_lt2<'a>(_foo: &'a Foo) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes (anonymous on the reference, named on Foo)\n+// No warning; two input lifetimes (anonymous on the reference, named on `Foo`).\n fn struct_with_lt3<'a>(_foo: &Foo<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes\n+// No warning; two input lifetimes.\n fn struct_with_lt4<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n     unimplemented!()\n }\n@@ -152,13 +168,13 @@ trait WithLifetime<'a> {}\n \n type WithLifetimeAlias<'a> = WithLifetime<'a>;\n \n-// should not warn because it won't build without the lifetime\n+// Should not warn because it won't build without the lifetime.\n fn trait_obj_elided<'a>(_arg: &'a WithLifetime) -> &'a str {\n     unimplemented!()\n }\n \n-// this should warn because there is no lifetime on Drop, so this would be\n-// unambiguous if we elided the lifetime\n+// Should warn because there is no lifetime on `Drop`, so this would be\n+// unambiguous if we elided the lifetime.\n fn trait_obj_elided2<'a>(_arg: &'a Drop) -> &'a str {\n     unimplemented!()\n }\n@@ -169,17 +185,17 @@ fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes (named on the reference, anonymous on Foo)\n+// No warning; two input lifetimes (named on the reference, anonymous on `FooAlias`).\n fn alias_with_lt2<'a>(_foo: &'a FooAlias) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes (anonymous on the reference, named on Foo)\n+// No warning; two input lifetimes (anonymous on the reference, named on `FooAlias`).\n fn alias_with_lt3<'a>(_foo: &FooAlias<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// no warning, two input lifetimes\n+// No warning; two input lifetimes.\n fn alias_with_lt4<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n     unimplemented!()\n }\n@@ -199,12 +215,12 @@ fn trait_bound<'a, T: WithLifetime<'a>>(_: &'a u8, _: T) {\n     unimplemented!()\n }\n \n-// don't warn on these, see #292\n+// Don't warn on these; see issue #292.\n fn trait_bound_bug<'a, T: WithLifetime<'a>>() {\n     unimplemented!()\n }\n \n-// #740\n+// See issue #740.\n struct Test {\n     vec: Vec<usize>,\n }\n@@ -224,8 +240,7 @@ fn test<'a>(x: &'a [u8]) -> u8 {\n     *y\n }\n \n-// #3284 - Give a hint regarding lifetime in return type\n-\n+// Issue #3284: give hint regarding lifetime in return type.\n struct Cow<'a> {\n     x: &'a str,\n }"}, {"sha": "9eac0407e4d58fd2158af2644a7f86e23a4e3ad3", "filename": "tests/ui/lifetimes.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Flifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -13,23 +13,23 @@ LL | fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:14:1\n+  --> $DIR/lifetimes.rs:16:1\n    |\n LL | / fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n LL | |     x\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:38:1\n+  --> $DIR/lifetimes.rs:45:1\n    |\n LL | / fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n LL | |     Ok(x)\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:43:1\n+  --> $DIR/lifetimes.rs:50:1\n    |\n LL | / fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n LL | | where\n@@ -40,13 +40,13 @@ LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:54:1\n+  --> $DIR/lifetimes.rs:62:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:75:1\n+  --> $DIR/lifetimes.rs:86:1\n    |\n LL | / fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n LL | | where\n@@ -57,61 +57,61 @@ LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:108:5\n+  --> $DIR/lifetimes.rs:120:5\n    |\n LL | /     fn self_and_out<'s>(&'s self) -> &'s u8 {\n LL | |         &self.x\n LL | |     }\n    | |_____^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:116:5\n+  --> $DIR/lifetimes.rs:129:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:132:1\n+  --> $DIR/lifetimes.rs:148:1\n    |\n LL | / fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n LL | |     unimplemented!()\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:162:1\n+  --> $DIR/lifetimes.rs:178:1\n    |\n LL | / fn trait_obj_elided2<'a>(_arg: &'a Drop) -> &'a str {\n LL | |     unimplemented!()\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:168:1\n+  --> $DIR/lifetimes.rs:184:1\n    |\n LL | / fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n LL | |     unimplemented!()\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:187:1\n+  --> $DIR/lifetimes.rs:203:1\n    |\n LL | / fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n LL | |     unimplemented!()\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:195:1\n+  --> $DIR/lifetimes.rs:211:1\n    |\n LL | / fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n LL | |     unimplemented!()\n LL | | }\n    | |_^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/lifetimes.rs:232:1\n+  --> $DIR/lifetimes.rs:247:1\n    |\n LL | / fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n LL | |     unimplemented!()"}, {"sha": "b711367d123cfaf49c84304dd9d0aaa6fa511a93", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -13,7 +13,7 @@ fn ref_pats() {\n             &None => println!(\"none\"),\n         }\n         match v {\n-            // this doesn't trigger, we have a different pattern\n+            // This doesn't trigger; we have a different pattern.\n             &Some(v) => println!(\"some\"),\n             other => println!(\"other\"),\n         }\n@@ -23,13 +23,13 @@ fn ref_pats() {\n         &(v, 1) => println!(\"{}\", v),\n         _ => println!(\"none\"),\n     }\n-    // special case: using & both in expr and pats\n+    // Special case: using `&` both in expr and pats.\n     let w = Some(0);\n     match &w {\n         &Some(v) => println!(\"{:?}\", v),\n         &None => println!(\"none\"),\n     }\n-    // false positive: only wildcard pattern\n+    // False positive: only wildcard pattern.\n     let w = Some(0);\n     match w {\n         _ => println!(\"none\"),\n@@ -69,14 +69,14 @@ fn match_wild_err_arm() {\n         },\n     }\n \n-    // allowed when not with `panic!` block\n+    // Allowed when not with `panic!` block.\n     match x {\n         Ok(3) => println!(\"ok\"),\n         Ok(_) => println!(\"ok\"),\n         Err(_) => println!(\"err\"),\n     }\n \n-    // allowed when used with `unreachable!`\n+    // Allowed when used with `unreachable!`.\n     match x {\n         Ok(3) => println!(\"ok\"),\n         Ok(_) => println!(\"ok\"),\n@@ -97,14 +97,14 @@ fn match_wild_err_arm() {\n         },\n     }\n \n-    // no warning because of the guard\n+    // No warning because of the guard.\n     match x {\n         Ok(x) if x * x == 64 => println!(\"ok\"),\n         Ok(_) => println!(\"ok\"),\n         Err(_) => println!(\"err\"),\n     }\n \n-    // this used to be a false positive, see #1996\n+    // This used to be a false positive; see issue #1996.\n     match x {\n         Ok(3) => println!(\"ok\"),\n         Ok(x) if x * x == 64 => println!(\"ok 64\"),\n@@ -118,14 +118,14 @@ fn match_wild_err_arm() {\n         _ => println!(\"err\"),\n     }\n \n-    // no warning because of the different types for x\n+    // No warning; different types for `x`.\n     match (x, Some(1.0f64)) {\n         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n         _ => println!(\"err\"),\n     }\n \n-    // because of a bug, no warning was generated for this case before #2251\n+    // Because of a bug, no warning was generated for this case before #2251.\n     match x {\n         Ok(_tmp) => println!(\"ok\"),\n         Ok(3) => println!(\"ok\"),"}, {"sha": "46a16f75c7bcce4b91a916970a7dec6412ab37f1", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -49,19 +49,20 @@ impl T {\n         true\n     }\n \n-    // no error, self is a ref\n+    // No error; self is a ref.\n     fn sub(&self, other: T) -> &T {\n         self\n     }\n \n-    // no error, different #arguments\n+    // No error; different number of arguments.\n     fn div(self) -> T {\n         self\n     }\n \n-    fn rem(self, other: T) {} // no error, wrong return type\n+    // No error; wrong return type.\n+    fn rem(self, other: T) {}\n \n-    // fine\n+    // Fine\n     fn into_u32(self) -> u32 {\n         0\n     }\n@@ -84,7 +85,7 @@ struct Lt<'a> {\n }\n \n impl<'a> Lt<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n     #[allow(clippy::needless_lifetimes)]\n     pub fn new<'b>(s: &'b str) -> Lt<'b> {\n         unimplemented!()\n@@ -96,7 +97,7 @@ struct Lt2<'a> {\n }\n \n impl<'a> Lt2<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n     pub fn new(s: &str) -> Lt2 {\n         unimplemented!()\n     }\n@@ -107,7 +108,7 @@ struct Lt3<'a> {\n }\n \n impl<'a> Lt3<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n     pub fn new() -> Lt3<'static> {\n         unimplemented!()\n     }\n@@ -120,7 +121,7 @@ impl U {\n     fn new() -> Self {\n         U\n     }\n-    // ok because U is Copy\n+    // Ok because `U` is `Copy`.\n     fn to_something(self) -> u32 {\n         0\n     }\n@@ -138,7 +139,7 @@ impl<T> V<T> {\n \n impl Mul<T> for T {\n     type Output = T;\n-    // no error, obviously\n+    // No error, obviously.\n     fn mul(self, other: T) -> T {\n         self\n     }\n@@ -152,12 +153,12 @@ impl Mul<T> for T {\n fn option_methods() {\n     let opt = Some(1);\n \n-    // Check OPTION_MAP_UNWRAP_OR\n-    // single line case\n+    // Check `OPTION_MAP_UNWRAP_OR`.\n+    // Single line case.\n     let _ = opt.map(|x| x + 1)\n-\n-               .unwrap_or(0); // should lint even though this call is on a separate line\n-    // multi line cases\n+                // Should lint even though this call is on a separate line.\n+               .unwrap_or(0);\n+    // Multi-line cases.\n     let _ = opt.map(|x| {\n                         x + 1\n                     }\n@@ -166,9 +167,9 @@ fn option_methods() {\n                .unwrap_or({\n                     0\n                 });\n-    // single line `map(f).unwrap_or(None)` case\n+    // Single line `map(f).unwrap_or(None)` case.\n     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n-    // multiline `map(f).unwrap_or(None)` cases\n+    // Multi-line `map(f).unwrap_or(None)` cases.\n     let _ = opt.map(|x| {\n         Some(x + 1)\n     }\n@@ -189,9 +190,9 @@ fn option_methods() {\n     // Check OPTION_MAP_UNWRAP_OR_ELSE\n     // single line case\n     let _ = opt.map(|x| x + 1)\n-\n-               .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n-    // multi line cases\n+                // Should lint even though this call is on a separate line.\n+               .unwrap_or_else(|| 0);\n+    // Multi-line cases.\n     let _ = opt.map(|x| {\n                         x + 1\n                     }\n@@ -200,20 +201,21 @@ fn option_methods() {\n                .unwrap_or_else(||\n                     0\n                 );\n-    // macro case\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0); // should not lint\n+    // Macro case.\n+    // Should not lint.\n+    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n \n-    // Check OPTION_MAP_OR_NONE\n-    // single line case\n+    // Check `OPTION_MAP_OR_NONE`.\n+    // Single line case.\n     let _ = opt.map_or(None, |x| Some(x + 1));\n-    // multi line case\n+    // Multi-line case.\n     let _ = opt.map_or(None, |x| {\n                         Some(x + 1)\n                        }\n                 );\n }\n \n-/// Struct to generate false positives for things with .iter()\n+/// Struct to generate false positives for things with `.iter()`.\n #[derive(Copy, Clone)]\n struct HasIter;\n \n@@ -227,65 +229,65 @@ impl HasIter {\n     }\n }\n \n-/// Checks implementation of `FILTER_NEXT` lint\n+/// Checks implementation of `FILTER_NEXT` lint.\n #[rustfmt::skip]\n fn filter_next() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n-    // check single-line case\n+    // Single-line case.\n     let _ = v.iter().filter(|&x| *x < 0).next();\n \n-    // check multi-line case\n+    // Multi-line case.\n     let _ = v.iter().filter(|&x| {\n                                 *x < 0\n                             }\n                    ).next();\n \n-    // check that we don't lint if the caller is not an Iterator\n+    // Check that hat we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.filter().next();\n }\n \n-/// Checks implementation of `SEARCH_IS_SOME` lint\n+/// Checks implementation of `SEARCH_IS_SOME` lint.\n #[rustfmt::skip]\n fn search_is_some() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n-    // check `find().is_some()`, single-line\n+    // Check `find().is_some()`, single-line case.\n     let _ = v.iter().find(|&x| *x < 0).is_some();\n \n-    // check `find().is_some()`, multi-line\n+    // Check `find().is_some()`, multi-line case.\n     let _ = v.iter().find(|&x| {\n                               *x < 0\n                           }\n                    ).is_some();\n \n-    // check `position().is_some()`, single-line\n+    // Check `position().is_some()`, single-line case.\n     let _ = v.iter().position(|&x| x < 0).is_some();\n \n-    // check `position().is_some()`, multi-line\n+    // Check `position().is_some()`, multi-line case.\n     let _ = v.iter().position(|&x| {\n                                   x < 0\n                               }\n                    ).is_some();\n \n-    // check `rposition().is_some()`, single-line\n+    // Check `rposition().is_some()`, single-line case.\n     let _ = v.iter().rposition(|&x| x < 0).is_some();\n \n-    // check `rposition().is_some()`, multi-line\n+    // Check `rposition().is_some()`, multi-line case.\n     let _ = v.iter().rposition(|&x| {\n                                    x < 0\n                                }\n                    ).is_some();\n \n-    // check that we don't lint if the caller is not an Iterator\n+    // Check that we don't lint if the caller is not an `Iterator`.\n     let foo = IteratorFalsePositives { foo: 0 };\n     let _ = foo.find().is_some();\n     let _ = foo.position().is_some();\n     let _ = foo.rposition().is_some();\n }\n \n-/// Checks implementation of the `OR_FUN_CALL` lint\n+/// Checks implementation of the `OR_FUN_CALL` lint.\n fn or_fun_call() {\n     struct Foo;\n \n@@ -348,22 +350,22 @@ fn or_fun_call() {\n     let _ = stringy.unwrap_or(\"\".to_owned());\n }\n \n-/// Checks implementation of `ITER_NTH` lint\n+/// Checks implementation of `ITER_NTH` lint.\n fn iter_nth() {\n     let mut some_vec = vec![0, 1, 2, 3];\n     let mut boxed_slice: Box<[u8]> = Box::new([0, 1, 2, 3]);\n     let mut some_vec_deque: VecDeque<_> = some_vec.iter().cloned().collect();\n \n     {\n-        // Make sure we lint `.iter()` for relevant types\n+        // Make sure we lint `.iter()` for relevant types.\n         let bad_vec = some_vec.iter().nth(3);\n         let bad_slice = &some_vec[..].iter().nth(3);\n         let bad_boxed_slice = boxed_slice.iter().nth(3);\n         let bad_vec_deque = some_vec_deque.iter().nth(3);\n     }\n \n     {\n-        // Make sure we lint `.iter_mut()` for relevant types\n+        // Make sure we lint `.iter_mut()` for relevant types.\n         let bad_vec = some_vec.iter_mut().nth(3);\n     }\n     {\n@@ -373,7 +375,7 @@ fn iter_nth() {\n         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n     }\n \n-    // Make sure we don't lint for non-relevant types\n+    // Make sure we don't lint for non-relevant types.\n     let false_positive = HasIter;\n     let ok = false_positive.iter().nth(3);\n     let ok_mut = false_positive.iter_mut().nth(3);"}, {"sha": "cfbb0152eebdb9a130b069cb13dd49960c9c7255", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -9,39 +9,39 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:69:17\n+  --> $DIR/methods.rs:70:17\n    |\n LL |     fn into_u16(&self) -> u16 {\n    |                 ^^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:73:21\n+  --> $DIR/methods.rs:74:21\n    |\n LL |     fn to_something(self) -> u32 {\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:77:12\n+  --> $DIR/methods.rs:78:12\n    |\n LL |     fn new(self) -> Self {\n    |            ^^^^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:157:13\n+  --> $DIR/methods.rs:158:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n-LL | |\n-LL | |                .unwrap_or(0); // should lint even though this call is on a separate line\n+LL | |                 // Should lint even though this call is on a separate line.\n+LL | |                .unwrap_or(0);\n    | |____________________________^\n    |\n    = note: `-D clippy::option-map-unwrap-or` implied by `-D warnings`\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:161:13\n+  --> $DIR/methods.rs:162:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -51,7 +51,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:165:13\n+  --> $DIR/methods.rs:166:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -61,15 +61,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:170:13\n+  --> $DIR/methods.rs:171:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:172:13\n+  --> $DIR/methods.rs:173:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -79,7 +79,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:176:13\n+  --> $DIR/methods.rs:177:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -90,27 +90,27 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:187:13\n+  --> $DIR/methods.rs:188:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:191:13\n+  --> $DIR/methods.rs:192:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n-LL | |\n-LL | |                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n+LL | |                 // Should lint even though this call is on a separate line.\n+LL | |                .unwrap_or_else(|| 0);\n    | |____________________________________^\n    |\n    = note: `-D clippy::option-map-unwrap-or-else` implied by `-D warnings`\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:195:13\n+  --> $DIR/methods.rs:196:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:199:13\n+  --> $DIR/methods.rs:200:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -130,15 +130,15 @@ LL | |                 );\n    | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:208:13\n+  --> $DIR/methods.rs:210:13\n    |\n LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:210:13\n+  --> $DIR/methods.rs:212:13\n    |\n LL |       let _ = opt.map_or(None, |x| {\n    |  _____________^\n@@ -154,7 +154,7 @@ LL |                        });\n    |\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:236:13\n+  --> $DIR/methods.rs:238:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -163,7 +163,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:239:13\n+  --> $DIR/methods.rs:241:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -173,7 +173,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:255:13\n+  --> $DIR/methods.rs:257:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -182,7 +182,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:258:13\n+  --> $DIR/methods.rs:260:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -192,15 +192,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:264:13\n+  --> $DIR/methods.rs:266:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:267:13\n+  --> $DIR/methods.rs:269:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -210,15 +210,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:273:13\n+  --> $DIR/methods.rs:275:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:276:13\n+  --> $DIR/methods.rs:278:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -228,125 +228,125 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:313:22\n+  --> $DIR/methods.rs:315:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/methods.rs:316:5\n+  --> $DIR/methods.rs:318:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:319:21\n+  --> $DIR/methods.rs:321:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:322:14\n+  --> $DIR/methods.rs:324:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:325:19\n+  --> $DIR/methods.rs:327:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:328:5\n+  --> $DIR/methods.rs:330:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:331:5\n+  --> $DIR/methods.rs:333:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:334:14\n+  --> $DIR/methods.rs:336:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:339:21\n+  --> $DIR/methods.rs:341:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:342:19\n+  --> $DIR/methods.rs:344:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:345:21\n+  --> $DIR/methods.rs:347:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:348:21\n+  --> $DIR/methods.rs:350:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:359:23\n+  --> $DIR/methods.rs:361:23\n    |\n LL |         let bad_vec = some_vec.iter().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:360:26\n+  --> $DIR/methods.rs:362:26\n    |\n LL |         let bad_slice = &some_vec[..].iter().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:361:31\n+  --> $DIR/methods.rs:363:31\n    |\n LL |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:362:29\n+  --> $DIR/methods.rs:364:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:367:23\n+  --> $DIR/methods.rs:369:23\n    |\n LL |         let bad_vec = some_vec.iter_mut().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:370:26\n+  --> $DIR/methods.rs:372:26\n    |\n LL |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:373:29\n+  --> $DIR/methods.rs:375:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:385:13\n+  --> $DIR/methods.rs:387:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^"}, {"sha": "c76f4de9b07ab444a29aec630b1e81f4c22fe10d", "filename": "tests/ui/needless_borrowed_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrowed_ref.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -14,12 +14,12 @@ fn main() {\n     let mut var2 = 5;\n     let thingy2 = Some(&mut var2);\n     if let Some(&mut ref mut v) = thingy2 {\n-        //          ^ should *not* be linted\n+        //          ^ should **not** be linted\n         // v is borrowed as mutable.\n         *v = 10;\n     }\n     if let Some(&mut ref v) = thingy2 {\n-        //          ^ should *not* be linted\n+        //          ^ should **not** be linted\n         // here, v is borrowed as immutable.\n         // can't do that:\n         //*v = 15;\n@@ -37,7 +37,7 @@ enum Animal {\n fn foo(a: &Animal, b: &Animal) {\n     match (a, b) {\n         (&Animal::Cat(v), &ref k) | (&ref k, &Animal::Cat(v)) => (), // lifetime mismatch error if there is no '&ref'\n-        //                  ^    and   ^ should *not* be linted\n-        (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should *not* be linted\n+        //                  ^    and   ^ should **not** be linted\n+        (&Animal::Dog(ref a), &Animal::Dog(_)) => (), //              ^ should **not** be linted\n     }\n }"}, {"sha": "3bc0448234ef63ddd0d8593ab69852408610ad81", "filename": "tests/ui/toplevel_ref_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -20,6 +20,6 @@ fn main() {\n \n     let ref mut z = 1 + 2;\n \n-    let (ref x, _) = (1, 2); // okay, not top level\n+    let (ref x, _) = (1, 2); // ok, not top level\n     println!(\"The answer is {}.\", x);\n }"}, {"sha": "27db9594f3b3305c7385ccea3506a22f534740f1", "filename": "tests/ui/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funicode.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -7,13 +7,13 @@ fn zero() {\n #[warn(clippy::unicode_not_nfc)]\n fn canon() {\n     print!(\"\u0300a\u0300h?\");\n-    print!(\"a\\u{0300}h?\"); // also okay\n+    print!(\"a\\u{0300}h?\"); // also ok\n }\n \n #[warn(clippy::non_ascii_literal)]\n fn uni() {\n     print!(\"\u00dcben!\");\n-    print!(\"\\u{DC}ben!\"); // this is okay\n+    print!(\"\\u{DC}ben!\"); // this is ok\n }\n \n fn main() {"}, {"sha": "cd8b3fb33c755049ddb5e31e74cb67729fdc1672", "filename": "tests/ui/update-references.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fupdate-references.sh?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -6,7 +6,7 @@\n # script will then copy that output and replace the \"expected output\"\n # files. You can then commit the changes.\n #\n-# If you find yourself manually editing a foo.stderr file, you're\n+# If you find yourself manually editing a `foo.stderr` file, you're\n # doing it wrong.\n \n if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then"}, {"sha": "550e16a4a2045c6912a0b8b20c3eb57de35c1b77", "filename": "tests/ui/used_underscore_binding.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fused_underscore_binding.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -9,12 +9,12 @@ macro_rules! test_macro {\n     }};\n }\n \n-/// Test that we lint if we use a binding with a single leading underscore\n+/// Tests that we lint if we use a binding with a single leading underscore\n fn prefix_underscore(_foo: u32) -> u32 {\n     _foo + 1\n }\n \n-/// Test that we lint if we use a `_`-variable defined outside within a macro expansion\n+/// Tests that we lint if we use a `_`-variable defined outside within a macro expansion\n fn in_macro(_foo: u32) {\n     println!(\"{}\", _foo);\n     assert_eq!(_foo, _foo);\n@@ -27,23 +27,23 @@ struct StructFieldTest {\n     _underscore_field: u32,\n }\n \n-/// Test that we lint the use of a struct field which is prefixed with an underscore\n+/// Tests that we lint the use of a struct field which is prefixed with an underscore\n fn in_struct_field() {\n     let mut s = StructFieldTest { _underscore_field: 0 };\n     s._underscore_field += 1;\n }\n \n-/// Test that we do not lint if the underscore is not a prefix\n+/// Tests that we do not lint if the underscore is not a prefix\n fn non_prefix_underscore(some_foo: u32) -> u32 {\n     some_foo + 1\n }\n \n-/// Test that we do not lint if we do not use the binding (simple case)\n+/// Tests that we do not lint if we do not use the binding (simple case)\n fn unused_underscore_simple(_foo: u32) -> u32 {\n     1\n }\n \n-/// Test that we do not lint if we do not use the binding (complex case). This checks for\n+/// Tests that we do not lint if we do not use the binding (complex case). This checks for\n /// compatibility with the built-in `unused_variables` lint.\n fn unused_underscore_complex(mut _foo: u32) -> u32 {\n     _foo += 1;\n@@ -64,7 +64,7 @@ enum _EnumTest {\n     _Value(_StructTest),\n }\n \n-/// Test that we do not lint for non-variable bindings\n+/// Tests that we do not lint for non-variable bindings\n fn non_variables() {\n     _fn_test();\n     let _s = _StructTest;"}, {"sha": "ee7f7306a4bf7978d50275ee3080649f3b27ba5f", "filename": "tests/ui/while_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdac4a9c798f8e22a4db220020713175eb9159b/tests%2Fui%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_loop.rs?ref=1cdac4a9c798f8e22a4db220020713175eb9159b", "patch": "@@ -118,7 +118,7 @@ fn main() {\n \n // regression test (#360)\n // this should not panic\n-// it's okay if further iterations of the lint\n+// it's ok if further iterations of the lint\n // cause this function to trigger it\n fn no_panic<T>(slice: &[T]) {\n     let mut iter = slice.iter();"}]}