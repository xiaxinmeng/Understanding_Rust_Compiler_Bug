{"sha": "61e171566a9c97ec41656e96e4dd23261b812b9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZTE3MTU2NmE5Yzk3ZWM0MTY1NmU5NmU0ZGQyMzI2MWI4MTJiOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-26T23:17:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-26T23:17:31Z"}, "message": "Auto merge of #84092 - scottmcm:try_trait_initial, r=yaahc,m-ou-se\n\nAdd the `try_trait_v2` library basics\n\nNo compiler changes as part of this -- just new unstable traits and impls thereof.\n\nThe goal here is to add the things that aren't going to break anything, to keep the feature implementation simpler in the next PR.\n\n(Draft since the FCP won't end until Saturday, but I was feeling optimistic today -- and had forgotten that FCP was 10 days, not 7 days.)", "tree": {"sha": "7f86ad8ceb01bedfba9d5b531c475ca7c17dad71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f86ad8ceb01bedfba9d5b531c475ca7c17dad71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61e171566a9c97ec41656e96e4dd23261b812b9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61e171566a9c97ec41656e96e4dd23261b812b9d", "html_url": "https://github.com/rust-lang/rust/commit/61e171566a9c97ec41656e96e4dd23261b812b9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61e171566a9c97ec41656e96e4dd23261b812b9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9684258936dabda2ba49d4c67f041a6baf388348", "url": "https://api.github.com/repos/rust-lang/rust/commits/9684258936dabda2ba49d4c67f041a6baf388348", "html_url": "https://github.com/rust-lang/rust/commit/9684258936dabda2ba49d4c67f041a6baf388348"}, {"sha": "5671647902e5dc34e2620f7d4b0b1c7b717f514a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5671647902e5dc34e2620f7d4b0b1c7b717f514a", "html_url": "https://github.com/rust-lang/rust/commit/5671647902e5dc34e2620f7d4b0b1c7b717f514a"}], "stats": {"total": 412, "additions": 407, "deletions": 5}, "files": [{"sha": "ecaff053bd5c0ebe49471c176c3ade6b909fdc09", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -1,4 +1,5 @@\n-use crate::ops::Try;\n+use crate::convert;\n+use crate::ops::{self, Try};\n \n /// Used to tell an operation whether it should exit early or go on as usual.\n ///\n@@ -81,6 +82,35 @@ impl<B, C> Try for ControlFlow<B, C> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<B, C> ops::TryV2 for ControlFlow<B, C> {\n+    type Output = C;\n+    type Residual = ControlFlow<B, convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        ControlFlow::Continue(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            ControlFlow::Continue(c) => ControlFlow::Continue(c),\n+            ControlFlow::Break(b) => ControlFlow::Break(ControlFlow::Break(b)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<B, C> ops::FromResidual for ControlFlow<B, C> {\n+    #[inline]\n+    fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {\n+        match residual {\n+            ControlFlow::Break(b) => ControlFlow::Break(b),\n+        }\n+    }\n+}\n+\n impl<B, C> ControlFlow<B, C> {\n     /// Returns `true` if this is a `Break` variant.\n     ///"}, {"sha": "1b07936ccde1dceb2bcbd551a6c2d2952cd080bc", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -148,6 +148,7 @@ mod generator;\n mod index;\n mod range;\n mod r#try;\n+mod try_trait;\n mod unsize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -184,6 +185,12 @@ pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::r#try::Try;\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub use self::try_trait::FromResidual;\n+\n+#[unstable(feature = \"try_trait_transition\", reason = \"for bootstrap\", issue = \"none\")]\n+pub use self::try_trait::Try as TryV2;\n+\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n "}, {"sha": "0c819b000aaab7e590643384b862277b3cb23824", "filename": "library/core/src/ops/try_trait.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -0,0 +1,243 @@\n+use crate::ops::ControlFlow;\n+\n+/// The `?` operator and `try {}` blocks.\n+///\n+/// `try_*` methods typically involve a type implementing this trait.  For\n+/// example, the closures passed to [`Iterator::try_fold`] and\n+/// [`Iterator::try_for_each`] must return such a type.\n+///\n+/// `Try` types are typically those containing two or more categories of values,\n+/// some subset of which are so commonly handled via early returns that it's\n+/// worth providing a terse (but still visible) syntax to make that easy.\n+///\n+/// This is most often seen for error handling with [`Result`] and [`Option`].\n+/// The quintessential implementation of this trait is on [`ControlFlow`].\n+///\n+/// # Using `Try` in Generic Code\n+///\n+/// `Iterator::try_fold` was stabilized to call back in Rust 1.27, but\n+/// this trait is much newer.  To illustrate the various associated types and\n+/// methods, let's implement our own version.\n+///\n+/// As a reminder, an infallible version of a fold looks something like this:\n+/// ```\n+/// fn simple_fold<A, T>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> A,\n+/// ) -> A {\n+///     for x in iter {\n+///         accum = f(accum, x);\n+///     }\n+///     accum\n+/// }\n+/// ```\n+///\n+/// So instead of `f` returning just an `A`, we'll need it to return some other\n+/// type that produces an `A` in the \"don't short circuit\" path.  Conveniently,\n+/// that's also the type we need to return from the function.\n+///\n+/// Let's add a new generic parameter `R` for that type, and bound it to the\n+/// output type that we want:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # use std::ops::TryV2 as Try;\n+/// fn simple_try_fold_1<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     todo!()\n+/// }\n+/// ```\n+///\n+/// If we get through the entire iterator, we need to wrap up the accumulator\n+/// into the return type using [`Try::from_output`]:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # #![feature(control_flow_enum)]\n+/// # use std::ops::{ControlFlow, TryV2 as Try};\n+/// fn simple_try_fold_2<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         let cf = f(accum, x).branch();\n+///         match cf {\n+///             ControlFlow::Continue(a) => accum = a,\n+///             ControlFlow::Break(_) => todo!(),\n+///         }\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+///\n+/// We'll also need [`FromResidual::from_residual`] to turn the residual back\n+/// into the original type.  But because it's a supertrait of `Try`, we don't\n+/// need to mention it in the bounds.  All types which implement `Try` can be\n+/// recreated from their corresponding residual, so we'll just call it:\n+/// ```\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # #![feature(control_flow_enum)]\n+/// # use std::ops::{ControlFlow, TryV2 as Try};\n+/// pub fn simple_try_fold_3<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         let cf = f(accum, x).branch();\n+///         match cf {\n+///             ControlFlow::Continue(a) => accum = a,\n+///             ControlFlow::Break(r) => return R::from_residual(r),\n+///         }\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+///\n+/// But this \"call `branch`, then `match` on it, and `return` if it was a\n+/// `Break`\" is exactly what happens inside the `?` operator.  So rather than\n+/// do all this manually, we can just use `?` instead:\n+/// ```compile_fail (enable again once ? converts to the new trait)\n+/// # #![feature(try_trait_v2)]\n+/// # #![feature(try_trait_transition)]\n+/// # use std::ops::TryV2 as Try;\n+/// fn simple_try_fold<A, T, R: Try<Output = A>>(\n+///     iter: impl Iterator<Item = T>,\n+///     mut accum: A,\n+///     mut f: impl FnMut(A, T) -> R,\n+/// ) -> R {\n+///     for x in iter {\n+///         accum = f(accum, x)?;\n+///     }\n+///     R::from_output(accum)\n+/// }\n+/// ```\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub trait Try: FromResidual {\n+    /// The type of the value produced by `?` when *not* short-circuiting.\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    type Output;\n+\n+    /// The type of the value passed to [`FromResidual::from_residual`]\n+    /// as part of `?` when short-circuiting.\n+    ///\n+    /// This represents the possible values of the `Self` type which are *not*\n+    /// represented by the `Output` type.\n+    ///\n+    /// # Note to Implementors\n+    ///\n+    /// The choice of this type is critical to interconversion.\n+    /// Unlike the `Output` type, which will often be a raw generic type,\n+    /// this type is typically a newtype of some sort to \"color\" the type\n+    /// so that it's distinguishable from the residuals of other types.\n+    ///\n+    /// This is why `Result<T, E>::Residual` is not `E`, but `Result<Infallible, E>`.\n+    /// That way it's distinct from `ControlFlow<E>::Residual`, for example,\n+    /// and thus `?` on `ControlFlow` cannot be used in a method returning `Result`.\n+    ///\n+    /// If you're making a generic type `Foo<T>` that implements `Try<Output = T>`,\n+    /// then typically you can use `Foo<std::convert::Infallible>` as its `Residual`\n+    /// type: that type will have a \"hole\" in the correct place, and will maintain the\n+    /// \"foo-ness\" of the residual so other types need to opt-in to interconversion.\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    type Residual;\n+\n+    /// Constructs the type from its `Output` type.\n+    ///\n+    /// This should be implemented consistently with the `branch` method\n+    /// such that applying the `?` operator will get back the original value:\n+    /// `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// #![feature(try_trait_transition)]\n+    /// use std::ops::TryV2 as Try;\n+    ///\n+    /// assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n+    /// assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n+    /// assert_eq!(\n+    ///     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n+    ///     std::ops::ControlFlow::Continue(5),\n+    /// );\n+    ///\n+    /// # fn make_question_mark_work() -> Option<()> {\n+    /// assert_eq!(Option::from_output(4)?, 4);\n+    /// # None }\n+    /// # make_question_mark_work();\n+    ///\n+    /// // This is used, for example, on the accumulator in `try_fold`:\n+    /// let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n+    /// assert_eq!(r, Some(4));\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn from_output(output: Self::Output) -> Self;\n+\n+    /// Used in `?` to decide whether the operator should produce a value\n+    /// (because this returned [`ControlFlow::Continue`])\n+    /// or propagate a value back to the caller\n+    /// (because this returned [`ControlFlow::Break`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// #![feature(try_trait_transition)]\n+    /// use std::ops::{ControlFlow, TryV2 as Try};\n+    ///\n+    /// assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n+    ///\n+    /// assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n+    ///\n+    /// assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n+    /// assert_eq!(\n+    ///     ControlFlow::<_, String>::Break(3).branch(),\n+    ///     ControlFlow::Break(ControlFlow::Break(3)),\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output>;\n+}\n+\n+/// Used to specify which residuals can be converted into which [`Try`] types.\n+///\n+/// Every `Try` type needs to be recreatable from its own associated\n+/// `Residual` type, but can also have additional `FromResidual` implementations\n+/// to support interconversion with other `Try` types.\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+pub trait FromResidual<R = <Self as Try>::Residual> {\n+    /// Constructs the type from a compatible `Residual` type.\n+    ///\n+    /// This should be implemented consistently with the `branch` method such\n+    /// that applying the `?` operator will get back an equivalent residual:\n+    /// `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n+    /// (It may not be an *identical* residual when interconversion is involved.)\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_trait_v2)]\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::{ControlFlow, FromResidual};\n+    ///\n+    /// assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n+    /// assert_eq!(Option::<String>::from_residual(None), None);\n+    /// assert_eq!(\n+    ///     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n+    ///     ControlFlow::Break(5),\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+    fn from_residual(residual: R) -> Self;\n+}"}, {"sha": "9c527eff4916fba70723dfa6e06029382eda77d9", "filename": "library/core/src/option.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -150,8 +150,8 @@\n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n use crate::pin::Pin;\n use crate::{\n-    hint, mem,\n-    ops::{self, Deref, DerefMut},\n+    convert, hint, mem,\n+    ops::{self, ControlFlow, Deref, DerefMut},\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n@@ -1664,6 +1664,35 @@ impl<T> ops::Try for Option<T> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T> ops::TryV2 for Option<T> {\n+    type Output = T;\n+    type Residual = Option<convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Some(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Some(v) => ControlFlow::Continue(v),\n+            None => ControlFlow::Break(None),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T> ops::FromResidual for Option<T> {\n+    #[inline]\n+    fn from_residual(residual: Option<convert::Infallible>) -> Self {\n+        match residual {\n+            None => None,\n+        }\n+    }\n+}\n+\n impl<T> Option<Option<T>> {\n     /// Converts from `Option<Option<T>>` to `Option<T>`\n     ///"}, {"sha": "bac02104c3488ac4baecefb1d6ac7f21053cce50", "filename": "library/core/src/result.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -228,7 +228,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\n-use crate::ops::{self, Deref, DerefMut};\n+use crate::ops::{self, ControlFlow, Deref, DerefMut};\n use crate::{convert, fmt, hint};\n \n /// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n@@ -1646,3 +1646,32 @@ impl<T, E> ops::Try for Result<T, E> {\n         Err(v)\n     }\n }\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Result<T, E> {\n+    type Output = T;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Ok(output)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(e) => ControlFlow::Break(Err(e)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {\n+    #[inline]\n+    fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n+        match residual {\n+            Err(e) => Err(From::from(e)),\n+        }\n+    }\n+}"}, {"sha": "2765c21a46db11b1e2ad5d142255319d126c8e7c", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61e171566a9c97ec41656e96e4dd23261b812b9d/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=61e171566a9c97ec41656e96e4dd23261b812b9d", "patch": "@@ -1,6 +1,7 @@\n #![stable(feature = \"futures_api\", since = \"1.36.0\")]\n \n-use crate::ops::Try;\n+use crate::convert;\n+use crate::ops::{self, ControlFlow, Try};\n use crate::result::Result;\n \n /// Indicates whether a value is available or if the current task has been\n@@ -152,6 +153,36 @@ impl<T, E> Try for Poll<Result<T, E>> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Poll<Result<T, E>> {\n+    type Output = Poll<T>;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(c: Self::Output) -> Self {\n+        c.map(Ok)\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Poll::Ready(Ok(x)) => ControlFlow::Continue(Poll::Ready(x)),\n+            Poll::Ready(Err(e)) => ControlFlow::Break(Err(e)),\n+            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Poll<Result<T, F>> {\n+    #[inline]\n+    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n+        match x {\n+            Err(e) => Poll::Ready(Err(From::from(e))),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<T, E> Try for Poll<Option<Result<T, E>>> {\n     type Ok = Poll<Option<T>>;\n@@ -177,3 +208,36 @@ impl<T, E> Try for Poll<Option<Result<T, E>>> {\n         x.map(|x| x.map(Ok))\n     }\n }\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E> ops::TryV2 for Poll<Option<Result<T, E>>> {\n+    type Output = Poll<Option<T>>;\n+    type Residual = Result<convert::Infallible, E>;\n+\n+    #[inline]\n+    fn from_output(c: Self::Output) -> Self {\n+        c.map(|x| x.map(Ok))\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self {\n+            Poll::Ready(Some(Ok(x))) => ControlFlow::Continue(Poll::Ready(Some(x))),\n+            Poll::Ready(Some(Err(e))) => ControlFlow::Break(Err(e)),\n+            Poll::Ready(None) => ControlFlow::Continue(Poll::Ready(None)),\n+            Poll::Pending => ControlFlow::Continue(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>>\n+    for Poll<Option<Result<T, F>>>\n+{\n+    #[inline]\n+    fn from_residual(x: Result<convert::Infallible, E>) -> Self {\n+        match x {\n+            Err(e) => Poll::Ready(Some(Err(From::from(e)))),\n+        }\n+    }\n+}"}]}