{"sha": "fdda7e0a33a1aec94966248de4a210d45ead67a6", "node_id": "C_kwDOAAsO6NoAKGZkZGE3ZTBhMzNhMWFlYzk0OTY2MjQ4ZGU0YTIxMGQ0NWVhZDY3YTY", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-09-25T16:40:57Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-09-25T16:40:57Z"}, "message": "more code refactor on smart_resolve_report_errors", "tree": {"sha": "fd81979363a107523497deba3b6ab73d029b6838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd81979363a107523497deba3b6ab73d029b6838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdda7e0a33a1aec94966248de4a210d45ead67a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdda7e0a33a1aec94966248de4a210d45ead67a6", "html_url": "https://github.com/rust-lang/rust/commit/fdda7e0a33a1aec94966248de4a210d45ead67a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdda7e0a33a1aec94966248de4a210d45ead67a6/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7adfb44b95335ce9a565aea1f5f32a3e14119f9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7adfb44b95335ce9a565aea1f5f32a3e14119f9c", "html_url": "https://github.com/rust-lang/rust/commit/7adfb44b95335ce9a565aea1f5f32a3e14119f9c"}], "stats": {"total": 382, "additions": 207, "deletions": 175}, "files": [{"sha": "c82e59ca44f125db2aa31a61c472b9bf4079ca22", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 207, "deletions": 175, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/fdda7e0a33a1aec94966248de4a210d45ead67a6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdda7e0a33a1aec94966248de4a210d45ead67a6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=fdda7e0a33a1aec94966248de4a210d45ead67a6", "patch": "@@ -131,13 +131,13 @@ pub(super) enum LifetimeElisionCandidate {\n }\n \n /// Only used for diagnostics.\n-struct BaseError<'a> {\n+struct BaseError {\n     msg: String,\n     fallback_label: String,\n     span: Span,\n-    span_label: Option<(Span, &'a str)>,\n+    span_label: Option<(Span, &'static str)>,\n     could_be_expr: bool,\n-    suggestion: Option<(Span, &'a str, String)>,\n+    suggestion: Option<(Span, &'static str, String)>,\n }\n \n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n@@ -154,7 +154,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> BaseError<'static> {\n+    ) -> BaseError {\n         // Make the base error.\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n@@ -290,7 +290,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n-        if let Some((span, label)) = base_error.span_label.clone() {\n+        if let Some((span, label)) = base_error.span_label {\n             err.span_label(span, label);\n         }\n \n@@ -303,17 +303,29 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         self.suggest_self_or_self_ref(&mut err, path, span);\n         self.detect_assoct_type_constraint_meant_as_path(&mut err, &base_error);\n-        if self.suggest_self_ty_or_self_value(&mut err, source, path, span) {\n+        if self.suggest_self_ty(&mut err, source, path, span)\n+            || self.suggest_self_value(&mut err, source, path, span)\n+        {\n             return (err, Vec::new());\n         }\n \n         let (found, candidates) =\n-            self.try_lookup_name_with_relex_fashion(&mut err, source, path, span, res, &base_error);\n+            self.try_lookup_name_relaxed(&mut err, source, path, span, res, &base_error);\n         if found {\n             return (err, candidates);\n         }\n \n-        self.suggest_type_ascription(&mut err, source, path, res, span, &base_error);\n+        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n+            let mut fallback =\n+                self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n+            if self.suggest_typo(&mut err, source, path, span, &base_error) {\n+                fallback = true;\n+            }\n+            if fallback {\n+                // Fallback label.\n+                err.span_label(base_error.span, &base_error.fallback_label);\n+            }\n+        }\n         self.err_code_special_cases(&mut err, source, path, span);\n \n         (err, candidates)\n@@ -322,7 +334,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn detect_assoct_type_constraint_meant_as_path(\n         &self,\n         err: &mut Diagnostic,\n-        base_error: &BaseError<'static>,\n+        base_error: &BaseError,\n     ) {\n         let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n         let TyKind::Path(_, path) = &ty.kind else { return; };\n@@ -355,7 +367,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n         let is_assoc_fn = self.self_type_is_available();\n-        let item_str = path.last().unwrap().ident;\n+        let Some(path_last_segment) = path.last() else { return };\n+        let item_str = path_last_segment.ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -392,14 +405,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    fn try_lookup_name_with_relex_fashion(\n+    fn try_lookup_name_relaxed(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n         source: PathSource<'_>,\n         path: &[Segment],\n         span: Span,\n         res: Option<Res>,\n-        base_error: &BaseError<'static>,\n+        base_error: &BaseError,\n     ) -> (bool, Vec<ImportSuggestion>) {\n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n@@ -563,109 +576,114 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         return (false, candidates);\n     }\n \n-    fn suggest_type_ascription(\n+    fn suggest_trait_and_bounds(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n         source: PathSource<'_>,\n-        path: &[Segment],\n         res: Option<Res>,\n         span: Span,\n-        base_error: &BaseError<'static>,\n-    ) {\n+        base_error: &BaseError,\n+    ) -> bool {\n         let is_macro =\n             base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(err, base_error.span) {\n-            let mut fallback = false;\n-            if let (\n-                PathSource::Trait(AliasPossibility::Maybe),\n-                Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n-                false,\n-            ) = (source, res, is_macro)\n-            {\n-                if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n-                    fallback = true;\n-                    let spans: Vec<Span> = bounds\n-                        .iter()\n-                        .map(|bound| bound.span())\n-                        .filter(|&sp| sp != base_error.span)\n-                        .collect();\n+        let mut fallback = false;\n \n-                    let start_span = bounds[0].span();\n-                    // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n-                    let end_span = bounds.last().unwrap().span();\n-                    // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n-                    let last_bound_span = spans.last().cloned().unwrap();\n-                    let mut multi_span: MultiSpan = spans.clone().into();\n-                    for sp in spans {\n-                        let msg = if sp == last_bound_span {\n-                            format!(\n-                                \"...because of {these} bound{s}\",\n-                                these = pluralize!(\"this\", bounds.len() - 1),\n-                                s = pluralize!(bounds.len() - 1),\n-                            )\n-                        } else {\n-                            String::new()\n-                        };\n-                        multi_span.push_span_label(sp, msg);\n-                    }\n-                    multi_span\n-                        .push_span_label(base_error.span, \"expected this type to be a trait...\");\n-                    err.span_help(\n-                        multi_span,\n-                        \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n-                         auto-traits; structs and enums can't be bound in that way\",\n-                    );\n-                    if bounds.iter().all(|bound| match bound {\n-                        ast::GenericBound::Outlives(_) => true,\n-                        ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n-                    }) {\n-                        let mut sugg = vec![];\n-                        if base_error.span != start_span {\n-                            sugg.push((start_span.until(base_error.span), String::new()));\n-                        }\n-                        if base_error.span != end_span {\n-                            sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n-                        }\n+        if let (\n+            PathSource::Trait(AliasPossibility::Maybe),\n+            Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n+            false,\n+        ) = (source, res, is_macro)\n+        {\n+            if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n+                fallback = true;\n+                let spans: Vec<Span> = bounds\n+                    .iter()\n+                    .map(|bound| bound.span())\n+                    .filter(|&sp| sp != base_error.span)\n+                    .collect();\n \n-                        err.multipart_suggestion(\n-                            \"if you meant to use a type and not a trait here, remove the bounds\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                let start_span = bounds[0].span();\n+                // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n+                let end_span = bounds.last().unwrap().span();\n+                // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n+                let last_bound_span = spans.last().cloned().unwrap();\n+                let mut multi_span: MultiSpan = spans.clone().into();\n+                for sp in spans {\n+                    let msg = if sp == last_bound_span {\n+                        format!(\n+                            \"...because of {these} bound{s}\",\n+                            these = pluralize!(\"this\", bounds.len() - 1),\n+                            s = pluralize!(bounds.len() - 1),\n+                        )\n+                    } else {\n+                        String::new()\n+                    };\n+                    multi_span.push_span_label(sp, msg);\n+                }\n+                multi_span.push_span_label(base_error.span, \"expected this type to be a trait...\");\n+                err.span_help(\n+                    multi_span,\n+                    \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n+                        auto-traits; structs and enums can't be bound in that way\",\n+                );\n+                if bounds.iter().all(|bound| match bound {\n+                    ast::GenericBound::Outlives(_) => true,\n+                    ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n+                }) {\n+                    let mut sugg = vec![];\n+                    if base_error.span != start_span {\n+                        sugg.push((start_span.until(base_error.span), String::new()));\n+                    }\n+                    if base_error.span != end_span {\n+                        sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n                     }\n+\n+                    err.multipart_suggestion(\n+                        \"if you meant to use a type and not a trait here, remove the bounds\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n+        }\n \n-            let is_expected = &|res| source.is_expected(res);\n-            let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-            fallback |= self.restrict_assoc_type_in_where_clause(span, err);\n+        fallback |= self.restrict_assoc_type_in_where_clause(span, err);\n+        fallback\n+    }\n \n-            let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n-            if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n-                fallback = true;\n-                match self.diagnostic_metadata.current_let_binding {\n-                    Some((pat_sp, Some(ty_sp), None))\n-                        if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n-                    {\n-                        err.span_suggestion_short(\n-                            pat_sp.between(ty_sp),\n-                            \"use `=` if you meant to assign\",\n-                            \" = \",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n+    fn suggest_typo(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        base_error: &BaseError,\n+    ) -> bool {\n+        let is_expected = &|res| source.is_expected(res);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+        let mut fallback = false;\n+        if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n+            fallback = true;\n+            match self.diagnostic_metadata.current_let_binding {\n+                Some((pat_sp, Some(ty_sp), None))\n+                    if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n+                {\n+                    err.span_suggestion_short(\n+                        pat_sp.between(ty_sp),\n+                        \"use `=` if you meant to assign\",\n+                        \" = \",\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-\n-                // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n-                let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-                self.r.add_typo_suggestion(err, suggestion, ident_span);\n-            }\n-            if fallback {\n-                // Fallback label.\n-                err.span_label(base_error.span, &base_error.fallback_label);\n+                _ => {}\n             }\n+\n+            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n+            self.r.add_typo_suggestion(err, suggestion, ident_span);\n         }\n+        fallback\n     }\n \n     fn err_code_special_cases(\n@@ -713,103 +731,113 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     }\n \n     /// Emit special messages for unresolved `Self` and `self`.\n-    fn suggest_self_ty_or_self_value(\n+    fn suggest_self_ty(\n         &mut self,\n         err: &mut Diagnostic,\n         source: PathSource<'_>,\n         path: &[Segment],\n         span: Span,\n     ) -> bool {\n-        if is_self_type(path, source.namespace()) {\n-            err.code(rustc_errors::error_code!(E0411));\n+        if !is_self_type(path, source.namespace()) {\n+            return false;\n+        }\n+        err.code(rustc_errors::error_code!(E0411));\n+        err.span_label(\n+            span,\n+            \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+        );\n+        if let Some(item_kind) = self.diagnostic_metadata.current_item {\n             err.span_label(\n-                span,\n-                \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+                item_kind.ident.span,\n+                format!(\n+                    \"`Self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n             );\n-            if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`Self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return true;\n         }\n+        true\n+    }\n \n-        if is_self_value(path, source.namespace()) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-            err.code(rustc_errors::error_code!(E0424));\n-            err.span_label(\n+    fn suggest_self_value(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if !is_self_value(path, source.namespace()) {\n+            return false;\n+        }\n+\n+        debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+        err.code(rustc_errors::error_code!(E0424));\n+        err.span_label(\n             span,\n             match source {\n                 PathSource::Pat => {\n                     \"`self` value is a keyword and may not be bound to variables or shadowed\"\n                 }\n                 _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n             },\n-            );\n-            let is_assoc_fn = self.self_type_is_available();\n-            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-                // The current function has a `self' parameter, but we were unable to resolve\n-                // a reference to `self`. This can only happen if the `self` identifier we\n-                // are resolving came from a different hygiene context.\n-                if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n-                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+        );\n+        let is_assoc_fn = self.self_type_is_available();\n+        if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n+            // The current function has a `self' parameter, but we were unable to resolve\n+            // a reference to `self`. This can only happen if the `self` identifier we\n+            // are resolving came from a different hygiene context.\n+            if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+                err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+            } else {\n+                let doesnt = if is_assoc_fn {\n+                    let (span, sugg) = fn_kind\n+                        .decl()\n+                        .inputs\n+                        .get(0)\n+                        .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                        .unwrap_or_else(|| {\n+                            // Try to look for the \"(\" after the function name, if possible.\n+                            // This avoids placing the suggestion into the visibility specifier.\n+                            let span = fn_kind\n+                                .ident()\n+                                .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n+                            (\n+                                self.r\n+                                    .session\n+                                    .source_map()\n+                                    .span_through_char(span, '(')\n+                                    .shrink_to_hi(),\n+                                \"&self\",\n+                            )\n+                        });\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    \"doesn't\"\n                 } else {\n-                    let doesnt = if is_assoc_fn {\n-                        let (span, sugg) = fn_kind\n-                            .decl()\n-                            .inputs\n-                            .get(0)\n-                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n-                            .unwrap_or_else(|| {\n-                                // Try to look for the \"(\" after the function name, if possible.\n-                                // This avoids placing the suggestion into the visibility specifier.\n-                                let span = fn_kind\n-                                    .ident()\n-                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n-                                (\n-                                    self.r\n-                                        .session\n-                                        .source_map()\n-                                        .span_through_char(span, '(')\n-                                        .shrink_to_hi(),\n-                                    \"&self\",\n-                                )\n-                            });\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        \"doesn't\"\n-                    } else {\n-                        \"can't\"\n-                    };\n-                    if let Some(ident) = fn_kind.ident() {\n-                        err.span_label(\n-                            ident.span,\n-                            &format!(\"this function {} have a `self` parameter\", doesnt),\n-                        );\n-                    }\n+                    \"can't\"\n+                };\n+                if let Some(ident) = fn_kind.ident() {\n+                    err.span_label(\n+                        ident.span,\n+                        &format!(\"this function {} have a `self` parameter\", doesnt),\n+                    );\n                 }\n-            } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n             }\n-            return true;\n+        } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+            err.span_label(\n+                item_kind.ident.span,\n+                format!(\n+                    \"`self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n+            );\n         }\n-        false\n+        true\n     }\n \n     fn suggest_swapping_misplaced_self_ty_and_trait(\n@@ -861,7 +889,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         span: Span,\n     ) {\n         if let PathSource::Expr(_) = source &&\n-        let Some(Expr { span: expr_span, kind: ExprKind::Assign(lhs, _, _), .. } ) = self.diagnostic_metadata.in_if_condition {\n+        let Some(Expr {\n+                    span: expr_span,\n+                    kind: ExprKind::Assign(lhs, _, _),\n+                    ..\n+                })  = self.diagnostic_metadata.in_if_condition {\n             // Icky heuristic so we don't suggest:\n             // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n             // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)"}]}