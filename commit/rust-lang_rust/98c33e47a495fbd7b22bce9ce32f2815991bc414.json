{"sha": "98c33e47a495fbd7b22bce9ce32f2815991bc414", "node_id": "C_kwDOAAsO6NoAKDk4YzMzZTQ3YTQ5NWZiZDdiMjJiY2U5Y2UzMmYyODE1OTkxYmM0MTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T09:41:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-02T09:41:35Z"}, "message": "Auto merge of #109128 - chenyukang:yukang/remove-type-ascription, r=estebank\n\nRemove type ascription from parser and diagnostics\n\nMostly based on https://github.com/rust-lang/rust/pull/106826\n\nPart of #101728\n\nr? `@estebank`", "tree": {"sha": "5a29fad853f7fe163f7d7c70e31d0993039da2eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a29fad853f7fe163f7d7c70e31d0993039da2eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c33e47a495fbd7b22bce9ce32f2815991bc414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c33e47a495fbd7b22bce9ce32f2815991bc414", "html_url": "https://github.com/rust-lang/rust/commit/98c33e47a495fbd7b22bce9ce32f2815991bc414", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c33e47a495fbd7b22bce9ce32f2815991bc414/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b99493492ad59c7a44c65373558175db42b4151", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b99493492ad59c7a44c65373558175db42b4151", "html_url": "https://github.com/rust-lang/rust/commit/7b99493492ad59c7a44c65373558175db42b4151"}, {"sha": "5d1796a608d387be784f17c28ec7c81f178a81eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1796a608d387be784f17c28ec7c81f178a81eb", "html_url": "https://github.com/rust-lang/rust/commit/5d1796a608d387be784f17c28ec7c81f178a81eb"}], "stats": {"total": 1892, "additions": 752, "deletions": 1140}, "files": [{"sha": "dce7106d1280462460ac30686e01eeae4f8f0735", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1589,7 +1589,6 @@ pub enum ClosureBinder {\n pub struct MacCall {\n     pub path: Path,\n     pub args: P<DelimArgs>,\n-    pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n impl MacCall {"}, {"sha": "66b94d12a32c6c11933eaf9e209a298694f187a2", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -631,7 +631,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n-    let MacCall { path, args, prior_type_ascription: _ } = mac;\n+    let MacCall { path, args } = mac;\n     vis.visit_path(path);\n     visit_delim_args(args, vis);\n }"}, {"sha": "35afd5423721d980a2c57f438cefcd745f512040", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -53,8 +53,6 @@ pub enum AssocOp {\n     DotDot,\n     /// `..=` range\n     DotDotEq,\n-    /// `:`\n-    Colon,\n }\n \n #[derive(PartialEq, Debug)]\n@@ -96,7 +94,6 @@ impl AssocOp {\n             token::DotDotEq => Some(DotDotEq),\n             // DotDotDot is no longer supported, but we need some way to display the error\n             token::DotDotDot => Some(DotDotEq),\n-            token::Colon => Some(Colon),\n             // `<-` should probably be `< -`\n             token::LArrow => Some(Less),\n             _ if t.is_keyword(kw::As) => Some(As),\n@@ -133,7 +130,7 @@ impl AssocOp {\n     pub fn precedence(&self) -> usize {\n         use AssocOp::*;\n         match *self {\n-            As | Colon => 14,\n+            As => 14,\n             Multiply | Divide | Modulus => 13,\n             Add | Subtract => 12,\n             ShiftLeft | ShiftRight => 11,\n@@ -156,7 +153,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => Fixity::Right,\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd\n             | BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual\n-            | LAnd | LOr | Colon => Fixity::Left,\n+            | LAnd | LOr => Fixity::Left,\n             DotDot | DotDotEq => Fixity::None,\n         }\n     }\n@@ -166,8 +163,9 @@ impl AssocOp {\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract\n-            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq\n-            | Colon => false,\n+            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq => {\n+                false\n+            }\n         }\n     }\n \n@@ -177,7 +175,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply\n             | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor\n-            | BitOr | LAnd | LOr | DotDot | DotDotEq | Colon => false,\n+            | BitOr | LAnd | LOr | DotDot | DotDotEq => false,\n         }\n     }\n \n@@ -202,7 +200,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None,\n+            Assign | AssignOp(_) | As | DotDot | DotDotEq => None,\n         }\n     }\n \n@@ -223,10 +221,9 @@ impl AssocOp {\n             Greater | // `{ 42 } > 3`\n             GreaterEqual | // `{ 42 } >= 3`\n             AssignOp(_) | // `{ 42 } +=`\n-            As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n-            Colon, // `{ 42 }: usize`\n+            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            As // `{ 42 } as usize`\n         )\n     }\n }\n@@ -254,7 +251,6 @@ pub enum ExprPrecedence {\n     Binary(BinOpKind),\n \n     Cast,\n-    Type,\n \n     Assign,\n     AssignOp,\n@@ -313,7 +309,6 @@ impl ExprPrecedence {\n             // Binop-like expr kinds, handled by `AssocOp`.\n             ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n             ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n-            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n \n             ExprPrecedence::Assign |\n             ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,"}, {"sha": "b74c59bca30c5022c90d8ca148c0d75f66b4a259", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -341,10 +341,16 @@ impl<'a> State<'a> {\n                 self.print_type(ty);\n             }\n             ast::ExprKind::Type(expr, ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n+                self.word(\"type_ascribe!(\");\n+                self.ibox(0);\n+                self.print_expr(expr);\n+\n+                self.word(\",\");\n+                self.space_if_not_bol();\n                 self.print_type(ty);\n+\n+                self.end();\n+                self.word(\")\");\n             }\n             ast::ExprKind::Let(pat, scrutinee, _) => {\n                 self.print_let(pat, scrutinee);"}, {"sha": "0ea8454db0893667246414d25882c5747b55fc58", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -68,9 +68,7 @@ pub fn parse_asm_args<'a>(\n         if !p.eat(&token::Comma) {\n             if allow_templates {\n                 // After a template string, we always expect *only* a comma...\n-                let mut err = diag.create_err(errors::AsmExpectedComma { span: p.token.span });\n-                p.maybe_annotate_with_ascription(&mut err, false);\n-                return Err(err);\n+                return Err(diag.create_err(errors::AsmExpectedComma { span: p.token.span }));\n             } else {\n                 // ...after that delegate to `expect` to also include the other expected tokens.\n                 return Err(p.expect(&token::Comma).err().unwrap());"}, {"sha": "ab4ea9c8c20525ff7c3a989a63bcc4520c7c689f", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -61,7 +61,6 @@ pub fn expand_assert<'cx>(\n                     delim: MacDelimiter::Parenthesis,\n                     tokens,\n                 }),\n-                prior_type_ascription: None,\n             })),\n         );\n         expr_if_not(cx, call_site_span, cond_expr, then, None)"}, {"sha": "ea830a0ce60dfba2edce4bdf7737188d4e214ec3", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -182,7 +182,6 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     delim: MacDelimiter::Parenthesis,\n                     tokens: initial.into_iter().chain(captures).collect::<TokenStream>(),\n                 }),\n-                prior_type_ascription: None,\n             })),\n         )\n     }"}, {"sha": "ef0db23ff2f2d8cb15e4e3954bed4d27c27bd0e5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -63,7 +63,6 @@ fn expand<'cx>(\n                     delim: MacDelimiter::Parenthesis,\n                     tokens: tts,\n                 }),\n-                prior_type_ascription: None,\n             })),\n         ),\n     )"}, {"sha": "2345cc5223b538e44d85f1d6e6d017abfa92d262", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -992,7 +992,6 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub dir_ownership: DirOwnership,\n-    pub prior_type_ascription: Option<(Span, bool)>,\n     /// Some parent node that is close to this macro call\n     pub lint_node_id: NodeId,\n     pub is_trailing_mac: bool,\n@@ -1043,7 +1042,6 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 module: Default::default(),\n                 dir_ownership: DirOwnership::Owned { relative: None },\n-                prior_type_ascription: None,\n                 lint_node_id: ast::CRATE_NODE_ID,\n                 is_trailing_mac: false,\n             },"}, {"sha": "28539d46ba1034c4571472719759e4f11f56e64f", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -657,16 +657,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n-                    let prev = self.cx.current_expansion.prior_type_ascription;\n-                    self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n                     let tok_result = expander.expand(self.cx, span, mac.args.tokens.clone());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n                         self.error_wrong_fragment_kind(fragment_kind, &mac, span);\n                         fragment_kind.dummy(span)\n                     };\n-                    self.cx.current_expansion.prior_type_ascription = prev;\n                     result\n                 }\n                 _ => unreachable!(),"}, {"sha": "ccfee935901cd0d3d376e6c30e00a56affac0303", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -250,8 +250,7 @@ fn expand_macro<'cx>(\n                 trace_macros_note(&mut cx.expansions, sp, msg);\n             }\n \n-            let mut p = Parser::new(sess, tts, false, None);\n-            p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+            let p = Parser::new(sess, tts, false, None);\n \n             if is_local {\n                 cx.resolver.record_macro_rule_usage(node_id, i);"}, {"sha": "e9af688ee2b61004e24d89ebaf26cf0cc6a85053", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -21,7 +21,6 @@ pub fn placeholder(\n                 delim: ast::MacDelimiter::Parenthesis,\n                 tokens: ast::tokenstream::TokenStream::new(Vec::new()),\n             }),\n-            prior_type_ascription: None,\n         })\n     }\n "}, {"sha": "d93e8efc1b59ad2d0f344fc064babfde819a91b6", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1407,10 +1407,16 @@ impl<'a> State<'a> {\n                 self.print_type(ty);\n             }\n             hir::ExprKind::Type(expr, ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n+                self.word(\"type_ascribe!(\");\n+                self.ibox(0);\n+                self.print_expr(expr);\n+\n+                self.word(\",\");\n+                self.space_if_not_bol();\n                 self.print_type(ty);\n+\n+                self.end();\n+                self.word(\")\");\n             }\n             hir::ExprKind::DropTemps(init) => {\n                 // Print `{`:"}, {"sha": "f229b10c44767162c0f0519c8da071a7c0d2e9b6", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -685,10 +685,9 @@ enum ArmType {\n /// For example, if we are constructing a witness for the match against\n ///\n /// ```compile_fail,E0004\n-/// # #![feature(type_ascription)]\n /// struct Pair(Option<(u32, u32)>, bool);\n /// # fn foo(p: Pair) {\n-/// match (p: Pair) {\n+/// match p {\n ///    Pair(None, _) => {}\n ///    Pair(_, false) => {}\n /// }"}, {"sha": "9a5232b1bcdd9eb903cc66f218c751251cedd06b", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -420,6 +420,15 @@ parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of\n parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n     .suggestion = use `Fn` to refer to the trait\n \n+parse_path_single_colon = path separator must be a double colon\n+    .suggestion = use a double colon instead\n+\n+parse_colon_as_semi = statements are terminated with a semicolon\n+    .suggestion = use a semicolon instead\n+\n+parse_type_ascription_removed =\n+    if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n     .label = unexpected where clause\n     .name_label = while parsing this tuple struct"}, {"sha": "b445ccc7ad0aabc34727cd4da4d8effc5648b2d0", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1340,6 +1340,28 @@ pub(crate) struct ExpectedFnPathFoundFnKeyword {\n     pub fn_token_span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_path_single_colon)]\n+pub(crate) struct PathSingleColon {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"::\")]\n+    pub span: Span,\n+\n+    #[note(parse_type_ascription_removed)]\n+    pub type_ascription: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_colon_as_semi)]\n+pub(crate) struct ColonAsSemi {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \";\")]\n+    pub span: Span,\n+\n+    #[note(parse_type_ascription_removed)]\n+    pub type_ascription: Option<()>,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_where_clause_before_tuple_struct_body)]\n pub(crate) struct WhereClauseBeforeTupleStructBody {"}, {"sha": "638a432cea5f1700bfaab6728706001a4bbb4fa8", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 75, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -4,7 +4,7 @@ use super::{\n     TokenExpectType, TokenType,\n };\n use crate::errors::{\n-    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n+    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub, ColonAsSemi,\n     ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n     ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentDoesNotDocumentAnything,\n     DocCommentOnParamType, DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n@@ -84,6 +84,7 @@ impl RecoverQPath for Ty {\n }\n \n impl RecoverQPath for Pat {\n+    const PATH_STYLE: PathStyle = PathStyle::Pat;\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n@@ -663,7 +664,6 @@ impl<'a> Parser<'a> {\n             err.span_label(sp, label_exp);\n             err.span_label(self.token.span, \"unexpected token\");\n         }\n-        self.maybe_annotate_with_ascription(&mut err, false);\n         Err(err)\n     }\n \n@@ -788,59 +788,6 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    pub fn maybe_annotate_with_ascription(\n-        &mut self,\n-        err: &mut Diagnostic,\n-        maybe_expected_semicolon: bool,\n-    ) {\n-        if let Some((sp, likely_path)) = self.last_type_ascription.take() {\n-            let sm = self.sess.source_map();\n-            let next_pos = sm.lookup_char_pos(self.token.span.lo());\n-            let op_pos = sm.lookup_char_pos(sp.hi());\n-\n-            let allow_unstable = self.sess.unstable_features.is_nightly_build();\n-\n-            if likely_path {\n-                err.span_suggestion(\n-                    sp,\n-                    \"maybe write a path separator here\",\n-                    \"::\",\n-                    if allow_unstable {\n-                        Applicability::MaybeIncorrect\n-                    } else {\n-                        Applicability::MachineApplicable\n-                    },\n-                );\n-                self.sess.type_ascription_path_suggestions.borrow_mut().insert(sp);\n-            } else if op_pos.line != next_pos.line && maybe_expected_semicolon {\n-                err.span_suggestion(\n-                    sp,\n-                    \"try using a semicolon\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else if allow_unstable {\n-                err.span_label(sp, \"tried to parse a type due to this type ascription\");\n-            } else {\n-                err.span_label(sp, \"tried to parse a type due to this\");\n-            }\n-            if allow_unstable {\n-                // Give extra information about type ascription only if it's a nightly compiler.\n-                err.note(\n-                    \"`#![feature(type_ascription)]` lets you annotate an expression with a type: \\\n-                     `<expr>: <type>`\",\n-                );\n-                if !likely_path {\n-                    // Avoid giving too much info when it was likely an unrelated typo.\n-                    err.note(\n-                        \"see issue #23416 <https://github.com/rust-lang/rust/issues/23416> \\\n-                        for more information\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     pub(super) fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n@@ -1622,12 +1569,36 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn expect_semi(&mut self) -> PResult<'a, ()> {\n-        if self.eat(&token::Semi) {\n+        if self.eat(&token::Semi) || self.recover_colon_as_semi() {\n             return Ok(());\n         }\n         self.expect(&token::Semi).map(drop) // Error unconditionally\n     }\n \n+    pub(super) fn recover_colon_as_semi(&mut self) -> bool {\n+        let line_idx = |span: Span| {\n+            self.sess\n+                .source_map()\n+                .span_to_lines(span)\n+                .ok()\n+                .and_then(|lines| Some(lines.lines.get(0)?.line_index))\n+        };\n+\n+        if self.may_recover()\n+            && self.token == token::Colon\n+            && self.look_ahead(1, |next| line_idx(self.token.span) < line_idx(next.span))\n+        {\n+            self.sess.emit_err(ColonAsSemi {\n+                span: self.token.span,\n+                type_ascription: self.sess.unstable_features.is_nightly_build().then_some(()),\n+            });\n+            self.bump();\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n     /// Consumes alternative await syntaxes like `await!(<expr>)`, `await <expr>`,\n     /// `await? <expr>`, `await(<expr>)`, and `await { <expr> }`.\n     pub(super) fn recover_incorrect_await_syntax(\n@@ -1790,24 +1761,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        (self.token == token::Lt && // `foo:<bar`, likely a typoed turbofish.\n-            self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident()))\n-            || self.token.is_ident() &&\n-            matches!(node, ast::ExprKind::Path(..) | ast::ExprKind::Field(..)) &&\n-            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Parenthesis))\n-            || self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Brace)) // `foo:bar {`\n-            || self.look_ahead(1, |t| t == &token::Colon) &&     // `foo:bar::<baz`\n-            self.look_ahead(2, |t| t == &token::Lt) &&\n-            self.look_ahead(3, |t| t.is_ident())\n-            || self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n-            self.look_ahead(2, |t| t.is_ident())\n-            || self.look_ahead(1, |t| t == &token::ModSep)\n-                && (self.look_ahead(2, |t| t.is_ident()) ||   // `foo:bar::baz`\n-            self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n-    }\n-\n     pub(super) fn recover_seq_parse_error(\n         &mut self,\n         delim: Delimiter,\n@@ -1902,7 +1855,6 @@ impl<'a> Parser<'a> {\n                         && brace_depth == 0\n                         && bracket_depth == 0 =>\n                 {\n-                    debug!(\"recover_stmt_ return - Semi\");\n                     break;\n                 }\n                 _ => self.bump(),"}, {"sha": "02db4b095dcd16fb1cf3e6c9a5f27b886cb125ee", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 22, "deletions": 68, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -174,10 +174,8 @@ impl<'a> Parser<'a> {\n                 self.parse_expr_prefix(attrs)?\n             }\n         };\n-        let last_type_ascription_set = self.last_type_ascription.is_some();\n \n         if !self.should_continue_as_assoc_expr(&lhs) {\n-            self.last_type_ascription = None;\n             return Ok(lhs);\n         }\n \n@@ -301,9 +299,6 @@ impl<'a> Parser<'a> {\n             if op == AssocOp::As {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue;\n-            } else if op == AssocOp::Colon {\n-                lhs = self.parse_assoc_op_ascribe(lhs, lhs_span)?;\n-                continue;\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn't have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n@@ -364,7 +359,7 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(span, aopexpr)\n                 }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                AssocOp::As | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.span_bug(span, \"AssocOp should have been handled by special case\")\n                 }\n             };\n@@ -373,9 +368,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        if last_type_ascription_set {\n-            self.last_type_ascription = None;\n-        }\n+\n         Ok(lhs)\n     }\n \n@@ -743,7 +736,7 @@ impl<'a> Parser<'a> {\n                     (\n                         // `foo: `\n                         ExprKind::Path(None, ast::Path { segments, .. }),\n-                        TokenKind::Ident(kw::For | kw::Loop | kw::While, false),\n+                        token::Ident(kw::For | kw::Loop | kw::While, false),\n                     ) if segments.len() == 1 => {\n                         let snapshot = self.create_snapshot_for_diagnostic();\n                         let label = Label {\n@@ -838,21 +831,19 @@ impl<'a> Parser<'a> {\n         &mut self,\n         cast_expr: P<Expr>,\n     ) -> PResult<'a, P<Expr>> {\n+        if let ExprKind::Type(_, _) = cast_expr.kind {\n+            panic!(\"ExprKind::Type must not be parsed\");\n+        }\n+\n         let span = cast_expr.span;\n-        let (cast_kind, maybe_ascription_span) =\n-            if let ExprKind::Type(ascripted_expr, _) = &cast_expr.kind {\n-                (\"type ascription\", Some(ascripted_expr.span.shrink_to_hi().with_hi(span.hi())))\n-            } else {\n-                (\"cast\", None)\n-            };\n \n         let with_postfix = self.parse_expr_dot_or_call_with_(cast_expr, span)?;\n \n         // Check if an illegal postfix operator has been added after the cast.\n         // If the resulting expression is not a cast, it is an illegal postfix operator.\n-        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) {\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _)) {\n             let msg = format!(\n-                \"{cast_kind} cannot be followed by {}\",\n+                \"cast cannot be followed by {}\",\n                 match with_postfix.kind {\n                     ExprKind::Index(_, _) => \"indexing\",\n                     ExprKind::Try(_) => \"`?`\",\n@@ -878,44 +869,13 @@ impl<'a> Parser<'a> {\n                 );\n             };\n \n-            // If type ascription is \"likely an error\", the user will already be getting a useful\n-            // help message, and doesn't need a second.\n-            if self.last_type_ascription.map_or(false, |last_ascription| last_ascription.1) {\n-                self.maybe_annotate_with_ascription(&mut err, false);\n-            } else if let Some(ascription_span) = maybe_ascription_span {\n-                let is_nightly = self.sess.unstable_features.is_nightly_build();\n-                if is_nightly {\n-                    suggest_parens(&mut err);\n-                }\n-                err.span_suggestion(\n-                    ascription_span,\n-                    &format!(\n-                        \"{}remove the type ascription\",\n-                        if is_nightly { \"alternatively, \" } else { \"\" }\n-                    ),\n-                    \"\",\n-                    if is_nightly {\n-                        Applicability::MaybeIncorrect\n-                    } else {\n-                        Applicability::MachineApplicable\n-                    },\n-                );\n-            } else {\n-                suggest_parens(&mut err);\n-            }\n+            suggest_parens(&mut err);\n+\n             err.emit();\n         };\n         Ok(with_postfix)\n     }\n \n-    fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n-        let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-        self.last_type_ascription = Some((self.prev_token.span, maybe_path));\n-        let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-        self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n-        Ok(lhs)\n-    }\n-\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n     fn parse_expr_borrow(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n@@ -1010,7 +970,7 @@ impl<'a> Parser<'a> {\n             };\n             if has_dot {\n                 // expr.f\n-                e = self.parse_expr_dot_suffix(lo, e)?;\n+                e = self.parse_dot_suffix_expr(lo, e)?;\n                 continue;\n             }\n             if self.expr_is_complete(&e) {\n@@ -1024,13 +984,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn look_ahead_type_ascription_as_field(&mut self) -> bool {\n-        self.look_ahead(1, |t| t.is_ident())\n-            && self.look_ahead(2, |t| t == &token::Colon)\n-            && self.look_ahead(3, |t| t.can_begin_expr())\n-    }\n-\n-    fn parse_expr_dot_suffix(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         match self.token.uninterpolate().kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n@@ -1183,9 +1137,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function call expression, `expr(...)`.\n     fn parse_expr_fn_call(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n-        let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n-            && self.look_ahead_type_ascription_as_field()\n-        {\n+        let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis) {\n             Some((self.create_snapshot_for_diagnostic(), fun.kind.clone()))\n         } else {\n             None\n@@ -1216,7 +1168,6 @@ impl<'a> Parser<'a> {\n         if !self.may_recover() {\n             return None;\n         }\n-\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 snapshot.bump(); // `(`\n@@ -1260,9 +1211,7 @@ impl<'a> Parser<'a> {\n                         return Some(self.mk_expr_err(span));\n                     }\n                     Ok(_) => {}\n-                    Err(mut err) => {\n-                        err.emit();\n-                    }\n+                    Err(err) => err.cancel(),\n                 }\n             }\n             _ => {}\n@@ -1516,7 +1465,6 @@ impl<'a> Parser<'a> {\n             let mac = P(MacCall {\n                 path,\n                 args: self.parse_delim_args()?,\n-                prior_type_ascription: self.last_type_ascription,\n             });\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))\n         } else if self.check(&token::OpenDelim(Delimiter::Brace))\n@@ -1535,7 +1483,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_expr_labeled(\n+    pub(super) fn parse_expr_labeled(\n         &mut self,\n         label_: Label,\n         mut consume_colon: bool,\n@@ -3013,6 +2961,11 @@ impl<'a> Parser<'a> {\n                     } else {\n                         e.span_label(pth.span, \"while parsing this struct\");\n                     }\n+\n+                    if !recover {\n+                        return Err(e);\n+                    }\n+\n                     e.emit();\n \n                     // If the next token is a comma, then try to parse\n@@ -3024,6 +2977,7 @@ impl<'a> Parser<'a> {\n                             break;\n                         }\n                     }\n+\n                     None\n                 }\n             };"}, {"sha": "64ff7f1fb2c10c96909baf9cb819d12f313d7050", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -443,7 +443,7 @@ impl<'a> Parser<'a> {\n             Ok(args) => {\n                 self.eat_semi_for_macro_if_needed(&args);\n                 self.complain_if_pub_macro(vis, false);\n-                Ok(MacCall { path, args, prior_type_ascription: self.last_type_ascription })\n+                Ok(MacCall { path, args })\n             }\n \n             Err(mut err) => {"}, {"sha": "b294e13402abc20f938d3a17101f86403b1b5a05", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -148,9 +148,6 @@ pub struct Parser<'a> {\n     max_angle_bracket_count: u32,\n \n     last_unexpected_token_span: Option<Span>,\n-    /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n-    /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n-    pub last_type_ascription: Option<(Span, bool /* likely path typo */)>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     subparser_name: Option<&'static str>,\n     capture_state: CaptureState,\n@@ -165,7 +162,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 288);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 272);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -470,7 +467,6 @@ impl<'a> Parser<'a> {\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n             last_unexpected_token_span: None,\n-            last_type_ascription: None,\n             subparser_name,\n             capture_state: CaptureState {\n                 capturing: Capturing::No,\n@@ -941,10 +937,14 @@ impl<'a> Parser<'a> {\n                                         // propagate the help message from sub error 'e' to main error 'expect_err;\n                                         expect_err.children.push(xx.clone());\n                                     }\n-                                    expect_err.emit();\n-\n                                     e.cancel();\n-                                    break;\n+                                    if self.token == token::Colon {\n+                                        // we will try to recover in `maybe_recover_struct_lit_bad_delims`\n+                                        return Err(expect_err);\n+                                    } else {\n+                                        expect_err.emit();\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }"}, {"sha": "3c4b2977af93ab72785fca258e1532833ce1b6fa", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -406,11 +406,11 @@ impl<'a> Parser<'a> {\n             // Parse pattern starting with a path\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Pat)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(PathStyle::Expr)?)\n+                (None, self.parse_path(PathStyle::Pat)?)\n             };\n             let span = lo.to(self.prev_token.span);\n \n@@ -666,7 +666,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n         let args = self.parse_delim_args()?;\n-        let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n+        let mac = P(MacCall { path, args });\n         Ok(PatKind::MacCall(mac))\n     }\n \n@@ -789,11 +789,11 @@ impl<'a> Parser<'a> {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Pat)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(PathStyle::Expr)?)\n+                (None, self.parse_path(PathStyle::Pat)?)\n             };\n             let hi = self.prev_token.span;\n             Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path)))"}, {"sha": "b9a2b141bce38ad7b9326acb5b19d37a789d6617", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,6 @@\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{Parser, Restrictions, TokenType};\n+use crate::errors::PathSingleColon;\n use crate::{errors, maybe_whole};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n@@ -8,7 +9,7 @@ use rustc_ast::{\n     AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n     Path, PathSegment, QSelf,\n };\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::{Applicability, IntoDiagnostic, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Ident};\n use std::mem;\n@@ -24,7 +25,19 @@ pub enum PathStyle {\n     /// In all such contexts the non-path interpretation is preferred by default for practical\n     /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n     /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n+    ///\n+    /// Also, a path may never be followed by a `:`. This means that we can eagerly recover if\n+    /// we encounter it.\n     Expr,\n+    /// The same as `Expr`, but may be followed by a `:`.\n+    /// For example, this code:\n+    /// ```rust\n+    /// struct S;\n+    ///\n+    /// let S: S;\n+    /// //  ^ Followed by a `:`\n+    /// ```\n+    Pat,\n     /// In other contexts, notably in types, no ambiguity exists and paths can be written\n     /// without the disambiguator, e.g., `x<y>` - unambiguously a path.\n     /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n@@ -38,6 +51,12 @@ pub enum PathStyle {\n     Mod,\n }\n \n+impl PathStyle {\n+    fn has_generic_ambiguity(&self) -> bool {\n+        matches!(self, Self::Expr | Self::Pat)\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a qualified path.\n     /// Assumes that the leading `<` has been parsed already.\n@@ -183,7 +202,6 @@ impl<'a> Parser<'a> {\n             segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, ty_generics)?;\n-\n         Ok(Path { segments, span: lo.to(self.prev_token.span), tokens: None })\n     }\n \n@@ -195,7 +213,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, ()> {\n         loop {\n             let segment = self.parse_path_segment(style, ty_generics)?;\n-            if style == PathStyle::Expr {\n+            if style.has_generic_ambiguity() {\n                 // In order to check for trailing angle brackets, we must have finished\n                 // recursing (`parse_path_segment` can indirectly call this function),\n                 // that is, the next token must be the highlighted part of the below example:\n@@ -217,6 +235,29 @@ impl<'a> Parser<'a> {\n             segments.push(segment);\n \n             if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                if style == PathStyle::Expr\n+                    && self.may_recover()\n+                    && self.token == token::Colon\n+                    && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+                {\n+                    // Emit a special error message for `a::b:c` to help users\n+                    // otherwise, `a: c` might have meant to introduce a new binding\n+                    if self.token.span.lo() == self.prev_token.span.hi()\n+                        && self.look_ahead(1, |token| self.token.span.hi() == token.span.lo())\n+                    {\n+                        self.bump(); // bump past the colon\n+                        self.sess.emit_err(PathSingleColon {\n+                            span: self.prev_token.span,\n+                            type_ascription: self\n+                                .sess\n+                                .unstable_features\n+                                .is_nightly_build()\n+                                .then_some(()),\n+                        });\n+                    }\n+                    continue;\n+                }\n+\n                 return Ok(());\n             }\n         }\n@@ -270,8 +311,25 @@ impl<'a> Parser<'a> {\n                         ty_generics,\n                     )?;\n                     self.expect_gt().map_err(|mut err| {\n+                        // Try to recover a `:` into a `::`\n+                        if self.token == token::Colon\n+                            && self.look_ahead(1, |token| {\n+                                token.is_ident() && !token.is_reserved_ident()\n+                            })\n+                        {\n+                            err.cancel();\n+                            err = PathSingleColon {\n+                                span: self.token.span,\n+                                type_ascription: self\n+                                    .sess\n+                                    .unstable_features\n+                                    .is_nightly_build()\n+                                    .then_some(()),\n+                            }\n+                            .into_diagnostic(self.diagnostic());\n+                        }\n                         // Attempt to find places where a missing `>` might belong.\n-                        if let Some(arg) = args\n+                        else if let Some(arg) = args\n                             .iter()\n                             .rev()\n                             .find(|arg| !matches!(arg, AngleBracketedArg::Constraint(_)))"}, {"sha": "0a571013d44daf1652dc4731a3ea1e52c1fca90b", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 107, "deletions": 20, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -10,6 +10,8 @@ use super::{\n use crate::errors;\n use crate::maybe_whole;\n \n+use crate::errors::MalformedLoopLabel;\n+use ast::Label;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -19,7 +21,8 @@ use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, HasAttrs, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_span::source_map::{BytePos, Span};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n+\n use std::mem;\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -186,7 +189,7 @@ impl<'a> Parser<'a> {\n             _ => MacStmtStyle::NoBraces,\n         };\n \n-        let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n+        let mac = P(MacCall { path, args });\n \n         let kind = if (style == MacStmtStyle::Braces\n             && self.token != token::Dot\n@@ -546,10 +549,36 @@ impl<'a> Parser<'a> {\n             }\n             let stmt = match self.parse_full_stmt(recover) {\n                 Err(mut err) if recover.yes() => {\n-                    self.maybe_annotate_with_ascription(&mut err, false);\n                     if let Some(ref mut snapshot) = snapshot {\n                         snapshot.recover_diff_marker();\n                     }\n+                    if self.token == token::Colon {\n+                        // if next token is following a colon, it's likely a path\n+                        // and we can suggest a path separator\n+                        let ident_span = self.prev_token.span;\n+                        self.bump();\n+                        if self.token.span.lo() == self.prev_token.span.hi() {\n+                            err.span_suggestion_verbose(\n+                                self.prev_token.span,\n+                                \"maybe write a path separator here\",\n+                                \"::\",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        if self.look_ahead(1, |token| token == &token::Eq) {\n+                            err.span_suggestion_verbose(\n+                                ident_span.shrink_to_lo(),\n+                                \"you might have meant to introduce a new binding\",\n+                                \"let \",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        if self.sess.unstable_features.is_nightly_build() {\n+                            // FIXME(Nilstrieb): Remove this again after a few months.\n+                            err.note(\"type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\");\n+                        }\n+                    }\n+\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(self.mk_stmt_err(self.token.span))\n@@ -580,19 +609,25 @@ impl<'a> Parser<'a> {\n         };\n \n         let mut eat_semi = true;\n+        let mut add_semi_to_stmt = false;\n+\n         match &mut stmt.kind {\n             // Expression without semicolon.\n             StmtKind::Expr(expr)\n                 if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n                 // `expect_one_of` returns PResult<'a, bool /* recovered */>\n-                let replace_with_err =\n-                    match self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]) {\n+\n+                let expect_result = self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]);\n+\n+                let replace_with_err = 'break_recover: {\n+                    match expect_result {\n                     // Recover from parser, skip type error to avoid extra errors.\n-                    Ok(true) => true,\n-                    Err(mut e) => {\n-                        if let TokenKind::DocComment(..) = self.token.kind &&\n-                            let Ok(snippet) = self.span_to_snippet(self.token.span) {\n+                        Ok(true) => true,\n+                        Err(mut e) => {\n+                            if let TokenKind::DocComment(..) = self.token.kind\n+                                && let Ok(snippet) = self.span_to_snippet(self.token.span)\n+                            {\n                                 let sp = self.token.span;\n                                 let marker = &snippet[..3];\n                                 let (comment_marker, doc_comment_marker) = marker.split_at(2);\n@@ -606,21 +641,72 @@ impl<'a> Parser<'a> {\n                                     format!(\"{} {}\", comment_marker, doc_comment_marker),\n                                     Applicability::MaybeIncorrect,\n                                 );\n-                        }\n+                            }\n+\n+                            if self.recover_colon_as_semi() {\n+                                // recover_colon_as_semi has already emitted a nicer error.\n+                                e.delay_as_bug();\n+                                add_semi_to_stmt = true;\n+                                eat_semi = false;\n+\n+                                break 'break_recover false;\n+                            }\n+\n+                            match &expr.kind {\n+                                ExprKind::Path(None, ast::Path { segments, .. }) if segments.len() == 1 => {\n+                                    if self.token == token::Colon\n+                                        && self.look_ahead(1, |token| {\n+                                            token.is_whole_block() || matches!(\n+                                                token.kind,\n+                                                token::Ident(kw::For | kw::Loop | kw::While, false)\n+                                                    | token::OpenDelim(Delimiter::Brace)\n+                                            )\n+                                        })\n+                                    {\n+                                        let snapshot = self.create_snapshot_for_diagnostic();\n+                                        let label = Label {\n+                                            ident: Ident::from_str_and_span(\n+                                                &format!(\"'{}\", segments[0].ident),\n+                                                segments[0].ident.span,\n+                                            ),\n+                                        };\n+                                        match self.parse_expr_labeled(label, false) {\n+                                            Ok(labeled_expr) => {\n+                                                e.delay_as_bug();\n+                                                self.sess.emit_err(MalformedLoopLabel {\n+                                                    span: label.ident.span,\n+                                                    correct_label: label.ident,\n+                                                });\n+                                                *expr = labeled_expr;\n+                                                break 'break_recover false;\n+                                            }\n+                                            Err(err) => {\n+                                                err.cancel();\n+                                                self.restore_snapshot(snapshot);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                _ => {}\n+                            }\n \n-                        if let Err(mut e) =\n-                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n-                        {\n-                            if recover.no() {\n-                                return Err(e);\n+                            if let Err(mut e) =\n+                                self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n+                            {\n+                                if recover.no() {\n+                                    return Err(e);\n+                                }\n+                                e.emit();\n+                                self.recover_stmt();\n                             }\n-                            e.emit();\n-                            self.recover_stmt();\n+\n+                            true\n+\n                         }\n-                        true\n+                        Ok(false) => false\n                     }\n-                    _ => false\n                 };\n+\n                 if replace_with_err {\n                     // We already emitted an error, so don't emit another type error\n                     let sp = expr.span.to(self.prev_token.span);\n@@ -643,9 +729,10 @@ impl<'a> Parser<'a> {\n             StmtKind::Empty | StmtKind::Item(_) | StmtKind::Local(_) | StmtKind::Semi(_) => eat_semi = false,\n         }\n \n-        if eat_semi && self.eat(&token::Semi) {\n+        if add_semi_to_stmt || (eat_semi && self.eat(&token::Semi)) {\n             stmt = stmt.add_trailing_semicolon();\n         }\n+\n         stmt.span = stmt.span.to(self.prev_token.span);\n         Ok(Some(stmt))\n     }"}, {"sha": "37c441fbecb96a54c2630a00dd0d93e5ea0eb9bc", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -317,7 +317,6 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n             let mut err = self.struct_span_err(self.token.span, &msg);\n             err.span_label(self.token.span, \"expected type\");\n-            self.maybe_annotate_with_ascription(&mut err, true);\n             return Err(err);\n         };\n \n@@ -651,11 +650,7 @@ impl<'a> Parser<'a> {\n         let path = self.parse_path_inner(PathStyle::Type, ty_generics)?;\n         if self.eat(&token::Not) {\n             // Macro invocation in type position\n-            Ok(TyKind::MacCall(P(MacCall {\n-                path,\n-                args: self.parse_delim_args()?,\n-                prior_type_ascription: self.last_type_ascription,\n-            })))\n+            Ok(TyKind::MacCall(P(MacCall { path, args: self.parse_delim_args()? })))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n             self.parse_remaining_bounds_path(ThinVec::new(), path, lo, true)"}, {"sha": "3a84a2db86cd5fd6350233bf64c2d61575cb2030", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1345,7 +1345,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n         ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize);\n+        debug!(\n+            \"resolve_path(path={:?}, opt_ns={:?}, finalize={:?}) path_len: {}\",\n+            path,\n+            opt_ns,\n+            finalize,\n+            path.len()\n+        );\n \n         let mut module = None;\n         let mut allow_super = true;"}, {"sha": "2ac6fac7f565ee5a1eafd1683e08c4a14549b944", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -548,9 +548,6 @@ struct DiagnosticMetadata<'ast> {\n     /// they are used (in a `break` or `continue` statement)\n     unused_labels: FxHashMap<NodeId, Span>,\n \n-    /// Only used for better errors on `fn(): fn()`.\n-    current_type_ascription: Vec<Span>,\n-\n     /// Only used for better errors on `let x = { foo: bar };`.\n     /// In the case of a parse error with `let x = { foo: bar, };`, this isn't needed, it's only\n     /// needed for cases where this parses as a correct type ascription.\n@@ -4064,17 +4061,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     }\n                 }\n             }\n-            ExprKind::Type(ref type_expr, ref ty) => {\n-                // `ParseSess::type_ascription_path_suggestions` keeps spans of colon tokens in\n-                // type ascription. Here we are trying to retrieve the span of the colon token as\n-                // well, but only if it's written without spaces `expr:Ty` and therefore confusable\n-                // with `expr::Ty`, only in this case it will match the span from\n-                // `type_ascription_path_suggestions`.\n-                self.diagnostic_metadata\n-                    .current_type_ascription\n-                    .push(type_expr.span.between(ty.span));\n+            ExprKind::Type(ref _type_expr, ref _ty) => {\n                 visit::walk_expr(self, expr);\n-                self.diagnostic_metadata.current_type_ascription.pop();\n             }\n             // `async |x| ...` gets desugared to `|x| async {...}`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the"}, {"sha": "383648877c8c04470120c5fd185012b2b0079e88", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 123, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -28,7 +28,7 @@ use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::Span;\n \n use std::iter;\n use std::ops::Deref;\n@@ -350,18 +350,15 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             return (err, candidates);\n         }\n \n-        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n-            let mut fallback =\n-                self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n+        let mut fallback = self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n \n-            // if we have suggested using pattern matching, then don't add needless suggestions\n-            // for typos.\n-            fallback |= self.suggest_typo(&mut err, source, path, span, &base_error);\n+        // if we have suggested using pattern matching, then don't add needless suggestions\n+        // for typos.\n+        fallback |= self.suggest_typo(&mut err, source, path, span, &base_error);\n \n-            if fallback {\n-                // Fallback label.\n-                err.span_label(base_error.span, &base_error.fallback_label);\n-            }\n+        if fallback {\n+            // Fallback label.\n+            err.span_label(base_error.span, &base_error.fallback_label);\n         }\n         self.err_code_special_cases(&mut err, source, path, span);\n \n@@ -494,24 +491,6 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 .filter(|(_, enum_ty_path)| !enum_ty_path.starts_with(\"std::prelude::\"))\n                 .collect();\n             if !enum_candidates.is_empty() {\n-                if let (PathSource::Type, Some(span)) =\n-                    (source, self.diagnostic_metadata.current_type_ascription.last())\n-                {\n-                    if self\n-                        .r\n-                        .tcx\n-                        .sess\n-                        .parse_sess\n-                        .type_ascription_path_suggestions\n-                        .borrow()\n-                        .contains(span)\n-                    {\n-                        // Already reported this issue on the lhs of the type ascription.\n-                        err.downgrade_to_delayed_bug();\n-                        return (true, candidates);\n-                    }\n-                }\n-\n                 enum_candidates.sort();\n \n                 // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n@@ -1393,26 +1372,6 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 Res::Def(DefKind::Enum, def_id),\n                 PathSource::TupleStruct(..) | PathSource::Expr(..),\n             ) => {\n-                if self\n-                    .diagnostic_metadata\n-                    .current_type_ascription\n-                    .last()\n-                    .map(|sp| {\n-                        self.r\n-                            .tcx\n-                            .sess\n-                            .parse_sess\n-                            .type_ascription_path_suggestions\n-                            .borrow()\n-                            .contains(&sp)\n-                    })\n-                    .unwrap_or(false)\n-                {\n-                    err.downgrade_to_delayed_bug();\n-                    // We already suggested changing `:` into `::` during parsing.\n-                    return false;\n-                }\n-\n                 self.suggest_using_enum_variant(err, source, def_id, span);\n             }\n             (Res::Def(DefKind::Struct, def_id), source) if ns == ValueNS => {\n@@ -1817,80 +1776,6 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         })\n     }\n \n-    /// Only used in a specific case of type ascription suggestions\n-    fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let sm = self.r.tcx.sess.source_map();\n-        start.to(sm.next_point(start))\n-    }\n-\n-    fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n-        let sm = self.r.tcx.sess.source_map();\n-        let base_snippet = sm.span_to_snippet(base_span);\n-        if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n-            if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                let len = snippet.trim_end().len() as u32;\n-                if snippet.trim() == \":\" {\n-                    let colon_sp =\n-                        sp.with_lo(sp.lo() + BytePos(len - 1)).with_hi(sp.lo() + BytePos(len));\n-                    let mut show_label = true;\n-                    if sm.is_multiline(sp) {\n-                        err.span_suggestion_short(\n-                            colon_sp,\n-                            \"maybe you meant to write `;` here\",\n-                            \";\",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        let after_colon_sp =\n-                            self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n-                        if snippet.len() == 1 {\n-                            // `foo:bar`\n-                            err.span_suggestion(\n-                                colon_sp,\n-                                \"maybe you meant to write a path separator here\",\n-                                \"::\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            show_label = false;\n-                            if !self\n-                                .r\n-                                .tcx\n-                                .sess\n-                                .parse_sess\n-                                .type_ascription_path_suggestions\n-                                .borrow_mut()\n-                                .insert(colon_sp)\n-                            {\n-                                err.downgrade_to_delayed_bug();\n-                            }\n-                        }\n-                        if let Ok(base_snippet) = base_snippet {\n-                            // Try to find an assignment\n-                            let eq_span = sm.span_look_ahead(after_colon_sp, Some(\"=\"), Some(50));\n-                            if let Ok(ref snippet) = sm.span_to_snippet(eq_span) && snippet == \"=\" {\n-                                err.span_suggestion(\n-                                    base_span,\n-                                    \"maybe you meant to write an assignment here\",\n-                                    format!(\"let {}\", base_snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                show_label = false;\n-                            }\n-                        }\n-                    }\n-                    if show_label {\n-                        err.span_label(\n-                            base_span,\n-                            \"expecting a type here because of type ascription\",\n-                        );\n-                    }\n-                    return show_label;\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n     // try to give a suggestion for this pattern: `name = blah`, which is common in other languages\n     // suggest `let name = blah` to introduce a new binding\n     fn let_binding_suggestion(&mut self, err: &mut Diagnostic, ident_span: Span) -> bool {"}, {"sha": "5cc9c62617dd5aafac439a0a9a230eaa0bcdd883", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -214,8 +214,6 @@ pub struct ParseSess {\n     pub env_depinfo: Lock<FxHashSet<(Symbol, Option<Symbol>)>>,\n     /// File paths accessed during the build.\n     pub file_depinfo: Lock<FxHashSet<Symbol>>,\n-    /// All the type ascriptions expressions that have had a suggestion for likely path typo.\n-    pub type_ascription_path_suggestions: Lock<FxHashSet<Span>>,\n     /// Whether cfg(version) should treat the current release as incomplete\n     pub assume_incomplete_release: bool,\n     /// Spans passed to `proc_macro::quote_span`. Each span has a numerical\n@@ -258,7 +256,6 @@ impl ParseSess {\n             reached_eof: AtomicBool::new(false),\n             env_depinfo: Default::default(),\n             file_depinfo: Default::default(),\n-            type_ascription_path_suggestions: Default::default(),\n             assume_incomplete_release: false,\n             proc_macro_quoted_spans: Default::default(),\n             attr_id_generator: AttrIdGenerator::new(),"}, {"sha": "03cd8e48b9a55479bcb636b53863eb5010d6f9e4", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -163,7 +163,8 @@ impl<'a> Sugg<'a> {\n                 get_snippet(rhs.span),\n             ),\n             hir::ExprKind::Cast(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n-            hir::ExprKind::Type(lhs, ty) => Sugg::BinOp(AssocOp::Colon, get_snippet(lhs.span), get_snippet(ty.span)),\n+            //FIXME(chenyukang), remove this after type ascription is removed from AST\n+            hir::ExprKind::Type(lhs, ty) => Sugg::BinOp(AssocOp::As, get_snippet(lhs.span), get_snippet(ty.span)),\n         }\n     }\n \n@@ -258,8 +259,9 @@ impl<'a> Sugg<'a> {\n                 snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n                 snippet_with_context(cx, ty.span, ctxt, default, app).0,\n             ),\n+            //FIXME(chenyukang), remove this after type ascription is removed from AST\n             ast::ExprKind::Type(ref lhs, ref ty) => Sugg::BinOp(\n-                AssocOp::Colon,\n+                AssocOp::As,\n                 snippet_with_context(cx, lhs.span, ctxt, default, app).0,\n                 snippet_with_context(cx, ty.span, ctxt, default, app).0,\n             ),\n@@ -392,7 +394,6 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n         AssocOp::As => format!(\"{lhs} as {rhs}\"),\n         AssocOp::DotDot => format!(\"{lhs}..{rhs}\"),\n         AssocOp::DotDotEq => format!(\"{lhs}..={rhs}\"),\n-        AssocOp::Colon => format!(\"{lhs}: {rhs}\"),\n     }\n }\n \n@@ -602,13 +603,13 @@ enum Associativity {\n #[must_use]\n fn associativity(op: AssocOp) -> Associativity {\n     use rustc_ast::util::parser::AssocOp::{\n-        Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Colon, Divide, DotDot, DotDotEq, Equal, Greater,\n+        Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Divide, DotDot, DotDotEq, Equal, Greater,\n         GreaterEqual, LAnd, LOr, Less, LessEqual, Modulus, Multiply, NotEqual, ShiftLeft, ShiftRight, Subtract,\n     };\n \n     match op {\n         Assign | AssignOp(_) => Associativity::Right,\n-        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n+        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As => Associativity::Both,\n         Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight\n         | Subtract => Associativity::Left,\n         DotDot | DotDotEq => Associativity::None,"}, {"sha": "4874094ccc4c450a1c44bad1fadfda5d7cf6169a", "filename": "src/tools/rustfmt/tests/source/type-ascription.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b99493492ad59c7a44c65373558175db42b4151/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b99493492ad59c7a44c65373558175db42b4151/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ftype-ascription.rs?ref=7b99493492ad59c7a44c65373558175db42b4151", "patch": "@@ -1,10 +0,0 @@\n-\n-fn main() {\n-    let xxxxxxxxxxx = yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy  :  SomeTrait<AA, BB, CC>;\n-\n-    let xxxxxxxxxxxxxxx = yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n-\n-    let z = funk(yyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz, wwwwww): AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n-\n-    x : u32 - 1u32 / 10f32 : u32\n-}"}, {"sha": "17ac1498c932cf6a3f76177c7e39b93c42bc6c6f", "filename": "src/tools/rustfmt/tests/target/configs/format_macro_bodies/true.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,10 +1,6 @@\n // rustfmt-format_macro_bodies: true\n \n macro_rules! foo {\n-    ($a: ident : $b: ty) => {\n-        $a(42): $b;\n-    };\n-    ($a: ident $b: ident $c: ident) => {\n-        $a = $b + $c;\n-    };\n+    ($a: ident : $b: ty) => { $a(42): $b; };\n+    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };\n }"}, {"sha": "01ecac9879d69c22e93672cf62bae714d40ba3d0", "filename": "src/tools/rustfmt/tests/target/configs/format_macro_matchers/false.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,10 +1,6 @@\n // rustfmt-format_macro_matchers: false\n \n macro_rules! foo {\n-    ($a: ident : $b: ty) => {\n-        $a(42): $b;\n-    };\n-    ($a: ident $b: ident $c: ident) => {\n-        $a = $b + $c;\n-    };\n+    ($a: ident : $b: ty) => { $a(42): $b; };\n+    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };\n }"}, {"sha": "fa0442e228ac8ef91ef90f493d5527f2f404788e", "filename": "src/tools/rustfmt/tests/target/configs/format_macro_matchers/true.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,10 +1,6 @@\n // rustfmt-format_macro_matchers: true\n \n macro_rules! foo {\n-    ($a:ident : $b:ty) => {\n-        $a(42): $b;\n-    };\n-    ($a:ident $b:ident $c:ident) => {\n-        $a = $b + $c;\n-    };\n+    ($a: ident : $b: ty) => { $a(42): $b; };\n+    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };\n }"}, {"sha": "7b4574349df3ec046cb1dd84c595c0bdffd6fce2", "filename": "src/tools/rustfmt/tests/target/macros.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmacros.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -122,7 +122,7 @@ fn main() {\n         20, 21, 22);\n \n     // #1092\n-    chain!(input, a: take!(max_size), || []);\n+    chain!(input, a:take!(max_size), || []);\n \n     // #2727\n     foo!(\"bar\");\n@@ -156,17 +156,13 @@ fn issue1178() {\n }\n \n fn issue1739() {\n-    sql_function!(\n-        add_rss_item,\n-        add_rss_item_t,\n-        (\n-            a: types::Integer,\n-            b: types::Timestamptz,\n-            c: types::Text,\n-            d: types::Text,\n-            e: types::Text\n-        )\n-    );\n+    sql_function!(add_rss_item,\n+                  add_rss_item_t,\n+                  (a: types::Integer,\n+                   b: types::Timestamptz,\n+                   c: types::Text,\n+                   d: types::Text,\n+                   e: types::Text));\n \n     w.slice_mut(s![\n         ..,\n@@ -232,7 +228,7 @@ fn issue_3174() {\n             \"debugMessage\": debug.message,\n         })\n     } else {\n-        json!({ \"errorKind\": format!(\"{:?}\", error.err_kind()) })\n+        json!({\"errorKind\": format!(\"{:?}\", error.err_kind())})\n     };\n }\n "}, {"sha": "a2f082ba4b4975a71c5a4cd98d1b00596e003804", "filename": "src/tools/rustfmt/tests/target/type-ascription.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b99493492ad59c7a44c65373558175db42b4151/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b99493492ad59c7a44c65373558175db42b4151/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype-ascription.rs?ref=7b99493492ad59c7a44c65373558175db42b4151", "patch": "@@ -1,12 +0,0 @@\n-fn main() {\n-    let xxxxxxxxxxx =\n-        yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: SomeTrait<AA, BB, CC>;\n-\n-    let xxxxxxxxxxxxxxx =\n-        yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n-\n-    let z = funk(yyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz, wwwwww):\n-        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n-\n-    x: u32 - 1u32 / 10f32: u32\n-}"}, {"sha": "c789ecb055a7df642549b525326661b628a0af27", "filename": "src/tools/rustfmt/tests/target/type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ftype.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -129,7 +129,7 @@ fn issue3117() {\n fn issue3139() {\n     assert_eq!(\n         to_json_value(&None::<i32>).unwrap(),\n-        json!({ \"test\": None::<i32> })\n+        json!(  { \"test\": None  ::  <i32> }  )\n     );\n }\n "}, {"sha": "fea24703ddadf678e30bec05d4ce40aac453bc09", "filename": "tests/ui/consts/auxiliary/external_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -9,6 +9,6 @@\n macro_rules! static_assert {\n     ($test:expr) => {\n         #[allow(dead_code)]\n-        const _: () = [()][!($test: bool) as usize];\n+        const _: () = [()][!($test) as usize];\n     }\n }"}, {"sha": "6d92fa5e14e989034adfb766a090cfaa351e05c7", "filename": "tests/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -65,6 +65,7 @@ error: unexpected `,` in pattern\n LL |     let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n    |              ^\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n help: try adding parentheses to match on a tuple\n    |\n LL |     let (women, men): (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()"}, {"sha": "5c3f0e37df63dfd57f5169ade9ba23247f62581a", "filename": "tests/ui/feature-gates/feature-gate-type_ascription.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // Type ascription is unstable\n \n fn main() {\n-    let a = 10: u8; //~ ERROR type ascription is experimental\n+    let a = type_ascribe!(10, u8); //~ ERROR use of unstable library feature 'type_ascription': placeholder syntax for type ascription\n }"}, {"sha": "d747aea6d177f8abe8f61efc68c5257de5c09b8a", "filename": "tests/ui/feature-gates/feature-gate-type_ascription.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: type ascription is experimental\n+error[E0658]: use of unstable library feature 'type_ascription': placeholder syntax for type ascription\n   --> $DIR/feature-gate-type_ascription.rs:4:13\n    |\n-LL |     let a = 10: u8;\n-   |             ^^^^^^\n+LL |     let a = type_ascribe!(10, u8);\n+   |             ^^^^^^^^^^^^\n    |\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n    = help: add `#![feature(type_ascription)]` to the crate attributes to enable"}, {"sha": "b7b93ef1c443b810e0d18cbfc1817d642a3a94f9", "filename": "tests/ui/generic-associated-types/parse/trait-path-missing-gen_arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -5,9 +5,6 @@ trait X {\n const _: () = {\n   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n       //~^ ERROR: expected one of `>`, a const expression, lifetime, or type, found `:`\n-      //~| ERROR: expected parameter name, found `>`\n-      //~| ERROR: expected one of `!`, `)`, `+`, `,`, or `::`, found `>`\n-      //~| ERROR: constant provided when a type was expected\n };\n \n const _: () = {"}, {"sha": "bfddb6dc693caac82c3acb63ca9e44e606fac0e1", "filename": "tests/ui/generic-associated-types/parse/trait-path-missing-gen_arg.stderr", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -3,41 +3,14 @@ error: expected one of `>`, a const expression, lifetime, or type, found `:`\n    |\n LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n    |                              ^ expected one of `>`, a const expression, lifetime, or type\n-   |\n-help: expressions must be enclosed in braces to be used as const generic arguments\n-   |\n-LL |   fn f1<'a>(arg : Box<{ dyn X< : 32 } >>) {}\n-   |                       +             +\n-\n-error: expected parameter name, found `>`\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:36\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                                    ^ expected parameter name\n-\n-error: expected one of `!`, `)`, `+`, `,`, or `::`, found `>`\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:36\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                                    ^\n-   |                                    |\n-   |                                    expected one of `!`, `)`, `+`, `,`, or `::`\n-   |                                    help: missing `,`\n \n error: expected one of `>`, a const expression, lifetime, or type, found `=`\n-  --> $DIR/trait-path-missing-gen_arg.rs:14:30\n+  --> $DIR/trait-path-missing-gen_arg.rs:11:30\n    |\n LL |   fn f1<'a>(arg : Box<dyn X< = 32 >>) {}\n    |                            - ^ expected one of `>`, a const expression, lifetime, or type\n    |                            |\n    |                            maybe try to close unmatched angle bracket\n \n-error[E0747]: constant provided when a type was expected\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:23\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                       ^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0747`."}, {"sha": "dff00b0b7200752cf4aa6de58e701f45b92d30a5", "filename": "tests/ui/generics/single-colon-path-not-const-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -6,8 +6,8 @@ pub mod foo {\n \n pub struct Foo {\n   a: Vec<foo::bar:A>,\n-  //~^ ERROR expected\n-  //~| HELP path separator\n+  //~^ ERROR path separator must be a double colon\n+  //~| HELP use a double colon instead\n }\n \n fn main() {}"}, {"sha": "96f07e190c1e27321650c92ca57841006026d5bc", "filename": "tests/ui/generics/single-colon-path-not-const-generics.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,11 +1,12 @@\n-error: expected one of `,` or `>`, found `:`\n+error: path separator must be a double colon\n   --> $DIR/single-colon-path-not-const-generics.rs:8:18\n    |\n+LL | pub struct Foo {\n+   |            --- while parsing this struct\n LL |   a: Vec<foo::bar:A>,\n-   |                  ^\n-   |                  |\n-   |                  expected one of `,` or `>`\n-   |                  help: write a path separator here: `::`\n+   |                  ^ help: use a double colon instead: `::`\n+   |\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "e3ada65049d56cd9667efbbffb591a982f6cd61a", "filename": "tests/ui/issues/issue-22644.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fissues%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fissues%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-22644.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,18 +1,12 @@\n-#![feature(type_ascription)]\n-\n fn main() {\n-    let a : usize = 0;\n-    let long_name : usize = 0;\n+    let a: usize = 0;\n+    let long_name: usize = 0;\n \n     println!(\"{}\", a as usize > long_name);\n     println!(\"{}\", a as usize < long_name); //~ ERROR `<` is interpreted as a start of generic\n     println!(\"{}{}\", a as usize < long_name, long_name);\n     //~^ ERROR `<` is interpreted as a start of generic\n     println!(\"{}\", a as usize < 4); //~ ERROR `<` is interpreted as a start of generic\n-    println!(\"{}\", a: usize > long_name);\n-    println!(\"{}{}\", a: usize < long_name, long_name);\n-    //~^ ERROR `<` is interpreted as a start of generic\n-    println!(\"{}\", a: usize < 4); //~ ERROR `<` is interpreted as a start of generic\n \n     println!(\"{}\", a\n                    as\n@@ -30,6 +24,4 @@ fn main() {\n                    5);\n \n     println!(\"{}\", a as usize << long_name); //~ ERROR `<<` is interpreted as a start of generic\n-\n-    println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n }"}, {"sha": "0799e9ef11b14f767ee96c51574e0ae524551ff9", "filename": "tests/ui/issues/issue-22644.stderr", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-22644.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:8:31\n+  --> $DIR/issue-22644.rs:6:31\n    |\n LL |     println!(\"{}\", a as usize < long_name);\n    |                               ^ --------- interpreted as generic arguments\n@@ -12,7 +12,7 @@ LL |     println!(\"{}\", (a as usize) < long_name);\n    |                    +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:9:33\n+  --> $DIR/issue-22644.rs:7:33\n    |\n LL |     println!(\"{}{}\", a as usize < long_name, long_name);\n    |                                 ^ -------------------- interpreted as generic arguments\n@@ -25,7 +25,7 @@ LL |     println!(\"{}{}\", (a as usize) < long_name, long_name);\n    |                      +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:11:31\n+  --> $DIR/issue-22644.rs:9:31\n    |\n LL |     println!(\"{}\", a as usize < 4);\n    |                               ^ - interpreted as generic arguments\n@@ -38,33 +38,7 @@ LL |     println!(\"{}\", (a as usize) < 4);\n    |                    +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:13:31\n-   |\n-LL |     println!(\"{}{}\", a: usize < long_name, long_name);\n-   |                               ^ -------------------- interpreted as generic arguments\n-   |                               |\n-   |                               not interpreted as comparison\n-   |\n-help: try comparing the cast value\n-   |\n-LL |     println!(\"{}{}\", (a: usize) < long_name, long_name);\n-   |                      +        +\n-\n-error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:15:29\n-   |\n-LL |     println!(\"{}\", a: usize < 4);\n-   |                             ^ - interpreted as generic arguments\n-   |                             |\n-   |                             not interpreted as comparison\n-   |\n-help: try comparing the cast value\n-   |\n-LL |     println!(\"{}\", (a: usize) < 4);\n-   |                    +        +\n-\n-error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:20:20\n+  --> $DIR/issue-22644.rs:14:20\n    |\n LL |                    <\n    |                    ^ not interpreted as comparison\n@@ -79,7 +53,7 @@ LL ~                    usize)\n    |\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:29:20\n+  --> $DIR/issue-22644.rs:23:20\n    |\n LL |                    <\n    |                    ^ not interpreted as comparison\n@@ -96,7 +70,7 @@ LL ~                    usize)\n    |\n \n error: `<<` is interpreted as a start of generic arguments for `usize`, not a shift\n-  --> $DIR/issue-22644.rs:32:31\n+  --> $DIR/issue-22644.rs:26:31\n    |\n LL |     println!(\"{}\", a as usize << long_name);\n    |                               ^^ --------- interpreted as generic arguments\n@@ -108,16 +82,5 @@ help: try shifting the cast value\n LL |     println!(\"{}\", (a as usize) << long_name);\n    |                    +          +\n \n-error: expected type, found `4`\n-  --> $DIR/issue-22644.rs:34:28\n-   |\n-LL |     println!(\"{}\", a: &mut 4);\n-   |                     -      ^ expected type\n-   |                     |\n-   |                     tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "816f99baa849532f5864696658a094cdd1e20aa9", "filename": "tests/ui/macros/stringify.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fstringify.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -134,8 +134,7 @@ fn test_expr() {\n     assert_eq!(stringify_expr!(expr as T<u8>), \"expr as T<u8>\");\n \n     // ExprKind::Type\n-    assert_eq!(stringify_expr!(expr: T), \"expr: T\");\n-    assert_eq!(stringify_expr!(expr: T<u8>), \"expr: T<u8>\");\n+    // There is no syntax for type ascription.\n \n     // ExprKind::If\n     assert_eq!(stringify_expr!(if true {}), \"if true {}\");"}, {"sha": "23dbb57cbcf0f0320049857b5ca6dc488a5d719d", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -8,9 +8,12 @@ use E::*;\n \n fn no_top_level_or_patterns() {\n     // We do *not* allow or-patterns at the top level of lambdas...\n-    let _ = |A | B: E| (); //~ ERROR no implementation for `E | ()`\n+    let _ = |A | B: E| ();\n+                           //~^ ERROR expected identifier, found\n     //           -------- This looks like an or-pattern but is in fact `|A| (B: E | ())`.\n+}\n \n+fn no_top_level_or_patterns_2() {\n     // ...and for now neither do we allow or-patterns at the top level of functions.\n     fn fun1(A | B: E) {}\n     //~^ ERROR top-level or-patterns are not allowed"}, {"sha": "c16a90368e1940ca4e2c5083402b13cfa16f650c", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,43 +1,34 @@\n+error: expected identifier, found `:`\n+  --> $DIR/or-patterns-syntactic-fail.rs:11:19\n+   |\n+LL |     let _ = |A | B: E| ();\n+   |                   ^ expected identifier\n+   |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n error: top-level or-patterns are not allowed in function parameters\n-  --> $DIR/or-patterns-syntactic-fail.rs:15:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:18:13\n    |\n LL |     fn fun1(A | B: E) {}\n    |             ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in function parameters\n-  --> $DIR/or-patterns-syntactic-fail.rs:18:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:21:13\n    |\n LL |     fn fun2(| A | B: E) {}\n    |             ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in `let` bindings\n-  --> $DIR/or-patterns-syntactic-fail.rs:23:9\n+  --> $DIR/or-patterns-syntactic-fail.rs:26:9\n    |\n LL |     let A | B: E = A;\n    |         ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in `let` bindings\n-  --> $DIR/or-patterns-syntactic-fail.rs:26:9\n+  --> $DIR/or-patterns-syntactic-fail.rs:29:9\n    |\n LL |     let | A | B: E = A;\n    |         ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n-error[E0369]: no implementation for `E | ()`\n-  --> $DIR/or-patterns-syntactic-fail.rs:11:22\n-   |\n-LL |     let _ = |A | B: E| ();\n-   |                  ----^ -- ()\n-   |                  |\n-   |                  E\n-   |\n-note: an implementation of `BitOr<()>` might be missing for `E`\n-  --> $DIR/or-patterns-syntactic-fail.rs:6:1\n-   |\n-LL | enum E { A, B }\n-   | ^^^^^^ must implement `BitOr<()>`\n-note: the trait `BitOr` must be implemented\n-  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-\n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0369`."}, {"sha": "d1950087c4c2d8acbf11d7794dc289d5ac22dde1", "filename": "tests/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -6,6 +6,7 @@ fn main() {}\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n //~^ ERROR an inner attribute is not permitted in this context\n+//~| ERROR an inner attribute is not permitted in this context\n //~| ERROR expected expression, found `)`\n #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n //~^ ERROR an inner attribute is not permitted in this context"}, {"sha": "96899fd3fc5ca59caef13693d4e5d8c40b55ce64", "filename": "tests/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 58, "deletions": 49, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -19,14 +19,23 @@ LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:7:36\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n+   |                                    ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+   = note: outer attributes, like `#[test]`, annotate the item following them\n+\n error: expected expression, found `)`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:7:44\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    |                                            ^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:10:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:11:38\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                      ^^^^^^^^\n@@ -35,13 +44,13 @@ LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected expression, found `)`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:10:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:11:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                              ^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:13:36\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:14:36\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n    |                                    ^^^^^^^^\n@@ -50,7 +59,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:15:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:16:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n    |                                 ^^^^^^^^\n@@ -59,7 +68,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:17:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:18:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    |                                 ^^^^^^^^\n@@ -68,13 +77,13 @@ LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:19:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:20:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n    |                                  ^ expected one of 8 possible tokens\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:21:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:22:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n    |                                   ^^^^^^^^\n@@ -83,7 +92,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:23:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:24:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n    |                                        ^^^^^^^^\n@@ -92,7 +101,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:25:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:26:35\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n    |                                   ^^^^^^^^\n@@ -101,7 +110,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:27:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:28:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n    |                                        ^^^^^^^^\n@@ -110,19 +119,19 @@ LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected expression, found `..`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:29:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:30:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..#[attr] 0; }\n    |                                        ^^ expected expression\n \n error: expected expression, found `..`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:31:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:32:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..; }\n    |                                        ^^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:33:41\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:34:41\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n    |                                         ^^^^^^^^\n@@ -131,7 +140,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:35:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:36:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |                                             ^^^^^^^^\n@@ -140,7 +149,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:37:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:38:37\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                --   ^^^^^^^ -- the attributes are attached to this branch\n@@ -149,7 +158,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:39:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:40:38\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    |                                      ^^^^^^^^\n@@ -158,13 +167,13 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:41:40\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:42:40\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:43:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:44:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                        ---- ^^^^^^^ -- the attributes are attached to this branch\n@@ -173,7 +182,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                        the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:45:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:46:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |                                              ^^^^^^^^\n@@ -182,7 +191,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:48:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                        ---- ^^^^^^^ ------- the attributes are attached to this branch\n@@ -191,7 +200,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                        the branch belongs to this `else`\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:49:50\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:50:50\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             --   ^^^^^^^ -- the attributes are attached to this branch\n@@ -200,7 +209,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:51:51\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:52:51\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |                                                   ^^^^^^^^\n@@ -209,7 +218,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:54:45\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                --           ^^^^^^^ -- the attributes are attached to this branch\n@@ -218,7 +227,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:55:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:56:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    |                                              ^^^^^^^^\n@@ -227,13 +236,13 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:57:48\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:58:48\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:59:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:60:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                ---- ^^^^^^^ -- the attributes are attached to this branch\n@@ -242,7 +251,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:61:54\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:62:54\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |                                                      ^^^^^^^^\n@@ -251,7 +260,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:63:53\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:64:53\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n    |                                                ---- ^^^^^^^ --------------- the attributes are attached to this branch\n@@ -260,7 +269,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}\n    |                                                the branch belongs to this `else`\n \n error: outer attributes are not allowed on `if` and `else` branches\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:65:66\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:66:66\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n    |                                                     --           ^^^^^^^ -- the attributes are attached to this branch\n@@ -269,7 +278,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}\n    |                                                     the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:67:67\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:68:67\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n    |                                                                   ^^^^^^^^\n@@ -278,7 +287,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:70:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:71:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -289,7 +298,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:72:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:73:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -300,7 +309,7 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:74:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:75:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    |                        ------- ^^^^^^^^ ------- the inner attribute doesn't annotate this item macro invocation\n@@ -316,7 +325,7 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo!(); }\n    |\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:76:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:77:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    |                        ------- ^^^^^^^^ ------- the inner attribute doesn't annotate this item macro invocation\n@@ -332,7 +341,7 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo![]; }\n    |\n \n error: an inner attribute is not permitted following an outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:78:32\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:79:32\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    |                        ------- ^^^^^^^^ ------ the inner attribute doesn't annotate this item macro invocation\n@@ -348,89 +357,89 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo!{}; }\n    |\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:84:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:85:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:84:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:85:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:87:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:88:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:87:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:88:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:90:39\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:91:39\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n    |                                       ^\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:92:35\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:93:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:92:38\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:93:38\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:96:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:97:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:96:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:97:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: unexpected token: `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:104:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:105:37\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                     ^^^^^^^\n \n error: expected statement after outer attribute\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:106:37\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:107:37\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n    |                                     ^^^^^^^\n \n-error: aborting due to 52 previous errors\n+error: aborting due to 53 previous errors\n \n For more information about this error, try `rustc --explain E0586`."}, {"sha": "9213437458a5917edb29be88787ed8265c5c6eab", "filename": "tests/ui/parser/issue-103869.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissue-103869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissue-103869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissue-103869.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -2,7 +2,6 @@ enum VecOrMap{\n     vec: Vec<usize>,\n     //~^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n     //~| HELP: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n-    //~| ERROR expected item, found `:`\n     map: HashMap<String,usize>\n }\n "}, {"sha": "9eb20e2005a4a7f91a0476f104190eca010fae54", "filename": "tests/ui/parser/issue-103869.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissue-103869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissue-103869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissue-103869.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,16 +1,12 @@\n error: expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n   --> $DIR/issue-103869.rs:2:8\n    |\n+LL | enum VecOrMap{\n+   |      -------- while parsing this enum\n LL |     vec: Vec<usize>,\n    |        ^ expected one of `(`, `,`, `=`, `{`, or `}`\n    |\n    = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n \n-error: expected item, found `:`\n-  --> $DIR/issue-103869.rs:2:8\n-   |\n-LL |     vec: Vec<usize>,\n-   |        ^ expected item\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "3d110adef3e3460c6fb03d643e591d2656583018", "filename": "tests/ui/parser/issues/issue-35813-postfix-after-cast.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -10,22 +10,22 @@ pub fn index_after_as_cast() {\n     vec![1, 2, 3] as Vec<i32>[0];\n     //~^ ERROR: cast cannot be followed by indexing\n     vec![1, 2, 3]: Vec<i32>[0];\n-    //~^ ERROR: type ascription cannot be followed by indexing\n+    //~^ ERROR: expected one of\n }\n \n pub fn index_after_cast_to_index() {\n     (&[0]) as &[i32][0];\n     //~^ ERROR: cast cannot be followed by indexing\n     (&[0i32]): &[i32; 1][0];\n-    //~^ ERROR: type ascription cannot be followed by indexing\n+    //~^ ERROR: expected one of\n }\n \n pub fn cast_after_cast() {\n     if 5u64 as i32 as u16 == 0u16 {\n \n     }\n     if 5u64: u64: u64 == 0u64 {\n-\n+        //~^ ERROR expected `{`, found `:`\n     }\n     let _ = 5u64: u64: u64 as u8 as i8 == 9i8;\n     let _ = 0i32: i32: i32;\n@@ -36,26 +36,46 @@ pub fn cast_after_cast() {\n }\n \n pub fn cast_cast_method_call() {\n-    let _ = 0i32: i32: i32.count_ones();\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0 as i32: i32.count_ones();\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0i32: i32 as i32.count_ones();\n-    //~^ ERROR: cast cannot be followed by a method call\n+    let _ = 0i32: i32: i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_2() {\n+    let _ = 0 as i32: i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_3() {\n+    let _ = 0i32: i32 as i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_4() {\n     let _ = 0 as i32 as i32.count_ones();\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n-    //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32.count_ones(): u32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0 as i32.count_ones(): u32;\n+}\n+\n+pub fn cast_cast_method_call_5() {\n+    let _ = 0i32: i32: i32 as u32 as i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_6() {\n+    let _ = 0i32: i32.count_ones(): u32; //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_7() {\n+    let _ = 0 as i32.count_ones(): u32; //~ ERROR expected one of\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32.count_ones() as u32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+}\n+\n+pub fn cast_cast_method_call_8() {\n+    let _ = 0i32: i32.count_ones() as u32; //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_9() {\n     let _ = 0 as i32.count_ones() as u32;\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+}\n+\n+pub fn cast_cast_method_call_10() {\n+    let _ = 0i32: i32: i32.count_ones() as u32 as i32; //~ ERROR expected one of\n }\n \n pub fn multiline_error() {\n@@ -74,8 +94,7 @@ pub fn precedence() {\n pub fn method_calls() {\n     0 as i32.max(0);\n     //~^ ERROR: cast cannot be followed by a method call\n-    0: i32.max(0);\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+    0: i32.max(0); //~ ERROR expected one of\n }\n \n pub fn complex() {\n@@ -84,7 +103,7 @@ pub fn complex() {\n         if true { 33 } else { 44 } as i32.max(0),\n         //~^ ERROR: cast cannot be followed by a method call\n         if true { 33 } else { 44 }: i32.max(0)\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected one of\n     );\n }\n \n@@ -93,7 +112,7 @@ pub fn in_condition() {\n         //~^ ERROR: cast cannot be followed by a method call\n     }\n     if 5u64: u64.max(0) == 0 {\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected `{`, found `:`\n     }\n }\n \n@@ -104,22 +123,22 @@ pub fn inside_block() {\n     } else { false };\n     let _ = if true {\n         5u64: u64.max(0) == 0\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected one of\n     } else { false };\n }\n \n static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n //~^ ERROR: cast cannot be followed by indexing\n \n static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-//~^ ERROR: type ascription cannot be followed by indexing\n+//~^ ERROR: expected one of\n \n \n pub fn cast_then_try() -> Result<u64,u64> {\n     Err(0u64) as Result<u64,u64>?;\n     //~^ ERROR: cast cannot be followed by `?`\n     Err(0u64): Result<u64,u64>?;\n-    //~^ ERROR: type ascription cannot be followed by `?`\n+    //~^ ERROR: expected one of\n     Ok(1)\n }\n \n@@ -131,29 +150,30 @@ pub fn cast_then_call() {\n     drop as F();\n     //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n     drop_ptr: F();\n-    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+    //~^ ERROR: expected identifier, found `:`\n }\n \n pub fn cast_to_fn_should_work() {\n     let drop_ptr = drop as fn(u8);\n     drop as fn(u8);\n     drop_ptr: fn(u8);\n+    //~^ ERROR expected one of\n }\n \n pub fn parens_after_cast_error() {\n     let drop_ptr = drop as fn(u8);\n     drop as fn(u8)(0);\n     //~^ ERROR: cast cannot be followed by a function call\n     drop_ptr: fn(u8)(0);\n-    //~^ ERROR: type ascription cannot be followed by a function call\n+    //~^ ERROR: expected one of\n }\n \n pub async fn cast_then_await() {\n     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n     //~^ ERROR: cast cannot be followed by `.await`\n \n     Box::pin(noop()): Pin<Box<_>>.await;\n-    //~^ ERROR: type ascription cannot be followed by `.await`\n+    //~^ ERROR: expected one of\n }\n \n pub async fn noop() {}\n@@ -167,5 +187,5 @@ pub fn struct_field() {\n     Foo::default() as Foo.bar;\n     //~^ ERROR: cannot be followed by a field access\n     Foo::default(): Foo.bar;\n-    //~^ ERROR: type ascription cannot be followed by a field access\n+    //~^ ERROR expected one of\n }"}, {"sha": "d313c888e51c65f574d5c7df0edc420d68c47124", "filename": "tests/ui/parser/issues/issue-35813-postfix-after-cast.stderr", "status": "modified", "additions": 108, "deletions": 230, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -9,21 +9,11 @@ help: try surrounding the expression in parentheses\n LL |     (vec![1, 2, 3] as Vec<i32>)[0];\n    |     +                         +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:12:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:12:18\n    |\n LL |     vec![1, 2, 3]: Vec<i32>[0];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (vec![1, 2, 3]: Vec<i32>)[0];\n-   |     +                       +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     vec![1, 2, 3]: Vec<i32>[0];\n-LL +     vec![1, 2, 3][0];\n-   |\n+   |                  ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by indexing\n   --> $DIR/issue-35813-postfix-after-cast.rs:17:5\n@@ -36,67 +26,50 @@ help: try surrounding the expression in parentheses\n LL |     ((&[0]) as &[i32])[0];\n    |     +                +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:19:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:19:14\n    |\n LL |     (&[0i32]): &[i32; 1][0];\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator\n+\n+error: expected `{`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:27:12\n    |\n-LL |     ((&[0i32]): &[i32; 1])[0];\n-   |     +                    +\n-help: alternatively, remove the type ascription\n+LL |     if 5u64: u64: u64 == 0u64 {\n+   |            ^ expected `{`\n    |\n-LL -     (&[0i32]): &[i32; 1][0];\n-LL +     (&[0i32])[0];\n+note: the `if` expression is missing a block after this condition\n+  --> $DIR/issue-35813-postfix-after-cast.rs:27:8\n    |\n+LL |     if 5u64: u64: u64 == 0u64 {\n+   |        ^^^^\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:39:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:39:17\n    |\n LL |     let _ = 0i32: i32: i32.count_ones();\n-   |             ^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32: i32).count_ones();\n-   |             +              +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32: i32.count_ones();\n-LL +     let _ = 0i32: i32.count_ones();\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:41:13\n+error: expected one of `!`, `(`, `.`, `::`, `;`, `<`, `?`, or `else`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:43:21\n    |\n LL |     let _ = 0 as i32: i32.count_ones();\n-   |             ^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0 as i32: i32).count_ones();\n-   |             +             +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0 as i32: i32.count_ones();\n-LL +     let _ = 0 as i32.count_ones();\n+   |                     ^ expected one of 8 possible tokens\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:43:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:47:17\n    |\n LL |     let _ = 0i32: i32 as i32.count_ones();\n-   |             ^^^^^^^^^^^^^^^^\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32 as i32).count_ones();\n-   |             +                +\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:45:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n    |\n LL |     let _ = 0 as i32 as i32.count_ones();\n    |             ^^^^^^^^^^^^^^^\n@@ -106,35 +79,24 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32 as i32).count_ones();\n    |             +               +\n \n-error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:47:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:56:17\n    |\n LL |     let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-LL |     let _ = (0i32: i32: i32 as u32 as i32).count_ones();\n-   |             +                            +\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:49:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:60:17\n    |\n LL |     let _ = 0i32: i32.count_ones(): u32;\n-   |             ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32).count_ones(): u32;\n-   |             +         +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32.count_ones(): u32;\n-LL +     let _ = 0i32.count_ones(): u32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:64:13\n    |\n LL |     let _ = 0 as i32.count_ones(): u32;\n    |             ^^^^^^^^\n@@ -144,24 +106,24 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32).count_ones(): u32;\n    |             +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:53:13\n+error: expected one of `.`, `;`, `?`, or `else`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:64:34\n    |\n-LL |     let _ = 0i32: i32.count_ones() as u32;\n-   |             ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+LL |     let _ = 0 as i32.count_ones(): u32;\n+   |                                  ^ expected one of `.`, `;`, `?`, or `else`\n    |\n-LL |     let _ = (0i32: i32).count_ones() as u32;\n-   |             +         +\n-help: alternatively, remove the type ascription\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:69:17\n    |\n-LL -     let _ = 0i32: i32.count_ones() as u32;\n-LL +     let _ = 0i32.count_ones() as u32;\n+LL |     let _ = 0i32: i32.count_ones() as u32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:55:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:73:13\n    |\n LL |     let _ = 0 as i32.count_ones() as u32;\n    |             ^^^^^^^^\n@@ -171,24 +133,16 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32).count_ones() as u32;\n    |             +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:57:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:78:17\n    |\n LL |     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-   |             ^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32: i32).count_ones() as u32 as i32;\n-   |             +              +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-LL +     let _ = 0i32: i32.count_ones() as u32 as i32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:62:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:82:13\n    |\n LL |       let _ = 0\n    |  _____________^\n@@ -202,7 +156,7 @@ LL ~         as i32)\n    |\n \n error: cast cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:70:18\n+  --> $DIR/issue-35813-postfix-after-cast.rs:90:18\n    |\n LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -213,7 +167,7 @@ LL |     let x: i32 = (&vec![1, 2, 3] as &Vec<i32>)[0];\n    |                  +                           +\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:75:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:95:5\n    |\n LL |     0 as i32.max(0);\n    |     ^^^^^^^^\n@@ -223,24 +177,14 @@ help: try surrounding the expression in parentheses\n LL |     (0 as i32).max(0);\n    |     +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:77:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:97:6\n    |\n LL |     0: i32.max(0);\n-   |     ^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (0: i32).max(0);\n-   |     +      +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     0: i32.max(0);\n-LL +     0.max(0);\n-   |\n+   |      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:92:8\n+  --> $DIR/issue-35813-postfix-after-cast.rs:111:8\n    |\n LL |     if 5u64 as i32.max(0) == 0 {\n    |        ^^^^^^^^^^^\n@@ -250,24 +194,20 @@ help: try surrounding the expression in parentheses\n LL |     if (5u64 as i32).max(0) == 0 {\n    |        +           +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:95:8\n+error: expected `{`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:12\n    |\n LL |     if 5u64: u64.max(0) == 0 {\n-   |        ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     if (5u64: u64).max(0) == 0 {\n-   |        +         +\n-help: alternatively, remove the type ascription\n+   |            ^ expected `{`\n    |\n-LL -     if 5u64: u64.max(0) == 0 {\n-LL +     if 5u64.max(0) == 0 {\n+note: the `if` expression is missing a block after this condition\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:8\n    |\n+LL |     if 5u64: u64.max(0) == 0 {\n+   |        ^^^^\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:102:9\n+  --> $DIR/issue-35813-postfix-after-cast.rs:121:9\n    |\n LL |         5u64 as u32.max(0) == 0\n    |         ^^^^^^^^^^^\n@@ -277,24 +217,14 @@ help: try surrounding the expression in parentheses\n LL |         (5u64 as u32).max(0) == 0\n    |         +           +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:106:9\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:125:13\n    |\n LL |         5u64: u64.max(0) == 0\n-   |         ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |         (5u64: u64).max(0) == 0\n-   |         +         +\n-help: alternatively, remove the type ascription\n-   |\n-LL -         5u64: u64.max(0) == 0\n-LL +         5u64.max(0) == 0\n-   |\n+   |             ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:111:24\n+  --> $DIR/issue-35813-postfix-after-cast.rs:130:24\n    |\n LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n    |                        ^^^^^^^^^^^^^^^^^^\n@@ -304,24 +234,14 @@ help: try surrounding the expression in parentheses\n LL | static bar: &[i32] = &((&[1,2,3] as &[i32])[0..1]);\n    |                        +                  +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:114:25\n+error: expected one of `)`, `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:133:36\n    |\n LL | static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL | static bar2: &[i32] = &((&[1i32,2,3]: &[i32; 3])[0..1]);\n-   |                         +                      +\n-help: alternatively, remove the type ascription\n-   |\n-LL - static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-LL + static bar2: &[i32] = &(&[1i32,2,3][0..1]);\n-   |\n+   |                                    ^ expected one of `)`, `,`, `.`, `?`, or an operator\n \n error: cast cannot be followed by `?`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:119:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:138:5\n    |\n LL |     Err(0u64) as Result<u64,u64>?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -331,24 +251,28 @@ help: try surrounding the expression in parentheses\n LL |     (Err(0u64) as Result<u64,u64>)?;\n    |     +                            +\n \n-error: type ascription cannot be followed by `?`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:121:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:140:14\n    |\n LL |     Err(0u64): Result<u64,u64>?;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator\n+\n+error: expected identifier, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:152:13\n    |\n-LL |     (Err(0u64): Result<u64,u64>)?;\n-   |     +                          +\n-help: alternatively, remove the type ascription\n+LL |     drop_ptr: F();\n+   |             ^ expected identifier\n    |\n-LL -     Err(0u64): Result<u64,u64>?;\n-LL +     Err(0u64)?;\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:159:13\n    |\n+LL |     drop_ptr: fn(u8);\n+   |             ^ expected one of 8 possible tokens\n \n error: cast cannot be followed by a function call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:145:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:165:5\n    |\n LL |     drop as fn(u8)(0);\n    |     ^^^^^^^^^^^^^^\n@@ -358,24 +282,14 @@ help: try surrounding the expression in parentheses\n LL |     (drop as fn(u8))(0);\n    |     +              +\n \n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:147:5\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:167:13\n    |\n LL |     drop_ptr: fn(u8)(0);\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (drop_ptr: fn(u8))(0);\n-   |     +                +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     drop_ptr: fn(u8)(0);\n-LL +     drop_ptr(0);\n-   |\n+   |             ^ expected one of 8 possible tokens\n \n error: cast cannot be followed by `.await`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:152:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:172:5\n    |\n LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -385,24 +299,14 @@ help: try surrounding the expression in parentheses\n LL |     (Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>).await;\n    |     +                                                     +\n \n-error: type ascription cannot be followed by `.await`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:155:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:175:21\n    |\n LL |     Box::pin(noop()): Pin<Box<_>>.await;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (Box::pin(noop()): Pin<Box<_>>).await;\n-   |     +                             +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     Box::pin(noop()): Pin<Box<_>>.await;\n-LL +     Box::pin(noop()).await;\n-   |\n+   |                     ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a field access\n-  --> $DIR/issue-35813-postfix-after-cast.rs:167:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:187:5\n    |\n LL |     Foo::default() as Foo.bar;\n    |     ^^^^^^^^^^^^^^^^^^^^^\n@@ -412,24 +316,14 @@ help: try surrounding the expression in parentheses\n LL |     (Foo::default() as Foo).bar;\n    |     +                     +\n \n-error: type ascription cannot be followed by a field access\n-  --> $DIR/issue-35813-postfix-after-cast.rs:169:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:189:19\n    |\n LL |     Foo::default(): Foo.bar;\n-   |     ^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (Foo::default(): Foo).bar;\n-   |     +                   +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     Foo::default(): Foo.bar;\n-LL +     Foo::default().bar;\n-   |\n+   |                   ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:84:9\n+  --> $DIR/issue-35813-postfix-after-cast.rs:103:9\n    |\n LL |         if true { 33 } else { 44 } as i32.max(0),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -439,34 +333,18 @@ help: try surrounding the expression in parentheses\n LL |         (if true { 33 } else { 44 } as i32).max(0),\n    |         +                                 +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:86:9\n+error: expected one of `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:105:35\n    |\n LL |         if true { 33 } else { 44 }: i32.max(0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |         (if true { 33 } else { 44 }: i32).max(0)\n-   |         +                               +\n-help: alternatively, remove the type ascription\n-   |\n-LL -         if true { 33 } else { 44 }: i32.max(0)\n-LL +         if true { 33 } else { 44 }.max(0)\n-   |\n+   |                                   ^ expected one of `,`, `.`, `?`, or an operator\n \n error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-35813-postfix-after-cast.rs:131:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:150:13\n    |\n LL |     drop as F();\n    |             ^^^ only `Fn` traits may use parentheses\n \n-error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-35813-postfix-after-cast.rs:133:15\n-   |\n-LL |     drop_ptr: F();\n-   |               ^^^ only `Fn` traits may use parentheses\n-\n-error: aborting due to 36 previous errors\n+error: aborting due to 39 previous errors\n \n For more information about this error, try `rustc --explain E0214`."}, {"sha": "6719e5828483614d642f967bd3b5cb8722a20cb1", "filename": "tests/ui/parser/issues/issue-44406.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -6,5 +6,4 @@ macro_rules! foo {\n \n fn main() {\n     foo!(true);\n-    //~^ ERROR expected identifier, found keyword\n }"}, {"sha": "69ff64c2772de92f24daff8a8f5e119d4a3286c1", "filename": "tests/ui/parser/issues/issue-44406.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,14 +1,3 @@\n-error: expected identifier, found keyword `true`\n-  --> $DIR/issue-44406.rs:8:10\n-   |\n-LL |     foo!(true);\n-   |          ^^^^ expected identifier, found keyword\n-   |\n-help: escape `true` to use it as an identifier\n-   |\n-LL |     foo!(r#true);\n-   |          ++\n-\n error: invalid `struct` delimiters or `fn` call arguments\n   --> $DIR/issue-44406.rs:3:9\n    |\n@@ -29,5 +18,5 @@ LL -         bar(baz: $rest)\n LL +         bar(: $rest)\n    |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "80e0940ad8f85c660ea5b3d56beba4a5385bc8a1", "filename": "tests/ui/parser/issues/issue-91461.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,6 +1,5 @@\n fn main() {\n     a(_:b:,)\n-    //~^ ERROR: expected identifier, found reserved identifier `_`\n-    //~| ERROR: expected type, found `,`\n-    //~| ERROR: expected type, found `,`\n+    //~^ ERROR expected identifier, found reserved identifier\n+    //~| ERROR: expected one of\n }"}, {"sha": "27e1b5cdc177ffc612ed7dd7043d884455ffdfed", "filename": "tests/ui/parser/issues/issue-91461.stderr", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -4,28 +4,11 @@ error: expected identifier, found reserved identifier `_`\n LL |     a(_:b:,)\n    |       ^ expected identifier, found reserved identifier\n \n-error: expected type, found `,`\n-  --> $DIR/issue-91461.rs:2:11\n+error: expected one of `)`, `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-91461.rs:2:8\n    |\n LL |     a(_:b:,)\n-   |     -    -^ expected type\n-   |     |    |\n-   |     |    tried to parse a type due to this type ascription\n-   |     while parsing this struct\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-\n-error: expected type, found `,`\n-  --> $DIR/issue-91461.rs:2:11\n-   |\n-LL |     a(_:b:,)\n-   |          -^ expected type\n-   |          |\n-   |          tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   |        ^ expected one of `)`, `,`, `.`, `?`, or an operator\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "01a978d55574bb6096f2e8e49608dd651a7f71ea", "filename": "tests/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -22,8 +22,7 @@ fn case_1() {\n #[cfg(FALSE)]\n fn case_2() {\n     let a @ (b: u8);\n-    //~^ ERROR expected one of `!`\n-    //~| ERROR expected one of `)`\n+    //~^ ERROR expected one of `)`\n }\n \n #[cfg(FALSE)]"}, {"sha": "0c109ff6bbad12dbfde2aaeb9787005071dfb044", "filename": "tests/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -9,18 +9,14 @@ error: expected one of `)`, `,`, `@`, or `|`, found `:`\n    |\n LL |     let a @ (b: u8);\n    |               ^ expected one of `)`, `,`, `@`, or `|`\n-\n-error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `)`\n-  --> $DIR/nested-type-ascription-syntactically-invalid.rs:24:19\n    |\n-LL |     let a @ (b: u8);\n-   |                   ^ expected one of 7 possible tokens\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `@`\n-  --> $DIR/nested-type-ascription-syntactically-invalid.rs:31:15\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:30:15\n    |\n LL |     let a: T1 @ Outer(b: T2);\n    |               ^ expected one of 7 possible tokens\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "cc2406d6690e3b193d1ee19b7df9649851fafde2", "filename": "tests/ui/suggestions/many-type-ascription.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let _ = 0: i32; //~ ERROR: type ascription is experimental\n+    let _ = 0: i32; //~ ERROR: expected one of\n     let _ = 0: i32; // (error only emitted once)\n }"}, {"sha": "e36919c82f83255d06e83e3b22e2d694a1274668", "filename": "tests/ui/suggestions/many-type-ascription.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: type ascription is experimental\n-  --> $DIR/many-type-ascription.rs:2:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/many-type-ascription.rs:2:14\n    |\n LL |     let _ = 0: i32;\n-   |             ^^^^^^\n+   |              ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "5ad6024329861c4284c2b39e971e68a2970ed9cb", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -3,8 +3,7 @@ fn fun(x: i32) -> i32 { x }\n fn main() {\n     let closure_annotated = |value: i32| -> i32 {\n         temp: i32 = fun(5i32);\n-        //~^ ERROR cannot find value `temp` in this scope\n+        //~^ ERROR expected identifier, found `:`\n         temp + value + 1\n-        //~^ ERROR cannot find value `temp` in this scope\n     };\n }"}, {"sha": "fb697b0ccfd5e25ea6510f44a0f1b0b43c055997", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,18 +1,8 @@\n-error[E0425]: cannot find value `temp` in this scope\n-  --> $DIR/type-ascription-instead-of-let.rs:5:9\n+error: expected identifier, found `:`\n+  --> $DIR/type-ascription-instead-of-let.rs:5:13\n    |\n LL |         temp: i32 = fun(5i32);\n-   |         ^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: maybe you meant to write an assignment here: `let temp`\n+   |             ^ expected identifier\n \n-error[E0425]: cannot find value `temp` in this scope\n-  --> $DIR/type-ascription-instead-of-let.rs:7:9\n-   |\n-LL |         temp + value + 1\n-   |         ^^^^ not found in this scope\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "02e316b264e87996c8fbaba22756cfc3bf1f468b", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Box::new(\"foo\".to_string());\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "6f893ee89b2cc707e09d31f0378cdaa8fa3a3bb3", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Box:new(\"foo\".to_string());\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "b3799101cf0a58ae24705f623dab4be8ce92f75d", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,10 @@\n-error: expected type, found `\"foo\"`\n-  --> $DIR/type-ascription-instead-of-method.rs:3:21\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-method.rs:3:16\n    |\n LL |     let _ = Box:new(\"foo\".to_string());\n-   |                -    ^^^^^ expected type\n-   |                |\n-   |                help: maybe write a path separator here: `::`\n+   |                ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "4cec58be856f033e3906ee4c596af4d437cdf3b5", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n fn main() -> Result<(), ()> {\n     let _ = vec![Ok(2)].into_iter().collect::<Result<Vec<_>,_>>()?;\n-    //~^ ERROR expected `::`, found `(`\n+    //~^ ERROR expected one of\n     Ok(())\n }"}, {"sha": "5695d5a7f72510d21ee5b88f03dcdf2dbec46fc5", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n fn main() -> Result<(), ()> {\n     let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n-    //~^ ERROR expected `::`, found `(`\n+    //~^ ERROR expected one of\n     Ok(())\n }"}, {"sha": "43d00591e74c0be6aa1538ccc4825658151c1b91", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,14 @@\n-error: expected `::`, found `(`\n-  --> $DIR/type-ascription-instead-of-path-2.rs:3:63\n+error: expected one of `(`, `.`, `::`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/type-ascription-instead-of-path-2.rs:3:44\n    |\n LL |     let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n-   |                                            -                  ^ expected `::`\n-   |                                            |\n-   |                                            help: maybe write a path separator here: `::`\n+   |                                            ^ expected one of 7 possible tokens\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+help: maybe write a path separator here\n+   |\n+LL |     let _ = vec![Ok(2)].into_iter().collect::<Result<Vec<_>,_>>()?;\n+   |                                            ~~\n \n error: aborting due to previous error\n "}, {"sha": "69647887afcee176f04f3a3c3ff08c01b4f42475", "filename": "tests/ui/suggestions/type-ascription-instead-of-path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,4 @@\n fn main() {\n     std:io::stdin();\n-    //~^ ERROR failed to resolve: use of undeclared crate or module `io`\n-    //~| ERROR expected value, found crate\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "849630218daedb68311c05e1d458f341493a6bed", "filename": "tests/ui/suggestions/type-ascription-instead-of-path.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,18 +1,10 @@\n-error[E0433]: failed to resolve: use of undeclared crate or module `io`\n-  --> $DIR/type-ascription-instead-of-path.rs:2:9\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-path.rs:2:8\n    |\n LL |     std:io::stdin();\n-   |         ^^ use of undeclared crate or module `io`\n-\n-error[E0423]: expected value, found crate `std`\n-  --> $DIR/type-ascription-instead-of-path.rs:2:5\n+   |        ^ help: use a double colon instead: `::`\n    |\n-LL |     std:io::stdin();\n-   |     ^^^- help: maybe you meant to write a path separator here: `::`\n-   |     |\n-   |     not a value\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0423, E0433.\n-For more information about an error, try `rustc --explain E0423`."}, {"sha": "04cb206862462cf39342bfab3722f2216ecaac0b", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Option::Some(\"\");\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "2cce69bfec8f344c8d1a3cd3e2a76115cd6c28f1", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Option:Some(\"\");\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "11d0f5f527e21e6fa7f56c84e0e242c1e6a82ac1", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,10 @@\n-error: expected type, found `\"\"`\n-  --> $DIR/type-ascription-instead-of-variant.rs:3:25\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-variant.rs:3:19\n    |\n LL |     let _ = Option:Some(\"\");\n-   |                   -     ^^ expected type\n-   |                   |\n-   |                   help: maybe write a path separator here: `::`\n+   |                   ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "7436f83593d34bd79bcb6ec88948057bcd8adfcc", "filename": "tests/ui/type/ascription/issue-34255-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,13 +1,12 @@\n+// rustfix\n+\n struct Reactor {\n     input_cells: Vec<usize>,\n }\n \n impl Reactor {\n-    pub fn new() -> Self {\n+    pub fn new() -> Self { //~ ERROR struct literal body without path\n         input_cells: Vec::new()\n-        //~^ ERROR cannot find value `input_cells` in this scope\n-        //~| ERROR parenthesized type parameters may only be used with a `Fn` trait\n-        //~| ERROR missing generics for struct `Vec`\n     }\n }\n "}, {"sha": "254d36cb9479c5c14ec2528d012591690cfddd62", "filename": "tests/ui/type/ascription/issue-34255-1.stderr", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,36 +1,18 @@\n-error[E0425]: cannot find value `input_cells` in this scope\n-  --> $DIR/issue-34255-1.rs:7:9\n+error: struct literal body without path\n+  --> $DIR/issue-34255-1.rs:8:26\n    |\n-LL |         input_cells: Vec::new()\n-   |         ^^^^^^^^^^^ a field by this name exists in `Self`\n+LL |       pub fn new() -> Self {\n+   |  __________________________^\n+LL | |         input_cells: Vec::new()\n+LL | |     }\n+   | |_____^\n    |\n-help: you might have meant to write a `struct` literal\n+help: you might have forgotten to add the struct literal inside the block\n    |\n LL ~     pub fn new() -> Self { SomeStruct {\n LL |         input_cells: Vec::new()\n- ...\n-LL |\n-LL ~     }}\n-   |\n-\n-error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-34255-1.rs:7:27\n-   |\n-LL |         input_cells: Vec::new()\n-   |                           ^^^^^ only `Fn` traits may use parentheses\n-\n-error[E0107]: missing generics for struct `Vec`\n-  --> $DIR/issue-34255-1.rs:7:22\n-   |\n-LL |         input_cells: Vec::new()\n-   |                      ^^^ expected at least 1 generic argument\n-   |\n-help: add missing generic argument\n+LL ~     } }\n    |\n-LL |         input_cells: Vec<T>::new()\n-   |                         +++\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0107, E0214, E0425.\n-For more information about an error, try `rustc --explain E0107`."}, {"sha": "027c692f9003bc8c109f50e607b1e67c2ce52e98", "filename": "tests/ui/type/ascription/issue-47666.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,4 +1,4 @@\n // run-rustfix\n fn main() {\n-    let _ = Option::Some(vec![0, 1]); //~ ERROR expected type, found\n+    let _ = Option::Some(vec![0, 1]); //~ ERROR path separator must be a double colon\n }"}, {"sha": "e2f5d03ef74250bf9873e5083c3b54e906de710d", "filename": "tests/ui/type/ascription/issue-47666.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,4 +1,4 @@\n // run-rustfix\n fn main() {\n-    let _ = Option:Some(vec![0, 1]); //~ ERROR expected type, found\n+    let _ = Option:Some(vec![0, 1]); //~ ERROR path separator must be a double colon\n }"}, {"sha": "74d85a75c85c691f1ed86714725277597b515b96", "filename": "tests/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,16 +1,10 @@\n-error: expected type, found `<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0, 1]))`\n-  --> $DIR/issue-47666.rs:3:25\n+error: path separator must be a double colon\n+  --> $DIR/issue-47666.rs:3:19\n    |\n LL |     let _ = Option:Some(vec![0, 1]);\n-   |                   -     ^^^^^^^^^^\n-   |                   |     |\n-   |                   |     expected type\n-   |                   |     in this macro invocation\n-   |                   |     this macro call doesn't expand to a type\n-   |                   help: maybe write a path separator here: `::`\n+   |                   ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: this error originates in the macro `$crate::__rust_force_expr` which comes from the expansion of the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "48622663b4d5e2119c7b4ebcdd2d5779a57d0c07", "filename": "tests/ui/type/ascription/issue-54516.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -3,5 +3,5 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem::size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "9e71d2af1d32bed827da753bc8c139e29a959558", "filename": "tests/ui/type/ascription/issue-54516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -3,5 +3,5 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "a1371432f5ad6823870bae350164c0ebfdcaa681", "filename": "tests/ui/type/ascription/issue-54516.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,10 @@\n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-54516.rs:5:20\n+error: path separator must be a double colon\n+  --> $DIR/issue-54516.rs:5:28\n    |\n LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                    ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                            |\n-   |                            help: maybe write a path separator here: `::`\n+   |                            ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "016ad4a7e6a636e8a8b60aa544b4d987eb5dd50c", "filename": "tests/ui/type/ascription/issue-60933.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _: usize = std::mem::size_of::<u32>();\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "972bf2827f97f2b78fdcdbbcfa0a391a5021d013", "filename": "tests/ui/type/ascription/issue-60933.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _: usize = std::mem:size_of::<u32>();\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "0ec527ff5a9583f8efd0cc6256e085b040d63f7e", "filename": "tests/ui/type/ascription/issue-60933.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,12 +1,10 @@\n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-60933.rs:3:20\n+error: path separator must be a double colon\n+  --> $DIR/issue-60933.rs:3:28\n    |\n LL |     let _: usize = std::mem:size_of::<u32>();\n-   |                    ^^^^^^^^-^^^^^^^^^^^^^^\n-   |                            |\n-   |                            help: maybe write a path separator here: `::`\n+   |                            ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "4301fed2312e60bd53ebf4e9ed7e684814fa0f59", "filename": "tests/ui/type/missing-let-in-binding.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let mut _foo: i32 = 1;\n-    let _foo: i32 = 4; //~ ERROR type ascription is experimental\n+    let _foo: i32 = 4; //~ ERROR expected identifier, found `:`\n }"}, {"sha": "c0f91d98ff31f6ddaa560080414fc8a4495b8a49", "filename": "tests/ui/type/missing-let-in-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let mut _foo: i32 = 1;\n-    _foo: i32 = 4; //~ ERROR type ascription is experimental\n+    _foo: i32 = 4; //~ ERROR expected identifier, found `:`\n }"}, {"sha": "fc094e8cbad717a273a6b9e9ebf34c643dcd28e8", "filename": "tests/ui/type/missing-let-in-binding.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,16 +1,14 @@\n-error[E0658]: type ascription is experimental\n-  --> $DIR/missing-let-in-binding.rs:4:5\n+error: expected identifier, found `:`\n+  --> $DIR/missing-let-in-binding.rs:4:9\n    |\n LL |     _foo: i32 = 4;\n-   |     ^^^^^^^^^\n+   |         ^ expected identifier\n    |\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n help: you might have meant to introduce a new binding\n    |\n LL |     let _foo: i32 = 4;\n    |     +++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "e30e571386bd254ba86c0f48785468c5eaaf39cd", "filename": "tests/ui/type/type-ascription-instead-of-statement-end.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,10 +1,8 @@\n-#![feature(type_ascription)]\n-\n fn main() {\n-    println!(\"test\"):\n-    0; //~ ERROR expected type, found `0`\n+    println!(\"test\"): //~ ERROR statements are terminated with a semicolon\n+    0;\n }\n \n fn foo() {\n-    println!(\"test\"): 0; //~ ERROR expected type, found `0`\n+    println!(\"test\"): 0; //~ ERROR expected one of\n }"}, {"sha": "8c09e78bc5fbc97ca85178a93dca1d01db21ac96", "filename": "tests/ui/type/type-ascription-instead-of-statement-end.stderr", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,24 +1,16 @@\n-error: expected type, found `0`\n-  --> $DIR/type-ascription-instead-of-statement-end.rs:5:5\n+error: statements are terminated with a semicolon\n+  --> $DIR/type-ascription-instead-of-statement-end.rs:2:21\n    |\n LL |     println!(\"test\"):\n-   |                     - help: try using a semicolon: `;`\n-LL |     0;\n-   |     ^ expected type\n+   |                     ^ help: use a semicolon instead: `;`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: expected type, found `0`\n-  --> $DIR/type-ascription-instead-of-statement-end.rs:9:23\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-instead-of-statement-end.rs:7:21\n    |\n LL |     println!(\"test\"): 0;\n-   |                     - ^ expected type\n-   |                     |\n-   |                     tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   |                     ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1527bb7aa177ba543e13ff6280ecaf9281b9dc13", "filename": "tests/ui/type/type-ascription-precedence.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,10 +1,8 @@\n // Operator precedence of type ascription\n // Type ascription has very high precedence, the same as operator `as`\n-\n #![feature(type_ascription)]\n \n use std::ops::*;\n-\n struct S;\n struct Z;\n \n@@ -25,30 +23,34 @@ impl Deref for S {\n     fn deref(&self) -> &Z { panic!() }\n }\n \n-fn main() {\n-    &S: &S; // OK\n-    (&S): &S; // OK\n-    &(S: &S); //~ ERROR mismatched types\n+fn test1() {\n+    &S: &S; //~ ERROR expected one of\n+    (&S): &S;\n+    &(S: &S);\n+}\n+\n+fn test2() {\n+    *(S: Z); //~ ERROR expected identifier\n+}\n \n-    *S: Z; // OK\n-    (*S): Z; // OK\n-    *(S: Z); //~ ERROR mismatched types\n-    //~^ ERROR type `Z` cannot be dereferenced\n+fn test3() {\n+    -(S: Z); //~ ERROR expected identifier\n+}\n \n-    -S: Z; // OK\n-    (-S): Z; // OK\n-    -(S: Z); //~ ERROR mismatched types\n-    //~^ ERROR cannot apply unary operator `-` to type `Z`\n+fn test4() {\n+    (S + Z): Z; //~ ERROR expected one of\n+}\n \n-    S + Z: Z; // OK\n-    S + (Z: Z); // OK\n-    (S + Z): Z; //~ ERROR mismatched types\n+fn test5() {\n+    (S * Z): Z; //~ ERROR expected one of\n+}\n \n-    S * Z: Z; // OK\n-    S * (Z: Z); // OK\n-    (S * Z): Z; //~ ERROR mismatched types\n+fn test6() {\n+    S .. S: S; //~ ERROR expected identifier, found `:`\n+}\n \n-    S .. S: S; // OK\n-    S .. (S: S); // OK\n-    (S .. S): S; //~ ERROR mismatched types\n+fn test7() {\n+    (S .. S): S; //~ ERROR expected one of\n }\n+\n+fn main() {}"}, {"sha": "09cdc370309dc5d92f2a5bff791983a75f195245", "filename": "tests/ui/type/type-ascription-precedence.stderr", "status": "modified", "additions": 28, "deletions": 45, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,63 +1,46 @@\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:31:7\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-precedence.rs:27:7\n    |\n-LL |     &(S: &S);\n-   |       ^ expected `&S`, found `S`\n+LL |     &S: &S;\n+   |       ^ expected one of 8 possible tokens\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:35:7\n+error: expected identifier, found `:`\n+  --> $DIR/type-ascription-precedence.rs:33:8\n    |\n LL |     *(S: Z);\n-   |       ^ expected `Z`, found `S`\n+   |        ^ expected identifier\n \n-error[E0614]: type `Z` cannot be dereferenced\n-  --> $DIR/type-ascription-precedence.rs:35:5\n-   |\n-LL |     *(S: Z);\n-   |     ^^^^^^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:40:7\n-   |\n-LL |     -(S: Z);\n-   |       ^ expected `Z`, found `S`\n-\n-error[E0600]: cannot apply unary operator `-` to type `Z`\n-  --> $DIR/type-ascription-precedence.rs:40:5\n+error: expected identifier, found `:`\n+  --> $DIR/type-ascription-precedence.rs:37:8\n    |\n LL |     -(S: Z);\n-   |     ^^^^^^^ cannot apply unary operator `-`\n-   |\n-note: an implementation of `std::ops::Neg` might be missing for `Z`\n-  --> $DIR/type-ascription-precedence.rs:9:1\n-   |\n-LL | struct Z;\n-   | ^^^^^^^^ must implement `std::ops::Neg`\n-note: the trait `std::ops::Neg` must be implemented\n-  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |        ^ expected identifier\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:45:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-precedence.rs:41:12\n    |\n LL |     (S + Z): Z;\n-   |     ^^^^^^^ expected `Z`, found `S`\n+   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:49:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-precedence.rs:45:12\n    |\n LL |     (S * Z): Z;\n-   |     ^^^^^^^ expected `Z`, found `S`\n+   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:53:5\n+error: expected identifier, found `:`\n+  --> $DIR/type-ascription-precedence.rs:49:11\n    |\n-LL |     (S .. S): S;\n-   |     ^^^^^^^^ expected `S`, found `Range<S>`\n+LL |     S .. S: S;\n+   |           ^ expected identifier\n    |\n-   = note: expected struct `S`\n-              found struct `std::ops::Range<S>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-precedence.rs:53:13\n+   |\n+LL |     (S .. S): S;\n+   |             ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0308, E0600, E0614.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "847f33099732e61f7c0aa0679b60e544799fdd2e", "filename": "tests/ui/type/type-ascription-with-fn-call.fixed", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,9 +1,7 @@\n // run-rustfix\n-#![feature(type_ascription)]\n-\n fn main() {\n-    f()  ;\n-    f(); //~ ERROR expected type, found function\n+    f()  ; //~ ERROR statements are terminated with a semicolon\n+    f();\n }\n \n fn f() {}"}, {"sha": "1db48b0adc435faba4e57c0382f19a2a5278e533", "filename": "tests/ui/type/type-ascription-with-fn-call.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,9 +1,7 @@\n // run-rustfix\n-#![feature(type_ascription)]\n-\n fn main() {\n-    f()  :\n-    f(); //~ ERROR expected type, found function\n+    f()  : //~ ERROR statements are terminated with a semicolon\n+    f();\n }\n \n fn f() {}"}, {"sha": "e3afa497ac20155d55a58d412ebb90c774d2414e", "filename": "tests/ui/type/type-ascription-with-fn-call.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c33e47a495fbd7b22bce9ce32f2815991bc414/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr?ref=98c33e47a495fbd7b22bce9ce32f2815991bc414", "patch": "@@ -1,11 +1,10 @@\n-error[E0573]: expected type, found function `f`\n-  --> $DIR/type-ascription-with-fn-call.rs:6:5\n+error: statements are terminated with a semicolon\n+  --> $DIR/type-ascription-with-fn-call.rs:3:10\n    |\n LL |     f()  :\n-   |          - help: maybe you meant to write `;` here\n-LL |     f();\n-   |     ^^^ expecting a type here because of type ascription\n+   |          ^ help: use a semicolon instead: `;`\n+   |\n+   = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0573`."}]}