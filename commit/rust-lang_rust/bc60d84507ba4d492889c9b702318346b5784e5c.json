{"sha": "bc60d84507ba4d492889c9b702318346b5784e5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNjBkODQ1MDdiYTRkNDkyODg5YzliNzAyMzE4MzQ2YjU3ODRlNWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-17T05:57:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-18T21:07:35Z"}, "message": "core::pipes: Just reordering declarations", "tree": {"sha": "356cd3bf122f22108305e9c54caadb881097f8ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/356cd3bf122f22108305e9c54caadb881097f8ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc60d84507ba4d492889c9b702318346b5784e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc60d84507ba4d492889c9b702318346b5784e5c", "html_url": "https://github.com/rust-lang/rust/commit/bc60d84507ba4d492889c9b702318346b5784e5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc60d84507ba4d492889c9b702318346b5784e5c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "html_url": "https://github.com/rust-lang/rust/commit/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae"}], "stats": {"total": 95, "additions": 49, "deletions": 46}, "files": [{"sha": "60ec4fbfddb30c556099e74a450779307ade292c", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bc60d84507ba4d492889c9b702318346b5784e5c/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc60d84507ba4d492889c9b702318346b5784e5c/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=bc60d84507ba4d492889c9b702318346b5784e5c", "patch": "@@ -56,20 +56,6 @@ pub trait Peekable<T> {\n     fn peek(&self) -> bool;\n }\n \n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n-    }\n-}\n \n // Streams - Make pipes a little easier in general.\n \n@@ -322,38 +308,6 @@ pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n     unstable::exclusive(c)\n }\n \n-/// Receive a message from one of two endpoints.\n-pub trait Select2<T: Owned, U: Owned> {\n-    /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n-    /// Receive a message or fail if a connection closes.\n-    fn select(&self) -> Either<T, U>;\n-}\n-\n-impl<T: Owned, U: Owned,\n-     Left: Selectable + GenericPort<T>,\n-     Right: Selectable + GenericPort<U>>\n-    Select2<T, U> for (Left, Right) {\n-\n-    fn select(&self) -> Either<T, U> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.recv()),\n-            Right(()) => Right(rp.recv())\n-          }\n-        }\n-    }\n-\n-    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.try_recv()),\n-            Right(()) => Right(rp.try_recv())\n-          }\n-        }\n-    }\n-}\n-\n /*proto! oneshot (\n     Oneshot:send<T:Owned> {\n         send(T) -> !\n@@ -486,6 +440,55 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n     oneshot::client::try_send(chan, data).is_some()\n }\n \n+\n+\n+/// Returns the index of an endpoint that is ready to receive.\n+pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+    wait_many(endpoints)\n+}\n+\n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n+pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n+    match wait_many([a.header(), b.header()]) {\n+      0 => Left(()),\n+      1 => Right(()),\n+      _ => fail!(~\"wait returned unexpected index\")\n+    }\n+}\n+\n+/// Receive a message from one of two endpoints.\n+pub trait Select2<T: Owned, U: Owned> {\n+    /// Receive a message or return `None` if a connection closes.\n+    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n+    /// Receive a message or fail if a connection closes.\n+    fn select(&self) -> Either<T, U>;\n+}\n+\n+impl<T: Owned, U: Owned,\n+     Left: Selectable + GenericPort<T>,\n+     Right: Selectable + GenericPort<U>>\n+    Select2<T, U> for (Left, Right) {\n+\n+    fn select(&self) -> Either<T, U> {\n+        match *self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.recv()),\n+            Right(()) => Right(rp.recv())\n+          }\n+        }\n+    }\n+\n+    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n+        match *self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.try_recv()),\n+            Right(()) => Right(rp.try_recv())\n+          }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use either::Right;"}]}