{"sha": "39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZTQ0NGQ3MDE0NWNiZjYxZGRmZGQyMDI1NzJkOWM2YTdmMmZkM2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T10:58:49Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T10:58:49Z"}, "message": "remove ast::*Kind enums\n\nWith the new owned trees, we don't need an indirection here", "tree": {"sha": "8abfc129c17e978098b1b7455c801e898185e330", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8abfc129c17e978098b1b7455c801e898185e330"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "html_url": "https://github.com/rust-lang/rust/commit/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba2836245b64fffd9c8107a4ed511eba90583d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2836245b64fffd9c8107a4ed511eba90583d06", "html_url": "https://github.com/rust-lang/rust/commit/ba2836245b64fffd9c8107a4ed511eba90583d06"}], "stats": {"total": 787, "additions": 397, "deletions": 390}, "files": [{"sha": "9c57897013eeabcdaf83ceae00cec119228b3fe3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 339, "deletions": 345, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "patch": "@@ -591,34 +591,7 @@ impl EnumVariantList {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Expr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Expr {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n-            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n-            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR\n-            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR\n-            | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => {\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ExprKind {\n+pub enum Expr {\n     TupleExpr(TupleExpr),\n     ArrayExpr(ArrayExpr),\n     ParenExpr(ParenExpr),\n@@ -652,189 +625,235 @@ pub enum ExprKind {\n }\n impl From<TupleExpr> for Expr {\n     fn from(node: TupleExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TupleExpr(node)\n     }\n }\n impl From<ArrayExpr> for Expr {\n     fn from(node: ArrayExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ArrayExpr(node)\n     }\n }\n impl From<ParenExpr> for Expr {\n     fn from(node: ParenExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ParenExpr(node)\n     }\n }\n impl From<PathExpr> for Expr {\n     fn from(node: PathExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::PathExpr(node)\n     }\n }\n impl From<LambdaExpr> for Expr {\n     fn from(node: LambdaExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::LambdaExpr(node)\n     }\n }\n impl From<IfExpr> for Expr {\n     fn from(node: IfExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::IfExpr(node)\n     }\n }\n impl From<LoopExpr> for Expr {\n     fn from(node: LoopExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::LoopExpr(node)\n     }\n }\n impl From<ForExpr> for Expr {\n     fn from(node: ForExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ForExpr(node)\n     }\n }\n impl From<WhileExpr> for Expr {\n     fn from(node: WhileExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::WhileExpr(node)\n     }\n }\n impl From<ContinueExpr> for Expr {\n     fn from(node: ContinueExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ContinueExpr(node)\n     }\n }\n impl From<BreakExpr> for Expr {\n     fn from(node: BreakExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BreakExpr(node)\n     }\n }\n impl From<Label> for Expr {\n     fn from(node: Label) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::Label(node)\n     }\n }\n impl From<BlockExpr> for Expr {\n     fn from(node: BlockExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BlockExpr(node)\n     }\n }\n impl From<ReturnExpr> for Expr {\n     fn from(node: ReturnExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::ReturnExpr(node)\n     }\n }\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::MatchExpr(node)\n     }\n }\n impl From<StructLit> for Expr {\n     fn from(node: StructLit) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::StructLit(node)\n     }\n }\n impl From<CallExpr> for Expr {\n     fn from(node: CallExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::CallExpr(node)\n     }\n }\n impl From<IndexExpr> for Expr {\n     fn from(node: IndexExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::IndexExpr(node)\n     }\n }\n impl From<MethodCallExpr> for Expr {\n     fn from(node: MethodCallExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::MethodCallExpr(node)\n     }\n }\n impl From<FieldExpr> for Expr {\n     fn from(node: FieldExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::FieldExpr(node)\n     }\n }\n impl From<AwaitExpr> for Expr {\n     fn from(node: AwaitExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::AwaitExpr(node)\n     }\n }\n impl From<TryExpr> for Expr {\n     fn from(node: TryExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TryExpr(node)\n     }\n }\n impl From<TryBlockExpr> for Expr {\n     fn from(node: TryBlockExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::TryBlockExpr(node)\n     }\n }\n impl From<CastExpr> for Expr {\n     fn from(node: CastExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::CastExpr(node)\n     }\n }\n impl From<RefExpr> for Expr {\n     fn from(node: RefExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::RefExpr(node)\n     }\n }\n impl From<PrefixExpr> for Expr {\n     fn from(node: PrefixExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::PrefixExpr(node)\n     }\n }\n impl From<RangeExpr> for Expr {\n     fn from(node: RangeExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::RangeExpr(node)\n     }\n }\n impl From<BinExpr> for Expr {\n     fn from(node: BinExpr) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::BinExpr(node)\n     }\n }\n impl From<Literal> for Expr {\n     fn from(node: Literal) -> Expr {\n-        Expr { syntax: node.syntax }\n+        Expr::Literal(node)\n     }\n }\n impl From<MacroCall> for Expr {\n     fn from(node: MacroCall) -> Expr {\n-        Expr { syntax: node.syntax }\n-    }\n-}\n-impl Expr {\n-    pub fn kind(&self) -> ExprKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            TUPLE_EXPR => ExprKind::TupleExpr(TupleExpr { syntax }),\n-            ARRAY_EXPR => ExprKind::ArrayExpr(ArrayExpr { syntax }),\n-            PAREN_EXPR => ExprKind::ParenExpr(ParenExpr { syntax }),\n-            PATH_EXPR => ExprKind::PathExpr(PathExpr { syntax }),\n-            LAMBDA_EXPR => ExprKind::LambdaExpr(LambdaExpr { syntax }),\n-            IF_EXPR => ExprKind::IfExpr(IfExpr { syntax }),\n-            LOOP_EXPR => ExprKind::LoopExpr(LoopExpr { syntax }),\n-            FOR_EXPR => ExprKind::ForExpr(ForExpr { syntax }),\n-            WHILE_EXPR => ExprKind::WhileExpr(WhileExpr { syntax }),\n-            CONTINUE_EXPR => ExprKind::ContinueExpr(ContinueExpr { syntax }),\n-            BREAK_EXPR => ExprKind::BreakExpr(BreakExpr { syntax }),\n-            LABEL => ExprKind::Label(Label { syntax }),\n-            BLOCK_EXPR => ExprKind::BlockExpr(BlockExpr { syntax }),\n-            RETURN_EXPR => ExprKind::ReturnExpr(ReturnExpr { syntax }),\n-            MATCH_EXPR => ExprKind::MatchExpr(MatchExpr { syntax }),\n-            STRUCT_LIT => ExprKind::StructLit(StructLit { syntax }),\n-            CALL_EXPR => ExprKind::CallExpr(CallExpr { syntax }),\n-            INDEX_EXPR => ExprKind::IndexExpr(IndexExpr { syntax }),\n-            METHOD_CALL_EXPR => ExprKind::MethodCallExpr(MethodCallExpr { syntax }),\n-            FIELD_EXPR => ExprKind::FieldExpr(FieldExpr { syntax }),\n-            AWAIT_EXPR => ExprKind::AwaitExpr(AwaitExpr { syntax }),\n-            TRY_EXPR => ExprKind::TryExpr(TryExpr { syntax }),\n-            TRY_BLOCK_EXPR => ExprKind::TryBlockExpr(TryBlockExpr { syntax }),\n-            CAST_EXPR => ExprKind::CastExpr(CastExpr { syntax }),\n-            REF_EXPR => ExprKind::RefExpr(RefExpr { syntax }),\n-            PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr { syntax }),\n-            RANGE_EXPR => ExprKind::RangeExpr(RangeExpr { syntax }),\n-            BIN_EXPR => ExprKind::BinExpr(BinExpr { syntax }),\n-            LITERAL => ExprKind::Literal(Literal { syntax }),\n-            MACRO_CALL => ExprKind::MacroCall(MacroCall { syntax }),\n-            _ => unreachable!(),\n+        Expr::MacroCall(node)\n+    }\n+}\n+impl AstNode for Expr {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n+            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n+            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR\n+            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR\n+            | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n+            ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),\n+            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n+            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n+            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),\n+            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n+            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n+            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n+            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n+            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n+            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n+            LABEL => Expr::Label(Label { syntax }),\n+            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),\n+            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n+            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n+            STRUCT_LIT => Expr::StructLit(StructLit { syntax }),\n+            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),\n+            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),\n+            METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n+            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n+            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n+            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n+            TRY_BLOCK_EXPR => Expr::TryBlockExpr(TryBlockExpr { syntax }),\n+            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n+            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),\n+            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),\n+            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n+            LITERAL => Expr::Literal(Literal { syntax }),\n+            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Expr::TupleExpr(it) => &it.syntax,\n+            Expr::ArrayExpr(it) => &it.syntax,\n+            Expr::ParenExpr(it) => &it.syntax,\n+            Expr::PathExpr(it) => &it.syntax,\n+            Expr::LambdaExpr(it) => &it.syntax,\n+            Expr::IfExpr(it) => &it.syntax,\n+            Expr::LoopExpr(it) => &it.syntax,\n+            Expr::ForExpr(it) => &it.syntax,\n+            Expr::WhileExpr(it) => &it.syntax,\n+            Expr::ContinueExpr(it) => &it.syntax,\n+            Expr::BreakExpr(it) => &it.syntax,\n+            Expr::Label(it) => &it.syntax,\n+            Expr::BlockExpr(it) => &it.syntax,\n+            Expr::ReturnExpr(it) => &it.syntax,\n+            Expr::MatchExpr(it) => &it.syntax,\n+            Expr::StructLit(it) => &it.syntax,\n+            Expr::CallExpr(it) => &it.syntax,\n+            Expr::IndexExpr(it) => &it.syntax,\n+            Expr::MethodCallExpr(it) => &it.syntax,\n+            Expr::FieldExpr(it) => &it.syntax,\n+            Expr::AwaitExpr(it) => &it.syntax,\n+            Expr::TryExpr(it) => &it.syntax,\n+            Expr::TryBlockExpr(it) => &it.syntax,\n+            Expr::CastExpr(it) => &it.syntax,\n+            Expr::RefExpr(it) => &it.syntax,\n+            Expr::PrefixExpr(it) => &it.syntax,\n+            Expr::RangeExpr(it) => &it.syntax,\n+            Expr::BinExpr(it) => &it.syntax,\n+            Expr::Literal(it) => &it.syntax,\n+            Expr::MacroCall(it) => &it.syntax,\n         }\n     }\n }\n@@ -1167,55 +1186,47 @@ impl ImplBlock {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ImplItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for ImplItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ImplItemKind {\n+pub enum ImplItem {\n     FnDef(FnDef),\n     TypeAliasDef(TypeAliasDef),\n     ConstDef(ConstDef),\n }\n impl From<FnDef> for ImplItem {\n     fn from(node: FnDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::FnDef(node)\n     }\n }\n impl From<TypeAliasDef> for ImplItem {\n     fn from(node: TypeAliasDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::TypeAliasDef(node)\n     }\n }\n impl From<ConstDef> for ImplItem {\n     fn from(node: ConstDef) -> ImplItem {\n-        ImplItem { syntax: node.syntax }\n+        ImplItem::ConstDef(node)\n     }\n }\n-impl ImplItem {\n-    pub fn kind(&self) -> ImplItemKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            FN_DEF => ImplItemKind::FnDef(FnDef { syntax }),\n-            TYPE_ALIAS_DEF => ImplItemKind::TypeAliasDef(TypeAliasDef { syntax }),\n-            CONST_DEF => ImplItemKind::ConstDef(ConstDef { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for ImplItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            FN_DEF => ImplItem::FnDef(FnDef { syntax }),\n+            TYPE_ALIAS_DEF => ImplItem::TypeAliasDef(TypeAliasDef { syntax }),\n+            CONST_DEF => ImplItem::ConstDef(ConstDef { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            ImplItem::FnDef(it) => &it.syntax,\n+            ImplItem::TypeAliasDef(it) => &it.syntax,\n+            ImplItem::ConstDef(it) => &it.syntax,\n         }\n     }\n }\n@@ -1774,29 +1785,7 @@ impl Module {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ModuleItem {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for ModuleItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM\n-            | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum ModuleItemKind {\n+pub enum ModuleItem {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n     FnDef(FnDef),\n@@ -1811,75 +1800,97 @@ pub enum ModuleItemKind {\n }\n impl From<StructDef> for ModuleItem {\n     fn from(node: StructDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::StructDef(node)\n     }\n }\n impl From<EnumDef> for ModuleItem {\n     fn from(node: EnumDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::EnumDef(node)\n     }\n }\n impl From<FnDef> for ModuleItem {\n     fn from(node: FnDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::FnDef(node)\n     }\n }\n impl From<TraitDef> for ModuleItem {\n     fn from(node: TraitDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::TraitDef(node)\n     }\n }\n impl From<TypeAliasDef> for ModuleItem {\n     fn from(node: TypeAliasDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::TypeAliasDef(node)\n     }\n }\n impl From<ImplBlock> for ModuleItem {\n     fn from(node: ImplBlock) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ImplBlock(node)\n     }\n }\n impl From<UseItem> for ModuleItem {\n     fn from(node: UseItem) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::UseItem(node)\n     }\n }\n impl From<ExternCrateItem> for ModuleItem {\n     fn from(node: ExternCrateItem) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ExternCrateItem(node)\n     }\n }\n impl From<ConstDef> for ModuleItem {\n     fn from(node: ConstDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::ConstDef(node)\n     }\n }\n impl From<StaticDef> for ModuleItem {\n     fn from(node: StaticDef) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::StaticDef(node)\n     }\n }\n impl From<Module> for ModuleItem {\n     fn from(node: Module) -> ModuleItem {\n-        ModuleItem { syntax: node.syntax }\n+        ModuleItem::Module(node)\n     }\n }\n-impl ModuleItem {\n-    pub fn kind(&self) -> ModuleItemKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            STRUCT_DEF => ModuleItemKind::StructDef(StructDef { syntax }),\n-            ENUM_DEF => ModuleItemKind::EnumDef(EnumDef { syntax }),\n-            FN_DEF => ModuleItemKind::FnDef(FnDef { syntax }),\n-            TRAIT_DEF => ModuleItemKind::TraitDef(TraitDef { syntax }),\n-            TYPE_ALIAS_DEF => ModuleItemKind::TypeAliasDef(TypeAliasDef { syntax }),\n-            IMPL_BLOCK => ModuleItemKind::ImplBlock(ImplBlock { syntax }),\n-            USE_ITEM => ModuleItemKind::UseItem(UseItem { syntax }),\n-            EXTERN_CRATE_ITEM => ModuleItemKind::ExternCrateItem(ExternCrateItem { syntax }),\n-            CONST_DEF => ModuleItemKind::ConstDef(ConstDef { syntax }),\n-            STATIC_DEF => ModuleItemKind::StaticDef(StaticDef { syntax }),\n-            MODULE => ModuleItemKind::Module(Module { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for ModuleItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM\n+            | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            STRUCT_DEF => ModuleItem::StructDef(StructDef { syntax }),\n+            ENUM_DEF => ModuleItem::EnumDef(EnumDef { syntax }),\n+            FN_DEF => ModuleItem::FnDef(FnDef { syntax }),\n+            TRAIT_DEF => ModuleItem::TraitDef(TraitDef { syntax }),\n+            TYPE_ALIAS_DEF => ModuleItem::TypeAliasDef(TypeAliasDef { syntax }),\n+            IMPL_BLOCK => ModuleItem::ImplBlock(ImplBlock { syntax }),\n+            USE_ITEM => ModuleItem::UseItem(UseItem { syntax }),\n+            EXTERN_CRATE_ITEM => ModuleItem::ExternCrateItem(ExternCrateItem { syntax }),\n+            CONST_DEF => ModuleItem::ConstDef(ConstDef { syntax }),\n+            STATIC_DEF => ModuleItem::StaticDef(StaticDef { syntax }),\n+            MODULE => ModuleItem::Module(Module { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            ModuleItem::StructDef(it) => &it.syntax,\n+            ModuleItem::EnumDef(it) => &it.syntax,\n+            ModuleItem::FnDef(it) => &it.syntax,\n+            ModuleItem::TraitDef(it) => &it.syntax,\n+            ModuleItem::TypeAliasDef(it) => &it.syntax,\n+            ModuleItem::ImplBlock(it) => &it.syntax,\n+            ModuleItem::UseItem(it) => &it.syntax,\n+            ModuleItem::ExternCrateItem(it) => &it.syntax,\n+            ModuleItem::ConstDef(it) => &it.syntax,\n+            ModuleItem::StaticDef(it) => &it.syntax,\n+            ModuleItem::Module(it) => &it.syntax,\n         }\n     }\n }\n@@ -2069,48 +2080,39 @@ impl AstNode for NeverType {\n }\n impl NeverType {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NominalDef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for NominalDef {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            STRUCT_DEF | ENUM_DEF => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum NominalDefKind {\n+pub enum NominalDef {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n }\n impl From<StructDef> for NominalDef {\n     fn from(node: StructDef) -> NominalDef {\n-        NominalDef { syntax: node.syntax }\n+        NominalDef::StructDef(node)\n     }\n }\n impl From<EnumDef> for NominalDef {\n     fn from(node: EnumDef) -> NominalDef {\n-        NominalDef { syntax: node.syntax }\n+        NominalDef::EnumDef(node)\n     }\n }\n-impl NominalDef {\n-    pub fn kind(&self) -> NominalDefKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            STRUCT_DEF => NominalDefKind::StructDef(StructDef { syntax }),\n-            ENUM_DEF => NominalDefKind::EnumDef(EnumDef { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for NominalDef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_DEF | ENUM_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            STRUCT_DEF => NominalDef::StructDef(StructDef { syntax }),\n+            ENUM_DEF => NominalDef::EnumDef(EnumDef { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            NominalDef::StructDef(it) => &it.syntax,\n+            NominalDef::EnumDef(it) => &it.syntax,\n         }\n     }\n }\n@@ -2232,29 +2234,7 @@ impl ParenType {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Pat {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Pat {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT\n-            | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum PatKind {\n+pub enum Pat {\n     RefPat(RefPat),\n     BindPat(BindPat),\n     PlaceholderPat(PlaceholderPat),\n@@ -2268,69 +2248,90 @@ pub enum PatKind {\n }\n impl From<RefPat> for Pat {\n     fn from(node: RefPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::RefPat(node)\n     }\n }\n impl From<BindPat> for Pat {\n     fn from(node: BindPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::BindPat(node)\n     }\n }\n impl From<PlaceholderPat> for Pat {\n     fn from(node: PlaceholderPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::PlaceholderPat(node)\n     }\n }\n impl From<PathPat> for Pat {\n     fn from(node: PathPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::PathPat(node)\n     }\n }\n impl From<StructPat> for Pat {\n     fn from(node: StructPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::StructPat(node)\n     }\n }\n impl From<TupleStructPat> for Pat {\n     fn from(node: TupleStructPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::TupleStructPat(node)\n     }\n }\n impl From<TuplePat> for Pat {\n     fn from(node: TuplePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::TuplePat(node)\n     }\n }\n impl From<SlicePat> for Pat {\n     fn from(node: SlicePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::SlicePat(node)\n     }\n }\n impl From<RangePat> for Pat {\n     fn from(node: RangePat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::RangePat(node)\n     }\n }\n impl From<LiteralPat> for Pat {\n     fn from(node: LiteralPat) -> Pat {\n-        Pat { syntax: node.syntax }\n+        Pat::LiteralPat(node)\n     }\n }\n-impl Pat {\n-    pub fn kind(&self) -> PatKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            REF_PAT => PatKind::RefPat(RefPat { syntax }),\n-            BIND_PAT => PatKind::BindPat(BindPat { syntax }),\n-            PLACEHOLDER_PAT => PatKind::PlaceholderPat(PlaceholderPat { syntax }),\n-            PATH_PAT => PatKind::PathPat(PathPat { syntax }),\n-            STRUCT_PAT => PatKind::StructPat(StructPat { syntax }),\n-            TUPLE_STRUCT_PAT => PatKind::TupleStructPat(TupleStructPat { syntax }),\n-            TUPLE_PAT => PatKind::TuplePat(TuplePat { syntax }),\n-            SLICE_PAT => PatKind::SlicePat(SlicePat { syntax }),\n-            RANGE_PAT => PatKind::RangePat(RangePat { syntax }),\n-            LITERAL_PAT => PatKind::LiteralPat(LiteralPat { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for Pat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT\n+            | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            REF_PAT => Pat::RefPat(RefPat { syntax }),\n+            BIND_PAT => Pat::BindPat(BindPat { syntax }),\n+            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n+            PATH_PAT => Pat::PathPat(PathPat { syntax }),\n+            STRUCT_PAT => Pat::StructPat(StructPat { syntax }),\n+            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n+            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n+            SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),\n+            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n+            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Pat::RefPat(it) => &it.syntax,\n+            Pat::BindPat(it) => &it.syntax,\n+            Pat::PlaceholderPat(it) => &it.syntax,\n+            Pat::PathPat(it) => &it.syntax,\n+            Pat::StructPat(it) => &it.syntax,\n+            Pat::TupleStructPat(it) => &it.syntax,\n+            Pat::TuplePat(it) => &it.syntax,\n+            Pat::SlicePat(it) => &it.syntax,\n+            Pat::RangePat(it) => &it.syntax,\n+            Pat::LiteralPat(it) => &it.syntax,\n         }\n     }\n }\n@@ -2951,48 +2952,39 @@ impl StaticDef {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Stmt {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for Stmt {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            EXPR_STMT | LET_STMT => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum StmtKind {\n+pub enum Stmt {\n     ExprStmt(ExprStmt),\n     LetStmt(LetStmt),\n }\n impl From<ExprStmt> for Stmt {\n     fn from(node: ExprStmt) -> Stmt {\n-        Stmt { syntax: node.syntax }\n+        Stmt::ExprStmt(node)\n     }\n }\n impl From<LetStmt> for Stmt {\n     fn from(node: LetStmt) -> Stmt {\n-        Stmt { syntax: node.syntax }\n+        Stmt::LetStmt(node)\n     }\n }\n-impl Stmt {\n-    pub fn kind(&self) -> StmtKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            EXPR_STMT => StmtKind::ExprStmt(ExprStmt { syntax }),\n-            LET_STMT => StmtKind::LetStmt(LetStmt { syntax }),\n-            _ => unreachable!(),\n+impl AstNode for Stmt {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            EXPR_STMT | LET_STMT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),\n+            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Stmt::ExprStmt(it) => &it.syntax,\n+            Stmt::LetStmt(it) => &it.syntax,\n         }\n     }\n }\n@@ -3508,30 +3500,7 @@ impl TypeParamList {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeRef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl AstNode for TypeRef {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n-            | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n-            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.syntax\n-    }\n-}\n-pub enum TypeRefKind {\n+pub enum TypeRef {\n     ParenType(ParenType),\n     TupleType(TupleType),\n     NeverType(NeverType),\n@@ -3548,87 +3517,112 @@ pub enum TypeRefKind {\n }\n impl From<ParenType> for TypeRef {\n     fn from(node: ParenType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ParenType(node)\n     }\n }\n impl From<TupleType> for TypeRef {\n     fn from(node: TupleType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::TupleType(node)\n     }\n }\n impl From<NeverType> for TypeRef {\n     fn from(node: NeverType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::NeverType(node)\n     }\n }\n impl From<PathType> for TypeRef {\n     fn from(node: PathType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PathType(node)\n     }\n }\n impl From<PointerType> for TypeRef {\n     fn from(node: PointerType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PointerType(node)\n     }\n }\n impl From<ArrayType> for TypeRef {\n     fn from(node: ArrayType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ArrayType(node)\n     }\n }\n impl From<SliceType> for TypeRef {\n     fn from(node: SliceType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::SliceType(node)\n     }\n }\n impl From<ReferenceType> for TypeRef {\n     fn from(node: ReferenceType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ReferenceType(node)\n     }\n }\n impl From<PlaceholderType> for TypeRef {\n     fn from(node: PlaceholderType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::PlaceholderType(node)\n     }\n }\n impl From<FnPointerType> for TypeRef {\n     fn from(node: FnPointerType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::FnPointerType(node)\n     }\n }\n impl From<ForType> for TypeRef {\n     fn from(node: ForType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ForType(node)\n     }\n }\n impl From<ImplTraitType> for TypeRef {\n     fn from(node: ImplTraitType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n+        TypeRef::ImplTraitType(node)\n     }\n }\n impl From<DynTraitType> for TypeRef {\n     fn from(node: DynTraitType) -> TypeRef {\n-        TypeRef { syntax: node.syntax }\n-    }\n-}\n-impl TypeRef {\n-    pub fn kind(&self) -> TypeRefKind {\n-        let syntax = self.syntax.clone();\n-        match syntax.kind() {\n-            PAREN_TYPE => TypeRefKind::ParenType(ParenType { syntax }),\n-            TUPLE_TYPE => TypeRefKind::TupleType(TupleType { syntax }),\n-            NEVER_TYPE => TypeRefKind::NeverType(NeverType { syntax }),\n-            PATH_TYPE => TypeRefKind::PathType(PathType { syntax }),\n-            POINTER_TYPE => TypeRefKind::PointerType(PointerType { syntax }),\n-            ARRAY_TYPE => TypeRefKind::ArrayType(ArrayType { syntax }),\n-            SLICE_TYPE => TypeRefKind::SliceType(SliceType { syntax }),\n-            REFERENCE_TYPE => TypeRefKind::ReferenceType(ReferenceType { syntax }),\n-            PLACEHOLDER_TYPE => TypeRefKind::PlaceholderType(PlaceholderType { syntax }),\n-            FN_POINTER_TYPE => TypeRefKind::FnPointerType(FnPointerType { syntax }),\n-            FOR_TYPE => TypeRefKind::ForType(ForType { syntax }),\n-            IMPL_TRAIT_TYPE => TypeRefKind::ImplTraitType(ImplTraitType { syntax }),\n-            DYN_TRAIT_TYPE => TypeRefKind::DynTraitType(DynTraitType { syntax }),\n-            _ => unreachable!(),\n+        TypeRef::DynTraitType(node)\n+    }\n+}\n+impl AstNode for TypeRef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n+            | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n+            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            PAREN_TYPE => TypeRef::ParenType(ParenType { syntax }),\n+            TUPLE_TYPE => TypeRef::TupleType(TupleType { syntax }),\n+            NEVER_TYPE => TypeRef::NeverType(NeverType { syntax }),\n+            PATH_TYPE => TypeRef::PathType(PathType { syntax }),\n+            POINTER_TYPE => TypeRef::PointerType(PointerType { syntax }),\n+            ARRAY_TYPE => TypeRef::ArrayType(ArrayType { syntax }),\n+            SLICE_TYPE => TypeRef::SliceType(SliceType { syntax }),\n+            REFERENCE_TYPE => TypeRef::ReferenceType(ReferenceType { syntax }),\n+            PLACEHOLDER_TYPE => TypeRef::PlaceholderType(PlaceholderType { syntax }),\n+            FN_POINTER_TYPE => TypeRef::FnPointerType(FnPointerType { syntax }),\n+            FOR_TYPE => TypeRef::ForType(ForType { syntax }),\n+            IMPL_TRAIT_TYPE => TypeRef::ImplTraitType(ImplTraitType { syntax }),\n+            DYN_TRAIT_TYPE => TypeRef::DynTraitType(DynTraitType { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            TypeRef::ParenType(it) => &it.syntax,\n+            TypeRef::TupleType(it) => &it.syntax,\n+            TypeRef::NeverType(it) => &it.syntax,\n+            TypeRef::PathType(it) => &it.syntax,\n+            TypeRef::PointerType(it) => &it.syntax,\n+            TypeRef::ArrayType(it) => &it.syntax,\n+            TypeRef::SliceType(it) => &it.syntax,\n+            TypeRef::ReferenceType(it) => &it.syntax,\n+            TypeRef::PlaceholderType(it) => &it.syntax,\n+            TypeRef::FnPointerType(it) => &it.syntax,\n+            TypeRef::ForType(it) => &it.syntax,\n+            TypeRef::ImplTraitType(it) => &it.syntax,\n+            TypeRef::DynTraitType(it) => &it.syntax,\n         }\n     }\n }"}, {"sha": "2bced18678afd063c6c06d533b2cb5a64d809145", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "patch": "@@ -186,8 +186,8 @@ fn api_walkthrough() {\n     // Let's fetch the `foo` function.\n     let mut func = None;\n     for item in file.items() {\n-        match item.kind() {\n-            ast::ModuleItemKind::FnDef(f) => func = Some(f),\n+        match item {\n+            ast::ModuleItem::FnDef(f) => func = Some(f),\n             _ => unreachable!(),\n         }\n     }\n@@ -206,12 +206,12 @@ fn api_walkthrough() {\n     let block: ast::Block = func.body().unwrap();\n     let expr: ast::Expr = block.expr().unwrap();\n \n-    // \"Enum\"-like nodes are represented using the \"kind\" pattern. It allows us\n-    // to match exhaustively against all flavors of nodes, while maintaining\n-    // internal representation flexibility. The drawback is that one can't write\n-    // nested matches as one pattern.\n-    let bin_expr: ast::BinExpr = match expr.kind() {\n-        ast::ExprKind::BinExpr(e) => e,\n+    // Enums are used to group related ast nodes together, and can be used for\n+    // matching. However, because there are no public fields, it's possible to\n+    // match only the top level enum: that is the price we pay for increased API\n+    // flexibility\n+    let bin_expr: &ast::BinExpr = match &expr {\n+        ast::Expr::BinExpr(e) => e,\n         _ => unreachable!(),\n     };\n "}, {"sha": "01d092d4844a0a1d495a04b6bf90ba64a68cd60d", "filename": "crates/ra_tools/src/boilerplate_gen.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tools%2Fsrc%2Fboilerplate_gen.rs?ref=39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "patch": "@@ -37,41 +37,72 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n             ast_node.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n         let name = format_ident!(\"{}\", name);\n \n-        let kinds = if variants.is_empty() { vec![name.clone()] } else { variants.clone() }\n-            .into_iter()\n-            .map(|name| format_ident!(\"{}\", name.to_string().to_shouty_snake_case()))\n-            .collect::<Vec<_>>();\n+        let adt = if variants.is_empty() {\n+            let kind = format_ident!(\"{}\", name.to_string().to_shouty_snake_case());\n+            quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub struct #name {\n+                    pub(crate) syntax: SyntaxNode,\n+                }\n \n-        let variants = if variants.is_empty() {\n-            None\n+                impl AstNode for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #kind => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                    }\n+                    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+                }\n+            }\n         } else {\n-            let kind_enum = format_ident!(\"{}Kind\", name);\n-            Some(quote!(\n-                pub enum #kind_enum {\n+            let kinds = variants\n+                .iter()\n+                .map(|name| format_ident!(\"{}\", name.to_string().to_shouty_snake_case()))\n+                .collect::<Vec<_>>();\n+\n+            quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub enum #name {\n                     #(#variants(#variants),)*\n                 }\n \n                 #(\n                 impl From<#variants> for #name {\n                     fn from(node: #variants) -> #name {\n-                        #name { syntax: node.syntax }\n+                        #name::#variants(node)\n                     }\n                 }\n                 )*\n \n-                impl #name {\n-                    pub fn kind(&self) -> #kind_enum {\n-                        let syntax = self.syntax.clone();\n-                        match syntax.kind() {\n+                impl AstNode for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                        let res = match syntax.kind() {\n                             #(\n-                            #kinds =>\n-                                #kind_enum::#variants(#variants { syntax }),\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &SyntaxNode {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n                             )*\n-                            _ => unreachable!(),\n                         }\n                     }\n                 }\n-            ))\n+            }\n         };\n \n         let traits = ast_node.traits.iter().map(|trait_name| {\n@@ -105,25 +136,7 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n         });\n \n         quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name {\n-                pub(crate) syntax: SyntaxNode,\n-            }\n-\n-            impl AstNode for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #(#kinds)|* => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n-                }\n-                fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-            }\n-\n-            #variants\n+            #adt\n \n             #(#traits)*\n "}]}