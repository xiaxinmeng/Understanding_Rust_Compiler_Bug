{"sha": "cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNmUzZTY0MzEzM2ZjMWM2Y2RmZDYwNjc0NDUyMzZmOWI3NzZjN2M=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-27T00:36:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "If a \"start\" lang item incl. MIR is present, run that instead of running main directly\n\nThis fixes the memory leaks when running a simple \"Hello World\" with MIR-libstd", "tree": {"sha": "20a357de2c3290da7dad8b68964307edd798598e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a357de2c3290da7dad8b68964307edd798598e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "html_url": "https://github.com/rust-lang/rust/commit/cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "720c5f874ea2eeef247eb8dddd2dcf4b93dada7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/720c5f874ea2eeef247eb8dddd2dcf4b93dada7d", "html_url": "https://github.com/rust-lang/rust/commit/720c5f874ea2eeef247eb8dddd2dcf4b93dada7d"}], "stats": {"total": 203, "additions": 136, "deletions": 67}, "files": [{"sha": "4a82d45493b887d9f7389dca9dca6406e3a9310a", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "patch": "@@ -84,7 +84,7 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n                     if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n                         let did = self.1.hir.body_owner_def_id(body_id);\n                         println!(\"running test: {}\", self.1.hir.def_path(did).to_string(self.1));\n-                        miri::eval_main(self.1, did, self.0);\n+                        miri::eval_main(self.1, did, None, self.0);\n                         self.2.session.abort_if_errors();\n                     }\n                 }\n@@ -95,7 +95,9 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n     } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        miri::eval_main(tcx, entry_def_id, limits);\n+        let start_wrapper = tcx.lang_items.start_fn()\n+                                      .and_then(|start_fn| if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n+        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n \n         state.session.abort_if_errors();\n     } else {"}, {"sha": "9a57e75da090b348a0526af865d91866e20c2aff", "filename": "src/eval_context.rs", "status": "modified", "additions": 105, "deletions": 46, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "patch": "@@ -126,6 +126,7 @@ impl Default for ResourceLimits {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+        // Register array drop glue code\n         let source_info = mir::SourceInfo {\n             span: DUMMY_SP,\n             scope: mir::ARGUMENT_VISIBILITY_SCOPE\n@@ -852,7 +853,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let fn_ptr = self.memory.create_fn_alloc(instance);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n-                        ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                        ref other => bug!(\"closure fn pointer on {:?}\", other),\n                     },\n                 }\n             }\n@@ -1676,62 +1677,120 @@ impl<'tcx> Frame<'tcx> {\n \n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n     limits: ResourceLimits,\n ) {\n-    let mut ecx = EvalContext::new(tcx, limits);\n-    let instance = ty::Instance::mono(tcx, def_id);\n-    let mir = ecx.load_mir(instance.def).expect(\"main function's MIR not found\");\n-\n-    if !mir.return_ty.is_nil() || mir.arg_count != 0 {\n-        let msg = \"miri does not support main functions without `fn()` type signatures\";\n-        tcx.sess.err(&EvalError::Unimplemented(String::from(msg)).to_string());\n-        return;\n-    }\n-\n-    ecx.push_stack_frame(\n-        instance,\n-        DUMMY_SP,\n-        mir,\n-        Lvalue::from_ptr(Pointer::zst_ptr()),\n-        StackPopCleanup::None,\n-    ).expect(\"could not allocate first stack frame\");\n-\n-    loop {\n-        match ecx.step() {\n-            Ok(true) => {}\n-            Ok(false) => {\n-                let leaks = ecx.memory.leak_report();\n-                if leaks != 0 {\n-                    tcx.sess.err(\"the evaluated program leaked memory\");\n-                }\n-                return;\n+    fn run_main<'a, 'tcx: 'a>(\n+        ecx: &mut EvalContext<'a, 'tcx>,\n+        main_id: DefId,\n+        start_wrapper: Option<DefId>,\n+    ) -> EvalResult<'tcx> {\n+        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n+        let main_mir = ecx.load_mir(main_instance.def)?;\n+\n+        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n+            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+        }\n+\n+        if let Some(start_id) = start_wrapper {\n+            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n+            let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+            if start_mir.arg_count != 3 {\n+                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n             }\n-            Err(e) => {\n-                report(tcx, &ecx, e);\n-                return;\n+\n+            // Push our stack frame\n+            ecx.push_stack_frame(\n+                start_instance,\n+                start_mir.span,\n+                start_mir,\n+                Lvalue::from_ptr(Pointer::zst_ptr()), // we'll fix the return lvalue later\n+                StackPopCleanup::None,\n+            )?;\n+\n+            let mut args = ecx.frame().mir.args_iter();\n+\n+            // First argument: pointer to main()\n+            let main_ptr = ecx.memory.create_fn_alloc(main_instance);\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let main_ty = main_instance.def.def_ty(ecx.tcx);\n+            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig());\n+            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n+\n+            // Second argument (argc): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.types.isize;\n+            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+\n+            // Third argument (argv): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+            ecx.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, ty)?;\n+        } else {\n+            ecx.push_stack_frame(\n+                main_instance,\n+                main_mir.span,\n+                main_mir,\n+                Lvalue::from_ptr(Pointer::zst_ptr()),\n+                StackPopCleanup::None,\n+            )?;\n+        }\n+\n+        // Allocate memory for the return value.  We have to do this when a stack frame was already pushed as the type code below\n+        // calls EvalContext::substs, which needs a frame to be allocated (?!?)\n+        let ret_ptr = {\n+            let ty = ecx.tcx.types.isize;\n+            let layout = ecx.type_layout(ty)?;\n+            let size = layout.size(&ecx.tcx.data_layout).bytes();\n+            let align = layout.align(&ecx.tcx.data_layout).pref(); // FIXME is this right?\n+            ecx.memory.allocate(size, align)?\n+        };\n+        ecx.frame_mut().return_lvalue = Lvalue::from_ptr(ret_ptr);\n+\n+        loop {\n+            if !ecx.step()? {\n+                ecx.memory.deallocate(ret_ptr)?;\n+                return Ok(());\n+            }\n+        }\n+    }\n+\n+    let mut ecx = EvalContext::new(tcx, limits);\n+    match run_main(&mut ecx, main_id, start_wrapper) {\n+        Ok(()) => {\n+            let leaks = ecx.memory.leak_report();\n+            if leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n             }\n         }\n+        Err(e) => {\n+            report(tcx, &ecx, e);\n+        }\n     }\n }\n \n fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n-    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n-    let block = &frame.mir.basic_blocks()[frame.block];\n-    let span = if frame.stmt < block.statements.len() {\n-        block.statements[frame.stmt].source_info.span\n-    } else {\n-        block.terminator().source_info.span\n-    };\n-    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n-        if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n-            err.span_note(span, \"inside call to closure\");\n-            continue;\n+    if let Some(frame) = ecx.stack().last() {\n+        let block = &frame.mir.basic_blocks()[frame.block];\n+        let span = if frame.stmt < block.statements.len() {\n+            block.statements[frame.stmt].source_info.span\n+        } else {\n+            block.terminator().source_info.span\n+        };\n+        let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n+        for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n+            if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                err.span_note(span, \"inside call to closure\");\n+                continue;\n+            }\n+            err.span_note(span, &format!(\"inside call to {}\", instance));\n         }\n-        err.span_note(span, &format!(\"inside call to {}\", instance));\n+        err.emit();\n+    } else {\n+        tcx.sess.err(&e.to_string());\n     }\n-    err.emit();\n }\n \n // TODO(solson): Upstream these methods into rustc::ty::layout."}, {"sha": "81bac8c985b8cafd3ff0ec93645d07424330a39b", "filename": "src/step.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "patch": "@@ -43,14 +43,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::from_ptr(Pointer::zst_ptr()),\n                     StackPopCleanup::None,\n                 )?;\n-                if let Some(arg_local) = self.frame().mir.args_iter().next() {\n-                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                    self.write_value(Value::ByVal(PrimVal::Ptr(ptr)), dest, ty)?;\n-                } else {\n-                    return Err(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()));\n-                }\n-\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                self.write_value(Value::ByVal(PrimVal::Ptr(ptr)), dest, ty)?;\n                 return Ok(true);\n             }\n             return Ok(false);"}, {"sha": "09361aa43b3b4d1e21142cba79bb9fb5022182d3", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "patch": "@@ -637,23 +637,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n             }\n \n-            // unix panic code inside libstd will read the return value of this function\n-            \"pthread_rwlock_rdlock\" => {\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n \n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                let result = match name {\n+                    30 => 4096, // _SC_PAGESIZE\n+                    _ => return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)))\n+                };\n+                self.write_primval(dest, PrimVal::Bytes(result), dest_ty)?;\n+            }\n+\n+            \"mmap\" => {\n+                // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n+                let addr = args[0].read_ptr(&self.memory)?;\n+                self.write_primval(dest, PrimVal::Ptr(addr), dest_ty)?;\n+            }\n+\n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = args[0].read_ptr(&self.memory)?;\n                 \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor_fn_ty = match self.operand_ty(&arg_operands[1]).sty {\n-                    TypeVariants::TyAdt(_, ref substs) => {\n-                        substs.type_at(0)\n-                    }\n-                    _ => return Err(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: Second argument must be option of a function pointer.\".to_owned()))\n-                };\n-                let dtor_ptr = self.value_to_primval(args[1], dtor_fn_ty)?.to_ptr()?;\n+                let dtor_ptr = args[1].read_ptr(&self.memory)?;\n                 // TODO: The null-pointer case here is entirely untested\n                 let dtor = if dtor_ptr.is_null_ptr() { None } else { Some(self.memory.get_fn(dtor_ptr.alloc_id)?) };\n                 \n@@ -699,8 +709,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n \n+            // Stub out all the other pthread calls to just return 0\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 warn!(\"ignoring C ABI call: {}\", link_name);\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             },\n \n             _ => {"}, {"sha": "d15f1d6ae3e75fa4b3b60ad717ca50097a649c9e", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6e3e643133fc1c6cdfd6067445236f9b776c7c/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute, attr_literals)]\n-#![miri(memory_size=0)]\n+#![miri(memory_size=20)]\n \n fn main() {\n     let _x = [42; 10];\n-    //~^ERROR tried to allocate 40 more bytes, but only 0 bytes are free of the 0 byte memory\n+    //~^ERROR tried to allocate 40 more bytes, but only\n }"}]}