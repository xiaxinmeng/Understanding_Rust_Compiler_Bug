{"sha": "244b95490b9f0ca5c7ab38455153b421b0b51818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NGI5NTQ5MGI5ZjBjYTVjN2FiMzg0NTUxNTNiNDIxYjBiNTE4MTg=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-06T20:51:02Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-07T16:21:22Z"}, "message": "gc: Refactoring.", "tree": {"sha": "fdce9b34712856c0d9691e9d86b2cf79e1fe30d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdce9b34712856c0d9691e9d86b2cf79e1fe30d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244b95490b9f0ca5c7ab38455153b421b0b51818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244b95490b9f0ca5c7ab38455153b421b0b51818", "html_url": "https://github.com/rust-lang/rust/commit/244b95490b9f0ca5c7ab38455153b421b0b51818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244b95490b9f0ca5c7ab38455153b421b0b51818/comments", "author": null, "committer": null, "parents": [{"sha": "d22b7ca39a4c9561e366faebf36c48daeb5576dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22b7ca39a4c9561e366faebf36c48daeb5576dc", "html_url": "https://github.com/rust-lang/rust/commit/d22b7ca39a4c9561e366faebf36c48daeb5576dc"}], "stats": {"total": 85, "additions": 39, "deletions": 46}, "files": [{"sha": "2c68607c6d488eca69e424b3a4a35bd0bc16e5c9", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/244b95490b9f0ca5c7ab38455153b421b0b51818/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244b95490b9f0ca5c7ab38455153b421b0b51818/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=244b95490b9f0ca5c7ab38455153b421b0b51818", "patch": "@@ -54,13 +54,15 @@ extern mod rustrt {\n     fn rust_get_stack_segment() -> *StackSegment;\n }\n \n-// Is fp contained in segment?\n-unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n-    let begin: Word = unsafe::reinterpret_cast(&segment);\n-    let end: Word = unsafe::reinterpret_cast(&(*segment).end);\n-    let frame: Word = unsafe::reinterpret_cast(&fp);\n+unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n+    return unsafe::reinterpret_cast(&ptr::offset(ptr, count));\n+}\n \n-    return begin <= frame && frame <= end;\n+unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n+    let align = sys::min_align_of::<*T>();\n+    let ptr: uint = unsafe::reinterpret_cast(&ptr);\n+    let ptr = (ptr + (align - 1)) & -align;\n+    return unsafe::reinterpret_cast(&ptr);\n }\n \n type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n@@ -69,59 +71,41 @@ type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n // any.\n unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     let module_meta = rustrt::rust_gc_metadata();\n-    let num_safe_points_ptr: *u32 = unsafe::reinterpret_cast(&module_meta);\n-    let num_safe_points = *num_safe_points_ptr as Word;\n-    let safe_points: *Word =\n-        ptr::offset(unsafe::reinterpret_cast(&module_meta), 1);\n+    let num_safe_points = *module_meta;\n+    let safe_points: *Word = bump(module_meta, 1);\n \n     if ptr::is_null(pc) {\n         return None;\n     }\n \n     // FIXME (#2997): Use binary rather than linear search.\n-    let mut sp = 0 as Word;\n-    while sp < num_safe_points {\n-        let sp_loc = *ptr::offset(safe_points, sp*3) as *Word;\n+    let mut spi = 0;\n+    while spi < num_safe_points {\n+        let sp: **Word = bump(safe_points, spi*3);\n+        let sp_loc = *sp;\n         if sp_loc == pc {\n-            return Some(\n-                {sp_meta: *ptr::offset(safe_points, sp*3 + 1) as *Word,\n-                 fn_meta: *ptr::offset(safe_points, sp*3 + 2) as *Word});\n+            return Some({sp_meta: *bump(sp, 1), fn_meta: *bump(sp, 2)});\n         }\n-        sp += 1;\n+        spi += 1;\n     }\n     return None;\n }\n \n type Visitor = fn(root: **Word, tydesc: *Word) -> bool;\n \n-unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n-    return unsafe::reinterpret_cast(&ptr::offset(ptr, count));\n-}\n-\n-unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n-    let align = sys::min_align_of::<*T>();\n-    let ptr: uint = unsafe::reinterpret_cast(&ptr);\n-    let ptr = (ptr + (align - 1)) & -align;\n-    return unsafe::reinterpret_cast(&ptr);\n-}\n-\n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n-    let sp_meta_u32s: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n+    let sp_meta: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n \n-    let num_stack_roots = *sp_meta_u32s as uint;\n-    let num_reg_roots = *ptr::offset(sp_meta_u32s, 1) as uint;\n+    let num_stack_roots = *sp_meta as uint;\n+    let num_reg_roots = *ptr::offset(sp_meta, 1) as uint;\n \n-    let stack_roots: *u32 =\n-        unsafe::reinterpret_cast(&ptr::offset(sp_meta_u32s, 2));\n-    let reg_roots: *u8 =\n-        unsafe::reinterpret_cast(&ptr::offset(stack_roots, num_stack_roots));\n-    let addrspaces: *Word =\n-        unsafe::reinterpret_cast(&ptr::offset(reg_roots, num_reg_roots));\n-    let tydescs: ***Word =\n-        unsafe::reinterpret_cast(&ptr::offset(addrspaces, num_stack_roots));\n+    let stack_roots: *u32 = bump(sp_meta, 2);\n+    let reg_roots: *u8 = bump(stack_roots, num_stack_roots);\n+    let addrspaces: *Word = align_to_pointer(bump(reg_roots, num_reg_roots));\n+    let tydescs: ***Word = bump(addrspaces, num_stack_roots);\n \n     // Stack roots\n     let mut sri = 0;\n@@ -152,13 +136,14 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     }\n }\n \n-type Memory = uint;\n-\n-const task_local_heap: Memory = 1;\n-const exchange_heap:   Memory = 2;\n-const stack:           Memory = 4;\n+// Is fp contained in segment?\n+unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n+    let begin: Word = unsafe::reinterpret_cast(&segment);\n+    let end: Word = unsafe::reinterpret_cast(&(*segment).end);\n+    let frame: Word = unsafe::reinterpret_cast(&fp);\n \n-const need_cleanup:    Memory = exchange_heap | stack;\n+    return begin <= frame && frame <= end;\n+}\n \n // Find and return the segment containing the given frame pointer. At\n // stack segment boundaries, returns true for boundary, so that the\n@@ -191,6 +176,14 @@ unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n     return {segment: segment, boundary: false};\n }\n \n+type Memory = uint;\n+\n+const task_local_heap: Memory = 1;\n+const exchange_heap:   Memory = 2;\n+const stack:           Memory = 4;\n+\n+const need_cleanup:    Memory = exchange_heap | stack;\n+\n // Walks stack, searching for roots of the requested type, and passes\n // each root to the visitor.\n unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {"}, {"sha": "4566289d2606ad57aee715eb22c44b0f9e24a8c2", "filename": "src/rt/rust_gc_metadata.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244b95490b9f0ca5c7ab38455153b421b0b51818/src%2Frt%2Frust_gc_metadata.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/244b95490b9f0ca5c7ab38455153b421b0b51818/src%2Frt%2Frust_gc_metadata.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gc_metadata.cpp?ref=244b95490b9f0ca5c7ab38455153b421b0b51818", "patch": "@@ -54,7 +54,7 @@ update_gc_metadata(const void* map) {\n     if (!global_safe_points) return;\n \n     uintptr_t *next = global_safe_points;\n-    *(uint32_t *)next = safe_points.size();\n+    *next = safe_points.size();\n     next++;\n     for (uint32_t i = 0; i < safe_points.size(); i++) {\n         next[0] = safe_points[i].safe_point_loc;"}]}