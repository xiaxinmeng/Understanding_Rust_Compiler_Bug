{"sha": "a9b02e13a6b4572570c816e46aab3aba62473863", "node_id": "C_kwDOAAsO6NoAKGE5YjAyZTEzYTZiNDU3MjU3MGM4MTZlNDZhYWIzYWJhNjI0NzM4NjM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-29T01:35:23Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-29T05:27:07Z"}, "message": "drive-by: move Copy bound suggestion to its own function", "tree": {"sha": "34fd5d30d04d9b0d62507382961ca7e2fe5ea79d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34fd5d30d04d9b0d62507382961ca7e2fe5ea79d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9b02e13a6b4572570c816e46aab3aba62473863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b02e13a6b4572570c816e46aab3aba62473863", "html_url": "https://github.com/rust-lang/rust/commit/a9b02e13a6b4572570c816e46aab3aba62473863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9b02e13a6b4572570c816e46aab3aba62473863/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f3c2933e05321f214616ae084d86f4081866f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f3c2933e05321f214616ae084d86f4081866f44", "html_url": "https://github.com/rust-lang/rust/commit/0f3c2933e05321f214616ae084d86f4081866f44"}], "stats": {"total": 125, "additions": 65, "deletions": 60}, "files": [{"sha": "fcbefc74895fc345e5dab5e1d282a433ab5a283f", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a9b02e13a6b4572570c816e46aab3aba62473863/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b02e13a6b4572570c816e46aab3aba62473863/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=a9b02e13a6b4572570c816e46aab3aba62473863", "patch": "@@ -151,6 +151,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .args_or_use()\n                 })\n                 .collect::<Vec<Span>>();\n+\n             let reinits = maybe_reinitialized_locations.len();\n             if reinits == 1 {\n                 err.span_label(reinit_spans[0], \"this reinitialization might get skipped\");\n@@ -282,69 +283,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 Some(ref name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-\n-            let tcx = self.infcx.tcx;\n-            let generics = tcx.generics_of(self.mir_def_id());\n-\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n                 // Suppress the next note, since we don't want to put more `Fn`-like bounds onto something that already has them\n             } else if needs_note {\n-                if let Some(hir_generics) = tcx\n-                    .typeck_root_def_id(self.mir_def_id().to_def_id())\n-                    .as_local()\n-                    .and_then(|def_id| tcx.hir().get_generics(def_id))\n-                {\n-                    // Try to find predicates on *generic params* that would allow copying `ty`\n-                    let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-                        let mut fulfill_cx =\n-                            <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n-                        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-                        let cause = ObligationCause::new(\n-                            span,\n-                            self.mir_hir_id(),\n-                            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-                        );\n-                        fulfill_cx.register_bound(\n-                            &infcx,\n-                            self.param_env,\n-                            // Erase any region vids from the type, which may not be resolved\n-                            infcx.tcx.erase_regions(ty),\n-                            copy_did,\n-                            cause,\n-                        );\n-                        // Select all, including ambiguous predicates\n-                        let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-                        // Only emit suggestion if all required predicates are on generic\n-                        errors\n-                            .into_iter()\n-                            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                                PredicateKind::Trait(predicate) => {\n-                                    match predicate.self_ty().kind() {\n-                                        ty::Param(param_ty) => Ok((\n-                                            generics.type_param(param_ty, tcx),\n-                                            predicate.trait_ref.print_only_trait_path().to_string(),\n-                                        )),\n-                                        _ => Err(()),\n-                                    }\n-                                }\n-                                _ => Err(()),\n-                            })\n-                            .collect()\n-                    });\n-\n-                    if let Ok(predicates) = predicates {\n-                        suggest_constraining_type_params(\n-                            tcx,\n-                            hir_generics,\n-                            &mut err,\n-                            predicates.iter().map(|(param, constraint)| {\n-                                (param.name.as_str(), &**constraint, None)\n-                            }),\n-                        );\n-                    }\n-                }\n+                self.suggest_adding_copy_bounds(&mut err, ty, span);\n \n                 let span = if let Some(local) = place.as_local() {\n                     Some(self.body.local_decls[local].source_info.span)\n@@ -450,6 +392,69 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         true\n     }\n \n+    fn suggest_adding_copy_bounds(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+        let generics = tcx.generics_of(self.mir_def_id());\n+\n+        let Some(hir_generics) = tcx\n+            .typeck_root_def_id(self.mir_def_id().to_def_id())\n+            .as_local()\n+            .and_then(|def_id| tcx.hir().get_generics(def_id))\n+        else { return; };\n+        // Try to find predicates on *generic params* that would allow copying `ty`\n+        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n+            let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+\n+            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+            let cause = ObligationCause::new(\n+                span,\n+                self.mir_hir_id(),\n+                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+            );\n+            fulfill_cx.register_bound(\n+                &infcx,\n+                self.param_env,\n+                // Erase any region vids from the type, which may not be resolved\n+                infcx.tcx.erase_regions(ty),\n+                copy_did,\n+                cause,\n+            );\n+            // Select all, including ambiguous predicates\n+            let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+            // Only emit suggestion if all required predicates are on generic\n+            errors\n+                .into_iter()\n+                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                    PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n+                        ty::Param(param_ty) => Ok((\n+                            generics.type_param(param_ty, tcx),\n+                            predicate.trait_ref.print_only_trait_path().to_string(),\n+                        )),\n+                        _ => Err(()),\n+                    },\n+                    _ => Err(()),\n+                })\n+                .collect()\n+        });\n+\n+        if let Ok(predicates) = predicates {\n+            suggest_constraining_type_params(\n+                tcx,\n+                hir_generics,\n+                err,\n+                predicates\n+                    .iter()\n+                    .map(|(param, constraint)| (param.name.as_str(), &**constraint, None)),\n+            );\n+        }\n+    }\n+\n     pub(crate) fn report_move_out_while_borrowed(\n         &mut self,\n         location: Location,"}]}