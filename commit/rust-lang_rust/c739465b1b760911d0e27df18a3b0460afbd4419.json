{"sha": "c739465b1b760911d0e27df18a3b0460afbd4419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3Mzk0NjViMWI3NjA5MTFkMGUyN2RmMThhM2IwNDYwYWZiZDQ0MTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-01T12:32:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T12:32:14Z"}, "message": "Rollup merge of #70522 - rcoh:60762-raw-string-errors, r=petrochenkov\n\nImprove error messages for raw strings (#60762)\n\nThis diff improves error messages around raw strings in a few ways:\n- Catch extra trailing `#` in the parser. This can't be handled in the lexer because we could be in a macro that actually expects another # (see test)\n- Refactor & unify error handling in the lexer between ByteStrings and RawByteStrings\n- Detect potentially intended terminators (longest sequence of \"#*\" is suggested)\n\nFixes #60762\ncc @estebank who reviewed the original (abandoned) PR for the same ticket.\nr? @Centril", "tree": {"sha": "c00d88de344604e53211cc9b7b699c880d5c1187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c00d88de344604e53211cc9b7b699c880d5c1187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c739465b1b760911d0e27df18a3b0460afbd4419", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehInOCRBK7hj4Ov3rIwAAdHIIADf0/Z2UJPSL2fIpgFsgXWMl\nBV88xDpWveAWyac/OuNYvy4BLmvqF+TR53P/GJUzHY2v3Fw59V4j5Bok0panQ1aO\nZpeDwweCgkpMr2V7mw39LS4ICZZUHK/zvKRlV/SEmICTOvQFkLPPX/+gE+0OET8J\nzp27RsDb5H/km9jdTfC9mVLIfj26sJ+o71iebr1nbOhkl4QTOrzKMpojRmgzj9ft\nO2j4VBylOwS1pDFaUOyopXDccnwc6Dw8uRxCawvEqRYzhEp/6xNvpdj7DEd3l4zP\nhjrnxaeYNBVuO2WQHS4xs0vNJSyvlET2QR3OQUh56ekL3SzdwSZCMbnyjltyjnQ=\n=d3Ut\n-----END PGP SIGNATURE-----\n", "payload": "tree c00d88de344604e53211cc9b7b699c880d5c1187\nparent 84a463388040a1bc86578c0e3df2bf65e91127d3\nparent 55a5eea763ed330bd9c3da4fbe9cf7d448afbe83\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585744334 +0200\ncommitter GitHub <noreply@github.com> 1585744334 +0200\n\nRollup merge of #70522 - rcoh:60762-raw-string-errors, r=petrochenkov\n\nImprove error messages for raw strings (#60762)\n\nThis diff improves error messages around raw strings in a few ways:\n- Catch extra trailing `#` in the parser. This can't be handled in the lexer because we could be in a macro that actually expects another # (see test)\n- Refactor & unify error handling in the lexer between ByteStrings and RawByteStrings\n- Detect potentially intended terminators (longest sequence of \"#*\" is suggested)\n\nFixes #60762\ncc @estebank who reviewed the original (abandoned) PR for the same ticket.\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c739465b1b760911d0e27df18a3b0460afbd4419", "html_url": "https://github.com/rust-lang/rust/commit/c739465b1b760911d0e27df18a3b0460afbd4419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c739465b1b760911d0e27df18a3b0460afbd4419/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84a463388040a1bc86578c0e3df2bf65e91127d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/84a463388040a1bc86578c0e3df2bf65e91127d3", "html_url": "https://github.com/rust-lang/rust/commit/84a463388040a1bc86578c0e3df2bf65e91127d3"}, {"sha": "55a5eea763ed330bd9c3da4fbe9cf7d448afbe83", "url": "https://api.github.com/repos/rust-lang/rust/commits/55a5eea763ed330bd9c3da4fbe9cf7d448afbe83", "html_url": "https://github.com/rust-lang/rust/commit/55a5eea763ed330bd9c3da4fbe9cf7d448afbe83"}], "stats": {"total": 459, "additions": 385, "deletions": 74}, "files": [{"sha": "fcb7475cc2e89890d16bc92bce45a5a1af21ec53", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 124, "deletions": 22, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -17,9 +17,13 @@\n mod cursor;\n pub mod unescape;\n \n+#[cfg(test)]\n+mod tests;\n+\n use self::LiteralKind::*;\n use self::TokenKind::*;\n use crate::cursor::{Cursor, EOF_CHAR};\n+use std::convert::TryInto;\n \n /// Parsed token.\n /// It doesn't contain information about data that has been parsed,\n@@ -132,9 +136,80 @@ pub enum LiteralKind {\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\"\n-    RawStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawStr(UnvalidatedRawStr),\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\"\n-    RawByteStr { n_hashes: usize, started: bool, terminated: bool },\n+    RawByteStr(UnvalidatedRawStr),\n+}\n+\n+/// Represents something that looks like a raw string, but may have some\n+/// problems. Use `.validate()` to convert it into something\n+/// usable.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct UnvalidatedRawStr {\n+    /// The prefix (`r###\"`) is valid\n+    valid_start: bool,\n+    /// The number of leading `#`\n+    n_start_hashes: usize,\n+    /// The number of trailing `#`. `n_end_hashes` <= `n_start_hashes`\n+    n_end_hashes: usize,\n+    /// The offset starting at `r` or `br` where the user may have intended to end the string.\n+    /// Currently, it is the longest sequence of pattern `\"#+\"`.\n+    possible_terminator_offset: Option<usize>,\n+}\n+\n+/// Error produced validating a raw string. Represents cases like:\n+/// - `r##~\"abcde\"##`: `LexRawStrError::InvalidStarter`\n+/// - `r###\"abcde\"##`: `LexRawStrError::NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n+/// - Too many `#`s (>65536): `TooManyDelimiters`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum LexRawStrError {\n+    /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n+    InvalidStarter,\n+    /// The string was never terminated. `possible_terminator_offset` is the number of characters after `r` or `br` where they\n+    /// may have intended to terminate it.\n+    NoTerminator { expected: usize, found: usize, possible_terminator_offset: Option<usize> },\n+    /// More than 65536 `#`s exist.\n+    TooManyDelimiters,\n+}\n+\n+/// Raw String that contains a valid prefix (`#+\"`) and postfix (`\"#+`) where\n+/// there are a matching number of `#` characters in both. Note that this will\n+/// not consume extra trailing `#` characters: `r###\"abcde\"####` is lexed as a\n+/// `ValidatedRawString { n_hashes: 3 }` followed by a `#` token.\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+pub struct ValidatedRawStr {\n+    n_hashes: u16,\n+}\n+\n+impl ValidatedRawStr {\n+    pub fn num_hashes(&self) -> u16 {\n+        self.n_hashes\n+    }\n+}\n+\n+impl UnvalidatedRawStr {\n+    pub fn validate(self) -> Result<ValidatedRawStr, LexRawStrError> {\n+        if !self.valid_start {\n+            return Err(LexRawStrError::InvalidStarter);\n+        }\n+\n+        // Only up to 65535 `#`s are allowed in raw strings\n+        let n_start_safe: u16 =\n+            self.n_start_hashes.try_into().map_err(|_| LexRawStrError::TooManyDelimiters)?;\n+\n+        if self.n_start_hashes > self.n_end_hashes {\n+            Err(LexRawStrError::NoTerminator {\n+                expected: self.n_start_hashes,\n+                found: self.n_end_hashes,\n+                possible_terminator_offset: self.possible_terminator_offset,\n+            })\n+        } else {\n+            // Since the lexer should never produce a literal with n_end > n_start, if n_start <= n_end,\n+            // they must be equal.\n+            debug_assert_eq!(self.n_start_hashes, self.n_end_hashes);\n+            Ok(ValidatedRawStr { n_hashes: n_start_safe })\n+        }\n+    }\n }\n \n /// Base of numeric literal encoding according to its prefix.\n@@ -209,7 +284,7 @@ pub fn is_whitespace(c: char) -> bool {\n         // Dedicated whitespace characters from Unicode\n         | '\\u{2028}' // LINE SEPARATOR\n         | '\\u{2029}' // PARAGRAPH SEPARATOR\n-            => true,\n+        => true,\n         _ => false,\n     }\n }\n@@ -258,12 +333,12 @@ impl Cursor<'_> {\n             'r' => match (self.first(), self.second()) {\n                 ('#', c1) if is_id_start(c1) => self.raw_ident(),\n                 ('#', _) | ('\"', _) => {\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(1);\n                     let suffix_start = self.len_consumed();\n-                    if terminated {\n+                    if raw_str_i.n_end_hashes == raw_str_i.n_start_hashes {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawStr { n_hashes, started, terminated };\n+                    let kind = RawStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -293,12 +368,14 @@ impl Cursor<'_> {\n                 }\n                 ('r', '\"') | ('r', '#') => {\n                     self.bump();\n-                    let (n_hashes, started, terminated) = self.raw_double_quoted_string();\n+                    let raw_str_i = self.raw_double_quoted_string(2);\n                     let suffix_start = self.len_consumed();\n+                    let terminated = raw_str_i.n_start_hashes == raw_str_i.n_end_hashes;\n                     if terminated {\n                         self.eat_literal_suffix();\n                     }\n-                    let kind = RawByteStr { n_hashes, started, terminated };\n+\n+                    let kind = RawByteStr(raw_str_i);\n                     Literal { kind, suffix_start }\n                 }\n                 _ => self.ident(),\n@@ -594,37 +671,49 @@ impl Cursor<'_> {\n         false\n     }\n \n-    /// Eats the double-quoted string and returns a tuple of\n-    /// (amount of the '#' symbols, raw string started, raw string terminated)\n-    fn raw_double_quoted_string(&mut self) -> (usize, bool, bool) {\n+    /// Eats the double-quoted string and returns an `UnvalidatedRawStr`.\n+    fn raw_double_quoted_string(&mut self, prefix_len: usize) -> UnvalidatedRawStr {\n         debug_assert!(self.prev() == 'r');\n-        let mut started: bool = false;\n-        let mut finished: bool = false;\n+        let mut valid_start: bool = false;\n+        let start_pos = self.len_consumed();\n+        let (mut possible_terminator_offset, mut max_hashes) = (None, 0);\n \n         // Count opening '#' symbols.\n-        let n_hashes = self.eat_while(|c| c == '#');\n+        let n_start_hashes = self.eat_while(|c| c == '#');\n \n         // Check that string is started.\n         match self.bump() {\n-            Some('\"') => started = true,\n-            _ => return (n_hashes, started, finished),\n+            Some('\"') => valid_start = true,\n+            _ => {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: 0,\n+                    possible_terminator_offset,\n+                };\n+            }\n         }\n \n         // Skip the string contents and on each '#' character met, check if this is\n         // a raw string termination.\n-        while !finished {\n+        loop {\n             self.eat_while(|c| c != '\"');\n \n             if self.is_eof() {\n-                return (n_hashes, started, finished);\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes: max_hashes,\n+                    possible_terminator_offset,\n+                };\n             }\n \n             // Eat closing double quote.\n             self.bump();\n \n             // Check that amount of closing '#' symbols\n             // is equal to the amount of opening ones.\n-            let mut hashes_left = n_hashes;\n+            let mut hashes_left = n_start_hashes;\n             let is_closing_hash = |c| {\n                 if c == '#' && hashes_left != 0 {\n                     hashes_left -= 1;\n@@ -633,10 +722,23 @@ impl Cursor<'_> {\n                     false\n                 }\n             };\n-            finished = self.eat_while(is_closing_hash) == n_hashes;\n+            let n_end_hashes = self.eat_while(is_closing_hash);\n+\n+            if n_end_hashes == n_start_hashes {\n+                return UnvalidatedRawStr {\n+                    valid_start,\n+                    n_start_hashes,\n+                    n_end_hashes,\n+                    possible_terminator_offset: None,\n+                };\n+            } else if n_end_hashes > max_hashes {\n+                // Keep track of possible terminators to give a hint about where there might be\n+                // a missing terminator\n+                possible_terminator_offset =\n+                    Some(self.len_consumed() - start_pos - n_end_hashes + prefix_len);\n+                max_hashes = n_end_hashes;\n+            }\n         }\n-\n-        (n_hashes, started, finished)\n     }\n \n     fn eat_decimal_digits(&mut self) -> bool {"}, {"sha": "4af435536f011d9f85912f6a58d4fd6170732313", "filename": "src/librustc_lexer/src/tests.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,121 @@\n+#[cfg(test)]\n+mod tests {\n+    use crate::*;\n+\n+    fn check_raw_str(\n+        s: &str,\n+        expected: UnvalidatedRawStr,\n+        validated: Result<ValidatedRawStr, LexRawStrError>,\n+    ) {\n+        let s = &format!(\"r{}\", s);\n+        let mut cursor = Cursor::new(s);\n+        cursor.bump();\n+        let tok = cursor.raw_double_quoted_string(0);\n+        assert_eq!(tok, expected);\n+        assert_eq!(tok.validate(), validated);\n+    }\n+\n+    #[test]\n+    fn test_naked_raw_str() {\n+        check_raw_str(\n+            r#\"\"abc\"\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_raw_no_start() {\n+        check_raw_str(\n+            r##\"\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 0,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 0 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_too_many_terminators() {\n+        // this error is handled in the parser later\n+        check_raw_str(\n+            r###\"#\"abc\"##\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Ok(ValidatedRawStr { n_hashes: 1 }),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_unterminated() {\n+        check_raw_str(\n+            r#\"#\"abc\"#,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 1,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        );\n+        check_raw_str(\n+            r###\"##\"abc\"#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 1,\n+                valid_start: true,\n+                possible_terminator_offset: Some(7),\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 1,\n+                possible_terminator_offset: Some(7),\n+            }),\n+        );\n+        // We're looking for \"# not just any #\n+        check_raw_str(\n+            r###\"##\"abc#\"###,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 2,\n+                n_end_hashes: 0,\n+                valid_start: true,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::NoTerminator {\n+                expected: 2,\n+                found: 0,\n+                possible_terminator_offset: None,\n+            }),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_invalid_start() {\n+        check_raw_str(\n+            r##\"#~\"abc\"#\"##,\n+            UnvalidatedRawStr {\n+                n_start_hashes: 1,\n+                n_end_hashes: 0,\n+                valid_start: false,\n+                possible_terminator_offset: None,\n+            },\n+            Err(LexRawStrError::InvalidStarter),\n+        );\n+    }\n+}"}, {"sha": "96321ef2145e595fadfff8f78ab34f841a55f8c7", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -1,20 +1,20 @@\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{error_code, DiagnosticBuilder, FatalError};\n-use rustc_lexer::unescape;\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n use rustc_lexer::Base;\n+use rustc_lexer::{unescape, LexRawStrError, UnvalidatedRawStr, ValidatedRawStr};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Pos, Span};\n \n use log::debug;\n use std::char;\n-use std::convert::TryInto;\n \n mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n+\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -373,30 +373,22 @@ impl<'a> StringReader<'a> {\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::ByteStr, id)\n             }\n-            rustc_lexer::LiteralKind::RawStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawStr(unvalidated_raw_str) => {\n+                let valid_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = valid_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(2 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_str_escape(content_start, content_end);\n                 let id = self.symbol_from_to(content_start, content_end);\n                 (token::StrRaw(n_hashes), id)\n             }\n-            rustc_lexer::LiteralKind::RawByteStr { n_hashes, started, terminated } => {\n-                if !started {\n-                    self.report_non_started_raw_string(start);\n-                }\n-                if !terminated {\n-                    self.report_unterminated_raw_string(start, n_hashes)\n-                }\n-                let n_hashes: u16 = self.restrict_n_hashes(start, n_hashes);\n+            rustc_lexer::LiteralKind::RawByteStr(unvalidated_raw_str) => {\n+                let validated_raw_str = self.validate_and_report_errors(start, unvalidated_raw_str);\n+                let n_hashes = validated_raw_str.num_hashes();\n                 let n = u32::from(n_hashes);\n+\n                 let content_start = start + BytePos(3 + n);\n                 let content_end = suffix_start - BytePos(1 + n);\n                 self.validate_raw_byte_str_escape(content_start, content_end);\n@@ -482,6 +474,26 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    fn validate_and_report_errors(\n+        &self,\n+        start: BytePos,\n+        unvalidated_raw_str: UnvalidatedRawStr,\n+    ) -> ValidatedRawStr {\n+        match unvalidated_raw_str.validate() {\n+            Err(LexRawStrError::InvalidStarter) => self.report_non_started_raw_string(start),\n+            Err(LexRawStrError::NoTerminator { expected, found, possible_terminator_offset }) => {\n+                self.report_unterminated_raw_string(\n+                    start,\n+                    expected,\n+                    possible_terminator_offset,\n+                    found,\n+                )\n+            }\n+            Err(LexRawStrError::TooManyDelimiters) => self.report_too_many_hashes(start),\n+            Ok(valid) => valid,\n+        }\n+    }\n+\n     fn report_non_started_raw_string(&self, start: BytePos) -> ! {\n         let bad_char = self.str_from(start).chars().last().unwrap();\n         self.struct_fatal_span_char(\n@@ -495,38 +507,51 @@ impl<'a> StringReader<'a> {\n         FatalError.raise()\n     }\n \n-    fn report_unterminated_raw_string(&self, start: BytePos, n_hashes: usize) -> ! {\n+    fn report_unterminated_raw_string(\n+        &self,\n+        start: BytePos,\n+        n_hashes: usize,\n+        possible_offset: Option<usize>,\n+        found_terminators: usize,\n+    ) -> ! {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal_with_code(\n             self.mk_sp(start, start),\n             \"unterminated raw string\",\n             error_code!(E0748),\n         );\n+\n         err.span_label(self.mk_sp(start, start), \"unterminated raw string\");\n \n         if n_hashes > 0 {\n             err.note(&format!(\n                 \"this raw string should be terminated with `\\\"{}`\",\n-                \"#\".repeat(n_hashes as usize)\n+                \"#\".repeat(n_hashes)\n             ));\n         }\n \n+        if let Some(possible_offset) = possible_offset {\n+            let lo = start + BytePos(possible_offset as u32);\n+            let hi = lo + BytePos(found_terminators as u32);\n+            let span = self.mk_sp(lo, hi);\n+            err.span_suggestion(\n+                span,\n+                \"consider terminating the string here\",\n+                \"#\".repeat(n_hashes),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n         err.emit();\n         FatalError.raise()\n     }\n \n-    fn restrict_n_hashes(&self, start: BytePos, n_hashes: usize) -> u16 {\n-        match n_hashes.try_into() {\n-            Ok(n_hashes) => n_hashes,\n-            Err(_) => {\n-                self.fatal_span_(\n-                    start,\n-                    self.pos,\n-                    \"too many `#` symbols: raw strings may be \\\n-                                  delimited by up to 65535 `#` symbols\",\n-                )\n-                .raise();\n-            }\n-        }\n+    fn report_too_many_hashes(&self, start: BytePos) -> ! {\n+        self.fatal_span_(\n+            start,\n+            self.pos,\n+            \"too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+        )\n+        .raise();\n     }\n \n     fn validate_char_escape(&self, content_start: BytePos, content_end: BytePos) {"}, {"sha": "8e2a9513d6b829dffa8c962f4b47556f3fae703d", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -4,6 +4,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n #![feature(try_blocks)]\n+#![feature(or_patterns)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};"}, {"sha": "12b9b682682485038b7482c6abee3c4a568ba3f3", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ast::{\n };\n use rustc_ast::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -255,6 +255,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        if self.check_too_many_raw_str_terminators(&mut err) {\n+            return Err(err);\n+        }\n+\n         let sm = self.sess.source_map();\n         if self.prev_token.span == DUMMY_SP {\n             // Account for macro context where the previous span might not be\n@@ -282,6 +286,29 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n+    fn check_too_many_raw_str_terminators(&mut self, err: &mut DiagnosticBuilder<'_>) -> bool {\n+        match (&self.prev_token.kind, &self.token.kind) {\n+            (\n+                TokenKind::Literal(Lit {\n+                    kind: LitKind::StrRaw(n_hashes) | LitKind::ByteStrRaw(n_hashes),\n+                    ..\n+                }),\n+                TokenKind::Pound,\n+            ) => {\n+                err.set_primary_message(\"too many `#` when terminating raw string\");\n+                err.span_suggestion(\n+                    self.token.span,\n+                    \"remove the extra `#`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.note(&format!(\"the raw string started with {} `#`s\", n_hashes));\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -491,7 +518,7 @@ impl<'a> Parser<'a> {\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n                     err.span_suggestion_verbose(\n-                            inner_op.span.shrink_to_hi(),\n+                        inner_op.span.shrink_to_hi(),\n                         \"split the comparison into two\",\n                         format!(\" && {}\", expr_to_str(&r1)),\n                         Applicability::MaybeIncorrect,\n@@ -1086,7 +1113,7 @@ impl<'a> Parser<'a> {\n             self.look_ahead(2, |t| t.is_ident())\n             || self.look_ahead(1, |t| t == &token::ModSep)\n                 && (self.look_ahead(2, |t| t.is_ident()) ||   // `foo:bar::baz`\n-             self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n+            self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n     }\n \n     pub(super) fn recover_seq_parse_error("}, {"sha": "5a1d1be11b63362de0d48bd4dfeb4eba377f8849", "filename": "src/test/ui/parser/raw-str-unbalanced.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84a463388040a1bc86578c0e3df2bf65e91127d3/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a463388040a1bc86578c0e3df2bf65e91127d3/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.rs?ref=84a463388040a1bc86578c0e3df2bf65e91127d3", "patch": "@@ -1,4 +0,0 @@\n-static s: &'static str =\n-    r#\"\n-      \"## //~ ERROR expected one of `.`, `;`, `?`, or an operator, found `#`\n-;"}, {"sha": "ddb75722bef9f32c37e39f6da7fcc4eebd8beda2", "filename": "src/test/ui/parser/raw-str-unbalanced.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84a463388040a1bc86578c0e3df2bf65e91127d3/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84a463388040a1bc86578c0e3df2bf65e91127d3/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-str-unbalanced.stderr?ref=84a463388040a1bc86578c0e3df2bf65e91127d3", "patch": "@@ -1,8 +0,0 @@\n-error: expected one of `.`, `;`, `?`, or an operator, found `#`\n-  --> $DIR/raw-str-unbalanced.rs:3:9\n-   |\n-LL |       \"##\n-   |         ^ expected one of `.`, `;`, `?`, or an operator\n-\n-error: aborting due to previous error\n-"}, {"sha": "b74907b72b0cfe182a6c46ad2ac719b67c811b80", "filename": "src/test/ui/parser/raw/raw-byte-string-eof.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-byte-string-eof.rs"}, {"sha": "a76668e8051b52c75daf1df79f3c8060611d8ddd", "filename": "src/test/ui/parser/raw/raw-byte-string-eof.stderr", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-eof.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -2,7 +2,9 @@ error[E0748]: unterminated raw string\n   --> $DIR/raw-byte-string-eof.rs:2:5\n    |\n LL |     br##\"a\"#;\n-   |     ^ unterminated raw string\n+   |     ^      - help: consider terminating the string here: `##`\n+   |     |\n+   |     unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n ", "previous_filename": "src/test/ui/parser/raw-byte-string-eof.stderr"}, {"sha": "163c8ac66b022ae8eb4aac851d8adc71027e05bb", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-byte-string-literals.rs"}, {"sha": "4076fe334e6533e3ddf1a697d9db181ef1e48512", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-byte-string-literals.stderr"}, {"sha": "2f13893cecd2f00a8bf73aeacb3e7db00aeeb642", "filename": "src/test/ui/parser/raw/raw-str-delim.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-str-delim.rs"}, {"sha": "8a04f99a126dadb7534b8f9faa8affc217ead99a", "filename": "src/test/ui/parser/raw/raw-str-delim.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-delim.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-str-delim.stderr"}, {"sha": "462c2279f5c1c3791af6098c461d17d68ed2929d", "filename": "src/test/ui/parser/raw/raw-str-in-macro-call.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-in-macro-call.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+macro_rules! m1 {\n+    ($tt:tt #) => ()\n+}\n+\n+macro_rules! m2 {\n+    ($tt:tt) => ()\n+}\n+\n+fn main() {\n+    m1!(r#\"abc\"##);\n+    m2!(r#\"abc\"#);\n+}"}, {"sha": "35f118f5ce6eed46af1e1b3a89f2be036f7204ea", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,4 @@\n+static s: &'static str =\n+    r#\"\n+      \"## //~ too many `#` when terminating raw string\n+;"}, {"sha": "bf8f3a7a5a4bd833cc012ec8f3cc23d5831945df", "filename": "src/test/ui/parser/raw/raw-str-unbalanced.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unbalanced.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,10 @@\n+error: too many `#` when terminating raw string\n+  --> $DIR/raw-str-unbalanced.rs:3:9\n+   |\n+LL |       \"##\n+   |         ^ help: remove the extra `#`\n+   |\n+   = note: the raw string started with 1 `#`s\n+\n+error: aborting due to previous error\n+"}, {"sha": "fd317295561f4084214b2babd523d4a7142f2831", "filename": "src/test/ui/parser/raw/raw-str-unterminated.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-str-unterminated.rs"}, {"sha": "077f763f154c589cd2f58e79a0e31552e8884a20", "filename": "src/test/ui/parser/raw/raw-str-unterminated.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-str-unterminated.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw-str-unterminated.stderr"}, {"sha": "067332d2819bdcfae675a6a843a9b0a8682e9a1b", "filename": "src/test/ui/parser/raw/raw-string-2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = r###\"here's a long string\"# \"# \"##;\n+    //~^ ERROR unterminated raw string\n+}"}, {"sha": "8bbac9d7bd0bd9a799e1b3326e9714e26d0a116d", "filename": "src/test/ui/parser/raw/raw-string-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string-2.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -0,0 +1,11 @@\n+error[E0748]: unterminated raw string\n+  --> $DIR/raw-string-2.rs:2:13\n+   |\n+LL |     let x = r###\"here's a long string\"# \"# \"##;\n+   |             ^ unterminated raw string       -- help: consider terminating the string here: `###`\n+   |\n+   = note: this raw string should be terminated with `\"###`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0748`."}, {"sha": "84f07c4a941bc900a5e3db9f8ef1f11cd3bded58", "filename": "src/test/ui/parser/raw/raw-string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.rs?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "previous_filename": "src/test/ui/parser/raw/raw_string.rs"}, {"sha": "b2b853a89e7510ba18d194074491a9fa53cf6685", "filename": "src/test/ui/parser/raw/raw-string.stderr", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c739465b1b760911d0e27df18a3b0460afbd4419/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-string.stderr?ref=c739465b1b760911d0e27df18a3b0460afbd4419", "patch": "@@ -1,8 +1,10 @@\n error[E0748]: unterminated raw string\n-  --> $DIR/raw_string.rs:2:13\n+  --> $DIR/raw-string.rs:2:13\n    |\n LL |     let x = r##\"lol\"#;\n-   |             ^ unterminated raw string\n+   |             ^       - help: consider terminating the string here: `##`\n+   |             |\n+   |             unterminated raw string\n    |\n    = note: this raw string should be terminated with `\"##`\n ", "previous_filename": "src/test/ui/parser/raw/raw_string.stderr"}]}