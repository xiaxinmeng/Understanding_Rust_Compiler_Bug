{"sha": "486b5dfe74ced6ba93953fe91483815138bd370f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NmI1ZGZlNzRjZWQ2YmE5Mzk1M2ZlOTE0ODM4MTUxMzhiZDM3MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T09:53:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T09:53:05Z"}, "message": "Auto merge of #1832 - hyd-dev:1776-follow-up, r=RalfJung\n\nReport an error if a `#[no_mangle]`/`#[export_name = ...]` function has the same symbol name as a built-in shim\n\nImplements https://github.com/rust-lang/miri/pull/1776#issuecomment-821322605.\n\nThe error looks like this:\n```\nerror: found `malloc` symbol definition that clashes with a built-in shim\n  --> tests/compile-fail/function_calls/exported_symbol_shim_clashing.rs:12:9\n   |\n12 |         malloc(0);\n   |         ^^^^^^^^^ found `malloc` symbol definition that clashes with a built-in shim\n   |\nhelp: the `malloc` symbol is defined here\n\n  --> tests/compile-fail/function_calls/exported_symbol_shim_clashing.rs:2:1\n   |\n2  | / extern \"C\" fn malloc(_: usize) -> *mut std::ffi::c_void {\n3  | |     //~^ HELP the `malloc` symbol is defined here\n4  | |     unreachable!()\n5  | | }\n   | |_^\n   = note: inside `main` at tests/compile-fail/function_calls/exported_symbol_shim_clashing.rs:12:9\n```\n\nThis does not implement \"better error messages than we do currently for arg/ABI mismatches\" in https://github.com/rust-lang/miri/pull/1776#issuecomment-821343175 -- I failed to remove all `check_arg_count()` and `check_abi()` (they are still used in `src/shims/intrinsics.rs` and `call_dlsym()`) and they don't receive the name of the shim.", "tree": {"sha": "c86344d8134ae9410ab8660f125f080d81f402d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c86344d8134ae9410ab8660f125f080d81f402d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/486b5dfe74ced6ba93953fe91483815138bd370f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/486b5dfe74ced6ba93953fe91483815138bd370f", "html_url": "https://github.com/rust-lang/rust/commit/486b5dfe74ced6ba93953fe91483815138bd370f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/486b5dfe74ced6ba93953fe91483815138bd370f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "042db78ab3701b37c32366b2d0d7bf9a82092345", "url": "https://api.github.com/repos/rust-lang/rust/commits/042db78ab3701b37c32366b2d0d7bf9a82092345", "html_url": "https://github.com/rust-lang/rust/commit/042db78ab3701b37c32366b2d0d7bf9a82092345"}, {"sha": "aaaa142dc18ecae15bb357584b1de35395e3bdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaaa142dc18ecae15bb357584b1de35395e3bdb8", "html_url": "https://github.com/rust-lang/rust/commit/aaaa142dc18ecae15bb357584b1de35395e3bdb8"}], "stats": {"total": 721, "additions": 350, "deletions": 371}, "files": [{"sha": "887b2ac4b378b7c67be5f06bfd7860a5284a0ae4", "filename": "src/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -26,6 +26,10 @@ pub enum TerminationInfo {\n         second: SpanData,\n         second_crate: Symbol,\n     },\n+    SymbolShimClashing {\n+        link_name: Symbol,\n+        span: SpanData,\n+    },\n }\n \n impl fmt::Display for TerminationInfo {\n@@ -39,6 +43,11 @@ impl fmt::Display for TerminationInfo {\n             Deadlock => write!(f, \"the evaluated program deadlocked\"),\n             MultipleSymbolDefinitions { link_name, .. } =>\n                 write!(f, \"multiple definitions of symbol `{}`\", link_name),\n+            SymbolShimClashing { link_name, .. } => write!(\n+                f,\n+                \"found `{}` symbol definition that clashes with a built-in shim\",\n+                link_name\n+            ),\n         }\n     }\n }\n@@ -79,7 +88,7 @@ pub fn report_error<'tcx, 'mir>(\n                 UnsupportedInIsolation(_) => Some(\"unsupported operation\"),\n                 ExperimentalUb { .. } => Some(\"Undefined Behavior\"),\n                 Deadlock => Some(\"deadlock\"),\n-                MultipleSymbolDefinitions { .. } => None,\n+                MultipleSymbolDefinitions { .. } | SymbolShimClashing { .. } => None,\n             };\n             #[rustfmt::skip]\n             let helps = match info {\n@@ -98,6 +107,8 @@ pub fn report_error<'tcx, 'mir>(\n                         (Some(*first), format!(\"it's first defined here, in crate `{}`\", first_crate)),\n                         (Some(*second), format!(\"then it's defined here again, in crate `{}`\", second_crate)),\n                     ],\n+                SymbolShimClashing { link_name, span } =>\n+                    vec![(Some(*span), format!(\"the `{}` symbol is defined here\", link_name))],\n                 _ => vec![],\n             };\n             (title, helps)"}, {"sha": "b99a446577ac43d8c12474ce4a0770e75c29bbad", "filename": "src/helpers.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -8,6 +8,7 @@ use log::trace;\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, layout::TyAndLayout, List, TyCtxt};\n+use rustc_span::Symbol;\n use rustc_target::abi::{Align, FieldsShape, LayoutOf, Size, Variants};\n use rustc_target::spec::abi::Abi;\n \n@@ -677,6 +678,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"{}\", error_msg.as_ref());\n         }\n     }\n+\n+    fn check_abi_and_shim_symbol_clash(\n+        &mut self,\n+        abi: Abi,\n+        exp_abi: Abi,\n+        link_name: Symbol,\n+    ) -> InterpResult<'tcx, ()> {\n+        self.check_abi(abi, exp_abi)?;\n+        if let Some(body) = self.eval_context_mut().lookup_exported_symbol(link_name)? {\n+            throw_machine_stop!(TerminationInfo::SymbolShimClashing {\n+                link_name,\n+                span: body.span.data(),\n+            })\n+        }\n+        Ok(())\n+    }\n+\n+    fn check_shim<'a, const N: usize>(\n+        &mut self,\n+        abi: Abi,\n+        exp_abi: Abi,\n+        link_name: Symbol,\n+        args: &'a [OpTy<'tcx, Tag>],\n+    ) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n+    where\n+        &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]>,\n+    {\n+        self.check_abi_and_shim_symbol_clash(abi, exp_abi, link_name)?;\n+        check_arg_count(args)\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "91a83a8acf4039aa8629c3ecd07b839c14330114", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -297,7 +297,8 @@ pub struct Evaluator<'mir, 'tcx> {\n     string_cache: FxHashMap<String, measureme::StringId>,\n \n     /// Cache of `Instance` exported under the given `Symbol` name.\n-    pub(crate) exported_symbols_cache: FxHashMap<Symbol, Instance<'tcx>>,\n+    /// `None` means no `Instance` exported under the given name is found.\n+    pub(crate) exported_symbols_cache: FxHashMap<Symbol, Option<Instance<'tcx>>>,\n \n     /// Whether to raise a panic in the context of the evaluated process when unsupported\n     /// functionality is encountered. If `false`, an error is propagated in the Miri application context"}, {"sha": "4ea374344c0dd1ec392dbcd583e85cd2a1cafa21", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -1,22 +1,23 @@\n use crate::rustc_target::abi::LayoutOf as _;\n use crate::*;\n-use helpers::check_arg_count;\n use rustc_ast::ast::Mutability;\n use rustc_middle::ty::{self, TypeAndMut};\n-use rustc_span::BytePos;\n-use rustc_target::abi::Size;\n+use rustc_span::{BytePos, Symbol};\n+use rustc_target::{abi::Size, spec::abi::Abi};\n use std::convert::TryInto as _;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn handle_miri_get_backtrace(\n         &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n-        let &[ref flags] = check_arg_count(args)?;\n+        let &[ref flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n         if flags != 0 {\n@@ -71,12 +72,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn handle_miri_resolve_frame(\n         &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n-        let &[ref ptr, ref flags] = check_arg_count(args)?;\n+        let &[ref ptr, ref flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n         if flags != 0 {"}, {"sha": "596f6c33d6474d8d318da9d0f7dab547e080a28b", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -25,7 +25,6 @@ use rustc_target::{\n \n use super::backtrace::EvalContextExt as _;\n use crate::*;\n-use helpers::check_arg_count;\n \n /// Returned by `emulate_foreign_item_by_name`.\n pub enum EmulateByNameResult {\n@@ -136,7 +135,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // If the result was cached, just return it.\n         if let Some(instance) = this.machine.exported_symbols_cache.get(&link_name) {\n-            return Ok(Some(this.load_mir(instance.def, None)?));\n+            return instance.map(|instance| this.load_mir(instance.def, None)).transpose();\n         }\n \n         // Find it if it was not cached.\n@@ -188,13 +187,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n+        let instance = instance_and_crate.map(|ic| ic.0);\n         // Cache it and load its MIR, if found.\n-        instance_and_crate\n-            .map(|(instance, _)| {\n-                this.machine.exported_symbols_cache.insert(link_name, instance);\n-                this.load_mir(instance.def, None)\n-            })\n-            .transpose()\n+        this.machine.exported_symbols_cache.insert(link_name, instance);\n+        instance.map(|instance| this.load_mir(instance.def, None)).transpose()\n     }\n \n     /// Emulates calling a foreign item, failing if the item is not supported.\n@@ -213,28 +209,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n-        let link_name_sym = this\n+        let link_name = this\n             .tcx\n             .sess\n             .first_attr_value_str_by_name(&attrs, sym::link_name)\n             .unwrap_or_else(|| this.tcx.item_name(def_id));\n-        let link_name = link_name_sym.as_str();\n-        // Strip linker suffixes (seen on 32-bit macOS).\n-        let link_name = link_name.trim_end_matches(\"$UNIX2003\");\n         let tcx = this.tcx.tcx;\n \n         // First: functions that diverge.\n         let (dest, ret) = match ret {\n-            None => match link_name {\n+            None => match &*link_name.as_str() {\n                 \"miri_start_panic\" => {\n-                    this.check_abi(abi, Abi::Rust)?;\n-                    this.handle_miri_start_panic(args, unwind)?;\n+                    // `check_shim` happens inside `handle_miri_start_panic`.\n+                    this.handle_miri_start_panic(abi, link_name, args, unwind)?;\n                     return Ok(None);\n                 }\n                 // This matches calls to the foreign item `panic_impl`.\n                 // The implementation is provided by the function with the `#[panic_handler]` attribute.\n                 \"panic_impl\" => {\n-                    this.check_abi(abi, Abi::Rust)?;\n+                    // We don't use `check_shim` here because we are just forwarding to the lang\n+                    // item. Argument count checking will be performed when the returned `Body` is\n+                    // called.\n+                    this.check_abi_and_shim_symbol_clash(abi, Abi::Rust, link_name)?;\n                     let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n                     let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n                     return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));\n@@ -243,20 +239,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 | \"exit\"\n                 | \"ExitProcess\"\n                 => {\n-                    this.check_abi(abi, if link_name == \"exit\" { Abi::C { unwind: false } } else { Abi::System { unwind: false } })?;\n-                    let &[ref code] = check_arg_count(args)?;\n+                    let exp_abi = if link_name.as_str() == \"exit\" {\n+                        Abi::C { unwind: false }\n+                    } else {\n+                        Abi::System { unwind: false }\n+                    };\n+                    let &[ref code] = this.check_shim(abi, exp_abi, link_name, args)?;\n                     // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                     let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                 }\n                 \"abort\" => {\n-                    this.check_abi(abi, Abi::C { unwind: false })?;\n+                    let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                     throw_machine_stop!(TerminationInfo::Abort(\n                         \"the program aborted execution\".to_owned()\n                     ))\n                 }\n                 _ => {\n-                    if let Some(body) = this.lookup_exported_symbol(link_name_sym)? {\n+                    if let Some(body) = this.lookup_exported_symbol(link_name)? {\n                         return Ok(Some(body));\n                     }\n                     this.handle_unsupported(format!(\n@@ -277,7 +277,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             EmulateByNameResult::AlreadyJumped => (),\n             EmulateByNameResult::NotSupported => {\n-                if let Some(body) = this.lookup_exported_symbol(link_name_sym)? {\n+                if let Some(body) = this.lookup_exported_symbol(link_name)? {\n                     return Ok(Some(body));\n                 }\n \n@@ -292,7 +292,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Emulates calling a foreign item using its name.\n     fn emulate_foreign_item_by_name(\n         &mut self,\n-        link_name: &str,\n+        link_name: Symbol,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n@@ -302,11 +302,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Here we dispatch all the shims for foreign functions. If you have a platform specific\n         // shim, add it to the corresponding submodule.\n-        match link_name {\n+        match &*link_name.as_str() {\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let ptr = this.force_ptr(ptr)?;\n                 if ptr.offset != Size::ZERO {\n@@ -317,28 +316,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Obtains a Miri backtrace. See the README for details.\n             \"miri_get_backtrace\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                this.handle_miri_get_backtrace(args, dest)?;\n+                // `check_shim` happens inside `handle_miri_get_backtrace`.\n+                this.handle_miri_get_backtrace(abi, link_name, args, dest)?;\n             }\n \n             // Resolves a Miri backtrace frame. See the README for details.\n             \"miri_resolve_frame\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                this.handle_miri_resolve_frame(args, dest)?;\n+                // `check_shim` happens inside `handle_miri_resolve_frame`.\n+                this.handle_miri_resolve_frame(abi, link_name, args, dest)?;\n             }\n \n \n             // Standard C allocation\n             \"malloc\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref size] = check_arg_count(args)?;\n+                let &[ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref items, ref len] = check_arg_count(args)?;\n+                let &[ref items, ref len] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let items = this.read_scalar(items)?.to_machine_usize(this)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 let size =\n@@ -347,14 +344,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"free\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref old_ptr, ref new_size] = check_arg_count(args)?;\n+                let &[ref old_ptr, ref new_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let old_ptr = this.read_scalar(old_ptr)?.check_init()?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n@@ -365,8 +360,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // (Usually these would be forwarded to to `#[global_allocator]`; we instead implement a generic\n             // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                let &[ref size, ref align] = check_arg_count(args)?;\n+                let &[ref size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n@@ -378,8 +372,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                let &[ref size, ref align] = check_arg_count(args)?;\n+                let &[ref size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n@@ -393,8 +386,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                let &[ref ptr, ref old_size, ref align] = check_arg_count(args)?;\n+                let &[ref ptr, ref old_size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -407,8 +399,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                this.check_abi(abi, Abi::Rust)?;\n-                let &[ref ptr, ref old_size, ref align, ref new_size] = check_arg_count(args)?;\n+                let &[ref ptr, ref old_size, ref align, ref new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -428,8 +419,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // C memory handling functions\n             \"memcmp\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref left, ref right, ref n] = check_arg_count(args)?;\n+                let &[ref left, ref right, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let left = this.read_scalar(left)?.check_init()?;\n                 let right = this.read_scalar(right)?.check_init()?;\n                 let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n@@ -449,8 +439,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"memrchr\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n+                let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -468,8 +457,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"memchr\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n+                let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -486,8 +474,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"strlen\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n@@ -503,11 +490,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asinf\"\n             | \"atanf\"\n             => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref f] = check_arg_count(args)?;\n+                let &[ref f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n-                let f = match link_name {\n+                let f = match &*link_name.as_str() {\n                     \"cbrtf\" => f.cbrt(),\n                     \"coshf\" => f.cosh(),\n                     \"sinhf\" => f.sinh(),\n@@ -524,14 +510,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref f1, ref f2] = check_arg_count(args)?;\n+                let &[ref f1, ref f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n                 let f1 = f32::from_bits(this.read_scalar(f1)?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n-                let n = match link_name {\n+                let n = match &*link_name.as_str() {\n                     \"_hypotf\" | \"hypotf\" => f1.hypot(f2),\n                     \"atan2f\" => f1.atan2(f2),\n                     _ => bug!(),\n@@ -547,11 +532,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asin\"\n             | \"atan\"\n             => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref f] = check_arg_count(args)?;\n+                let &[ref f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n-                let f = match link_name {\n+                let f = match &*link_name.as_str() {\n                     \"cbrt\" => f.cbrt(),\n                     \"cosh\" => f.cosh(),\n                     \"sinh\" => f.sinh(),\n@@ -568,12 +552,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypot\"\n             | \"atan2\"\n             => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref f1, ref f2] = check_arg_count(args)?;\n+                let &[ref f1, ref f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n-                let n = match link_name {\n+                let n = match &*link_name.as_str() {\n                     \"_hypot\" | \"hypot\" => f1.hypot(f2),\n                     \"atan2\" => f1.atan2(f2),\n                     _ => bug!(),\n@@ -585,8 +568,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref x, ref exp] = check_arg_count(args)?;\n+                let &[ref x, ref exp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(x)?.to_f64()?;\n                 let exp = this.read_scalar(exp)?.to_i32()?;\n@@ -607,13 +589,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Architecture-specific shims\n             \"llvm.x86.sse2.pause\" if this.tcx.sess.target.arch == \"x86\" || this.tcx.sess.target.arch == \"x86_64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.yield_active_thread();\n             }\n             \"llvm.aarch64.isb\" if this.tcx.sess.target.arch == \"aarch64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref arg] = check_arg_count(args)?;\n+                let &[ref arg] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let arg = this.read_scalar(arg)?.to_i32()?;\n                 match arg {\n                     15 => { // SY (\"full system scope\")"}, {"sha": "68b648f32718a7b324b6eb8dcdfd809a8c165cf2", "filename": "src/shims/panic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -15,6 +15,7 @@ use log::trace;\n \n use rustc_ast::Mutability;\n use rustc_middle::{mir, ty};\n+use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n \n@@ -40,6 +41,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     fn handle_miri_start_panic(\n         &mut self,\n+        abi: Abi,\n+        link_name: Symbol,\n         args: &[OpTy<'tcx, Tag>],\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -48,7 +51,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"miri_start_panic: {:?}\", this.frame().instance);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n-        let &[ref payload] = check_arg_count(args)?;\n+        let &[ref payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n         let payload = this.read_scalar(payload)?.check_init()?;\n         let thread = this.active_thread_mut();\n         assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");"}, {"sha": "4035deff63ef048e8e7d01563fc0414c1401ec74", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 66, "deletions": 124, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -1,11 +1,11 @@\n use log::trace;\n \n use rustc_middle::mir;\n+use rustc_span::Symbol;\n use rustc_target::abi::{Align, LayoutOf, Size};\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_arg_count;\n use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::sync::EvalContextExt as _;\n@@ -15,72 +15,66 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n-        link_name: &str,\n+        link_name: Symbol,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n-        match link_name {\n+        match &*link_name.as_str() {\n             // Environment related shims\n             \"getenv\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name, ref value, ref overwrite] = check_arg_count(args)?;\n+                let &[ref name, ref value, ref overwrite] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref buf, ref size] = check_arg_count(args)?;\n+                let &[ref buf, ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path] = check_arg_count(args)?;\n+                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path, ref flag, ref mode] = check_arg_count(args)?;\n+                let &[ref path, ref flag, ref mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n+                // `fcntl` is variadic. The argument count is checked based on the first argument\n+                // in `this.fcntl()`, so we do not use `check_shim` here.\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n                 let result = this.fcntl(args)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref buf, ref count] = check_arg_count(args)?;\n+                let &[ref fd, ref buf, ref count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref buf, ref n] = check_arg_count(args)?;\n+                let &[ref fd, ref buf, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n@@ -90,71 +84,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path] = check_arg_count(args)?;\n+                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref target, ref linkpath] = check_arg_count(args)?;\n+                let &[ref target, ref linkpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref oldpath, ref newpath] = check_arg_count(args)?;\n+                let &[ref oldpath, ref newpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path, ref mode] = check_arg_count(args)?;\n+                let &[ref path, ref mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path] = check_arg_count(args)?;\n+                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref dirp] = check_arg_count(args)?;\n+                let &[ref dirp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref offset, ref whence] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref whence] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd] = check_arg_count(args)?;\n+                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd] = check_arg_count(args)?;\n+                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref pathname, ref buf, ref bufsize] = check_arg_count(args)?;\n+                let &[ref pathname, ref buf, ref bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ret, ref align, ref size] = check_arg_count(args)?;\n+                let &[ref ret, ref align, ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n@@ -184,8 +167,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref handle, ref symbol] = check_arg_count(args)?;\n+                let &[ref handle, ref symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n                 let symbol_name = this.read_c_str(symbol)?;\n@@ -199,8 +181,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n                 let sysconfs = &[\n@@ -225,8 +206,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref key, ref dtor] = check_arg_count(args)?;\n+                let &[ref key, ref dtor] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n \n@@ -254,24 +234,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref key] = check_arg_count(args)?;\n+                let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref key] = check_arg_count(args)?;\n+                let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref key, ref new_ptr] = check_arg_count(args)?;\n+                let &[ref key, ref new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n@@ -283,178 +260,149 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr] = check_arg_count(args)?;\n+                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr, ref kind] = check_arg_count(args)?;\n+                let &[ref attr, ref kind] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr] = check_arg_count(args)?;\n+                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref mutex, ref attr] = check_arg_count(args)?;\n+                let &[ref mutex, ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr] = check_arg_count(args)?;\n+                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr] = check_arg_count(args)?;\n+                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond, ref attr] = check_arg_count(args)?;\n+                let &[ref cond, ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond] = check_arg_count(args)?;\n+                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond] = check_arg_count(args)?;\n+                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond, ref mutex] = check_arg_count(args)?;\n+                let &[ref cond, ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond, ref mutex, ref abstime] = check_arg_count(args)?;\n+                let &[ref cond, ref mutex, ref abstime] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref cond] = check_arg_count(args)?;\n+                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref thread, ref attr, ref start, ref arg] = check_arg_count(args)?;\n+                let &[ref thread, ref attr, ref start, ref arg] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref thread, ref retval] = check_arg_count(args)?;\n+                let &[ref thread, ref retval] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref thread] = check_arg_count(args)?;\n+                let &[ref thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref req, ref rem] = check_arg_count(args)?;\n+                let &[ref req, ref rem] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd] = check_arg_count(args)?;\n+                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n                 // FIXME: we just say nothing is a terminal.\n@@ -463,8 +411,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref prepare, ref parent, ref child] = check_arg_count(args)?;\n+                let &[ref prepare, ref parent, ref child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(child)?.check_init()?, this.memory.pointer_size())?;\n@@ -476,8 +423,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref _attr, ref guard_size] = check_arg_count(args)?;\n+                let &[ref _attr, ref guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n                 this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), &guard_size.into())?;\n@@ -489,29 +435,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[_] = check_arg_count(args)?;\n+                let &[_] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n             | \"pthread_attr_setstacksize\"\n             if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[_, _] = check_arg_count(args)?;\n+                let &[_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n \n             | \"signal\"\n             | \"sigaltstack\"\n             if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[_, _] = check_arg_count(args)?;\n+                let &[_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n             | \"sigaction\"\n             | \"mprotect\"\n             if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[_, _, _] = check_arg_count(args)?;\n+                let &[_, _, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n "}, {"sha": "1d551b9fa1ea7c555b7f91160c9e39e544f31696", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -1,7 +1,7 @@\n use rustc_middle::mir;\n+use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n-use crate::helpers::check_arg_count;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n@@ -13,19 +13,18 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n-        link_name: &str,\n+        link_name: Symbol,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n-        match link_name {\n+        match &*link_name.as_str() {\n             // errno\n             \"__errno_location\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n@@ -34,33 +33,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd] = check_arg_count(args)?;\n+                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n+                let &[ref dirp, ref entry, ref result] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref length] = check_arg_count(args)?;\n+                let &[ref fd, ref length] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref offset, ref len, ref advice] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref len, ref advice] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n                 this.read_scalar(len)?.to_machine_isize(this)?;\n@@ -69,26 +67,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref offset, ref nbytes, ref flags] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref nbytes, ref flags] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a POSIX function but it has only been tested on linux.\n-                let &[ref clk_id, ref tp] = check_arg_count(args)?;\n+                let &[ref clk_id, ref tp] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n-                let &[ref attr_place, ref addr_place, ref size_place] = check_arg_count(args)?;\n+                let &[ref attr_place, ref addr_place, ref size_place] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.deref_operand(attr_place)?;\n                 let addr_place = this.deref_operand(addr_place)?;\n                 let size_place = this.deref_operand(size_place)?;\n@@ -108,27 +106,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] = check_arg_count(args)?;\n+                let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr, ref clock_id] = check_arg_count(args)?;\n+                let &[ref attr, ref clock_id] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref attr, ref clock_id] = check_arg_count(args)?;\n+                let &[ref attr, ref clock_id] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n+                // We do not use `check_shim` here because `syscall` is variadic. The argument\n+                // count is checked bellow.\n+                this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n                 // extra arguments are simply ignored. However, all arguments need to be scalars;\n                 // other types might be treated differently by the calling convention.\n@@ -192,13 +192,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref ptr, ref len, ref flags] = check_arg_count(args)?;\n+                let &[ref ptr, ref len, ref flags] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref pid, ref cpusetsize, ref mask] = check_arg_count(args)?;\n+                let &[ref pid, ref cpusetsize, ref mask] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n                 this.deref_operand(mask)?;\n@@ -211,8 +211,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_getattr_np\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref _thread, ref _attr] = check_arg_count(args)?;\n+                let &[ref _thread, ref _attr] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n "}, {"sha": "47a860b96a87a1e37b3a99d9ad824a0864b5d5da", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -1,8 +1,8 @@\n use rustc_middle::mir;\n+use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_arg_count;\n use shims::foreign_items::EmulateByNameResult;\n use shims::posix::fs::EvalContextExt as _;\n use shims::posix::thread::EvalContextExt as _;\n@@ -11,111 +11,106 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n-        link_name: &str,\n+        link_name: Symbol,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, EmulateByNameResult> {\n         let this = self.eval_context_mut();\n \n-        match link_name {\n+        match &*link_name.as_str() {\n             // errno\n             \"__error\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref result] = check_arg_count(args)?;\n+                let &[ref result] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path, ref buf] = check_arg_count(args)?;\n+                let &[ref path, ref buf] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref path, ref buf] = check_arg_count(args)?;\n+                let &[ref path, ref buf] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref buf] = check_arg_count(args)?;\n+                let &[ref fd, ref buf] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n+                let &[ref dirp, ref entry, ref result] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref fd, ref length] = check_arg_count(args)?;\n+                let &[ref fd, ref length] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n             }\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref tv, ref tz] = check_arg_count(args)?;\n+                let &[ref tv, ref tz] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref info] = check_arg_count(args)?;\n+                let &[ref info] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref dtor, ref data] = check_arg_count(args)?;\n+                let &[ref dtor, ref data] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.check_init()?;\n@@ -125,34 +120,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref thread] = check_arg_count(args)?;\n+                let &[ref thread] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref thread] = check_arg_count(args)?;\n+                let &[ref thread] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n \n             // Threading\n             \"pthread_setname_np\" => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n-                let &[ref name] = check_arg_count(args)?;\n+                let &[ref name] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let name = this.read_scalar(name)?.check_init()?;\n                 this.pthread_setname_np(name)?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::C { unwind: false })?;\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n-                let &[ref addr, _, _, _, _, _] = check_arg_count(args)?;\n+                let &[ref addr, _, _, _, _, _] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;\n                 this.write_scalar(addr, dest)?;\n             }"}, {"sha": "1921af359423917fe9fc2561575f1f8df2f4ce1f", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 76, "deletions": 82, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -1,19 +1,19 @@\n use std::iter;\n \n use rustc_middle::mir;\n+use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use crate::*;\n-use helpers::check_arg_count;\n use shims::foreign_items::EmulateByNameResult;\n use shims::windows::sync::EvalContextExt as _;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n-        link_name: &str,\n+        link_name: Symbol,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n@@ -26,58 +26,56 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // DWORD = ULONG = u32\n         // BOOL = i32\n         // BOOLEAN = u8\n-        match link_name {\n+        match &*link_name.as_str() {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref name, ref buf, ref size] = check_arg_count(args)?;\n+                let &[ref name, ref buf, ref size] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref name, ref value] = check_arg_count(args)?;\n+                let &[ref name, ref value] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref env_block] = check_arg_count(args)?;\n+                let &[ref env_block] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref size, ref buf] = check_arg_count(args)?;\n+                let &[ref size, ref buf] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref path] = check_arg_count(args)?;\n+                let &[ref path] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref which] = check_arg_count(args)?;\n+                let &[ref which] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] =\n-                    check_arg_count(args)?;\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n@@ -111,8 +109,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref handle, ref flags, ref size] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref size] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n@@ -121,17 +119,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref handle, ref flags, ref ptr] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref handle, ref flags, ref ptr, ref size] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref ptr, ref size] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n@@ -142,22 +140,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref error] = check_arg_count(args)?;\n+                let &[ref error] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref system_info] = check_arg_count(args)?;\n+                let &[ref system_info] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n                 this.memory.write_bytes(\n@@ -172,25 +169,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"TlsAlloc\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = this.machine.tls.create_tls_key(None, dest.layout.size)?;\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref key] = check_arg_count(args)?;\n+                let &[ref key] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref key, ref new_ptr] = check_arg_count(args)?;\n+                let &[ref key, ref new_ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n@@ -202,8 +198,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n                     dest,\n@@ -212,65 +207,65 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref LPFILETIME] = check_arg_count(args)?;\n+                let &[ref LPFILETIME] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref lpPerformanceCount] = check_arg_count(args)?;\n+                let &[ref lpPerformanceCount] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref lpFrequency] = check_arg_count(args)?;\n+                let &[ref lpFrequency] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr] = check_arg_count(args)?;\n+                let &[ref ptr] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n+                let &[ref hModule, ref lpProcName] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n                 let name = this.read_c_str(this.read_scalar(lpProcName)?.check_init()?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n@@ -284,16 +279,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // This is really 'RtlGenRandom'.\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref ptr, ref len] = check_arg_count(args)?;\n+                let &[ref ptr, ref len] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"BCryptGenRandom\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[ref algorithm, ref ptr, ref len, ref flags] = check_arg_count(args)?;\n+                let &[ref algorithm, ref ptr, ref len, ref flags] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n@@ -313,36 +308,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?; // STATUS_SUCCESS\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // `term` needs this, so we fake it.\n-                let &[ref console, ref buffer_info] = check_arg_count(args)?;\n+                let &[ref console, ref buffer_info] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(buffer_info)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n             \"GetConsoleMode\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n-                let &[ref console, ref mode] = check_arg_count(args)?;\n+                let &[ref console, ref mode] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(mode)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n             }\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n+                let &[_, _, _, _, _, _] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n                 this.handle_unsupported(\"can't create threads on Windows\")?;\n                 return Ok(EmulateByNameResult::AlreadyJumped);\n@@ -351,29 +346,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n-                let &[] = check_arg_count(args)?;\n+                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"SetConsoleTextAttribute\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n+                let &[ref _hConsoleOutput, ref _wAttribute] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n             \"AddVectoredExceptionHandler\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref _First, ref _Handler] = check_arg_count(args)?;\n+                let &[ref _First, ref _Handler] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n             \"SetThreadStackGuarantee\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[_StackSizeInBytes] = check_arg_count(args)?;\n+                let &[_StackSizeInBytes] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_u32(1), dest)?;\n             }\n@@ -383,9 +377,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"DeleteCriticalSection\"\n                 if this.frame_in_std() =>\n             {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref _lpCriticalSection] = check_arg_count(args)?;\n+                let &[ref _lpCriticalSection] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 assert_eq!(\n                     this.get_total_thread_count(),\n                     1,\n@@ -396,9 +390,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // so not doing any futher checks here is at least not incorrect.)\n             }\n             \"TryEnterCriticalSection\" if this.frame_in_std() => {\n-                this.check_abi(abi, Abi::System { unwind: false })?;\n                 #[allow(non_snake_case)]\n-                let &[ref _lpCriticalSection] = check_arg_count(args)?;\n+                let &[ref _lpCriticalSection] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 assert_eq!(\n                     this.get_total_thread_count(),\n                     1,"}, {"sha": "85e1b9deeb36f548b0e93508e8a5b5b9d82eddac", "filename": "tests/compile-fail/function_calls/check_arg_count_abort.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fcheck_arg_count_abort.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    extern \"C\" {\n+        fn abort(_: i32) -> !;\n+    }\n+\n+    unsafe {\n+        abort(1);\n+        //~^ ERROR Undefined Behavior: incorrect number of arguments: got 1, expected 0\n+    }\n+}"}, {"sha": "c46d57cee0dded51afbd80f52327e00589b8a405", "filename": "tests/compile-fail/function_calls/exported_symbol_shim_clashing.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_shim_clashing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_shim_clashing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffunction_calls%2Fexported_symbol_shim_clashing.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -0,0 +1,15 @@\n+#[no_mangle]\n+extern \"C\" fn malloc(_: usize) -> *mut std::ffi::c_void {\n+    //~^ HELP the `malloc` symbol is defined here\n+    unreachable!()\n+}\n+\n+fn main() {\n+    extern \"C\" {\n+        fn malloc(_: usize) -> *mut std::ffi::c_void;\n+    }\n+    unsafe {\n+        malloc(0);\n+        //~^ ERROR found `malloc` symbol definition that clashes with a built-in shim\n+    }\n+}"}, {"sha": "58115542332f205f6fcfc38a01d507c74aac2a5b", "filename": "tests/run-pass/function_calls/exported_symbol.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/486b5dfe74ced6ba93953fe91483815138bd370f/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_calls%2Fexported_symbol.rs?ref=486b5dfe74ced6ba93953fe91483815138bd370f", "patch": "@@ -15,26 +15,20 @@ fn baz() -> i32 {\n     -3\n }\n \n-// Make sure shims take precedence.\n-#[no_mangle]\n-extern \"C\" fn exit(_: i32) -> ! {\n-    unreachable!()\n-}\n-\n-#[no_mangle]\n-extern \"C\" fn ExitProcess(_: u32) -> ! {\n-    unreachable!()\n-}\n-\n fn main() {\n     // Repeat calls to make sure the `Instance` cache is not broken.\n     for _ in 0..3 {\n         extern \"C\" {\n             fn foo() -> i32;\n+            fn free(_: *mut std::ffi::c_void);\n         }\n \n         assert_eq!(unsafe { foo() }, -1);\n \n+        // `free()` is a built-in shim, so calling it will add (\"free\", None) to the cache.\n+        // Test that the cache is not broken with (\"free\", None).\n+        unsafe { free(std::ptr::null_mut()) }\n+\n         extern \"Rust\" {\n             fn bar() -> i32;\n             fn baz() -> i32;"}]}