{"sha": "cf6461168f5a784c996ffd6618d23f33113d2819", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNjQ2MTE2OGY1YTc4NGM5OTZmZmQ2NjE4ZDIzZjMzMTEzZDI4MTk=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-08-25T02:34:31Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2016-08-25T07:40:42Z"}, "message": "Fix debug line info for macro expansions. \n\n\n\nMacro expansions produce code tagged with debug locations that are completely different from the surrounding expressions.  This wrecks havoc on debugger's ability the step over source lines.\n\nIn order to have a good line stepping behavior in debugger, we overwrite debug locations of macro expansions with that of the outermost expansion site.", "tree": {"sha": "8bd9a633f4f1ac054d316c0b1d0d4bc7dfbf9569", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd9a633f4f1ac054d316c0b1d0d4bc7dfbf9569"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf6461168f5a784c996ffd6618d23f33113d2819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf6461168f5a784c996ffd6618d23f33113d2819", "html_url": "https://github.com/rust-lang/rust/commit/cf6461168f5a784c996ffd6618d23f33113d2819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf6461168f5a784c996ffd6618d23f33113d2819/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bc1bac8c7664fb1b487879b3fbd56221f6a721", "html_url": "https://github.com/rust-lang/rust/commit/e9bc1bac8c7664fb1b487879b3fbd56221f6a721"}], "stats": {"total": 351, "additions": 298, "deletions": 53}, "files": [{"sha": "faf2f7dae08c5a9793eb8ba303e02e8f88e146ee", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -237,7 +237,7 @@ impl CodeExtent {\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n                         let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span { lo: stmt_span.hi, ..blk.span })\n+                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, expn_id: stmt_span.expn_id })\n                     }\n                 }\n             }"}, {"sha": "8a32797dbd75a82e59410042408129a16b6a874f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -891,6 +891,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"force overflow checks on or off\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n+    debug_macros: bool = (false, parse_bool, [TRACKED],\n+          \"emit line numbers debug info inside macros\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n           \"force nonzeroing move optimization on\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "754910c246d6f599203a47dd72590b7927406867", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -1796,6 +1796,11 @@ extern {\n                                                Col: c_uint)\n                                                -> DILexicalBlock;\n \n+    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: DIBuilderRef,\n+                                                   Scope: DIScope,\n+                                                   File: DIFile)\n+                                                   -> DILexicalBlock;\n+\n     pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n                                                  Context: DIScope,\n                                                  Name: *const c_char,"}, {"sha": "21716d55ac6fa33c67d950d467f4d49deae26574", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -25,11 +25,33 @@ use syntax_pos::Pos;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n+use syntax_pos::BytePos;\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct MirDebugScope {\n+    pub scope_metadata: DIScope,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl MirDebugScope {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_null()\n+    }\n+}\n+\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, DIScope> {\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, MirDebugScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = IndexVec::from_elem(ptr::null_mut(), &mir.visibility_scopes);\n+    let null_scope = MirDebugScope {\n+        scope_metadata: ptr::null_mut(),\n+        file_start_pos: BytePos(0),\n+        file_end_pos: BytePos(0)\n+    };\n+    let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -59,8 +81,8 @@ fn make_mir_scope(ccx: &CrateContext,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n                   scope: VisibilityScope,\n-                  scopes: &mut IndexVec<VisibilityScope, DIScope>) {\n-    if !scopes[scope].is_null() {\n+                  scopes: &mut IndexVec<VisibilityScope, MirDebugScope>) {\n+    if scopes[scope].is_valid() {\n         return;\n     }\n \n@@ -70,7 +92,12 @@ fn make_mir_scope(ccx: &CrateContext,\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n-        scopes[scope] = fn_metadata;\n+        let loc = span_start(ccx, mir.span);\n+        scopes[scope] = MirDebugScope {\n+            scope_metadata: fn_metadata,\n+            file_start_pos: loc.file.start_pos,\n+            file_end_pos: loc.file.end_pos,\n+        };\n         return;\n     };\n \n@@ -81,20 +108,25 @@ fn make_mir_scope(ccx: &CrateContext,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope != fn_metadata {\n+        if parent_scope.scope_metadata != fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n-    scopes[scope] = unsafe {\n     let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n+    let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n-            parent_scope,\n+            parent_scope.scope_metadata,\n             file_metadata,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint)\n     };\n+    scopes[scope] = MirDebugScope {\n+        scope_metadata: scope_metadata,\n+        file_start_pos: loc.file.start_pos,\n+        file_end_pos: loc.file.end_pos,\n+    };\n }"}, {"sha": "fccb326b23221ecc0c69f1923bff6979947fc265", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -22,7 +22,7 @@ use context::SharedCrateContext;\n use session::Session;\n \n use llvm::{self, ValueRef};\n-use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DILexicalBlock};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -1839,3 +1839,17 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     ptr::null_mut());\n     }\n }\n+\n+// Creates an \"extension\" of an existing DIScope into another file.\n+pub fn extend_scope_to_file(ccx: &CrateContext,\n+                            scope_metadata: DIScope,\n+                            file: &syntax_pos::FileMap)\n+                            -> DILexicalBlock {\n+    let file_metadata = file_metadata(ccx, &file.name, &file.abs_path);\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n+            DIB(ccx),\n+            scope_metadata,\n+            file_metadata)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "58425cf60d5500767513c864eb47362fdeac5c5f", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -53,9 +53,10 @@ pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::create_scope_map::create_mir_scopes;\n+pub use self::create_scope_map::{create_mir_scopes, MirDebugScope};\n pub use self::source_loc::start_emitting_source_locations;\n pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::extend_scope_to_file;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;"}, {"sha": "1934f7b870d187be0f06dbd18ca2b306a20c7570", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 100, "deletions": 41, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -10,18 +10,17 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n-use llvm::debuginfo::DIScope;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n use common::{self, Block, BlockAndBuilder, CrateContext, FunctionContext, C_null};\n-use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n+use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind, FunctionDebugContext};\n use machine;\n use type_of;\n \n-use syntax_pos::DUMMY_SP;\n+use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n@@ -103,12 +102,67 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::VisibilityScope, DIScope>\n+    scopes: IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n }\n \n impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n-        DebugLoc::ScopeAt(self.scopes[source_info.scope], source_info.span)\n+    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> DebugLoc {\n+        // Bail out if debug info emission is not enabled.\n+        match self.fcx.debug_context {\n+            FunctionDebugContext::DebugInfoDisabled |\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                // Can't return DebugLoc::None here because intrinsic::trans_intrinsic_call()\n+                // relies on debug location to obtain span of the call site.\n+                return DebugLoc::ScopeAt(self.scopes[source_info.scope].scope_metadata,\n+                                         source_info.span);\n+            }\n+            FunctionDebugContext::RegularContext(_) =>{}\n+        }\n+\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        if source_info.span.expn_id == NO_EXPANSION ||\n+            source_info.span.expn_id == COMMAND_LINE_EXPN ||\n+            self.fcx.ccx.sess().opts.debugging_opts.debug_macros {\n+\n+            let scope_metadata = self.scope_metadata_for_loc(source_info.scope,\n+                                                             source_info.span.lo);\n+            DebugLoc::ScopeAt(scope_metadata, source_info.span)\n+        } else {\n+            let cm = self.fcx.ccx.sess().codemap();\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            let mut span = source_info.span;\n+            while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n+                if let Some(callsite_span) = cm.with_expn_info(span.expn_id,\n+                                                    |ei| ei.map(|ei| ei.call_site.clone())) {\n+                    span = callsite_span;\n+                } else {\n+                    break;\n+                }\n+            }\n+            let scope_metadata = self.scope_metadata_for_loc(source_info.scope, span.lo);\n+            // Use span of the outermost call site, while keeping the original lexical scope\n+            DebugLoc::ScopeAt(scope_metadata, span)\n+        }\n+    }\n+\n+    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    // it may so happen that the current span belongs to a different file than the DIScope\n+    // corresponding to span's containing visibility scope.  If so, we need to create a DIScope\n+    // \"extension\" into that file.\n+    fn scope_metadata_for_loc(&self, scope_id: mir::VisibilityScope, pos: BytePos)\n+                               -> llvm::debuginfo::DIScope {\n+        let scope_metadata = self.scopes[scope_id].scope_metadata;\n+        if pos < self.scopes[scope_id].file_start_pos ||\n+           pos >= self.scopes[scope_id].file_end_pos {\n+            let cm = self.fcx.ccx.sess().codemap();\n+            debuginfo::extend_scope_to_file(self.fcx.ccx,\n+                                            scope_metadata,\n+                                            &cm.lookup_char_pos(pos).file)\n+        } else {\n+            scope_metadata\n+        }\n     }\n }\n \n@@ -155,16 +209,38 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n          analyze::cleanup_kinds(bcx, &mir))\n     });\n \n+    // Allocate a `Block` for every basic block\n+    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n+        mir.basic_blocks().indices().map(|bb| {\n+            if bb == mir::START_BLOCK {\n+                fcx.new_block(\"start\")\n+            } else {\n+                fcx.new_block(&format!(\"{:?}\", bb))\n+            }\n+        }).collect();\n+\n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n+    let mut mircx = MirContext {\n+        mir: mir.clone(),\n+        fcx: fcx,\n+        llpersonalityslot: None,\n+        blocks: block_bcxs,\n+        unreachable_block: None,\n+        cleanup_kinds: cleanup_kinds,\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        scopes: scopes,\n+        locals: IndexVec::new(),\n+    };\n+\n     // Allocate variable and temp allocas\n-    let locals = {\n-        let args = arg_local_refs(&bcx, &mir, &scopes, &lvalue_locals);\n+    mircx.locals = {\n+        let args = arg_local_refs(&bcx, &mir, &mircx.scopes, &lvalue_locals);\n         let vars = mir.var_decls.iter().enumerate().map(|(i, decl)| {\n             let ty = bcx.monomorphize(&decl.ty);\n-            let scope = scopes[decl.source_info.scope];\n-            let dbg = !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo;\n+            let debug_scope = mircx.scopes[decl.source_info.scope];\n+            let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n             let local = mir.local_index(&mir::Lvalue::Var(mir::Var::new(i))).unwrap();\n             if !lvalue_locals.contains(local.index()) && !dbg {\n@@ -173,11 +249,16 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n             let lvalue = LvalueRef::alloca(&bcx, ty, &decl.name.as_str());\n             if dbg {\n-                bcx.with_block(|bcx| {\n-                    declare_local(bcx, decl.name, ty, scope,\n-                                VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                                VariableKind::LocalVariable, decl.source_info.span);\n-                });\n+                let dbg_loc = mircx.debug_loc(decl.source_info);\n+                if let DebugLoc::ScopeAt(scope, span) = dbg_loc {\n+                    bcx.with_block(|bcx| {\n+                        declare_local(bcx, decl.name, ty, scope,\n+                                    VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                                    VariableKind::LocalVariable, span);\n+                    });\n+                } else {\n+                    panic!(\"Unexpected\");\n+                }\n             }\n             LocalRef::Lvalue(lvalue)\n         });\n@@ -203,37 +284,15 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         })).collect()\n     };\n \n-    // Allocate a `Block` for every basic block\n-    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n-        mir.basic_blocks().indices().map(|bb| {\n-            if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\")\n-            } else {\n-                fcx.new_block(&format!(\"{:?}\", bb))\n-            }\n-        }).collect();\n-\n     // Branch to the START block\n-    let start_bcx = block_bcxs[mir::START_BLOCK];\n+    let start_bcx = mircx.blocks[mir::START_BLOCK];\n     bcx.br(start_bcx.llbb);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(fcx);\n \n-    let mut mircx = MirContext {\n-        mir: mir.clone(),\n-        fcx: fcx,\n-        llpersonalityslot: None,\n-        blocks: block_bcxs,\n-        unreachable_block: None,\n-        cleanup_kinds: cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n-        locals: locals,\n-        scopes: scopes\n-    };\n-\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     let mut rpo = traversal::reverse_postorder(&mir);\n@@ -271,7 +330,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n /// indirect.\n fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>,\n-                              scopes: &IndexVec<mir::VisibilityScope, DIScope>,\n+                              scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                               lvalue_locals: &BitVector)\n                               -> Vec<LocalRef<'tcx>> {\n     let fcx = bcx.fcx();\n@@ -281,8 +340,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n-    let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n-        Some(arg_scope)\n+    let arg_scope = if arg_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+        Some(arg_scope.scope_metadata)\n     } else {\n         None\n     };"}, {"sha": "82fb2b0918f79fcfedb4f37614103f47bbd1dee3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -521,6 +521,15 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n         ));\n }\n \n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlockFile(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n+    LLVMRustMetadataRef File) {\n+    return wrap(Builder->createLexicalBlockFile(\n+        unwrapDI<DIDescriptor>(Scope),\n+        unwrapDI<DIFile>(File)));\n+}\n+\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     LLVMRustDIBuilderRef Builder,\n     LLVMRustMetadataRef Context,"}, {"sha": "1006b684a8c22e1f4fafc322ddbad1a5efee393b", "filename": "src/test/debuginfo/auxiliary/macro-stepping.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-g\n+\n+#![crate_type = \"rlib\"]\n+\n+#[macro_export]\n+macro_rules! new_scope {\n+    () => {\n+        let x = 1;\n+    }\n+}"}, {"sha": "eb5798dc7cc486746d250e2ca2481ea0eabeaab6", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -10,7 +10,7 @@\n \n // min-lldb-version: 310\n \n-// compile-flags:-g\n+// compile-flags:-g -Zdebug-macros\n \n // === GDB TESTS ===================================================================================\n "}, {"sha": "52a2a58ed7d27d17bf6445df6eb234e67c0f3af5", "filename": "src/test/debuginfo/macro-stepping.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6461168f5a784c996ffd6618d23f33113d2819/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs?ref=cf6461168f5a784c996ffd6618d23f33113d2819", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-android\n+// min-lldb-version: 310\n+\n+// aux-build:macro-stepping.rs\n+\n+#![allow(unused)]\n+\n+#[macro_use]\n+extern crate macro_stepping; // exports new_scope!()\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc1[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc2[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc3[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc4[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc5[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc6[...]\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:set set stop-line-count-before 0\n+// lldb-command:set set stop-line-count-after 1\n+// Can't set both to zero or lldb will stop printing source at all.  So it will output the current\n+// line and the next.  We deal with this by having at least 2 lines between the #loc's\n+\n+// lldb-command:run\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc1[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc2[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc3[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc4[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc5[...]\n+\n+macro_rules! foo {\n+    () => {\n+        let a = 1;\n+        let b = 2;\n+        let c = 3;\n+    }\n+}\n+\n+macro_rules! foo2 {\n+    () => {\n+        foo!();\n+        let x = 1;\n+        foo!();\n+    }\n+}\n+\n+fn main() {\n+    zzz(); // #break\n+\n+    foo!(); // #loc1\n+\n+    foo2!(); // #loc2\n+\n+    let x = vec![42]; // #loc3\n+\n+    new_scope!(); // #loc4\n+\n+    println!(\"Hello {}\", // #loc5\n+             \"world\");\n+\n+    zzz(); // #loc6\n+}\n+\n+fn zzz() {()}"}]}