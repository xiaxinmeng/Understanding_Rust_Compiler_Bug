{"sha": "a7e1a35f8836f78894a4499ac7bebcc76472f172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZTFhMzVmODgzNmY3ODg5NGE0NDk5YWM3YmViY2M3NjQ3MmYxNzI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-04T10:32:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-04T16:28:51Z"}, "message": "Properly typecheck and compile invocations of generic methods.\n\nAligning the type parameters of the ifaces, impls, and methods\ncorrectly in typeck is almost brain surgery. Seems to work now for\neverything I threw at it, but might still break in other corner cases.\n\nIssue #1227", "tree": {"sha": "b61e43ec7d9751fe5b6b0cdc0d45c76ed5f4191c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b61e43ec7d9751fe5b6b0cdc0d45c76ed5f4191c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e1a35f8836f78894a4499ac7bebcc76472f172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e1a35f8836f78894a4499ac7bebcc76472f172", "html_url": "https://github.com/rust-lang/rust/commit/a7e1a35f8836f78894a4499ac7bebcc76472f172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e1a35f8836f78894a4499ac7bebcc76472f172/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ffe5034b341a9a522c01705cafdb19bac9cedb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ffe5034b341a9a522c01705cafdb19bac9cedb", "html_url": "https://github.com/rust-lang/rust/commit/d1ffe5034b341a9a522c01705cafdb19bac9cedb"}], "stats": {"total": 403, "additions": 236, "deletions": 167}, "files": [{"sha": "8e174ead713dcd373d88545e12bcafc70242f59a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -37,7 +37,7 @@ tag scope {\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n-    scope_self(ast::node_id);\n+    scope_method(ast::node_id, [ast::ty_param]);\n }\n \n type scopes = list<scope>;\n@@ -404,9 +404,17 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n         alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n         v.visit_ty(sty, sc, v);\n         for m in methods {\n-            v.visit_fn(visit::fk_method(m.ident, tps + m.tps),\n-                       m.decl, m.body, m.span,\n-                       m.id, sc, v);\n+            let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n+            v.visit_fn(visit::fk_method(m.ident, []),\n+                       m.decl, m.body, m.span, m.id, msc, v);\n+        }\n+      }\n+      ast::item_iface(tps, methods) {\n+        visit::visit_ty_params(tps, sc, v);\n+        for m in methods {\n+            let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n+            for a in m.decl.inputs { v.visit_ty(a.ty, msc, v); }\n+            v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n       _ { visit::visit_item(i, sc, v); }\n@@ -437,8 +445,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // for f's constrs in the table.\n     for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n-      visit::fk_item_fn(_, tps) | visit::fk_method(_, tps) |\n-      visit::fk_res(_, tps) {\n+      visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n+      visit::fk_method(_, tps) {\n         scope_bare_fn(decl, id, tps)\n       }\n       visit::fk_anon(_) | visit::fk_fn_block. {\n@@ -491,7 +499,7 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n         v.visit_block(blk, new_sc, v);\n       }\n       ast::expr_anon_obj(_) {\n-        visit::visit_expr(x, cons(scope_self(x.id), @sc), v);\n+        visit::visit_expr(x, cons(scope_method(x.id, []), @sc), v);\n       }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n@@ -801,9 +809,6 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                 ret lookup_in_obj(name, ob, ty_params, ns, it.id);\n               }\n               ast::item_impl(ty_params, _, _, _) {\n-                if (name == \"self\" && ns == ns_value) {\n-                    ret some(ast::def_self(local_def(it.id)));\n-                }\n                 if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n               }\n               ast::item_iface(tps, _) | ast::item_tag(_, tps) |\n@@ -819,9 +824,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               _ { }\n             }\n           }\n-          scope_self(id) {\n+          scope_method(id, tps) {\n             if (name == \"self\" && ns == ns_value) {\n                 ret some(ast::def_self(local_def(id)));\n+            } else if ns == ns_type {\n+                ret lookup_in_ty_params(name, tps);\n             }\n           }\n           scope_native_item(it) {"}, {"sha": "d67fbedf8a4fcdd2c4b9530a345bdb54a8dcd130", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -37,12 +37,13 @@ fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n     {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n }\n \n-fn trans_dict_callee(bcx: @block_ctxt, _e: @ast::expr, base: @ast::expr,\n+fn trans_dict_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n                      iface_id: ast::def_id, n_method: uint,\n                      n_param: uint, n_bound: uint) -> lval_maybe_callee {\n+    let tcx = bcx_tcx(bcx);\n     let {bcx, val} = trans_self_arg(bcx, base);\n     let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n-    let method = ty::iface_methods(bcx_tcx(bcx), iface_id)[n_method];\n+    let method = ty::iface_methods(tcx, iface_id)[n_method];\n     let bare_fn_ty = type_of_fn(bcx_ccx(bcx), ast_util::dummy_sp(),\n                                 false, method.fty.inputs, method.fty.output,\n                                 *method.tps);\n@@ -51,9 +52,26 @@ fn trans_dict_callee(bcx: @block_ctxt, _e: @ast::expr, base: @ast::expr,\n     let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n                              T_ptr(T_array(T_ptr(fn_ty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n+    let generic = none;\n+    if vec::len(*method.tps) > 0u {\n+        let tydescs = [], tis = [];\n+        for t in ty::node_id_to_type_params(tcx, e.id) {\n+            // TODO: Doesn't always escape.\n+            let ti = none;\n+            let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n+            tis += [ti];\n+            tydescs += [td.val];\n+            bcx = td.bcx;\n+        }\n+        generic = some({item_type: ty::mk_fn(tcx, method.fty),\n+                        static_tis: tis,\n+                        tydescs: tydescs,\n+                        param_bounds: method.tps,\n+                        origins: bcx_ccx(bcx).dict_map.find(e.id)});\n+    }\n     {bcx: bcx, val: mptr, kind: owned,\n      env: dict_env(dict, val),\n-     generic: none} // FIXME[impl] fetch generic info for method\n+     generic: generic}\n }\n \n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {"}, {"sha": "1a0a295ed459de49202afc2261b17ffedc1dcae0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -18,7 +18,7 @@ import util::common::*;\n import syntax::util::interner;\n import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n-import util::ppaux::mode_str_1;\n+import util::ppaux::mode_str;\n import syntax::print::pprust::*;\n \n export node_id_to_monotype;\n@@ -1739,7 +1739,7 @@ mod unify {\n     export ures_ok;\n     export ures_err;\n     export var_bindings;\n-    export precise, in_bindings, bind_params;\n+    export precise, in_bindings;\n \n     tag result { ures_ok(t); ures_err(type_err); }\n     tag union_result { unres_ok; unres_err(type_err); }\n@@ -1753,7 +1753,6 @@ mod unify {\n     tag unify_style {\n         precise;\n         in_bindings(@var_bindings);\n-        bind_params(@mutable [mutable option::t<t>]);\n     }\n     type ctxt = {st: unify_style, tcx: ty_ctxt};\n \n@@ -2172,16 +2171,6 @@ mod unify {\n             }\n             ret ures_ok(mk_var(cx.tcx, actual_id));\n           }\n-          ty::ty_param(n, _) {\n-            alt cx.st {\n-              bind_params(cell) {\n-                while vec::len(*cell) < n + 1u { *cell += [mutable none]; }\n-                cell[n] = some(expected);\n-                ret ures_ok(expected);\n-              }\n-              _ {}\n-            }\n-          }\n           _ {/* empty */ }\n         }\n         alt struct(cx.tcx, expected) {\n@@ -2627,8 +2616,8 @@ fn type_err_to_str(err: ty::type_err) -> str {\n                 \"' but found one with method '\" + a_meth + \"'\";\n       }\n       terr_mode_mismatch(e_mode, a_mode) {\n-        ret \"expected argument mode \" + mode_str_1(e_mode) + \" but found \" +\n-                mode_str_1(a_mode);\n+        ret \"expected argument mode \" + mode_str(e_mode) + \" but found \" +\n+                mode_str(a_mode);\n       }\n       terr_constr_len(e_len, a_len) {\n         ret \"Expected a type with \" + uint::str(e_len) +\n@@ -2646,24 +2635,17 @@ fn type_err_to_str(err: ty::type_err) -> str {\n \n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n-fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n+fn bind_params_in_type(cx: ctxt, next_ty_var: block() -> int, typ: t,\n                        ty_param_count: uint) -> {ids: [int], ty: t} {\n-    let param_var_ids: @mutable [int] = @mutable [];\n-    let i = 0u;\n-    while i < ty_param_count { *param_var_ids += [next_ty_var()]; i += 1u; }\n-    fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n-              _next_ty_var: fn@() -> int, index: uint, _did: def_id) -> t {\n-        if index < vec::len(*param_var_ids) {\n-            ret mk_var(cx, param_var_ids[index]);\n-        } else {\n-            cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n-        }\n-    }\n-    let new_typ =\n-        fold_ty(cx,\n-                fm_param(bind binder(sp, cx, param_var_ids, next_ty_var, _,\n-                                     _)), typ);\n-    ret {ids: *param_var_ids, ty: new_typ};\n+    let param_var_ids = [], i = 0u;\n+    while i < ty_param_count { param_var_ids += [next_ty_var()]; i += 1u; }\n+    let param_var_ids = @param_var_ids;\n+    fn binder(cx: ctxt, param_var_ids: @[int], index: uint,\n+              _did: def_id) -> t {\n+        ret mk_var(cx, param_var_ids[index]);\n+    }\n+    {ids: *param_var_ids,\n+     ty: fold_ty(cx, fm_param(bind binder(cx, param_var_ids, _, _)), typ)}\n }\n \n "}, {"sha": "61ecf68e0250b4ac66764a097aa03b0621eb75c0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 172, "deletions": 117, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -7,7 +7,7 @@ import driver::session;\n import util::common::*;\n import syntax::codemap::span;\n import middle::ty;\n-import middle::ty::{node_id_to_type, arg, bind_params_in_type, block_ty,\n+import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n                     ty_param_substs_opt_and_ty, ty_param_bounds_and_ty};\n import util::ppaux::ty_to_str;\n@@ -28,6 +28,15 @@ tag method_origin {\n }\n type method_map = hashmap<ast::node_id, method_origin>;\n \n+// Resolutions for bounds of all parameters, left to right, for a given path.\n+type dict_res = @[dict_origin];\n+tag dict_origin {\n+    dict_static(ast::def_id, [ty::t], dict_res);\n+    // Param number, bound number\n+    dict_param(uint, uint);\n+}\n+type dict_map = hashmap<ast::node_id, dict_res>;\n+\n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an object.\n@@ -39,6 +48,7 @@ tag self_info {\n type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n+                   dict_map: dict_map,\n                    tcx: ty::ctxt};\n \n type fn_ctxt =\n@@ -128,16 +138,18 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     }\n }\n \n+fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n+    -> {ids: [int], ty: ty::t} {\n+    ty::bind_params_in_type(fcx.ccx.tcx, {|| next_ty_var_id(fcx)}, tp, count)\n+}\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n                     tpt: ty_param_bounds_and_ty, sp: span)\n     -> ty_param_substs_opt_and_ty {\n     let ty_param_count = vec::len(*tpt.bounds);\n-    let bind_result =\n-        bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n-                            ty_param_count);\n+    let bind_result = bind_params(fcx, tpt.ty, ty_param_count);\n     let ty_param_vars = bind_result.ids;\n     let ty_substs_opt;\n     let ty_substs_len = vec::len::<@ast::ty>(pth.node.types);\n@@ -1489,7 +1501,7 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n \n fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                  name: ast::ident, ty: ty::t, sp: span)\n-    -> option::t<{method_ty: ty::t, n_tps: uint, ids: [int],\n+    -> option::t<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n                   origin: method_origin}> {\n     let tcx = fcx.ccx.tcx;\n \n@@ -1500,7 +1512,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n         for bound in *tcx.ty_param_bounds.get(did.node) {\n             alt bound {\n               ty::bound_iface(t) {\n-                let (iid, _tps) = alt ty::struct(tcx, t) {\n+                let (iid, tps) = alt ty::struct(tcx, t) {\n                     ty::ty_iface(i, tps) { (i, tps) }\n                     _ { ret none; }\n                 };\n@@ -1510,7 +1522,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     let m = ifce_methods[pos];\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),\n                               n_tps: vec::len(*m.tps),\n-                              ids: [], // FIXME[impl]\n+                              substs: tps,\n                               origin: method_param(iid, pos, n, bound_n)});\n                   }\n                   _ {}\n@@ -1544,9 +1556,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n               some(m) {\n                 let {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n                 let {ids, ty: self_ty} = if n_tps > 0u {\n-                    bind_params_in_type(ast_util::dummy_sp(), tcx,\n-                                        bind next_ty_var_id(fcx), self_ty,\n-                                        n_tps)\n+                    bind_params(fcx, self_ty, n_tps)\n                 } else { {ids: [], ty: self_ty} };\n                 alt unify::unify(fcx, ty, self_ty) {\n                   ures_ok(_) {\n@@ -1555,10 +1565,12 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                         tcx.sess.span_err(\n                             sp, \"multiple applicable methods in scope\");\n                     } else {\n-                        result = some({method_ty: ty_from_did(tcx, m.did),\n-                                       n_tps: m.n_tps,\n-                                       ids: ids,\n-                                       origin: method_static(m.did)});\n+                        result = some({\n+                            method_ty: ty_from_did(tcx, m.did),\n+                            n_tps: m.n_tps,\n+                            substs: vec::map(ids, {|id| ty::mk_var(tcx, id)}),\n+                            origin: method_static(m.did)\n+                        });\n                     }\n                   }\n                   _ {}\n@@ -2258,41 +2270,34 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !handled {\n             let iscope = fcx.ccx.impl_map.get(expr.id);\n             alt lookup_method(fcx, iscope, field, expr_t, expr.span) {\n-              some({method_ty: fty, n_tps: method_n_tps, ids, origin}) {\n-                let tvars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n-                let n_tps = vec::len(ids);\n-                if method_n_tps + n_tps  > 0u {\n-                    let b = bind_params_in_type(expr.span, tcx,\n-                                                bind next_ty_var_id(fcx), fty,\n-                                                n_tps + method_n_tps);\n-                    let _tvars = vec::map(b.ids, {|id| ty::mk_var(tcx, id)});\n-                    let i = 0;\n-                    for v in tvars {\n-                        demand::simple(fcx, expr.span, v, _tvars[i]);\n-                        i += 1;\n-                    }\n-                    tvars = _tvars;\n+              some({method_ty: fty, n_tps: method_n_tps, substs, origin}) {\n+                let substs = substs, n_tps = vec::len(substs);\n+                if method_n_tps + n_tps > 0u {\n                     if n_tys > 0u {\n                         if n_tys != method_n_tps {\n                             tcx.sess.span_fatal\n                                 (expr.span, \"incorrect number of type \\\n                                            parameters given for this method\");\n \n                         }\n-                        let i = 0u;\n                         for ty in tys {\n-                            let tvar = tvars[i + n_tps];\n-                            let t_subst = ast_ty_to_ty_crate(fcx.ccx, ty);\n-                            demand::simple(fcx, expr.span, tvar, t_subst);\n+                            substs += [ast_ty_to_ty_crate(fcx.ccx, ty)];\n+                        }\n+                    } else {\n+                        let i = 0u;\n+                        while i < method_n_tps {\n+                            substs += [ty::mk_var(tcx, next_ty_var_id(fcx))];\n                             i += 1u;\n                         }\n                     }\n+                    write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n                 } else if n_tys > 0u {\n                     tcx.sess.span_fatal(expr.span,\n                                         \"this method does not take type \\\n                                          parameters\");\n+                } else {\n+                    write::ty_only_fixup(fcx, id, fty);\n                 }\n-                write::ty_fixup(fcx, id, {substs: some(tvars), ty: fty});\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n               none. {\n@@ -2723,6 +2728,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // If we have an enclosing function scope, our type variables will be\n     // resolved when the enclosing scope finishes up.\n     if option::is_none(old_fcx) {\n+        dict::resolve_in_block(fcx, body);\n         writeback::resolve_type_vars_in_block(fcx, body);\n     }\n }\n@@ -2731,6 +2737,30 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n+fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+    if impl_m.tps != if_m.tps {\n+        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                          \"` has an incompatible set of type parameters\");\n+    } else {\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        // Add dummy substs for the parameters of the impl method\n+        let substs = substs + vec::init_fn({|i|\n+            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+        }, vec::len(*if_m.tps));\n+        let if_fty = ty::substitute_type_params(tcx, substs, \n+                                                ty::mk_fn(tcx, if_m.fty));\n+        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n+          ty::unify::ures_err(err) {\n+            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                              \"` has an incompatible type: \" +\n+                              ty::type_err_to_str(err));\n+          }\n+          _ {}\n+        }\n+    }\n+}\n+\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n@@ -2769,11 +2799,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                 for if_m in *ty::iface_methods(ccx.tcx, did) {\n                     alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n                       some(m) {\n-                        if !ty::same_method(ccx.tcx, m, if_m) {\n-                            ccx.tcx.sess.span_err(\n-                                ty.span, \"method `\" + if_m.ident +\n-                                \"` has the wrong type\");\n-                        }\n+                        compare_impl_method(ccx.tcx, ty.span, m,\n+                                            vec::len(tps), if_m, tys);\n                       }\n                       none. {\n                         ccx.tcx.sess.span_err(ty.span, \"missing method `\" +\n@@ -2879,80 +2906,25 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n-// Resolutions for bounds of all parameters, left to right, for a given path.\n-type dict_res = @[dict_origin];\n-tag dict_origin {\n-    dict_static(ast::def_id, [ty::t], dict_res);\n-    // Param number, bound number\n-    dict_param(uint, uint);\n-}\n-type dict_map = hashmap<ast::node_id, dict_res>;\n-\n-// Detect points where an interface-bounded type parameter is instantiated,\n-// resolve the impls for the parameters.\n-fn resolve_dicts(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-                 method_map: method_map, crate: @ast::crate) -> dict_map {\n-    type ccx = {tcx: ty::ctxt,\n-                impl_map: resolve::impl_map,\n-                method_map: method_map,\n-                dict_map: dict_map};\n-    let cx = {tcx: tcx, impl_map: impl_map,\n-              method_map: method_map, dict_map: new_int_hash()};\n-\n+mod dict {\n     fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n         vec::any(tps, {|bs|\n             vec::any(*bs, {|b|\n                 alt b { ty::bound_iface(_) { true } _ { false } }\n             })\n         })\n     }\n-    fn resolve_expr(ex: @ast::expr, cx: ccx, v: visit::vt<ccx>) {\n-        alt ex.node {\n-          ast::expr_path(_) {\n-            let substs = ty::node_id_to_ty_param_substs_opt_and_ty(\n-                cx.tcx, ex.id);\n-            alt substs.substs {\n-              some(ts) {\n-                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n-                let item_ty = ty::lookup_item_type(cx.tcx, did);\n-                if has_iface_bounds(*item_ty.bounds) {\n-                    let impls = cx.impl_map.get(ex.id);\n-                    cx.dict_map.insert(ex.id, lookup_dicts(\n-                        cx.tcx, impls, ex.span, item_ty.bounds, ts));\n-                }\n-              }\n-              _ {}\n-            }\n-          }\n-          // Must resolve bounds on methods with bounded params\n-          ast::expr_field(_, _, _) {\n-            alt cx.method_map.find(ex.id) {\n-              some(method_static(did)) {\n-                let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-                if has_iface_bounds(*bounds) {\n-                    let tys = ty::node_id_to_type_params(cx.tcx, ex.id);\n-                    let iscs = cx.impl_map.get(ex.id);\n-                    cx.dict_map.insert(ex.id, lookup_dicts(\n-                        cx.tcx, iscs, ex.span, bounds, tys));\n-                }\n-              }\n-              _ {}\n-            }\n-          }\n-          _ {}\n-        }\n-        visit::visit_expr(ex, cx, v);\n-    }\n \n-    fn lookup_dicts(tcx: ty::ctxt, isc: resolve::iscopes, sp: span,\n+    fn lookup_dicts(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                     bounds: @[ty::param_bounds], tys: [ty::t])\n         -> dict_res {\n-        let result = [], i = 0u;\n+        let tcx = fcx.ccx.tcx, result = [], i = 0u;\n         for ty in tys {\n             for bound in *bounds[i] {\n                 alt bound {\n                   ty::bound_iface(i_ty) {\n-                    result += [lookup_dict(tcx, isc, sp, ty, i_ty)];\n+                    let i_ty = ty::substitute_type_params(tcx, tys, i_ty);\n+                    result += [lookup_dict(fcx, isc, sp, ty, i_ty)];\n                   }\n                   _ {}\n                 }\n@@ -2962,12 +2934,14 @@ fn resolve_dicts(tcx: ty::ctxt, impl_map: resolve::impl_map,\n         @result\n     }\n \n-    fn lookup_dict(tcx: ty::ctxt, isc: resolve::iscopes, sp: span,\n+    fn lookup_dict(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                    ty: ty::t, iface_ty: ty::t) -> dict_origin {\n-        let iface_id = alt ty::struct(tcx, iface_ty) {\n-            ty::ty_iface(did, _) { did }\n+        let tcx = fcx.ccx.tcx;\n+        let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n+            ty::ty_iface(did, tps) { (did, tps) }\n             _ { tcx.sess.abort_if_errors(); fail; }\n         };\n+        let ty = fixup_ty(fcx, sp, ty);\n         alt ty::struct(tcx, ty) {\n           ty::ty_param(n, did) {\n             let n_bound = 0u;\n@@ -2991,22 +2965,27 @@ fn resolve_dicts(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 if option::is_some(found) { ret; }\n                 for im in *impls {\n                     if im.iface_did == some(iface_id) {\n-                        let self_ty = impl_self_ty(tcx, im.did).ty;\n+                        let {n_tps, ty: self_ty} = impl_self_ty(tcx, im.did);\n+                        let {ids, ty: self_ty} = if n_tps > 0u {\n+                            bind_params(fcx, self_ty, n_tps)\n+                        } else { {ids: [], ty: self_ty} };\n+                        let vars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                        let params = @mutable [mutable];\n-                        alt ty::unify::unify(ty, self_ty,\n-                                             ty::unify::bind_params(params),\n-                                             tcx) {\n+                        // FIXME[impl] don't do this in fcx (or make\n+                        // unify transactional by scrubbing bindings on fail)\n+                        alt unify::unify(fcx, ty, self_ty) {\n                           ures_ok(_) {\n                             if option::is_some(found) {\n                                 tcx.sess.span_err(\n                                     sp, \"multiple applicable implementations \\\n                                          in scope\");\n                             } else {\n-                                let params = vec::map_mut(\n-                                    *params, {|p| option::get(p)});\n-                                let subres = lookup_dicts(tcx, isc, sp,\n-                                                          im_bs, params);\n+                                connect_iface_tps(fcx, sp, vars, iface_tps,\n+                                                  im.did);\n+                                let params = vec::map(vars, {|t|\n+                                    fixup_ty(fcx, sp, t)});\n+                                let subres = lookup_dicts(fcx, isc, sp, im_bs,\n+                                                          params);\n                                 found = some(dict_static(im.did, params,\n                                                          subres));\n                             }\n@@ -3029,11 +3008,87 @@ fn resolve_dicts(tcx: ty::ctxt, impl_map: resolve::impl_map,\n             ty_to_str(tcx, ty));\n     }\n \n-    visit::visit_crate(*crate, cx, visit::mk_vt(@{\n-        visit_expr: resolve_expr\n-        with *visit::default_visitor()\n-    }));\n-    cx.dict_map\n+    fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n+        let tcx = fcx.ccx.tcx;\n+        alt ty::unify::fixup_vars(tcx, some(sp), fcx.var_bindings, ty) {\n+          fix_ok(new_type) { new_type }\n+          fix_err(vid) {\n+            tcx.sess.span_fatal(sp, \"could not determine a type for a \\\n+                                     bounded type parameter\");\n+          }\n+        }\n+    }\n+\n+    fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n+                         iface_tys: [ty::t], impl_did: ast::def_id) {\n+        let tcx = fcx.ccx.tcx;\n+        // FIXME[impl]\n+        assert impl_did.crate == ast::local_crate;\n+        let ity = alt tcx.items.get(impl_did.node) {\n+          ast_map::node_item(@{node: ast::item_impl(_, some(ity), _, _), _}) {\n+              ast_ty_to_ty(tcx, m_check, ity)\n+          }\n+        };\n+        let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n+        alt ty::struct(tcx, iface_ty) {\n+          ty::ty_iface(_, tps) {\n+            vec::iter2(tps, iface_tys,\n+                       {|a, b| demand::simple(fcx, sp, a, b);});\n+          }\n+        }\n+    }\n+\n+    fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+        let cx = fcx.ccx;\n+        alt ex.node {\n+          ast::expr_path(_) {\n+            let substs = ty::node_id_to_ty_param_substs_opt_and_ty(\n+                cx.tcx, ex.id);\n+            alt substs.substs {\n+              some(ts) {\n+                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n+                let item_ty = ty::lookup_item_type(cx.tcx, did);\n+                if has_iface_bounds(*item_ty.bounds) {\n+                    let impls = cx.impl_map.get(ex.id);\n+                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                        fcx, impls, ex.span, item_ty.bounds, ts));\n+                }\n+              }\n+              _ {}\n+            }\n+          }\n+          // Must resolve bounds on methods with bounded params\n+          ast::expr_field(_, _, _) {\n+            alt cx.method_map.find(ex.id) {\n+              some(method_static(did)) {\n+                let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+                if has_iface_bounds(*bounds) {\n+                    let ts = ty::node_id_to_type_params(cx.tcx, ex.id);\n+                    let iscs = cx.impl_map.get(ex.id);\n+                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                        fcx, iscs, ex.span, bounds, ts));\n+                }\n+              }\n+              _ {}\n+            }\n+          }\n+          ast::expr_fn(ast::proto_block., _, _, _) {}\n+          ast::expr_fn(_, _, _, _) { ret; }\n+          _ {}\n+        }\n+        visit::visit_expr(ex, fcx, v);\n+    }\n+\n+    // Detect points where an interface-bounded type parameter is instantiated,\n+    // resolve the impls for the parameters.\n+    fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n+        visit::visit_block(bl, fcx, visit::mk_vt(@{\n+            visit_expr: resolve_expr,\n+            visit_item: fn(_i: @ast::item, &&_e: @fn_ctxt,\n+                           _v: visit::vt<@fn_ctxt>) {}\n+            with *visit::default_visitor()\n+        }));\n+    }\n }\n \n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n@@ -3043,17 +3098,17 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n     let ccx = @{mutable self_infos: [],\n                 impl_map: impl_map,\n                 method_map: std::map::new_int_hash(),\n+                dict_map: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit =\n         visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _),\n                                    visit_native_item:\n                                        bind check_native_item(ccx, _)\n                                    with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n-    let dict_map = resolve_dicts(tcx, impl_map, ccx.method_map, crate);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n-    (ccx.method_map, dict_map)\n+    (ccx.method_map, ccx.dict_map)\n }\n //\n // Local Variables:"}, {"sha": "d4c01edbb15a4c3b22ff5b94014bb604d990d75d", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -19,10 +19,6 @@ fn mode_str(m: ty::mode) -> str {\n     }\n }\n \n-fn mode_str_1(m: ty::mode) -> str {\n-    alt m { ast::by_ref. { \"ref\" } _ { mode_str(m) } }\n-}\n-\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {"}, {"sha": "0c1db7119af8e1e607bf800930cfde4cdd5728e0", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e1a35f8836f78894a4499ac7bebcc76472f172/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a7e1a35f8836f78894a4499ac7bebcc76472f172", "patch": "@@ -742,6 +742,17 @@ fn iter<T>(v: [const T], f: block(T)) {\n     iteri(v) { |_i, v| f(v) }\n }\n \n+/*\n+Function: iter2\n+\n+Iterates over two vectors in parallel\n+\n+*/\n+fn iter2<U, T>(v: [U], v2: [T], f: block(U, T)) {\n+    let i = 0;\n+    for elt in v { f(elt, v2[i]); i += 1; }\n+}\n+\n /*\n Function: iteri\n "}]}