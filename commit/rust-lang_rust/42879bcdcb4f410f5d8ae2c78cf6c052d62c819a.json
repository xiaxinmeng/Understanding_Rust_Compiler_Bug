{"sha": "42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyODc5YmNkY2I0ZjQxMGY1ZDhhZTJjNzhjZjZjMDUyZDYyYzgxOWE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-30T17:53:43Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-29T10:19:12Z"}, "message": "Add a `USELESS_LET_IF_SEQ` lint", "tree": {"sha": "4803503c567ad21181c16dc56596fe404b557ce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4803503c567ad21181c16dc56596fe404b557ce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXSsIiAAoJEF5CfHlMukXoO+gP/3ExaRJiL66ZP/olTRhGSy7r\nb5YvHahs0Ur1umLBoxC73zg+iKVk3tDpeOwlJYuW1jYmdPokVdTdUeNM1+ZafGZp\n4RtXZuCN7rQbck+U6YgjGuqPHTBb+66fp4Ci5d6tNnW7rJ2ixEDTa3n1MQmAzqPp\nQzNTwrdWwoT3mgQQptv8hKKespbpXGZUsn1mFfgahlgpmH4zCbn4La3vzavDudo0\n87Z+gzk8v0/jJMMAOdDkJ3ePWWGuL4iCGoqesfV0irNqnBDE6jlfRqLMKsy9MWfN\nio1ZFc/7Fgxsxhy908RMQWmx75LEJJl1OLuxQbhI+my1mSeUU6wjIbvCoplGbfhR\nMPKpQkuAuqO5w8/kpxAPIW1jEX3q10UZJ8T4hChNmrf46JiPZwUAANxmDvxLrxt1\nAa8liYauc5/dFLUlb5vgxSdaM0OfuGkDsp5Kbs3MQpvF08GpuBxwTQwT6RAn45DG\nm9UzCGlsjqVqI7F/qQcpu/LagKFNBY95PM9ZAWXJI9RwpbIRJNVG2LtFHF8LJO4O\ncx6vWpAdVBg+LmXOpAdFRPc9aQVskPcXnelOMPC+sdbM9W+ICJL7zAuFrUEOZXxL\nvtWw/bF6t0gvGsOONgsrxyKJ/TovF2g/p2joaLE4mhKYMnduD/E8FnJ0J4bOAW04\n2YKUW6hMu0b7gNsxgu3t\n=Bv0z\n-----END PGP SIGNATURE-----", "payload": "tree 4803503c567ad21181c16dc56596fe404b557ce1\nparent ed7ac0d9b5ff57bda043b088ba81c73e84bc5c83\nauthor mcarton <cartonmartin+git@gmail.com> 1459360423 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1464517152 +0200\n\nAdd a `USELESS_LET_IF_SEQ` lint\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "html_url": "https://github.com/rust-lang/rust/commit/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed7ac0d9b5ff57bda043b088ba81c73e84bc5c83", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7ac0d9b5ff57bda043b088ba81c73e84bc5c83", "html_url": "https://github.com/rust-lang/rust/commit/ed7ac0d9b5ff57bda043b088ba81c73e84bc5c83"}], "stats": {"total": 265, "additions": 264, "deletions": 1}, "files": [{"sha": "b59249b257cfe4227cd538d1dc73ac1a1e1ca196", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.71 \u2014 TBD\n+* New lint: [`useless_let_if_seq`]\n+\n ## 0.0.70 \u2014 2016-05-28\n * Rustup to *rustc 1.10.0-nightly (7bddce693 2016-05-27)*\n * [`invalid_regex`] and [`trivial_regex`] can now warn on `RegexSet::new`,\n@@ -240,6 +243,7 @@ All notable changes to this project will be documented in this file.\n [`use_debug`]: https://github.com/Manishearth/rust-clippy/wiki#use_debug\n [`used_underscore_binding`]: https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding\n [`useless_format`]: https://github.com/Manishearth/rust-clippy/wiki#useless_format\n+[`useless_let_if_seq`]: https://github.com/Manishearth/rust-clippy/wiki#useless_let_if_seq\n [`useless_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#useless_transmute\n [`useless_vec`]: https://github.com/Manishearth/rust-clippy/wiki#useless_vec\n [`while_let_loop`]: https://github.com/Manishearth/rust-clippy/wiki#while_let_loop"}, {"sha": "3b5b6768c237eeff205fd3c75fcb71c53ca52229", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 151 lints included in this crate:\n+There are 152 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -164,6 +164,7 @@ name\n [use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n [used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | allow   | using a binding which is prefixed with an underscore\n [useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                                     | warn    | useless use of `format!`\n+[useless_let_if_seq](https://github.com/Manishearth/rust-clippy/wiki#useless_let_if_seq)                             | warn    | Checks for unidiomatic `let mut` declaration followed by initialization in `if`\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                               | warn    | transmutes that have the same to and from types\n [useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                           | warn    | useless `vec!`\n [while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop"}, {"sha": "29551a413e2aa12235b4b27946cb2c61e9714fec", "filename": "clippy_lints/src/let_if_seq.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "patch": "@@ -0,0 +1,176 @@\n+use rustc::lint::*;\n+use rustc::hir;\n+use syntax::codemap;\n+use utils::{snippet, span_lint_and_then};\n+\n+/// **What it does:** This lint checks for variable declarations immediately followed by a\n+/// conditional affectation.\n+///\n+/// **Why is this bad?** This is not idiomatic Rust.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// let foo;\n+///\n+/// if bar() {\n+///     foo = 42;\n+/// } else {\n+///     foo = 0;\n+/// }\n+///\n+/// let mut baz = None;\n+///\n+/// if bar() {\n+///     baz = Some(42);\n+/// }\n+/// ```\n+///\n+/// should be written\n+///\n+/// ```rust,ignore\n+/// let foo = if bar() {\n+///     42;\n+/// } else {\n+///     0;\n+/// };\n+///\n+/// let baz = if bar() {\n+///     Some(42);\n+/// } else {\n+///     None\n+/// };\n+/// ```\n+declare_lint! {\n+    pub USELESS_LET_IF_SEQ,\n+    Warn,\n+    \"Checks for unidiomatic `let mut` declaration followed by initialization in `if`\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct LetIfSeq;\n+\n+impl LintPass for LetIfSeq {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(USELESS_LET_IF_SEQ)\n+    }\n+}\n+\n+impl LateLintPass for LetIfSeq {\n+    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+        let mut it = block.stmts.iter().peekable();\n+        while let Some(ref stmt) = it.next() {\n+            if_let_chain! {[\n+                let Some(expr) = it.peek(),\n+                let hir::StmtDecl(ref decl, _) = stmt.node,\n+                let hir::DeclLocal(ref decl) = decl.node,\n+                let hir::PatKind::Ident(mode, ref name, None) = decl.pat.node,\n+                let Some(def) = cx.tcx.def_map.borrow().get(&decl.pat.id),\n+                let hir::StmtExpr(ref if_, _) = expr.node,\n+                let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n+                let Some(value) = check_assign(cx, def.def_id(), then),\n+            ], {\n+                let span = codemap::mk_sp(stmt.span.lo, if_.span.hi);\n+\n+                let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n+                    if let hir::ExprBlock(ref else_) = else_.node {\n+                        if let Some(default) = check_assign(cx, def.def_id(), else_) {\n+                            (else_.stmts.len() > 1, default)\n+                        } else if let Some(ref default) = decl.init {\n+                            (true, &**default)\n+                        } else {\n+                            continue;\n+                        }\n+                    } else {\n+                        continue;\n+                    }\n+                } else if let Some(ref default) = decl.init {\n+                    (false, &**default)\n+                } else {\n+                    continue;\n+                };\n+\n+                let mutability = match mode {\n+                    hir::BindByRef(hir::MutMutable) | hir::BindByValue(hir::MutMutable) => \"<mut> \",\n+                    _ => \"\",\n+                };\n+\n+                // FIXME: this should not suggest `mut` if we can detect that the variable is not\n+                // use mutably after the `if`\n+\n+                let sug = format!(\n+                    \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n+                    mut=mutability,\n+                    name=name.node,\n+                    cond=snippet(cx, cond.span, \"_\"),\n+                    then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },\n+                    else=if default_multi_stmts { \" ..;\" } else { \"\" },\n+                    value=snippet(cx, value.span, \"<value>\"),\n+                    default=snippet(cx, default.span, \"<default>\"),\n+                );\n+                span_lint_and_then(cx,\n+                                   USELESS_LET_IF_SEQ,\n+                                   span,\n+                                   \"`if _ { .. } else { .. }` is an expression\",\n+                                   |db| {\n+                                       db.span_suggestion(span,\n+                                                          \"it is more idiomatic to write\",\n+                                                          sug);\n+                                       if !mutability.is_empty() {\n+                                           db.note(\"you might not need `mut` at all\");\n+                                       }\n+                                   });\n+            }}\n+        }\n+    }\n+}\n+\n+struct UsedVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    id: hir::def_id::DefId,\n+    used: bool,\n+}\n+\n+impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+        if_let_chain! {[\n+            let hir::ExprPath(None, _) = expr.node,\n+            let Some(def) = self.cx.tcx.def_map.borrow().get(&expr.id),\n+            self.id == def.def_id(),\n+        ], {\n+            self.used = true;\n+            return;\n+        }}\n+        hir::intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::Block) -> Option<&'e hir::Expr> {\n+    if_let_chain! {[\n+        let Some(expr) = block.stmts.iter().last(),\n+        let hir::StmtSemi(ref expr, _) = expr.node,\n+        let hir::ExprAssign(ref var, ref value) = expr.node,\n+        let hir::ExprPath(None, _) = var.node,\n+        let Some(def) = cx.tcx.def_map.borrow().get(&var.id),\n+        decl == def.def_id(),\n+    ], {\n+        let mut v = UsedVisitor {\n+            cx: cx,\n+            id: decl,\n+            used: false,\n+        };\n+\n+        for s in block.stmts.iter().take(block.stmts.len()-1) {\n+            hir::intravisit::walk_stmt(&mut v, s);\n+        }\n+\n+        return if v.used {\n+            None\n+        } else {\n+            Some(value)\n+        };\n+    }}\n+\n+    None\n+}"}, {"sha": "4a5c3a87c8c83ad28698dc42546ebce23b0d7932", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "patch": "@@ -80,6 +80,7 @@ pub mod identity_op;\n pub mod if_not_else;\n pub mod items_after_statements;\n pub mod len_zero;\n+pub mod let_if_seq;\n pub mod lifetimes;\n pub mod loops;\n pub mod map_clone;\n@@ -246,6 +247,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n     reg.register_late_lint_pass(box assign_ops::AssignOps);\n+    reg.register_late_lint_pass(box let_if_seq::LetIfSeq);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -318,6 +320,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         identity_op::IDENTITY_OP,\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n+        let_if_seq::USELESS_LET_IF_SEQ,\n         lifetimes::NEEDLESS_LIFETIMES,\n         lifetimes::UNUSED_LIFETIMES,\n         loops::EMPTY_LOOP,"}, {"sha": "011848e95ddfe99c771321d29fedb9a6096191ca", "filename": "tests/compile-fail/let_if_seq.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/tests%2Fcompile-fail%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42879bcdcb4f410f5d8ae2c78cf6c052d62c819a/tests%2Fcompile-fail%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flet_if_seq.rs?ref=42879bcdcb4f410f5d8ae2c78cf6c052d62c819a", "patch": "@@ -0,0 +1,79 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![allow(unused_variables, unused_assignments, similar_names, blacklisted_name)]\n+#![deny(useless_let_if_seq)]\n+\n+fn f() -> bool { true }\n+\n+fn early_return() -> u8 {\n+    // FIXME: we could extend the lint to include such cases:\n+    let foo;\n+\n+    if f() {\n+        return 42;\n+    } else {\n+        foo = 0;\n+    }\n+\n+    foo\n+}\n+\n+fn main() {\n+    early_return();\n+\n+    let mut foo = 0;\n+    //~^ ERROR `if _ { .. } else { .. }` is an expression\n+    //~| HELP more idiomatic\n+    //~| SUGGESTION let <mut> foo = if f() { 42 } else { 0 };\n+    if f() {\n+        foo = 42;\n+    }\n+\n+    let mut bar = 0;\n+    //~^ ERROR `if _ { .. } else { .. }` is an expression\n+    //~| HELP more idiomatic\n+    //~| SUGGESTION let <mut> bar = if f() { ..; 42 } else { ..; 0 };\n+    if f() {\n+        f();\n+        bar = 42;\n+    }\n+    else {\n+        f();\n+    }\n+\n+    let quz;\n+    //~^ ERROR `if _ { .. } else { .. }` is an expression\n+    //~| HELP more idiomatic\n+    //~| SUGGESTION let quz = if f() { 42 } else { 0 };\n+\n+    if f() {\n+        quz = 42;\n+    } else {\n+        quz = 0;\n+    }\n+\n+    // `toto` is used several times\n+    let mut toto;\n+\n+    if f() {\n+        toto = 42;\n+    } else {\n+        for i in &[1, 2] {\n+            toto = *i;\n+        }\n+\n+        toto = 2;\n+    }\n+\n+    // baz needs to be mut\n+    let mut baz = 0;\n+    //~^ ERROR `if _ { .. } else { .. }` is an expression\n+    //~| HELP more idiomatic\n+    //~| SUGGESTION let <mut> baz = if f() { 42 } else { 0 };\n+    if f() {\n+        baz = 42;\n+    }\n+\n+    baz = 1337;\n+}"}]}