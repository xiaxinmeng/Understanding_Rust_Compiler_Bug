{"sha": "66326bc66572ca753bbb1d81a67d43488f6695f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzI2YmM2NjU3MmNhNzUzYmJiMWQ4MWE2N2Q0MzQ4OGY2Njk1ZjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-12T17:31:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-19T00:22:17Z"}, "message": "refactorings of `lowering` that make it more amenable to using `&mut`\ninstead of `Cell` (but stop short of actualling switching to `&mut`)", "tree": {"sha": "81637e406955eded5451a9df205df8d7a2bb15c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81637e406955eded5451a9df205df8d7a2bb15c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66326bc66572ca753bbb1d81a67d43488f6695f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66326bc66572ca753bbb1d81a67d43488f6695f3", "html_url": "https://github.com/rust-lang/rust/commit/66326bc66572ca753bbb1d81a67d43488f6695f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66326bc66572ca753bbb1d81a67d43488f6695f3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ccd390dbd4288dccf7f5d3e8a2cc3a75e9ef5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ccd390dbd4288dccf7f5d3e8a2cc3a75e9ef5fb", "html_url": "https://github.com/rust-lang/rust/commit/6ccd390dbd4288dccf7f5d3e8a2cc3a75e9ef5fb"}], "stats": {"total": 585, "additions": 295, "deletions": 290}, "files": [{"sha": "250379d2d7efc3d2df58f6b4d421b8bece9c75a9", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 295, "deletions": 290, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/66326bc66572ca753bbb1d81a67d43488f6695f3/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66326bc66572ca753bbb1d81a67d43488f6695f3/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=66326bc66572ca753bbb1d81a67d43488f6695f3", "patch": "@@ -875,19 +875,16 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     })\n }\n \n-// RAII utility for setting and unsetting the cached id.\n-struct CachedIdSetter<'a> {\n-    reset: bool,\n-    lctx: &'a LoweringContext<'a>,\n-}\n-\n-impl<'a> CachedIdSetter<'a> {\n-    fn new(lctx: &'a LoweringContext, expr_id: NodeId) -> CachedIdSetter<'a> {\n-        // Only reset the id if it was previously 0, i.e., was not cached.\n-        // If it was cached, we are in a nested node, but our id count will\n-        // still count towards the parent's count.\n-        let reset_cached_id = lctx.cached_id.get() == 0;\n-\n+// Utility fn for setting and unsetting the cached id.\n+fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n+    where OP: FnOnce(&LoweringContext) -> R\n+{\n+    // Only reset the id if it was previously 0, i.e., was not cached.\n+    // If it was cached, we are in a nested node, but our id count will\n+    // still count towards the parent's count.\n+    let reset_cached_id = lctx.cached_id.get() == 0;\n+\n+    {\n         let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n \n         if id_cache.contains_key(&expr_id) {\n@@ -907,21 +904,16 @@ impl<'a> CachedIdSetter<'a> {\n             id_cache.insert(expr_id, next_id);\n             lctx.gensym_key.set(next_id);\n         }\n-\n-        CachedIdSetter {\n-            reset: reset_cached_id,\n-            lctx: lctx,\n-        }\n     }\n-}\n \n-impl<'a> Drop for CachedIdSetter<'a> {\n-    fn drop(&mut self) {\n-        if self.reset {\n-            self.lctx.cached_id.set(0);\n-            self.lctx.gensym_key.set(0);\n-        }\n+    let result = op(lctx);\n+\n+    if reset_cached_id {\n+        lctx.cached_id.set(0);\n+        lctx.gensym_key.set(0);\n     }\n+\n+    result\n }\n \n pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n@@ -959,147 +951,162 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                 //     InPlace::finalize(place)\n                 // })\n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    let placer_expr = lower_expr(lctx, placer);\n+                    let value_expr = lower_expr(lctx, value_expr);\n+\n+                    let placer_ident = lctx.str_to_ident(\"placer\");\n+                    let place_ident = lctx.str_to_ident(\"place\");\n+                    let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+\n+                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                    let make_call = |lctx: &LoweringContext, p, args| {\n+                        let path = core_path(lctx, e.span, p);\n+                        let path = expr_path(lctx, path);\n+                        expr_call(lctx, e.span, path, args)\n+                    };\n \n-                let placer_expr = lower_expr(lctx, placer);\n-                let value_expr = lower_expr(lctx, value_expr);\n+                    let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n+                        stmt_let(lctx, e.span, false, bind, expr)\n+                    };\n \n-                let placer_ident = lctx.str_to_ident(\"placer\");\n-                let agent_ident = lctx.str_to_ident(\"place\");\n-                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+                    let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n+                        stmt_let(lctx, e.span, true, bind, expr)\n+                    };\n \n-                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+                    // let placer = <placer_expr> ;\n+                    let s1 = {\n+                        let placer_expr = signal_block_expr(lctx,\n+                                                            vec![],\n+                                                            placer_expr,\n+                                                            e.span,\n+                                                            hir::PopUnstableBlock);\n+                        mk_stmt_let(lctx, placer_ident, placer_expr)\n+                    };\n \n-                let make_call = |lctx, p, args| {\n-                    let path = core_path(lctx, e.span, p);\n-                    let path = expr_path(lctx, path);\n-                    expr_call(lctx, e.span, path, args)\n-                };\n+                    // let mut place = Placer::make_place(placer);\n+                    let s2 = {\n+                        let placer = expr_ident(lctx, e.span, placer_ident);\n+                        let call = make_call(lctx, &make_place, vec![placer]);\n+                        mk_stmt_let_mut(lctx, place_ident, call)\n+                    };\n \n-                let mk_stmt_let = |lctx, bind, expr| stmt_let(lctx, e.span, false, bind, expr);\n-                let mk_stmt_let_mut = |lctx, bind, expr| stmt_let(lctx, e.span, true, bind, expr);\n-\n-                // let placer = <placer_expr> ;\n-                let s1 = mk_stmt_let(lctx,\n-                                     placer_ident,\n-                                     signal_block_expr(lctx,\n-                                                       vec![],\n-                                                       placer_expr,\n-                                                       e.span,\n-                                                       hir::PopUnstableBlock));\n-\n-                // let mut place = Placer::make_place(placer);\n-                let s2 = {\n-                    let call = make_call(lctx,\n-                                         &make_place,\n-                                         vec![expr_ident(lctx, e.span, placer_ident)]);\n-                    mk_stmt_let_mut(lctx, agent_ident, call)\n-                };\n+                    // let p_ptr = Place::pointer(&mut place);\n+                    let s3 = {\n+                        let agent = expr_ident(lctx, e.span, place_ident);\n+                        let args = vec![expr_mut_addr_of(lctx, e.span, agent)];\n+                        let call = make_call(lctx, &place_pointer, args);\n+                        mk_stmt_let(lctx, p_ptr_ident, call)\n+                    };\n \n-                // let p_ptr = Place::pointer(&mut place);\n-                let s3 = {\n-                    let args = vec![expr_mut_addr_of(lctx,\n-                                                     e.span,\n-                                                     expr_ident(lctx, e.span, agent_ident))];\n-                    let call = make_call(lctx, &place_pointer, args);\n-                    mk_stmt_let(lctx, p_ptr_ident, call)\n-                };\n+                    // pop_unsafe!(EXPR));\n+                    let pop_unsafe_expr = {\n+                        let value_expr = signal_block_expr(lctx,\n+                                                           vec![],\n+                                                           value_expr,\n+                                                           e.span,\n+                                                           hir::PopUnstableBlock);\n+                        signal_block_expr(lctx,\n+                                          vec![],\n+                                          value_expr,\n+                                          e.span,\n+                                          hir::PopUnsafeBlock(hir::CompilerGenerated))\n+                    };\n \n-                // pop_unsafe!(EXPR));\n-                let pop_unsafe_expr =\n-                    signal_block_expr(lctx,\n-                                      vec![],\n-                                      signal_block_expr(lctx,\n-                                                        vec![],\n-                                                        value_expr,\n-                                                        e.span,\n-                                                        hir::PopUnstableBlock),\n-                                      e.span,\n-                                      hir::PopUnsafeBlock(hir::CompilerGenerated));\n+                    // push_unsafe!({\n+                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                    //     InPlace::finalize(place)\n+                    // })\n+                    let expr = {\n+                        let ptr = expr_ident(lctx, e.span, p_ptr_ident);\n+                        let call_move_val_init =\n+                            hir::StmtSemi(\n+                                make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n+                                lctx.next_id());\n+                        let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                        let place = expr_ident(lctx, e.span, place_ident);\n+                        let call = make_call(lctx, &inplace_finalize, vec![place]);\n+                        signal_block_expr(lctx,\n+                                          vec![P(call_move_val_init)],\n+                                          call,\n+                                          e.span,\n+                                          hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                    };\n \n-                // push_unsafe!({\n-                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                //     InPlace::finalize(place)\n-                // })\n-                let expr = {\n-                    let call_move_val_init =\n-                        hir::StmtSemi(make_call(lctx,\n-                                                &move_val_init,\n-                                                vec![expr_ident(lctx, e.span, p_ptr_ident),\n-                                                     pop_unsafe_expr]),\n-                                      lctx.next_id());\n-                    let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                    let call = make_call(lctx,\n-                                         &inplace_finalize,\n-                                         vec![expr_ident(lctx, e.span, agent_ident)]);\n                     signal_block_expr(lctx,\n-                                      vec![P(call_move_val_init)],\n-                                      call,\n+                                      vec![s1, s2, s3],\n+                                      expr,\n                                       e.span,\n-                                      hir::PushUnsafeBlock(hir::CompilerGenerated))\n-                };\n-\n-                return signal_block_expr(lctx,\n-                                         vec![s1, s2, s3],\n-                                         expr,\n-                                         e.span,\n-                                         hir::PushUnstableBlock);\n+                                      hir::PushUnstableBlock)\n+                });\n             }\n \n             ExprVec(ref exprs) => {\n                 hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprRepeat(ref expr, ref count) => {\n-                hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n+                let expr = lower_expr(lctx, expr);\n+                let count = lower_expr(lctx, count);\n+                hir::ExprRepeat(expr, count)\n             }\n             ExprTup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprCall(ref f, ref args) => {\n-                hir::ExprCall(lower_expr(lctx, f),\n-                              args.iter().map(|x| lower_expr(lctx, x)).collect())\n+                let f = lower_expr(lctx, f);\n+                hir::ExprCall(f, args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n             ExprMethodCall(i, ref tps, ref args) => {\n-                hir::ExprMethodCall(respan(i.span, i.node.name),\n-                                    tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n-                                    args.iter().map(|x| lower_expr(lctx, x)).collect())\n+                let tps = tps.iter().map(|x| lower_ty(lctx, x)).collect();\n+                let args = args.iter().map(|x| lower_expr(lctx, x)).collect();\n+                hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n             }\n             ExprBinary(binop, ref lhs, ref rhs) => {\n-                hir::ExprBinary(lower_binop(lctx, binop),\n-                                lower_expr(lctx, lhs),\n-                                lower_expr(lctx, rhs))\n+                let binop = lower_binop(lctx, binop);\n+                let lhs = lower_expr(lctx, lhs);\n+                let rhs = lower_expr(lctx, rhs);\n+                hir::ExprBinary(binop, lhs, rhs)\n             }\n             ExprUnary(op, ref ohs) => {\n-                hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n+                let op = lower_unop(lctx, op);\n+                let ohs = lower_expr(lctx, ohs);\n+                hir::ExprUnary(op, ohs)\n             }\n             ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n             ExprCast(ref expr, ref ty) => {\n-                hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n+                let expr = lower_expr(lctx, expr);\n+                hir::ExprCast(expr, lower_ty(lctx, ty))\n             }\n             ExprAddrOf(m, ref ohs) => {\n-                hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n+                let m = lower_mutability(lctx, m);\n+                let ohs = lower_expr(lctx, ohs);\n+                hir::ExprAddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n             ExprIf(ref cond, ref blk, ref else_opt) => {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprIfLet(..) => {\n-                            let _old_cached = CachedIdSetter::new(lctx, e.id);\n-                            // wrap the if-let expr in a block\n-                            let span = els.span;\n-                            let blk = P(hir::Block {\n-                                stmts: vec![],\n-                                expr: Some(lower_expr(lctx, els)),\n-                                id: lctx.next_id(),\n-                                rules: hir::DefaultBlock,\n-                                span: span,\n-                            });\n-                            expr_block(lctx, blk)\n+                            cache_ids(lctx, e.id, |lctx| {\n+                                // wrap the if-let expr in a block\n+                                let span = els.span;\n+                                let els = lower_expr(lctx, els);\n+                                let id = lctx.next_id();\n+                                let blk = P(hir::Block {\n+                                    stmts: vec![],\n+                                    expr: Some(els),\n+                                    id: id,\n+                                    rules: hir::DefaultBlock,\n+                                    span: span,\n+                                });\n+                                expr_block(lctx, blk)\n+                            })\n                         }\n                         _ => lower_expr(lctx, els),\n                     }\n@@ -1204,76 +1211,79 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // `<pat> => <body>`\n-                let pat_arm = {\n-                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                    arm(vec![lower_pat(lctx, pat)], body_expr)\n-                };\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body = lower_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body);\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n \n-                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n-                let else_if_arms = {\n-                    let mut arms = vec![];\n-                    loop {\n-                        let else_opt_continue = else_opt.and_then(|els| {\n-                            els.and_then(|els| {\n-                                match els.node {\n-                                    // else if\n-                                    hir::ExprIf(cond, then, else_opt) => {\n-                                        let pat_under = pat_wild(lctx, e.span);\n-                                        arms.push(hir::Arm {\n-                                            attrs: vec![],\n-                                            pats: vec![pat_under],\n-                                            guard: Some(cond),\n-                                            body: expr_block(lctx, then),\n-                                        });\n-                                        else_opt.map(|else_opt| (else_opt, true))\n+                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                    let else_if_arms = {\n+                        let mut arms = vec![];\n+                        loop {\n+                            let else_opt_continue = else_opt.and_then(|els| {\n+                                els.and_then(|els| {\n+                                    match els.node {\n+                                        // else if\n+                                        hir::ExprIf(cond, then, else_opt) => {\n+                                            let pat_under = pat_wild(lctx, e.span);\n+                                            arms.push(hir::Arm {\n+                                                attrs: vec![],\n+                                                pats: vec![pat_under],\n+                                                guard: Some(cond),\n+                                                body: expr_block(lctx, then),\n+                                            });\n+                                            else_opt.map(|else_opt| (else_opt, true))\n+                                        }\n+                                        _ => Some((P(els), false)),\n                                     }\n-                                    _ => Some((P(els), false)),\n+                                })\n+                            });\n+                            match else_opt_continue {\n+                                Some((e, true)) => {\n+                                    else_opt = Some(e);\n+                                }\n+                                Some((e, false)) => {\n+                                    else_opt = Some(e);\n+                                    break;\n+                                }\n+                                None => {\n+                                    else_opt = None;\n+                                    break;\n                                 }\n-                            })\n-                        });\n-                        match else_opt_continue {\n-                            Some((e, true)) => {\n-                                else_opt = Some(e);\n-                            }\n-                            Some((e, false)) => {\n-                                else_opt = Some(e);\n-                                break;\n-                            }\n-                            None => {\n-                                else_opt = None;\n-                                break;\n                             }\n                         }\n-                    }\n-                    arms\n-                };\n+                        arms\n+                    };\n \n-                let contains_else_clause = else_opt.is_some();\n+                    let contains_else_clause = else_opt.is_some();\n \n-                // `_ => [<else_opt> | ()]`\n-                let else_arm = {\n-                    let pat_under = pat_wild(lctx, e.span);\n-                    let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n-                    arm(vec![pat_under], else_expr)\n-                };\n+                    // `_ => [<else_opt> | ()]`\n+                    let else_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let else_expr =\n+                            else_opt.unwrap_or_else(\n+                                || expr_tuple(lctx, e.span, vec![]));\n+                        arm(vec![pat_under], else_expr)\n+                    };\n \n-                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-                arms.push(pat_arm);\n-                arms.extend(else_if_arms);\n-                arms.push(else_arm);\n+                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                    arms.push(pat_arm);\n+                    arms.extend(else_if_arms);\n+                    arms.push(else_arm);\n \n-                let match_expr = expr(lctx,\n-                                      e.span,\n-                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n-                                                     arms,\n-                                                     hir::MatchSource::IfLetDesugar {\n-                                                         contains_else_clause: contains_else_clause,\n-                                                     }));\n-                return match_expr;\n+                    let sub_expr = lower_expr(lctx, sub_expr);\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(sub_expr,\n+                                        arms,\n+                                        hir::MatchSource::IfLetDesugar {\n+                                            contains_else_clause: contains_else_clause,\n+                                        }))\n+                });\n             }\n \n             // Desugar ExprWhileLet\n@@ -1288,32 +1298,34 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // `<pat> => <body>`\n-                let pat_arm = {\n-                    let body_expr = expr_block(lctx, lower_block(lctx, body));\n-                    arm(vec![lower_pat(lctx, pat)], body_expr)\n-                };\n-\n-                // `_ => break`\n-                let break_arm = {\n-                    let pat_under = pat_wild(lctx, e.span);\n-                    let break_expr = expr_break(lctx, e.span);\n-                    arm(vec![pat_under], break_expr)\n-                };\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body = lower_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body);\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n \n-                // `match <sub_expr> { ... }`\n-                let arms = vec![pat_arm, break_arm];\n-                let match_expr = expr(lctx,\n-                                      e.span,\n-                                      hir::ExprMatch(lower_expr(lctx, sub_expr),\n-                                                     arms,\n-                                                     hir::MatchSource::WhileLetDesugar));\n+                    // `_ => break`\n+                    let break_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span);\n+                        arm(vec![pat_under], break_expr)\n+                    };\n \n-                // `[opt_ident]: loop { ... }`\n-                let loop_block = block_expr(lctx, match_expr);\n-                return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+                    // `match <sub_expr> { ... }`\n+                    let arms = vec![pat_arm, break_arm];\n+                    let sub_expr = lower_expr(lctx, sub_expr);\n+                    let match_expr = expr(lctx,\n+                                          e.span,\n+                                          hir::ExprMatch(sub_expr,\n+                                                         arms,\n+                                                         hir::MatchSource::WhileLetDesugar));\n+\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident))\n+                });\n             }\n \n             // Desugar ExprForLoop\n@@ -1335,97 +1347,90 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     result\n                 //   }\n \n-                let _old_cached = CachedIdSetter::new(lctx, e.id);\n-\n-                // expand <head>\n-                let head = lower_expr(lctx, head);\n-\n-                let iter = lctx.str_to_ident(\"iter\");\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // expand <head>\n+                    let head = lower_expr(lctx, head);\n \n-                // `::std::option::Option::Some(<pat>) => <body>`\n-                let pat_arm = {\n-                    let body_block = lower_block(lctx, body);\n-                    let body_span = body_block.span;\n-                    let body_expr = P(hir::Expr {\n-                        id: lctx.next_id(),\n-                        node: hir::ExprBlock(body_block),\n-                        span: body_span,\n-                    });\n-                    let pat = lower_pat(lctx, pat);\n-                    let some_pat = pat_some(lctx, e.span, pat);\n+                    let iter = lctx.str_to_ident(\"iter\");\n \n-                    arm(vec![some_pat], body_expr)\n-                };\n+                    // `::std::option::Option::Some(<pat>) => <body>`\n+                    let pat_arm = {\n+                        let body_block = lower_block(lctx, body);\n+                        let body_span = body_block.span;\n+                        let body_expr = P(hir::Expr {\n+                            id: lctx.next_id(),\n+                            node: hir::ExprBlock(body_block),\n+                            span: body_span,\n+                        });\n+                        let pat = lower_pat(lctx, pat);\n+                        let some_pat = pat_some(lctx, e.span, pat);\n \n-                // `::std::option::Option::None => break`\n-                let break_arm = {\n-                    let break_expr = expr_break(lctx, e.span);\n+                        arm(vec![some_pat], body_expr)\n+                    };\n \n-                    arm(vec![pat_none(lctx, e.span)], break_expr)\n-                };\n+                    // `::std::option::Option::None => break`\n+                    let break_arm = {\n+                        let break_expr = expr_break(lctx, e.span);\n \n-                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                let match_expr = {\n-                    let next_path = {\n-                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                    };\n \n-                        path_global(e.span, strs)\n+                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                    let match_expr = {\n+                        let next_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+\n+                            path_global(e.span, strs)\n+                        };\n+                        let iter = expr_ident(lctx, e.span, iter);\n+                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter);\n+                        let next_path = expr_path(lctx, next_path);\n+                        let next_expr = expr_call(lctx, e.span, next_path, vec![ref_mut_iter]);\n+                        let arms = vec![pat_arm, break_arm];\n+\n+                        expr(lctx,\n+                             e.span,\n+                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n                     };\n-                    let ref_mut_iter = expr_mut_addr_of(lctx,\n-                                                        e.span,\n-                                                        expr_ident(lctx, e.span, iter));\n-                    let next_expr = expr_call(lctx,\n-                                              e.span,\n-                                              expr_path(lctx, next_path),\n-                                              vec![ref_mut_iter]);\n-                    let arms = vec![pat_arm, break_arm];\n \n-                    expr(lctx,\n-                         e.span,\n-                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n-                };\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+\n+                    // `mut iter => { ... }`\n+                    let iter_arm = {\n+                        let iter_pat = pat_ident_binding_mode(lctx,\n+                                                              e.span,\n+                                                              iter,\n+                                                              hir::BindByValue(hir::MutMutable));\n+                        arm(vec![iter_pat], loop_expr)\n+                    };\n \n-                // `[opt_ident]: loop { ... }`\n-                let loop_block = block_expr(lctx, match_expr);\n-                let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n-\n-                // `mut iter => { ... }`\n-                let iter_arm = {\n-                    let iter_pat = pat_ident_binding_mode(lctx,\n-                                                          e.span,\n-                                                          iter,\n-                                                          hir::BindByValue(hir::MutMutable));\n-                    arm(vec![iter_pat], loop_expr)\n-                };\n+                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                    let into_iter_expr = {\n+                        let into_iter_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                let into_iter_expr = {\n-                    let into_iter_path = {\n-                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                            path_global(e.span, strs)\n+                        };\n \n-                        path_global(e.span, strs)\n+                        let into_iter = expr_path(lctx, into_iter_path);\n+                        expr_call(lctx, e.span, into_iter, vec![head])\n                     };\n \n-                    expr_call(lctx, e.span, expr_path(lctx, into_iter_path), vec![head])\n-                };\n-\n-                let match_expr = expr_match(lctx,\n-                                            e.span,\n-                                            into_iter_expr,\n-                                            vec![iter_arm],\n-                                            hir::MatchSource::ForLoopDesugar);\n-\n-                // `{ let result = ...; result }`\n-                let result_ident = lctx.str_to_ident(\"result\");\n-                return expr_block(lctx,\n-                                  block_all(lctx,\n-                                            e.span,\n-                                            vec![stmt_let(lctx,\n-                                                          e.span,\n-                                                          false,\n-                                                          result_ident,\n-                                                          match_expr)],\n-                                            Some(expr_ident(lctx, e.span, result_ident))));\n+                    let match_expr = expr_match(lctx,\n+                                                e.span,\n+                                                into_iter_expr,\n+                                                vec![iter_arm],\n+                                                hir::MatchSource::ForLoopDesugar);\n+\n+                    // `{ let result = ...; result }`\n+                    let result_ident = lctx.str_to_ident(\"result\");\n+                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr);\n+                    let result = expr_ident(lctx, e.span, result_ident);\n+                    let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n+                    expr_block(lctx, block)\n+                });\n             }\n \n             ExprMac(_) => panic!(\"Shouldn't exist here\"),"}]}