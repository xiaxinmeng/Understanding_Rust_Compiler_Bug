{"sha": "8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "node_id": "C_kwDOAAsO6NoAKDhmYTFlZDhmMTIzZjI3MTRhNzc5NmMwM2Q3ZDYzNGIwNDZiZGFlZDI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-05T10:34:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-05T10:34:31Z"}, "message": "Rollup merge of #97712 - RalfJung:untyped, r=scottmcm\n\nptr::copy and ptr::swap are doing untyped copies\n\nThe consensus in https://github.com/rust-lang/rust/issues/63159 seemed to be that these operations should be \"untyped\", i.e., they should treat the data as raw bytes, should work when these bytes violate the validity invariant of `T`, and should exactly preserve the initialization state of the bytes that are being copied. This is already somewhat implied by the description of \"copying/swapping size*N bytes\" (rather than \"N instances of `T`\").\n\nThe implementations mostly already work that way (well, for LLVM's intrinsics the documentation is not precise enough to say what exactly happens to poison, but if this ever gets clarified to something that would *not* perfectly preserve poison, then I strongly assume there will be some way to make a copy that *does* perfectly preserve poison). However, I had to adjust `swap_nonoverlapping`; after ``@scottmcm's`` [recent changes](https://github.com/rust-lang/rust/pull/94212), that one (sometimes) made a typed copy. (Note that `mem::swap`, which works on mutable references, is unchanged. It is documented as \"swapping the values at two mutable locations\", which to me strongly indicates that it is indeed typed. It is also safe and can rely on `&mut T` pointing to a valid `T` as part of its safety invariant.)\n\nOn top of adding a test (that will be run by Miri), this PR then also adjusts the documentation to indeed stably promise the untyped semantics. I assume this means the PR has to go through t-libs (and maybe t-lang?) FCP.\n\nFixes https://github.com/rust-lang/rust/issues/63159", "tree": {"sha": "9db087f1dc800fec89ad0fa1482fb3e5e94475e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9db087f1dc800fec89ad0fa1482fb3e5e94475e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixBO4CRBK7hj4Ov3rIwAAe/4IAHw+ZD9o/Q9lJ5Nz2KqhyMKb\n1HFhBm9auMZ6+9ofd+5lvJVZIVrrgBxuST+z3BC3V28uEnINN6WLfczAlr1R5+js\nZUymkMaiAAd71IbgXfikDwMXnHwCFPFdF34pwhMSUp3Fp5vkZwj57ycP2yTZVryN\nE2fXJRfgzNaR7Gs8po/oOwmNBGjPhMmByd3UQg29ZdB89A2nWOijenkLuEOeHT0B\n34uCV33y5RD7/fq+f9T3TO1t7mLIEsJZCPFL4Lx3HL3M8WfVCf+aCxeVzAnrHzLP\nHYTnsUMMHe5RFF7m3vmRsStShNlHdqrTzLQlhisTMw+dCXRqQWIFTOx+jw3/yn4=\n=oYEb\n-----END PGP SIGNATURE-----\n", "payload": "tree 9db087f1dc800fec89ad0fa1482fb3e5e94475e1\nparent 4045ce641a9eede71cc12031a2cd71692b273890\nparent cb7cd97641b7a2d1646520b7bf785934f9c6aaeb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657017271 +0530\ncommitter GitHub <noreply@github.com> 1657017271 +0530\n\nRollup merge of #97712 - RalfJung:untyped, r=scottmcm\n\nptr::copy and ptr::swap are doing untyped copies\n\nThe consensus in https://github.com/rust-lang/rust/issues/63159 seemed to be that these operations should be \"untyped\", i.e., they should treat the data as raw bytes, should work when these bytes violate the validity invariant of `T`, and should exactly preserve the initialization state of the bytes that are being copied. This is already somewhat implied by the description of \"copying/swapping size*N bytes\" (rather than \"N instances of `T`\").\n\nThe implementations mostly already work that way (well, for LLVM's intrinsics the documentation is not precise enough to say what exactly happens to poison, but if this ever gets clarified to something that would *not* perfectly preserve poison, then I strongly assume there will be some way to make a copy that *does* perfectly preserve poison). However, I had to adjust `swap_nonoverlapping`; after ``@scottmcm's`` [recent changes](https://github.com/rust-lang/rust/pull/94212), that one (sometimes) made a typed copy. (Note that `mem::swap`, which works on mutable references, is unchanged. It is documented as \"swapping the values at two mutable locations\", which to me strongly indicates that it is indeed typed. It is also safe and can rely on `&mut T` pointing to a valid `T` as part of its safety invariant.)\n\nOn top of adding a test (that will be run by Miri), this PR then also adjusts the documentation to indeed stably promise the untyped semantics. I assume this means the PR has to go through t-libs (and maybe t-lang?) FCP.\n\nFixes https://github.com/rust-lang/rust/issues/63159\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "html_url": "https://github.com/rust-lang/rust/commit/8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4045ce641a9eede71cc12031a2cd71692b273890", "url": "https://api.github.com/repos/rust-lang/rust/commits/4045ce641a9eede71cc12031a2cd71692b273890", "html_url": "https://github.com/rust-lang/rust/commit/4045ce641a9eede71cc12031a2cd71692b273890"}, {"sha": "cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb", "html_url": "https://github.com/rust-lang/rust/commit/cb7cd97641b7a2d1646520b7bf785934f9c6aaeb"}], "stats": {"total": 65, "additions": 51, "deletions": 14}, "files": [{"sha": "2895c923adc1346ab88baacdb60552e50adce212", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "patch": "@@ -2356,6 +2356,9 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n /// with the argument order swapped.\n ///\n+/// The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n ///\n /// # Safety\n@@ -2461,6 +2464,9 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n /// order swapped. Copying takes place as if the bytes were copied from `src`\n /// to a temporary array and then copied from the array to `dst`.\n ///\n+/// The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n ///\n /// # Safety"}, {"sha": "4f257f9de3080295aff57eb316a8ed24abfc0552", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "patch": "@@ -730,7 +730,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// But for the following two exceptions, this function is semantically\n+/// But for the following exceptions, this function is semantically\n /// equivalent to [`mem::swap`]:\n ///\n /// * It operates on raw pointers instead of references. When references are\n@@ -740,6 +740,9 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///   overlapping region of memory from `x` will be used. This is demonstrated\n ///   in the second example below.\n ///\n+/// * The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate\n+///   the requirements of `T`. The initialization state is preserved exactly.\n+///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -816,6 +819,9 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n /// beginning at `x` and `y`. The two regions must *not* overlap.\n ///\n+/// The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n+/// requirements of `T`. The initialization state is preserved exactly.\n+///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -861,15 +867,15 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n             if mem::align_of::<T>() >= mem::align_of::<$ChunkTy>()\n                 && mem::size_of::<T>() % mem::size_of::<$ChunkTy>() == 0\n             {\n-                let x: *mut MaybeUninit<$ChunkTy> = x.cast();\n-                let y: *mut MaybeUninit<$ChunkTy> = y.cast();\n+                let x: *mut $ChunkTy = x.cast();\n+                let y: *mut $ChunkTy = y.cast();\n                 let count = count * (mem::size_of::<T>() / mem::size_of::<$ChunkTy>());\n                 // SAFETY: these are the same bytes that the caller promised were\n                 // ok, just typed as `MaybeUninit<ChunkTy>`s instead of as `T`s.\n                 // The `if` condition above ensures that we're not violating\n                 // alignment requirements, and that the division is exact so\n                 // that we don't lose any bytes off the end.\n-                return unsafe { swap_nonoverlapping_simple(x, y, count) };\n+                return unsafe { swap_nonoverlapping_simple_untyped(x, y, count) };\n             }\n         };\n     }\n@@ -902,7 +908,7 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     }\n \n     // SAFETY: Same preconditions as this function\n-    unsafe { swap_nonoverlapping_simple(x, y, count) }\n+    unsafe { swap_nonoverlapping_simple_untyped(x, y, count) }\n }\n \n /// Same behaviour and safety conditions as [`swap_nonoverlapping`]\n@@ -911,17 +917,17 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n /// `swap_nonoverlapping` tries to use) so no need to manually SIMD it.\n #[inline]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-const unsafe fn swap_nonoverlapping_simple<T>(x: *mut T, y: *mut T, count: usize) {\n+const unsafe fn swap_nonoverlapping_simple_untyped<T>(x: *mut T, y: *mut T, count: usize) {\n+    let x = x.cast::<MaybeUninit<T>>();\n+    let y = y.cast::<MaybeUninit<T>>();\n     let mut i = 0;\n     while i < count {\n-        let x: &mut T =\n-            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n-            unsafe { &mut *x.add(i) };\n-        let y: &mut T =\n-            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n-            // and it's distinct from `x` since the ranges are non-overlapping\n-            unsafe { &mut *y.add(i) };\n-        mem::swap_simple(x, y);\n+        // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+        let x = unsafe { &mut *x.add(i) };\n+        // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+        // and it's distinct from `x` since the ranges are non-overlapping\n+        let y = unsafe { &mut *y.add(i) };\n+        mem::swap_simple::<MaybeUninit<T>>(x, y);\n \n         i += 1;\n     }"}, {"sha": "bab2b1792f68093940d61c5d06644b9a746f4596", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa1ed8f123f2714a7796c03d7d634b046bdaed2/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "patch": "@@ -781,6 +781,31 @@ fn nonnull_tagged_pointer_with_provenance() {\n     }\n }\n \n+#[test]\n+fn swap_copy_untyped() {\n+    // We call `{swap,copy}{,_nonoverlapping}` at `bool` type on data that is not a valid bool.\n+    // These should all do untyped copies, so this should work fine.\n+    let mut x = 5u8;\n+    let mut y = 6u8;\n+\n+    let ptr1 = &mut x as *mut u8 as *mut bool;\n+    let ptr2 = &mut y as *mut u8 as *mut bool;\n+\n+    unsafe {\n+        ptr::swap(ptr1, ptr2);\n+        ptr::swap_nonoverlapping(ptr1, ptr2, 1);\n+    }\n+    assert_eq!(x, 5);\n+    assert_eq!(y, 6);\n+\n+    unsafe {\n+        ptr::copy(ptr1, ptr2, 1);\n+        ptr::copy_nonoverlapping(ptr1, ptr2, 1);\n+    }\n+    assert_eq!(x, 5);\n+    assert_eq!(y, 5);\n+}\n+\n #[test]\n fn test_const_copy() {\n     const {"}]}