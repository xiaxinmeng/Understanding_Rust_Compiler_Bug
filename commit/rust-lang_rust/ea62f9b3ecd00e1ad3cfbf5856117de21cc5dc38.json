{"sha": "ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNjJmOWIzZWNkMDBlMWFkM2NmYmY1ODU2MTE3ZGUyMWNjNWRjMzg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-11T02:33:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-11T02:33:11Z"}, "message": "Rollup merge of #61665 - aschampion:slice-eq-ptr, r=sfackler\n\ncore: check for pointer equality when comparing Eq slices\n\nBecause `Eq` types must be reflexively equal, an equal-length slice to the same memory location must be equal.\n\nThis is related to #33892 (and #32699) answering this comment from that PR:\n\n> Great! One more easy question: why does this optimization not apply in the non-BytewiseEquality implementation directly above?\n\nBecause slices of non-reflexively equal types (like `f64`) are not equal even if it's the same slice. But if the types are `Eq`, we can use this same-address optimization, which this PR implements. Obviously this changes behavior if types violate the reflexivity condition of `Eq`, because their impls of `PartialEq` will no longer be called per-item, but \ud83e\udd37\u200d\u2642 .\n\nIt's not clear how often this optimization comes up in the real world outside of the same-`&str` case covered by #33892, so **I'm requesting a perf run** (on MacOS today, so can't run `rustc_perf` myself). I'm going ahead and making the PR on the basis of being surprised things didn't already work this way.\n\nThis is my first time hacking rust itself, so as a perf sanity check I ran `./x.py bench --stage 0 src/lib{std,alloc}`, but the differences were noisy.\n\nTo make the existing specialization for `BytewiseEquality` explicit, it's now a supertrait of `Eq + Copy`. `Eq` should be sufficient, but `Copy` was included for clarity.", "tree": {"sha": "f3c471da6d44b5aba0a5fecf1631dcc62b797c26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c471da6d44b5aba0a5fecf1631dcc62b797c26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdJp/nCRBK7hj4Ov3rIwAAdHIIAAc+iuSqFj+Ogj2ripNxNBLi\n8/oQ3XSn2w/mUWlMTfMATNP9N2YxyWkhHOmV4bcs4PrQyDR3V9bk6pX/PJRDsZpT\nMik6qASJtWzOmZDgHfP19NcWB50u593Dqy8GGF1pnlAbxmmppUhGTU74xjh3lvwL\nmAdcGkjmBYLrwDKPuhfwSrTn8L1DE1dz4qNQJ3CzGNtnks/N+fhZNsReRiK8JnXL\nE8DtC3zZmJhMQfU/MxJansDPU9PjwSu34XhfkLQDDQwOuCBeb6m5xxYhjMzhRu+5\nwPgzQfGtlvrSwXReir2+Z2ivh82+gGauZTs9Qpu/ckGQrPR2ZSU8nSP3m4zzXuE=\n=CRyZ\n-----END PGP SIGNATURE-----\n", "payload": "tree f3c471da6d44b5aba0a5fecf1631dcc62b797c26\nparent 35cacbce1661366250a877da4fa5b6b4cb03542e\nparent d482589f292abda9a5c2895adf63189168f92a70\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562812391 +0200\ncommitter GitHub <noreply@github.com> 1562812391 +0200\n\nRollup merge of #61665 - aschampion:slice-eq-ptr, r=sfackler\n\ncore: check for pointer equality when comparing Eq slices\n\nBecause `Eq` types must be reflexively equal, an equal-length slice to the same memory location must be equal.\n\nThis is related to #33892 (and #32699) answering this comment from that PR:\n\n> Great! One more easy question: why does this optimization not apply in the non-BytewiseEquality implementation directly above?\n\nBecause slices of non-reflexively equal types (like `f64`) are not equal even if it's the same slice. But if the types are `Eq`, we can use this same-address optimization, which this PR implements. Obviously this changes behavior if types violate the reflexivity condition of `Eq`, because their impls of `PartialEq` will no longer be called per-item, but \ud83e\udd37\u200d\u2642 .\n\nIt's not clear how often this optimization comes up in the real world outside of the same-`&str` case covered by #33892, so **I'm requesting a perf run** (on MacOS today, so can't run `rustc_perf` myself). I'm going ahead and making the PR on the basis of being surprised things didn't already work this way.\n\nThis is my first time hacking rust itself, so as a perf sanity check I ran `./x.py bench --stage 0 src/lib{std,alloc}`, but the differences were noisy.\n\nTo make the existing specialization for `BytewiseEquality` explicit, it's now a supertrait of `Eq + Copy`. `Eq` should be sufficient, but `Copy` was included for clarity.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38", "html_url": "https://github.com/rust-lang/rust/commit/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35cacbce1661366250a877da4fa5b6b4cb03542e", "url": "https://api.github.com/repos/rust-lang/rust/commits/35cacbce1661366250a877da4fa5b6b4cb03542e", "html_url": "https://github.com/rust-lang/rust/commit/35cacbce1661366250a877da4fa5b6b4cb03542e"}, {"sha": "d482589f292abda9a5c2895adf63189168f92a70", "url": "https://api.github.com/repos/rust-lang/rust/commits/d482589f292abda9a5c2895adf63189168f92a70", "html_url": "https://github.com/rust-lang/rust/commit/d482589f292abda9a5c2895adf63189168f92a70"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "363ae088275586239e95a53f337b0e9c2ab1905b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=ea62f9b3ecd00e1ad3cfbf5856117de21cc5dc38", "patch": "@@ -5342,13 +5342,24 @@ impl<A, B> SlicePartialEq<B> for [A]\n             return false;\n         }\n \n-        for i in 0..self.len() {\n-            if !self[i].eq(&other[i]) {\n-                return false;\n-            }\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n+    }\n+}\n+\n+// Use an equal-pointer optimization when types are `Eq`\n+impl<A> SlicePartialEq<A> for [A]\n+    where A: PartialEq<A> + Eq\n+{\n+    default fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        if self.as_ptr() == other.as_ptr() {\n+            return true;\n         }\n \n-        true\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n     }\n }\n \n@@ -5457,7 +5468,7 @@ impl SliceOrd<u8> for [u8] {\n #[doc(hidden)]\n /// Trait implemented for types that can be compared for equality using\n /// their bytewise representation\n-trait BytewiseEquality { }\n+trait BytewiseEquality: Eq + Copy { }\n \n macro_rules! impl_marker_for {\n     ($traitname:ident, $($ty:ty)*) => {"}]}