{"sha": "006c6b6be4499fd999ef3f52996b944263baa220", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNmM2YjZiZTQ0OTlmZDk5OWVmM2Y1Mjk5NmI5NDQyNjNiYWEyMjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T17:42:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T18:01:19Z"}, "message": "trans: Rely on new AutoBorrowObj adjustment to match up object receivers\n\nNote: some portions of this commit written by @Sodel-the-Vociferous\n(Daniel Ralston)", "tree": {"sha": "7577af1a8bd4d7f6be3c92c1e3a97f3356a59a75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7577af1a8bd4d7f6be3c92c1e3a97f3356a59a75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/006c6b6be4499fd999ef3f52996b944263baa220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/006c6b6be4499fd999ef3f52996b944263baa220", "html_url": "https://github.com/rust-lang/rust/commit/006c6b6be4499fd999ef3f52996b944263baa220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/006c6b6be4499fd999ef3f52996b944263baa220/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f319812d602fb1d6558b583b80a9326f1cc14b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f319812d602fb1d6558b583b80a9326f1cc14b3", "html_url": "https://github.com/rust-lang/rust/commit/6f319812d602fb1d6558b583b80a9326f1cc14b3"}], "stats": {"total": 253, "additions": 141, "deletions": 112}, "files": [{"sha": "4caaf384873511c1dc8865f2bdcd895e7338781e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=006c6b6be4499fd999ef3f52996b944263baa220", "patch": "@@ -60,7 +60,6 @@ pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n     temp_cleanup: Option<ValueRef>,\n-    self_ty: ty::t,\n     self_mode: ty::SelfMode,\n }\n "}, {"sha": "aa56ff3d26e80aafe449556e3869ace080ac8348", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=006c6b6be4499fd999ef3f52996b944263baa220", "patch": "@@ -13,7 +13,7 @@ use back::{upcall};\n use driver::session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n-use lib::llvm::{mk_target_data};\n+use lib::llvm::{mk_target_data, False};\n use metadata::common::LinkMeta;\n use middle::astencode;\n use middle::resolve;\n@@ -22,6 +22,7 @@ use middle::trans::base;\n use middle::trans::builder::Builder;\n use middle::trans::debuginfo;\n use middle::trans::type_use;\n+use middle::trans::common::{C_i32, C_null};\n use middle::ty;\n \n use middle::trans::type_::Type;\n@@ -30,6 +31,8 @@ use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n+use std::vec;\n+use std::libc::c_uint;\n use syntax::ast;\n \n use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};"}, {"sha": "cb4a7f364dac6c39c11a21cb704161abaea696ea", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=006c6b6be4499fd999ef3f52996b944263baa220", "patch": "@@ -137,9 +137,8 @@ use middle::trans::meth;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n-use middle::ty::{AutoDerefRef, AutoAddEnv};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n-                 AutoUnsafe};\n+use middle::ty::{AutoBorrowObj, AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n@@ -223,6 +222,10 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n                                                     datum.ty, Some(adjustment));\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n+                Some(AutoBorrowObj(*)) => {\n+                    unpack_datum!(bcx, auto_borrow_obj(\n+                        bcx, adj.autoderefs, expr, datum))\n+                }\n             };\n         }\n     }\n@@ -298,6 +301,98 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n+\n+    fn auto_borrow_obj(mut bcx: @mut Block,\n+                       autoderefs: uint,\n+                       expr: @ast::expr,\n+                       source_datum: Datum) -> DatumBlock {\n+        let tcx = bcx.tcx();\n+        let target_obj_ty = expr_ty_adjusted(bcx, expr);\n+        debug!(\"auto_borrow_obj(target=%s)\",\n+               target_obj_ty.repr(tcx));\n+        let scratch = scratch_datum(bcx, target_obj_ty,\n+                                    \"__auto_borrow_obj\", false);\n+\n+        // Convert a @Object, ~Object, or &Object pair into an &Object pair.\n+\n+        // Get a pointer to the source object, which is represented as\n+        // a (vtable, data) pair.\n+        let source_llval = source_datum.to_ref_llval(bcx);\n+\n+        // Set the vtable field of the new pair\n+        let vtable_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_vtable]);\n+        let vtable = Load(bcx, vtable_ptr);\n+        Store(bcx, vtable, GEPi(bcx, scratch.val, [0u, abi::trt_field_vtable]));\n+\n+        // Load the data for the source, which is either an @T,\n+        // ~T, or &T, depending on source_obj_ty.\n+        let source_data_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_box]);\n+        let source_data = Load(bcx, source_data_ptr); // always a ptr\n+        let (source_store, source_mutbl) = match ty::get(source_datum.ty).sty {\n+            ty::ty_trait(_, _, s, m, _) => (s, m),\n+            _ => {\n+                bcx.sess().span_bug(\n+                    expr.span,\n+                    fmt!(\"auto_borrow_trait_obj expected a trait, found %s\",\n+                         source_datum.ty.repr(bcx.tcx())));\n+            }\n+        };\n+        let target_data = match source_store {\n+            ty::BoxTraitStore(*) => {\n+                // For deref of @T or @mut T, create a dummy datum and\n+                // use the datum's deref method. This is more work\n+                // than just calling GEPi ourselves, but it ensures\n+                // that any write guards will be appropriate\n+                // processed.  Note that we don't know the type T, so\n+                // just substitute `i8`-- it doesn't really matter for\n+                // our purposes right now.\n+                let source_ty =\n+                    ty::mk_box(tcx,\n+                               ty::mt {\n+                                   ty: ty::mk_i8(),\n+                                   mutbl: source_mutbl});\n+                let source_datum =\n+                    Datum {val: source_data,\n+                           ty: source_ty,\n+                           mode: ByValue};\n+                let derefd_datum =\n+                    unpack_datum!(bcx,\n+                                  source_datum.deref(bcx,\n+                                                     expr,\n+                                                     autoderefs));\n+                derefd_datum.to_rptr(bcx).to_value_llval(bcx)\n+            }\n+            ty::UniqTraitStore(*) => {\n+                // For a ~T box, there may or may not be a header,\n+                // depending on whether the type T references managed\n+                // boxes. However, since we do not *know* the type T\n+                // for objects, this presents a hurdle. Our solution is\n+                // to load the \"borrow offset\" from the type descriptor;\n+                // this value will either be 0 or sizeof(BoxHeader), depending\n+                // on the type T.\n+                let llopaque =\n+                    PointerCast(bcx, source_data, Type::opaque().ptr_to());\n+                let lltydesc_ptr_ptr =\n+                    PointerCast(bcx, vtable,\n+                                bcx.ccx().tydesc_type.ptr_to().ptr_to());\n+                let lltydesc_ptr =\n+                    Load(bcx, lltydesc_ptr_ptr);\n+                let borrow_offset_ptr =\n+                    GEPi(bcx, lltydesc_ptr,\n+                         [0, abi::tydesc_field_borrow_offset]);\n+                let borrow_offset =\n+                    Load(bcx, borrow_offset_ptr);\n+                InBoundsGEP(bcx, llopaque, [borrow_offset])\n+            }\n+            ty::RegionTraitStore(*) => {\n+                source_data\n+            }\n+        };\n+        Store(bcx, target_data,\n+              GEPi(bcx, scratch.val, [0u, abi::trt_field_box]));\n+\n+        DatumBlock { bcx: bcx, datum: scratch }\n+    }\n }\n \n pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {"}, {"sha": "f5b2ff755966e6cf3f29ff2f7b2cb2fe26202d19", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 39, "deletions": 107, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006c6b6be4499fd999ef3f52996b944263baa220/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=006c6b6be4499fd999ef3f52996b944263baa220", "patch": "@@ -164,7 +164,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n                     llfn: callee_fn.llfn,\n                     llself: val,\n                     temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n-                    self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n                 })\n             }\n@@ -187,13 +186,11 @@ pub fn trans_method_callee(bcx: @mut Block,\n             }\n         }\n \n-        typeck::method_trait(_, off, store) => {\n+        typeck::method_trait(_, off) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n                                off,\n-                               this,\n-                               store,\n-                               mentry.explicit_self)\n+                               this)\n         }\n     }\n }\n@@ -341,7 +338,6 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n                   llfn: llfn_val,\n                   llself: llself_val,\n                   temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n-                  self_ty: node_id_type(bcx, base.id),\n                   self_mode: mentry.self_mode,\n               })\n           }\n@@ -406,142 +402,78 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n pub fn trans_trait_callee(bcx: @mut Block,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n-                          self_expr: @ast::expr,\n-                          store: ty::TraitStore,\n-                          explicit_self: ast::explicit_self_)\n+                          self_expr: @ast::expr)\n                           -> Callee {\n-    //!\n-    //\n-    // Create a method callee where the method is coming from a trait\n-    // instance (e.g., @Trait type).  In this case, we must pull the\n-    // fn pointer out of the vtable that is packaged up with the\n-    // @/~/&Trait instance.  @/~/&Traits are represented as a pair, so we\n-    // first evaluate the self expression (expected a by-ref result) and then\n-    // extract the self data and vtable out of the pair.\n+    /*!\n+     * Create a method callee where the method is coming from a trait\n+     * object (e.g., @Trait type).  In this case, we must pull the fn\n+     * pointer out of the vtable that is packaged up with the object.\n+     * Objects are represented as a pair, so we first evaluate the self\n+     * expression and then extract the self data and vtable out of the\n+     * pair.\n+     */\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n-    let self_datum = unpack_datum!(bcx,\n-        expr::trans_to_datum(bcx, self_expr));\n-    let llpair = self_datum.to_ref_llval(bcx);\n-\n-    let llpair = match explicit_self {\n-        ast::sty_region(*) => Load(bcx, llpair),\n-        ast::sty_static | ast::sty_value |\n-        ast::sty_box(_) | ast::sty_uniq => llpair\n-    };\n+\n+    let self_ty = expr_ty_adjusted(bcx, self_expr);\n+    let self_scratch = scratch_datum(bcx, self_ty, \"__trait_callee\", false);\n+    bcx = expr::trans_into(bcx, self_expr, expr::SaveIn(self_scratch.val));\n+\n+    // Arrange a temporary cleanup for the object in case something\n+    // should go wrong before the method is actually *invoked*.\n+    self_scratch.add_clean(bcx);\n \n     let callee_ty = node_id_type(bcx, callee_id);\n     trans_trait_callee_from_llval(bcx,\n                                   callee_ty,\n                                   n_method,\n-                                  llpair,\n-                                  store,\n-                                  explicit_self)\n+                                  self_scratch.val,\n+                                  Some(self_scratch.val))\n }\n \n pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n-                                     store: ty::TraitStore,\n-                                     explicit_self: ast::explicit_self_)\n+                                     temp_cleanup: Option<ValueRef>)\n                                   -> Callee {\n-    //!\n-    //\n-    // Same as `trans_trait_callee()` above, except that it is given\n-    // a by-ref pointer to the @Trait pair.\n+    /*!\n+     * Same as `trans_trait_callee()` above, except that it is given\n+     * a by-ref pointer to the object pair.\n+     */\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n \n-    // Load the vtable from the @Trait pair\n-    debug!(\"(translating trait callee) loading vtable from pair %s\",\n-           bcx.val_to_str(llpair));\n-    let llvtable = Load(bcx,\n-                      PointerCast(bcx,\n-                                  GEPi(bcx, llpair,\n-                                       [0u, abi::trt_field_vtable]),\n-                                  Type::vtable().ptr_to().ptr_to()));\n-\n-    // Load the box from the @Trait pair and GEP over the box header if\n-    // necessary:\n-    let mut llself;\n+    // Load the data pointer from the object.\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n-\n-    // Munge `llself` appropriately for the type of `self` in the method.\n-    match explicit_self {\n-        ast::sty_static => {\n-            bcx.tcx().sess.bug(\"shouldn't see static method here\");\n-        }\n-        ast::sty_value => {\n-            bcx.tcx().sess.bug(\"methods with by-value self should not be \\\n-                                called on objects\");\n-        }\n-        ast::sty_region(*) => {\n-            match store {\n-                ty::UniqTraitStore\n-                    if !ty::type_contents(bcx.tcx(), callee_ty).contains_managed() => {\n-                    llself = llbox;\n-                }\n-                ty::BoxTraitStore |\n-                ty::UniqTraitStore => {\n-                    llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-                }\n-                ty::RegionTraitStore(_) => {\n-                    llself = llbox;\n-                }\n-            }\n-        }\n-        ast::sty_box(_) => {\n-            // Bump the reference count on the box.\n-            debug!(\"(translating trait callee) callee type is `%s`\",\n-                   bcx.ty_to_str(callee_ty));\n-            glue::incr_refcnt_of_boxed(bcx, llbox);\n-\n-            // Pass a pointer to the box.\n-            match store {\n-                ty::BoxTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(\"@self receiver with non-@Trait\")\n-            }\n-        }\n-        ast::sty_uniq => {\n-            // Pass the unique pointer.\n-            match store {\n-                ty::UniqTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(\"~self receiver with non-~Trait\")\n-            }\n-\n-            zero_mem(bcx, llboxptr, ty::mk_opaque_box(bcx.tcx()));\n-        }\n-    }\n-\n-    llself = PointerCast(bcx, llself, Type::opaque_box(ccx).ptr_to());\n-    let scratch = scratch_datum(bcx, ty::mk_opaque_box(bcx.tcx()),\n-                                \"__trait_callee\", false);\n-    Store(bcx, llself, scratch.val);\n-    scratch.add_clean(bcx);\n+    let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n-\n-    // Plus one in order to skip past the type descriptor.\n+    let llvtable = Load(bcx,\n+                        PointerCast(bcx,\n+                                    GEPi(bcx, llpair,\n+                                         [0u, abi::trt_field_vtable]),\n+                                    Type::vtable().ptr_to().ptr_to()));\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n-\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n         bcx: bcx,\n         data: Method(MethodData {\n             llfn: mptr,\n-            llself: scratch.to_value_llval(bcx),\n-            temp_cleanup: Some(scratch.val),\n-            self_ty: scratch.ty,\n+            llself: llself,\n+            temp_cleanup: temp_cleanup,\n+\n+                // We know that the func declaration is &self, ~self,\n+                // or @self, and such functions are always by-copy\n+                // (right now, at least).\n             self_mode: ty::ByCopy,\n-            /* XXX: Some(llbox) */\n         })\n     };\n }"}]}