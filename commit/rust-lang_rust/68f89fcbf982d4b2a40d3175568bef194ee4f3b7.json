{"sha": "68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Zjg5ZmNiZjk4MmQ0YjJhNDBkMzE3NTU2OGJlZjE5NGVlNGYzYjc=", "commit": {"author": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "esm@eduardosm.net", "date": "2020-05-03T16:12:00Z"}, "committer": {"name": "Eduardo S\u00e1nchez Mu\u00f1oz", "email": "esm@eduardosm.net", "date": "2020-05-03T16:12:53Z"}, "message": "Make `std::char` functions and constants associated to `char`.", "tree": {"sha": "61d3dee2a81139f0cbf4a4c76b4dd068655a6c80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61d3dee2a81139f0cbf4a4c76b4dd068655a6c80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "html_url": "https://github.com/rust-lang/rust/commit/68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68f89fcbf982d4b2a40d3175568bef194ee4f3b7/comments", "author": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eduardosm", "id": 761151, "node_id": "MDQ6VXNlcjc2MTE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/761151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eduardosm", "html_url": "https://github.com/eduardosm", "followers_url": "https://api.github.com/users/eduardosm/followers", "following_url": "https://api.github.com/users/eduardosm/following{/other_user}", "gists_url": "https://api.github.com/users/eduardosm/gists{/gist_id}", "starred_url": "https://api.github.com/users/eduardosm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eduardosm/subscriptions", "organizations_url": "https://api.github.com/users/eduardosm/orgs", "repos_url": "https://api.github.com/users/eduardosm/repos", "events_url": "https://api.github.com/users/eduardosm/events{/privacy}", "received_events_url": "https://api.github.com/users/eduardosm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f35df2c6944b843b08369c4b2ff3bdb0beb2d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f35df2c6944b843b08369c4b2ff3bdb0beb2d2", "html_url": "https://github.com/rust-lang/rust/commit/e5f35df2c6944b843b08369c4b2ff3bdb0beb2d2"}], "stats": {"total": 244, "additions": 242, "deletions": 2}, "files": [{"sha": "e0e7021691808daaf568957113a09e6610d5eeb8", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/68f89fcbf982d4b2a40d3175568bef194ee4f3b7/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68f89fcbf982d4b2a40d3175568bef194ee4f3b7/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "patch": "@@ -9,6 +9,246 @@ use super::*;\n \n #[lang = \"char\"]\n impl char {\n+    /// The highest valid code point a `char` can have.\n+    ///\n+    /// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n+    /// Point], but only ones within a certain range. `MAX` is the highest valid\n+    /// code point that's a valid [Unicode Scalar Value].\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+    /// [Code Point]: http://www.unicode.org/glossary/#code_point\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const MAX: char = '\\u{10ffff}';\n+\n+    /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n+    /// decoding error.\n+    ///\n+    /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n+    /// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+\n+    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+    /// `char` and `str` methods are based on.\n+    ///\n+    /// New versions of Unicode are released regularly and subsequently all methods\n+    /// in the standard library depending on Unicode are updated. Therefore the\n+    /// behavior of some `char` and `str` methods and the value of this constant\n+    /// changes over time. This is *not* considered to be a breaking change.\n+    ///\n+    /// The version numbering scheme is explained in\n+    /// [Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard](https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const UNICODE_VERSION: (u8, u8, u8) = crate::unicode::UNICODE_VERSION;\n+\n+    /// Creates an iterator over the UTF-16 encoded code points in `iter`,\n+    /// returning unpaired surrogates as `Err`s.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char::decode_utf16;\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+    ///         .collect::<Vec<_>>(),\n+    ///     vec![\n+    ///         Ok('\ud834\udd1e'),\n+    ///         Ok('m'), Ok('u'), Ok('s'),\n+    ///         Err(0xDD1E),\n+    ///         Ok('i'), Ok('c'),\n+    ///         Err(0xD834)\n+    ///     ]\n+    /// );\n+    /// ```\n+    ///\n+    /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+    ///\n+    /// ```\n+    /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+    ///        .collect::<String>(),\n+    ///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+        super::decode::decode_utf16(iter)\n+    }\n+\n+    /// Converts a `u32` to a `char`.\n+    ///\n+    /// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n+    /// for a [`char`].\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`u32`]: ../../std/primitive.u32.html\n+    ///\n+    /// For an unsafe version of this function which ignores these checks, see\n+    /// [`from_u32_unchecked`].\n+    ///\n+    /// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x2764);\n+    ///\n+    /// assert_eq!(Some('\u2764'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a valid [`char`]:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x110000);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_u32(i: u32) -> Option<char> {\n+        super::convert::from_u32(i)\n+    }\n+\n+    /// Converts a `u32` to a `char`, ignoring validity.\n+    ///\n+    /// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+    /// [`char`], possibly creating an invalid one.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`u32`]: ../../std/primitive.u32.html\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe, as it may construct invalid `char` values.\n+    ///\n+    /// For a safe version of this function, see the [`from_u32`] function.\n+    ///\n+    /// [`from_u32`]: fn.from_u32.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+    ///\n+    /// assert_eq!('\u2764', c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+        super::convert::from_u32_unchecked(i)\n+    }\n+\n+    /// Converts a digit in the given radix to a `char`.\n+    ///\n+    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n+    /// indicates a binary number, a radix of ten, decimal, and a radix of\n+    /// sixteen, hexadecimal, to give some common values. Arbitrary\n+    /// radices are supported.\n+    ///\n+    /// `from_digit()` will return `None` if the input is not a digit in\n+    /// the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix larger than 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(4, 10);\n+    ///\n+    /// assert_eq!(Some('4'), c);\n+    ///\n+    /// // Decimal 11 is a single digit in base 16\n+    /// let c = char::from_digit(11, 16);\n+    ///\n+    /// assert_eq!(Some('b'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a digit:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(20, 10);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    ///\n+    /// Passing a large radix, causing a panic:\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    /// use std::char;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     // this panics\n+    ///     let c = char::from_digit(1, 37);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n+        super::convert::from_digit(num, radix)\n+    }\n+\n     /// Checks if a `char` is a digit in the given radix.\n     ///\n     /// A 'radix' here is sometimes also called a 'base'. A radix of two"}, {"sha": "bf65c31e135975826e856cbbe6a41f02783fd403", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68f89fcbf982d4b2a40d3175568bef194ee4f3b7/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68f89fcbf982d4b2a40d3175568bef194ee4f3b7/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=68f89fcbf982d4b2a40d3175568bef194ee4f3b7", "patch": "@@ -92,15 +92,15 @@ const MAX_THREE_B: u32 = 0x10000;\n /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n /// [Code Point]: http://www.unicode.org/glossary/#code_point\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: char = '\\u{10ffff}';\n+pub const MAX: char = char::MAX;\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n /// decoding error.\n ///\n /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n /// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+pub const REPLACEMENT_CHARACTER: char = char::REPLACEMENT_CHARACTER;\n \n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s."}]}