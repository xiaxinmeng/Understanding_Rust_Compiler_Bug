{"sha": "ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjQyNGRkMjJlYjVmYWY1ZGE4NmNlZjZkNzIzZDA3ZTU0OGE3YjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-25T22:21:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-25T23:36:38Z"}, "message": "Run test tasks in parallel according to RUST_THREADS. Issue #734", "tree": {"sha": "1415c61e183ceefd19765db419c16aab04e5df74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1415c61e183ceefd19765db419c16aab04e5df74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "html_url": "https://github.com/rust-lang/rust/commit/ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac2424dd22eb5faf5da86cef6d723d07e548a7b4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2de43c220c4ec39f1081b429ba060d765da0cef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2de43c220c4ec39f1081b429ba060d765da0cef5", "html_url": "https://github.com/rust-lang/rust/commit/2de43c220c4ec39f1081b429ba060d765da0cef5"}], "stats": {"total": 111, "additions": 79, "deletions": 32}, "files": [{"sha": "d46c84eda79f0ba8736554ed001d7b56e66ffc05", "filename": "src/lib/test.rs", "status": "modified", "additions": 78, "deletions": 31, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ac2424dd22eb5faf5da86cef6d723d07e548a7b4/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2424dd22eb5faf5da86cef6d723d07e548a7b4/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "patch": "@@ -4,6 +4,7 @@\n // while providing a base that other test frameworks may build off of.\n \n import sort = sort::ivector;\n+import getenv = generic_os::getenv;\n \n export test_name;\n export test_fn;\n@@ -104,32 +105,52 @@ fn run_tests_console(&test_opts opts, &test_desc[] tests) -> bool {\n     auto total = ivec::len(filtered_tests);\n     out.write_line(#fmt(\"running %u tests\", total));\n \n+    auto futures = ~[];\n+\n     auto passed = 0u;\n     auto failed = 0u;\n     auto ignored = 0u;\n \n     auto failures = ~[];\n \n-    for (test_desc test in filtered_tests) {\n-        out.write_str(#fmt(\"running %s ... \", test.name));\n-        alt (run_test(test)) {\n+    // It's tempting to just spawn all the tests at once but that doesn't\n+    // provide a great user experience because you might sit waiting for the\n+    // result of a particular test for an unusually long amount of time.\n+    auto concurrency = get_concurrency();\n+    log #fmt(\"using %u test tasks\", concurrency);\n+    auto run_idx = 0u;\n+    auto wait_idx = 0u;\n+\n+    while (wait_idx < total) {\n+        while (ivec::len(futures) < concurrency\n+               && run_idx < total) {\n+            futures += ~[run_test(filtered_tests.(run_idx))];\n+            run_idx += 1u;\n+        }\n+\n+        auto future = futures.(0);\n+        out.write_str(#fmt(\"running %s ... \", future.test.name));\n+        auto result = future.wait();\n+        alt (result) {\n             tr_ok {\n                 passed += 1u;\n-                write_ok(out);\n+                write_ok(out, concurrency);\n                 out.write_line(\"\");\n             }\n             tr_failed {\n                 failed += 1u;\n-                write_failed(out);\n+                write_failed(out, concurrency);\n                 out.write_line(\"\");\n-                failures += ~[test];\n+                failures += ~[future.test];\n             }\n             tr_ignored {\n                 ignored += 1u;\n-                write_ignored(out);\n+                write_ignored(out, concurrency);\n                 out.write_line(\"\");\n             }\n         }\n+        futures = ivec::slice(futures, 1u, ivec::len(futures));\n+        wait_idx += 1u;\n     }\n \n     assert passed + failed + ignored == total;\n@@ -144,38 +165,53 @@ fn run_tests_console(&test_opts opts, &test_desc[] tests) -> bool {\n \n     out.write_str(#fmt(\"\\nresult: \"));\n     if (success) {\n-        write_ok(out);\n+        write_ok(out, concurrency);\n     } else {\n-        write_failed(out);\n+        write_failed(out, concurrency);\n     }\n     out.write_str(#fmt(\". %u passed; %u failed; %u ignored\\n\\n\",\n                        passed, failed, ignored));\n \n     ret success;\n \n-    fn write_ok(&io::writer out) {\n-        write_pretty(out, \"ok\", term::color_green);\n+    fn write_ok(&io::writer out, uint concurrency) {\n+        write_pretty(out, \"ok\", term::color_green, concurrency);\n      }\n \n-    fn write_failed(&io::writer out) {\n-        write_pretty(out, \"FAILED\", term::color_red);\n+    fn write_failed(&io::writer out, uint concurrency) {\n+        write_pretty(out, \"FAILED\", term::color_red, concurrency);\n     }\n \n-    fn write_ignored(&io::writer out) {\n-        write_pretty(out, \"ignored\", term::color_yellow);\n+    fn write_ignored(&io::writer out, uint concurrency) {\n+        write_pretty(out, \"ignored\", term::color_yellow, concurrency);\n     }\n \n-    fn write_pretty(&io::writer out, &str word, u8 color) {\n-        if (term::color_supported()) {\n+    fn write_pretty(&io::writer out, &str word, u8 color,\n+                   uint concurrency) {\n+        // In the presence of concurrency, outputing control characters\n+        // can cause some crazy artifacting\n+        if (concurrency == 1u && term::color_supported()) {\n             term::fg(out.get_buf_writer(), color);\n         }\n         out.write_str(word);\n-        if (term::color_supported()) {\n+        if (concurrency == 1u && term::color_supported()) {\n             term::reset(out.get_buf_writer());\n         }\n     }\n }\n \n+fn get_concurrency() -> uint {\n+    alt getenv(\"RUST_THREADS\") {\n+      option::some(?t) {\n+        auto threads = uint::parse_buf(str::bytes(t), 10u);\n+        threads > 0u ? threads : 1u\n+      }\n+      option::none {\n+        1u\n+      }\n+    }\n+}\n+\n fn filter_tests(&test_opts opts, &test_desc[] tests) -> test_desc[] {\n     auto filtered = tests;\n \n@@ -226,15 +262,30 @@ fn filter_tests(&test_opts opts, &test_desc[] tests) -> test_desc[] {\n     ret filtered;\n }\n \n-fn run_test(&test_desc test) -> test_result {\n+type test_future = rec(test_desc test,\n+                       @fn() fnref,\n+                       fn() -> test_result wait);\n+\n+fn run_test(&test_desc test) -> test_future {\n+    // FIXME: Because of the unsafe way we're passing the test function\n+    // to the test task, we need to make sure we keep a reference to that\n+    // function around for longer than the lifetime of the task. To that end\n+    // we keep the function boxed in the test future.\n+    auto fnref = @test.fn;\n     if (!test.ignore) {\n-        if (run_test_fn_in_task(test.fn)) {\n-            ret tr_ok;\n-        } else {\n-            ret tr_failed;\n-        }\n+        auto test_task = run_test_fn_in_task(*fnref);\n+        ret rec(test = test,\n+                fnref = fnref,\n+                wait = bind fn(&task test_task) -> test_result {\n+                    alt (task::join(test_task)) {\n+                      task::tr_success { tr_ok }\n+                      task::tr_failure { tr_failed }\n+                    }\n+                } (test_task));\n     } else {\n-        ret tr_ignored;\n+        ret rec(test = test,\n+                fnref = fnref,\n+                wait = fn() -> test_result { tr_ignored });\n     }\n }\n \n@@ -245,7 +296,7 @@ native \"rust\" mod rustrt {\n // We need to run our tests in another task in order to trap test failures.\n // But, at least currently, functions can't be used as spawn arguments so\n // we've got to treat our test functions as unsafe pointers.\n-fn run_test_fn_in_task(&fn() f) -> bool {\n+fn run_test_fn_in_task(&fn() f) -> task {\n     fn run_task(*mutable fn() fptr) {\n         // If this task fails we don't want that failure to propagate to the\n         // test runner or else we couldn't keep running tests\n@@ -261,11 +312,7 @@ fn run_test_fn_in_task(&fn() f) -> bool {\n         (*fptr)()\n     }\n     auto fptr = ptr::addr_of(f);\n-    auto test_task = spawn run_task(fptr);\n-    ret alt (task::join(test_task)) {\n-        task::tr_success { true }\n-        task::tr_failure { false }\n-    }\n+    ret spawn run_task(fptr);\n }\n \n "}, {"sha": "e4317b10727e098b6862ed9aef738c037b69eb36", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac2424dd22eb5faf5da86cef6d723d07e548a7b4/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2424dd22eb5faf5da86cef6d723d07e548a7b4/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=ac2424dd22eb5faf5da86cef6d723d07e548a7b4", "patch": "@@ -26,7 +26,7 @@ fn ignored_tests_result_in_ignored() {\n     auto desc = rec(name = \"whatever\",\n                     fn = f,\n                     ignore = true);\n-    auto res = test::run_test(desc);\n+    auto res = test::run_test(desc).wait();\n     assert res == test::tr_ignored;\n }\n "}]}