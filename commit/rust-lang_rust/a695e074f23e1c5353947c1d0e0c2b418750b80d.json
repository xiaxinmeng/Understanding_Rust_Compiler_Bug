{"sha": "a695e074f23e1c5353947c1d0e0c2b418750b80d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OTVlMDc0ZjIzZTFjNTM1Mzk0N2MxZDBlMGMyYjQxODc1MGI4MGQ=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-07T21:23:10Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-07T23:58:15Z"}, "message": "rustc: Cosmetic change to type_of to make control flow more obvious.", "tree": {"sha": "97c18a25bcaab73198b3ab1a22479b121eaf6148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97c18a25bcaab73198b3ab1a22479b121eaf6148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a695e074f23e1c5353947c1d0e0c2b418750b80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a695e074f23e1c5353947c1d0e0c2b418750b80d", "html_url": "https://github.com/rust-lang/rust/commit/a695e074f23e1c5353947c1d0e0c2b418750b80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a695e074f23e1c5353947c1d0e0c2b418750b80d/comments", "author": null, "committer": null, "parents": [{"sha": "cdfc4b1c7a968635ae7a0fec40e26e93b5a77538", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfc4b1c7a968635ae7a0fec40e26e93b5a77538", "html_url": "https://github.com/rust-lang/rust/commit/cdfc4b1c7a968635ae7a0fec40e26e93b5a77538"}], "stats": {"total": 222, "additions": 110, "deletions": 112}, "files": [{"sha": "86c9cb0ff97b502678d39742f83ebacbef5aad1b", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a695e074f23e1c5353947c1d0e0c2b418750b80d/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a695e074f23e1c5353947c1d0e0c2b418750b80d/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a695e074f23e1c5353947c1d0e0c2b418750b80d", "patch": "@@ -78,125 +78,123 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     // type than `option<myrec>`.\n     let t_norm = ty::normalize_ty(cx.tcx, t);\n \n-    let mut llty;\n     if t != t_norm {\n-        llty = type_of(cx, t_norm);\n+        let llty = type_of(cx, t_norm);\n         cx.lltypes.insert(t, llty);\n-    } else {\n-        llty = match ty::get(t).struct {\n-          ty::ty_nil | ty::ty_bot => T_nil(),\n-          ty::ty_bool => T_bool(),\n-          ty::ty_int(t) => T_int_ty(cx, t),\n-          ty::ty_uint(t) => T_uint_ty(cx, t),\n-          ty::ty_float(t) => T_float_ty(cx, t),\n-          ty::ty_estr(ty::vstore_uniq) => {\n-            T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n-          }\n-          ty::ty_enum(did, _) => {\n-            // Only create the named struct, but don't fill it in. We\n-            // fill it in *after* placing it into the type cache. This\n-            // avoids creating more than one copy of the enum when one\n-            // of the enum's variants refers to the enum itself.\n-\n-            common::T_named_struct(llvm_type_name(cx, t))\n-          }\n-          ty::ty_estr(ty::vstore_box) => {\n-            T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n-          }\n-          ty::ty_evec(mt, ty::vstore_box) => {\n-            T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n-          }\n-          ty::ty_box(mt) => T_box_ptr(T_box(cx, type_of(cx, mt.ty))),\n-          ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n-          ty::ty_uniq(mt) => T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))),\n-          ty::ty_evec(mt, ty::vstore_uniq) => {\n-            T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n-          }\n-          ty::ty_unboxed_vec(mt) => {\n-            T_vec(cx, type_of(cx, mt.ty))\n-          }\n-          ty::ty_ptr(mt) => T_ptr(type_of(cx, mt.ty)),\n-          ty::ty_rptr(_, mt) => T_ptr(type_of(cx, mt.ty)),\n-\n-          ty::ty_evec(mt, ty::vstore_slice(_)) => {\n-            T_struct(~[T_ptr(type_of(cx, mt.ty)),\n-                      T_uint_ty(cx, ast::ty_u)])\n-          }\n-\n-          ty::ty_estr(ty::vstore_slice(_)) => {\n-            T_struct(~[T_ptr(T_i8()),\n-                      T_uint_ty(cx, ast::ty_u)])\n-          }\n-\n-          ty::ty_estr(ty::vstore_fixed(n)) => {\n-            T_array(T_i8(), n + 1u /* +1 for trailing null */)\n-          }\n-\n-          ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n-            T_array(type_of(cx, mt.ty), n)\n-          }\n+        return llty;\n+    }\n \n-          ty::ty_rec(fields) => {\n-            let mut tys: ~[TypeRef] = ~[];\n-            for vec::each(fields) |f| {\n-                let mt_ty = f.mt.ty;\n-                vec::push(tys, type_of(cx, mt_ty));\n-            }\n-            T_struct(tys)\n-          }\n-          ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n-          ty::ty_trait(_, _) => T_opaque_trait(cx),\n-          ty::ty_type => T_ptr(cx.tydesc_type),\n-          ty::ty_tup(elts) => {\n-            let mut tys = ~[];\n-            for vec::each(elts) |elt| {\n-                vec::push(tys, type_of(cx, elt));\n-            }\n-            T_struct(tys)\n-          }\n-          ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n-          ty::ty_class(*) => {\n-            // Only create the named struct, but don't fill it in. We fill it\n-            // in *after* placing it into the type cache. This prevents\n-            // infinite recursion with recursive class types.\n+    let llty = match ty::get(t).struct {\n+      ty::ty_nil | ty::ty_bot => T_nil(),\n+      ty::ty_bool => T_bool(),\n+      ty::ty_int(t) => T_int_ty(cx, t),\n+      ty::ty_uint(t) => T_uint_ty(cx, t),\n+      ty::ty_float(t) => T_float_ty(cx, t),\n+      ty::ty_estr(ty::vstore_uniq) => {\n+        T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n+      }\n+      ty::ty_enum(did, _) => {\n+        // Only create the named struct, but don't fill it in. We\n+        // fill it in *after* placing it into the type cache. This\n+        // avoids creating more than one copy of the enum when one\n+        // of the enum's variants refers to the enum itself.\n+\n+        common::T_named_struct(llvm_type_name(cx, t))\n+      }\n+      ty::ty_estr(ty::vstore_box) => {\n+        T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n+      }\n+      ty::ty_evec(mt, ty::vstore_box) => {\n+        T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n+      }\n+      ty::ty_box(mt) => T_box_ptr(T_box(cx, type_of(cx, mt.ty))),\n+      ty::ty_opaque_box => T_box_ptr(T_box(cx, T_i8())),\n+      ty::ty_uniq(mt) => T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))),\n+      ty::ty_evec(mt, ty::vstore_uniq) => {\n+        T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n+      }\n+      ty::ty_unboxed_vec(mt) => {\n+        T_vec(cx, type_of(cx, mt.ty))\n+      }\n+      ty::ty_ptr(mt) => T_ptr(type_of(cx, mt.ty)),\n+      ty::ty_rptr(_, mt) => T_ptr(type_of(cx, mt.ty)),\n+\n+      ty::ty_evec(mt, ty::vstore_slice(_)) => {\n+        T_struct(~[T_ptr(type_of(cx, mt.ty)),\n+                   T_uint_ty(cx, ast::ty_u)])\n+      }\n+\n+      ty::ty_estr(ty::vstore_slice(_)) => {\n+        T_struct(~[T_ptr(T_i8()),\n+                   T_uint_ty(cx, ast::ty_u)])\n+      }\n+\n+      ty::ty_estr(ty::vstore_fixed(n)) => {\n+        T_array(T_i8(), n + 1u /* +1 for trailing null */)\n+      }\n+\n+      ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n+        T_array(type_of(cx, mt.ty), n)\n+      }\n+\n+      ty::ty_rec(fields) => {\n+        let mut tys: ~[TypeRef] = ~[];\n+        for vec::each(fields) |f| {\n+            let mt_ty = f.mt.ty;\n+            vec::push(tys, type_of(cx, mt_ty));\n+        }\n+        T_struct(tys)\n+      }\n+      ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+      ty::ty_trait(_, _) => T_opaque_trait(cx),\n+      ty::ty_type => T_ptr(cx.tydesc_type),\n+      ty::ty_tup(elts) => {\n+        let mut tys = ~[];\n+        for vec::each(elts) |elt| {\n+            vec::push(tys, type_of(cx, elt));\n+        }\n+        T_struct(tys)\n+      }\n+      ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n+      ty::ty_class(*) => {\n+        // Only create the named struct, but don't fill it in. We fill it\n+        // in *after* placing it into the type cache. This prevents\n+        // infinite recursion with recursive class types.\n+\n+        common::T_named_struct(llvm_type_name(cx, t))\n+      }\n+      ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n+      ty::ty_var(_) => cx.tcx.sess.bug(~\"type_of with ty_var\"),\n+      ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n+      ty::ty_var_integral(_) => {\n+        cx.tcx.sess.bug(~\"type_of shouldn't see a ty_var_integral\");\n+      }\n+    };\n \n-            common::T_named_struct(llvm_type_name(cx, t))\n-          }\n-          ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n-          ty::ty_var(_) => cx.tcx.sess.bug(~\"type_of with ty_var\"),\n-          ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n-          ty::ty_var_integral(_) => {\n-            cx.tcx.sess.bug(~\"type_of shouldn't see a ty_var_integral\");\n-          }\n+    cx.lltypes.insert(t, llty);\n+\n+    // If this was an enum or class, fill in the type now.\n+    match ty::get(t).struct {\n+      ty::ty_enum(did, _) => {\n+        fill_type_of_enum(cx, did, t, llty);\n+      }\n+      ty::ty_class(did, ts) => {\n+        // Only instance vars are record fields at runtime.\n+        let fields = ty::lookup_class_fields(cx.tcx, did);\n+        let mut tys = do vec::map(fields) |f| {\n+            let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n+            type_of(cx, t)\n         };\n \n-        cx.lltypes.insert(t, llty);\n-\n-        // If this was an enum or class, fill in the type now.\n-        match ty::get(t).struct {\n-          ty::ty_enum(did, _) => {\n-              fill_type_of_enum(cx, did, t, llty);\n-          }\n-          ty::ty_class(did, ts) => {\n-            // Only instance vars are record fields at runtime.\n-            let fields = ty::lookup_class_fields(cx.tcx, did);\n-            let mut tys = do vec::map(fields) |f| {\n-                let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n-                type_of(cx, t)\n-            };\n-\n-            if ty::ty_dtor(cx.tcx, did) != none {\n-              // resource type\n-              tys = ~[T_i8(), T_struct(tys)];\n-            }\n-\n-            common::set_struct_body(llty, tys);\n-          }\n-          _ => {\n-            // Nothing more to do.\n-          }\n+        if ty::ty_dtor(cx.tcx, did) != none {\n+            // resource type\n+            tys = ~[T_i8(), T_struct(tys)];\n         }\n-    };\n+\n+        common::set_struct_body(llty, tys);\n+      }\n+      _ => ()\n+    }\n \n     return llty;\n }"}]}