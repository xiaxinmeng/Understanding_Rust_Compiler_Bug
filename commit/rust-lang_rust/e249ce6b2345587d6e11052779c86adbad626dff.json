{"sha": "e249ce6b2345587d6e11052779c86adbad626dff", "node_id": "C_kwDOAAsO6NoAKGUyNDljZTZiMjM0NTU4N2Q2ZTExMDUyNzc5Yzg2YWRiYWQ2MjZkZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T19:31:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T19:31:47Z"}, "message": "Auto merge of #90422 - GuillaumeGomez:rollup-s1mdag0, r=GuillaumeGomez\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #90156 (Remove underlines from non-top docblocks.)\n - #90183 (Show all Deref implementations recursively)\n - #90202 (Improve and test cross-crate hygiene)\n - #90375 (Use `is_global` in `candidate_should_be_dropped_in_favor_of`)\n - #90399 (Skipping verbose diagnostic suggestions when calling .as_ref() on type not implementing AsRef)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7c821c38d7cce4a75c40c221559eb59ea28e7cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c821c38d7cce4a75c40c221559eb59ea28e7cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e249ce6b2345587d6e11052779c86adbad626dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e249ce6b2345587d6e11052779c86adbad626dff", "html_url": "https://github.com/rust-lang/rust/commit/e249ce6b2345587d6e11052779c86adbad626dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e249ce6b2345587d6e11052779c86adbad626dff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2609fab8e46414333aa68412134df65c7fcd1a77", "url": "https://api.github.com/repos/rust-lang/rust/commits/2609fab8e46414333aa68412134df65c7fcd1a77", "html_url": "https://github.com/rust-lang/rust/commit/2609fab8e46414333aa68412134df65c7fcd1a77"}, {"sha": "197da45e183097f108c6f5f283a30070845f182d", "url": "https://api.github.com/repos/rust-lang/rust/commits/197da45e183097f108c6f5f283a30070845f182d", "html_url": "https://github.com/rust-lang/rust/commit/197da45e183097f108c6f5f283a30070845f182d"}], "stats": {"total": 1039, "additions": 968, "deletions": 71}, "files": [{"sha": "5e90aec003e9b1a20e381b1069059a87b1125bc6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1198,8 +1198,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         }\n \n-        if let EntryKind::Mod(data) = kind {\n-            for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n+        if let EntryKind::Mod(exports) = kind {\n+            for exp in exports.decode((self, sess)) {\n                 match exp.res {\n                     Res::Def(DefKind::Macro(..), _) => {}\n                     _ if macros_only => continue,\n@@ -1219,10 +1219,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn module_expansion(&self, id: DefIndex, sess: &Session) -> ExpnId {\n-        if let EntryKind::Mod(m) = self.kind(id) {\n-            m.decode((self, sess)).expansion\n-        } else {\n-            panic!(\"Expected module, found {:?}\", self.local_def_id(id))\n+        match self.kind(id) {\n+            EntryKind::Mod(_) | EntryKind::Enum(_) | EntryKind::Trait(_) => {\n+                self.get_expn_that_defined(id, sess)\n+            }\n+            _ => panic!(\"Expected module, found {:?}\", self.local_def_id(id)),\n         }\n     }\n "}, {"sha": "0dbef66ac37d77ff78eeb6fa2fb10a5986f1e1f3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1086,11 +1086,11 @@ impl EncodeContext<'a, 'tcx> {\n             Lazy::empty()\n         };\n \n-        let data = ModData { reexports, expansion: tcx.expn_that_defined(local_def_id) };\n-\n-        record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.tables.kind[def_id] <- EntryKind::Mod(reexports));\n         if self.is_proc_macro {\n             record!(self.tables.children[def_id] <- &[]);\n+            // Encode this here because we don't do it in encode_def_ids.\n+            record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n             record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n                 item_id.def_id.local_def_index"}, {"sha": "4e09d23169aca3c771b86ad12d68c6ec713c32b2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -346,7 +346,7 @@ enum EntryKind {\n     Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n-    Mod(Lazy<ModData>),\n+    Mod(Lazy<[Export]>),\n     MacroDef(Lazy<MacroDef>),\n     ProcMacro(MacroKind),\n     Closure,\n@@ -364,12 +364,6 @@ enum EntryKind {\n #[derive(Encodable, Decodable)]\n struct RenderedConst(String);\n \n-#[derive(MetadataEncodable, MetadataDecodable)]\n-struct ModData {\n-    reexports: Lazy<[Export]>,\n-    expansion: ExpnId,\n-}\n-\n #[derive(MetadataEncodable, MetadataDecodable)]\n struct FnData {\n     asyncness: hir::IsAsync,"}, {"sha": "33af9884cbb6686ced37c2729251fdb5094491e1", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -145,17 +145,11 @@ impl<'a> Resolver<'a> {\n                     } else {\n                         def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n                     };\n-                    let expn_id = if def_kind == DefKind::Mod {\n-                        self.cstore().module_expansion_untracked(def_id, &self.session)\n-                    } else {\n-                        // FIXME: Parent expansions for enums and traits are not kept in metadata.\n-                        ExpnId::root()\n-                    };\n \n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n-                        expn_id,\n+                        self.cstore().module_expansion_untracked(def_id, &self.session),\n                         self.cstore().get_span_untracked(def_id, &self.session),\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),"}, {"sha": "163acebcceacffe792a1238f13a014e71a6858c5", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -842,9 +842,11 @@ impl<'a> Resolver<'a> {\n \n                 // collect results based on the filter function\n                 // avoid suggesting anything from the same module in which we are resolving\n+                // avoid suggesting anything with a hygienic name\n                 if ident.name == lookup_ident.name\n                     && ns == namespace\n                     && !ptr::eq(in_module, parent_scope.module)\n+                    && !ident.span.normalize_to_macros_2_0().from_expansion()\n                 {\n                     let res = name_binding.res();\n                     if filter_fn(res) {"}, {"sha": "724d1904dc33c7125d7231f2190abc64d7d4f7c9", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -709,7 +709,7 @@ impl SyntaxContext {\n     ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n     ///     }\n-    ///     n(f);\n+    ///     n!(f);\n     ///     macro n($j:ident) {\n     ///         use foo::*;\n     ///         f(); // `f`'s `SyntaxContext` has a mark from `m` and a mark from `n`"}, {"sha": "60676ad3f4f606b9cec87aec869d4083b539f098", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1547,8 +1547,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Check if a bound would previously have been removed when normalizing\n         // the param_env so that it can be given the lowest priority. See\n         // #50825 for the motivation for this.\n-        let is_global =\n-            |cand: &ty::PolyTraitRef<'_>| cand.is_known_global() && !cand.has_late_bound_regions();\n+        let is_global = |cand: &ty::PolyTraitRef<'tcx>| {\n+            cand.is_global(self.infcx.tcx) && !cand.has_late_bound_regions()\n+        };\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n         // and `DiscriminantKindCandidate` to anything else."}, {"sha": "8007b9f23776a169f141afa3d63ca7f61617839a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{source_map, FileName, MultiSpan, Span};\n+use rustc_span::{source_map, FileName, MultiSpan, Span, Symbol};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{FulfillmentError, Obligation};\n \n@@ -1251,6 +1251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.lang_items().deref_trait(),\n                 self.tcx.lang_items().deref_mut_trait(),\n                 self.tcx.lang_items().drop_trait(),\n+                self.tcx.get_diagnostic_item(sym::AsRef),\n             ];\n             // Try alternative arbitrary self types that could fulfill this call.\n             // FIXME: probe for all types that *could* be arbitrary self-types, not\n@@ -1300,7 +1301,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // We don't want to suggest a container type when the missing\n                             // method is `.clone()` or `.deref()` otherwise we'd suggest\n                             // `Arc::new(foo).clone()`, which is far from what the user wants.\n-                            let skip = skippable.contains(&did);\n+                            // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n+                            // implement the `AsRef` trait.\n+                            let skip = skippable.contains(&did)\n+                                || ((\"Pin::new\" == *pre)\n+                                    && (Symbol::intern(\"as_ref\") == item_name.name));\n                             // Make sure the method is defined for the *actual* receiver: we don't\n                             // want to treat `Box<Self>` as a receiver if it only works because of\n                             // an autoderef to `&self`"}, {"sha": "826e7782db1e96420756258f3c68846699cadef7", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -6,7 +6,7 @@ use std::rc::Rc;\n use std::sync::mpsc::{channel, Receiver};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -54,6 +54,9 @@ crate struct Context<'tcx> {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub(super) render_redirect_pages: bool,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: RefCell<FxHashMap<DefId, String>>,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     pub(super) id_map: RefCell<IdMap>,\n     /// Shared mutable state.\n@@ -70,7 +73,7 @@ crate struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Context<'_>, 104);\n+rustc_data_structures::static_assert_size!(Context<'_>, 144);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n crate struct SharedContext<'tcx> {\n@@ -513,6 +516,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst,\n             render_redirect_pages: false,\n             id_map: RefCell::new(id_map),\n+            deref_id_map: RefCell::new(FxHashMap::default()),\n             shared: Rc::new(scx),\n             include_sources,\n         };\n@@ -536,6 +540,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: self.current.clone(),\n             dst: self.dst.clone(),\n             render_redirect_pages: self.render_redirect_pages,\n+            deref_id_map: RefCell::new(FxHashMap::default()),\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n             include_sources: self.include_sources,"}, {"sha": "f78129050d7ec6124b67e97374c5e7501ab96f0c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 78, "deletions": 16, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1054,6 +1054,19 @@ fn render_assoc_items(\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+) {\n+    let mut derefs = FxHashSet::default();\n+    derefs.insert(it);\n+    render_assoc_items_inner(w, cx, containing_item, it, what, &mut derefs)\n+}\n+\n+fn render_assoc_items_inner(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    containing_item: &clean::Item,\n+    it: DefId,\n+    what: AssocItemRender<'_>,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let cache = cx.cache();\n@@ -1063,31 +1076,39 @@ fn render_assoc_items(\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n+        let mut tmp_buf = Buffer::empty_from(w);\n         let render_mode = match what {\n             AssocItemRender::All => {\n-                w.write_str(\n+                tmp_buf.write_str(\n                     \"<h2 id=\\\"implementations\\\" class=\\\"small-section-header\\\">\\\n                          Implementations<a href=\\\"#implementations\\\" class=\\\"anchor\\\"></a>\\\n                     </h2>\",\n                 );\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n+                let id =\n+                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n+                if let Some(def_id) = type_.def_id(cx.cache()) {\n+                    cx.deref_id_map.borrow_mut().insert(def_id, id.clone());\n+                }\n                 write!(\n-                    w,\n-                    \"<h2 id=\\\"deref-methods\\\" class=\\\"small-section-header\\\">\\\n+                    tmp_buf,\n+                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                          <span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\\\n-                         <a href=\\\"#deref-methods\\\" class=\\\"anchor\\\"></a>\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n+                    id = id,\n                     trait_ = trait_.print(cx),\n                     type_ = type_.print(cx),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n+        let mut impls_buf = Buffer::empty_from(w);\n         for i in &non_trait {\n             render_impl(\n-                w,\n+                &mut impls_buf,\n                 cx,\n                 i,\n                 containing_item,\n@@ -1104,18 +1125,27 @@ fn render_assoc_items(\n                 },\n             );\n         }\n+        if !impls_buf.is_empty() {\n+            w.push_buffer(tmp_buf);\n+            w.push_buffer(impls_buf);\n+        }\n     }\n-    if let AssocItemRender::DerefFor { .. } = what {\n-        return;\n-    }\n+\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n                 traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, derefs);\n+        }\n+\n+        // If we were already one level into rendering deref methods, we don't want to render\n+        // anything after recursing into any further deref methods above.\n+        if let AssocItemRender::DerefFor { .. } = what {\n+            return;\n         }\n+\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -1167,6 +1197,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     let cache = cx.cache();\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n@@ -1188,16 +1219,16 @@ fn render_deref_methods(\n     if let Some(did) = target.def_id(cache) {\n         if let Some(type_did) = impl_.inner_impl().for_.def_id(cache) {\n             // `impl Deref<Target = S> for S`\n-            if did == type_did {\n+            if did == type_did || !derefs.insert(did) {\n                 // Avoid infinite cycles\n                 return;\n             }\n         }\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+                render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n             }\n         }\n     }\n@@ -1987,7 +2018,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             if let Some(impl_) =\n                 v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n             {\n-                sidebar_deref_methods(cx, out, impl_, v);\n+                let mut derefs = FxHashSet::default();\n+                derefs.insert(did);\n+                sidebar_deref_methods(cx, out, impl_, v, &mut derefs);\n             }\n \n             let format_impls = |impls: Vec<&Impl>| {\n@@ -2061,7 +2094,13 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[Impl]) {\n+fn sidebar_deref_methods(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    impl_: &Impl,\n+    v: &[Impl],\n+    derefs: &mut FxHashSet<DefId>,\n+) {\n     let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n@@ -2078,7 +2117,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n         if let Some(did) = target.def_id(c) {\n             if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n                 // `impl Deref<Target = S> for S`\n-                if did == type_did {\n+                if did == type_did || !derefs.insert(did) {\n                     // Avoid infinite cycles\n                     return;\n                 }\n@@ -2102,9 +2141,17 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n+                let map;\n+                let id = if let Some(target_def_id) = real_target.def_id(c) {\n+                    map = cx.deref_id_map.borrow();\n+                    map.get(&target_def_id).expect(\"Deref section without derived id\")\n+                } else {\n+                    \"deref-methods\"\n+                };\n                 write!(\n                     out,\n-                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#deref-methods\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    id,\n                     Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n                     Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );\n@@ -2117,6 +2164,21 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 out.push_str(\"</div>\");\n             }\n         }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id_no_primitives() {\n+            if let Some(target_impls) = c.impls.get(&target_did) {\n+                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                    i.inner_impl()\n+                        .trait_\n+                        .as_ref()\n+                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                        .unwrap_or(false)\n+                }) {\n+                    sidebar_deref_methods(cx, out, target_deref_impl, target_impls, derefs);\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "93cbc0debb945378213a53e68a42b68fa61d7054", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -134,7 +134,7 @@ h1, h2, h3, h4 {\n \tmargin: 20px 0 15px 0;\n \tpadding-bottom: 6px;\n }\n-h5, h6 {\n+.docblock h3, .docblock h4, h5, h6 {\n \tmargin: 15px 0 5px 0;\n }\n h1.fqn {\n@@ -149,7 +149,14 @@ h1.fqn {\n h1.fqn > .in-band > a:hover {\n \ttext-decoration: underline;\n }\n-h2, h3, h4 {\n+/* The only headings that get underlines are:\n+\t Markdown-generated headings within the top-doc\n+\t Rustdoc-generated h2 section headings (e.g. \"Implementations\", \"Required Methods\", etc)\n+\tUnderlines elsewhere in the documentation break up visual flow and tend to invert\n+\tsection hierarchies. */\n+h2,\n+.top-doc h3,\n+.top-doc h4 {\n \tborder-bottom: 1px solid;\n }\n h3.code-header {"}, {"sha": "7a4198198fa694ca15f2883e039972fe5a8a8410", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -3,7 +3,8 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n@@ -51,12 +52,35 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     }\n \n     let mut cleaner = BadImplStripper { prims, items: crate_items };\n+    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n+\n+    // Follow all `Deref` targets of included items and recursively add them as valid\n+    fn add_deref_target(\n+        map: &FxHashMap<DefId, &Type>,\n+        cleaner: &mut BadImplStripper,\n+        type_did: DefId,\n+    ) {\n+        if let Some(target) = map.get(&type_did) {\n+            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n+            if let Some(target_prim) = target.primitive_type() {\n+                cleaner.prims.insert(target_prim);\n+            } else if let Some(target_did) = target.def_id_no_primitives() {\n+                // `impl Deref<Target = S> for S`\n+                if target_did == type_did {\n+                    // Avoid infinite cycles\n+                    return;\n+                }\n+                cleaner.items.insert(target_did.into());\n+                add_deref_target(map, cleaner, target_did);\n+            }\n+        }\n+    }\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_impl(for_)\n-                && trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+            if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+                && cleaner.keep_impl(for_, true)\n             {\n                 let target = items\n                     .iter()\n@@ -71,16 +95,26 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n+                if let Some(for_did) = for_.def_id_no_primitives() {\n+                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                            add_deref_target(&type_did_to_deref_target, &mut cleaner, for_did);\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n \n     new_items.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_impl(for_)\n-                || trait_\n-                    .as_ref()\n-                    .map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n+            cleaner.keep_impl(\n+                for_,\n+                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+            ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || blanket_impl.is_some()\n         } else {\n             true\n@@ -179,14 +213,14 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_impl(&self, ty: &Type) -> bool {\n+    fn keep_impl(&self, ty: &Type, is_deref: bool) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id_no_primitives() {\n-            self.keep_impl_with_def_id(did.into())\n+            is_deref || self.keep_impl_with_def_id(did.into())\n         } else {\n             false\n         }"}, {"sha": "35d772170f6f98c3b96f5cf69a6ab4ce96d19ad0", "filename": "src/test/rustdoc-gui/headings.goml", "status": "renamed", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1,6 +1,8 @@\n-// This test check that headers (a) have the correct heading level, and (b) are the right size.\n+// This test check that headers (a) have the correct heading level, (b) are the right size,\n+// and (c) have the correct underlining (or absence of underlining).\n // The sizes may change as design changes, but try to make sure a lower header is never bigger than\n-// its parent headers.\n+// its parent headers. Also make sure lower headers don't have underlines when their parents lack\n+// an underline.\n // Most of these sizes are set in CSS in `em` units, so here's a conversion chart based on our\n // default 16px font size:\n // 24px    1.5em\n@@ -13,87 +15,139 @@\n goto: file://|DOC_PATH|/test_docs/struct.HeavilyDocumentedStruct.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\"h1.fqn\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"font-size\": \"18.4px\"})\n+assert-css: (\"h3#top-doc-prose-sub-heading\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h4#top-doc-prose-sub-sub-heading\", {\"font-size\": \"17.6px\"})\n+assert-css: (\"h4#top-doc-prose-sub-sub-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#fields\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#fields\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#title-for-field\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h3#title-for-field\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h4#sub-heading-for-field\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#sub-heading-for-field\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h2#implementations\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#implementations\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"#impl > h3.code-header\", {\"font-size\": \"17.6px\"})\n+assert-css: (\"#impl > h3.code-header\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"#method\\.do_nothing > h4.code-header\", {\"font-size\": \"16px\"})\n+assert-css: (\"#method\\.do_nothing > h4.code-header\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h4#title-for-struct-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#title-for-struct-impl-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h5#sub-heading-for-struct-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#sub-heading-for-struct-impl-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-sub-heading-for-struct-impl-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-sub-heading-for-struct-impl-doc\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h5#title-for-struct-impl-item-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#title-for-struct-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-heading-for-struct-impl-item-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-heading-for-struct-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-sub-heading-for-struct-impl-item-doc\", {\"font-size\": \"15.2px\"})\n \n goto: file://|DOC_PATH|/test_docs/enum.HeavilyDocumentedEnum.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\"h1.fqn\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"font-size\": \"18.4px\"})\n+assert-css: (\"h3#top-doc-prose-sub-heading\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h4#top-doc-prose-sub-sub-heading\", {\"font-size\": \"17.6px\"})\n+assert-css: (\"h4#top-doc-prose-sub-sub-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#variants\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#variants\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h3#none-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h3#none-prose-title\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h4#none-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#none-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h3#wrapped-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h3#wrapped-prose-title\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h4#wrapped-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#wrapped-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h4#wrapped0-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#wrapped0-prose-title\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h5#wrapped0-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#wrapped0-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h4#structy-prose-title\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#structy-prose-title\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h5#structy-prose-sub-heading\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#structy-prose-sub-heading\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h2#implementations\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#implementations\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"#impl > h3.code-header\", {\"font-size\": \"17.6px\"})\n+assert-css: (\"#impl > h3.code-header\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"#method\\.do_nothing > h4.code-header\", {\"font-size\": \"16px\"})\n+assert-css: (\"#method\\.do_nothing > h4.code-header\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h4#title-for-enum-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#title-for-enum-impl-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h5#sub-heading-for-enum-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#sub-heading-for-enum-impl-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-sub-heading-for-enum-impl-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-sub-heading-for-enum-impl-doc\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h5#title-for-enum-impl-item-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#title-for-enum-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-heading-for-enum-impl-item-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-heading-for-enum-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-sub-heading-for-enum-impl-item-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-sub-heading-for-enum-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n \n goto: file://|DOC_PATH|/test_docs/union.HeavilyDocumentedUnion.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\"h1.fqn\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"font-size\": \"18.4px\"})\n+assert-css: (\"h3#top-doc-prose-sub-heading\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#fields\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#fields\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h3#title-for-union-variant\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h3#title-for-union-variant\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h4#sub-heading-for-union-variant\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#sub-heading-for-union-variant\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h2#implementations\", {\"font-size\": \"22.4px\"})\n+assert-css: (\"h2#implementations\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"#impl > h3.code-header\", {\"font-size\": \"17.6px\"})\n+assert-css: (\"#impl > h3.code-header\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h4#title-for-union-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h4#title-for-union-impl-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h5#sub-heading-for-union-impl-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#sub-heading-for-union-impl-doc\", {\"border-bottom-width\": \"0px\"})\n \n assert-css: (\"h5#title-for-union-impl-item-doc\", {\"font-size\": \"16px\"})\n+assert-css: (\"h5#title-for-union-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n assert-css: (\"h6#sub-heading-for-union-impl-item-doc\", {\"font-size\": \"15.2px\"})\n+assert-css: (\"h6#sub-heading-for-union-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n \n goto: file://|DOC_PATH|/test_docs/macro.heavily_documented_macro.html\n \n assert-css: (\"h1.fqn\", {\"font-size\": \"24px\"})\n+assert-css: (\"h1.fqn\", {\"border-bottom-width\": \"1px\"})\n \n assert-css: (\"h2#top-doc-prose-title\", {\"font-size\": \"20.8px\"})\n+assert-css: (\"h2#top-doc-prose-title\", {\"border-bottom-width\": \"1px\"})\n assert-css: (\"h3#top-doc-prose-sub-heading\", {\"font-size\": \"18.4px\"})\n+assert-css: (\"h3#top-doc-prose-sub-heading\", {\"border-bottom-width\": \"1px\"})", "previous_filename": "src/test/rustdoc-gui/header-size.goml"}, {"sha": "c44fd27f40305b38e454d00232ae2859dbcccfef", "filename": "src/test/rustdoc-ui/recursive-deref-ice.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// ICE found in https://github.com/rust-lang/rust/issues/83123\n+\n+pub struct Attribute;\n+\n+pub struct Map<'hir> {}\n+impl<'hir> Map<'hir> {\n+    pub fn attrs(&self) -> &'hir [Attribute] { &[] }\n+}\n+\n+pub struct List<T>(T);\n+\n+impl<T> std::ops::Deref for List<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &[]\n+    }\n+}"}, {"sha": "9ab338ca9b1d1bd42e7eb1ea4e4b207a350acc46", "filename": "src/test/rustdoc/deref-recursive-pathbuf.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,25 @@\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels and across multiple crates.\n+// For `Deref` on non-foreign types, look at `deref-recursive.rs`.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-PathBuf\"]' 'Methods from Deref<Target = PathBuf>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.as_path\"]' 'pub fn as_path(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Path\"]' 'Methods from Deref<Target = Path>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.exists\"]' 'pub fn exists(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-PathBuf\"]' 'Methods from Deref<Target=PathBuf>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.as_path\"]' 'as_path'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Path\"]' 'Methods from Deref<Target=Path>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.exists\"]' 'exists'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+use std::path::PathBuf;\n+\n+pub struct Foo(PathBuf);\n+\n+impl Deref for Foo {\n+    type Target = PathBuf;\n+    fn deref(&self) -> &PathBuf { &self.0 }\n+}"}, {"sha": "c07e048b0651c41f9ab2ee2b0c055bfd4142fce5", "filename": "src/test/rustdoc/deref-recursive.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,41 @@\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels if needed.\n+// For `Deref` on foreign types, look at `deref-recursive-pathbuf.rs`.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-Bar\"]' 'Methods from Deref<Target = Bar>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.bar\"]' 'pub fn bar(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Baz\"]' 'Methods from Deref<Target = Baz>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.baz\"]' 'pub fn baz(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Bar\"]' 'Methods from Deref<Target=Bar>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.bar\"]' 'bar'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Baz\"]' 'Methods from Deref<Target=Baz>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.baz\"]' 'baz'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+\n+pub struct Foo(Bar);\n+pub struct Bar(Baz);\n+pub struct Baz;\n+\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar { &self.0 }\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { &self.0 }\n+}\n+\n+impl Bar {\n+    /// This appears under `Foo` methods\n+    pub fn bar(&self) {}\n+}\n+\n+impl Baz {\n+    /// This should also appear in `Foo` methods when recursing\n+    pub fn baz(&self) {}\n+}"}, {"sha": "ad7a96c5dad1fc7c6ce37cc1746c13b7387b85d7", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1,12 +1,12 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.Bar.html'\n-// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooJ>'\n+// @has '-' '//*[@id=\"deref-methods-FooJ\"]' 'Methods from Deref<Target = FooJ>'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_j\"]' 'pub fn foo_j(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods\"]' 'Methods from Deref<Target=FooJ>'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-FooJ\"]' 'Methods from Deref<Target=FooJ>'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'"}, {"sha": "65a7debc2538dd8e1804d0a302956a0e60fe5c2c", "filename": "src/test/rustdoc/recursive-deref-sidebar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -15,7 +15,7 @@ impl Deref for A {\n     fn deref(&self) -> &B { todo!() }\n }\n \n-// @!has recursive_deref_sidebar/struct.A.html '//div[@class=\"sidebar-links\"]' 'foo_c'\n+// @has recursive_deref_sidebar/struct.A.html '//div[@class=\"sidebar-links\"]' 'foo_c'\n impl Deref for B {\n     type Target = C;\n     fn deref(&self) -> &C { todo!() }"}, {"sha": "a7504fbccfb508f9384b13b551698a2fc59fd2cc", "filename": "src/test/rustdoc/recursive-deref.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frecursive-deref.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -1,9 +1,16 @@\n use std::ops::Deref;\n \n+// Cyclic deref with the parent (which is not the top parent).\n pub struct A;\n pub struct B;\n+pub struct C;\n+\n+impl C {\n+    pub fn c(&self) {}\n+}\n \n // @has recursive_deref/struct.A.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for A'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for A {\n     type Target = B;\n \n@@ -13,8 +20,99 @@ impl Deref for A {\n }\n \n // @has recursive_deref/struct.B.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for B'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for B {\n-    type Target = A;\n+    type Target = C;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.C.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for C'\n+impl Deref for C {\n+    type Target = B;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// Cyclic deref with the grand-parent (which is not the top parent).\n+pub struct D;\n+pub struct E;\n+pub struct F;\n+pub struct G;\n+\n+impl G {\n+    // There is no \"self\" parameter so it shouldn't be listed!\n+    pub fn g() {}\n+}\n+\n+// @has recursive_deref/struct.D.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for D'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for D {\n+    type Target = E;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.E.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for E'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for E {\n+    type Target = F;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.F.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for F'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for F {\n+    type Target = G;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.G.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for G'\n+impl Deref for G {\n+    type Target = E;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// Cyclic deref with top parent.\n+pub struct H;\n+pub struct I;\n+\n+impl I {\n+    // There is no \"self\" parameter so it shouldn't be listed!\n+    pub fn i() {}\n+}\n+\n+// @has recursive_deref/struct.H.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for H'\n+// @!has '-' '//*[@id=\"deref-methods-I\"]'\n+impl Deref for H {\n+    type Target = I;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.I.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for I'\n+impl Deref for I {\n+    type Target = H;\n \n     fn deref(&self) -> &Self::Target {\n         panic!()"}, {"sha": "733d11a9e8229349dde7068f55b06a33e6c833b1", "filename": "src/test/ui/hygiene/auxiliary/fields.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,73 @@\n+#![feature(decl_macro)]\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Field {\n+    RootCtxt,\n+    MacroCtxt,\n+}\n+\n+#[rustfmt::skip]\n+macro x(\n+    $macro_name:ident,\n+    $macro2_name:ident,\n+    $type_name:ident,\n+    $field_name:ident,\n+    $const_name:ident\n+) {\n+    #[derive(Copy, Clone)]\n+    pub struct $type_name {\n+        pub field: Field,\n+        pub $field_name: Field,\n+    }\n+\n+    pub const $const_name: $type_name =\n+        $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt };\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (check_fields_of $e:expr) => {{\n+            let e = $e;\n+            assert_eq!(e.field, Field::MacroCtxt);\n+            assert_eq!(e.$field_name, Field::RootCtxt);\n+        }};\n+        (check_fields) => {{\n+            assert_eq!($const_name.field, Field::MacroCtxt);\n+            assert_eq!($const_name.$field_name, Field::RootCtxt);\n+        }};\n+        (construct) => {\n+            $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt }\n+        };\n+    }\n+\n+    pub macro $macro2_name {\n+        (check_fields_of $e:expr) => {{\n+            let e = $e;\n+            assert_eq!(e.field, Field::MacroCtxt);\n+            assert_eq!(e.$field_name, Field::RootCtxt);\n+        }},\n+        (check_fields) => {{\n+            assert_eq!($const_name.field, Field::MacroCtxt);\n+            assert_eq!($const_name.$field_name, Field::RootCtxt);\n+        }},\n+        (construct) => {\n+            $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt }\n+        }\n+    }\n+}\n+\n+x!(test_fields, test_fields2, MyStruct, field, MY_CONST);\n+\n+pub fn check_fields(s: MyStruct) {\n+    test_fields!(check_fields_of s);\n+}\n+\n+pub fn check_fields_local() {\n+    test_fields!(check_fields);\n+    test_fields2!(check_fields);\n+\n+    let s1 = test_fields!(construct);\n+    test_fields!(check_fields_of s1);\n+\n+    let s2 = test_fields2!(construct);\n+    test_fields2!(check_fields_of s2);\n+}"}, {"sha": "23b9c61cfc05820cac7060ec9757f70421f03100", "filename": "src/test/ui/hygiene/auxiliary/methods.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,160 @@\n+#![feature(decl_macro)]\n+\n+#[derive(PartialEq, Eq, Debug)]\n+pub enum Method {\n+    DefaultMacroCtxt,\n+    DefaultRootCtxt,\n+    OverrideMacroCtxt,\n+    OverrideRootCtxt,\n+}\n+\n+#[rustfmt::skip]\n+macro x($macro_name:ident, $macro2_name:ident, $trait_name:ident, $method_name:ident) {\n+    pub trait $trait_name {\n+        fn method(&self) -> Method {\n+            Method::DefaultMacroCtxt\n+        }\n+\n+        fn $method_name(&self) -> Method {\n+            Method::DefaultRootCtxt\n+        }\n+    }\n+\n+    impl $trait_name for () {}\n+    impl $trait_name for bool {\n+        fn method(&self) -> Method {\n+            Method::OverrideMacroCtxt\n+        }\n+\n+        fn $method_name(&self) -> Method {\n+            Method::OverrideRootCtxt\n+        }\n+    }\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (check_resolutions) => {\n+            assert_eq!(().method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&()), Method::DefaultMacroCtxt);\n+            assert_eq!(().$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&()), Method::DefaultRootCtxt);\n+\n+            assert_eq!(false.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&false), Method::OverrideMacroCtxt);\n+            assert_eq!(false.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&false), Method::OverrideRootCtxt);\n+\n+            assert_eq!('a'.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&'a'), Method::DefaultMacroCtxt);\n+            assert_eq!('a'.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&'a'), Method::DefaultRootCtxt);\n+\n+            assert_eq!(1i32.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i32), Method::OverrideMacroCtxt);\n+            assert_eq!(1i32.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i32), Method::OverrideRootCtxt);\n+\n+            assert_eq!(1i64.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i64), Method::OverrideMacroCtxt);\n+            assert_eq!(1i64.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i64), Method::OverrideRootCtxt);\n+        };\n+        (assert_no_override $v:expr) => {\n+            assert_eq!($v.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::DefaultMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::DefaultRootCtxt);\n+        };\n+        (assert_override $v:expr) => {\n+            assert_eq!($v.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::OverrideMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::OverrideRootCtxt);\n+        };\n+        (impl for $t:ty) => {\n+            impl $trait_name for $t {\n+                fn method(&self) -> Method {\n+                    Method::OverrideMacroCtxt\n+                }\n+\n+                fn $method_name(&self) -> Method {\n+                    Method::OverrideRootCtxt\n+                }\n+            }\n+        };\n+    }\n+\n+    pub macro $macro2_name {\n+        (check_resolutions) => {\n+            assert_eq!(().method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&()), Method::DefaultMacroCtxt);\n+            assert_eq!(().$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&()), Method::DefaultRootCtxt);\n+\n+            assert_eq!(false.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&false), Method::OverrideMacroCtxt);\n+            assert_eq!(false.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&false), Method::OverrideRootCtxt);\n+\n+            assert_eq!('a'.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&'a'), Method::DefaultMacroCtxt);\n+            assert_eq!('a'.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&'a'), Method::DefaultRootCtxt);\n+\n+            assert_eq!(1i32.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i32), Method::OverrideMacroCtxt);\n+            assert_eq!(1i32.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i32), Method::OverrideRootCtxt);\n+\n+            assert_eq!(1i64.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i64), Method::OverrideMacroCtxt);\n+            assert_eq!(1i64.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i64), Method::OverrideRootCtxt);\n+        },\n+        (assert_no_override $v:expr) => {\n+            assert_eq!($v.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::DefaultMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::DefaultRootCtxt);\n+        },\n+        (assert_override $v:expr) => {\n+            assert_eq!($v.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::OverrideMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::OverrideRootCtxt);\n+        },\n+        (impl for $t:ty) => {\n+            impl $trait_name for $t {\n+                fn method(&self) -> Method {\n+                    Method::OverrideMacroCtxt\n+                }\n+\n+                fn $method_name(&self) -> Method {\n+                    Method::OverrideRootCtxt\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+x!(test_trait, test_trait2, MyTrait, method);\n+\n+impl MyTrait for char {}\n+test_trait!(impl for i32);\n+test_trait2!(impl for i64);\n+\n+pub fn check_crate_local() {\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+}\n+\n+// Check that any comparison of idents at monomorphization time is correct\n+pub fn check_crate_local_generic<T: MyTrait, U: MyTrait>(t: T, u: U) {\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+\n+    test_trait!(assert_no_override t);\n+    test_trait2!(assert_no_override t);\n+    test_trait!(assert_override u);\n+    test_trait2!(assert_override u);\n+}"}, {"sha": "47e76a629c8b1cedd186086560d3bc2ca21c6fde", "filename": "src/test/ui/hygiene/auxiliary/pub_hygiene.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,7 @@\n+#![feature(decl_macro)]\n+\n+macro x() {\n+    pub struct MyStruct;\n+}\n+\n+x!();"}, {"sha": "791cf0358952a648e6c94d2662271614ebba8c1e", "filename": "src/test/ui/hygiene/auxiliary/use_by_macro.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,15 @@\n+#![feature(decl_macro)]\n+\n+macro x($macro_name:ident) {\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (define) => {\n+            pub struct MyStruct;\n+        };\n+        (create) => {\n+            MyStruct {}\n+        };\n+    }\n+}\n+\n+x!(my_struct);"}, {"sha": "dbfcce17d47f1f6e3081571508a49900b58067ea", "filename": "src/test/ui/hygiene/auxiliary/variants.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,36 @@\n+#![feature(decl_macro)]\n+\n+#[rustfmt::skip]\n+macro x($macro_name:ident, $macro2_name:ident, $type_name:ident, $variant_name:ident) {\n+    #[repr(u8)]\n+    pub enum $type_name {\n+        Variant = 0,\n+        $variant_name = 1,\n+    }\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        () => {{\n+            assert_eq!($type_name::Variant as u8, 0);\n+            assert_eq!($type_name::$variant_name as u8, 1);\n+            assert_eq!(<$type_name>::Variant as u8, 0);\n+            assert_eq!(<$type_name>::$variant_name as u8, 1);\n+        }};\n+    }\n+\n+    pub macro $macro2_name {\n+        () => {{\n+            assert_eq!($type_name::Variant as u8, 0);\n+            assert_eq!($type_name::$variant_name as u8, 1);\n+            assert_eq!(<$type_name>::Variant as u8, 0);\n+            assert_eq!(<$type_name>::$variant_name as u8, 1);\n+        }},\n+    }\n+}\n+\n+x!(test_variants, test_variants2, MyEnum, Variant);\n+\n+pub fn check_variants() {\n+    test_variants!();\n+    test_variants2!();\n+}"}, {"sha": "94f1adff626429f0909e96ea21c326c230dab673", "filename": "src/test/ui/hygiene/cross-crate-define-and-use.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,19 @@\n+// Check that a marco from another crate can define an item in one expansion\n+// and use it from another, without it being visible to everyone.\n+// This requires that the definition of `my_struct` preserves the hygiene\n+// information for the tokens in its definition.\n+\n+// check-pass\n+// aux-build:use_by_macro.rs\n+\n+#![feature(type_name_of_val)]\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+enum MyStruct {}\n+my_struct!(define);\n+\n+fn main() {\n+    let x = my_struct!(create);\n+}"}, {"sha": "1bcd64573ac6e19c3e073c8ad174430f09b64419", "filename": "src/test/ui/hygiene/cross-crate-fields.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,24 @@\n+// Test that fields on a struct defined in another crate are resolved correctly\n+// their names differ only in `SyntaxContext`.\n+\n+// run-pass\n+// aux-build:fields.rs\n+\n+extern crate fields;\n+\n+use fields::*;\n+\n+fn main() {\n+    check_fields_local();\n+\n+    test_fields!(check_fields);\n+    test_fields2!(check_fields);\n+\n+    let s1 = test_fields!(construct);\n+    check_fields(s1);\n+    test_fields!(check_fields_of s1);\n+\n+    let s2 = test_fields2!(construct);\n+    check_fields(s2);\n+    test_fields2!(check_fields_of s2);\n+}"}, {"sha": "de5576682a6bdd725ceaa0e2e90d8323386be039", "filename": "src/test/ui/hygiene/cross-crate-glob-hygiene.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,23 @@\n+// Check that globs cannot import hygienic identifiers from a macro expansion\n+// in another crate. `my_struct` is a `macro_rules` macro, so the struct it\n+// defines is only not imported because `my_struct` is defined by a macros 2.0\n+// macro.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+mod m {\n+    use use_by_macro::*;\n+\n+    my_struct!(define);\n+}\n+\n+use m::*;\n+\n+fn main() {\n+    let x = my_struct!(create);\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "7369e77d0709eb2420cce04572a22bb8867c3a1b", "filename": "src/test/ui/hygiene/cross-crate-glob-hygiene.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,11 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-glob-hygiene.rs:21:13\n+   |\n+LL |     let x = my_struct!(create);\n+   |             ^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: this error originates in the macro `my_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "0e6f57c33f64a26f213db38ac52b47ce5d0f6e08", "filename": "src/test/ui/hygiene/cross-crate-methods.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,33 @@\n+// Test that methods defined in another crate are resolved correctly their\n+// names differ only in `SyntaxContext`. This also checks that any name\n+// resolution done when monomorphizing is correct.\n+\n+// run-pass\n+// aux-build:methods.rs\n+\n+extern crate methods;\n+\n+use methods::*;\n+\n+struct A;\n+struct B;\n+struct C;\n+\n+impl MyTrait for A {}\n+test_trait!(impl for B);\n+test_trait2!(impl for C);\n+\n+fn main() {\n+    check_crate_local();\n+    check_crate_local_generic(A, B);\n+    check_crate_local_generic(A, C);\n+\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+    test_trait!(assert_no_override A);\n+    test_trait2!(assert_no_override A);\n+    test_trait!(assert_override B);\n+    test_trait2!(assert_override B);\n+    test_trait!(assert_override C);\n+    test_trait2!(assert_override C);\n+}"}, {"sha": "8f118782f2319864c5cadb21e952cd3b2b149013", "filename": "src/test/ui/hygiene/cross-crate-name-collision.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,12 @@\n+// Check that two items defined in another crate that have identifiers that\n+// only differ by `SyntaxContext` do not cause name collisions when imported\n+// in another crate.\n+\n+// check-pass\n+// aux-build:needs_hygiene.rs\n+\n+extern crate needs_hygiene;\n+\n+use needs_hygiene::*;\n+\n+fn main() {}"}, {"sha": "3eacd775c9e539e5e32b12d060a19dc828396753", "filename": "src/test/ui/hygiene/cross-crate-name-hiding-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,15 @@\n+// Check that an identifier from a 2.0 macro in another crate cannot be\n+// resolved with an identifier that's not from a macro expansion.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+my_struct!(define);\n+\n+fn main() {\n+    let x = MyStruct {};\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "46314cdd5ab4eafb0239ff8c3cbf02e843e54907", "filename": "src/test/ui/hygiene/cross-crate-name-hiding-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,9 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-name-hiding-2.rs:13:13\n+   |\n+LL |     let x = MyStruct {};\n+   |             ^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "dd76ecc5762f534b0129692e367519b9ab4ed41f", "filename": "src/test/ui/hygiene/cross-crate-name-hiding.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,13 @@\n+// Check that an item defined by a 2.0 macro in another crate cannot be used in\n+// another crate.\n+\n+// aux-build:pub_hygiene.rs\n+\n+extern crate pub_hygiene;\n+\n+use pub_hygiene::*;\n+\n+fn main() {\n+    let x = MyStruct {};\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "f8840c8f85a33f5f3be6d22dbc2dfb2f3ba24296", "filename": "src/test/ui/hygiene/cross-crate-name-hiding.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,9 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-name-hiding.rs:11:13\n+   |\n+LL |     let x = MyStruct {};\n+   |             ^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "3cb06b4bad87359d98e677838465b70635b8de62", "filename": "src/test/ui/hygiene/cross-crate-redefine.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,14 @@\n+// Check that items with identical `SyntaxContext` conflict even when that\n+// context involves a mark from another crate.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+my_struct!(define);\n+//~^ ERROR the name `MyStruct` is defined multiple times\n+my_struct!(define);\n+\n+fn main() {}"}, {"sha": "4f1419de426778663d13b163e4b5be8080a921d1", "filename": "src/test/ui/hygiene/cross-crate-redefine.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,15 @@\n+error[E0428]: the name `MyStruct` is defined multiple times\n+  --> $DIR/cross-crate-redefine.rs:10:1\n+   |\n+LL | my_struct!(define);\n+   | ^^^^^^^^^^^^^^^^^^ `MyStruct` redefined here\n+LL |\n+LL | my_struct!(define);\n+   | ------------------ previous definition of the type `MyStruct` here\n+   |\n+   = note: `MyStruct` must be defined only once in the type namespace of this module\n+   = note: this error originates in the macro `my_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "efc73a21f16f302e267456723e9520e39a8a37e2", "filename": "src/test/ui/hygiene/cross-crate-variants.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,18 @@\n+// Test that variants of an enum defined in another crate are resolved\n+// correctly when their names differ only in `SyntaxContext`.\n+\n+// run-pass\n+// aux-build:variants.rs\n+\n+extern crate variants;\n+\n+use variants::*;\n+\n+fn main() {\n+    check_variants();\n+\n+    test_variants!();\n+    test_variants2!();\n+\n+    assert_eq!(MyEnum::Variant as u8, 1);\n+}"}, {"sha": "75742960b7e3ccafef7b7725be18502395658955", "filename": "src/test/ui/hygiene/cross_crate_hygiene.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2609fab8e46414333aa68412134df65c7fcd1a77/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2609fab8e46414333aa68412134df65c7fcd1a77/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs?ref=2609fab8e46414333aa68412134df65c7fcd1a77", "patch": "@@ -1,8 +0,0 @@\n-// check-pass\n-// aux-build:needs_hygiene.rs\n-\n-extern crate needs_hygiene;\n-\n-use needs_hygiene::*;\n-\n-fn main() {}"}, {"sha": "5d04fe1e3de5f5cd08f9ead0fb563fdfd8d05eca", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -49,6 +49,8 @@ crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt:\n crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"produce_it\")\n crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro(Bang, \"$crate::dummy\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"include\")\n crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n "}, {"sha": "709b2a2169e08d8f9033ba28e706f17f06756acc", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -73,6 +73,8 @@ crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt:\n crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"include\")\n crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n "}, {"sha": "b739dc46e4e8b7b34369ce8ce61d618d796135ac", "filename": "src/test/ui/traits/issue-90195-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftraits%2Fissue-90195-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftraits%2Fissue-90195-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-90195-2.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+pub trait Archive {\n+    type Archived;\n+}\n+\n+impl<T> Archive for Option<T> {\n+    type Archived = ();\n+}\n+pub type Archived<T> = <T as Archive>::Archived;\n+\n+pub trait Deserialize<D> {}\n+\n+const ARRAY_SIZE: usize = 32;\n+impl<__D> Deserialize<__D> for ()\n+where\n+    Option<[u8; ARRAY_SIZE]>: Archive,\n+    Archived<Option<[u8; ARRAY_SIZE]>>: Deserialize<__D>,\n+{\n+}\n+fn main() {}"}, {"sha": "543c9f197e1bb92e8d66603009bf88a67962858c", "filename": "src/test/ui/traits/issue-90195.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftraits%2Fissue-90195.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftraits%2Fissue-90195.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-90195.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+pub trait Archive {\n+    type Archived;\n+}\n+\n+impl<T> Archive for Option<T> {\n+    type Archived = ();\n+}\n+pub type Archived<T> = <T as Archive>::Archived;\n+\n+pub trait Deserialize<D> {}\n+\n+const ARRAY_SIZE: usize = 32;\n+impl<__D> Deserialize<__D> for ()\n+where\n+    Option<[u8; ARRAY_SIZE]>: Archive,\n+    Option<[u8; ARRAY_SIZE]>: Archive,\n+    Archived<Option<[u8; ARRAY_SIZE]>>: Deserialize<__D>,\n+{\n+}\n+fn main() {}"}, {"sha": "69cec08652ae92f690eee2b7ef079c7d0f7dff89", "filename": "src/test/ui/typeck/issue-89806.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.rs?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    0u8.as_ref(); //~ ERROR no method named `as_ref` found for type `u8` in the current scope\n+}"}, {"sha": "c36b4967ee9962bf84b3b5e9464b83932be3a8a3", "filename": "src/test/ui/typeck/issue-89806.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e249ce6b2345587d6e11052779c86adbad626dff/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-89806.stderr?ref=e249ce6b2345587d6e11052779c86adbad626dff", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no method named `as_ref` found for type `u8` in the current scope\n+  --> $DIR/issue-89806.rs:2:9\n+   |\n+LL |     0u8.as_ref();\n+   |         ^^^^^^ method not found in `u8`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}