{"sha": "4c30f6405c80fe2cd5f1789838ded06020a50457", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzBmNjQwNWM4MGZlMmNkNWYxNzg5ODM4ZGVkMDYwMjBhNTA0NTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-03T20:15:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-09T22:03:54Z"}, "message": "Move the hack with fake partial resolution for <A>::B from typeck to resolve", "tree": {"sha": "c45797dae51dfe7efcb091f0b7bde9a9c60779a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c45797dae51dfe7efcb091f0b7bde9a9c60779a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c30f6405c80fe2cd5f1789838ded06020a50457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c30f6405c80fe2cd5f1789838ded06020a50457", "html_url": "https://github.com/rust-lang/rust/commit/4c30f6405c80fe2cd5f1789838ded06020a50457", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c30f6405c80fe2cd5f1789838ded06020a50457/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91b9dabdebb95b689d335b98a8890923d9af7f7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b9dabdebb95b689d335b98a8890923d9af7f7e", "html_url": "https://github.com/rust-lang/rust/commit/91b9dabdebb95b689d335b98a8890923d9af7f7e"}], "stats": {"total": 145, "additions": 40, "deletions": 105}, "files": [{"sha": "7d98aab8d27d8699b5def36cdbf625507f1caeb3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4c30f6405c80fe2cd5f1789838ded06020a50457", "patch": "@@ -1238,7 +1238,7 @@ impl<'a> LoweringContext<'a> {\n                             position: position,\n                         }\n                     });\n-                    let rename = if path.segments.len() == 1 {\n+                    let rename = if qself.is_none() && path.segments.len() == 1 {\n                         // Only local variables are renamed\n                         match self.resolver.get_resolution(e.id).map(|d| d.full_def()) {\n                             Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,"}, {"sha": "921a6683069ecea3c3dba1f34047cf360b6eb3f0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 83, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4c30f6405c80fe2cd5f1789838ded06020a50457", "patch": "@@ -38,7 +38,6 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n-use self::AssocItemResolveResult::*;\n use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n@@ -671,15 +670,6 @@ enum ModulePrefixResult<'a> {\n     PrefixFound(Module<'a>, usize),\n }\n \n-#[derive(Copy, Clone)]\n-enum AssocItemResolveResult {\n-    /// Syntax such as `<T>::item`, which can't be resolved until type\n-    /// checking.\n-    TypecheckRequired,\n-    /// We should have been able to resolve the associated item.\n-    ResolveAttempt(Option<PathResolution>),\n-}\n-\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n@@ -2131,24 +2121,12 @@ impl<'a> Resolver<'a> {\n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n             TyKind::Path(ref maybe_qself, ref path) => {\n-                let resolution = match self.resolve_possibly_assoc_item(ty.id,\n-                                                                        maybe_qself.as_ref(),\n-                                                                        path,\n-                                                                        TypeNS) {\n-                    // `<T>::a::b::c` is resolved by typeck alone.\n-                    TypecheckRequired => {\n-                        // Resolve embedded types.\n-                        visit::walk_ty(self, ty);\n-                        return;\n-                    }\n-                    ResolveAttempt(resolution) => resolution,\n-                };\n-\n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                if let Some(def) = resolution {\n+                if let Some(def) = self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(),\n+                                                                    path, TypeNS) {\n                     match def.base_def {\n-                        Def::Mod(..) => {\n+                        Def::Mod(..) if def.depth == 0 => {\n                             self.session.span_err(path.span, \"expected type, found module\");\n                             self.record_def(ty.id, err_path_resolution());\n                         }\n@@ -2281,54 +2259,40 @@ impl<'a> Resolver<'a> {\n                             expected_what: &'static str)\n         where ExpectedFn: FnOnce(Def) -> bool\n     {\n-        let resolution = match self.resolve_possibly_assoc_item(pat_id, qself, path, namespace) {\n-            ResolveAttempt(resolution) => {\n-                if let Some(resolution) = resolution {\n-                    if resolution.depth == 0 {\n-                        if expected_fn(resolution.base_def) {\n-                            resolution\n-                        } else {\n-                            resolve_error(\n-                                self,\n-                                path.span,\n-                                ResolutionError::PatPathUnexpected(expected_what,\n-                                                                   resolution.kind_name(), path)\n-                            );\n-                            err_path_resolution()\n-                        }\n-                    } else {\n-                        // Not fully resolved associated item `T::A::B::C` or\n-                        // `<T as Tr>::A::B::C`. If `C` should be resolved in value\n-                        // namespace then it needs to be added to the trait map.\n-                        if namespace == ValueNS {\n-                            let item_name = path.segments.last().unwrap().identifier.name;\n-                            let traits = self.get_traits_containing_item(item_name);\n-                            self.trait_map.insert(pat_id, traits);\n-                        }\n-                        resolution\n-                    }\n+        let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n+                                                                        qself, path, namespace) {\n+            if resolution.depth == 0 {\n+                if expected_fn(resolution.base_def) {\n+                    resolution\n                 } else {\n-                    if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n-                        resolve_error(\n-                            self,\n-                            path.span,\n-                            ResolutionError::PatPathUnresolved(expected_what, path)\n-                        );\n-                    }\n+                    resolve_error(\n+                        self,\n+                        path.span,\n+                        ResolutionError::PatPathUnexpected(expected_what,\n+                                                           resolution.kind_name(), path)\n+                    );\n                     err_path_resolution()\n                 }\n-            }\n-            TypecheckRequired => {\n-                // `<T>::A::B::C`, resolves exclusively during typechecking.\n-                // If `C` should be resolved in value namespace then it needs\n-                // to be added to the trait map.\n+            } else {\n+                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n+                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n+                // it needs to be added to the trait map.\n                 if namespace == ValueNS {\n                     let item_name = path.segments.last().unwrap().identifier.name;\n                     let traits = self.get_traits_containing_item(item_name);\n                     self.trait_map.insert(pat_id, traits);\n                 }\n-                return;\n+                resolution\n+            }\n+        } else {\n+            if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n+                resolve_error(\n+                    self,\n+                    path.span,\n+                    ResolutionError::PatPathUnresolved(expected_what, path)\n+                );\n             }\n+            err_path_resolution()\n         };\n \n         self.record_def(pat_id, resolution);\n@@ -2444,13 +2408,17 @@ impl<'a> Resolver<'a> {\n                                    maybe_qself: Option<&QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace)\n-                                   -> AssocItemResolveResult {\n+                                   -> Option<PathResolution> {\n         let max_assoc_types;\n \n         match maybe_qself {\n             Some(qself) => {\n                 if qself.position == 0 {\n-                    return TypecheckRequired;\n+                    // FIXME: Create some fake resolution that can't possibly be a type.\n+                    return Some(PathResolution {\n+                        base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n+                        depth: path.segments.len()\n+                    });\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n                 // Make sure the trait is valid.\n@@ -2477,7 +2445,7 @@ impl<'a> Resolver<'a> {\n                 }\n             });\n         }\n-        ResolveAttempt(resolution)\n+        resolution\n     }\n \n     /// Skips `path_depth` trailing segments, which is also reflected in the\n@@ -2826,24 +2794,10 @@ impl<'a> Resolver<'a> {\n         // Next, resolve the node.\n         match expr.node {\n             ExprKind::Path(ref maybe_qself, ref path) => {\n-                let resolution = match self.resolve_possibly_assoc_item(expr.id,\n-                                                                        maybe_qself.as_ref(),\n-                                                                        path,\n-                                                                        ValueNS) {\n-                    // `<T>::a::b::c` is resolved by typeck alone.\n-                    TypecheckRequired => {\n-                        let method_name = path.segments.last().unwrap().identifier.name;\n-                        let traits = self.get_traits_containing_item(method_name);\n-                        self.trait_map.insert(expr.id, traits);\n-                        visit::walk_expr(self, expr);\n-                        return;\n-                    }\n-                    ResolveAttempt(resolution) => resolution,\n-                };\n-\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-                if let Some(path_res) = resolution {\n+                if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n+                                                            maybe_qself.as_ref(), path, ValueNS) {\n                     // Check if struct variant\n                     let is_struct_variant = if let Def::Variant(_, variant_id) = path_res.base_def {\n                         self.structs.contains_key(&variant_id)"}, {"sha": "d492c34a55dbcf76f356c922289e27ea807b9e8c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4c30f6405c80fe2cd5f1789838ded06020a50457", "patch": "@@ -1723,12 +1723,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n                     d\n-                } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n-                    // Create some fake resolution that can't possibly be a type.\n-                    def::PathResolution {\n-                        base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len()\n-                    }\n                 } else {\n                     span_bug!(ast_ty.span, \"unbound path {:?}\", ast_ty)\n                 };"}, {"sha": "c06aa9f14df1eb68a1d2c59b3a866a2e53309f70", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4c30f6405c80fe2cd5f1789838ded06020a50457", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::{self, Def};\n+use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use hir::pat_util::{PatIdMap, pat_id_map};\n use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n@@ -224,13 +224,6 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                     d\n-                } else if qself.position == 0 {\n-                    // This is just a sentinel for finish_resolving_def_to_ty.\n-                    let sentinel = self.tcx.map.local_def_id(ast::CRATE_NODE_ID);\n-                    def::PathResolution {\n-                        base_def: Def::Mod(sentinel),\n-                        depth: path.segments.len()\n-                    }\n                 } else {\n                     debug!(\"unbound path {:?}\", pat);\n                     self.write_error(pat.id);"}, {"sha": "c59401764210caabc17a899c97cf7e25ac968b1c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c30f6405c80fe2cd5f1789838ded06020a50457/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4c30f6405c80fe2cd5f1789838ded06020a50457", "patch": "@@ -3352,13 +3352,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n                   d\n-              } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n-                    // Create some fake resolution that can't possibly be a type.\n-                    def::PathResolution {\n-                        base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len()\n-                    }\n-                } else {\n+              } else {\n                   span_bug!(expr.span, \"unbound path {:?}\", expr)\n               };\n "}]}