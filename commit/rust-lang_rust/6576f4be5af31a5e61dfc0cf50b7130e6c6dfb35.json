{"sha": "6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NzZmNGJlNWFmMzFhNWU2MWRmYzBjZjUwYjcxMzBlNmM2ZGZiMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-22T00:20:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-22T00:20:12Z"}, "message": "Auto merge of #65671 - Centril:rollup-00glhmb, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #62330 (Change untagged_unions to not allow union fields with drop)\n - #65092 (make is_power_of_two a const function)\n - #65621 (miri: add write_bytes method to Memory doing bounds-checks and supporting iterators)\n - #65647 (Remove unnecessary trait bounds and derivations)\n - #65653 (keep the root dir clean from debugging)\n - #65660 (Rename `ConstValue::Infer(InferConst::Canonical(..))` to `ConstValue::Bound(..)`)\n - #65663 (Fix typo from #65214)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2996f7c8eb4fb2727165a36eb2976ecd8fe684a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2996f7c8eb4fb2727165a36eb2976ecd8fe684a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "html_url": "https://github.com/rust-lang/rust/commit/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "html_url": "https://github.com/rust-lang/rust/commit/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07"}, {"sha": "56756c28a03d794b55b9b725758045faf8fe8aed", "url": "https://api.github.com/repos/rust-lang/rust/commits/56756c28a03d794b55b9b725758045faf8fe8aed", "html_url": "https://github.com/rust-lang/rust/commit/56756c28a03d794b55b9b725758045faf8fe8aed"}], "stats": {"total": 1149, "additions": 667, "deletions": 482}, "files": [{"sha": "487867c375d4529a0a7f0e36c6b2207665e174c6", "filename": ".gitignore", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,6 +1,10 @@\n-# This file should only ignore things that are generated during a build,\n-# generated by common IDEs, and optional files controlled by the user\n-# that affect the build (such as config.toml).\n+# This file should only ignore things that are generated during a `x.py` build,\n+# generated by common IDEs, and optional files controlled by the user that\n+# affect the build (such as config.toml).\n+# In particular, things like `mir_dump` should not be listed here; they are only\n+# created during manual debugging and many people like to clean up instead of\n+# having git ignore such leftovers. You can use `.git/info/exclude` to\n+# configure your local ignore list.\n # FIXME: This needs cleanup.\n *~\n .#*\n@@ -52,6 +56,4 @@ config.stamp\n Session.vim\n .cargo\n no_llvm_build\n-# Generated when dumping Graphviz output for debugging:\n-/mir_dump/\n-/*.dot\n+# Before adding new lines, see the comment at the top."}, {"sha": "4310f2c6fa1405902c8ee04fdf068be18dda8226", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -161,7 +161,7 @@ impl Ord for Interned<String> {\n     }\n }\n \n-struct TyIntern<T: Hash + Clone + Eq> {\n+struct TyIntern<T: Clone + Eq> {\n     items: Vec<T>,\n     set: HashMap<T, Interned<T>>,\n }"}, {"sha": "813d7c4bafef8cfdaf779be20dacf71cfc46de35", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -596,30 +596,6 @@ warning: function cannot return without recursing\n   |\n ```\n \n-## unions-with-drop-fields\n-\n-This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![feature(untagged_unions)]\n-\n-union U {\n-    s: String,\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n- --> src/main.rs:4:5\n-  |\n-4 |     s: String,\n-  |     ^^^^^^^^^\n-  |\n-```\n-\n ## unknown-lints\n \n This lint detects unrecognized lint attribute. Some"}, {"sha": "b4ade70414462cd45704c47623b16fb9134751b6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -3757,8 +3757,8 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n-            pub fn is_power_of_two(self) -> bool {\n-                (self.wrapping_sub(1)) & self == 0 && !(self == 0)\n+            pub const fn is_power_of_two(self) -> bool {\n+                self.count_ones() == 1\n             }\n         }\n "}, {"sha": "93274ef0c927cdc1050bdc368710f3d672006fa2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -36,5 +36,5 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.3\""}, {"sha": "0104507f7020ff30b940af4ffe85eaf85492f33e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -35,7 +35,7 @@ impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(PartialEq)]\n pub enum DepNodeColor {\n     Red,\n     Green(DepNodeIndex)"}, {"sha": "d95637c3b986828638e8ea34b1b90cc56d2b2b0f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -599,7 +599,6 @@ macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n     }) => (\n-        #[derive(Clone, Copy, Debug, Hash, RustcEncodable, RustcDecodable)]\n         pub enum GlobalMetaDataKind {\n             $($variant),*\n         }"}, {"sha": "364a8ace1aac434dd08b04403dbe7e0c3b0a5d0a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1077,7 +1077,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1211,7 +1211,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1388,8 +1388,7 @@ impl Body {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1412,8 +1411,7 @@ impl fmt::Display for GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,"}, {"sha": "7ee461a859bd6b4e78f93589f406370110e29602", "filename": "src/librustc/hir/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -11,7 +11,7 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq)]\n+#[derive(PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }"}, {"sha": "49a2c90bdbf603e37bf28edbafbb3c68781892f0", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -468,7 +468,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ConstValue::Infer(InferConst::Fresh(_)) => {\n                 bug!(\"encountered a fresh const during canonicalization\")\n             }\n-            ConstValue::Infer(InferConst::Canonical(debruijn, _)) => {\n+            ConstValue::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n                     bug!(\"escaping bound type during canonicalization\")\n                 } else {\n@@ -700,7 +700,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             let var = self.canonical_var(info, const_var.into());\n             self.tcx().mk_const(\n                 ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(self.binder_index, var.into())),\n+                    val: ConstValue::Bound(self.binder_index, var.into()),\n                     ty: self.fold_ty(const_var.ty),\n                 }\n             )"}, {"sha": "d833feeeb09d615f6187e69300cd2cd4cab17780", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -33,7 +33,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, InferConst, Lift, List, Region, TyCtxt};\n+use crate::ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -73,7 +73,7 @@ pub struct CanonicalVarValues<'tcx> {\n /// various parts of it with canonical variables. This struct stores\n /// those replaced bits to remember for when we process the query\n /// result.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct OriginalQueryValues<'tcx> {\n     /// Map from the universes that appear in the query to the\n     /// universes in the caller context. For the time being, we only\n@@ -510,9 +510,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     GenericArgKind::Const(ct) => {\n                         tcx.mk_const(ty::Const {\n                             ty: ct.ty,\n-                            val: ConstValue::Infer(\n-                                InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from_u32(i))\n-                            ),\n+                            val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n                         }).into()\n                     }\n                 })"}, {"sha": "7ad6006012f49cafecf02430b776414e90ee9f0a", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -26,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::{self, BoundVar, InferConst, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n@@ -493,10 +493,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {\n-                    if let ty::Const {\n-                        val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n-                        ..\n-                    } = result_value {\n+                    if let ty::Const { val: ConstValue::Bound(debrujin, b), .. } = result_value {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "f06dbc72cd9611c71f7ae383813ebca1f55df0a7", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -53,7 +53,7 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo\n }"}, {"sha": "1841bd9ea6423e9a4e3d8c390fa348389275b186", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 return ct;\n             }\n \n-            ConstValue::Infer(ty::InferConst::Canonical(..)) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(_) => {\n                 bug!(\"unexpected const {:?}\", ct)\n             }"}, {"sha": "f4ed7dac1f7c435b55fcea2a988224cdc0185319", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -407,7 +407,7 @@ pub enum RegionVariableOrigin {\n     NLL(NLLRegionVariableOrigin),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub enum NLLRegionVariableOrigin {\n     /// During NLL region processing, we create variables for free\n     /// regions that we encounter in the function signature and"}, {"sha": "64ef0421808f44f29958a7f79ac7d677bf7f6042", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -27,12 +27,12 @@ use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq)]\n pub enum NormalizationStrategy {\n     Lazy,\n     Eager,\n@@ -618,7 +618,7 @@ where\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n             // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n             // so this is probably not correct.\n             self.infcx.super_combine_consts(self, a, b)\n@@ -993,7 +993,7 @@ where\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n \n-        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+        if let ty::Const { val: ConstValue::Bound(..), .. } = a {\n             bug!(\n                 \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                 a"}, {"sha": "8c6a7c9a376a79900eabcada996a0681fce73777", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -116,7 +116,7 @@ pub struct RegionConstraintData<'tcx> {\n }\n \n /// Represents a constraint that influences the inference process.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n     /// A region variable is a subregion of another.\n     VarSubVar(RegionVid, RegionVid),"}, {"sha": "3b0ac9ada8f65894e7cc52fbcbd6f0c73e3fd6fa", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -43,6 +43,7 @@\n #![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n+#![feature(option_expect_none)]\n #![feature(range_is_empty)]\n #![feature(slice_patterns)]\n #![feature(specialization)]"}, {"sha": "ec1e32988a607b4d0a3ac041a9b82ec8a7aea006", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -117,7 +117,7 @@ pub struct NativeLibrary {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,"}, {"sha": "cbf336fdbe2f3cd69627c81f94a8f689644e2a6e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -102,7 +102,7 @@ pub struct Upvar {\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n pub enum PointerKind<'tcx> {\n     /// `Box<T>`\n     Unique,\n@@ -116,7 +116,7 @@ pub enum PointerKind<'tcx> {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g., a field\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq)]\n pub enum InteriorKind {\n     InteriorField(FieldIndex),\n     InteriorElement(InteriorOffsetKind),\n@@ -139,13 +139,13 @@ impl Hash for FieldIndex {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum InteriorOffsetKind {\n     Index,   // e.g., `array_expr[index_expr]`\n     Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable."}, {"sha": "e65f17c79497e169c6375153ba836883c1183ce7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -25,7 +25,7 @@ use crate::util::nodemap::{FxHashSet, FxHashMap};\n use std::mem::replace;\n use std::cmp::Ordering;\n \n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n+#[derive(PartialEq, Clone, Copy, Debug)]\n pub enum StabilityLevel {\n     Unstable,\n     Stable,"}, {"sha": "796d293e2c63cb72c1e05c32ed6c3a6618ef819b", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -245,6 +245,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     #[inline]\n     pub fn get_bytes(\n         &self,\n@@ -275,6 +277,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// so be sure to actually put data there!\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n+    /// on `InterpCx` instead.\n     pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -297,6 +301,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n+    ///\n+    /// Most likely, you want to call `Memory::read_c_str` instead of this method.\n     pub fn read_c_str(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -342,33 +348,22 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `Memory::write_bytes` instead of this method.\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-        src: &[u8],\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n     ) -> InterpResult<'tcx>\n     {\n+        let mut src = src.into_iter();\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n-        bytes.clone_from_slice(src);\n-        Ok(())\n-    }\n-\n-    /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    pub fn write_repeat(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        val: u8,\n-        count: Size\n-    ) -> InterpResult<'tcx>\n-    {\n-        let bytes = self.get_bytes_mut(cx, ptr, count)?;\n-        for b in bytes {\n-            *b = val;\n+        // `zip` would stop when the first iterator ends; we want to definitely\n+        // cover all of `bytes`.\n+        for dest in bytes {\n+            *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n         }\n+        src.next().expect_none(\"iterator was longer than it said it would be\");\n         Ok(())\n     }\n \n@@ -380,6 +375,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -418,6 +414,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n     pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -435,6 +432,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -477,6 +475,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n+    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n     pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "ac16b8b884c450f9b51b8729e2c051087d056b84", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -5,11 +5,12 @@ use rustc_apfloat::{Float, ieee::{Double, Single}};\n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n+use crate::ty::{BoundVar, DebruijnIndex};\n \n use super::{InterpResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents the result of a raw const operation, pre-validation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Clone, HashStable)]\n pub struct RawConst<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n@@ -28,6 +29,9 @@ pub enum ConstValue<'tcx> {\n     /// Infer the value of the const.\n     Infer(InferConst<'tcx>),\n \n+    /// Bound const variable, used only when preparing a trait query.\n+    Bound(DebruijnIndex, BoundVar),\n+\n     /// A placeholder const - universally quantified higher-ranked const.\n     Placeholder(PlaceholderConst),\n \n@@ -66,8 +70,9 @@ impl<'tcx> ConstValue<'tcx> {\n         match *self {\n             ConstValue::Param(_) |\n             ConstValue::Infer(_) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(_) |\n-            ConstValue::ByRef{ .. } |\n+            ConstValue::ByRef { .. } |\n             ConstValue::Unevaluated(..) |\n             ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n@@ -487,7 +492,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,"}, {"sha": "ccf64c51e133041167bd61955d1195720d42fe09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -468,7 +468,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceInfo {\n     /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -608,7 +608,7 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n@@ -630,7 +630,7 @@ pub struct VarBindingForm<'tcx> {\n     pub pat_span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n     Var(VarBindingForm<'tcx>),\n@@ -641,7 +641,7 @@ pub enum BindingForm<'tcx> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2392,7 +2392,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2438,7 +2438,7 @@ pub struct Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjections {\n     pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n }\n@@ -2515,7 +2515,7 @@ impl<'tcx> UserTypeProjections {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,\n@@ -2724,7 +2724,7 @@ impl Location {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n@@ -2733,15 +2733,15 @@ pub enum UnsafetyViolationKind {\n     BorrowPacked(hir::HirId),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub description: InternedString,\n     pub details: InternedString,\n     pub kind: UnsafetyViolationKind,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,"}, {"sha": "eeb997d75ca55c084f32ebef7ad7917e1b99eca4", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -15,7 +15,7 @@ use std::fmt;\n use std::hash::Hash;\n \n /// Describes how a monomorphization will be instantiated in object files.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+#[derive(PartialEq)]\n pub enum InstantiationMode {\n     /// There will be exactly one instance of the given MonoItem. It will have\n     /// external linkage so that it can be linked to from other codegen units.\n@@ -251,7 +251,7 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,\n@@ -280,7 +280,7 @@ impl_stable_hash_for!(enum self::Linkage {\n     Common\n });\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum Visibility {\n     Default,\n     Hidden,"}, {"sha": "427540d72758e257f263cfcb57dd6212f0837034", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -947,7 +947,7 @@ impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting."}, {"sha": "2446d4f4788df8035ab8d7cd41b892678d7b1243", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -62,7 +62,7 @@ impl_stable_hash_via_hash!(OptLevel);\n \n /// This is what the `LtoCli` values get mapped to after resolving defaults and\n /// and taking other command line options into account.\n-#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+#[derive(Clone, PartialEq)]\n pub enum Lto {\n     /// Don't do any LTO whatsoever\n     No,\n@@ -296,10 +296,10 @@ impl OutputTypes {\n /// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n /// *Do not* switch `BTreeMap` or `BTreeSet` out for an unsorted container type! That\n /// would break dependency tracking for command-line arguments.\n-#[derive(Clone, Hash)]\n+#[derive(Clone)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n-#[derive(Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug, Default)]\n+#[derive(Clone, Debug, Default)]\n pub struct ExternEntry {\n     pub locations: BTreeSet<Option<String>>,\n     pub is_private_dep: bool\n@@ -459,7 +459,7 @@ pub enum PrintRequest {\n     NativeStaticLibs,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone)]\n pub enum BorrowckMode {\n     Mir,\n     Migrate,"}, {"sha": "949dad751a101f69c3d1a8c9cddedc14df31f507", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,5 +1,4 @@\n use std::path::{Path, PathBuf};\n-use rustc_macros::HashStable;\n use crate::session::{early_error, config};\n use crate::session::filesearch::make_target_lib_path;\n \n@@ -10,7 +9,7 @@ pub struct SearchPath {\n     pub files: Vec<PathBuf>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(PartialEq, Clone, Copy, Debug, HashStable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "f6ea77dc5cc684562944f209750988f6cbcd7135", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -40,7 +40,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;"}, {"sha": "7aa98703411b28e2881a5b962d448160e393055c", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Clone, Debug)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n     pub ty: Ty<'tcx>,\n }"}, {"sha": "5570144489cdf315bfb783698df01ab386adab05", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -2,7 +2,7 @@ use crate::hir::BindingAnnotation::*;\n use crate::hir::BindingAnnotation;\n use crate::hir::Mutability;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BindingMode {\n     BindByReference(Mutability),\n     BindByValue(Mutability),"}, {"sha": "d118bef37fc119e79475dbaedae51bd3fb0a4455", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -827,7 +827,7 @@ rustc_index::newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -882,7 +882,7 @@ impl CanonicalUserType<'tcx> {\n                         },\n \n                         GenericArgKind::Const(ct) => match ct.val {\n-                            ConstValue::Infer(InferConst::Canonical(debruijn, b)) => {\n+                            ConstValue::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n                                 cvar == b\n@@ -899,7 +899,7 @@ impl CanonicalUserType<'tcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "3395715f67ff98424a8d4874629ec76be93f1c17", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -51,7 +51,6 @@ pub enum TypeError<'tcx> {\n     IntrinsicCast,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum UnconstrainedNumeric {\n     UnconstrainedFloat,\n     UnconstrainedInt,"}, {"sha": "27a09b394b8fa32b8923140e5ff6f2219fad90fc", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -19,7 +19,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// the non-stable but fast to construct DefId-version is the better choice.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum SimplifiedTypeGen<D>\n-    where D: Copy + Debug + Ord + Eq + Hash\n+    where D: Copy + Debug + Ord + Eq\n {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n@@ -123,10 +123,10 @@ pub fn simplify_type(\n     }\n }\n \n-impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n+impl<D: Copy + Debug + Ord + Eq> SimplifiedTypeGen<D> {\n     pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n         where F: Fn(D) -> U,\n-              U: Copy + Debug + Ord + Eq + Hash,\n+              U: Copy + Debug + Ord + Eq,\n     {\n         match self {\n             BoolSimplifiedType => BoolSimplifiedType,\n@@ -155,7 +155,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n \n impl<'a, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n where\n-    D: Copy + Debug + Ord + Eq + Hash + HashStable<StableHashingContext<'a>>,\n+    D: Copy + Debug + Ord + Eq + HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "cb1fb4f685de57853fa775241e1f97acaca3fd55", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -240,10 +240,10 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);\n                 match infer {\n                     InferConst::Fresh(_) => {}\n-                    InferConst::Canonical(debruijn, _) => self.add_binder(debruijn),\n                     InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n                 }\n             }\n+            ConstValue::Bound(debruijn, _) => self.add_binder(debruijn),\n             ConstValue::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_PARAMS);\n             }"}, {"sha": "bacf3d42f043130fd47b040df8f40720ba5710a9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -521,10 +521,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n-            ty,\n-        } = *ct {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_const), ty } = *ct {\n             if debruijn == self.current_index {\n                 let fld_c = &mut self.fld_c;\n                 let ct = fld_c(bound_const, ty);\n@@ -570,7 +567,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         // identity for bound types and consts\n         let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n         let fld_c = |bound_ct, ty| {\n-            self.mk_const_infer(ty::InferConst::Canonical(ty::INNERMOST, bound_ct), ty)\n+            self.mk_const(ty::Const {\n+                val: ConstValue::Bound(ty::INNERMOST, bound_ct),\n+                ty,\n+            })\n         };\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n@@ -721,7 +721,6 @@ impl<'tcx> TyCtxt<'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n enum Direction {\n     In,\n     Out,\n@@ -802,10 +801,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n-            ty,\n-        } = *ct {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_ct), ty } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n@@ -816,7 +812,10 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                         debruijn.shifted_out(self.amount)\n                     }\n                 };\n-                self.tcx.mk_const_infer(ty::InferConst::Canonical(debruijn, bound_const), ty)\n+                self.tcx.mk_const(ty::Const {\n+                    val: ConstValue::Bound(debruijn, bound_ct),\n+                    ty,\n+                })\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -920,8 +919,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // const, as it has types/regions embedded in a lot of other\n         // places.\n         match ct.val {\n-            ConstValue::Infer(ty::InferConst::Canonical(debruijn, _))\n-                if debruijn >= self.outer_index => true,\n+            ConstValue::Bound(debruijn, _) if debruijn >= self.outer_index => true,\n             _ => ct.super_visit_with(self),\n         }\n     }"}, {"sha": "d377b7328e80b1d2a4e8f4b2b8c2d3f7201a95e5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -159,7 +159,7 @@ impl AssocItemContainer {\n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n /// bounds / where-clauses).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ImplHeader<'tcx> {\n     pub impl_def_id: DefId,\n     pub self_ty: Ty<'tcx>,\n@@ -195,7 +195,7 @@ pub struct AssocItem {\n     pub method_has_self_argument: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum AssocKind {\n     Const,\n     Method,\n@@ -331,7 +331,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcDecodable, RustcEncodable, HashStable)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -752,7 +752,7 @@ pub struct UpvarId {\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,"}, {"sha": "f61801cd23276b86e2be67ba2751b7a46310bbaf", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -8,14 +8,12 @@ use crate::ty::subst::SubstsRef;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::mir;\n \n-use std::fmt::Debug;\n-use std::hash::Hash;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n-pub(super) trait Key: Clone + Hash + Eq + Debug {\n+pub(super) trait Key {\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate(&self) -> CrateNum;\n@@ -201,10 +199,7 @@ impl Key for InternedString {\n \n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n-impl<'tcx, T> Key for Canonical<'tcx, T>\n-where\n-    T: Debug + Hash + Clone + Eq,\n-{\n+impl<'tcx, T> Key for Canonical<'tcx, T> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "41b4883793b5414c8c4f319814abd84c62192f6e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -801,7 +801,7 @@ macro_rules! define_queries_inner {\n         }\n \n         #[allow(nonstandard_style)]\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+        #[derive(Clone, Copy)]\n         pub enum QueryName {\n             $($name),*\n         }\n@@ -819,7 +819,7 @@ macro_rules! define_queries_inner {\n         }\n \n         #[allow(nonstandard_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+        #[derive(Clone, Debug)]\n         pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }"}, {"sha": "6b1f10bdb21c46f9ed84308ee122f76ba2594243", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1379,27 +1379,23 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef { alloc, offset } =>\n-                ConstValue::ByRef { alloc, offset },\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n-            ConstValue::Placeholder(p) => ConstValue::Placeholder(p),\n-            ConstValue::Scalar(a) => ConstValue::Scalar(a),\n-            ConstValue::Slice { data, start, end } => ConstValue::Slice { data, start, end },\n             ConstValue::Unevaluated(did, substs)\n                 => ConstValue::Unevaluated(did, substs.fold_with(folder)),\n+            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(..)\n+            | ConstValue::Scalar(..) | ConstValue::Slice { .. } => *self,\n+\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstValue::ByRef { .. } => false,\n             ConstValue::Infer(ic) => ic.visit_with(visitor),\n             ConstValue::Param(p) => p.visit_with(visitor),\n-            ConstValue::Placeholder(_) => false,\n-            ConstValue::Scalar(_) => false,\n-            ConstValue::Slice { .. } => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n+            ConstValue::ByRef { .. } | ConstValue::Bound(..) | ConstValue::Placeholder(_)\n+            | ConstValue::Scalar(_) | ConstValue::Slice { .. } => false,\n         }\n     }\n }"}, {"sha": "298e798959635ef5c7275a768f4d6d02c5677052", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -304,8 +304,7 @@ static_assert_size!(TyKind<'_>, 24);\n /// type parameters is similar, but the role of CK and CS are\n /// different. CK represents the \"yield type\" and CS represents the\n /// \"return type\" of the generator.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n-         RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n@@ -392,8 +391,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n }\n \n /// Similar to `ClosureSubsts`; see the above documentation for more.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n-         RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -1035,7 +1033,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug)]\n pub struct GenSig<'tcx> {\n     pub yield_ty: Ty<'tcx>,\n     pub return_ty: Ty<'tcx>,\n@@ -2373,6 +2371,4 @@ pub enum InferConst<'tcx> {\n     Var(ConstVid<'tcx>),\n     /// A fresh const variable. See `infer::freshen` for more details.\n     Fresh(u32),\n-    /// Canonicalized const variable, used only when preparing a trait query.\n-    Canonical(DebruijnIndex, BoundVar),\n }"}, {"sha": "29721979099d59e0c7635b92f5a8d3a936e6cf19", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -2,7 +2,7 @@\n \n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::ty::{self, Lift, List, Ty, TyCtxt, InferConst, ParamConst};\n+use crate::ty::{self, Lift, List, Ty, TyCtxt, ParamConst};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::mir::interpret::ConstValue;\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -234,9 +234,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n                 ty::GenericParamDefKind::Const => {\n                     tcx.mk_const(ty::Const {\n-                        val: ConstValue::Infer(\n-                            InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from(param.index))\n-                        ),\n+                        val: ConstValue::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n                         ty: tcx.type_of(def_id),\n                     }).into()\n                 }"}, {"sha": "5555dace45bfa63e750d01875875fc367ad86f2d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -818,6 +818,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n+    ///\n+    /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0"}, {"sha": "c69942ef3f2d52fd18c0c3abdc49c153212a5d04", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -50,7 +50,7 @@ pub enum CallConv {\n }\n \n /// LLVMRustLinkage\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq)]\n #[repr(C)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n@@ -67,7 +67,6 @@ pub enum Linkage {\n }\n \n // LLVMRustVisibility\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[repr(C)]\n pub enum Visibility {\n     Default = 0,"}, {"sha": "ba5e47aeede1b36f8a355f8309848f7c53f82e48", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -79,6 +79,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             ConstValue::Unevaluated(..) => bug!(\"unevaluated constant in `OperandRef::from_const`\"),\n             ConstValue::Param(_) => bug!(\"encountered a ConstValue::Param in codegen\"),\n             ConstValue::Infer(_) => bug!(\"encountered a ConstValue::Infer in codegen\"),\n+            ConstValue::Bound(..) => bug!(\"encountered a ConstValue::Bound in codegen\"),\n             ConstValue::Placeholder(_) => bug!(\"encountered a ConstValue::Placeholder in codegen\"),\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {"}, {"sha": "9fdcea6df88c59a7a865a68d7d38051661be5a3a", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -60,10 +60,10 @@ impl<N> SnapshotVecDelegate for Edge<N> {\n     fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct NodeIndex(pub usize);\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct EdgeIndex(pub usize);\n \n pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);"}, {"sha": "2f972eeccdcbd2494477483ea16c3ba14abf4b8d", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -90,7 +90,7 @@ impl<T> Sharded<T> {\n \n pub type ShardedHashMap<K, V> = Sharded<FxHashMap<K, V>>;\n \n-impl<K: Eq + Hash, V> ShardedHashMap<K, V> {\n+impl<K: Eq, V> ShardedHashMap<K, V> {\n     pub fn len(&self) -> usize {\n         self.lock_shards().iter().map(|shard| shard.len()).sum()\n     }"}, {"sha": "bdd3dc9665629a5af94a362ce3b08b53c24f110e", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -7,7 +7,7 @@ use std::mem;\n mod tests;\n \n pub struct SnapshotMap<K, V>\n-    where K: Hash + Clone + Eq\n+    where K: Clone + Eq\n {\n     map: FxHashMap<K, V>,\n     undo_log: Vec<UndoLog<K, V>>,"}, {"sha": "092208cfe1db74d6c3ff2ed525d6f31f3042ced1", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -169,7 +169,7 @@ pub trait HashStable<CTX> {\n /// example, for DefId that can be converted to a DefPathHash. This is used for\n /// bringing maps into a predictable order before hashing them.\n pub trait ToStableHashKey<HCX> {\n-    type KeyType: Ord + Clone + Sized + HashStable<HCX>;\n+    type KeyType: Ord + Sized + HashStable<HCX>;\n     fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType;\n }\n \n@@ -460,7 +460,7 @@ impl_stable_hash_via_hash!(::std::path::Path);\n impl_stable_hash_via_hash!(::std::path::PathBuf);\n \n impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n-    where K: ToStableHashKey<HCX> + Eq + Hash,\n+    where K: ToStableHashKey<HCX> + Eq,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n {\n@@ -471,7 +471,7 @@ impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n }\n \n impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n-    where K: ToStableHashKey<HCX> + Eq + Hash,\n+    where K: ToStableHashKey<HCX> + Eq,\n           R: BuildHasher,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n@@ -513,10 +513,10 @@ pub fn hash_stable_hashmap<HCX, K, V, R, SK, F>(\n     hasher: &mut StableHasher,\n     map: &::std::collections::HashMap<K, V, R>,\n     to_stable_hash_key: F)\n-    where K: Eq + Hash,\n+    where K: Eq,\n           V: HashStable<HCX>,\n           R: BuildHasher,\n-          SK: HashStable<HCX> + Ord + Clone,\n+          SK: HashStable<HCX> + Ord,\n           F: Fn(&K, &HCX) -> SK,\n {\n     let mut entries: Vec<_> = map.iter()"}, {"sha": "f09474ff4d344a8c37f801b09cd9b2de1f42d60a", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -738,7 +738,7 @@ impl<T: Clone> Clone for RwLock<T> {\n \n /// A type which only allows its inner value to be used in one thread.\n /// It will panic if it is used on multiple threads.\n-#[derive(Copy, Clone, Hash, Debug, Eq, PartialEq)]\n+#[derive(Debug)]\n pub struct OneThread<T> {\n     #[cfg(parallel_compiler)]\n     thread: thread::ThreadId,"}, {"sha": "d97da489db8df88d11bc900dda5c8d2f51796a37", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -3,7 +3,7 @@ use crate::stable_hasher::{StableHasher, HashStable};\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n \n impl<T> ThinVec<T> {"}, {"sha": "371f0f6fa0b4482eb35b3d4c5ddf3c2b832027d3", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -14,7 +14,7 @@\n #[cfg(test)]\n mod tests;\n \n-#[derive(Clone, Hash, Debug, PartialEq)]\n+#[derive(Clone)]\n pub struct TinyList<T: PartialEq> {\n     head: Option<Element<T>>\n }\n@@ -80,7 +80,7 @@ impl<T: PartialEq> TinyList<T> {\n     }\n }\n \n-#[derive(Clone, Hash, Debug, PartialEq)]\n+#[derive(Clone)]\n struct Element<T: PartialEq> {\n     data: T,\n     next: Option<Box<Element<T>>>,"}, {"sha": "a3926c15551728c996aff3b75d3a1abd0eb3093a", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -11,7 +11,7 @@ use std::mem;\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n+pub struct TransitiveRelation<T: Eq + Hash> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n \n@@ -35,7 +35,7 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n }\n \n // HACK(eddyb) manual impl avoids `Default` bound on `T`.\n-impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n+impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     fn default() -> Self {\n         TransitiveRelation {\n             elements: Default::default(),\n@@ -46,7 +46,7 @@ impl<T: Clone + Debug + Eq + Hash> Default for TransitiveRelation<T> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, RustcEncodable, RustcDecodable, Debug)]\n struct Index(usize);\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "5d9a97cc21eefe2302b82deec42e768e892e00ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -980,35 +980,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     }\n }\n \n-declare_lint! {\n-    UNIONS_WITH_DROP_FIELDS,\n-    Warn,\n-    \"use of unions that contain fields with possibly non-trivial drop code\"\n-}\n-\n-declare_lint_pass!(\n-    /// Lint for unions that contain fields with possibly non-trivial destructors.\n-    UnionsWithDropFields => [UNIONS_WITH_DROP_FIELDS]\n-);\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n-    fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if let hir::ItemKind::Union(ref vdata, _) = item.kind {\n-            for field in vdata.fields() {\n-                let field_ty = ctx.tcx.type_of(\n-                    ctx.tcx.hir().local_def_id(field.hir_id));\n-                if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n-                    ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n-                                  field.span,\n-                                  \"union contains a field with possibly non-trivial drop code, \\\n-                                   drop code of union fields is ignored when dropping the union\");\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     pub UNREACHABLE_PUB,\n     Allow,\n@@ -1288,7 +1259,6 @@ declare_lint_pass!(\n         NO_MANGLE_GENERIC_ITEMS,\n         MUTABLE_TRANSMUTES,\n         UNSTABLE_FEATURES,\n-        UNIONS_WITH_DROP_FIELDS,\n         UNREACHABLE_PUB,\n         TYPE_ALIAS_BOUNDS,\n         TRIVIAL_BOUNDS"}, {"sha": "f83755181f82e9c37232ceff2556dcbff0e02890", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -164,9 +164,6 @@ macro_rules! late_lint_mod_passes {\n             // Depends on referenced function signatures in expressions\n             MutableTransmutes: MutableTransmutes,\n \n-            // Depends on types of fields, checks if they implement Drop\n-            UnionsWithDropFields: UnionsWithDropFields,\n-\n             TypeAliasBounds: TypeAliasBounds,\n \n             TrivialConstraints: TrivialConstraints,"}, {"sha": "8a242b7ee25ba861beb07b0131e8cd4a9d0f1c0e", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -71,7 +71,7 @@ impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct OutlivesConstraint {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the"}, {"sha": "75213d30982f9a833e936d28cec1537e32a1d611", "filename": "src/librustc_mir/borrow_check/nll/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmember_constraints.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -11,7 +11,7 @@ use syntax_pos::Span;\n /// indexed by the region `R0`.\n crate struct MemberConstraintSet<'tcx, R>\n where\n-    R: Copy + Hash + Eq,\n+    R: Copy + Eq,\n {\n     /// Stores the first \"member\" constraint for a given `R0`. This is an\n     /// index into the `constraints` vector below.\n@@ -191,7 +191,7 @@ where\n \n impl<'tcx, R> Index<NllMemberConstraintIndex> for MemberConstraintSet<'tcx, R>\n where\n-    R: Copy + Hash + Eq,\n+    R: Copy + Eq,\n {\n     type Output = NllMemberConstraint<'tcx>;\n "}, {"sha": "7a86536573dcf5f7728e67282211019c981791ea", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -129,7 +129,7 @@ rustc_index::newtype_index! {\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug)]\n crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),"}, {"sha": "fd1f333010adc4b716554683b6d0f70ea6467500", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -146,7 +146,7 @@ struct UniversalRegionIndices<'tcx> {\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialEq)]\n pub enum RegionClassification {\n     /// A **global** region is one that can be named from\n     /// anywhere. There is only one, `'static`."}, {"sha": "2ab7c41bb787e0e4e56d1d305df94687db0fc5de", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -91,7 +91,7 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     pub extra: Extra,\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -113,7 +113,7 @@ pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n }\n \n /// Current value of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,"}, {"sha": "eef1868ec65b69574d6d5af3a1cc3d7e5915760b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -7,7 +7,7 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::ptr;\n+use std::{ptr, iter};\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n@@ -22,7 +22,7 @@ use super::{\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n };\n \n-#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+#[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n@@ -785,6 +785,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n     }\n \n+    /// Writes the given stream of bytes into memory.\n+    ///\n+    /// Performs appropriate bounds checks.\n+    pub fn write_bytes(\n+        &mut self,\n+        ptr: Scalar<M::PointerTag>,\n+        src: impl IntoIterator<Item=u8, IntoIter: iter::ExactSizeIterator>,\n+    ) -> InterpResult<'tcx>\n+    {\n+        let src = src.into_iter();\n+        let size = Size::from_bytes(src.len() as u64);\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n+        let tcx = self.tcx.tcx;\n+        self.get_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+    }\n+\n     /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,"}, {"sha": "4fd5e6a5435517742aa728c558b637ecaf137397", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -26,7 +26,7 @@ pub use rustc::mir::interpret::ScalarMaybeUndef;\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Immediate<Tag=(), Id=AllocId> {\n     Scalar(ScalarMaybeUndef<Tag, Id>),\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n@@ -123,7 +123,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Operand<Tag=(), Id=AllocId> {\n     Immediate(Immediate<Tag, Id>),\n     Indirect(MemPlace<Tag, Id>),\n@@ -153,7 +153,7 @@ impl<Tag> Operand<Tag> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct OpTy<'tcx, Tag=()> {\n     op: Operand<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n@@ -589,8 +589,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n                 Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             },\n-            ConstValue::Scalar(x) =>\n-                Operand::Immediate(tag_scalar(x).into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x).into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n@@ -606,6 +605,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ConstValue::Param(..) |\n             ConstValue::Infer(..) |\n+            ConstValue::Bound(..) |\n             ConstValue::Placeholder(..) |\n             ConstValue::Unevaluated(..) =>\n                 bug!(\"eval_const_to_op: Unexpected ConstValue {:?}\", val),"}, {"sha": "5e31b80bec6d3d5a6f87ce2cd6841ffdfa94da1c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -199,7 +199,7 @@ use rustc_data_structures::sync::{MTRef, MTLock, ParallelIterator, par_iter};\n \n use std::iter;\n \n-#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n+#[derive(PartialEq)]\n pub enum MonoItemCollectionMode {\n     Eager,\n     Lazy"}, {"sha": "d91588db1834fa59184cd8129d17e60766566a60", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -71,8 +71,7 @@ mod riscv_base;\n mod wasm32_base;\n mod vxworks_base;\n \n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum LinkerFlavor {\n     Em,\n     Gcc,\n@@ -82,8 +81,7 @@ pub enum LinkerFlavor {\n     PtxLinker,\n }\n \n-#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum LldFlavor {\n     Wasm,\n     Ld64,"}, {"sha": "8d136a1b65c79504ec1b91f9153193b8a703fd4c", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -33,7 +33,7 @@ use rustc::traits::{\n     InEnvironment,\n     ChalkCanonicalGoal,\n };\n-use rustc::ty::{self, TyCtxt, InferConst};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{GenericArg, GenericArgKind};\n@@ -286,7 +286,7 @@ impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n                     _ => false,\n                 },\n                 GenericArgKind::Const(ct) => match ct.val {\n-                    ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)) => {\n+                    ConstValue::Bound(debruijn, bound_ct) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == bound_ct\n                     }"}, {"sha": "49d76681196af6db5f1b6a7a1343e65a7878a5e0", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -16,7 +16,7 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n-use rustc::ty::{self, Ty, TyCtxt, InferConst};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::GenericArg;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::mir::interpret::ConstValue;\n@@ -287,10 +287,7 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const {\n-            val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n-            ..\n-        } = a {\n+        if let ty::Const { val: ConstValue::Bound(debruijn, bound_ct), .. } = a {\n             if *debruijn == self.binder_index {\n                 self.unify_free_answer_var(*bound_ct, b.into())?;\n                 return Ok(b);\n@@ -299,14 +296,8 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n \n         match (a, b) {\n             (\n-                ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(a_debruijn, a_bound)),\n-                    ..\n-                },\n-                ty::Const {\n-                    val: ConstValue::Infer(InferConst::Canonical(b_debruijn, b_bound)),\n-                    ..\n-                },\n+                ty::Const { val: ConstValue::Bound(a_debruijn, a_bound), .. },\n+                ty::Const { val: ConstValue::Bound(b_debruijn, b_bound), .. },\n             ) => {\n                 assert_eq!(a_debruijn, b_debruijn);\n                 assert_eq!(a_bound, b_bound);"}, {"sha": "73a025182a7e338ae9854f37b31aa0190095e62d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1387,9 +1387,37 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n     check_transparent(tcx, span, def_id);\n+    check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def_id);\n }\n \n+/// When the `#![feature(untagged_unions)]` gate is active,\n+/// check that the fields of the `union` does not contain fields that need dropping.\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n+    let item_type = tcx.type_of(item_def_id);\n+    if let ty::Adt(def, substs) = item_type.kind {\n+        assert!(def.is_union());\n+        let fields = &def.non_enum_variant().fields;\n+        for field in fields {\n+            let field_ty = field.ty(tcx, substs);\n+            // We are currently checking the type this field came from, so it must be local.\n+            let field_span = tcx.hir().span_if_local(field.did).unwrap();\n+            let param_env = tcx.param_env(field.did);\n+            if field_ty.needs_drop(tcx, param_env) {\n+                struct_span_err!(tcx.sess, field_span, E0740,\n+                                    \"unions may not contain fields that need dropping\")\n+                            .span_note(field_span,\n+                                        \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n+                            .emit();\n+                return false;\n+            }\n+        }\n+    } else {\n+        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind);\n+    }\n+    return true;\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>("}, {"sha": "3ecbf620cbc7b9068d956b2a355b924f47f9c10c", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -4863,6 +4863,10 @@ assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n ```\n \"##,\n \n+E0740: r##\"\n+A `union` cannot have fields with destructors.\n+\"##,\n+\n E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n "}, {"sha": "09c9757dc4d07dd08d14fa75d52b6aaffb04d6ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1307,7 +1307,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, Debug)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n@@ -1589,7 +1589,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n }\n \n // maybe use a Generic enum and use Vec<Generic>?\n-#[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n+#[derive(Clone, Debug, Default)]\n pub struct Generics {\n     pub params: Vec<GenericParamDef>,\n     pub where_predicates: Vec<WherePredicate>,\n@@ -3847,7 +3847,7 @@ impl Clean<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Copy, Debug, Hash)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -4506,7 +4506,6 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>\n }\n \n-#[derive(Eq, PartialEq, Hash, Debug)]\n enum SimpleBound {\n     TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n     Outlives(Lifetime),"}, {"sha": "f2e9be14c8d12ed4198240ab7a7d8898fef0f527", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -143,7 +143,7 @@ impl<T> Decodable for BTreeSet<T>\n }\n \n impl<K, V, S> Encodable for HashMap<K, V, S>\n-    where K: Encodable + Hash + Eq,\n+    where K: Encodable + Eq,\n           V: Encodable,\n           S: BuildHasher,\n {\n@@ -180,7 +180,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n }\n \n impl<T, S> Encodable for HashSet<T, S>\n-    where T: Encodable + Hash + Eq,\n+    where T: Encodable + Eq,\n           S: BuildHasher,\n {\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {"}, {"sha": "93d3e4ea3df228a33fefc5534065897a8abcb5fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -275,6 +275,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(log_syntax)]\n+#![feature(manually_drop_take)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]"}, {"sha": "577673b7e405b6e3e3de3e86f6636823e366aaed", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -264,7 +264,7 @@ impl RefUnwindSafe for atomic::AtomicI128 {}\n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_hastarget_has_atomic_load_store_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU8 {}\n #[cfg(target_has_atomic_load_store = \"16\")]"}, {"sha": "2dde81bb0ecd48bc4681e1fc99a292bb9cfc0eaa", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -12,8 +12,7 @@ use core::panic::{BoxMeUp, PanicInfo, Location};\n use crate::any::Any;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem;\n-use crate::ptr;\n+use crate::mem::{self, ManuallyDrop};\n use crate::raw;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n@@ -227,10 +226,9 @@ pub use realstd::rt::update_panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n-    #[allow(unions_with_drop_fields)]\n     union Data<F, R> {\n-        f: F,\n-        r: R,\n+        f: ManuallyDrop<F>,\n+        r: ManuallyDrop<R>,\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n@@ -261,7 +259,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     let mut any_data = 0;\n     let mut any_vtable = 0;\n     let mut data = Data {\n-        f,\n+        f: ManuallyDrop::new(f)\n     };\n \n     let r = __rust_maybe_catch_panic(do_call::<F, R>,\n@@ -271,7 +269,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n \n     return if r == 0 {\n         debug_assert!(update_panic_count(0) == 0);\n-        Ok(data.r)\n+        Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n         update_panic_count(-1);\n         debug_assert!(update_panic_count(0) == 0);\n@@ -284,8 +282,9 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;\n-            let f = ptr::read(&mut (*data).f);\n-            ptr::write(&mut (*data).r, f());\n+            let data = &mut (*data);\n+            let f = ManuallyDrop::take(&mut data.f);\n+            data.r = ManuallyDrop::new(f());\n         }\n     }\n }"}, {"sha": "8be7f4478fa09c0c6ffd415d153d2b651d39df21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1305,7 +1305,7 @@ impl MacroDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n     Cooked,\n@@ -1327,7 +1327,7 @@ pub struct Lit {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LitIntType {\n     Signed(IntTy),\n     Unsigned(UintTy),\n@@ -1337,7 +1337,7 @@ pub enum LitIntType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),"}, {"sha": "84c86c9651fcf4a501d4e9e35f144133283b3354", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -84,15 +84,15 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum OptimizeAttr {\n     None,\n     Speed,\n@@ -624,8 +624,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n     }\n }\n \n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, Clone)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     pub note: Option<Symbol>,\n@@ -749,7 +748,7 @@ pub enum ReprAttr {\n     ReprAlign(u32),\n }\n \n-#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+#[derive(Eq, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "d987dc855b6156ec8c7ae2fbdd272167a1c47540", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -35,7 +35,6 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n /// An owned smart pointer.\n-#[derive(Hash, PartialEq, Eq)]\n pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }"}, {"sha": "a1d147637e27e82379948bbbb3550b1d300c35a2", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -41,7 +41,7 @@ pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,"}, {"sha": "d0f790638efa3afd5ca07ffc3db8c7ce3c3c0c1f", "filename": "src/libsyntax_expand/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -73,7 +73,7 @@ impl KleeneToken {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,"}, {"sha": "7e42b931961f8638670e7e63dfcde0e3b991d1d6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1311,7 +1311,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte UTF-8 characters, a byte offset\n /// is not equivalent to a character offset. The `SourceMap` will convert `BytePos`\n /// values to `CharPos` values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: lots of boilerplate in these impls, but so far my attempts to fix"}, {"sha": "97c5acf1f72ca42129efce0205612dc331f7719d", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -3,13 +3,13 @@\n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields, unused_assignments)]\n+#![allow(unused_assignments)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n-trait Tr3 { type As3; }\n-trait Tr4<'a> { type As4; }\n-trait Tr5 { type As5; }\n+trait Tr1: Copy { type As1: Copy; }\n+trait Tr2: Copy { type As2: Copy; }\n+trait Tr3: Copy { type As3: Copy; }\n+trait Tr4<'a>: Copy { type As4: Copy; }\n+trait Tr5: Copy { type As5: Copy; }\n \n impl Tr1 for &str { type As1 = bool; }\n impl Tr2 for bool { type As2 = u8; }\n@@ -71,7 +71,8 @@ where\n     let _: &'a T = &x.f0;\n }\n \n-union UnSelf<T> where Self: Tr1<As1: Tr2> {\n+#[derive(Copy, Clone)]\n+union UnSelf<T> where Self: Tr1<As1: Tr2>, T: Copy {\n     f0: T,\n     f1: <Self as Tr1>::As1,\n     f2: <<Self as Tr1>::As1 as Tr2>::As2,"}, {"sha": "8e84a900605f552ccdf65a793af6cf70dcf40224", "filename": "src/test/ui/consts/const-int-pow-rpass.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+\n+const IS_POWER_OF_TWO_A: bool = 0u32.is_power_of_two();\n+const IS_POWER_OF_TWO_B: bool = 32u32.is_power_of_two();\n+const IS_POWER_OF_TWO_C: bool = 33u32.is_power_of_two();\n+\n+fn main() {\n+    assert!(!IS_POWER_OF_TWO_A);\n+    assert!(IS_POWER_OF_TWO_B);\n+    assert!(!IS_POWER_OF_TWO_C);\n+}"}, {"sha": "5a7568fe2cd50fa025c5ad8018da27c56f448d4b", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -8,6 +8,7 @@\n #![feature(slice_patterns)]\n \n use std::cell::{Cell, RefCell};\n+use std::mem::ManuallyDrop;\n use std::ops::Generator;\n use std::panic;\n use std::pin::Pin;\n@@ -152,17 +153,16 @@ fn assignment1(a: &Allocator, c0: bool) {\n     _v = _w;\n }\n \n-#[allow(unions_with_drop_fields)]\n union Boxy<T> {\n-    a: T,\n-    b: T,\n+    a: ManuallyDrop<T>,\n+    b: ManuallyDrop<T>,\n }\n \n fn union1(a: &Allocator) {\n     unsafe {\n-        let mut u = Boxy { a: a.alloc() };\n-        u.b = a.alloc();\n-        drop(u.a);\n+        let mut u = Boxy { a: ManuallyDrop::new(a.alloc()) };\n+        *u.b = a.alloc(); // drops first alloc\n+        drop(ManuallyDrop::into_inner(u.a));\n     }\n }\n "}, {"sha": "0faa9090f4ebcfd898a632a1faf6d6dc6448d5be", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,7 +1,7 @@\n #![feature(untagged_unions)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n+trait Tr1 { type As1: Copy; }\n+trait Tr2 { type As2: Copy; }\n \n struct S1;\n #[derive(Copy, Clone)]\n@@ -32,7 +32,7 @@ enum _En1<T: Tr1<As1: Tr2>> {\n \n union _Un1<T: Tr1<As1: Tr2>> {\n //~^ ERROR associated type bounds are unstable\n-    outest: T,\n+    outest: std::mem::ManuallyDrop<T>,\n     outer: T::As1,\n     inner: <T::As1 as Tr2>::As2,\n }"}, {"sha": "9ee0e6f681dcc4ae2f1b9b335ab15a90825d8aee", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -7,11 +7,11 @@ union U2<T: Copy> { // OK\n }\n \n union U3 { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: String,\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U4<T> { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: T,\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U5 { //~ ERROR unions with `Drop` implementations are unstable"}, {"sha": "1885518a4585cc0e8b916bd34e31f39d18821624", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.stderr", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -31,6 +31,31 @@ LL | | }\n    = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n-error: aborting due to 3 previous errors\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors have detailed explanations: E0658, E0740.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "ea8a3c177e9d7f77dd202b8dced545200e861400", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,13 +1,12 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'b, U> { //~ ERROR rustc_outlives\n+union Foo<'b, U: Copy> { //~ ERROR rustc_outlives\n     bar: Bar<'b, U>\n }\n \n-union Bar<'a, T> where T: 'a {\n+union Bar<'a, T: Copy> where T: 'a {\n     x: &'a (),\n     y: T,\n }"}, {"sha": "8aa246e8bfeb35f312a6fd413bc7a9f36295a470", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/explicit-union.rs:6:1\n+  --> $DIR/explicit-union.rs:5:1\n    |\n-LL | / union Foo<'b, U> {\n+LL | / union Foo<'b, U: Copy> {\n LL | |     bar: Bar<'b, U>\n LL | | }\n    | |_^"}, {"sha": "0da3cc2ba1b0434c363c2c8503066ef878e03840", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,14 +1,13 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'a, T> { //~ ERROR rustc_outlives\n+union Foo<'a, T: Copy> { //~ ERROR rustc_outlives\n     field1: Bar<'a, T>\n }\n \n // Type U needs to outlive lifetime 'b\n-union Bar<'b, U> {\n+union Bar<'b, U: Copy> {\n     field2: &'b U\n }\n "}, {"sha": "a42285a56d0890cb39d809e5494b26bd8bb9336a", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/nested-union.rs:6:1\n+  --> $DIR/nested-union.rs:5:1\n    |\n-LL | / union Foo<'a, T> {\n+LL | / union Foo<'a, T: Copy> {\n LL | |     field1: Bar<'a, T>\n LL | | }\n    | |_^"}, {"sha": "3b1eb9e1dfa16a86543aad7f17e3126941a65839", "filename": "src/test/ui/self/self-in-typedefs.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -3,7 +3,8 @@\n #![feature(untagged_unions)]\n \n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n+\n+use std::mem::ManuallyDrop;\n \n enum A<'a, T: 'a>\n where\n@@ -24,6 +25,14 @@ where\n union C<'a, T: 'a>\n where\n     Self: Send, T: PartialEq<Self>\n+{\n+    foo: &'a Self,\n+    bar: ManuallyDrop<T>,\n+}\n+\n+union D<'a, T: 'a>\n+where\n+    Self: Send, T: PartialEq<Self> + Copy\n {\n     foo: &'a Self,\n     bar: T,"}, {"sha": "610937739c194489104ee2d1e413b63b0abc7a2a", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -46,13 +46,13 @@ error: def-path(bar::<impl foo::Foo>::baz)\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h059bf53000885489E)\n+error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h636bc933fc62ee2fE)\n   --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h059bf53000885489)\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h636bc933fc62ee2f)\n   --> $DIR/impl1.rs:61:13\n    |\n LL |             #[rustc_symbol_name]"}, {"sha": "91e9a0d0b659c7e7cbc1a496f2adfed56d97fd8e", "filename": "src/test/ui/union/issue-41073.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,24 @@\n+#![feature(untagged_unions)]\n+\n+union Test {\n+    a: A, //~ ERROR unions may not contain fields that need dropping\n+    b: B\n+}\n+\n+#[derive(Debug)]\n+struct A(i32);\n+impl Drop for A {\n+    fn drop(&mut self) { println!(\"A\"); }\n+}\n+\n+#[derive(Debug)]\n+struct B(f32);\n+impl Drop for B {\n+    fn drop(&mut self) { println!(\"B\"); }\n+}\n+\n+fn main() {\n+    let mut test = Test { a: A(3) };\n+    println!(\"{:?}\", unsafe { test.b });\n+    unsafe { test.b = B(0.5); }\n+}"}, {"sha": "2e9598b227124f9e07731f2a48ca956935bd7d4a", "filename": "src/test/ui/union/issue-41073.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "edf08e6ca678f13a4340aac6b5afd54052fc8bff", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,51 +1,90 @@\n #![feature(untagged_unions)]\n #![allow(unused)]\n \n-#[allow(unions_with_drop_fields)]\n+use std::ops::{Deref, DerefMut};\n+\n+#[derive(Default)]\n+struct MockBox<T> {\n+    value: [T; 1],\n+}\n+\n+impl<T> MockBox<T> {\n+    fn new(value: T) -> Self { MockBox { value: [value] } }\n+}\n+\n+impl<T> Deref for MockBox<T> {\n+    type Target = T;\n+    fn deref(&self) -> &T { &self.value[0] }\n+}\n+\n+impl<T> DerefMut for MockBox<T> {\n+    fn deref_mut(&mut self) -> &mut T { &mut self.value[0] }\n+}\n+\n+#[derive(Default)]\n+struct MockVec<T> {\n+    value: [T; 0],\n+}\n+\n+impl<T> MockVec<T> {\n+    fn new() -> Self { MockVec { value: [] } }\n+}\n+\n+impl<T> Deref for MockVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] { &self.value }\n+}\n+\n+impl<T> DerefMut for MockVec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] { &mut self.value }\n+}\n+\n+\n union U {\n-    x: ((Vec<u8>, Vec<u8>), Vec<u8>),\n-    y: Box<Vec<u8>>,\n+    x: ((MockVec<u8>, MockVec<u8>), MockVec<u8>),\n+    y: MockBox<MockVec<u8>>,\n }\n \n fn use_borrow<T>(_: &T) {}\n \n unsafe fn parent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut u.x.0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn parent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = u.x.0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn grandparent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut (u.x.0).0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn grandparent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = (u.x.0).0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn deref_sibling_borrow() {\n-    let mut u = U { y: Box::default() };\n+    let mut u = U { y: MockBox::default() };\n     let a = &mut *u.y;\n     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n     use_borrow(a);\n }\n \n unsafe fn deref_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-    let a = *u.y;\n-    let b = u.x; //~ ERROR use of moved value: `u`\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n+    // No way to test deref-move without Box in union\n+    // let a = *u.y;\n+    // let b = u.x; ERROR use of moved value: `u`\n }\n \n "}, {"sha": "8ba155bafb0b95526c0e13fa4ca9f2bd072db98a", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:15:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:53:13\n    |\n LL |     let a = &mut u.x.0;\n    |             ---------- mutable borrow occurs here (via `u.x.0`)\n@@ -11,17 +11,17 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:60:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = u.x.0;\n    |             ----- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:66:13\n    |\n LL |     let a = &mut (u.x.0).0;\n    |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n@@ -33,38 +33,28 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:73:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = (u.x.0).0;\n    |             --------- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n-error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n+error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `u.y`)\n+  --> $DIR/union-borrow-move-parent-sibling.rs:79:13\n    |\n LL |     let a = &mut *u.y;\n-   |             --------- mutable borrow occurs here (via `*u.y`)\n+   |                   --- mutable borrow occurs here (via `u.y`)\n LL |     let b = &u.x;\n-   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n+   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `u.y` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n    |\n-   = note: `u.x` is a field of the union `U`, so it overlaps the field `*u.y`\n+   = note: `u.x` is a field of the union `U`, so it overlaps the field `u.y`\n \n-error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:48:13\n-   |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n-LL |     let a = *u.y;\n-   |             ---- value moved here\n-LL |     let b = u.x;\n-   |             ^^^ value used here after move\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0382, E0502.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "8f816cc1b737c6c4822e80379c969ae6185337ba", "filename": "src/test/ui/union/union-custom-drop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,19 @@\n+// test for a union with a field that's a union with a manual impl Drop\n+// Ensures we do not treat all unions as not having any drop glue.\n+\n+#![feature(untagged_unions)]\n+\n+union Foo {\n+    bar: Bar, //~ ERROR unions may not contain fields that need dropping\n+}\n+\n+union Bar {\n+    a: i32,\n+    b: u32,\n+}\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "ee2333f905fb4106ed234eb144621456a2c3621d", "filename": "src/test/ui/union/union-custom-drop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "60e280f53f52c8dc0caabf6f4aad068a4c312c73", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,5 +1,7 @@\n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n #[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n union U1 {\n     a: u8,\n@@ -18,14 +20,19 @@ union U3 {\n }\n \n #[derive(Clone, Copy)]\n-union U4<T> {\n+union U4<T: Copy> {\n     a: T, // OK\n }\n \n+#[derive(Clone, Copy)]\n+union U5<T> {\n+    a: ManuallyDrop<T>, // OK\n+}\n+\n #[derive(Clone)]\n struct CloneNoCopy;\n \n fn main() {\n-    let u = U4 { a: CloneNoCopy };\n-    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+    let u = U5 { a: ManuallyDrop::new(CloneNoCopy) };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U5<CloneNoCopy>`\n }"}, {"sha": "6893f9176f2db7778bd846d090c0707a2f9dcacc", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,22 +1,22 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:3:10\n+  --> $DIR/union-derive-clone.rs:5:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n    |\n    = note: required by `std::clone::AssertParamIsCopy`\n \n-error[E0599]: no method named `clone` found for type `U4<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:30:15\n+error[E0599]: no method named `clone` found for type `U5<CloneNoCopy>` in the current scope\n+  --> $DIR/union-derive-clone.rs:37:15\n    |\n-LL | union U4<T> {\n+LL | union U5<T> {\n    | ----------- method `clone` not found for this\n ...\n LL |     let w = u.clone();\n-   |               ^^^^^ method not found in `U4<CloneNoCopy>`\n+   |               ^^^^^ method not found in `U5<CloneNoCopy>`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n-           `U4<CloneNoCopy> : std::clone::Clone`\n+           `U5<CloneNoCopy> : std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "b2f7ae679fd6849ec8ee3dae2843bfec8d4ef4ea", "filename": "src/test/ui/union/union-derive-rpass.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Some traits can be derived for unions.\n \n@@ -24,11 +23,11 @@ impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n     Copy,\n     Eq\n )]\n-union W<T> {\n+union W<T: Copy> {\n     a: T,\n }\n \n-impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+impl<T: Copy> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n \n fn main() {\n     let u = U { b: 0 };"}, {"sha": "f1511b0a60180c63328642c3325542b916a89b55", "filename": "src/test/ui/union/union-drop-assign.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,15 +1,16 @@\n // run-pass\n #![allow(unused_assignments)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n struct S;\n \n union U {\n-    a: S\n+    a: ManuallyDrop<S>\n }\n \n impl Drop for S {\n@@ -28,11 +29,11 @@ static mut CHECK: u8 = 0;\n \n fn main() {\n     unsafe {\n-        let mut u = U { a: S };\n+        let mut u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 0);\n-        u = U { a: S };\n+        u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 1); // union itself is assigned, union is dropped, field is not dropped\n-        u.a = S;\n+        *u.a = S;\n         assert_eq!(CHECK, 11); // union field is assigned, field is dropped\n     }\n }"}, {"sha": "daa03ce6b6fd85d47473ca9942124e28cd949cbe", "filename": "src/test/ui/union/union-drop.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n@@ -21,12 +20,6 @@ union Y {\n     a: S,\n }\n \n-impl Drop for S {\n-    fn drop(&mut self) {\n-        unsafe { CHECK += 10; }\n-    }\n-}\n-\n impl Drop for U {\n     fn drop(&mut self) {\n         unsafe { CHECK += 1; }\n@@ -51,10 +44,10 @@ fn main() {\n         {\n             let w = W { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 11, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of W is called\n         {\n             let y = Y { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 12, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of Y is called\n     }\n }"}, {"sha": "eb169c516d2a81f53d438a04d66c7c3b7115294e", "filename": "src/test/ui/union/union-generic-rpass.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,37 +1,33 @@\n // run-pass\n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n union MaybeItem<T: Iterator> {\n-    elem: T::Item,\n+    elem: ManuallyDrop<T::Item>,\n     none: (),\n }\n \n-union U<A, B> {\n+union U<A, B> where A: Copy, B: Copy {\n     a: A,\n     b: B,\n }\n \n-unsafe fn union_transmute<A, B>(a: A) -> B {\n+unsafe fn union_transmute<A, B>(a: A) -> B where A: Copy, B: Copy {\n     U { a: a }.b\n }\n \n fn main() {\n     unsafe {\n-        let u = U::<String, Vec<u8>> { a: String::from(\"abcd\") };\n-\n-        assert_eq!(u.b.len(), 4);\n-        assert_eq!(u.b[0], b'a');\n-\n         let b = union_transmute::<(u8, u8), u16>((1, 1));\n         assert_eq!(b, (1 << 8) + 1);\n \n         let v: Vec<u8> = vec![1, 2, 3];\n         let mut i = v.iter();\n         i.next();\n-        let mi = MaybeItem::<std::slice::Iter<_>> { elem: i.next().unwrap() };\n-        assert_eq!(*mi.elem, 2);\n+        let mi = MaybeItem::<std::slice::Iter<_>> { elem: ManuallyDrop::new(i.next().unwrap()) };\n+        assert_eq!(**mi.elem, 2);\n     }\n }"}, {"sha": "a43a5050865691e6bd7db60e2222feff00ecfc16", "filename": "src/test/ui/union/union-manuallydrop-rpass.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,42 @@\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+// run-pass\n+\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n+\n+struct NeedDrop;\n+\n+impl Drop for NeedDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+union UnionOk1<T> {\n+    empty: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+union UnionOk2 {\n+    value: ManuallyDrop<NeedDrop>,\n+}\n+\n+#[allow(dead_code)]\n+union UnionOk3<T: Copy> {\n+    empty: (),\n+    value: T,\n+}\n+\n+trait Foo { }\n+\n+trait ImpliesCopy : Copy { }\n+\n+#[allow(dead_code)]\n+union UnionOk4<T: ImpliesCopy> {\n+    value: T,\n+}\n+\n+fn main() {\n+    // NeedDrop should not make needs_drop true\n+    assert!(!needs_drop::<UnionOk1<NeedDrop>>());\n+    assert!(!needs_drop::<UnionOk3<&dyn Foo>>());\n+}"}, {"sha": "59282bec59b84de9cbf6757e0c78ef1197e21406", "filename": "src/test/ui/union/union-nodrop.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,12 +1,11 @@\n // run-pass\n \n-#![feature(core_intrinsics)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields)]\n #![allow(dead_code)]\n \n-use std::intrinsics::needs_drop;\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n \n struct NeedDrop;\n \n@@ -16,10 +15,14 @@ impl Drop for NeedDrop {\n \n // Constant expressios allow `NoDrop` to go out of scope,\n // unlike a value of the interior type implementing `Drop`.\n-static X: () = (NoDrop { inner: NeedDrop }, ()).1;\n+static X: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const Y: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const fn _f() { (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1 }\n \n // A union that scrubs the drop glue from its inner type\n-union NoDrop<T> {inner: T}\n+union NoDrop<T> { inner: ManuallyDrop<T> }\n \n // Copy currently can't be implemented on drop-containing unions,\n // this may change later\n@@ -40,7 +43,7 @@ struct Baz {\n     y: Box<u8>,\n }\n \n-union ActuallyDrop<T> {inner: T}\n+union ActuallyDrop<T> { inner: ManuallyDrop<T> }\n \n impl<T> Drop for ActuallyDrop<T> {\n     fn drop(&mut self) {}"}, {"sha": "8234beb74a8269137568b0d8b63c6575fd61b9a9", "filename": "src/test/ui/union/union-overwrite.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,21 +1,27 @@\n // run-pass\n-#![allow(unions_with_drop_fields)]\n-\n #![feature(untagged_unions)]\n \n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Pair<T, U>(T, U);\n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Triple<T>(T, T, T);\n \n #[repr(C)]\n-union U<A, B> {\n+union U<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: Pair<A, A>,\n     b: B,\n }\n \n #[repr(C)]\n-union W<A, B> {\n+union W<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: A,\n     b: B,\n }"}, {"sha": "8535cbd019ce87c6871f2dfbc8511df2e186c25a", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,29 +1,33 @@\n #![feature(untagged_unions)]\n+use std::mem::ManuallyDrop;\n \n union U1 {\n     a: u8\n }\n \n union U2 {\n-    a: String\n+    a: ManuallyDrop<String>\n }\n \n union U3<T> {\n-    a: T\n+    a: ManuallyDrop<T>\n }\n \n union U4<T: Copy> {\n     a: T\n }\n \n fn generic_noncopy<T: Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n }\n \n fn generic_copy<T: Copy + Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); // OK\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); // OK\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n+\n     let mut u4 = U4 { a: T::default() };\n     u4.a = T::default(); // OK\n }\n@@ -32,14 +36,20 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field is unsafe\n     u1.a = 11; // OK\n+\n     let U1 { a } = u1; //~ ERROR access to union field is unsafe\n     if let U1 { a: 12 } = u1 {} //~ ERROR access to union field is unsafe\n     // let U1 { .. } = u1; // OK\n \n-    let mut u2 = U2 { a: String::from(\"old\") }; // OK\n-    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n-    let mut u3 = U3 { a: 0 }; // OK\n-    u3.a = 1; // OK\n-    let mut u3 = U3 { a: String::from(\"old\") }; // OK\n-    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u2 = U2 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u2.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u2.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK\n+    u3.a = ManuallyDrop::new(1); // OK\n+    *u3.a = 1; //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u3.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u3.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n }"}, {"sha": "e020dab63f8f442d503b119caf1b59bcd2d53793", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,51 +1,91 @@\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:21:5\n+  --> $DIR/union-unsafe.rs:22:5\n    |\n-LL |     u3.a = T::default();\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(T::default());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:33:13\n+  --> $DIR/union-unsafe.rs:23:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:29:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:37:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:35:14\n+  --> $DIR/union-unsafe.rs:40:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:20\n+  --> $DIR/union-unsafe.rs:41:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:5\n+  --> $DIR/union-unsafe.rs:45:5\n    |\n-LL |     u2.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u2.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:46:6\n+   |\n+LL |     *u2.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:50:6\n+   |\n+LL |     *u3.a = 1;\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:44:5\n+  --> $DIR/union-unsafe.rs:53:5\n    |\n-LL |     u3.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n-error: aborting due to 6 previous errors\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:54:6\n+   |\n+LL |     *u3.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "4dbeb7c1e7e973d3a0b7b3afc99bcf8d01a4af9c", "filename": "src/test/ui/union/union-with-drop-fields-lint-rpass.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs?ref=10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-\n-#![feature(untagged_unions)]\n-#![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n-\n-union U {\n-    a: u8, // OK\n-}\n-\n-union W {\n-    a: String, // OK\n-    b: String, // OK\n-}\n-\n-struct S(String);\n-\n-// `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n-union Y {\n-    a: S, // OK\n-}\n-\n-// We don't know if `T` is trivially-destructable or not until trans\n-union J<T> {\n-    a: T, // OK\n-}\n-\n-union H<T: Copy> {\n-    a: T, // OK\n-}\n-\n-fn main() {}"}, {"sha": "2f90f240d2e1947e05807f22bf49dbfa0dfdb4bb", "filename": "src/test/ui/union/union-with-drop-fields-lint.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr?ref=10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "patch": "@@ -1,26 +0,0 @@\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:10:5\n-   |\n-LL |     a: String,\n-   |     ^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/union-with-drop-fields-lint.rs:3:9\n-   |\n-LL | #![deny(unions_with_drop_fields)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:18:5\n-   |\n-LL |     a: S,\n-   |     ^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:23:5\n-   |\n-LL |     a: T,\n-   |     ^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "e3c63a6d5b5a2e7ad447a3ff7bb7a8d3e794e4fa", "filename": "src/test/ui/union/union-with-drop-fields.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -1,26 +1,25 @@\n #![feature(untagged_unions)]\n #![allow(dead_code)]\n-#![deny(unions_with_drop_fields)]\n \n union U {\n     a: u8, // OK\n }\n \n union W {\n-    a: String, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n     b: String, // OK, only one field is reported\n }\n \n struct S(String);\n \n // `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n union Y {\n-    a: S, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: S, //~ ERROR unions may not contain fields that need dropping\n }\n \n // We don't know if `T` is trivially-destructable or not until trans\n union J<T> {\n-    a: T, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union H<T: Copy> {", "previous_filename": "src/test/ui/union/union-with-drop-fields-lint.rs"}, {"sha": "0e77279be616a7a1f71b2759a70e1b29a776dcfa", "filename": "src/test/ui/union/union-with-drop-fields.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr?ref=6576f4be5af31a5e61dfc0cf50b7130e6c6dfb35", "patch": "@@ -0,0 +1,39 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0740`."}]}