{"sha": "4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZDBkYWEyMjBmZDVlMDBjZTQyNWM5MjA4ODY5ZWEwZDZmNGI5ODE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T18:02:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-27T10:55:25Z"}, "message": "Move proc macro server into libsyntax", "tree": {"sha": "dbec20ac9b847bec08667635b18af31ed261570c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbec20ac9b847bec08667635b18af31ed261570c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "html_url": "https://github.com/rust-lang/rust/commit/4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eeec1c5d2a6342b6b38720ae67091e1546ac7d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1", "html_url": "https://github.com/rust-lang/rust/commit/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1"}], "stats": {"total": 614, "additions": 271, "deletions": 343}, "files": [{"sha": "d1afe5944ee97262d5cbf1e4eb456d0f9e44f664", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -3008,7 +3008,6 @@ dependencies = [\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n "}, {"sha": "5ff60a9267bad52ba8dbde98a128679ceace9f42", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -21,5 +21,4 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d5f1e715186f4ca984eb3c1f1a218bfe0aa4630d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -586,8 +586,7 @@ impl<'a> CrateLoader<'a> {\n         use std::{env, mem};\n         use crate::dynamic_lib::DynamicLibrary;\n         use proc_macro::bridge::client::ProcMacro;\n-        use syntax_ext::deriving::custom::ProcMacroDerive;\n-        use syntax_ext::proc_macro_impl::{AttrProcMacro, BangProcMacro};\n+        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,"}, {"sha": "ee1175e798d806cddfb85c3f0618a316979b3e33", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -31,10 +31,10 @@ use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n "}, {"sha": "ff9ad46deecc078c0d3a7cf1683d2f08f502bb2d", "filename": "src/libsyntax/ext/derive.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=3eeec1c5d2a6342b6b38720ae67091e1546ac7d1", "patch": "@@ -1,72 +0,0 @@\n-use crate::attr::HasAttrs;\n-use crate::ast;\n-use crate::source_map::{ExpnInfo, ExpnKind};\n-use crate::ext::base::{ExtCtxt, MacroKind};\n-use crate::ext::build::AstBuilder;\n-use crate::parse::parser::PathStyle;\n-use crate::symbol::{Symbol, sym};\n-use crate::errors::Applicability;\n-\n-use syntax_pos::Span;\n-use rustc_data_structures::fx::FxHashSet;\n-\n-pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n-    let mut result = Vec::new();\n-    attrs.retain(|attr| {\n-        if attr.path != sym::derive {\n-            return true;\n-        }\n-        if !attr.is_meta_item_list() {\n-            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"missing traits to be derived\",\n-                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).emit();\n-            return false;\n-        }\n-\n-        match attr.parse_list(cx.parse_sess,\n-                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n-            Ok(traits) => {\n-                result.extend(traits);\n-                true\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                false\n-            }\n-        }\n-    });\n-    result\n-}\n-\n-pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T)\n-    where T: HasAttrs,\n-{\n-    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n-    for (i, path) in traits.iter().enumerate() {\n-        if i > 0 {\n-            pretty_name.push_str(\", \");\n-        }\n-        pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n-    }\n-\n-    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n-        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n-    ));\n-\n-    item.visit_attrs(|attrs| {\n-        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n-            let meta = cx.meta_word(span, sym::structural_match);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-        if names.contains(&sym::Copy) {\n-            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-    });\n-}"}, {"sha": "cd602d08c5baaf0e886cc9be4422800173a4eb06", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::derive::{add_derived_markers, collect_derives};\n+use crate::ext::proc_macro::{add_derived_markers, collect_derives};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};"}, {"sha": "4b4ac57207eff085691657c8f3ab569156a24c5d", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 244, "deletions": 2, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -1,7 +1,249 @@\n-use crate::ast::Attribute;\n-use crate::symbol::sym;\n+use crate::ast::{self, ItemKind, Attribute, Mac};\n+use crate::attr::{mark_used, mark_known, HasAttrs};\n+use crate::errors::{Applicability, FatalError};\n+use crate::ext::base::{self, *};\n+use crate::ext::build::AstBuilder;\n+use crate::ext::proc_macro_server;\n+use crate::parse::{self, token};\n+use crate::parse::parser::PathStyle;\n+use crate::symbol::{sym, Symbol};\n+use crate::tokenstream::{self, TokenStream};\n+use crate::visit::Visitor;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n+    proc_macro::bridge::server::SameThread;\n+\n+pub struct BangProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::ProcMacro for BangProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   input: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc macro panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AttrProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::AttrProcMacro for AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"custom attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct ProcMacroDerive {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+    pub attrs: Vec<ast::Name>,\n+}\n+\n+impl MultiItemModifier for ProcMacroDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              _meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let item = match item {\n+            Annotatable::Item(item) => item,\n+            Annotatable::ImplItem(_) |\n+            Annotatable::TraitItem(_) |\n+            Annotatable::ForeignItem(_) |\n+            Annotatable::Stmt(_) |\n+            Annotatable::Expr(_) => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        };\n+        match item.node {\n+            ItemKind::Struct(..) |\n+            ItemKind::Enum(..) |\n+            ItemKind::Union(..) => {},\n+            _ => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        }\n+\n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n+        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n+        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n+\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc-macro derive panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        };\n+\n+        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n+        let msg = \"proc-macro derive produced unparseable tokens\";\n+\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n+        let mut items = vec![];\n+\n+        loop {\n+            match parser.parse_item() {\n+                Ok(None) => break,\n+                Ok(Some(item)) => {\n+                    items.push(Annotatable::Item(item))\n+                }\n+                Err(mut err) => {\n+                    // FIXME: handle this better\n+                    err.cancel();\n+                    ecx.struct_span_fatal(span, msg).emit();\n+                    FatalError.raise();\n+                }\n+            }\n+        }\n+\n+\n+        // fail if there have been errors emitted\n+        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+            ecx.struct_span_fatal(span, msg).emit();\n+            FatalError.raise();\n+        }\n+\n+        items\n+    }\n+}\n+\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n+\n+impl<'a> Visitor<'a> for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if let Some(ident) = attr.ident() {\n+            if self.0.contains(&ident.name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _mac: &Mac) {}\n+}\n \n pub fn is_proc_macro_attr(attr: &Attribute) -> bool {\n     [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n         .iter().any(|kind| attr.check_name(*kind))\n }\n+\n+crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n+    let mut result = Vec::new();\n+    attrs.retain(|attr| {\n+        if attr.path != sym::derive {\n+            return true;\n+        }\n+        if !attr.is_meta_item_list() {\n+            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n+                .span_suggestion(\n+                    attr.span,\n+                    \"missing traits to be derived\",\n+                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n+                    Applicability::HasPlaceholders,\n+                ).emit();\n+            return false;\n+        }\n+\n+        match attr.parse_list(cx.parse_sess,\n+                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n+            Ok(traits) => {\n+                result.extend(traits);\n+                true\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                false\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+crate fn add_derived_markers<T: HasAttrs>(\n+    cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T\n+) {\n+    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n+    for (i, path) in traits.iter().enumerate() {\n+        if i > 0 {\n+            pretty_name.push_str(\", \");\n+        }\n+        pretty_name.push_str(&path.to_string());\n+        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n+    }\n+\n+    let span = span.fresh_expansion(cx.current_expansion.mark, ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n+        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n+    ));\n+\n+    item.visit_attrs(|attrs| {\n+        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n+            let meta = cx.meta_word(span, sym::structural_match);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+        if names.contains(&sym::Copy) {\n+            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+    });\n+}"}, {"sha": "8d0023c9ab1eb986e57c69a8a6ef3e81b41e4758", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -1,21 +1,19 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n-\n-use std::panic;\n-\n-use proc_macro::bridge::{server, TokenTree};\n-use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use crate::ast;\n+use crate::ext::base::ExtCtxt;\n+use crate::parse::{self, token, ParseSess};\n+use crate::parse::lexer::comments;\n+use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n+use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n-use std::ascii;\n-use std::ops::Bound;\n-use syntax::ast;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::parse::lexer::comments;\n-use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n+use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n-use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n+\n+use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use proc_macro::bridge::{server, TokenTree};\n+use std::{ascii, panic};\n+use std::ops::Bound;\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -52,7 +50,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n {\n     fn from_internal(((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>))\n                     -> Self {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let joint = is_joint == Joint;\n         let Token { kind, span } = match tree {\n@@ -193,7 +191,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n \n impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n     fn to_internal(self) -> TokenStream {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),", "previous_filename": "src/libsyntax_ext/proc_macro_server.rs"}, {"sha": "a4102ce45aac92c3f4260969dd91cdb0a0e734f4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -18,12 +18,17 @@\n #![feature(label_break_value)]\n #![feature(mem_take)]\n #![feature(nll)]\n+#![feature(proc_macro_diagnostic)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]\n \n+extern crate proc_macro;\n+\n pub use errors;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::bit_set::GrowableBitSet;\n@@ -162,13 +167,14 @@ pub mod print {\n }\n \n pub mod ext {\n+    mod placeholders;\n+    mod proc_macro_server;\n+\n     pub use syntax_pos::hygiene;\n     pub mod allocator;\n     pub mod base;\n     pub mod build;\n-    pub mod derive;\n     pub mod expand;\n-    pub mod placeholders;\n     pub mod proc_macro;\n \n     pub mod tt {"}, {"sha": "98465d75e4680e9d31beb6665f871e22e0ade22b", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=3eeec1c5d2a6342b6b38720ae67091e1546ac7d1", "patch": "@@ -1,119 +0,0 @@\n-use crate::proc_macro_impl::EXEC_STRATEGY;\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use rustc_data_structures::sync::Lrc;\n-use syntax::ast::{self, ItemKind, Attribute, Mac};\n-use syntax::attr::{mark_used, mark_known};\n-use syntax::source_map::Span;\n-use syntax::ext::base::*;\n-use syntax::parse;\n-use syntax::parse::token;\n-use syntax::tokenstream;\n-use syntax::visit::Visitor;\n-use syntax_pos::DUMMY_SP;\n-\n-struct MarkAttrs<'a>(&'a [ast::Name]);\n-\n-impl<'a> Visitor<'a> for MarkAttrs<'a> {\n-    fn visit_attribute(&mut self, attr: &Attribute) {\n-        if let Some(ident) = attr.ident() {\n-            if self.0.contains(&ident.name) {\n-                mark_used(attr);\n-                mark_known(attr);\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Mac) {}\n-}\n-\n-pub struct ProcMacroDerive {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-    pub attrs: Vec<ast::Name>,\n-}\n-\n-impl MultiItemModifier for ProcMacroDerive {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              span: Span,\n-              _meta_item: &ast::MetaItem,\n-              item: Annotatable)\n-              -> Vec<Annotatable> {\n-        let item = match item {\n-            Annotatable::Item(item) => item,\n-            Annotatable::ImplItem(_) |\n-            Annotatable::TraitItem(_) |\n-            Annotatable::ForeignItem(_) |\n-            Annotatable::Stmt(_) |\n-            Annotatable::Expr(_) => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        };\n-        match item.node {\n-            ItemKind::Struct(..) |\n-            ItemKind::Enum(..) |\n-            ItemKind::Union(..) => {},\n-            _ => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        }\n-\n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n-        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n-\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc-macro derive panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        };\n-\n-        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        let msg = \"proc-macro derive produced unparseable tokens\";\n-\n-        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n-        let mut items = vec![];\n-\n-        loop {\n-            match parser.parse_item() {\n-                Ok(None) => break,\n-                Ok(Some(item)) => {\n-                    items.push(Annotatable::Item(item))\n-                }\n-                Err(mut err) => {\n-                    // FIXME: handle this better\n-                    err.cancel();\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n-                }\n-            }\n-        }\n-\n-\n-        // fail if there have been errors emitted\n-        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_fatal(span, msg).emit();\n-            FatalError.raise();\n-        }\n-\n-        items\n-    }\n-}"}, {"sha": "7f27769f236e29b97b4a1c098980254b5a1d8a8e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -1770,50 +1770,6 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n     }\n }\n \n-/// Call the method that is being derived on all the fields, and then\n-/// process the collected results. i.e.\n-///\n-/// ```ignore (only-for-syntax-highlight)\n-/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n-///                  self_2.method(__arg_1_2, __arg_2_2)])\n-/// ```\n-#[inline]\n-pub fn cs_same_method<F>(f: F,\n-                         mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-                         cx: &mut ExtCtxt<'_>,\n-                         trait_span: Span,\n-                         substructure: &Substructure<'_>)\n-                         -> P<Expr>\n-    where F: FnOnce(&mut ExtCtxt<'_>, Span, Vec<P<Expr>>) -> P<Expr>\n-{\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) |\n-        Struct(_, ref all_fields) => {\n-            // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = all_fields.iter()\n-                .map(|field| {\n-                    cx.expr_method_call(field.span,\n-                                        field.self_.clone(),\n-                                        substructure.method_ident,\n-                                        field.other\n-                                            .iter()\n-                                            .map(|e| cx.expr_addr_of(field.span, e.clone()))\n-                                            .collect())\n-                })\n-                .collect();\n-\n-            f(cx, trait_span, called)\n-        }\n-        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) => {\n-            enum_nonmatch_f(cx,\n-                            trait_span,\n-                            (&all_self_args[..], tuple),\n-                            substructure.nonself_args)\n-        }\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n-    }\n-}\n-\n /// Returns `true` if the type has no value fields\n /// (for an enum, no variant has any fields)\n pub fn is_type_without_fields(item: &Annotatable) -> bool {"}, {"sha": "394beb141712d8b7ad254120a04677da7496e578", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -18,6 +18,7 @@ pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n     /// *mut\n+    #[allow(dead_code)]\n     Raw(ast::Mutability),\n }\n \n@@ -107,13 +108,6 @@ pub enum Ty<'a> {\n     Tuple(Vec<Ty<'a>>),\n }\n \n-/// A const expression. Supports literals and blocks.\n-#[derive(Clone, Eq, PartialEq)]\n-pub enum Const {\n-    Literal,\n-    Block,\n-}\n-\n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n     Borrowed(None, ast::Mutability::Immutable)\n }"}, {"sha": "cad79917af284a623841f5e7104a718482f96a2b", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -26,7 +26,6 @@ pub mod decodable;\n pub mod hash;\n pub mod debug;\n pub mod default;\n-pub mod custom;\n \n #[path=\"cmp/partial_eq.rs\"]\n pub mod partial_eq;"}, {"sha": "d208d34eea185028bc48f3a2d2abb7bc37d08a50", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ad0daa220fd5e00ce425c9208869ea0d6f4b981/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=4ad0daa220fd5e00ce425c9208869ea0d6f4b981", "patch": "@@ -8,9 +8,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(nll)]\n-#![feature(proc_macro_diagnostic)]\n-#![feature(proc_macro_internals)]\n-#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unicode_internals)]\n \n@@ -32,22 +29,20 @@ mod cfg;\n mod compile_error;\n mod concat;\n mod concat_idents;\n+mod deriving;\n mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n mod global_asm;\n mod log_syntax;\n-mod proc_macro_server;\n mod source_util;\n mod test;\n mod test_case;\n mod trace_macros;\n \n-pub mod deriving;\n pub mod plugin_macro_defs;\n pub mod proc_macro_decls;\n-pub mod proc_macro_impl;\n \n pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n     let mut register = |name, kind| resolver.register_builtin_macro("}, {"sha": "f0fc6392cd73f593f7e963e8c4342f8ce2182b37", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeec1c5d2a6342b6b38720ae67091e1546ac7d1/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=3eeec1c5d2a6342b6b38720ae67091e1546ac7d1", "patch": "@@ -1,68 +0,0 @@\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use syntax::source_map::Span;\n-use syntax::ext::base::{self, *};\n-use syntax::tokenstream::TokenStream;\n-\n-pub const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n-    proc_macro::bridge::server::SameThread;\n-\n-pub struct AttrProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::AttrProcMacro for AttrProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   annotation: TokenStream,\n-                   annotated: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"custom attribute panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}\n-\n-pub struct BangProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::ProcMacro for BangProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   input: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc macro panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}"}]}