{"sha": "753971a4c597c60c55f2e3cd225d01fe5ad99d02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Mzk3MWE0YzU5N2M2MGM1NWYyZTNjZDIyNWQwMWZlNWFkOTlkMDI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T00:21:21Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-05-10T00:21:52Z"}, "message": "Handle promoted rvalues by recursing with call_nested.", "tree": {"sha": "ef1420f185fa0661884c09d882389dac2b6b94ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef1420f185fa0661884c09d882389dac2b6b94ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753971a4c597c60c55f2e3cd225d01fe5ad99d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753971a4c597c60c55f2e3cd225d01fe5ad99d02", "html_url": "https://github.com/rust-lang/rust/commit/753971a4c597c60c55f2e3cd225d01fe5ad99d02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753971a4c597c60c55f2e3cd225d01fe5ad99d02/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49b63495774bfa8328de3b3f940aa44e2a36a68c", "url": "https://api.github.com/repos/rust-lang/rust/commits/49b63495774bfa8328de3b3f940aa44e2a36a68c", "html_url": "https://github.com/rust-lang/rust/commit/49b63495774bfa8328de3b3f940aa44e2a36a68c"}], "stats": {"total": 99, "additions": 70, "deletions": 29}, "files": [{"sha": "a7a1ffb27b6032465b581922a3d21d81f0fea73f", "filename": "src/interpreter.rs", "status": "modified", "additions": 70, "deletions": 29, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/753971a4c597c60c55f2e3cd225d01fe5ad99d02/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753971a4c597c60c55f2e3cd225d01fe5ad99d02/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=753971a4c597c60c55f2e3cd225d01fe5ad99d02", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n-use std::ops::Deref;\n+use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n@@ -23,7 +23,7 @@ use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = false;\n \n-struct Interpreter<'a, 'tcx: 'a> {\n+struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: &'a TyCtxt<'tcx>,\n \n@@ -36,9 +36,6 @@ struct Interpreter<'a, 'tcx: 'a> {\n     /// The virtual memory system.\n     memory: Memory,\n \n-    /// The virtual call stack.\n-    stack: Vec<Frame<'a, 'tcx>>,\n-\n     /// Another stack containing the type substitutions for the current function invocation. It\n     /// exists separately from `stack` because it must contain the `Substs` for a function while\n     /// *creating* the `Frame` for that same function.\n@@ -51,6 +48,26 @@ struct Interpreter<'a, 'tcx: 'a> {\n     name_stack: Vec<(DefId, &'tcx Substs<'tcx>, codemap::Span)>,\n }\n \n+struct FnEvalContext<'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> {\n+    gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n+\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx>>,\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> Deref for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n+    type Target = GlobalEvalContext<'b, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        self.gecx\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> DerefMut for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.gecx\n+    }\n+}\n+\n /// A stack frame.\n struct Frame<'a, 'tcx: 'a> {\n     /// The MIR for the function called on this frame.\n@@ -106,18 +123,26 @@ enum TerminatorTarget {\n     Return,\n }\n \n-impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n+impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n     fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n-        Interpreter {\n+        GlobalEvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n             memory: Memory::new(),\n-            stack: Vec::new(),\n             substs_stack: Vec::new(),\n             name_stack: Vec::new(),\n         }\n     }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n+    fn new(gecx: &'a mut GlobalEvalContext<'b, 'tcx>) -> Self {\n+        FnEvalContext {\n+            gecx: gecx,\n+            stack: Vec::new(),\n+        }\n+    }\n \n     fn maybe_report<T>(&self, span: codemap::Span, r: EvalResult<T>) -> EvalResult<T> {\n         if let Err(ref e) = r {\n@@ -183,7 +208,24 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn push_stack_frame(&mut self, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n+    fn call_nested(&mut self, mir: &mir::Mir<'tcx>) -> EvalResult<Option<Pointer>> {\n+        let mut nested_fecx = FnEvalContext::new(self.gecx);\n+\n+        let return_ptr = match mir.return_ty {\n+            ty::FnConverging(ty) => {\n+                let size = nested_fecx.type_size(ty);\n+                Some(nested_fecx.memory.allocate(size))\n+            }\n+            ty::FnDiverging => None,\n+        };\n+\n+        let substs = nested_fecx.substs();\n+        nested_fecx.push_stack_frame(CachedMir::Ref(mir), substs, return_ptr);\n+        try!(nested_fecx.run());\n+        Ok(return_ptr)\n+    }\n+\n+    fn push_stack_frame(&mut self, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>)\n     {\n         self.substs_stack.push(substs);\n@@ -805,7 +847,11 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 match *literal {\n                     Value { ref value } => Ok(try!(self.const_to_ptr(value))),\n                     Item { .. } => unimplemented!(),\n-                    Promoted { .. } => unimplemented!(),\n+                    Promoted { index } => {\n+                        let current_mir = self.mir();\n+                        let mir = &current_mir.promoted[index];\n+                        self.call_nested(mir).map(Option::unwrap)\n+                    }\n                 }\n             }\n         }\n@@ -1020,23 +1066,23 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         Ok(val)\n     }\n \n-    fn frame(&self) -> &Frame<'a, 'tcx> {\n+    fn frame(&self) -> &Frame<'mir, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    fn frame_mut(&mut self) -> &mut Frame<'a, 'tcx> {\n+    fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    fn mir(&self) -> &mir::Mir<'tcx> {\n-        &self.frame().mir\n+    fn mir(&self) -> CachedMir<'mir, 'tcx> {\n+        self.frame().mir.clone()\n     }\n \n     fn substs(&self) -> &'tcx Substs<'tcx> {\n         self.substs_stack.last().cloned().unwrap_or_else(|| self.tcx.mk_substs(Substs::empty()))\n     }\n \n-    fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+    fn load_mir(&self, def_id: DefId) -> CachedMir<'mir, 'tcx> {\n         match self.tcx.map.as_local_node_id(def_id) {\n             Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n             None => {\n@@ -1200,22 +1246,17 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n \n                 println!(\"Interpreting: {}\", item.name);\n \n-                let mut miri = Interpreter::new(tcx, mir_map);\n-                let return_ptr = match mir.return_ty {\n-                    ty::FnConverging(ty) => {\n-                        let size = miri.type_size(ty);\n-                        Some(miri.memory.allocate(size))\n+                let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n+                let mut fecx = FnEvalContext::new(&mut gecx);\n+                match fecx.call_nested(mir) {\n+                    Ok(Some(return_ptr)) => fecx.memory.dump(return_ptr.alloc_id),\n+                    Ok(None) => println!(\"(diverging function returned)\"),\n+                    Err(_e) => {\n+                        // TODO(tsion): Detect whether the error was already reported or not.\n+                        // tcx.sess.err(&e.to_string());\n                     }\n-                    ty::FnDiverging => None,\n-                };\n-                let substs = miri.tcx.mk_substs(Substs::empty());\n-                miri.push_stack_frame(CachedMir::Ref(mir), substs, return_ptr);\n-                if let Err(_e) = miri.run() {\n-                    // TODO(tsion): Detect whether the error was already reported or not.\n-                    // tcx.sess.err(&e.to_string());\n-                } else if let Some(ret) = return_ptr {\n-                    miri.memory.dump(ret.alloc_id);\n                 }\n+\n                 println!(\"\");\n             }\n         }"}]}