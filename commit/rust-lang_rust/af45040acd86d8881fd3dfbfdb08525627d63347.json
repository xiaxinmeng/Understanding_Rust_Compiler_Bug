{"sha": "af45040acd86d8881fd3dfbfdb08525627d63347", "node_id": "C_kwDOAAsO6NoAKGFmNDUwNDBhY2Q4NmQ4ODgxZmQzZGZiZmRiMDg1MjU2MjdkNjMzNDc", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-12-02T18:36:20Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-12-02T18:40:40Z"}, "message": "Merge generics and where predicates and prevent duplicates in where predicates", "tree": {"sha": "5717a480a1fc7c375530bf9567d1ceb22c4a1c82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5717a480a1fc7c375530bf9567d1ceb22c4a1c82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af45040acd86d8881fd3dfbfdb08525627d63347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af45040acd86d8881fd3dfbfdb08525627d63347", "html_url": "https://github.com/rust-lang/rust/commit/af45040acd86d8881fd3dfbfdb08525627d63347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af45040acd86d8881fd3dfbfdb08525627d63347/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11663b1b4857ffeafbd85a9a36c234d117373b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/11663b1b4857ffeafbd85a9a36c234d117373b76", "html_url": "https://github.com/rust-lang/rust/commit/11663b1b4857ffeafbd85a9a36c234d117373b76"}], "stats": {"total": 124, "additions": 91, "deletions": 33}, "files": [{"sha": "2a2a9470d25c0ee4da19badf253f0207a6dcdda7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/af45040acd86d8881fd3dfbfdb08525627d63347/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af45040acd86d8881fd3dfbfdb08525627d63347/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=af45040acd86d8881fd3dfbfdb08525627d63347", "patch": "@@ -12,7 +12,7 @@ pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -598,47 +598,105 @@ pub(crate) fn clean_generics<'tcx>(\n         })\n         .collect::<Vec<_>>();\n \n+    let mut bound_predicates = FxIndexMap::default();\n+    let mut region_predicates = FxIndexMap::default();\n+    let mut eq_predicates = ThinVec::default();\n+    for pred in gens.predicates.iter().filter_map(|x| clean_where_predicate(x, cx)) {\n+        match pred {\n+            WherePredicate::BoundPredicate { ty, bounds, bound_params } => {\n+                match bound_predicates.entry(ty) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert((bounds, bound_params));\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().0.contains(&bound) {\n+                                o.get_mut().0.push(bound);\n+                            }\n+                        }\n+                        for bound_param in bound_params {\n+                            if !o.get().1.contains(&bound_param) {\n+                                o.get_mut().1.push(bound_param);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::RegionPredicate { lifetime, bounds } => {\n+                match region_predicates.entry(lifetime) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert(bounds);\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().contains(&bound) {\n+                                o.get_mut().push(bound);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n+                eq_predicates.push(WherePredicate::EqPredicate { lhs, rhs, bound_params });\n+            }\n+        }\n+    }\n+\n     let mut params = ThinVec::with_capacity(gens.params.len());\n+    // In this loop, we gather the generic parameters (`<'a, B: 'a>`) and check if they have\n+    // bounds in the where predicates. If so, we move their bounds into the where predicates\n+    // while also preventing duplicates.\n     for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-        let p = clean_generic_param(cx, Some(gens), p);\n+        let mut p = clean_generic_param(cx, Some(gens), p);\n+        match &mut p.kind {\n+            GenericParamDefKind::Lifetime { ref mut outlives } => {\n+                if let Some(region_pred) = region_predicates.get_mut(&Lifetime(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for outlive in outlives.drain(..) {\n+                        let outlive = GenericBound::Outlives(outlive);\n+                        if !region_pred.contains(&outlive) {\n+                            region_pred.push(outlive);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { bounds, synthetic: false, .. } => {\n+                if let Some(bound_pred) = bound_predicates.get_mut(&Type::Generic(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for bound in bounds.drain(..) {\n+                        if !bound_pred.0.contains(&bound) {\n+                            bound_pred.0.push(bound);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                // nothing to do here.\n+            }\n+        }\n         params.push(p);\n     }\n     params.extend(impl_trait_params);\n \n-    let mut generics = Generics {\n+    Generics {\n         params,\n-        where_predicates: gens\n-            .predicates\n-            .iter()\n-            .filter_map(|x| clean_where_predicate(x, cx))\n+        where_predicates: bound_predicates\n+            .into_iter()\n+            .map(|(ty, (bounds, bound_params))| WherePredicate::BoundPredicate {\n+                ty,\n+                bounds,\n+                bound_params,\n+            })\n+            .chain(\n+                region_predicates\n+                    .into_iter()\n+                    .map(|(lifetime, bounds)| WherePredicate::RegionPredicate { lifetime, bounds }),\n+            )\n+            .chain(eq_predicates.into_iter())\n             .collect(),\n-    };\n-\n-    // Some duplicates are generated for ?Sized bounds between type params and where\n-    // predicates. The point in here is to move the bounds definitions from type params\n-    // to where predicates when such cases occur.\n-    for where_pred in &mut generics.where_predicates {\n-        match *where_pred {\n-            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n-                if bounds.is_empty() {\n-                    for param in &mut generics.params {\n-                        match param.kind {\n-                            GenericParamDefKind::Lifetime { .. } => {}\n-                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                if &param.name == name {\n-                                    mem::swap(bounds, ty_bounds);\n-                                    break;\n-                                }\n-                            }\n-                            GenericParamDefKind::Const { .. } => {}\n-                        }\n-                    }\n-                }\n-            }\n-            _ => continue,\n-        }\n     }\n-    generics\n }\n \n fn clean_ty_generics<'tcx>("}]}