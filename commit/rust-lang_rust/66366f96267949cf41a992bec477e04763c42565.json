{"sha": "66366f96267949cf41a992bec477e04763c42565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MzY2Zjk2MjY3OTQ5Y2Y0MWE5OTJiZWM0NzdlMDQ3NjNjNDI1NjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-16T23:30:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-22T04:49:56Z"}, "message": "rustc: Lower link args to `@`-files on Windows more\n\nWhen spawning a linker rustc has historically been known to blow OS limits for\nthe command line being too large, notably on Windows. This is especially true of\nincremental compilation where there can be dozens of object files per\ncompilation. The compiler currently has logic for detecting a failure to spawn\nand instead passing arguments via a file instead, but this failure detection\nonly triggers if a process actually fails to spawn.\n\nUnfortunately on Windows we've got something else to worry about which is\n`cmd.exe`. The compiler may be running a linker through `cmd.exe` where\n`cmd.exe` has a limit of 8192 on the command line vs 32k on `CreateProcess`.\nMoreso rustc actually succeeds in spawning `cmd.exe` today, it's just that after\nit's running `cmd.exe` fails to spawn its child, which rustc doesn't currently\ndetect.\n\nConsequently this commit updates the logic for the spawning the linker on\nWindows to instead have a heuristic to see if we need to pass arguments via a\nfile. This heuristic is an overly pessimistic and \"inaccurate\" calculation which\njust calls `len` on a bunch of `OsString` instances (where `len` is not\nprecisely the length in u16 elements). This number, when exceeding the 6k\nthreshold, will force rustc to always pass arguments through a file.\n\nThis strategy should avoid us trying to parse the output on Windows of the\nlinker to see if it successfully spawned yet failed to actually sub-spawn the\nlinker. We may just be passing arguments through files a little more commonly\nnow...\n\nThe motivation for this commit was a recent bug in Gecko [1] when beta testing,\nnotably when incremental compilation was enabled it blew out the limit on\n`cmd.exe`. This commit will also fix #46999 as well though as emscripten uses a\nbat script as well (and we're blowing the limit there).\n\n[1]: https://bugzilla.mozilla.org/show_bug.cgi?id=1430886\n\nCloses #46999", "tree": {"sha": "7293dcc37403885a3c06ce0085ba1ea2344318dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7293dcc37403885a3c06ce0085ba1ea2344318dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66366f96267949cf41a992bec477e04763c42565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66366f96267949cf41a992bec477e04763c42565", "html_url": "https://github.com/rust-lang/rust/commit/66366f96267949cf41a992bec477e04763c42565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66366f96267949cf41a992bec477e04763c42565/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2a7c85757542f454934e00605355bbca7bc196", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2a7c85757542f454934e00605355bbca7bc196", "html_url": "https://github.com/rust-lang/rust/commit/ff2a7c85757542f454934e00605355bbca7bc196"}], "stats": {"total": 213, "additions": 181, "deletions": 32}, "files": [{"sha": "3b765a493e0e79a15d98982f4fbb986d7fa0b0be", "filename": "src/librustc_trans/back/command.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/66366f96267949cf41a992bec477e04763c42565/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66366f96267949cf41a992bec477e04763c42565/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=66366f96267949cf41a992bec477e04763c42565", "patch": "@@ -14,22 +14,34 @@\n use std::ffi::{OsStr, OsString};\n use std::fmt;\n use std::io;\n+use std::mem;\n use std::process::{self, Output};\n \n+#[derive(Clone)]\n pub struct Command {\n-    program: OsString,\n+    program: Program,\n     args: Vec<OsString>,\n     env: Vec<(OsString, OsString)>,\n }\n \n+#[derive(Clone)]\n+enum Program {\n+    Normal(OsString),\n+    CmdBatScript(OsString),\n+}\n+\n impl Command {\n     pub fn new<P: AsRef<OsStr>>(program: P) -> Command {\n-        Command::_new(program.as_ref())\n+        Command::_new(Program::Normal(program.as_ref().to_owned()))\n+    }\n+\n+    pub fn bat_script<P: AsRef<OsStr>>(program: P) -> Command {\n+        Command::_new(Program::CmdBatScript(program.as_ref().to_owned()))\n     }\n \n-    fn _new(program: &OsStr) -> Command {\n+    fn _new(program: Program) -> Command {\n         Command {\n-            program: program.to_owned(),\n+            program,\n             args: Vec::new(),\n             env: Vec::new(),\n         }\n@@ -82,24 +94,60 @@ impl Command {\n     }\n \n     pub fn command(&self) -> process::Command {\n-        let mut ret = process::Command::new(&self.program);\n+        let mut ret = match self.program {\n+            Program::Normal(ref p) => process::Command::new(p),\n+            Program::CmdBatScript(ref p) => {\n+                let mut c = process::Command::new(\"cmd\");\n+                c.arg(\"/c\").arg(p);\n+                c\n+            }\n+        };\n         ret.args(&self.args);\n         ret.envs(self.env.clone());\n         return ret\n     }\n \n     // extensions\n \n-    pub fn get_program(&self) -> &OsStr {\n-        &self.program\n+    pub fn take_args(&mut self) -> Vec<OsString> {\n+        mem::replace(&mut self.args, Vec::new())\n     }\n \n-    pub fn get_args(&self) -> &[OsString] {\n-        &self.args\n-    }\n+    /// Returns a `true` if we're pretty sure that this'll blow OS spawn limits,\n+    /// or `false` if we should attempt to spawn and see what the OS says.\n+    pub fn very_likely_to_exceed_some_spawn_limit(&self) -> bool {\n+        // We mostly only care about Windows in this method, on Unix the limits\n+        // can be gargantuan anyway so we're pretty unlikely to hit them\n+        if cfg!(unix) {\n+            return false\n+        }\n \n-    pub fn get_env(&self) -> &[(OsString, OsString)] {\n-        &self.env\n+        // Ok so on Windows to spawn a process is 32,768 characters in its\n+        // command line [1]. Unfortunately we don't actually have access to that\n+        // as it's calculated just before spawning. Instead we perform a\n+        // poor-man's guess as to how long our command line will be. We're\n+        // assuming here that we don't have to escape every character...\n+        //\n+        // Turns out though that `cmd.exe` has even smaller limits, 8192\n+        // characters [2]. Linkers can often be batch scripts (for example\n+        // Emscripten, Gecko's current build system) which means that we're\n+        // running through batch scripts. These linkers often just forward\n+        // arguments elsewhere (and maybe tack on more), so if we blow 8192\n+        // bytes we'll typically cause them to blow as well.\n+        //\n+        // Basically as a result just perform an inflated estimate of what our\n+        // command line will look like and test if it's > 8192 (we actually\n+        // test against 6k to artificially inflate our estimate). If all else\n+        // fails we'll fall back to the normal unix logic of testing the OS\n+        // error code if we fail to spawn and automatically re-spawning the\n+        // linker with smaller arguments.\n+        //\n+        // [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx\n+        // [2]: https://blogs.msdn.microsoft.com/oldnewthing/20031210-00/?p=41553\n+\n+        let estimated_command_line_len =\n+            self.args.iter().map(|a| a.len()).sum::<usize>();\n+        estimated_command_line_len > 1024 * 6\n     }\n }\n "}, {"sha": "923e5549927de95fe6a2832ed1f17b4ce96661a3", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/66366f96267949cf41a992bec477e04763c42565/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66366f96267949cf41a992bec477e04763c42565/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=66366f96267949cf41a992bec477e04763c42565", "patch": "@@ -36,8 +36,8 @@ use std::char;\n use std::env;\n use std::ffi::OsString;\n use std::fmt;\n-use std::fs::{self, File};\n-use std::io::{self, Write, BufWriter};\n+use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n use std::str;\n@@ -71,9 +71,7 @@ pub fn get_linker(sess: &Session) -> (PathBuf, Command, Vec<(OsString, OsString)\n     let cmd = |linker: &Path| {\n         if let Some(linker) = linker.to_str() {\n             if cfg!(windows) && linker.ends_with(\".bat\") {\n-                let mut cmd = Command::new(\"cmd\");\n-                cmd.arg(\"/c\").arg(linker);\n-                return cmd\n+                return Command::bat_script(linker)\n             }\n         }\n         Command::new(linker)\n@@ -758,26 +756,26 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n     // that contains all the arguments. The theory is that this is then\n     // accepted on all linkers and the linker will read all its options out of\n     // there instead of looking at the command line.\n-    match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n-        Ok(child) => return child.wait_with_output(),\n-        Err(ref e) if command_line_too_big(e) => {}\n-        Err(e) => return Err(e)\n+    if !cmd.very_likely_to_exceed_some_spawn_limit() {\n+        match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n+            Ok(child) => return child.wait_with_output(),\n+            Err(ref e) if command_line_too_big(e) => {}\n+            Err(e) => return Err(e)\n+        }\n     }\n \n-    let file = tmpdir.join(\"linker-arguments\");\n-    let mut cmd2 = Command::new(cmd.get_program());\n-    cmd2.arg(format!(\"@{}\", file.display()));\n-    for &(ref k, ref v) in cmd.get_env() {\n-        cmd2.env(k, v);\n-    }\n-    let mut f = BufWriter::new(File::create(&file)?);\n-    for arg in cmd.get_args() {\n-        writeln!(f, \"{}\", Escape {\n+    let mut cmd2 = cmd.clone();\n+    let mut args = String::new();\n+    for arg in cmd2.take_args() {\n+        args.push_str(&Escape {\n             arg: arg.to_str().unwrap(),\n             is_like_msvc: sess.target.target.options.is_like_msvc,\n-        })?;\n+        }.to_string());\n+        args.push_str(\"\\n\");\n     }\n-    f.into_inner()?;\n+    let file = tmpdir.join(\"linker-arguments\");\n+    fs::write(&file, args.as_bytes())?;\n+    cmd2.arg(format!(\"@{}\", file.display()));\n     return cmd2.output();\n \n     #[cfg(unix)]"}, {"sha": "debe9e93824bd92e1c36987dfd202031be1d22c6", "filename": "src/test/run-make/long-linker-command-lines-cmd-exe/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2FMakefile?ref=66366f96267949cf41a992bec477e04763c42565", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs -g\n+\tcp foo.bat $(TMPDIR)/\n+\tOUT_DIR=\"$(TMPDIR)\" RUSTC=\"$(RUSTC_ORIGINAL)\" $(call RUN,foo)"}, {"sha": "a9350f12bbb6d6e889d6a244daf87cb3aab3107d", "filename": "src/test/run-make/long-linker-command-lines-cmd-exe/foo.bat", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.bat", "raw_url": "https://github.com/rust-lang/rust/raw/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.bat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.bat?ref=66366f96267949cf41a992bec477e04763c42565", "patch": "@@ -0,0 +1 @@\n+%MY_LINKER% %*"}, {"sha": "f9168a82e225989fca3f6510296106bb9d14fad2", "filename": "src/test/run-make/long-linker-command-lines-cmd-exe/foo.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66366f96267949cf41a992bec477e04763c42565/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flong-linker-command-lines-cmd-exe%2Ffoo.rs?ref=66366f96267949cf41a992bec477e04763c42565", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Like the `long-linker-command-lines` test this test attempts to blow\n+// a command line limit for running the linker. Unlike that test, however,\n+// this test is testing `cmd.exe` specifically rather than the OS.\n+//\n+// Unfortunately `cmd.exe` has a 8192 limit which is relatively small\n+// in the grand scheme of things and anyone sripting rustc's linker\n+// is probably using a `*.bat` script and is likely to hit this limit.\n+//\n+// This test uses a `foo.bat` script as the linker which just simply\n+// delegates back to this program. The compiler should use a lower\n+// limit for arguments before passing everything via `@`, which\n+// means that everything should still succeed here.\n+\n+use std::env;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write, Read};\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    if !cfg!(windows) {\n+        return\n+    }\n+\n+    let tmpdir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+    let ok = tmpdir.join(\"ok\");\n+    let not_ok = tmpdir.join(\"not_ok\");\n+    if env::var(\"YOU_ARE_A_LINKER\").is_ok() {\n+        match env::args().find(|a| a.contains(\"@\")) {\n+            Some(file) => { fs::copy(&file[1..], &ok).unwrap(); }\n+            None => { File::create(&not_ok).unwrap(); }\n+        }\n+        return\n+    }\n+\n+    let rustc = env::var_os(\"RUSTC\").unwrap_or(\"rustc\".into());\n+    let me = env::current_exe().unwrap();\n+    let bat = me.parent()\n+        .unwrap()\n+        .join(\"foo.bat\");\n+    let bat_linker = format!(\"linker={}\", bat.display());\n+    for i in (1..).map(|i| i * 10) {\n+        println!(\"attempt: {}\", i);\n+\n+        let file = tmpdir.join(\"bar.rs\");\n+        let mut f = BufWriter::new(File::create(&file).unwrap());\n+        let mut lib_name = String::new();\n+        for _ in 0..i {\n+            lib_name.push_str(\"foo\");\n+        }\n+        for j in 0..i {\n+            writeln!(f, \"#[link(name = \\\"{}{}\\\")]\", lib_name, j).unwrap();\n+        }\n+        writeln!(f, \"extern {{}}\\nfn main() {{}}\").unwrap();\n+        f.into_inner().unwrap();\n+\n+        drop(fs::remove_file(&ok));\n+        drop(fs::remove_file(&not_ok));\n+        let status = Command::new(&rustc)\n+            .arg(&file)\n+            .arg(\"-C\").arg(&bat_linker)\n+            .arg(\"--out-dir\").arg(&tmpdir)\n+            .env(\"YOU_ARE_A_LINKER\", \"1\")\n+            .env(\"MY_LINKER\", &me)\n+            .status()\n+            .unwrap();\n+\n+        if !status.success() {\n+            panic!(\"rustc didn't succeed: {}\", status);\n+        }\n+\n+        if !ok.exists() {\n+            assert!(not_ok.exists());\n+            continue\n+        }\n+\n+        let mut contents = String::new();\n+        File::open(&ok).unwrap().read_to_string(&mut contents).unwrap();\n+\n+        for j in 0..i {\n+            assert!(contents.contains(&format!(\"{}{}\", lib_name, j)));\n+        }\n+\n+        break\n+    }\n+}"}]}