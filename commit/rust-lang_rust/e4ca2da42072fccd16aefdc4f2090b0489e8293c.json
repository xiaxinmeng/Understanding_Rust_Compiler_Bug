{"sha": "e4ca2da42072fccd16aefdc4f2090b0489e8293c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0Y2EyZGE0MjA3MmZjY2QxNmFlZmRjNGYyMDkwYjA0ODllODI5M2M=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-29T02:51:21Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-29T04:49:27Z"}, "message": "libstd: remove implicit copying of BigInt/BigUint", "tree": {"sha": "e934b46278206b84d0e8a1e4ec187352842d8888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e934b46278206b84d0e8a1e4ec187352842d8888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4ca2da42072fccd16aefdc4f2090b0489e8293c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ca2da42072fccd16aefdc4f2090b0489e8293c", "html_url": "https://github.com/rust-lang/rust/commit/e4ca2da42072fccd16aefdc4f2090b0489e8293c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4ca2da42072fccd16aefdc4f2090b0489e8293c/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "html_url": "https://github.com/rust-lang/rust/commit/7b7a0fc235cd2e0782302cd6fb83634e190b15b7"}], "stats": {"total": 57, "additions": 37, "deletions": 20}, "files": [{"sha": "74e5b00d896514a6aeeb8eedbef58a02abfef73c", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4ca2da42072fccd16aefdc4f2090b0489e8293c/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4ca2da42072fccd16aefdc4f2090b0489e8293c/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=e4ca2da42072fccd16aefdc4f2090b0489e8293c", "patch": "@@ -16,6 +16,9 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n+#[deny(vecs_implicitly_copyable)];\n+#[deny(deprecated_mutable_fields)];\n+\n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix};\n use core::*;\n@@ -355,16 +358,24 @@ impl Integer for BigUint {\n                 let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n                 let mut prod = b * d0;\n                 while prod > m {\n-                    d0   -= d_unit;\n-                    prod -= b_unit;\n+                    // FIXME(#6050): overloaded operators force moves with generic types\n+                    // d0 -= d_unit\n+                    d0   = d0 - d_unit;\n+                    // FIXME(#6050): overloaded operators force moves with generic types\n+                    // prod = prod - b_unit;\n+                    prod = prod - b_unit\n                 }\n                 if d0.is_zero() {\n                     n = 2;\n                     loop;\n                 }\n                 n = 1;\n-                d += d0;\n-                m -= prod;\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // d += d0;\n+                d = d + d0;\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // m -= prod;\n+                m = m - prod;\n             }\n             return (d, m);\n         }\n@@ -411,7 +422,7 @@ impl Integer for BigUint {\n     #[inline(always)]\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = *other;\n+        let mut m = copy *self, n = copy *other;\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -547,14 +558,18 @@ impl BigUint {\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n-                Some(d) => n += BigUint::from_uint(d) * power,\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // Some(d) => n += BigUint::from_uint(d) * power,\n+                Some(d) => n = n + BigUint::from_uint(d) * power,\n                 None    => return None\n             }\n             if end <= unit_len {\n                 return Some(n);\n             }\n             end -= unit_len;\n-            power *= base_num;\n+            // FIXME(#6050): overloaded operators force moves with generic types\n+            // power *= base_num;\n+            power = power * base_num;\n         }\n     }\n \n@@ -569,15 +584,15 @@ impl BigUint {\n     }\n \n     #[inline(always)]\n-    priv fn shl_unit(self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return self; }\n+    priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return copy *self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n     #[inline(always)]\n-    priv fn shl_bits(self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return self; }\n+    priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n         let shifted = do vec::map(self.data) |elem| {\n@@ -592,17 +607,17 @@ impl BigUint {\n     }\n \n     #[inline(always)]\n-    priv fn shr_unit(self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return self; }\n+    priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::slice(self.data, n_unit, self.data.len())\n         );\n     }\n \n     #[inline(always)]\n-    priv fn shr_bits(self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return self; }\n+    priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return copy *self; }\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n@@ -1070,7 +1085,7 @@ pub impl BigInt {\n             start = 1;\n         }\n         return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n-            .map(|bu| BigInt::from_biguint(sign, *bu));\n+            .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n     #[inline(always)]\n@@ -1376,10 +1391,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if !a.is_zero() {\n-                assert!(c.quot_rem(&a) == (b, Zero::zero()));\n+                assert!(c.quot_rem(&a) == (copy b, Zero::zero()));\n             }\n             if !b.is_zero() {\n-                assert!(c.quot_rem(&b) == (a, Zero::zero()));\n+                assert!(c.quot_rem(&b) == (copy a, Zero::zero()));\n             }\n         }\n \n@@ -1503,7 +1518,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert_eq!(Some(n), FromStrRadix::from_str_radix(str, radix));\n+                assert_eq!(&n, &FromStrRadix::from_str_radix(str, radix).get());\n             }\n         }\n \n@@ -1517,7 +1532,9 @@ mod biguint_tests {\n         fn factor(n: uint) -> BigUint {\n             let mut f= One::one::<BigUint>();\n             for uint::range(2, n + 1) |i| {\n-                f *= BigUint::from_uint(i);\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // f *= BigUint::from_uint(i);\n+                f = f * BigUint::from_uint(i);\n             }\n             return f;\n         }"}]}