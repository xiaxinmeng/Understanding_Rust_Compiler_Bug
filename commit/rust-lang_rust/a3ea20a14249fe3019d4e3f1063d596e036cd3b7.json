{"sha": "a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "node_id": "C_kwDOAAsO6NoAKGEzZWEyMGExNDI0OWZlMzAxOWQ0ZTNmMTA2M2Q1OTZlMDM2Y2QzYjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T13:58:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T13:58:28Z"}, "message": "Auto merge of #13725 - bvanjoi:resolve-const-triat-impls, r=flodiebold\n\nfeat: resolve const for trait impls\n\nFixed #13694", "tree": {"sha": "3f93c0393c7130ae650127b3659919a0546d691f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f93c0393c7130ae650127b3659919a0546d691f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "html_url": "https://github.com/rust-lang/rust/commit/a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "632f80479763b325b396ac6633cad5235379a47d", "url": "https://api.github.com/repos/rust-lang/rust/commits/632f80479763b325b396ac6633cad5235379a47d", "html_url": "https://github.com/rust-lang/rust/commit/632f80479763b325b396ac6633cad5235379a47d"}, {"sha": "7012b50db532d8c411040e51158153b4ea2f5a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/7012b50db532d8c411040e51158153b4ea2f5a63", "html_url": "https://github.com/rust-lang/rust/commit/7012b50db532d8c411040e51158153b4ea2f5a63"}], "stats": {"total": 263, "additions": 245, "deletions": 18}, "files": [{"sha": "e4714f5ab9e080022c92938e2a57292cca1d0b7c", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -351,6 +351,7 @@ pub fn eval_const(\n                         .infer\n                         .assoc_resolutions_for_expr(expr_id)\n                         .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n+                        .0\n                     {\n                         hir_def::AssocItemId::FunctionId(_) => {\n                             Err(ConstEvalError::NotSupported(\"assoc function\"))"}, {"sha": "6df64ceee6d8ae0a7440ac52f7065ef2a1b042fa", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -349,7 +349,7 @@ pub struct InferenceResult {\n     /// For each struct literal or pattern, records the variant it resolves to.\n     variant_resolutions: FxHashMap<ExprOrPatId, VariantId>,\n     /// For each associated item record what it resolves to\n-    assoc_resolutions: FxHashMap<ExprOrPatId, AssocItemId>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, (AssocItemId, Option<Substitution>)>,\n     pub diagnostics: Vec<InferenceDiagnostic>,\n     pub type_of_expr: ArenaMap<ExprId, Ty>,\n     /// For each pattern record the type it resolves to.\n@@ -379,11 +379,17 @@ impl InferenceResult {\n     pub fn variant_resolution_for_pat(&self, id: PatId) -> Option<VariantId> {\n         self.variant_resolutions.get(&id.into()).copied()\n     }\n-    pub fn assoc_resolutions_for_expr(&self, id: ExprId) -> Option<AssocItemId> {\n-        self.assoc_resolutions.get(&id.into()).copied()\n+    pub fn assoc_resolutions_for_expr(\n+        &self,\n+        id: ExprId,\n+    ) -> Option<(AssocItemId, Option<Substitution>)> {\n+        self.assoc_resolutions.get(&id.into()).cloned()\n     }\n-    pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<AssocItemId> {\n-        self.assoc_resolutions.get(&id.into()).copied()\n+    pub fn assoc_resolutions_for_pat(\n+        &self,\n+        id: PatId,\n+    ) -> Option<(AssocItemId, Option<Substitution>)> {\n+        self.assoc_resolutions.get(&id.into()).cloned()\n     }\n     pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(&expr.into())\n@@ -647,8 +653,13 @@ impl<'a> InferenceContext<'a> {\n         self.result.variant_resolutions.insert(id, variant);\n     }\n \n-    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: AssocItemId) {\n-        self.result.assoc_resolutions.insert(id, item);\n+    fn write_assoc_resolution(\n+        &mut self,\n+        id: ExprOrPatId,\n+        item: AssocItemId,\n+        subs: Option<Substitution>,\n+    ) {\n+        self.result.assoc_resolutions.insert(id, (item, subs));\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {"}, {"sha": "c1666c60e9792dc3444d559eec0559e6f535ee18", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -212,7 +212,7 @@ impl<'a> InferenceContext<'a> {\n             AssocItemId::TypeAliasId(_) => unreachable!(),\n         };\n \n-        self.write_assoc_resolution(id, item);\n+        self.write_assoc_resolution(id, item, Some(trait_ref.substitution.clone()));\n         Some((def, Some(trait_ref.substitution)))\n     }\n \n@@ -273,7 +273,7 @@ impl<'a> InferenceContext<'a> {\n                     ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => None,\n                 };\n \n-                self.write_assoc_resolution(id, item);\n+                self.write_assoc_resolution(id, item, substs.clone());\n                 Some((def, substs))\n             },\n         )"}, {"sha": "882f1afc1f855e0de450b622c5dd50bc473e7922", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -642,6 +642,30 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+pub fn lookup_impl_const(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    const_id: ConstId,\n+    subs: Substitution,\n+) -> ConstId {\n+    let trait_id = match const_id.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return const_id,\n+    };\n+    let substitution = Substitution::from_iter(Interner, subs.iter(Interner));\n+    let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution };\n+\n+    let const_data = db.const_data(const_id);\n+    let name = match const_data.name.as_ref() {\n+        Some(name) => name,\n+        None => return const_id,\n+    };\n+\n+    lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n+        .and_then(|assoc| if let AssocItemId::ConstId(id) = assoc { Some(id) } else { None })\n+        .unwrap_or(const_id)\n+}\n+\n /// Looks up the impl method that actually runs for the trait method `func`.\n ///\n /// Returns `func` if it's not a method defined in a trait or the lookup failed.\n@@ -663,15 +687,17 @@ pub fn lookup_impl_method(\n     };\n \n     let name = &db.function_data(func).name;\n-    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+    lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n+        .and_then(|assoc| if let AssocItemId::FunctionId(id) = assoc { Some(id) } else { None })\n+        .unwrap_or(func)\n }\n \n-fn lookup_impl_method_for_trait_ref(\n+fn lookup_impl_assoc_item_for_trait_ref(\n     trait_ref: TraitRef,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     name: &Name,\n-) -> Option<FunctionId> {\n+) -> Option<AssocItemId> {\n     let self_ty = trait_ref.self_type_parameter(Interner);\n     let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n     let impls = db.trait_impls_in_deps(env.krate);\n@@ -681,7 +707,15 @@ fn lookup_impl_method_for_trait_ref(\n \n     let impl_data = find_matching_impl(impls, table, trait_ref)?;\n     impl_data.items.iter().find_map(|it| match it {\n-        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        AssocItemId::FunctionId(f) => {\n+            (db.function_data(*f).name == *name).then(|| AssocItemId::FunctionId(*f))\n+        }\n+        AssocItemId::ConstId(c) => db\n+            .const_data(*c)\n+            .name\n+            .as_ref()\n+            .map(|n| *n == *name)\n+            .and_then(|result| if result { Some(AssocItemId::ConstId(*c)) } else { None }),\n         _ => None,\n     })\n }"}, {"sha": "a362570dd8bacf6156b38f7d4777c1a163b5987b", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -21,8 +21,8 @@ use hir_def::{\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n-    AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, TraitId, VariantId,\n+    AsMacroCall, AssocItemId, ConstId, DefWithBodyId, FieldId, FunctionId, ItemContainerId,\n+    LocalFieldId, Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -482,7 +482,7 @@ impl SourceAnalyzer {\n             let infer = self.infer.as_deref()?;\n             if let Some(path_expr) = parent().and_then(ast::PathExpr::cast) {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n-                if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n+                if let Some((assoc, subs)) = infer.assoc_resolutions_for_expr(expr_id) {\n                     let assoc = match assoc {\n                         AssocItemId::FunctionId(f_in_trait) => {\n                             match infer.type_of_expr.get(expr_id) {\n@@ -501,7 +501,13 @@ impl SourceAnalyzer {\n                                 }\n                             }\n                         }\n-\n+                        AssocItemId::ConstId(const_id) => {\n+                            if let Some(subs) = subs {\n+                                self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n+                            } else {\n+                                assoc\n+                            }\n+                        }\n                         _ => assoc,\n                     };\n \n@@ -515,7 +521,7 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some(assoc) = infer.assoc_resolutions_for_pat(pat_id) {\n+                if let Some((assoc, _)) = infer.assoc_resolutions_for_pat(pat_id) {\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n@@ -792,6 +798,24 @@ impl SourceAnalyzer {\n         method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n+    fn resolve_impl_const_or_trait_def(\n+        &self,\n+        db: &dyn HirDatabase,\n+        const_id: ConstId,\n+        subs: Substitution,\n+    ) -> ConstId {\n+        let krate = self.resolver.krate();\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return const_id,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n+            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n+            |d| db.trait_environment(d),\n+        );\n+        method_resolution::lookup_impl_const(db, env, const_id, subs)\n+    }\n+\n     fn lang_trait_fn(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "62404afc4b7d3743953eeedb1847b1dcfe5ce078", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea20a14249fe3019d4e3f1063d596e036cd3b7/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=a3ea20a14249fe3019d4e3f1063d596e036cd3b7", "patch": "@@ -3657,6 +3657,163 @@ enum E {\n \n #[test]\n fn hover_const_eval() {\n+    check(\n+        r#\"\n+trait T {\n+    const B: bool = false;\n+}\n+impl T for <()> {\n+    /// true\n+    const B: bool = true;\n+}\n+fn main() {\n+    <()>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+        *B*\n+\n+        ```rust\n+        test\n+        ```\n+\n+        ```rust\n+        const B: bool = true\n+        ```\n+\n+        ---\n+\n+        true\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct A {\n+    i: i32\n+};\n+\n+trait T {\n+    const AA: A = A {\n+        i: 1\n+    };\n+}\n+impl T for i32 {\n+    const AA: A = A {\n+        i: 2\n+    }\n+}\n+fn main() {\n+    <i32>::AA$0;\n+}\n+\"#,\n+        expect![[r#\"\n+        *AA*\n+\n+        ```rust\n+        test\n+        ```\n+\n+        ```rust\n+        const AA: A = A {\n+                i: 2\n+            }\n+        ```\n+    \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+    /// true\n+    const B: bool = true;\n+}\n+fn main() {\n+    T::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+}\n+fn main() {\n+    <()>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait T {\n+    /// false\n+    const B: bool = false;\n+}\n+impl T for () {\n+    /// true\n+    const B: bool = true;\n+}\n+impl T for i32 {}\n+fn main() {\n+    <i32>::B$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *B*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const B: bool = false\n+            ```\n+\n+            ---\n+\n+            false\n+        \"#]],\n+    );\n+\n     // show hex for <10\n     check(\n         r#\""}]}