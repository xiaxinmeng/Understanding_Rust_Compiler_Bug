{"sha": "86c86c37429e95aee45846262bb50239a69be546", "node_id": "C_kwDOAAsO6NoAKDg2Yzg2YzM3NDI5ZTk1YWVlNDU4NDYyNjJiYjUwMjM5YTY5YmU1NDY", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-05T13:44:01Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2022-10-05T13:44:06Z"}, "message": "Add `disallowed_macros` lint", "tree": {"sha": "8cb0c81c1608eb25296f6d7862ccdab93f4e3fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cb0c81c1608eb25296f6d7862ccdab93f4e3fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c86c37429e95aee45846262bb50239a69be546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c86c37429e95aee45846262bb50239a69be546", "html_url": "https://github.com/rust-lang/rust/commit/86c86c37429e95aee45846262bb50239a69be546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c86c37429e95aee45846262bb50239a69be546/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425e1ea73d1e67c38c1d12e160d5fd20b64ffa5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/425e1ea73d1e67c38c1d12e160d5fd20b64ffa5d", "html_url": "https://github.com/rust-lang/rust/commit/425e1ea73d1e67c38c1d12e160d5fd20b64ffa5d"}], "stats": {"total": 610, "additions": 500, "deletions": 110}, "files": [{"sha": "42615179f7053073fce07a19319a24216b159865", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -3820,6 +3820,7 @@ Released 2018-09-13\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`derive_partial_eq_without_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_partial_eq_without_eq\n+[`disallowed_macros`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_macros\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n [`disallowed_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_methods\n [`disallowed_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_names"}, {"sha": "34717811866d87fc0cb68922dc838d3548ccd3db", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -1,14 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n \n-use crate::utils::conf::DisallowedType;\n+use crate::utils::conf::DisallowedPath;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -171,12 +172,12 @@ impl_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF,\n \n #[derive(Debug)]\n pub struct AwaitHolding {\n-    conf_invalid_types: Vec<DisallowedType>,\n-    def_ids: FxHashMap<DefId, DisallowedType>,\n+    conf_invalid_types: Vec<DisallowedPath>,\n+    def_ids: FxHashMap<DefId, DisallowedPath>,\n }\n \n impl AwaitHolding {\n-    pub(crate) fn new(conf_invalid_types: Vec<DisallowedType>) -> Self {\n+    pub(crate) fn new(conf_invalid_types: Vec<DisallowedPath>) -> Self {\n         Self {\n             conf_invalid_types,\n             def_ids: FxHashMap::default(),\n@@ -187,11 +188,8 @@ impl AwaitHolding {\n impl LateLintPass<'_> for AwaitHolding {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_invalid_types {\n-            let path = match conf {\n-                DisallowedType::Simple(path) | DisallowedType::WithReason { path, .. } => path,\n-            };\n-            let segs: Vec<_> = path.split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n                 self.def_ids.insert(id, conf.clone());\n             }\n         }\n@@ -256,20 +254,18 @@ impl AwaitHolding {\n     }\n }\n \n-fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedType) {\n-    let (type_name, reason) = match disallowed {\n-        DisallowedType::Simple(path) => (path, &None),\n-        DisallowedType::WithReason { path, reason } => (path, reason),\n-    };\n-\n+fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedPath) {\n     span_lint_and_then(\n         cx,\n         AWAIT_HOLDING_INVALID_TYPE,\n         span,\n-        &format!(\"`{type_name}` may not be held across an `await` point per `clippy.toml`\",),\n+        &format!(\n+            \"`{}` may not be held across an `await` point per `clippy.toml`\",\n+            disallowed.path()\n+        ),\n         |diag| {\n-            if let Some(reason) = reason {\n-                diag.note(reason.clone());\n+            if let Some(reason) = disallowed.reason() {\n+                diag.note(reason);\n             }\n         },\n     );"}, {"sha": "5ab7144e29098b7d4a877804d8dab723943f65c5", "filename": "clippy_lints/src/disallowed_macros.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_macros.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,151 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::macro_backtrace;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefIdMap;\n+use rustc_hir::{Expr, ForeignItem, HirId, ImplItem, Item, Pat, Path, Stmt, TraitItem, Ty};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{ExpnId, Span};\n+\n+use crate::utils::conf;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Denies the configured macros in clippy.toml\n+    ///\n+    /// Note: Even though this lint is warn-by-default, it will only trigger if\n+    /// macros are defined in the clippy.toml file.\n+    ///\n+    /// ### Why is this bad?\n+    /// Some macros are undesirable in certain contexts, and it's beneficial to\n+    /// lint for them as needed.\n+    ///\n+    /// ### Example\n+    /// An example clippy.toml configuration:\n+    /// ```toml\n+    /// # clippy.toml\n+    /// disallowed-macros = [\n+    ///     # Can use a string as the path of the disallowed macro.\n+    ///     \"std::print\",\n+    ///     # Can also use an inline table with a `path` key.\n+    ///     { path = \"std::println\" },\n+    ///     # When using an inline table, can add a `reason` for why the macro\n+    ///     # is disallowed.\n+    ///     { path = \"serde::Serialize\", reason = \"no serializing\" },\n+    /// ]\n+    /// ```\n+    /// ```\n+    /// use serde::Serialize;\n+    ///\n+    /// // Example code where clippy issues a warning\n+    /// println!(\"warns\");\n+    ///\n+    /// // The diagnostic will contain the message \"no serializing\"\n+    /// #[derive(Serialize)]\n+    /// struct Data {\n+    ///     name: String,\n+    ///     value: usize,\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub DISALLOWED_MACROS,\n+    style,\n+    \"use of a disallowed macro\"\n+}\n+\n+pub struct DisallowedMacros {\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n+    disallowed: DefIdMap<usize>,\n+    seen: FxHashSet<ExpnId>,\n+}\n+\n+impl DisallowedMacros {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n+        Self {\n+            conf_disallowed,\n+            disallowed: DefIdMap::default(),\n+            seen: FxHashSet::default(),\n+        }\n+    }\n+\n+    fn check(&mut self, cx: &LateContext<'_>, span: Span) {\n+        if self.conf_disallowed.is_empty() {\n+            return;\n+        }\n+\n+        for mac in macro_backtrace(span) {\n+            if !self.seen.insert(mac.expn) {\n+                return;\n+            }\n+\n+            if let Some(&index) = self.disallowed.get(&mac.def_id) {\n+                let conf = &self.conf_disallowed[index];\n+\n+                span_lint_and_then(\n+                    cx,\n+                    DISALLOWED_MACROS,\n+                    mac.span,\n+                    &format!(\"use of a disallowed macro `{}`\", conf.path()),\n+                    |diag| {\n+                        if let Some(reason) = conf.reason() {\n+                            diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(DisallowedMacros => [DISALLOWED_MACROS]);\n+\n+impl LateLintPass<'_> for DisallowedMacros {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        for (index, conf) in self.conf_disallowed.iter().enumerate() {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::MacroNS)) {\n+                self.disallowed.insert(id, index);\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        self.check(cx, expr.span);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n+        self.check(cx, stmt.span);\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'_>, ty: &Ty<'_>) {\n+        self.check(cx, ty.span);\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'_>, pat: &Pat<'_>) {\n+        self.check(cx, pat.span);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, item: &ForeignItem<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &ImplItem<'_>) {\n+        self.check(cx, item.span);\n+        self.check(cx, item.vis_span);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+        self.check(cx, item.span);\n+    }\n+\n+    fn check_path(&mut self, cx: &LateContext<'_>, path: &Path<'_>, _: HirId) {\n+        self.check(cx, path.span);\n+    }\n+}"}, {"sha": "1a381f92c0314f7c06048682e984665c213f4aeb", "filename": "clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{fn_def_id, get_parent_expr, path_def_id};\n \n-use rustc_hir::{def::Res, def_id::DefIdMap, Expr, ExprKind};\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefIdMap;\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -58,12 +60,12 @@ declare_clippy_lint! {\n \n #[derive(Clone, Debug)]\n pub struct DisallowedMethods {\n-    conf_disallowed: Vec<conf::DisallowedMethod>,\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n     disallowed: DefIdMap<usize>,\n }\n \n impl DisallowedMethods {\n-    pub fn new(conf_disallowed: Vec<conf::DisallowedMethod>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n         Self {\n             conf_disallowed,\n             disallowed: DefIdMap::default(),\n@@ -77,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::ValueNS)) {\n                 self.disallowed.insert(id, index);\n             }\n         }\n@@ -102,10 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n         };\n         let msg = format!(\"use of a disallowed method `{}`\", conf.path());\n         span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n-            if let conf::DisallowedMethod::WithReason {\n-                reason: Some(reason), ..\n-            } = conf\n-            {\n+            if let Some(reason) = conf.reason() {\n                 diag.note(&format!(\"{reason} (from clippy.toml)\"));\n             }\n         });"}, {"sha": "c7131fc164d3e47d08feb845f720245d9e94e829", "filename": "clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{def::Res, def_id::DefId, Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind};\n+use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -50,13 +52,13 @@ declare_clippy_lint! {\n }\n #[derive(Clone, Debug)]\n pub struct DisallowedTypes {\n-    conf_disallowed: Vec<conf::DisallowedType>,\n+    conf_disallowed: Vec<conf::DisallowedPath>,\n     def_ids: FxHashMap<DefId, Option<String>>,\n     prim_tys: FxHashMap<PrimTy, Option<String>>,\n }\n \n impl DisallowedTypes {\n-    pub fn new(conf_disallowed: Vec<conf::DisallowedType>) -> Self {\n+    pub fn new(conf_disallowed: Vec<conf::DisallowedPath>) -> Self {\n         Self {\n             conf_disallowed,\n             def_ids: FxHashMap::default(),\n@@ -86,15 +88,9 @@ impl_lint_pass!(DisallowedTypes => [DISALLOWED_TYPES]);\n impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_disallowed {\n-            let (path, reason) = match conf {\n-                conf::DisallowedType::Simple(path) => (path, None),\n-                conf::DisallowedType::WithReason { path, reason } => (\n-                    path,\n-                    reason.as_ref().map(|reason| format!(\"{reason} (from clippy.toml)\")),\n-                ),\n-            };\n-            let segs: Vec<_> = path.split(\"::\").collect();\n-            match clippy_utils::def_path_res(cx, &segs) {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n+            let reason = conf.reason().map(|reason| format!(\"{reason} (from clippy.toml)\"));\n+            match clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n                 Res::Def(_, id) => {\n                     self.def_ids.insert(id, reason);\n                 },"}, {"sha": "5d26e4b336012d91f59d6859ae42a89c3204d644", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -45,6 +45,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n+    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_names::DISALLOWED_NAMES),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),"}, {"sha": "05d927dbea7942448898c45ee8cda13db461490c", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -114,6 +114,7 @@ store.register_lints(&[\n     derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n     derive::EXPL_IMPL_CLONE_ON_COPY,\n     derive::UNSAFE_DERIVE_DESERIALIZE,\n+    disallowed_macros::DISALLOWED_MACROS,\n     disallowed_methods::DISALLOWED_METHODS,\n     disallowed_names::DISALLOWED_NAMES,\n     disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS,"}, {"sha": "8e1390167dc81fd1e7bfd856ee63d6fea4b19577", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -15,6 +15,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n     LintId::of(dereference::NEEDLESS_BORROW),\n+    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_names::DISALLOWED_NAMES),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),"}, {"sha": "2dcefd78763b7f24013f2cd2b6d59cdb628d2cb2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -199,6 +199,7 @@ mod default_union_representation;\n mod dereference;\n mod derivable_impls;\n mod derive;\n+mod disallowed_macros;\n mod disallowed_methods;\n mod disallowed_names;\n mod disallowed_script_idents;\n@@ -820,6 +821,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(unwrap_in_result::UnwrapInResult));\n     store.register_late_pass(|_| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|_| Box::new(async_yields_async::AsyncYieldsAsync));\n+    let disallowed_macros = conf.disallowed_macros.clone();\n+    store.register_late_pass(move |_| Box::new(disallowed_macros::DisallowedMacros::new(disallowed_macros.clone())));\n     let disallowed_methods = conf.disallowed_methods.clone();\n     store.register_late_pass(move |_| Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));"}, {"sha": "872679f25ab5a777364c7c3ee8a1dfbe1a4d015d", "filename": "clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -58,7 +58,8 @@ impl_lint_pass!(ImportRename => [MISSING_ENFORCED_IMPORT_RENAMES]);\n impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n+            let segs = path.split(\"::\").collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, None) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }"}, {"sha": "668123e4d6e394e5e73f7f0fb9b2ec6a990de8f2", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -39,28 +39,28 @@ pub struct Rename {\n     pub rename: String,\n }\n \n-/// A single disallowed method, used by the `DISALLOWED_METHODS` lint.\n #[derive(Clone, Debug, Deserialize)]\n #[serde(untagged)]\n-pub enum DisallowedMethod {\n+pub enum DisallowedPath {\n     Simple(String),\n     WithReason { path: String, reason: Option<String> },\n }\n \n-impl DisallowedMethod {\n+impl DisallowedPath {\n     pub fn path(&self) -> &str {\n         let (Self::Simple(path) | Self::WithReason { path, .. }) = self;\n \n         path\n     }\n-}\n \n-/// A single disallowed type, used by the `DISALLOWED_TYPES` lint.\n-#[derive(Clone, Debug, Deserialize)]\n-#[serde(untagged)]\n-pub enum DisallowedType {\n-    Simple(String),\n-    WithReason { path: String, reason: Option<String> },\n+    pub fn reason(&self) -> Option<&str> {\n+        match self {\n+            Self::WithReason {\n+                reason: Some(reason), ..\n+            } => Some(reason),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Conf with parse errors\n@@ -315,14 +315,18 @@ define_Conf! {\n     ///\n     /// Whether to allow certain wildcard imports (prelude, super in tests).\n     (warn_on_all_wildcard_imports: bool = false),\n+    /// Lint: DISALLOWED_MACROS.\n+    ///\n+    /// The list of disallowed macros, written as fully qualified paths.\n+    (disallowed_macros: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: DISALLOWED_METHODS.\n     ///\n     /// The list of disallowed methods, written as fully qualified paths.\n-    (disallowed_methods: Vec<crate::utils::conf::DisallowedMethod> = Vec::new()),\n+    (disallowed_methods: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: DISALLOWED_TYPES.\n     ///\n     /// The list of disallowed types, written as fully qualified paths.\n-    (disallowed_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n+    (disallowed_types: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL.\n     ///\n     /// Should the fraction of a decimal be linted to include separators.\n@@ -362,7 +366,7 @@ define_Conf! {\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n     /// Lint: AWAIT_HOLDING_INVALID_TYPE\n-    (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n+    (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedPath> = Vec::new()),\n     /// Lint: LARGE_INCLUDE_FILE.\n     ///\n     /// The maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes"}, {"sha": "85bcbc7ad236966d9ec406e6caadc69432c3b1fb", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -15,7 +15,7 @@ use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::Visitor;\n@@ -920,7 +920,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, item_arg);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = def_path_res(cx, &segments[..]).opt_def_id();\n+            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n             then {\n                 // def_path_res will match field names before anything else, but for this we want to match\n                 // inherent functions first.\n@@ -952,7 +952,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n                         Item::DiagnosticItem(*item_name),\n                     )\n                 } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"]).def_id();\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n                     let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n                     (\n                         \"use of a def path to a `LangItem`\",\n@@ -1115,7 +1115,7 @@ fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path) != Res::Err {\n+    if def_path_res(cx, path, None) != Res::Err {\n         return true;\n     }\n \n@@ -1206,7 +1206,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module).opt_def_id() {\n+            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "3919851932923d3573267ad26f7251d703cae0a0", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -78,7 +78,7 @@ use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n@@ -522,15 +522,49 @@ pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>\n     path_res(cx, maybe_path).opt_def_id()\n }\n \n-/// Resolves a def path like `std::vec::Vec`.\n+fn find_primitive<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n+    let single = |ty| tcx.incoherent_impls(ty).iter().copied();\n+    let empty = || [].iter().copied();\n+    match name {\n+        \"bool\" => single(BoolSimplifiedType),\n+        \"char\" => single(CharSimplifiedType),\n+        \"str\" => single(StrSimplifiedType),\n+        \"array\" => single(ArraySimplifiedType),\n+        \"slice\" => single(SliceSimplifiedType),\n+        // FIXME: rustdoc documents these two using just `pointer`.\n+        //\n+        // Maybe this is something we should do here too.\n+        \"const_ptr\" => single(PtrSimplifiedType(Mutability::Not)),\n+        \"mut_ptr\" => single(PtrSimplifiedType(Mutability::Mut)),\n+        \"isize\" => single(IntSimplifiedType(IntTy::Isize)),\n+        \"i8\" => single(IntSimplifiedType(IntTy::I8)),\n+        \"i16\" => single(IntSimplifiedType(IntTy::I16)),\n+        \"i32\" => single(IntSimplifiedType(IntTy::I32)),\n+        \"i64\" => single(IntSimplifiedType(IntTy::I64)),\n+        \"i128\" => single(IntSimplifiedType(IntTy::I128)),\n+        \"usize\" => single(UintSimplifiedType(UintTy::Usize)),\n+        \"u8\" => single(UintSimplifiedType(UintTy::U8)),\n+        \"u16\" => single(UintSimplifiedType(UintTy::U16)),\n+        \"u32\" => single(UintSimplifiedType(UintTy::U32)),\n+        \"u64\" => single(UintSimplifiedType(UintTy::U64)),\n+        \"u128\" => single(UintSimplifiedType(UintTy::U128)),\n+        \"f32\" => single(FloatSimplifiedType(FloatTy::F32)),\n+        \"f64\" => single(FloatSimplifiedType(FloatTy::F64)),\n+        _ => empty(),\n+    }\n+}\n+\n+/// Resolves a def path like `std::vec::Vec`. `namespace_hint` can be supplied to disambiguate\n+/// between `std::vec` the module and `std::vec` the macro\n+///\n /// This function is expensive and should be used sparingly.\n-pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n-    fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Option<Res> {\n+pub fn def_path_res(cx: &LateContext<'_>, path: &[&str], namespace_hint: Option<Namespace>) -> Res {\n+    fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str, matches_ns: impl Fn(Res) -> bool) -> Option<Res> {\n         match tcx.def_kind(def_id) {\n             DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n                 .module_children(def_id)\n                 .iter()\n-                .find(|item| item.ident.name.as_str() == name)\n+                .find(|item| item.ident.name.as_str() == name && matches_ns(item.res.expect_non_local()))\n                 .map(|child| child.res.expect_non_local()),\n             DefKind::Impl => tcx\n                 .associated_item_def_ids(def_id)\n@@ -548,37 +582,7 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             _ => None,\n         }\n     }\n-    fn find_primitive<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n-        let single = |ty| tcx.incoherent_impls(ty).iter().copied();\n-        let empty = || [].iter().copied();\n-        match name {\n-            \"bool\" => single(BoolSimplifiedType),\n-            \"char\" => single(CharSimplifiedType),\n-            \"str\" => single(StrSimplifiedType),\n-            \"array\" => single(ArraySimplifiedType),\n-            \"slice\" => single(SliceSimplifiedType),\n-            // FIXME: rustdoc documents these two using just `pointer`.\n-            //\n-            // Maybe this is something we should do here too.\n-            \"const_ptr\" => single(PtrSimplifiedType(Mutability::Not)),\n-            \"mut_ptr\" => single(PtrSimplifiedType(Mutability::Mut)),\n-            \"isize\" => single(IntSimplifiedType(IntTy::Isize)),\n-            \"i8\" => single(IntSimplifiedType(IntTy::I8)),\n-            \"i16\" => single(IntSimplifiedType(IntTy::I16)),\n-            \"i32\" => single(IntSimplifiedType(IntTy::I32)),\n-            \"i64\" => single(IntSimplifiedType(IntTy::I64)),\n-            \"i128\" => single(IntSimplifiedType(IntTy::I128)),\n-            \"usize\" => single(UintSimplifiedType(UintTy::Usize)),\n-            \"u8\" => single(UintSimplifiedType(UintTy::U8)),\n-            \"u16\" => single(UintSimplifiedType(UintTy::U16)),\n-            \"u32\" => single(UintSimplifiedType(UintTy::U32)),\n-            \"u64\" => single(UintSimplifiedType(UintTy::U64)),\n-            \"u128\" => single(UintSimplifiedType(UintTy::U128)),\n-            \"f32\" => single(FloatSimplifiedType(FloatTy::F32)),\n-            \"f64\" => single(FloatSimplifiedType(FloatTy::F64)),\n-            _ => empty(),\n-        }\n-    }\n+\n     fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n         tcx.crates(())\n             .iter()\n@@ -587,32 +591,45 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             .map(CrateNum::as_def_id)\n     }\n \n-    let (base, first, path) = match *path {\n-        [base, first, ref path @ ..] => (base, first, path),\n+    let (base, path) = match *path {\n         [primitive] => {\n             return PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy);\n         },\n+        [base, ref path @ ..] => (base, path),\n         _ => return Res::Err,\n     };\n     let tcx = cx.tcx;\n     let starts = find_primitive(tcx, base)\n         .chain(find_crate(tcx, base))\n-        .filter_map(|id| item_child_by_name(tcx, id, first));\n+        .map(|id| Res::Def(tcx.def_kind(id), id));\n \n     for first in starts {\n         let last = path\n             .iter()\n             .copied()\n+            .enumerate()\n             // for each segment, find the child item\n-            .try_fold(first, |res, segment| {\n+            .try_fold(first, |res, (idx, segment)| {\n+                let matches_ns = |res: Res| {\n+                    // If at the last segment in the path, respect the namespace hint\n+                    if idx == path.len() - 1 {\n+                        match namespace_hint {\n+                            Some(ns) => res.matches_ns(ns),\n+                            None => true,\n+                        }\n+                    } else {\n+                        res.matches_ns(Namespace::TypeNS)\n+                    }\n+                };\n+\n                 let def_id = res.def_id();\n-                if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n+                if let Some(item) = item_child_by_name(tcx, def_id, segment, matches_ns) {\n                     Some(item)\n                 } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n                     // it is not a child item so check inherent impl items\n                     tcx.inherent_impls(def_id)\n                         .iter()\n-                        .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n+                        .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment, matches_ns))\n                 } else {\n                     None\n                 }\n@@ -628,8 +645,10 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n \n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n+///\n+/// This function is expensive and should be used sparingly.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match def_path_res(cx, path) {\n+    match def_path_res(cx, path, Some(Namespace::TypeNS)) {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n         _ => None,\n     }"}, {"sha": "3bf488ab4779b27906dddbb7e8841476c15bed41", "filename": "src/docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -106,6 +106,7 @@ docs! {\n     \"derive_hash_xor_eq\",\n     \"derive_ord_xor_partial_ord\",\n     \"derive_partial_eq_without_eq\",\n+    \"disallowed_macros\",\n     \"disallowed_methods\",\n     \"disallowed_names\",\n     \"disallowed_script_idents\","}, {"sha": "96fa15afabfd2b617d45cc9f351ef717cd46e7fc", "filename": "src/docs/disallowed_macros.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/src%2Fdocs%2Fdisallowed_macros.txt", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/src%2Fdocs%2Fdisallowed_macros.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_macros.txt?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,36 @@\n+### What it does\n+Denies the configured macros in clippy.toml\n+\n+Note: Even though this lint is warn-by-default, it will only trigger if\n+macros are defined in the clippy.toml file.\n+\n+### Why is this bad?\n+Some macros are undesirable in certain contexts, and it's beneficial to\n+lint for them as needed.\n+\n+### Example\n+An example clippy.toml configuration:\n+```\n+disallowed-macros = [\n+    # Can use a string as the path of the disallowed macro.\n+    \"std::print\",\n+    # Can also use an inline table with a `path` key.\n+    { path = \"std::println\" },\n+    # When using an inline table, can add a `reason` for why the macro\n+    # is disallowed.\n+    { path = \"serde::Serialize\", reason = \"no serializing\" },\n+]\n+```\n+```\n+use serde::Serialize;\n+\n+// Example code where clippy issues a warning\n+println!(\"warns\");\n+\n+// The diagnostic will contain the message \"no serializing\"\n+#[derive(Serialize)]\n+struct Data {\n+    name: String,\n+    value: usize,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "fcaeace0e98904882b03e51895bbc5d7fea96155", "filename": "tests/ui-toml/disallowed_macros/auxiliary/macros.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fauxiliary%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fauxiliary%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fdisallowed_macros%2Fauxiliary%2Fmacros.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,32 @@\n+#[macro_export]\n+macro_rules! expr {\n+    () => {\n+        1\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! stmt {\n+    () => {\n+        let _x = ();\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! ty {\n+    () => { &'static str };\n+}\n+\n+#[macro_export]\n+macro_rules! pat {\n+    () => {\n+        _\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! item {\n+    () => {\n+        const ITEM: usize = 1;\n+    };\n+}"}, {"sha": "c8fe8be9a7704d2e888b00ddbfe17814eb511ed1", "filename": "tests/ui-toml/disallowed_macros/clippy.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fdisallowed_macros%2Fclippy.toml?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,11 @@\n+disallowed-macros = [\n+    \"std::println\",\n+    \"std::vec\",\n+    { path = \"std::cfg\" },\n+    { path = \"serde::Serialize\", reason = \"no serializing\" },\n+    \"macros::expr\",\n+    \"macros::stmt\",\n+    \"macros::ty\",\n+    \"macros::pat\",\n+    \"macros::item\",\n+]"}, {"sha": "2bb5376076e28f56baa328385e696a3ab1bd6467", "filename": "tests/ui-toml/disallowed_macros/disallowed_macros.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,39 @@\n+// aux-build:macros.rs\n+\n+#![allow(unused)]\n+\n+extern crate macros;\n+\n+use serde::Serialize;\n+\n+fn main() {\n+    println!(\"one\");\n+    println!(\"two\");\n+    cfg!(unix);\n+    vec![1, 2, 3];\n+\n+    #[derive(Serialize)]\n+    struct Derive;\n+\n+    let _ = macros::expr!();\n+    macros::stmt!();\n+    let macros::pat!() = 1;\n+    let _: macros::ty!() = \"\";\n+    macros::item!();\n+\n+    eprintln!(\"allowed\");\n+}\n+\n+struct S;\n+\n+impl S {\n+    macros::item!();\n+}\n+\n+trait Y {\n+    macros::item!();\n+}\n+\n+impl Y for S {\n+    macros::item!();\n+}"}, {"sha": "aed9feb6f796c82fc792c9c96c95693cef29b78c", "filename": "tests/ui-toml/disallowed_macros/disallowed_macros.stderr", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fdisallowed_macros%2Fdisallowed_macros.stderr?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -0,0 +1,84 @@\n+error: use of a disallowed macro `std::println`\n+  --> $DIR/disallowed_macros.rs:10:5\n+   |\n+LL |     println!(\"one\");\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::disallowed-macros` implied by `-D warnings`\n+\n+error: use of a disallowed macro `std::println`\n+  --> $DIR/disallowed_macros.rs:11:5\n+   |\n+LL |     println!(\"two\");\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `std::cfg`\n+  --> $DIR/disallowed_macros.rs:12:5\n+   |\n+LL |     cfg!(unix);\n+   |     ^^^^^^^^^^\n+\n+error: use of a disallowed macro `std::vec`\n+  --> $DIR/disallowed_macros.rs:13:5\n+   |\n+LL |     vec![1, 2, 3];\n+   |     ^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `serde::Serialize`\n+  --> $DIR/disallowed_macros.rs:15:14\n+   |\n+LL |     #[derive(Serialize)]\n+   |              ^^^^^^^^^\n+   |\n+   = note: no serializing (from clippy.toml)\n+\n+error: use of a disallowed macro `macros::expr`\n+  --> $DIR/disallowed_macros.rs:18:13\n+   |\n+LL |     let _ = macros::expr!();\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::stmt`\n+  --> $DIR/disallowed_macros.rs:19:5\n+   |\n+LL |     macros::stmt!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::pat`\n+  --> $DIR/disallowed_macros.rs:20:9\n+   |\n+LL |     let macros::pat!() = 1;\n+   |         ^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::ty`\n+  --> $DIR/disallowed_macros.rs:21:12\n+   |\n+LL |     let _: macros::ty!() = \"\";\n+   |            ^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::item`\n+  --> $DIR/disallowed_macros.rs:22:5\n+   |\n+LL |     macros::item!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::item`\n+  --> $DIR/disallowed_macros.rs:30:5\n+   |\n+LL |     macros::item!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::item`\n+  --> $DIR/disallowed_macros.rs:34:5\n+   |\n+LL |     macros::item!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed macro `macros::item`\n+  --> $DIR/disallowed_macros.rs:38:5\n+   |\n+LL |     macros::item!();\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "28774db625bb77ff5d72e051850b076686dd7393", "filename": "tests/ui-toml/toml_disallowed_methods/clippy.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -3,6 +3,7 @@ disallowed-methods = [\n     \"std::iter::Iterator::sum\",\n     \"f32::clamp\",\n     \"slice::sort_unstable\",\n+    \"futures::stream::select_all\",\n     # can give path and reason with an inline table\n     { path = \"regex::Regex::is_match\", reason = \"no matching allowed\" },\n     # can use an inline table but omit reason"}, {"sha": "b483f160028976db51616dffefa214f4af61e588", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -1,6 +1,9 @@\n #![warn(clippy::disallowed_methods)]\n \n+extern crate futures;\n extern crate regex;\n+\n+use futures::stream::{empty, select_all};\n use regex::Regex;\n \n fn main() {\n@@ -20,4 +23,7 @@ fn main() {\n \n     let in_call = Box::new(f32::clamp);\n     let in_method_call = [\"^\", \"$\"].into_iter().map(Regex::new);\n+\n+    // resolve ambiguity between `futures::stream::select_all` the module and the function\n+    let same_name_as_module = select_all(vec![empty::<()>()]);\n }"}, {"sha": "6d78c32e127ee9ba8cb13e7079cfc4539af45361", "filename": "tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -1,54 +1,60 @@\n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:7:14\n+  --> $DIR/conf_disallowed_methods.rs:10:14\n    |\n LL |     let re = Regex::new(r\"ab.*c\").unwrap();\n    |              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::disallowed-methods` implied by `-D warnings`\n \n error: use of a disallowed method `regex::Regex::is_match`\n-  --> $DIR/conf_disallowed_methods.rs:8:5\n+  --> $DIR/conf_disallowed_methods.rs:11:5\n    |\n LL |     re.is_match(\"abc\");\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: no matching allowed (from clippy.toml)\n \n error: use of a disallowed method `std::iter::Iterator::sum`\n-  --> $DIR/conf_disallowed_methods.rs:11:5\n+  --> $DIR/conf_disallowed_methods.rs:14:5\n    |\n LL |     a.iter().sum::<i32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `slice::sort_unstable`\n-  --> $DIR/conf_disallowed_methods.rs:13:5\n+  --> $DIR/conf_disallowed_methods.rs:16:5\n    |\n LL |     a.sort_unstable();\n    |     ^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `f32::clamp`\n-  --> $DIR/conf_disallowed_methods.rs:15:13\n+  --> $DIR/conf_disallowed_methods.rs:18:13\n    |\n LL |     let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:18:61\n+  --> $DIR/conf_disallowed_methods.rs:21:61\n    |\n LL |     let indirect: fn(&str) -> Result<Regex, regex::Error> = Regex::new;\n    |                                                             ^^^^^^^^^^\n \n error: use of a disallowed method `f32::clamp`\n-  --> $DIR/conf_disallowed_methods.rs:21:28\n+  --> $DIR/conf_disallowed_methods.rs:24:28\n    |\n LL |     let in_call = Box::new(f32::clamp);\n    |                            ^^^^^^^^^^\n \n error: use of a disallowed method `regex::Regex::new`\n-  --> $DIR/conf_disallowed_methods.rs:22:53\n+  --> $DIR/conf_disallowed_methods.rs:25:53\n    |\n LL |     let in_method_call = [\"^\", \"$\"].into_iter().map(Regex::new);\n    |                                                     ^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: use of a disallowed method `futures::stream::select_all`\n+  --> $DIR/conf_disallowed_methods.rs:28:31\n+   |\n+LL |     let same_name_as_module = select_all(vec![empty::<()>()]);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "82ee8054132172a40b3323c5f99bf133df166a1c", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86c86c37429e95aee45846262bb50239a69be546/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=86c86c37429e95aee45846262bb50239a69be546", "patch": "@@ -11,6 +11,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            cargo-ignore-publish\n            cognitive-complexity-threshold\n            cyclomatic-complexity-threshold\n+           disallowed-macros\n            disallowed-methods\n            disallowed-names\n            disallowed-types"}]}