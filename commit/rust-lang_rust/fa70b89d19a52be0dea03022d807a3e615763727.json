{"sha": "fa70b89d19a52be0dea03022d807a3e615763727", "node_id": "C_kwDOAAsO6NoAKGZhNzBiODlkMTlhNTJiZTBkZWEwMzAyMmQ4MDdhM2U2MTU3NjM3Mjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T16:23:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T16:23:32Z"}, "message": "Auto merge of #97356 - Dylan-DPC:rollup-bhceawj, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #97288 (Lifetime variance fixes for rustdoc)\n - #97298 (Parse expression after `else` as a condition if followed by `{`)\n - #97308 (Stabilize `cell_filter_map`)\n - #97321 (explain how to turn integers into fn ptrs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "77460517983befba5d1bde07e8d7665ad8b6e09c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77460517983befba5d1bde07e8d7665ad8b6e09c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa70b89d19a52be0dea03022d807a3e615763727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa70b89d19a52be0dea03022d807a3e615763727", "html_url": "https://github.com/rust-lang/rust/commit/fa70b89d19a52be0dea03022d807a3e615763727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa70b89d19a52be0dea03022d807a3e615763727/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee9726cb10399724c943a16277c78a07e53f505c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9726cb10399724c943a16277c78a07e53f505c", "html_url": "https://github.com/rust-lang/rust/commit/ee9726cb10399724c943a16277c78a07e53f505c"}, {"sha": "4bd40186dbb498f8a3952a24f343b468ad5ef064", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd40186dbb498f8a3952a24f343b468ad5ef064", "html_url": "https://github.com/rust-lang/rust/commit/4bd40186dbb498f8a3952a24f343b468ad5ef064"}], "stats": {"total": 535, "additions": 370, "deletions": 165}, "files": [{"sha": "bda7affe52983b5ab1ca08b0f20b702a3219292f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -343,12 +343,12 @@ pub struct GenericArgs<'hir> {\n     pub span_ext: Span,\n }\n \n-impl GenericArgs<'_> {\n+impl<'hir> GenericArgs<'hir> {\n     pub const fn none() -> Self {\n         Self { args: &[], bindings: &[], parenthesized: false, span_ext: DUMMY_SP }\n     }\n \n-    pub fn inputs(&self) -> &[Ty<'_>] {\n+    pub fn inputs(&self) -> &[Ty<'hir>] {\n         if self.parenthesized {\n             for arg in self.args {\n                 match arg {\n@@ -549,7 +549,7 @@ impl<'hir> Generics<'hir> {\n         &NOPE\n     }\n \n-    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'hir>> {\n         for param in self.params {\n             if name == param.name.ident().name {\n                 return Some(param);\n@@ -608,7 +608,7 @@ impl<'hir> Generics<'hir> {\n     pub fn bounds_for_param(\n         &self,\n         param_def_id: LocalDefId,\n-    ) -> impl Iterator<Item = &WhereBoundPredicate<'_>> {\n+    ) -> impl Iterator<Item = &WhereBoundPredicate<'hir>> {\n         self.predicates.iter().filter_map(move |pred| match pred {\n             WherePredicate::BoundPredicate(bp) if bp.is_param_bound(param_def_id.to_def_id()) => {\n                 Some(bp)"}, {"sha": "37e3465694131b2c9a70f175ac126c86b9a347e1", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -2010,6 +2010,12 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n+    /// Parse a block which takes no attributes and has no label\n+    fn parse_simple_block(&mut self) -> PResult<'a, P<Expr>> {\n+        let blk = self.parse_block()?;\n+        Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()))\n+    }\n+\n     /// Recover on an explicitly quantified closure expression, e.g., `for<'a> |x: &'a u8| *x + 1`.\n     fn recover_quantified_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n@@ -2157,14 +2163,22 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n \n+        self.parse_if_after_cond(attrs, lo, cond)\n+    }\n+\n+    fn parse_if_after_cond(\n+        &mut self,\n+        attrs: AttrVec,\n+        lo: Span,\n+        cond: P<Expr>,\n+    ) -> PResult<'a, P<Expr>> {\n         let missing_then_block_binop_span = || {\n             match cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, ref right)\n                     if let ExprKind::Block(..) = right.kind => Some(binop_span),\n                 _ => None\n             }\n         };\n-\n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n@@ -2256,15 +2270,53 @@ impl<'a> Parser<'a> {\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        let ctx_span = self.prev_token.span; // `else`\n+        let else_span = self.prev_token.span; // `else`\n         let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n             self.parse_if_expr(AttrVec::new())?\n+        } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n+            self.parse_simple_block()?\n         } else {\n-            let blk = self.parse_block()?;\n-            self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new())\n+            let snapshot = self.create_snapshot_for_diagnostic();\n+            let first_tok = super::token_descr(&self.token);\n+            let first_tok_span = self.token.span;\n+            match self.parse_expr() {\n+                Ok(cond)\n+                // If it's not a free-standing expression, and is followed by a block,\n+                // then it's very likely the condition to an `else if`.\n+                    if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n+                        && classify::expr_requires_semi_to_be_stmt(&cond) =>\n+                {\n+                    self.struct_span_err(first_tok_span, format!(\"expected `{{`, found {first_tok}\"))\n+                        .span_label(else_span, \"expected an `if` or a block after this `else`\")\n+                        .span_suggestion(\n+                            cond.span.shrink_to_lo(),\n+                            \"add an `if` if this is the condition to an chained `if` statement after the `else`\",\n+                            \"if \".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        ).multipart_suggestion(\n+                            \"... otherwise, place this expression inside of a block if it is not an `if` condition\",\n+                            vec![\n+                                (cond.span.shrink_to_lo(), \"{ \".to_string()),\n+                                (cond.span.shrink_to_hi(), \" }\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    self.parse_if_after_cond(AttrVec::new(), cond.span.shrink_to_lo(), cond)?\n+                }\n+                Err(e) => {\n+                    e.cancel();\n+                    self.restore_snapshot(snapshot);\n+                    self.parse_simple_block()?\n+                },\n+                Ok(_) => {\n+                    self.restore_snapshot(snapshot);\n+                    self.parse_simple_block()?\n+                },\n+            }\n         };\n-        self.error_on_if_block_attrs(ctx_span, true, expr.span, &attrs);\n+        self.error_on_if_block_attrs(else_span, true, expr.span, &attrs);\n         Ok(expr)\n     }\n "}, {"sha": "321f2feb921cf2b9e19c871c79fcb5a2ea431eab", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -1390,16 +1390,14 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(cell_filter_map)]\n-    ///\n     /// use std::cell::{RefCell, Ref};\n     ///\n     /// let c = RefCell::new(vec![1, 2, 3]);\n     /// let b1: Ref<Vec<u32>> = c.borrow();\n     /// let b2: Result<Ref<u32>, _> = Ref::filter_map(b1, |v| v.get(1));\n     /// assert_eq!(*b2.unwrap(), 2);\n     /// ```\n-    #[unstable(feature = \"cell_filter_map\", reason = \"recently added\", issue = \"81061\")]\n+    #[stable(feature = \"cell_filter_map\", since = \"1.63.0\")]\n     #[inline]\n     pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Result<Ref<'b, U>, Self>\n     where\n@@ -1538,8 +1536,6 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(cell_filter_map)]\n-    ///\n     /// use std::cell::{RefCell, RefMut};\n     ///\n     /// let c = RefCell::new(vec![1, 2, 3]);\n@@ -1555,7 +1551,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     ///\n     /// assert_eq!(*c.borrow(), vec![1, 4, 3]);\n     /// ```\n-    #[unstable(feature = \"cell_filter_map\", reason = \"recently added\", issue = \"81061\")]\n+    #[stable(feature = \"cell_filter_map\", since = \"1.63.0\")]\n     #[inline]\n     pub fn filter_map<U: ?Sized, F>(mut orig: RefMut<'b, T>, f: F) -> Result<RefMut<'b, U>, Self>\n     where"}, {"sha": "6ba359f6edcd872810a1352972630ae895da30e5", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -930,6 +930,9 @@ extern \"rust-intrinsic\" {\n     /// fn foo() -> i32 {\n     ///     0\n     /// }\n+    /// // Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.\n+    /// // This avoids an integer-to-pointer `transmute`, which can be problematic.\n+    /// // Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\n     /// let pointer = foo as *const ();\n     /// let function = unsafe {\n     ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)"}, {"sha": "688ab63bf1366f12f92ff0b58ce8dabb7927c784", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -1351,6 +1351,32 @@ mod prim_ref {}\n /// is a reference to the function-specific ZST. `&bar` is basically never what you\n /// want when `bar` is a function.\n ///\n+/// ### Casting to and from integers\n+///\n+/// You cast function pointers directly to integers:\n+///\n+/// ```rust\n+/// let fnptr: fn(i32) -> i32 = |x| x+2;\n+/// let fnptr_addr = fnptr as usize;\n+/// ```\n+///\n+/// However, a direct cast back is not possible. You need to use `transmute`:\n+///\n+/// ```rust\n+/// # let fnptr: fn(i32) -> i32 = |x| x+2;\n+/// # let fnptr_addr = fnptr as usize;\n+/// let fnptr = fnptr_addr as *const ();\n+/// let fnptr: fn(i32) -> i32 = unsafe { std::mem::transmute(fnptr) };\n+/// assert_eq!(fnptr(40), 42);\n+/// ```\n+///\n+/// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.\n+/// This avoids an integer-to-pointer `transmute`, which can be problematic.\n+/// Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\n+///\n+/// Note that all of this is not portable to platforms where function pointers and data pointers\n+/// have different sizes.\n+///\n /// ### Traits\n ///\n /// Function pointers implement the following traits:"}, {"sha": "688ab63bf1366f12f92ff0b58ce8dabb7927c784", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -1351,6 +1351,32 @@ mod prim_ref {}\n /// is a reference to the function-specific ZST. `&bar` is basically never what you\n /// want when `bar` is a function.\n ///\n+/// ### Casting to and from integers\n+///\n+/// You cast function pointers directly to integers:\n+///\n+/// ```rust\n+/// let fnptr: fn(i32) -> i32 = |x| x+2;\n+/// let fnptr_addr = fnptr as usize;\n+/// ```\n+///\n+/// However, a direct cast back is not possible. You need to use `transmute`:\n+///\n+/// ```rust\n+/// # let fnptr: fn(i32) -> i32 = |x| x+2;\n+/// # let fnptr_addr = fnptr as usize;\n+/// let fnptr = fnptr_addr as *const ();\n+/// let fnptr: fn(i32) -> i32 = unsafe { std::mem::transmute(fnptr) };\n+/// assert_eq!(fnptr(40), 42);\n+/// ```\n+///\n+/// Crucially, we `as`-cast to a raw pointer before `transmute`ing to a function pointer.\n+/// This avoids an integer-to-pointer `transmute`, which can be problematic.\n+/// Transmuting between raw pointers and function pointers (i.e., two pointer types) is fine.\n+///\n+/// Note that all of this is not portable to platforms where function pointers and data pointers\n+/// have different sizes.\n+///\n /// ### Traits\n ///\n /// Function pointers implement the following traits:"}, {"sha": "a82abe669265540ea958589a8cdc49e4cbcc5169", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -218,7 +218,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n     }\n }\n \n-fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Function {\n+fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let predicates = cx.tcx.predicates_of(did);"}, {"sha": "4068531f0108ba972c4b801bd53c8a73ead3b612", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 150, "deletions": 138, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -44,12 +44,12 @@ use utils::*;\n pub(crate) use self::types::*;\n pub(crate) use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-pub(crate) trait Clean<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> T;\n+pub(crate) trait Clean<'tcx, T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> T;\n }\n \n-impl Clean<Item> for DocModule<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let mut items: Vec<Item> = vec![];\n         items.extend(\n             self.foreigns\n@@ -89,14 +89,14 @@ impl Clean<Item> for DocModule<'_> {\n     }\n }\n \n-impl Clean<Attributes> for [ast::Attribute] {\n+impl<'tcx> Clean<'tcx, Attributes> for [ast::Attribute] {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Attributes {\n         Attributes::from_ast(self, None)\n     }\n }\n \n-impl Clean<Option<GenericBound>> for hir::GenericBound<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<GenericBound> {\n+impl<'tcx> Clean<'tcx, Option<GenericBound>> for hir::GenericBound<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<GenericBound> {\n         Some(match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n@@ -131,9 +131,9 @@ impl Clean<Option<GenericBound>> for hir::GenericBound<'_> {\n     }\n }\n \n-fn clean_trait_ref_with_bindings(\n-    cx: &mut DocContext<'_>,\n-    trait_ref: ty::TraitRef<'_>,\n+fn clean_trait_ref_with_bindings<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n     bindings: &[TypeBinding],\n ) -> Path {\n     let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n@@ -148,15 +148,15 @@ fn clean_trait_ref_with_bindings(\n     path\n }\n \n-impl Clean<Path> for ty::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         clean_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n-fn clean_poly_trait_ref_with_bindings(\n-    cx: &mut DocContext<'_>,\n-    poly_trait_ref: ty::PolyTraitRef<'_>,\n+fn clean_poly_trait_ref_with_bindings<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     bindings: &[TypeBinding],\n ) -> GenericBound {\n     let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n@@ -182,14 +182,14 @@ fn clean_poly_trait_ref_with_bindings(\n     )\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         clean_poly_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n-impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n+impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n         if let Some(\n             rl::Region::EarlyBound(_, node_id)\n@@ -205,8 +205,8 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         Constant {\n             type_: cx\n                 .tcx\n@@ -217,7 +217,7 @@ impl Clean<Constant> for hir::ConstArg {\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::Region<'_> {\n+impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::Region<'tcx> {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match **self {\n             ty::ReStatic => Some(Lifetime::statik()),\n@@ -239,8 +239,8 @@ impl Clean<Option<Lifetime>> for ty::Region<'_> {\n     }\n }\n \n-impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         if !self.in_where_clause() {\n             return None;\n         }\n@@ -279,8 +279,8 @@ impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n     }\n }\n \n-impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(pred) => bound_predicate.rebind(pred).clean(cx),\n@@ -300,8 +300,8 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'a> Clean<Option<WherePredicate>> for ty::PolyTraitPredicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::PolyTraitPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         // `T: ~const Destruct` is hidden because `T: Destruct` is a no-op.\n         if self.skip_binder().constness == ty::BoundConstness::ConstIfConst\n             && Some(self.skip_binder().def_id()) == cx.tcx.lang_items().destruct_trait()\n@@ -318,10 +318,10 @@ impl<'a> Clean<Option<WherePredicate>> for ty::PolyTraitPredicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>>\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n     for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n         if a.is_empty() && b.is_empty() {\n@@ -335,8 +335,10 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n+    for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>\n+{\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n         if lt.is_empty() {\n@@ -351,17 +353,17 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n-impl<'tcx> Clean<Term> for ty::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n             ty::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n             ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n         }\n     }\n }\n \n-impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Term {\n+impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n             hir::Term::Ty(ty) => Term::Type(ty.clean(cx)),\n             hir::Term::Const(c) => {\n@@ -372,16 +374,16 @@ impl<'tcx> Clean<Term> for hir::Term<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n+impl<'tcx> Clean<'tcx, WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, term } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: term.clean(cx) }\n     }\n }\n \n fn clean_projection<'tcx>(\n     ty: ty::ProjectionTy<'tcx>,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n@@ -401,8 +403,8 @@ fn clean_projection<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         clean_projection(*self, cx, None)\n     }\n }\n@@ -414,7 +416,10 @@ fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type\n             .map_or(!self_type.is_self_type(), |(id, trait_)| id != trait_)\n }\n \n-fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>) -> PathSegment {\n+fn projection_to_path_segment<'tcx>(\n+    ty: ty::ProjectionTy<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> PathSegment {\n     let item = cx.tcx.associated_item(ty.item_def_id);\n     let generics = cx.tcx.generics_of(ty.item_def_id);\n     PathSegment {\n@@ -426,8 +431,8 @@ fn projection_to_path_segment(ty: ty::ProjectionTy<'_>, cx: &mut DocContext<'_>)\n     }\n }\n \n-impl Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n+impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name, GenericParamDefKind::Lifetime { outlives: vec![] })\n@@ -465,10 +470,10 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-fn clean_generic_param(\n-    cx: &mut DocContext<'_>,\n-    generics: Option<&hir::Generics<'_>>,\n-    param: &hir::GenericParam<'_>,\n+fn clean_generic_param<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    generics: Option<&hir::Generics<'tcx>>,\n+    param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n@@ -536,8 +541,8 @@ fn clean_generic_param(\n     GenericParamDef { name, kind }\n }\n \n-impl Clean<Generics> for hir::Generics<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n+impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -618,10 +623,10 @@ impl Clean<Generics> for hir::Generics<'_> {\n     }\n }\n \n-fn clean_ty_generics(\n-    cx: &mut DocContext<'_>,\n+fn clean_ty_generics<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     gens: &ty::Generics,\n-    preds: ty::GenericPredicates<'_>,\n+    preds: ty::GenericPredicates<'tcx>,\n ) -> Generics {\n     // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n     // since `Clean for ty::Predicate` would consume them.\n@@ -784,13 +789,13 @@ fn clean_ty_generics(\n     }\n }\n \n-fn clean_fn_or_proc_macro(\n-    item: &hir::Item<'_>,\n-    sig: &hir::FnSig<'_>,\n-    generics: &hir::Generics<'_>,\n+fn clean_fn_or_proc_macro<'tcx>(\n+    item: &hir::Item<'tcx>,\n+    sig: &hir::FnSig<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n     name: &mut Symbol,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> ItemKind {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let macro_kind = attrs.iter().find_map(|a| {\n@@ -868,10 +873,10 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n     }\n }\n \n-fn clean_function(\n-    cx: &mut DocContext<'_>,\n-    sig: &hir::FnSig<'_>,\n-    generics: &hir::Generics<'_>,\n+fn clean_function<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    sig: &hir::FnSig<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n ) -> Function {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n@@ -884,9 +889,9 @@ fn clean_function(\n     Function { decl, generics }\n }\n \n-fn clean_args_from_types_and_names(\n-    cx: &mut DocContext<'_>,\n-    types: &[hir::Ty<'_>],\n+fn clean_args_from_types_and_names<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    types: &[hir::Ty<'tcx>],\n     names: &[Ident],\n ) -> Arguments {\n     Arguments {\n@@ -904,9 +909,9 @@ fn clean_args_from_types_and_names(\n     }\n }\n \n-fn clean_args_from_types_and_body_id(\n-    cx: &mut DocContext<'_>,\n-    types: &[hir::Ty<'_>],\n+fn clean_args_from_types_and_body_id<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    types: &[hir::Ty<'tcx>],\n     body_id: hir::BodyId,\n ) -> Arguments {\n     let body = cx.tcx.hir().body(body_id);\n@@ -924,18 +929,18 @@ fn clean_args_from_types_and_body_id(\n     }\n }\n \n-fn clean_fn_decl_with_args(\n-    cx: &mut DocContext<'_>,\n-    decl: &hir::FnDecl<'_>,\n+fn clean_fn_decl_with_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    decl: &hir::FnDecl<'tcx>,\n     args: Arguments,\n ) -> FnDecl {\n     FnDecl { inputs: args, output: decl.output.clean(cx), c_variadic: decl.c_variadic }\n }\n \n-fn clean_fn_decl_from_did_and_sig(\n-    cx: &mut DocContext<'_>,\n+fn clean_fn_decl_from_did_and_sig<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: Option<DefId>,\n-    sig: ty::PolyFnSig<'_>,\n+    sig: ty::PolyFnSig<'tcx>,\n ) -> FnDecl {\n     let mut names = did.map_or(&[] as &[_], |did| cx.tcx.fn_arg_names(did)).iter();\n \n@@ -964,34 +969,34 @@ fn clean_fn_decl_from_did_and_sig(\n     }\n }\n \n-impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnRetTy {\n+impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n             Self::Return(ref typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n }\n \n-impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n+impl<'tcx> Clean<'tcx, bool> for hir::IsAuto {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n         }\n     }\n }\n \n-impl Clean<Path> for hir::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for hir::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         let path = self.path.clean(cx);\n         register_res(cx, path.res);\n         path\n     }\n }\n \n-impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n+impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self\n@@ -1003,8 +1008,8 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     }\n }\n \n-impl Clean<Item> for hir::TraitItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1050,8 +1055,8 @@ impl Clean<Item> for hir::TraitItem<'_> {\n     }\n }\n \n-impl Clean<Item> for hir::ImplItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1091,8 +1096,8 @@ impl Clean<Item> for hir::ImplItem<'_> {\n     }\n }\n \n-impl Clean<Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n@@ -1282,7 +1287,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n+fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n     let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let hir::TyKind::Path(qpath) = kind else { unreachable!() };\n \n@@ -1352,7 +1357,10 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     }\n }\n \n-fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n+fn maybe_expand_private_type_alias<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    path: &hir::Path<'tcx>,\n+) -> Option<Type> {\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n@@ -1435,8 +1443,8 @@ fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>\n     Some(cx.enter_alias(substs, |cx| ty.clean(cx)))\n }\n \n-impl Clean<Type> for hir::Ty<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         use rustc_hir::*;\n \n         match self.kind {\n@@ -1530,7 +1538,7 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>) -> Type {\n+fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'tcx>, def_id: Option<DefId>) -> Type {\n     trace!(\"cleaning type: {:?}\", this);\n     let ty = normalize(cx, this).unwrap_or(this);\n     match *ty.kind() {\n@@ -1715,14 +1723,14 @@ fn clean_ty<'tcx>(this: Ty<'tcx>, cx: &mut DocContext<'_>, def_id: Option<DefId>\n     }\n }\n \n-impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         clean_ty(*self, cx, None)\n     }\n }\n \n-impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n             type_: self.ty().clean(cx),\n@@ -1731,15 +1739,15 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     }\n }\n \n-impl Clean<Item> for hir::FieldDef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n         clean_field(def_id, self.ident.name, self.ty.clean(cx), cx)\n     }\n }\n \n-impl Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::FieldDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         clean_field(self.did, self.name, cx.tcx.type_of(self.did).clean(cx), cx)\n     }\n }\n@@ -1765,7 +1773,7 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-impl Clean<Visibility> for ty::Visibility {\n+impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n@@ -1779,23 +1787,23 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> VariantStruct {\n+impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n         }\n     }\n }\n \n-impl Clean<Vec<Item>> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n+impl<'tcx> Clean<'tcx, Vec<Item>> for hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n         self.fields().iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => {\n@@ -1813,8 +1821,8 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-impl Clean<Variant> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n+impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n             hir::VariantData::Tuple(..) => Variant::Tuple(self.clean(cx)),\n@@ -1823,14 +1831,14 @@ impl Clean<Variant> for hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Path> for hir::Path<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         Path { res: self.res, segments: self.segments.iter().map(|x| x.clean(cx)).collect() }\n     }\n }\n \n-impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericArgs {\n+impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n             let output =\n@@ -1858,14 +1866,14 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n     }\n }\n \n-impl Clean<PathSegment> for hir::PathSegment<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PathSegment {\n+impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n         PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n     }\n }\n \n-impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n+impl<'tcx> Clean<'tcx, BareFunctionDecl> for hir::BareFnTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n             let generic_params =\n@@ -1878,9 +1886,9 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-fn clean_maybe_renamed_item(\n-    cx: &mut DocContext<'_>,\n-    item: &hir::Item<'_>,\n+fn clean_maybe_renamed_item<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n@@ -1961,8 +1969,8 @@ fn clean_maybe_renamed_item(\n     })\n }\n \n-impl Clean<Item> for hir::Variant<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = VariantItem(self.data.clean(cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n@@ -1971,7 +1979,11 @@ impl Clean<Item> for hir::Variant<'_> {\n     }\n }\n \n-fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n+fn clean_impl<'tcx>(\n+    impl_: &hir::Impl<'tcx>,\n+    hir_id: hir::HirId,\n+    cx: &mut DocContext<'tcx>,\n+) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.as_ref().map(|t| t.clean(cx));\n@@ -2009,11 +2021,11 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n     ret\n }\n \n-fn clean_extern_crate(\n-    krate: &hir::Item<'_>,\n+fn clean_extern_crate<'tcx>(\n+    krate: &hir::Item<'tcx>,\n     name: Symbol,\n     orig_name: Option<Symbol>,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n@@ -2059,12 +2071,12 @@ fn clean_extern_crate(\n     }]\n }\n \n-fn clean_use_statement(\n-    import: &hir::Item<'_>,\n+fn clean_use_statement<'tcx>(\n+    import: &hir::Item<'tcx>,\n     name: Symbol,\n-    path: &hir::Path<'_>,\n+    path: &hir::Path<'tcx>,\n     kind: hir::UseKind,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2172,9 +2184,9 @@ fn clean_use_statement(\n     vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n-fn clean_maybe_renamed_foreign_item(\n-    cx: &mut DocContext<'_>,\n-    item: &hir::ForeignItem<'_>,\n+fn clean_maybe_renamed_foreign_item<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    item: &hir::ForeignItem<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Item {\n     let def_id = item.def_id.to_def_id();\n@@ -2205,17 +2217,17 @@ fn clean_maybe_renamed_foreign_item(\n     })\n }\n \n-impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n+impl<'tcx> Clean<'tcx, TypeBinding> for hir::TypeBinding<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBinding {\n         TypeBinding {\n             assoc: PathSegment { name: self.ident.name, args: self.gen_args.clean(cx) },\n             kind: self.kind.clean(cx),\n         }\n     }\n }\n \n-impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n+impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: term.clean(cx) }"}, {"sha": "a0014f721f46cb62765c95fd9533fd155327d7e0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -75,9 +75,9 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     Crate { module, primitives, external_traits: cx.external_traits.clone() }\n }\n \n-pub(crate) fn substs_to_args(\n-    cx: &mut DocContext<'_>,\n-    substs: &[ty::subst::GenericArg<'_>],\n+pub(crate) fn substs_to_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    substs: &[ty::subst::GenericArg<'tcx>],\n     mut skip_first: bool,\n ) -> Vec<GenericArg> {\n     let mut ret_val =\n@@ -99,12 +99,12 @@ pub(crate) fn substs_to_args(\n     ret_val\n }\n \n-fn external_generic_args(\n-    cx: &mut DocContext<'_>,\n+fn external_generic_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> GenericArgs {\n     let args = substs_to_args(cx, &substs, has_self);\n \n@@ -127,12 +127,12 @@ fn external_generic_args(\n     }\n }\n \n-pub(super) fn external_path(\n-    cx: &mut DocContext<'_>,\n+pub(super) fn external_path<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> Path {\n     let def_kind = cx.tcx.def_kind(did);\n     let name = cx.tcx.item_name(did);\n@@ -439,9 +439,9 @@ pub(crate) fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportS\n     }\n }\n \n-pub(crate) fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n+pub(crate) fn enter_impl_trait<'tcx, F, R>(cx: &mut DocContext<'tcx>, f: F) -> R\n where\n-    F: FnOnce(&mut DocContext<'_>) -> R,\n+    F: FnOnce(&mut DocContext<'tcx>) -> R,\n {\n     let old_bounds = mem::take(&mut cx.impl_trait_bounds);\n     let r = f(cx);"}, {"sha": "f0b40ecde6660bb0e7a7b2edb283fbb245bc7405", "filename": "src/test/ui/parser/else-no-if.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/src%2Ftest%2Fui%2Fparser%2Felse-no-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/src%2Ftest%2Fui%2Fparser%2Felse-no-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Felse-no-if.rs?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -0,0 +1,32 @@\n+fn foo() {\n+    if true {\n+    } else false {\n+    //~^ ERROR expected `{`, found keyword `false`\n+    }\n+}\n+\n+fn foo2() {\n+    if true {\n+    } else falsy() {\n+    //~^ ERROR expected `{`, found `falsy`\n+    }\n+}\n+\n+fn foo3() {\n+    if true {\n+    } else falsy();\n+    //~^ ERROR expected `{`, found `falsy`\n+}\n+\n+fn foo4() {\n+    if true {\n+    } else loop{}\n+    //~^ ERROR expected `{`, found keyword `loop`\n+    {}\n+}\n+\n+fn falsy() -> bool {\n+    false\n+}\n+\n+fn main() {}"}, {"sha": "27abbadd7ad2496605e1bccd3ddab0e8316188a6", "filename": "src/test/ui/parser/else-no-if.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fa70b89d19a52be0dea03022d807a3e615763727/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa70b89d19a52be0dea03022d807a3e615763727/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr?ref=fa70b89d19a52be0dea03022d807a3e615763727", "patch": "@@ -0,0 +1,58 @@\n+error: expected `{`, found keyword `false`\n+  --> $DIR/else-no-if.rs:3:12\n+   |\n+LL |     } else false {\n+   |       ---- ^^^^^\n+   |       |\n+   |       expected an `if` or a block after this `else`\n+   |\n+help: add an `if` if this is the condition to an chained `if` statement after the `else`\n+   |\n+LL |     } else if false {\n+   |            ++\n+help: ... otherwise, place this expression inside of a block if it is not an `if` condition\n+   |\n+LL |     } else { false } {\n+   |            +       +\n+\n+error: expected `{`, found `falsy`\n+  --> $DIR/else-no-if.rs:10:12\n+   |\n+LL |     } else falsy() {\n+   |       ---- ^^^^^\n+   |       |\n+   |       expected an `if` or a block after this `else`\n+   |\n+help: add an `if` if this is the condition to an chained `if` statement after the `else`\n+   |\n+LL |     } else if falsy() {\n+   |            ++\n+help: ... otherwise, place this expression inside of a block if it is not an `if` condition\n+   |\n+LL |     } else { falsy() } {\n+   |            +         +\n+\n+error: expected `{`, found `falsy`\n+  --> $DIR/else-no-if.rs:17:12\n+   |\n+LL |     } else falsy();\n+   |            ^^^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |     } else { falsy() };\n+   |            +         +\n+\n+error: expected `{`, found keyword `loop`\n+  --> $DIR/else-no-if.rs:23:12\n+   |\n+LL |     } else loop{}\n+   |            ^^^^ expected `{`\n+   |\n+help: try placing this code inside a block\n+   |\n+LL |     } else { loop{} }\n+   |            +        +\n+\n+error: aborting due to 4 previous errors\n+"}]}