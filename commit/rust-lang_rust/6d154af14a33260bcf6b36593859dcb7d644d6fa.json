{"sha": "6d154af14a33260bcf6b36593859dcb7d644d6fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMTU0YWYxNGEzMzI2MGJjZjZiMzY1OTM4NTlkY2I3ZDY0NGQ2ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T09:52:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T09:52:04Z"}, "message": "Auto merge of #28393 - arielb1:required-because-it-appears, r=nikomatsakis\n\nnew error style:\r\n```\r\npath.rs:4:6: 4:7 error: the trait `core::marker::Sized` is not implemented for the type `[u8]` [E0277]\r\npath.rs:4 fn f(p: Path) {}\r\n               ^\r\npath.rs:4:6: 4:7 help: run `rustc --explain E0277` to see a detailed explanation\r\npath.rs:4:6: 4:7 note: `[u8]` does not have a constant size known at compile-time\r\npath.rs:4:6: 4:7 note: required because it appears within the type `std::sys::os_str::Slice`\r\npath.rs:4:6: 4:7 note: required because it appears within the type `std::ffi::os_str::OsStr`\r\npath.rs:4:6: 4:7 note: required because it appears within the type `std::path::Path`\r\npath.rs:4:6: 4:7 note: all local variables must have a statically known size\r\npath.rs:7:5: 7:36 error: the trait `core::marker::Send` is not implemented for the type `alloc::rc::Rc<()>` [E0277]\r\npath.rs:7     foo::<BTreeMap<Rc<()>, Rc<()>>>();\r\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\npath.rs:7:5: 7:36 help: run `rustc --explain E0277` to see a detailed explanation\r\npath.rs:7:5: 7:36 note: `alloc::rc::Rc<()>` cannot be sent between threads safely\r\npath.rs:7:5: 7:36 note: required because it appears within the type `collections::btree::node::Node<alloc::rc::Rc<()>, alloc::rc::Rc<()>>`\r\npath.rs:7:5: 7:36 note: required because it appears within the type `collections::btree::map::BTreeMap<alloc::rc::Rc<()>, alloc::rc::Rc<()>>`\r\npath.rs:7:5: 7:36 note: required by `foo`\r\nerror: aborting due to 2 previous errors\r\n```\r\n\r\nFixes #21793 \r\nFixes #23286\r\n\r\nr? @nikomatsakis", "tree": {"sha": "f3120ccf818bae067b5825e1506e321b991336ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3120ccf818bae067b5825e1506e321b991336ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d154af14a33260bcf6b36593859dcb7d644d6fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d154af14a33260bcf6b36593859dcb7d644d6fa", "html_url": "https://github.com/rust-lang/rust/commit/6d154af14a33260bcf6b36593859dcb7d644d6fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d154af14a33260bcf6b36593859dcb7d644d6fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8320345221362e0a504e1d5efba7495bc895cb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/8320345221362e0a504e1d5efba7495bc895cb58", "html_url": "https://github.com/rust-lang/rust/commit/8320345221362e0a504e1d5efba7495bc895cb58"}, {"sha": "38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "url": "https://api.github.com/repos/rust-lang/rust/commits/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653", "html_url": "https://github.com/rust-lang/rust/commit/38f76dbc386e9367bd6dc8f1fe48e4ddfeb7f653"}], "stats": {"total": 87, "additions": 46, "deletions": 41}, "files": [{"sha": "2ed53f16afd28e9215426ad161a385b402747590", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6d154af14a33260bcf6b36593859dcb7d644d6fa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d154af14a33260bcf6b36593859dcb7d644d6fa/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=6d154af14a33260bcf6b36593859dcb7d644d6fa", "patch": "@@ -207,7 +207,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                       obligation.cause.span);\n                             if let Some(s) = custom_note {\n-                                infcx.tcx.sess.span_note(obligation.cause.span, &s);\n+                                infcx.tcx.sess.fileline_note(obligation.cause.span, &s);\n                             }\n                             note_obligation_cause(infcx, obligation);\n                         }\n@@ -305,29 +305,29 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for violation in object_safety_violations(tcx, trait_def_id) {\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     \"the trait cannot require that `Self : Sized`\");\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     \"the trait cannot use `Self` as a type parameter \\\n                      in the supertrait listing\");\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` has no receiver\",\n                              method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` references the `Self` type \\\n                               in its arguments or return type\",\n@@ -336,7 +336,7 @@ pub fn report_object_safety_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                tcx.sess.span_note(\n+                tcx.sess.fileline_note(\n                     span,\n                     &format!(\"method `{}` has generic type parameters\",\n                              method.name));\n@@ -458,111 +458,117 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n             note_obligation_cause_code(infcx, predicate, cause_span, subcode);\n         }\n         ObligationCauseCode::SliceOrArrayElem => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"slice and array elements must have `Sized` type\"));\n         }\n         ObligationCauseCode::ProjectionWf(data) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required so that the projection `{}` is well-formed\",\n                          data));\n         }\n         ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required so that reference `{}` does not outlive its referent\",\n                          ref_ty));\n         }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 &format!(\n                     \"required for the cast to the object type `{}`\",\n                     infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the `Copy` trait is required because the \\\n                  repeated element will be copied\");\n         }\n         ObligationCauseCode::VariableType(_) => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"all local variables must have a statically known size\");\n         }\n         ObligationCauseCode::ReturnType => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the return type of a function must have a \\\n                  statically known size\");\n         }\n         ObligationCauseCode::AssignmentLhsSized => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"the left-hand-side of an assignment must have a statically known size\");\n         }\n         ObligationCauseCode::StructInitializerSized => {\n-            tcx.sess.span_note(\n+            tcx.sess.fileline_note(\n                 cause_span,\n                 \"structs must have a statically known size to be initialized\");\n         }\n-        ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+        ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n             let trait_name = tcx.item_path_str(def_id);\n             let name = tcx.local_var_name_str(var_id);\n-            span_note!(tcx.sess, closure_span,\n-                       \"the closure that captures `{}` requires that all captured variables \\\n-                       implement the trait `{}`\",\n-                       name,\n-                       trait_name);\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"the closure that captures `{}` requires that all captured variables \\\n+                          implement the trait `{}`\",\n+                         name,\n+                         trait_name));\n         }\n         ObligationCauseCode::FieldSized => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"only the last field of a struct or enum variant \\\n-                       may have a dynamically sized type\")\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                \"only the last field of a struct or enum variant \\\n+                 may have a dynamically sized type\");\n         }\n         ObligationCauseCode::SharedStatic => {\n-            span_note!(tcx.sess, cause_span,\n-                       \"shared static variables must have a type that implements `Sync`\");\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                \"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            span_note!(tcx.sess, cause_span,\n-                       \"required because it appears within the type `{}`\",\n-                       parent_trait_ref.0.self_ty());\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"required because it appears within the type `{}`\",\n+                         parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            span_note!(tcx.sess, cause_span,\n-                       \"required because of the requirements on the impl of `{}` for `{}`\",\n-                       parent_trait_ref,\n-                       parent_trait_ref.0.self_ty());\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n+                         parent_trait_ref,\n+                         parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n-            span_note!(tcx.sess, cause_span,\n-                      \"the requirement `{}` appears on the impl method \\\n-                      but not on the corresponding trait method\",\n-                      predicate);\n+            tcx.sess.fileline_note(\n+                cause_span,\n+                &format!(\"the requirement `{}` appears on the impl method \\\n+                          but not on the corresponding trait method\",\n+                         predicate));\n         }\n     }\n }\n \n-pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n+fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n     let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    tcx.sess.span_note(\n+    tcx.sess.fileline_note(\n         span,\n         &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\","}, {"sha": "b0d4d92e8e1b28650dbeaf580e13d5a5ef7a7a7f", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d154af14a33260bcf6b36593859dcb7d644d6fa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d154af14a33260bcf6b36593859dcb7d644d6fa/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=6d154af14a33260bcf6b36593859dcb7d644d6fa", "patch": "@@ -29,7 +29,6 @@ pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::report_object_safety_error;\n-pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;"}]}