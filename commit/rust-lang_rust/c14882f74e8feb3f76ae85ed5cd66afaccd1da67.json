{"sha": "c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "node_id": "C_kwDOAAsO6NoAKGMxNDg4MmY3NGU4ZmViM2Y3NmFlODVlZDVjZDY2YWZhY2NkMWRhNjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T17:43:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T17:43:09Z"}, "message": "Auto merge of #107782 - Zoxc:worker-local, r=cjgillot\n\nMove the WorkerLocal type from the rustc-rayon fork into rustc_data_structures\n\nThis PR moves the definition of the `WorkerLocal` type from `rustc-rayon` into `rustc_data_structures`. This is enabled by the introduction of the `Registry` type which allows you to group up threads to be used by `WorkerLocal` which is basically just an array with an per thread index. The `Registry` type mirrors the one in Rayon and each Rayon worker thread is also registered with the new `Registry`. Safety for `WorkerLocal` is ensured by having it keep a reference to the registry and checking on each access that we're still on the group of threads associated with the registry used to construct it.\n\nAccessing a `WorkerLocal` is micro-optimized due to it being hot since it's used for most arena allocations.\n\nPerformance is slightly improved for the parallel compiler:\n<table><tr><td rowspan=\"2\">Benchmark</td><td colspan=\"1\"><b>Before</b></th><td colspan=\"2\"><b>After</b></th></tr><tr><td align=\"right\">Time</td><td align=\"right\">Time</td><td align=\"right\">%</th></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check</td><td align=\"right\">1.9992s</td><td align=\"right\">1.9949s</td><td align=\"right\"> -0.21%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check</td><td align=\"right\">0.2977s</td><td align=\"right\">0.2970s</td><td align=\"right\"> -0.22%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check</td><td align=\"right\">1.1335s</td><td align=\"right\">1.1315s</td><td align=\"right\"> -0.18%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check</td><td align=\"right\">1.8235s</td><td align=\"right\">1.8171s</td><td align=\"right\"> -0.35%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check</td><td align=\"right\">6.9047s</td><td align=\"right\">6.8930s</td><td align=\"right\"> -0.17%</td></tr><tr><td>Total</td><td align=\"right\">12.1586s</td><td align=\"right\">12.1336s</td><td align=\"right\"> -0.21%</td></tr><tr><td>Summary</td><td align=\"right\">1.0000s</td><td align=\"right\">0.9977s</td><td align=\"right\"> -0.23%</td></tr></table>\n\ncc `@SparrowLii`", "tree": {"sha": "e893ce45bb93289936dfb2a657337cae82d7f090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e893ce45bb93289936dfb2a657337cae82d7f090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "html_url": "https://github.com/rust-lang/rust/commit/c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "901fdb3b04375e3456b5cf771f86ecca8d6c1917", "url": "https://api.github.com/repos/rust-lang/rust/commits/901fdb3b04375e3456b5cf771f86ecca8d6c1917", "html_url": "https://github.com/rust-lang/rust/commit/901fdb3b04375e3456b5cf771f86ecca8d6c1917"}, {"sha": "efe7cf468f39e810b22e2779f4fafe976e74e563", "url": "https://api.github.com/repos/rust-lang/rust/commits/efe7cf468f39e810b22e2779f4fafe976e74e563", "html_url": "https://github.com/rust-lang/rust/commit/efe7cf468f39e810b22e2779f4fafe976e74e563"}], "stats": {"total": 264, "additions": 198, "deletions": 66}, "files": [{"sha": "e6c4db9e2ae5c1bb0623d0bc4a57e0c0eaeae9f9", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "patch": "@@ -10,15 +10,10 @@ use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n use crate::util::literal::escape_string_symbol;\n-use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n-use std::cell::Cell;\n use std::iter;\n-#[cfg(debug_assertions)]\n-use std::ops::BitXor;\n-#[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicU32, Ordering};\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -40,39 +35,16 @@ impl MarkedAttrs {\n     }\n }\n \n-pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n-\n-#[cfg(debug_assertions)]\n-static MAX_ATTR_ID: AtomicU32 = AtomicU32::new(u32::MAX);\n+pub struct AttrIdGenerator(AtomicU32);\n \n impl AttrIdGenerator {\n     pub fn new() -> Self {\n-        // We use `(index as u32).reverse_bits()` to initialize the\n-        // starting value of AttrId in each worker thread.\n-        // The `index` is the index of the worker thread.\n-        // This ensures that the AttrId generated in each thread is unique.\n-        AttrIdGenerator(WorkerLocal::new(|index| {\n-            let index: u32 = index.try_into().unwrap();\n-\n-            #[cfg(debug_assertions)]\n-            {\n-                let max_id = ((index + 1).next_power_of_two() - 1).bitxor(u32::MAX).reverse_bits();\n-                MAX_ATTR_ID.fetch_min(max_id, Ordering::Release);\n-            }\n-\n-            Cell::new(index.reverse_bits())\n-        }))\n+        AttrIdGenerator(AtomicU32::new(0))\n     }\n \n     pub fn mk_attr_id(&self) -> AttrId {\n-        let id = self.0.get();\n-\n-        // Ensure the assigned attr_id does not overlap the bits\n-        // representing the number of threads.\n-        #[cfg(debug_assertions)]\n-        assert!(id <= MAX_ATTR_ID.load(Ordering::Acquire));\n-\n-        self.0.set(id + 1);\n+        let id = self.0.fetch_add(1, Ordering::Relaxed);\n+        assert!(id != u32::MAX);\n         AttrId::from_u32(id)\n     }\n }"}, {"sha": "7ed70ba1e0fc7737a78af1e2a08842919f316922", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "patch": "@@ -1,14 +1,10 @@\n use crate::fx::{FxHashMap, FxHasher};\n-use crate::sync::{Lock, LockGuard};\n+use crate::sync::{CacheAligned, Lock, LockGuard};\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Default)]\n-#[cfg_attr(parallel_compiler, repr(align(64)))]\n-struct CacheAligned<T>(T);\n-\n #[cfg(parallel_compiler)]\n // 32 shards is sufficient to reduce contention on an 8-core Ryzen 7 1700,\n // but this should be tested on higher core count CPUs. How the `Sharded` type gets used"}, {"sha": "e73ca56efa0377d0357ce308a2a89f35e4a764d9", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "patch": "@@ -45,6 +45,9 @@ use std::hash::{BuildHasher, Hash};\n use std::ops::{Deref, DerefMut};\n use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n \n+mod worker_local;\n+pub use worker_local::{Registry, WorkerLocal};\n+\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n@@ -205,33 +208,6 @@ cfg_if! {\n \n         use std::cell::Cell;\n \n-        #[derive(Debug)]\n-        pub struct WorkerLocal<T>(OneThread<T>);\n-\n-        impl<T> WorkerLocal<T> {\n-            /// Creates a new worker local where the `initial` closure computes the\n-            /// value this worker local should take for each thread in the thread pool.\n-            #[inline]\n-            pub fn new<F: FnMut(usize) -> T>(mut f: F) -> WorkerLocal<T> {\n-                WorkerLocal(OneThread::new(f(0)))\n-            }\n-\n-            /// Returns the worker-local value for each thread\n-            #[inline]\n-            pub fn into_inner(self) -> Vec<T> {\n-                vec![OneThread::into_inner(self.0)]\n-            }\n-        }\n-\n-        impl<T> Deref for WorkerLocal<T> {\n-            type Target = T;\n-\n-            #[inline(always)]\n-            fn deref(&self) -> &T {\n-                &self.0\n-            }\n-        }\n-\n         pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n@@ -351,8 +327,6 @@ cfg_if! {\n             };\n         }\n \n-        pub use rayon_core::WorkerLocal;\n-\n         pub use rayon::iter::ParallelIterator;\n         use rayon::iter::IntoParallelIterator;\n \n@@ -383,6 +357,10 @@ pub fn assert_send<T: ?Sized + Send>() {}\n pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n \n+#[derive(Default)]\n+#[cfg_attr(parallel_compiler, repr(align(64)))]\n+pub struct CacheAligned<T>(pub T);\n+\n pub trait HashMapExt<K, V> {\n     /// Same as HashMap::insert, but it may panic if there's already an\n     /// entry for `key` with a value not equal to `value`"}, {"sha": "bfb04ba8a73f4cff7d5978614dcf0841048ce753", "filename": "compiler/rustc_data_structures/src/sync/worker_local.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs?ref=c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "patch": "@@ -0,0 +1,180 @@\n+use crate::sync::Lock;\n+use std::cell::Cell;\n+use std::cell::OnceCell;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::sync::Arc;\n+\n+#[cfg(parallel_compiler)]\n+use {crate::cold_path, crate::sync::CacheAligned};\n+\n+/// A pointer to the `RegistryData` which uniquely identifies a registry.\n+/// This identifier can be reused if the registry gets freed.\n+#[derive(Clone, Copy, PartialEq)]\n+struct RegistryId(*const RegistryData);\n+\n+impl RegistryId {\n+    #[inline(always)]\n+    /// Verifies that the current thread is associated with the registry and returns its unique\n+    /// index within the registry. This panics if the current thread is not associated with this\n+    /// registry.\n+    ///\n+    /// Note that there's a race possible where the identifer in `THREAD_DATA` could be reused\n+    /// so this can succeed from a different registry.\n+    #[cfg(parallel_compiler)]\n+    fn verify(self) -> usize {\n+        let (id, index) = THREAD_DATA.with(|data| (data.registry_id.get(), data.index.get()));\n+\n+        if id == self {\n+            index\n+        } else {\n+            cold_path(|| panic!(\"Unable to verify registry association\"))\n+        }\n+    }\n+}\n+\n+struct RegistryData {\n+    thread_limit: usize,\n+    threads: Lock<usize>,\n+}\n+\n+/// Represents a list of threads which can access worker locals.\n+#[derive(Clone)]\n+pub struct Registry(Arc<RegistryData>);\n+\n+thread_local! {\n+    /// The registry associated with the thread.\n+    /// This allows the `WorkerLocal` type to clone the registry in its constructor.\n+    static REGISTRY: OnceCell<Registry> = OnceCell::new();\n+}\n+\n+struct ThreadData {\n+    registry_id: Cell<RegistryId>,\n+    index: Cell<usize>,\n+}\n+\n+thread_local! {\n+    /// A thread local which contains the identifer of `REGISTRY` but allows for faster access.\n+    /// It also holds the index of the current thread.\n+    static THREAD_DATA: ThreadData = const { ThreadData {\n+        registry_id: Cell::new(RegistryId(ptr::null())),\n+        index: Cell::new(0),\n+    }};\n+}\n+\n+impl Registry {\n+    /// Creates a registry which can hold up to `thread_limit` threads.\n+    pub fn new(thread_limit: usize) -> Self {\n+        Registry(Arc::new(RegistryData { thread_limit, threads: Lock::new(0) }))\n+    }\n+\n+    /// Gets the registry associated with the current thread. Panics if there's no such registry.\n+    pub fn current() -> Self {\n+        REGISTRY.with(|registry| registry.get().cloned().expect(\"No assocated registry\"))\n+    }\n+\n+    /// Registers the current thread with the registry so worker locals can be used on it.\n+    /// Panics if the thread limit is hit or if the thread already has an associated registry.\n+    pub fn register(&self) {\n+        let mut threads = self.0.threads.lock();\n+        if *threads < self.0.thread_limit {\n+            REGISTRY.with(|registry| {\n+                if registry.get().is_some() {\n+                    drop(threads);\n+                    panic!(\"Thread already has a registry\");\n+                }\n+                registry.set(self.clone()).ok();\n+                THREAD_DATA.with(|data| {\n+                    data.registry_id.set(self.id());\n+                    data.index.set(*threads);\n+                });\n+                *threads += 1;\n+            });\n+        } else {\n+            drop(threads);\n+            panic!(\"Thread limit reached\");\n+        }\n+    }\n+\n+    /// Gets the identifer of this registry.\n+    fn id(&self) -> RegistryId {\n+        RegistryId(&*self.0)\n+    }\n+}\n+\n+/// Holds worker local values for each possible thread in a registry. You can only access the\n+/// worker local value through the `Deref` impl on the registry associated with the thread it was\n+/// created on. It will panic otherwise.\n+pub struct WorkerLocal<T> {\n+    #[cfg(not(parallel_compiler))]\n+    local: T,\n+    #[cfg(parallel_compiler)]\n+    locals: Box<[CacheAligned<T>]>,\n+    #[cfg(parallel_compiler)]\n+    registry: Registry,\n+}\n+\n+// This is safe because the `deref` call will return a reference to a `T` unique to each thread\n+// or it will panic for threads without an associated local. So there isn't a need for `T` to do\n+// it's own synchronization. The `verify` method on `RegistryId` has an issue where the the id\n+// can be reused, but `WorkerLocal` has a reference to `Registry` which will prevent any reuse.\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: Send> Sync for WorkerLocal<T> {}\n+\n+impl<T> WorkerLocal<T> {\n+    /// Creates a new worker local where the `initial` closure computes the\n+    /// value this worker local should take for each thread in the registry.\n+    #[inline]\n+    pub fn new<F: FnMut(usize) -> T>(mut initial: F) -> WorkerLocal<T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            let registry = Registry::current();\n+            WorkerLocal {\n+                locals: (0..registry.0.thread_limit).map(|i| CacheAligned(initial(i))).collect(),\n+                registry,\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            WorkerLocal { local: initial(0) }\n+        }\n+    }\n+\n+    /// Returns the worker-local values for each thread\n+    #[inline]\n+    pub fn into_inner(self) -> impl Iterator<Item = T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            self.locals.into_vec().into_iter().map(|local| local.0)\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            std::iter::once(self.local)\n+        }\n+    }\n+}\n+\n+impl<T> WorkerLocal<Vec<T>> {\n+    /// Joins the elements of all the worker locals into one Vec\n+    pub fn join(self) -> Vec<T> {\n+        self.into_inner().into_iter().flat_map(|v| v).collect()\n+    }\n+}\n+\n+impl<T> Deref for WorkerLocal<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    #[cfg(not(parallel_compiler))]\n+    fn deref(&self) -> &T {\n+        &self.local\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(parallel_compiler)]\n+    fn deref(&self) -> &T {\n+        // This is safe because `verify` will only return values less than\n+        // `self.registry.thread_limit` which is the size of the `self.locals` array.\n+        unsafe { &self.locals.get_unchecked(self.registry.id().verify()).0 }\n+    }\n+}"}, {"sha": "a27a1e2978a368e2f4c2d9b9ac463b861d9c5c33", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14882f74e8feb3f76ae85ed5cd66afaccd1da67/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "patch": "@@ -4,6 +4,8 @@ use libloading::Library;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::sync;\n use rustc_errors::registry::Registry;\n use rustc_parse::validate_attr;\n use rustc_session as session;\n@@ -170,6 +172,7 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     use rustc_middle::ty::tls;\n     use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n \n+    let registry = sync::Registry::new(threads);\n     let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n@@ -200,6 +203,9 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n                 .build_scoped(\n                     // Initialize each new worker thread when created.\n                     move |thread: rayon::ThreadBuilder| {\n+                        // Register the thread for use with the `WorkerLocal` type.\n+                        registry.register();\n+\n                         rustc_span::set_session_globals_then(session_globals, || thread.run())\n                     },\n                     // Run `f` on the first thread in the thread pool."}]}