{"sha": "0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDRkNmEzYjdlMmYyYmJhNGM3Y2M5YWRjMDRjMmI2ZTRlMDFiOTM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-12-26T15:36:55Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-20T21:53:46Z"}, "message": "Do not hold query key in Query.", "tree": {"sha": "4c62d947153b9d07ab6891cdc4c37d50129d021e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c62d947153b9d07ab6891cdc4c37d50129d021e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "html_url": "https://github.com/rust-lang/rust/commit/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f96e960ccfa92895217562ede43043405194eab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f96e960ccfa92895217562ede43043405194eab0", "html_url": "https://github.com/rust-lang/rust/commit/f96e960ccfa92895217562ede43043405194eab0"}], "stats": {"total": 127, "additions": 69, "deletions": 58}, "files": [{"sha": "f58092105c874b635412971c4ee52dfa3394424e", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "patch": "@@ -26,10 +26,9 @@ use rustc_middle::dep_graph;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{Providers, QueryEngine};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_serialize::opaque;\n use rustc_span::{Span, DUMMY_SP};\n-use std::mem;\n \n #[macro_use]\n mod plumbing;"}, {"sha": "2bb201945ad483d701117a0cb47266747f3018cd", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "patch": "@@ -45,7 +45,7 @@ impl HasDepContext for QueryCtxt<'tcx> {\n }\n \n impl QueryContext for QueryCtxt<'tcx> {\n-    type Query = Query<'tcx>;\n+    type Query = Query;\n \n     fn def_path_str(&self, def_id: DefId) -> String {\n         self.tcx.def_path_str(def_id)\n@@ -59,7 +59,7 @@ impl QueryContext for QueryCtxt<'tcx> {\n         &self,\n     ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n     {\n-        self.queries.try_collect_active_jobs()\n+        self.queries.try_collect_active_jobs(**self)\n     }\n \n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n@@ -185,12 +185,12 @@ impl<'tcx> QueryCtxt<'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<Query<'tcx>>,\n+        CycleError { usage, cycle: stack }: CycleError<Query>,\n     ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n-        let fix_span = |span: Span, query: &Query<'tcx>| {\n-            self.sess.source_map().guess_head_span(query.default_span(*self, span))\n+        let fix_span = |span: Span, query: &Query| {\n+            self.sess.source_map().guess_head_span(query.default_span(span))\n         };\n \n         // Disable naming impls with types in this path, since that\n@@ -204,24 +204,24 @@ impl<'tcx> QueryCtxt<'tcx> {\n                 span,\n                 E0391,\n                 \"cycle detected when {}\",\n-                stack[0].query.describe(self)\n+                stack[0].query.description\n             );\n \n             for i in 1..stack.len() {\n                 let query = &stack[i].query;\n                 let span = fix_span(stack[(i + 1) % stack.len()].span, query);\n-                err.span_note(span, &format!(\"...which requires {}...\", query.describe(self)));\n+                err.span_note(span, &format!(\"...which requires {}...\", query.description));\n             }\n \n             err.note(&format!(\n                 \"...which again requires {}, completing the cycle\",\n-                stack[0].query.describe(self)\n+                stack[0].query.description\n             ));\n \n             if let Some((span, query)) = usage {\n                 err.span_note(\n                     fix_span(span, &query),\n-                    &format!(\"cycle used when {}\", query.describe(self)),\n+                    &format!(\"cycle used when {}\", query.description),\n                 );\n             }\n \n@@ -371,54 +371,58 @@ macro_rules! define_queries {\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n-        #[allow(nonstandard_style)]\n         #[derive(Clone, Debug)]\n-        pub enum Query<$tcx> {\n-            $($(#[$attr])* $name(query_keys::$name<$tcx>)),*\n+        pub struct Query {\n+            pub name: &'static str,\n+            hash: Fingerprint,\n+            description: String,\n+            span: Option<Span>,\n         }\n \n-        impl<$tcx> Query<$tcx> {\n-            pub fn name(&self) -> &'static str {\n-                match *self {\n-                    $(Query::$name(_) => stringify!($name),)*\n-                }\n-            }\n-\n-            pub(crate) fn describe(&self, tcx: QueryCtxt<$tcx>) -> String {\n-                let (r, name) = match *self {\n-                    $(Query::$name(key) => {\n-                        (queries::$name::describe(tcx, key), stringify!($name))\n-                    })*\n+        impl Query {\n+            $(#[allow(nonstandard_style)] $(#[$attr])*\n+            pub fn $name<$tcx>(tcx: QueryCtxt<$tcx>, key: query_keys::$name<$tcx>) -> Self {\n+                let kind = dep_graph::DepKind::$name;\n+                let name = stringify!($name);\n+                let description = ty::print::with_forced_impl_filename_line(\n+                    // Force filename-line mode to avoid invoking `type_of` query.\n+                    || queries::$name::describe(tcx, key)\n+                );\n+                let description = if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", description, name)\n+                } else {\n+                    description\n                 };\n-                if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n+                let span = if kind == dep_graph::DepKind::def_span {\n+                    // The `def_span` query is used to calculate `default_span`,\n+                    // so exit to avoid infinite recursion.\n+                    None\n                 } else {\n-                    r\n-                }\n-            }\n+                    Some(key.default_span(*tcx))\n+                };\n+                let hash = {\n+                    let mut hcx = tcx.create_stable_hashing_context();\n+                    let mut hasher = StableHasher::new();\n+                    std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n+                    key.hash_stable(&mut hcx, &mut hasher);\n+                    hasher.finish()\n+                };\n+\n+                Self { name, description, span, hash }\n+            })*\n \n             // FIXME(eddyb) Get more valid `Span`s on queries.\n-            pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n+            pub fn default_span(&self, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n-                // The `def_span` query is used to calculate `default_span`,\n-                // so exit to avoid infinite recursion.\n-                if let Query::def_span(..) = *self {\n-                    return span\n-                }\n-                match *self {\n-                    $(Query::$name(key) => key.default_span(tcx),)*\n-                }\n+                self.span.unwrap_or(span)\n             }\n         }\n \n-        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n+        impl<'a> HashStable<StableHashingContext<'a>> for Query {\n             fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-                mem::discriminant(self).hash_stable(hcx, hasher);\n-                match *self {\n-                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n-                }\n+                self.hash.hash_stable(hcx, hasher)\n             }\n         }\n \n@@ -446,7 +450,9 @@ macro_rules! define_queries {\n             type Cache = query_storage::$name<$tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query<$tcx>, Self::Key> {\n+            fn query_state<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query, Self::Key>\n+                where QueryCtxt<$tcx>: 'a\n+            {\n                 &tcx.queries.$name\n             }\n \n@@ -478,7 +484,7 @@ macro_rules! define_queries {\n \n             fn handle_cycle_error(\n                 tcx: QueryCtxt<'tcx>,\n-                error: CycleError<Query<'tcx>>\n+                error: CycleError<Query>\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }\n@@ -581,7 +587,7 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*  $name: QueryState<\n                 crate::dep_graph::DepKind,\n-                Query<$tcx>,\n+                Query,\n                 query_keys::$name<$tcx>,\n             >,)*\n         }\n@@ -599,13 +605,16 @@ macro_rules! define_queries_struct {\n             }\n \n             pub(crate) fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, Query<$tcx>>>> {\n+                &$tcx self,\n+                tcx: TyCtxt<$tcx>,\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, Query>>> {\n+                let tcx = QueryCtxt { tcx, queries: self };\n                 let mut jobs = FxHashMap::default();\n \n                 $(\n                     self.$name.try_collect_active_jobs(\n-                        <queries::$name<'tcx> as QueryAccessors<QueryCtxt<'tcx>>>::DEP_KIND,\n+                        tcx,\n+                        dep_graph::DepKind::$name,\n                         Query::$name,\n                         &mut jobs,\n                     )?;\n@@ -651,7 +660,7 @@ macro_rules! define_queries_struct {\n                 handler: &Handler,\n                 num_frames: Option<usize>,\n             ) -> usize {\n-                let query_map = self.try_collect_active_jobs();\n+                let query_map = self.try_collect_active_jobs(tcx);\n \n                 let mut current_query = query;\n                 let mut i = 0;\n@@ -671,8 +680,8 @@ macro_rules! define_queries_struct {\n                         &format!(\n                             \"#{} [{}] {}\",\n                             i,\n-                            query_info.info.query.name(),\n-                            query_info.info.query.describe(QueryCtxt { tcx, queries: self })\n+                            query_info.info.query.name,\n+                            query_info.info.query.description,\n                         ),\n                     );\n                     diag.span = tcx.sess.source_map().guess_head_span(query_info.info.span).into();"}, {"sha": "8239f347923368c61387b42d702febe3f006e54a", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "patch": "@@ -73,7 +73,9 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Key>;\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Key>\n+    where\n+        CTX: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_cache<'a>(tcx: CTX) -> &'a QueryCacheStore<Self::Cache>"}, {"sha": "dbe7c4c2320cc6ccb76b8ccb8a3dbe97b17339f7", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "patch": "@@ -119,10 +119,11 @@ where\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n \n-    pub fn try_collect_active_jobs(\n+    pub fn try_collect_active_jobs<CTX: Copy>(\n         &self,\n+        tcx: CTX,\n         kind: D,\n-        make_query: fn(K) -> Q,\n+        make_query: fn(CTX, K) -> Q,\n         jobs: &mut QueryMap<D, Q>,\n     ) -> Option<()> {\n         // We use try_lock_shards here since we are called from the\n@@ -133,7 +134,7 @@ where\n             shard.active.iter().filter_map(move |(k, v)| {\n                 if let QueryResult::Started(ref job) = *v {\n                     let id = QueryJobId::new(job.id, shard_id, kind);\n-                    let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n+                    let info = QueryInfo { span: job.span, query: make_query(tcx, k.clone()) };\n                     Some((id, QueryJobInfo { info, job: job.clone() }))\n                 } else {\n                     None"}]}