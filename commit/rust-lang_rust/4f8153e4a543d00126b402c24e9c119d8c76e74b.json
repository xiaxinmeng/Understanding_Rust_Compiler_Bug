{"sha": "4f8153e4a543d00126b402c24e9c119d8c76e74b", "node_id": "C_kwDOAAsO6NoAKDRmODE1M2U0YTU0M2QwMDEyNmI0MDJjMjRlOWMxMTlkOGM3NmU3NGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-02T12:32:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-02T12:32:36Z"}, "message": "Auto merge of #13167 - iDawer:exhaustive_patterns, r=Veykril\n\nfeat: Implement `feature(exhaustive_patterns)` from unstable Rust\n\nCloses #12753\n\nRecognize Rust's unstable `#![feature(exhaustive_patterns)]` (RFC 1872). Allow omitting visibly uninhabited variants from `match` expressions when the feature is on.\n\nThis adjusts match checking to the current implementation of the postponed RFC 1872 in rustc.", "tree": {"sha": "f5d193f86cb913523a82d741ac5d9381aefe2661", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5d193f86cb913523a82d741ac5d9381aefe2661"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f8153e4a543d00126b402c24e9c119d8c76e74b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8153e4a543d00126b402c24e9c119d8c76e74b", "html_url": "https://github.com/rust-lang/rust/commit/4f8153e4a543d00126b402c24e9c119d8c76e74b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f8153e4a543d00126b402c24e9c119d8c76e74b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "412d614cf18a0696c87142f43c9ac46cb9d2ed0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/412d614cf18a0696c87142f43c9ac46cb9d2ed0e", "html_url": "https://github.com/rust-lang/rust/commit/412d614cf18a0696c87142f43c9ac46cb9d2ed0e"}, {"sha": "ffd79c28879d102baf8adcee8f2603ab98c5852d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd79c28879d102baf8adcee8f2603ab98c5852d", "html_url": "https://github.com/rust-lang/rust/commit/ffd79c28879d102baf8adcee8f2603ab98c5852d"}], "stats": {"total": 293, "additions": 272, "deletions": 21}, "files": [{"sha": "fc8444394cf505c158fcf70f99d0446c258f4158", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -64,7 +64,7 @@ use hir_expand::{name::Name, InFile, MacroCallId, MacroDefId};\n use itertools::Itertools;\n use la_arena::Arena;\n use profile::Count;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n use syntax::{ast, SmolStr};\n \n@@ -114,6 +114,8 @@ pub struct DefMap {\n     registered_attrs: Vec<SmolStr>,\n     /// Custom tool modules registered with `#![register_tool]`.\n     registered_tools: Vec<SmolStr>,\n+    /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n+    unstable_features: FxHashSet<SmolStr>,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -284,6 +286,7 @@ impl DefMap {\n             modules,\n             registered_attrs: Vec::new(),\n             registered_tools: Vec::new(),\n+            unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n         }\n     }\n@@ -314,6 +317,10 @@ impl DefMap {\n         &self.registered_attrs\n     }\n \n+    pub fn is_unstable_feature_enabled(&self, feature: &str) -> bool {\n+        self.unstable_features.contains(feature)\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -483,6 +490,7 @@ impl DefMap {\n             registered_tools,\n             fn_proc_macro_mapping,\n             derive_helpers_in_scope,\n+            unstable_features,\n             proc_macro_loading_error: _,\n             block: _,\n             edition: _,\n@@ -500,6 +508,7 @@ impl DefMap {\n         registered_tools.shrink_to_fit();\n         fn_proc_macro_mapping.shrink_to_fit();\n         derive_helpers_in_scope.shrink_to_fit();\n+        unstable_features.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();"}, {"sha": "ee27aa2554a38dffa97fd4f912bd20a1d98192c3", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -294,6 +294,17 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if *attr_name == hir_expand::name![feature] {\n+                    let features =\n+                        attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n+                            |feat| match feat.segments() {\n+                                [name] => Some(name.to_smol_str()),\n+                                _ => None,\n+                            },\n+                        );\n+                    self.def_map.unstable_features.extend(features);\n+                }\n+\n                 let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n                     || *attr_name == hir_expand::name![register_tool];\n                 if !attr_is_register_like {"}, {"sha": "4ce21a57967c72048f59b5db4517c544d075b528", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -336,6 +336,7 @@ pub mod known {\n         test,\n         test_case,\n         recursion_limit,\n+        feature,\n         // Safe intrinsics\n         abort,\n         add_with_overflow,"}, {"sha": "c8df4c796efca045f974d21e3b21a8a67e23bf28", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -159,12 +159,7 @@ impl ExprValidator {\n         }\n \n         let pattern_arena = Arena::new();\n-        let cx = MatchCheckCtx {\n-            module: self.owner.module(db.upcast()),\n-            body: self.owner,\n-            db,\n-            pattern_arena: &pattern_arena,\n-        };\n+        let cx = MatchCheckCtx::new(self.owner.module(db.upcast()), self.owner, db, &pattern_arena);\n \n         let mut m_arms = Vec::with_capacity(arms.len());\n         let mut has_lowering_errors = false;"}, {"sha": "47d60fc41e700bc2962665e48ab04f6720b3884d", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -52,7 +52,10 @@ use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n-use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+use crate::{\n+    infer::normalize, inhabitedness::is_enum_variant_uninhabited_from, AdtId, Interner, Scalar, Ty,\n+    TyExt, TyKind,\n+};\n \n use super::{\n     is_box,\n@@ -557,8 +560,8 @@ impl SplitWildcard {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n-            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n-                let enum_data = cx.db.enum_data(enum_id);\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), subst) => {\n+                let enum_data = cx.db.enum_data(*enum_id);\n \n                 // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n                 // additional \"unknown\" constructor.\n@@ -591,14 +594,15 @@ impl SplitWildcard {\n                 let mut ctors: SmallVec<[_; 1]> = enum_data\n                     .variants\n                     .iter()\n-                    .filter(|&(_, _v)| {\n+                    .map(|(local_id, _)| EnumVariantId { parent: *enum_id, local_id })\n+                    .filter(|&variant| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                         // uninhabited.\n                         let is_uninhabited = is_exhaustive_pat_feature\n-                            && unimplemented!(\"after MatchCheckCtx.feature_exhaustive_patterns()\");\n+                            && is_enum_variant_uninhabited_from(variant, subst, cx.module, cx.db);\n                         !is_uninhabited\n                     })\n-                    .map(|(local_id, _)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                    .map(Variant)\n                     .collect();\n \n                 if is_secretly_empty || is_declared_nonexhaustive {"}, {"sha": "c4d709a975b0299a7a0a0374b83d9e12824a8236", "filename": "crates/hir-ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -277,7 +277,7 @@ use hir_def::{AdtId, DefWithBodyId, HasModule, ModuleId};\n use smallvec::{smallvec, SmallVec};\n use typed_arena::Arena;\n \n-use crate::{db::HirDatabase, Ty, TyExt};\n+use crate::{db::HirDatabase, inhabitedness::is_ty_uninhabited_from, Ty, TyExt};\n \n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n@@ -289,13 +289,27 @@ pub(crate) struct MatchCheckCtx<'a, 'p> {\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    exhaustive_patterns: bool,\n }\n \n impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n-    pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n-        // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n-        // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n-        false\n+    pub(crate) fn new(\n+        module: ModuleId,\n+        body: DefWithBodyId,\n+        db: &'a dyn HirDatabase,\n+        pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    ) -> Self {\n+        let def_map = db.crate_def_map(module.krate());\n+        let exhaustive_patterns = def_map.is_unstable_feature_enabled(\"exhaustive_patterns\");\n+        Self { module, body, db, pattern_arena, exhaustive_patterns }\n+    }\n+\n+    pub(super) fn is_uninhabited(&self, ty: &Ty) -> bool {\n+        if self.feature_exhaustive_patterns() {\n+            is_ty_uninhabited_from(ty, self.module, self.db)\n+        } else {\n+            false\n+        }\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n@@ -311,10 +325,9 @@ impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n         }\n     }\n \n-    // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n+    // Rust's unstable feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n     pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n-        // FIXME see MatchCheckCtx::is_uninhabited\n-        false\n+        self.exhaustive_patterns\n     }\n }\n "}, {"sha": "0c547192ac0d0dd81b87ac0339d655f29eaeaa5a", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -0,0 +1,173 @@\n+//! Type inhabitedness logic.\n+use std::ops::ControlFlow::{self, Break, Continue};\n+\n+use chalk_ir::{\n+    visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n+    DebruijnIndex,\n+};\n+use hir_def::{\n+    adt::VariantData, attr::Attrs, type_ref::ConstScalar, visibility::Visibility, AdtId,\n+    EnumVariantId, HasModule, Lookup, ModuleId, VariantId,\n+};\n+\n+use crate::{\n+    db::HirDatabase, Binders, ConcreteConst, Const, ConstValue, Interner, Substitution, Ty, TyKind,\n+};\n+\n+/// Checks whether a type is visibly uninhabited from a particular module.\n+pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+/// Checks whether a variant is visibly uninhabited from a particular module.\n+pub(crate) fn is_enum_variant_uninhabited_from(\n+    variant: EnumVariantId,\n+    subst: &Substitution,\n+    target_mod: ModuleId,\n+    db: &dyn HirDatabase,\n+) -> bool {\n+    let enum_data = db.enum_data(variant.parent);\n+    let vars_attrs = db.variants_attrs(variant.parent);\n+    let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n+\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = uninhabited_from.visit_variant(\n+        variant.into(),\n+        &enum_data.variants[variant.local_id].variant_data,\n+        subst,\n+        &vars_attrs[variant.local_id],\n+        is_local,\n+    );\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+struct UninhabitedFrom<'a> {\n+    target_mod: ModuleId,\n+    db: &'a dyn HirDatabase,\n+}\n+\n+const CONTINUE_OPAQUELY_INHABITED: ControlFlow<VisiblyUninhabited> = Continue(());\n+const BREAK_VISIBLY_UNINHABITED: ControlFlow<VisiblyUninhabited> = Break(VisiblyUninhabited);\n+#[derive(PartialEq, Eq)]\n+struct VisiblyUninhabited;\n+\n+impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n+    type BreakTy = VisiblyUninhabited;\n+\n+    fn as_dyn(&mut self) -> &mut dyn TypeVisitor<Interner, BreakTy = VisiblyUninhabited> {\n+        self\n+    }\n+\n+    fn visit_ty(\n+        &mut self,\n+        ty: &Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        match ty.kind(Interner) {\n+            TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n+            TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n+            TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n+            TyKind::Array(item_ty, len) => match try_usize_const(len) {\n+                Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n+                Some(1..) => item_ty.super_visit_with(self, outer_binder),\n+            },\n+\n+            TyKind::Ref(..) | _ => CONTINUE_OPAQUELY_INHABITED,\n+        }\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+}\n+\n+impl UninhabitedFrom<'_> {\n+    fn visit_adt(&mut self, adt: AdtId, subst: &Substitution) -> ControlFlow<VisiblyUninhabited> {\n+        let attrs = self.db.attrs(adt.into());\n+        let adt_non_exhaustive = attrs.by_key(\"non_exhaustive\").exists();\n+        let is_local = adt.module(self.db.upcast()).krate() == self.target_mod.krate();\n+        if adt_non_exhaustive && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        // An ADT is uninhabited iff all its variants uninhabited.\n+        match adt {\n+            // rustc: For now, `union`s are never considered uninhabited.\n+            AdtId::UnionId(_) => CONTINUE_OPAQUELY_INHABITED,\n+            AdtId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                self.visit_variant(s.into(), &struct_data.variant_data, subst, &attrs, is_local)\n+            }\n+            AdtId::EnumId(e) => {\n+                let vars_attrs = self.db.variants_attrs(e);\n+                let enum_data = self.db.enum_data(e);\n+\n+                for (local_id, enum_var) in enum_data.variants.iter() {\n+                    let variant_inhabitedness = self.visit_variant(\n+                        EnumVariantId { parent: e, local_id }.into(),\n+                        &enum_var.variant_data,\n+                        subst,\n+                        &vars_attrs[local_id],\n+                        is_local,\n+                    );\n+                    match variant_inhabitedness {\n+                        Break(VisiblyUninhabited) => continue,\n+                        Continue(()) => return CONTINUE_OPAQUELY_INHABITED,\n+                    }\n+                }\n+                BREAK_VISIBLY_UNINHABITED\n+            }\n+        }\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        variant: VariantId,\n+        variant_data: &VariantData,\n+        subst: &Substitution,\n+        attrs: &Attrs,\n+        is_local: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        let non_exhaustive_field_list = attrs.by_key(\"non_exhaustive\").exists();\n+        if non_exhaustive_field_list && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        let is_enum = matches!(variant, VariantId::EnumVariantId(..));\n+        let field_tys = self.db.field_types(variant);\n+        let field_vis = self.db.field_visibilities(variant);\n+\n+        for (fid, _) in variant_data.fields().iter() {\n+            self.visit_field(field_vis[fid], &field_tys[fid], subst, is_enum)?;\n+        }\n+        CONTINUE_OPAQUELY_INHABITED\n+    }\n+\n+    fn visit_field(\n+        &mut self,\n+        vis: Visibility,\n+        ty: &Binders<Ty>,\n+        subst: &Substitution,\n+        is_enum: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        if is_enum || vis.is_visible_from(self.db.upcast(), self.target_mod) {\n+            let ty = ty.clone().substitute(Interner, subst);\n+            ty.visit_with(self, DebruijnIndex::INNERMOST)\n+        } else {\n+            CONTINUE_OPAQUELY_INHABITED\n+        }\n+    }\n+}\n+\n+fn try_usize_const(c: &Const) -> Option<u128> {\n+    let data = &c.data(Interner);\n+    if data.ty.kind(Interner) != &TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)) {\n+        return None;\n+    }\n+    match data.value {\n+        ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(value) }) => Some(value),\n+        _ => None,\n+    }\n+}"}, {"sha": "a82a331d4b8750e99c5fb8f69b6b04cf8007e96e", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -14,6 +14,7 @@ mod chalk_db;\n mod chalk_ext;\n pub mod consteval;\n mod infer;\n+mod inhabitedness;\n mod interner;\n mod lower;\n mod mapping;"}, {"sha": "c24430ce604692de844a2cc86cea6e0e2bc24abe", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8153e4a543d00126b402c24e9c119d8c76e74b/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=4f8153e4a543d00126b402c24e9c119d8c76e74b", "patch": "@@ -947,6 +947,50 @@ fn f() {\n         );\n     }\n \n+    mod rust_unstable {\n+        use super::*;\n+\n+        #[test]\n+        fn rfc_1872_exhaustive_patterns() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option, result\n+#![feature(exhaustive_patterns)]\n+enum Void {}\n+fn test() {\n+    match None::<!> { None => () }\n+    match Result::<u8, !>::Ok(2) { Ok(_) => () }\n+    match Result::<u8, Void>::Ok(2) { Ok(_) => () }\n+    match (2, loop {}) {}\n+    match Result::<!, !>::Ok(loop {}) {}\n+    match (&loop {}) {} // https://github.com/rust-lang/rust/issues/50642#issuecomment-388234919\n+    //    ^^^^^^^^^^ error: missing match arm: type `&!` is non-empty\n+}\",\n+            );\n+        }\n+\n+        #[test]\n+        fn rfc_1872_private_uninhabitedness() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option\n+//- /lib.rs crate:lib\n+#![feature(exhaustive_patterns)]\n+pub struct PrivatelyUninhabited { private_field: Void }\n+enum Void {}\n+fn test_local(x: Option<PrivatelyUninhabited>) {\n+    match x {}\n+} //      ^ error: missing match arm: `None` not covered\n+//- /main.rs crate:main deps:lib\n+#![feature(exhaustive_patterns)]\n+fn test(x: Option<lib::PrivatelyUninhabited>) {\n+    match x {}\n+    //    ^ error: missing match arm: `None` and `Some(_)` not covered\n+}\",\n+            );\n+        }\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}]}