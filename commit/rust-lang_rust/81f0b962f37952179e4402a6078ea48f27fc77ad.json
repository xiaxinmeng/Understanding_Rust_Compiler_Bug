{"sha": "81f0b962f37952179e4402a6078ea48f27fc77ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZjBiOTYyZjM3OTUyMTc5ZTQ0MDJhNjA3OGVhNDhmMjdmYzc3YWQ=", "commit": {"author": {"name": "Aravind Gollakota", "email": "aravindprasant@gmail.com", "date": "2018-03-04T00:47:17Z"}, "committer": {"name": "Aravind Gollakota", "email": "aravindprasant@gmail.com", "date": "2018-03-04T00:47:17Z"}, "message": "Refactor away `inferred_obligations` from the trait selector", "tree": {"sha": "a12338847d4a29ad6874d8fc1e5be9695a3e4bf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a12338847d4a29ad6874d8fc1e5be9695a3e4bf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f0b962f37952179e4402a6078ea48f27fc77ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f0b962f37952179e4402a6078ea48f27fc77ad", "html_url": "https://github.com/rust-lang/rust/commit/81f0b962f37952179e4402a6078ea48f27fc77ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f0b962f37952179e4402a6078ea48f27fc77ad/comments", "author": {"login": "aravind-pg", "id": 6913107, "node_id": "MDQ6VXNlcjY5MTMxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/6913107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aravind-pg", "html_url": "https://github.com/aravind-pg", "followers_url": "https://api.github.com/users/aravind-pg/followers", "following_url": "https://api.github.com/users/aravind-pg/following{/other_user}", "gists_url": "https://api.github.com/users/aravind-pg/gists{/gist_id}", "starred_url": "https://api.github.com/users/aravind-pg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aravind-pg/subscriptions", "organizations_url": "https://api.github.com/users/aravind-pg/orgs", "repos_url": "https://api.github.com/users/aravind-pg/repos", "events_url": "https://api.github.com/users/aravind-pg/events{/privacy}", "received_events_url": "https://api.github.com/users/aravind-pg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aravind-pg", "id": 6913107, "node_id": "MDQ6VXNlcjY5MTMxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/6913107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aravind-pg", "html_url": "https://github.com/aravind-pg", "followers_url": "https://api.github.com/users/aravind-pg/followers", "following_url": "https://api.github.com/users/aravind-pg/following{/other_user}", "gists_url": "https://api.github.com/users/aravind-pg/gists{/gist_id}", "starred_url": "https://api.github.com/users/aravind-pg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aravind-pg/subscriptions", "organizations_url": "https://api.github.com/users/aravind-pg/orgs", "repos_url": "https://api.github.com/users/aravind-pg/repos", "events_url": "https://api.github.com/users/aravind-pg/events{/privacy}", "received_events_url": "https://api.github.com/users/aravind-pg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8bd530b0ec0dc7538c12799468867662f818cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8bd530b0ec0dc7538c12799468867662f818cc", "html_url": "https://github.com/rust-lang/rust/commit/3b8bd530b0ec0dc7538c12799468867662f818cc"}], "stats": {"total": 125, "additions": 40, "deletions": 85}, "files": [{"sha": "26ff5756ba0bb5647a1385f59b202f8a9ff2ad18", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81f0b962f37952179e4402a6078ea48f27fc77ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f0b962f37952179e4402a6078ea48f27fc77ad/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=81f0b962f37952179e4402a6078ea48f27fc77ad", "patch": "@@ -854,19 +854,6 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n-        match self {\n-            &mut VtableImpl(ref mut i) => &mut i.nested,\n-            &mut VtableParam(ref mut n) => n,\n-            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n-            &mut VtableAutoImpl(ref mut d) => &mut d.nested,\n-            &mut VtableGenerator(ref mut c) => &mut c.nested,\n-            &mut VtableClosure(ref mut c) => &mut c.nested,\n-            &mut VtableObject(ref mut d) => &mut d.nested,\n-            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n-        }\n-    }\n-\n     pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M> where F: FnMut(N) -> M {\n         match self {\n             VtableImpl(i) => VtableImpl(VtableImplData {"}, {"sha": "9ebc9152a488a24c3296078bf9f2b5eacf1233bd", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 40, "deletions": 72, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/81f0b962f37952179e4402a6078ea48f27fc77ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f0b962f37952179e4402a6078ea48f27fc77ad/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=81f0b962f37952179e4402a6078ea48f27fc77ad", "patch": "@@ -44,27 +44,17 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::iter;\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n-use std::marker::PhantomData;\n use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use lint;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-struct InferredObligationsSnapshotVecDelegate<'tcx> {\n-    phantom: PhantomData<&'tcx i32>,\n-}\n-impl<'tcx> SnapshotVecDelegate for InferredObligationsSnapshotVecDelegate<'tcx> {\n-    type Value = PredicateObligation<'tcx>;\n-    type Undo = ();\n-    fn reverse(_: &mut Vec<Self::Value>, _: Self::Undo) {}\n-}\n \n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -92,8 +82,6 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: Option<IntercrateMode>,\n \n-    inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n-\n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n     /// Controls whether or not to filter out negative impls when selecting.\n@@ -429,7 +417,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -442,7 +429,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: Some(mode),\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -455,7 +441,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n         }\n@@ -498,8 +483,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        // The irrefutable nature of the operation means we don't need to snapshot the\n-        // inferred_obligations vector.\n         self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n     }\n \n@@ -508,28 +491,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn probe<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n-        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-        result\n+        self.infcx.probe(|snapshot| f(self, snapshot))\n     }\n \n     /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n     /// the transaction fails and s.t. old obligations are retained.\n     fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n         F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n-            Ok(ok) => {\n-                self.inferred_obligations.commit(inferred_obligations_snapshot);\n-                Ok(ok)\n-            },\n-            Err(err) => {\n-                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-                Err(err)\n-            }\n-        }\n+        self.infcx.commit_if_ok(|snapshot| f(self, snapshot))\n     }\n \n \n@@ -560,12 +530,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         let ret = match self.candidate_from_obligation(&stack)? {\n             None => None,\n-            Some(candidate) => {\n-                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n-                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n-                candidate.nested_obligations_mut().extend(inferred_obligations);\n-                Some(candidate)\n-            },\n+            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n         };\n \n         // Test whether this is a `()` which was produced by defaulting a\n@@ -658,7 +623,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult\n-        where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n+        where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n@@ -695,7 +660,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(&obligation.cause, obligation.param_env, p) {\n                     Ok(InferOk { obligations, .. }) => {\n-                        self.inferred_obligations.extend(obligations);\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n                         EvaluatedToOk\n                     },\n                     Err(_) => EvaluatedToErr\n@@ -706,7 +671,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.inferred_obligations.extend(obligations);\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n                         EvaluatedToOk\n                     },\n                     Some(Err(_)) => EvaluatedToErr,\n@@ -1553,12 +1518,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        match self.infcx.at(&obligation.cause, obligation.param_env)\n-                        .sup(ty::Binder(skol_trait_ref), trait_bound) {\n-            Ok(InferOk { obligations, .. }) => {\n-                self.inferred_obligations.extend(obligations);\n-            }\n-            Err(_) => { return false; }\n+        if let Err(_) = self.infcx.at(&obligation.cause, obligation.param_env)\n+                                  .sup(ty::Binder(skol_trait_ref), trait_bound) {\n+            return false;\n         }\n \n         self.infcx.leak_check(false, obligation.cause.span, skol_map, snapshot).is_ok()\n@@ -2644,6 +2606,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         let mut upcast_trait_ref = None;\n+        let mut nested = vec![];\n         let vtable_base;\n \n         {\n@@ -2662,7 +2625,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         self.commit_if_ok(\n                             |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n-                        Ok(_) => { upcast_trait_ref = Some(t); false }\n+                        Ok(obligations) => {\n+                            upcast_trait_ref = Some(t);\n+                            nested.extend(obligations);\n+                            false\n+                        }\n                         Err(_) => { true }\n                     }\n                 });\n@@ -2680,7 +2647,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base,\n-            nested: vec![]\n+            nested,\n         }\n     }\n \n@@ -2737,7 +2704,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n-            obligations\n+            mut obligations\n         } = normalize_with_depth(self,\n                                  obligation.param_env,\n                                  obligation.cause.clone(),\n@@ -2749,10 +2716,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         Ok(VtableGeneratorData {\n             closure_def_id: closure_def_id,\n@@ -2798,10 +2766,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         obligations.push(Obligation::new(\n             obligation.cause.clone(),\n@@ -2845,13 +2814,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                obligation_param_env: ty::ParamEnv<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n-                               -> Result<(), SelectionError<'tcx>>\n+                               -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx\n             .at(&obligation_cause, obligation_param_env)\n             .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+            .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2888,7 +2857,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_trait)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2950,7 +2919,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(b, a)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -3014,7 +2983,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_struct)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3045,7 +3014,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_tuple)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested T: Unsize<U> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3118,7 +3087,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   impl_substs);\n \n-        let impl_trait_ref =\n+        let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =\n             project::normalize_with_depth(self,\n                                           obligation.param_env,\n                                           obligation.cause.clone(),\n@@ -3134,12 +3103,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let InferOk { obligations, .. } =\n             self.infcx.at(&obligation.cause, obligation.param_env)\n-                      .eq(skol_obligation_trait_ref, impl_trait_ref.value)\n+                      .eq(skol_obligation_trait_ref, impl_trait_ref)\n                       .map_err(|e| {\n                           debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                           ()\n                       })?;\n-        self.inferred_obligations.extend(obligations);\n+        nested_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n                                               obligation.cause.span,\n@@ -3152,7 +3121,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok((Normalized {\n             value: impl_substs,\n-            obligations: impl_trait_ref.obligations\n+            obligations: nested_obligations\n         }, skol_map))\n     }\n \n@@ -3189,24 +3158,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        self.match_poly_trait_ref(obligation, where_clause_trait_ref)?;\n-        Ok(Vec::new())\n+        self.match_poly_trait_ref(obligation, where_clause_trait_ref)\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n     fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n-                            -> Result<(),()>\n+                            -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n         debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n                obligation,\n                poly_trait_ref);\n \n         self.infcx.at(&obligation.cause, obligation.param_env)\n                   .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n-                  .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+                  .map(|InferOk { obligations, .. }| obligations)\n                   .map_err(|_| ())\n     }\n "}]}