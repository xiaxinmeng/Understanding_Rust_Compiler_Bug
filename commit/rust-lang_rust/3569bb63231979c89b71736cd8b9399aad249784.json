{"sha": "3569bb63231979c89b71736cd8b9399aad249784", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NjliYjYzMjMxOTc5Yzg5YjcxNzM2Y2Q4YjkzOTlhYWQyNDk3ODQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-17T18:14:11Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-22T17:05:58Z"}, "message": "Update const-checker to replicate `qualify_min_const_fn`", "tree": {"sha": "122e20865122c77c0a3c718bab38980028a64af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122e20865122c77c0a3c718bab38980028a64af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3569bb63231979c89b71736cd8b9399aad249784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3569bb63231979c89b71736cd8b9399aad249784", "html_url": "https://github.com/rust-lang/rust/commit/3569bb63231979c89b71736cd8b9399aad249784", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3569bb63231979c89b71736cd8b9399aad249784/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ee5429e006af853827718fca42d6741ff26236e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ee5429e006af853827718fca42d6741ff26236e", "html_url": "https://github.com/rust-lang/rust/commit/5ee5429e006af853827718fca42d6741ff26236e"}], "stats": {"total": 341, "additions": 268, "deletions": 73}, "files": [{"sha": "0c171bbc464a2b0650c52906da21ce3ac63386d4", "filename": "compiler/rustc_mir/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3569bb63231979c89b71736cd8b9399aad249784/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569bb63231979c89b71736cd8b9399aad249784/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=3569bb63231979c89b71736cd8b9399aad249784", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n \n use super::ops;\n use super::qualifs::{NeedsDrop, Qualif};"}, {"sha": "55f49ab2be16bc3b36aa3a255df4838c4f09c491", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 267, "deletions": 72, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/3569bb63231979c89b71736cd8b9399aad249784/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3569bb63231979c89b71736cd8b9399aad249784/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=3569bb63231979c89b71736cd8b9399aad249784", "patch": "@@ -7,19 +7,21 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::{self, Instance, InstanceDef, TyCtxt};\n-use rustc_span::Span;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{\n+    self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt, TypeAndMut,\n+};\n+use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::{self, TraitEngine};\n \n-use std::borrow::Cow;\n use std::ops::Deref;\n \n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, CustomEq, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstCx, Qualif};\n-use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n+use crate::const_eval::is_unstable_const_fn;\n use crate::dataflow::impls::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n \n@@ -199,26 +201,51 @@ impl Validator<'mir, 'tcx> {\n     }\n \n     pub fn check_body(&mut self) {\n-        let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n-\n-        let use_min_const_fn_checks = (const_kind == Some(hir::ConstContext::ConstFn)\n-            && crate::const_eval::is_min_const_fn(tcx, def_id.to_def_id()))\n-            && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n-\n-        if use_min_const_fn_checks {\n-            // Enforce `min_const_fn` for stable `const fn`s.\n-            use crate::transform::qualify_min_const_fn::is_min_const_fn;\n-            if let Err((span, err)) = is_min_const_fn(tcx, def_id.to_def_id(), &body) {\n-                error_min_const_fn_violation(tcx, span, err);\n-                return;\n+        let ConstCx { tcx, body, def_id, .. } = *self.ccx;\n+\n+        // HACK: This function has side-effects???? Make sure we call it.\n+        let _ = crate::const_eval::is_min_const_fn(tcx, def_id.to_def_id());\n+\n+        // The local type and predicate checks are not free and only relevant for `const fn`s.\n+        if self.const_kind() == hir::ConstContext::ConstFn {\n+            // Prevent const trait methods from being annotated as `stable`.\n+            // FIXME: Do this as part of stability checking.\n+            if self.is_const_stable_const_fn() {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(self.def_id);\n+                if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+                    struct_span_err!(\n+                        self.ccx.tcx.sess,\n+                        self.span,\n+                        E0723,\n+                        \"trait methods cannot be stable const fn\"\n+                    )\n+                    .emit();\n+                }\n+            }\n+\n+            self.check_item_predicates();\n+\n+            for local in &body.local_decls {\n+                if local.internal {\n+                    continue;\n+                }\n+\n+                self.span = local.source_info.span;\n+                self.check_local_or_return_ty(local.ty);\n             }\n+\n+            // impl trait is gone in MIR, so check the return type of a const fn by its signature\n+            // instead of the type of the return place.\n+            self.span = body.local_decls[RETURN_PLACE].source_info.span;\n+            let return_ty = tcx.fn_sig(def_id).output();\n+            self.check_local_or_return_ty(return_ty.skip_binder());\n         }\n \n         self.visit_body(&body);\n \n         // Ensure that the end result is `Sync` in a non-thread local `static`.\n-        let should_check_for_sync = const_kind\n-            == Some(hir::ConstContext::Static(hir::Mutability::Not))\n+        let should_check_for_sync = self.const_kind()\n+            == hir::ConstContext::Static(hir::Mutability::Not)\n             && !tcx.is_thread_local_static(def_id.to_def_id());\n \n         if should_check_for_sync {\n@@ -258,6 +285,100 @@ impl Validator<'mir, 'tcx> {\n         );\n         self.check_op_spanned(ops::StaticAccess, span)\n     }\n+\n+    fn check_local_or_return_ty(&mut self, ty: Ty<'tcx>) {\n+        for ty in ty.walk() {\n+            let ty = match ty.unpack() {\n+                GenericArgKind::Type(ty) => ty,\n+\n+                // No constraints on lifetimes or constants, except potentially\n+                // constants' types, but `walk` will get to them as well.\n+                GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+            };\n+\n+            match *ty.kind() {\n+                ty::Ref(_, _, hir::Mutability::Mut) => self.check_op(ops::ty::MutRef),\n+                ty::Opaque(..) => self.check_op(ops::ty::ImplTrait),\n+                ty::FnPtr(..) => self.check_op(ops::ty::FnPtr),\n+\n+                ty::Dynamic(preds, _) => {\n+                    for pred in preds.iter() {\n+                        match pred.skip_binder() {\n+                            ty::ExistentialPredicate::AutoTrait(_)\n+                            | ty::ExistentialPredicate::Projection(_) => {\n+                                self.check_op(ops::ty::TraitBound)\n+                            }\n+                            ty::ExistentialPredicate::Trait(trait_ref) => {\n+                                if Some(trait_ref.def_id) != self.tcx.lang_items().sized_trait() {\n+                                    self.check_op(ops::ty::TraitBound)\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn check_item_predicates(&mut self) {\n+        let ConstCx { tcx, def_id, .. } = *self.ccx;\n+\n+        let mut current = def_id.to_def_id();\n+        loop {\n+            let predicates = tcx.predicates_of(current);\n+            for (predicate, _) in predicates.predicates {\n+                match predicate.skip_binders() {\n+                    ty::PredicateAtom::RegionOutlives(_)\n+                    | ty::PredicateAtom::TypeOutlives(_)\n+                    | ty::PredicateAtom::WellFormed(_)\n+                    | ty::PredicateAtom::Projection(_)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..)\n+                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n+                    ty::PredicateAtom::ObjectSafe(_) => {\n+                        bug!(\"object safe predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::ClosureKind(..) => {\n+                        bug!(\"closure kind predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::Subtype(_) => {\n+                        bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                    }\n+                    ty::PredicateAtom::Trait(pred, constness) => {\n+                        if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n+                            continue;\n+                        }\n+                        match pred.self_ty().kind() {\n+                            ty::Param(p) => {\n+                                let generics = tcx.generics_of(current);\n+                                let def = generics.type_param(p, tcx);\n+                                let span = tcx.def_span(def.def_id);\n+\n+                                if constness == hir::Constness::Const {\n+                                    self.check_op_spanned(ops::ty::TraitBound, span);\n+                                } else if !tcx.features().const_fn\n+                                    || self.ccx.is_const_stable_const_fn()\n+                                {\n+                                    // HACK: We shouldn't need the conditional above, but trait\n+                                    // bounds on containing impl blocks are wrongly being marked as\n+                                    // \"not-const\".\n+                                    self.check_op_spanned(ops::ty::TraitBound, span);\n+                                }\n+                            }\n+                            // other kinds of bounds are either tautologies\n+                            // or cause errors in other passes\n+                            _ => continue,\n+                        }\n+                    }\n+                }\n+            }\n+            match predicates.parent {\n+                Some(parent) => current = parent,\n+                None => break,\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n@@ -325,11 +446,6 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)\n-            | Rvalue::UnaryOp(UnOp::Neg, _)\n-            | Rvalue::UnaryOp(UnOp::Not, _)\n-            | Rvalue::NullaryOp(NullOp::SizeOf, _)\n-            | Rvalue::CheckedBinaryOp(..)\n-            | Rvalue::Cast(CastKind::Pointer(_), ..)\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(_)\n             | Rvalue::Aggregate(..) => {}\n@@ -379,6 +495,35 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n+            Rvalue::Cast(\n+                CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n+                _,\n+                _,\n+            ) => {}\n+\n+            Rvalue::Cast(\n+                CastKind::Pointer(\n+                    PointerCast::UnsafeFnPointer\n+                    | PointerCast::ClosureFnPointer(_)\n+                    | PointerCast::ReifyFnPointer,\n+                ),\n+                _,\n+                _,\n+            ) => self.check_op(ops::FnPtrCast),\n+\n+            Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), _, cast_ty) => {\n+                if let Some(TypeAndMut { ty, .. }) = cast_ty.builtin_deref(true) {\n+                    let unsized_ty = self.tcx.struct_tail_erasing_lifetimes(ty, self.param_env);\n+\n+                    // Casting/coercing things to slices is fine.\n+                    if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n+                        return;\n+                    }\n+                }\n+\n+                self.check_op(ops::UnsizingCast);\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n@@ -389,8 +534,23 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) => {}\n+            Rvalue::NullaryOp(NullOp::Box, _) => self.check_op(ops::HeapAllocation),\n+\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                let ty = operand.ty(self.body, self.tcx);\n+                if !(ty.is_integral() || ty.is_bool()) {\n+                    self.check_op(ops::NonPrimitiveOp)\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs)\n+            | Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(self.body, self.tcx);\n+                let rhs_ty = rhs.ty(self.body, self.tcx);\n+\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs_ty.kind() {\n+                    assert_eq!(lhs_ty, rhs_ty);\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -403,10 +563,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                     self.check_op(ops::RawPtrComparison);\n                 }\n-            }\n \n-            Rvalue::NullaryOp(NullOp::Box, _) => {\n-                self.check_op(ops::HeapAllocation);\n+                if !(lhs_ty.is_integral() || lhs_ty.is_bool() || lhs_ty.is_char())\n+                    || !(rhs_ty.is_integral() || rhs_ty.is_bool() || rhs_ty.is_char())\n+                {\n+                    self.check_op(ops::NonPrimitiveOp)\n+                }\n             }\n         }\n     }\n@@ -507,14 +669,19 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        use rustc_target::spec::abi::Abi::RustIntrinsic;\n+\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n             TerminatorKind::Call { func, .. } => {\n-                let fn_ty = func.ty(self.body, self.tcx);\n+                let ConstCx { tcx, body, def_id: caller, param_env, .. } = *self.ccx;\n+                let caller = caller.to_def_id();\n+\n+                let fn_ty = func.ty(body, tcx);\n \n-                let (def_id, substs) = match *fn_ty.kind() {\n+                let (mut callee, substs) = match *fn_ty.kind() {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n \n                     ty::FnPtr(_) => {\n@@ -526,38 +693,78 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     }\n                 };\n \n-                // At this point, we are calling a function whose `DefId` is known...\n-                if is_const_fn(self.tcx, def_id) {\n-                    return;\n-                }\n-\n-                // See if this is a trait method for a concrete type whose impl of that trait is\n-                // `const`.\n                 if self.tcx.features().const_trait_impl {\n-                    let instance = Instance::resolve(self.tcx, self.param_env, def_id, substs);\n-                    debug!(\"Resolving ({:?}) -> {:?}\", def_id, instance);\n+                    let instance = Instance::resolve(tcx, param_env, callee, substs);\n+                    debug!(\"Resolving ({:?}) -> {:?}\", callee, instance);\n                     if let Ok(Some(func)) = instance {\n                         if let InstanceDef::Item(def) = func.def {\n-                            if is_const_fn(self.tcx, def.did) {\n-                                return;\n-                            }\n+                            callee = def.did;\n                         }\n                     }\n                 }\n \n-                if is_lang_panic_fn(self.tcx, def_id) {\n+                // At this point, we are calling a function, `callee`, whose `DefId` is known...\n+\n+                if is_lang_panic_fn(tcx, callee) {\n                     self.check_op(ops::Panic);\n-                } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n-                    // Exempt unstable const fns inside of macros or functions with\n-                    // `#[allow_internal_unstable]`.\n-                    use crate::transform::qualify_min_const_fn::lib_feature_allowed;\n-                    if !self.span.allows_unstable(feature)\n-                        && !lib_feature_allowed(self.tcx, self.def_id.to_def_id(), feature)\n-                    {\n-                        self.check_op(ops::FnCallUnstable(def_id, feature));\n+                    return;\n+                }\n+\n+                // HACK: This is to \"unstabilize\" the `transmute` intrinsic\n+                // within const fns. `transmute` is allowed in all other const contexts.\n+                // This won't really scale to more intrinsics or functions. Let's allow const\n+                // transmutes in const fn before we add more hacks to this.\n+                if tcx.fn_sig(callee).abi() == RustIntrinsic\n+                    && tcx.item_name(callee) == sym::transmute\n+                {\n+                    self.check_op(ops::Transmute);\n+                    return;\n+                }\n+\n+                if !tcx.is_const_fn_raw(callee) {\n+                    self.check_op(ops::FnCallNonConst(callee));\n+                    return;\n+                }\n+\n+                // If the `const fn` we are trying to call is not const-stable, ensure that we have\n+                // the proper feature gate enabled.\n+                if let Some(gate) = is_unstable_const_fn(tcx, callee) {\n+                    if self.span.allows_unstable(gate) {\n+                        return;\n+                    }\n+\n+                    // Calling an unstable function *always* requires that the corresponding gate\n+                    // be enabled, even if the function has `#[allow_internal_unstable(the_gate)]`.\n+                    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate) {\n+                        self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n+                        return;\n+                    }\n+\n+                    // If this crate is not using stability attributes, or the caller is not claiming to be a\n+                    // stable `const fn`, that is all that is required.\n+                    if !self.ccx.is_const_stable_const_fn() {\n+                        return;\n+                    }\n+\n+                    // Otherwise, we are something const-stable calling a const-unstable fn.\n+\n+                    if super::allow_internal_unstable(tcx, caller, gate) {\n+                        return;\n+                    }\n+\n+                    self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n+                    return;\n+                }\n+\n+                // FIXME(ecstaticmorse); For compatibility, we consider `unstable` callees that\n+                // have no `rustc_const_stable` attributes to be const-unstable as well. This\n+                // should be fixed later.\n+                let callee_is_unstable_unmarked = tcx.lookup_const_stability(callee).is_none()\n+                    && tcx.lookup_stability(callee).map_or(false, |s| s.level.is_unstable());\n+                if callee_is_unstable_unmarked {\n+                    if self.ccx.is_const_stable_const_fn() {\n+                        self.check_op(ops::FnCallUnstable(callee, None));\n                     }\n-                } else {\n-                    self.check_op(ops::FnCallNonConst(def_id));\n                 }\n             }\n \n@@ -598,37 +805,25 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 }\n             }\n \n-            TerminatorKind::InlineAsm { .. } => {\n-                self.check_op(ops::InlineAsm);\n+            TerminatorKind::InlineAsm { .. } => self.check_op(ops::InlineAsm),\n+            TerminatorKind::Abort => self.check_op(ops::Abort),\n+\n+            TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n+                self.check_op(ops::Generator)\n             }\n \n-            // FIXME: Some of these are only caught by `min_const_fn`, but should error here\n-            // instead.\n-            TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n+            TerminatorKind::Assert { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n             | TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Return\n             | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable\n-            | TerminatorKind::Yield { .. } => {}\n+            | TerminatorKind::Unreachable => {}\n         }\n     }\n }\n \n-fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n-    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n-        .note(\n-            \"see issue #57563 <https://github.com/rust-lang/rust/issues/57563> \\\n-             for more information\",\n-        )\n-        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n-        .emit();\n-}\n-\n fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {"}]}