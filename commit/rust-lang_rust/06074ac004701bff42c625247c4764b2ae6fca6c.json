{"sha": "06074ac004701bff42c625247c4764b2ae6fca6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDc0YWMwMDQ3MDFiZmY0MmM2MjUyNDdjNDc2NGIyYWU2ZmNhNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T05:55:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T05:55:14Z"}, "message": "Auto merge of #32141 - jseyfried:fix_resolution_in_lexical_scopes, r=nikomatsakis\n\nFix name resolution in lexical scopes\n\nCurrently, `resolve_item_in_lexical_scope` does not check the \"ribs\" (type parameters and local variables). This can allow items that should be shadowed by type parameters to be named.\n\nFor example,\n```rust\nstruct T { i: i32 }\nfn f<T>() {\n    let t = T { i: 0 }; // This use of `T` resolves to the struct, not the type parameter\n}\n\nmod Foo {\n    pub fn f() {}\n}\nfn g<Foo>() {\n    Foo::f(); // This use of `Foo` resolves to the module, not the type parameter\n}\n```\n\nThis PR changes `resolve_item_in_lexical_scope` so that it fails when the item is shadowed by a rib (fixes #32120).\nThis is a [breaking-change], but it looks unlikely to cause breakage in practice.\n\nr? @nikomatsakis", "tree": {"sha": "2a0fcf29c5dbfab69629fe2211b64ca089609f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a0fcf29c5dbfab69629fe2211b64ca089609f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06074ac004701bff42c625247c4764b2ae6fca6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06074ac004701bff42c625247c4764b2ae6fca6c", "html_url": "https://github.com/rust-lang/rust/commit/06074ac004701bff42c625247c4764b2ae6fca6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06074ac004701bff42c625247c4764b2ae6fca6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e05371c13f851a5af57a96a5e13c99537787314", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e05371c13f851a5af57a96a5e13c99537787314", "html_url": "https://github.com/rust-lang/rust/commit/3e05371c13f851a5af57a96a5e13c99537787314"}, {"sha": "e926f281dfc9baec0e01fb6aa82eb1bf8a0645c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e926f281dfc9baec0e01fb6aa82eb1bf8a0645c4", "html_url": "https://github.com/rust-lang/rust/commit/e926f281dfc9baec0e01fb6aa82eb1bf8a0645c4"}], "stats": {"total": 186, "additions": 75, "deletions": 111}, "files": [{"sha": "9a4173bad6e4c2228382528d901e137b1b58bde0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 51, "deletions": 109, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=06074ac004701bff42c625247c4764b2ae6fca6c", "patch": "@@ -1166,8 +1166,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             unresolved_imports: 0,\n \n             current_module: graph_root,\n-            value_ribs: Vec::new(),\n-            type_ribs: Vec::new(),\n+            value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n+            type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n@@ -1354,7 +1354,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// On success, returns the resolved module, and the closest *private*\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n-                           module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n@@ -1365,10 +1364,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),\n-               module_to_string(&module_));\n+               module_to_string(self.current_module));\n \n         // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n+        let module_prefix_result = self.resolve_module_prefix(module_path);\n \n         let search_module;\n         let start_index;\n@@ -1410,8 +1409,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_item_in_lexical_scope(module_,\n-                                                                 module_path[0],\n+                        match self.resolve_item_in_lexical_scope(module_path[0],\n                                                                  TypeNS,\n                                                                  true) {\n                             Failed(err) => return Failed(err),\n@@ -1442,64 +1440,40 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            span)\n     }\n \n+    /// This function resolves `name` in `namespace` in the current lexical scope, returning\n+    /// Success(binding) if `name` resolves to an item, or Failed(None) if `name` does not resolve\n+    /// or resolves to a type parameter or local variable.\n+    /// n.b. `resolve_identifier_in_local_ribs` also resolves names in the current lexical scope.\n+    ///\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n-                                     module_: Module<'a>,\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n                                      -> ResolveResult<&'a NameBinding<'a>> {\n-        debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n-               name,\n-               namespace,\n-               module_to_string(&module_));\n-\n-        // Proceed up the scope chain looking for parent modules.\n-        let mut search_module = module_;\n-        loop {\n-            // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n-                Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                Failed(None) => (), // Continue up the search chain.\n-                Indeterminate => {\n-                    // We couldn't see through the higher scope because of an\n-                    // unresolved import higher up. Bail.\n-\n-                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n-                    return Indeterminate;\n-                }\n-                Success(binding) => {\n-                    // We found the module.\n-                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success(binding);\n-                }\n+        // Walk backwards up the ribs in scope.\n+        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n+            if let Some(_) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n+                // The name resolves to a type parameter or local variable, so return Failed(None).\n+                return Failed(None);\n             }\n \n-            // Go to the next parent.\n-            match search_module.parent_link {\n-                NoParentLink => {\n-                    // No more parents. This module was unresolved.\n-                    debug!(\"(resolving item in lexical scope) unresolved module: no parent module\");\n-                    return Failed(None);\n-                }\n-                ModuleParentLink(parent_module_node, _) => {\n-                    if search_module.is_normal() {\n-                        // We stop the search here.\n-                        debug!(\"(resolving item in lexical scope) unresolved module: not \\\n-                                searching through module parents\");\n-                            return Failed(None);\n-                    } else {\n-                        search_module = parent_module_node;\n-                    }\n-                }\n-                BlockParentLink(parent_module_node, _) => {\n-                    search_module = parent_module_node;\n+            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n+                if let Success(binding) = self.resolve_name_in_module(module,\n+                                                                      name,\n+                                                                      namespace,\n+                                                                      true,\n+                                                                      record_used) {\n+                    // The name resolves to an item.\n+                    return Success(binding);\n                 }\n+                // We can only see through anonymous modules\n+                if module.def.is_some() { return Failed(None); }\n             }\n         }\n+\n+        Failed(None)\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n@@ -1535,9 +1509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self,\n-                             module_: Module<'a>,\n-                             module_path: &[Name])\n+    fn resolve_module_prefix(&mut self, module_path: &[Name])\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -1546,6 +1518,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n+        let module_ = self.current_module;\n         let mut containing_module = self.get_nearest_normal_module_parent_or_self(module_);\n \n         // Now loop through all the `super`s we find.\n@@ -1905,7 +1878,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                trait_path: &Path,\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n-        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n+        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n             if let Def::Trait(_) = path_res.base_def {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n@@ -1963,7 +1936,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &hir::WherePredicate::BoundPredicate(_) |\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true);\n+                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS);\n                     if let Some(PathResolution { base_def: Def::TyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n@@ -2229,8 +2202,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let resolution = match self.resolve_possibly_assoc_item(ty.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n-                                                                        TypeNS,\n-                                                                        true) {\n+                                                                        TypeNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n@@ -2255,7 +2227,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, err_path_resolution());\n \n                         // Keep reporting some errors even if they're ignored above.\n-                        self.resolve_path(ty.id, path, 0, TypeNS, true);\n+                        self.resolve_path(ty.id, path, 0, TypeNS);\n \n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n@@ -2433,8 +2405,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n                                                                             path,\n-                                                                            ValueNS,\n-                                                                            false) {\n+                                                                            ValueNS) {\n                         // The below shouldn't happen because all\n                         // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n@@ -2506,8 +2477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             Some(qself),\n                                                                             path,\n-                                                                            ValueNS,\n-                                                                            false) {\n+                                                                            ValueNS) {\n                         TypecheckRequired => {\n                             // All `<T>::CONST` should end up here, and will\n                             // require use of the trait map to resolve\n@@ -2557,7 +2527,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n \n                 PatKind::Struct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, 0, TypeNS, false) {\n+                    match self.resolve_path(pat_id, path, 0, TypeNS) {\n                         Some(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -2591,8 +2561,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        name: Name,\n                                        span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        let module = self.current_module;\n-        match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n+        match self.resolve_item_in_lexical_scope(name, ValueNS, true) {\n             Success(binding) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n@@ -2639,8 +2608,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    id: NodeId,\n                                    maybe_qself: Option<&hir::QSelf>,\n                                    path: &Path,\n-                                   namespace: Namespace,\n-                                   check_ribs: bool)\n+                                   namespace: Namespace)\n                                    -> AssocItemResolveResult {\n         let max_assoc_types;\n \n@@ -2659,14 +2627,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace, check_ribs)\n+            this.resolve_path(id, path, 0, namespace)\n         });\n         for depth in 1..max_assoc_types {\n             if resolution.is_some() {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS, true);\n+                resolution = this.resolve_path(id, path, depth, TypeNS);\n             });\n         }\n         if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n@@ -2676,16 +2644,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ResolveAttempt(resolution)\n     }\n \n-    /// If `check_ribs` is true, checks the local definitions first; i.e.\n-    /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `middle::def::PathResolution` for more info.\n     pub fn resolve_path(&mut self,\n                         id: NodeId,\n                         path: &Path,\n                         path_depth: usize,\n-                        namespace: Namespace,\n-                        check_ribs: bool)\n+                        namespace: Namespace)\n                         -> Option<PathResolution> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n@@ -2700,14 +2665,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Try to find a path to an item in a module.\n         let last_ident = segments.last().unwrap().identifier;\n         if segments.len() <= 1 {\n-            let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, true);\n+            let unqualified_def = self.resolve_identifier(last_ident, namespace, true);\n             return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n                                   .map(|def| {\n                                       PathResolution::new(def, path_depth)\n                                   });\n         }\n \n-        let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, false);\n+        let unqualified_def = self.resolve_identifier(last_ident, namespace, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n             (Some(d), Some(ref ud)) if d == ud.def => {\n@@ -2727,7 +2692,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_identifier(&mut self,\n                           identifier: hir::Ident,\n                           namespace: Namespace,\n-                          check_ribs: bool,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n         if identifier.name == special_idents::invalid.name {\n@@ -2743,24 +2707,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        if check_ribs {\n-            match self.resolve_identifier_in_local_ribs(identifier, namespace, record_used) {\n-                Some(def) => return Some(def),\n-                None => {}\n-            }\n-        }\n-\n-        // Check the items.\n-        let module = self.current_module;\n-        let name = identifier.unhygienic_name;\n-        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success(binding) => binding.def().map(LocalDef::from_def),\n-            Failed(Some((span, msg))) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                None\n-            }\n-            _ => None,\n-        }\n+        self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2866,8 +2813,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        let current_module = self.current_module;\n-        match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n+        match self.resolve_module_path(&module_path, UseLexicalScope, span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3021,7 +2967,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 span: Span,\n                                 name_path: &[ast::Name])\n                                 -> Option<Module<'a>> {\n-            let root = this.current_module;\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n@@ -3031,7 +2976,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n-                this.resolve_module_path(root, &name_path, UseLexicalScope, span).success()\n+                this.resolve_module_path(&name_path, UseLexicalScope, span).success()\n             }\n         }\n \n@@ -3142,8 +3087,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let resolution = match self.resolve_possibly_assoc_item(expr.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n-                                                                        ValueNS,\n-                                                                        true) {\n+                                                                        ValueNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n@@ -3203,7 +3147,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // structs, which wouldn't result in this error.)\n                     let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n-                        this.resolve_path(expr.id, path, 0, TypeNS, false)\n+                        this.resolve_path(expr.id, path, 0, TypeNS)\n                     });\n \n                     self.record_def(expr.id, err_path_resolution());\n@@ -3224,7 +3168,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         _ => {\n                             // Keep reporting some errors even if they're ignored above.\n-                            self.resolve_path(expr.id, path, 0, ValueNS, true);\n+                            self.resolve_path(expr.id, path, 0, ValueNS);\n \n                             let mut method_scope = false;\n                             self.value_ribs.iter().rev().all(|rib| {\n@@ -3271,10 +3215,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let name_path = path.segments.iter()\n                                                         .map(|seg| seg.identifier.name)\n                                                         .collect::<Vec<_>>();\n-                                    let current_module = self.current_module;\n \n-                                    match self.resolve_module_path(current_module,\n-                                                                   &name_path[..],\n+                                    match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n                                                                    expr.span) {\n                                         Success(_) => {\n@@ -3300,7 +3242,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n-                match self.resolve_path(expr.id, path, 0, TypeNS, false) {\n+                match self.resolve_path(expr.id, path, 0, TypeNS) {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);"}, {"sha": "c4aa434092c0f026c5b1810093568595eff0922c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=06074ac004701bff42c625247c4764b2ae6fca6c", "patch": "@@ -444,8 +444,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(&module_));\n \n         self.resolver\n-            .resolve_module_path(module_,\n-                                 &import_directive.module_path,\n+            .resolve_module_path(&import_directive.module_path,\n                                  UseLexicalScopeFlag::DontUseLexicalScope,\n                                  import_directive.span)\n             .and_then(|containing_module| {"}, {"sha": "dbcd3f32f3b66f8af89f7029303d7344ce3147d8", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06074ac004701bff42c625247c4764b2ae6fca6c/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=06074ac004701bff42c625247c4764b2ae6fca6c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct T { i: i32 }\n+fn f<T>() {\n+    let t = T { i: 0 }; //~ ERROR `T` does not name a structure\n+}\n+\n+mod Foo {\n+    pub fn f() {}\n+}\n+fn g<Foo>() {\n+    Foo::f(); //~ ERROR no associated item named `f`\n+}\n+\n+fn main() {}"}]}