{"sha": "575950d12c38d79dcb2cac906f6664325d10ec9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTk1MGQxMmMzOGQ3OWRjYjJjYWM5MDZmNjY2NDMyNWQxMGVjOWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-23T17:35:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-23T17:41:33Z"}, "message": "rustc: Lower-case the error messages in kind.rs, for consistency", "tree": {"sha": "7715d7a155ab8eda10e399afe6919baf5c3cd09b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7715d7a155ab8eda10e399afe6919baf5c3cd09b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/575950d12c38d79dcb2cac906f6664325d10ec9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/575950d12c38d79dcb2cac906f6664325d10ec9d", "html_url": "https://github.com/rust-lang/rust/commit/575950d12c38d79dcb2cac906f6664325d10ec9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/575950d12c38d79dcb2cac906f6664325d10ec9d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce1466fbe5304cf50a159efdaa076495b1ccec70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1466fbe5304cf50a159efdaa076495b1ccec70", "html_url": "https://github.com/rust-lang/rust/commit/ce1466fbe5304cf50a159efdaa076495b1ccec70"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "fdc8fc7ea8eb51a2da1b2578810d7b74d6cf984c", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/575950d12c38d79dcb2cac906f6664325d10ec9d/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/575950d12c38d79dcb2cac906f6664325d10ec9d/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=575950d12c38d79dcb2cac906f6664325d10ec9d", "patch": "@@ -264,7 +264,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         };\n         if vec::len(*ts) != vec::len(*bounds) {\n             // Fail earlier to make debugging easier\n-            fail fmt!(\"Internal error: in kind::check_expr, length \\\n+            fail fmt!(\"internal error: in kind::check_expr, length \\\n                        mismatch between actual and declared bounds: actual = \\\n                         %s (%u tys), declared = %? (%u tys)\",\n                       tys_to_str(cx.tcx, *ts), ts.len(),\n@@ -279,29 +279,29 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(Some(ex)) => {\n-        maybe_copy(cx, ex, Some((\"Returned values must be copyable\",\n+        maybe_copy(cx, ex, Some((\"returned values must be copyable\",\n                                  try_adding)));\n       }\n       expr_cast(source, _) => {\n-        maybe_copy(cx, source, Some((\"Casted values must be copyable\",\n+        maybe_copy(cx, source, Some((\"casted values must be copyable\",\n                                      try_adding)));\n         check_cast_for_escaping_regions(cx, source, e);\n       }\n       expr_copy(expr) => check_copy_ex(cx, expr, false,\n-          Some((\"Explicit copy requires a copyable argument\", \"\"))),\n+          Some((\"explicit copy requires a copyable argument\", \"\"))),\n       // Vector add copies, but not \"implicitly\"\n       expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false,\n-                                   Some((\"Assignment with operation requires \\\n+                                   Some((\"assignment with operation requires \\\n                                           a copyable argument\", \"\"))),\n       expr_binary(add, ls, rs) => {\n-        let reason = Some((\"Binary operators require copyable arguments\",\n+        let reason = Some((\"binary operators require copyable arguments\",\n                            \"\"));\n         check_copy_ex(cx, ls, false, reason);\n         check_copy_ex(cx, rs, false, reason);\n       }\n       expr_rec(fields, def) | expr_struct(_, fields, def) => {\n         for fields.each |field| { maybe_copy(cx, field.node.expr,\n-                                   Some((\"Record or struct fields require \\\n+                                   Some((\"record or struct fields require \\\n                                           copyable arguments\", \"\"))); }\n         match def {\n           Some(ex) => {\n@@ -327,13 +327,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) => {\n         for exprs.each |expr| { maybe_copy(cx, *expr,\n-                    Some((\"Tuple or vec elements must be copyable\", \"\"))); }\n+                    Some((\"tuple or vec elements must be copyable\", \"\"))); }\n       }\n       expr_call(f, args, _) => {\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).eachi |i, arg_t| {\n             match ty::arg_mode(cx.tcx, *arg_t) {\n               by_copy => maybe_copy(cx, args[i],\n-                     Some((\"Callee takes its argument by copy\", \"\"))),\n+                     Some((\"callee takes its argument by copy\", \"\"))),\n               by_ref | by_val | by_move => ()\n             }\n         }\n@@ -345,7 +345,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             Some(ref mme) => {\n                 match ty::arg_mode(cx.tcx, mme.self_arg) {\n                     by_copy => maybe_copy(cx, lhs,\n-                      Some((\"Method call takes its self argument by copy\",\n+                      Some((\"method call takes its self argument by copy\",\n                             \"\"))),\n                     by_ref | by_val | by_move => ()\n                 }\n@@ -356,12 +356,12 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_repeat(element, count_expr, _) => {\n         let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n         if count == 1 {\n-            maybe_copy(cx, element, Some((\"Trivial repeat takes its element \\\n+            maybe_copy(cx, element, Some((\"trivial repeat takes its element \\\n                                            by copy\", \"\")));\n         } else {\n             let element_ty = ty::expr_ty(cx.tcx, element);\n             check_copy(cx, element.id, element_ty, element.span, true,\n-                       Some((\"Repeat takes its elements by copy\", \"\")));\n+                       Some((\"repeat takes its elements by copy\", \"\")));\n         }\n       }\n       _ => { }\n@@ -375,7 +375,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n         for locals.each |local| {\n             match local.node.init {\n               Some({op: init_assign, expr}) =>\n-                  maybe_copy(cx, expr, Some((\"Initializer statement \\\n+                  maybe_copy(cx, expr, Some((\"initializer statement \\\n                               takes its right-hand side by copy\", \"\"))),\n               _ => {}\n             }"}]}