{"sha": "b575c18992394f9723ddacee49665351874c7b30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NzVjMTg5OTIzOTRmOTcyM2RkYWNlZTQ5NjY1MzUxODc0YzdiMzA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-11T15:12:56Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:21:32Z"}, "message": "Refactoring generic counting loops", "tree": {"sha": "5061c717adb31d873b2a8388ffcb489669718e4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5061c717adb31d873b2a8388ffcb489669718e4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b575c18992394f9723ddacee49665351874c7b30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b575c18992394f9723ddacee49665351874c7b30", "html_url": "https://github.com/rust-lang/rust/commit/b575c18992394f9723ddacee49665351874c7b30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b575c18992394f9723ddacee49665351874c7b30/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe1f651e4c28bb39da739f1433d94c6ed6caec82", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe1f651e4c28bb39da739f1433d94c6ed6caec82", "html_url": "https://github.com/rust-lang/rust/commit/fe1f651e4c28bb39da739f1433d94c6ed6caec82"}], "stats": {"total": 138, "additions": 71, "deletions": 67}, "files": [{"sha": "4818006b9e7ebf4fb79957da6154974016d278f9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b575c18992394f9723ddacee49665351874c7b30", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n             types: 0,\n         };\n \n-        for param in self.params.iter() {\n+        for param in &self.params {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => own_counts.lifetimes += 1,\n                 GenericParamDefKind::Type(_) => own_counts.types += 1,\n@@ -814,7 +814,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     }\n \n     pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        for param in self.params.iter() {\n+        for param in &self.params {\n             match param.kind {\n                 GenericParamDefKind::Type(_) => return true,\n                 GenericParamDefKind::Lifetime => {}"}, {"sha": "ec685dd8c4c033e7389707590febcbdeb0f91c66", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b575c18992394f9723ddacee49665351874c7b30", "patch": "@@ -208,40 +208,39 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n-        let own_counts = decl_generics.own_counts();\n-        let num_types_provided = parameters.types.len();\n-        let expected_num_region_params = own_counts.lifetimes;\n-        let supplied_num_region_params = parameters.lifetimes.len();\n-        if expected_num_region_params != supplied_num_region_params {\n-            report_lifetime_number_error(tcx, span,\n-                                         supplied_num_region_params,\n-                                         expected_num_region_params);\n+        let ty_provided = parameters.types.len();\n+        let lt_provided = parameters.lifetimes.len();\n+\n+        let mut lt_accepted = 0;\n+        let mut ty_range = (0, 0);\n+        for param in &decl_generics.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    lt_accepted += 1;\n+                }\n+                GenericParamDefKind::Type(ty) => {\n+                    ty_range.1 += 1;\n+                    if !ty.has_default {\n+                        ty_range.0 += 1;\n+                    }\n+                }\n+            };\n+        }\n+        if self_ty.is_some() {\n+            ty_range.0 -= 1;\n+            ty_range.1 -= 1;\n+        }\n+\n+        if lt_accepted != lt_provided {\n+            report_lifetime_number_error(tcx, span, lt_provided, lt_accepted);\n         }\n \n         // If a self-type was declared, one should be provided.\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n-        let own_self = self_ty.is_some() as usize;\n-        let ty_param_defs = own_counts.types - own_self;\n-        if !infer_types || num_types_provided > ty_param_defs {\n-            let type_params_without_defaults = {\n-                let mut count = 0;\n-                for param in decl_generics.params.iter() {\n-                    if let ty::GenericParamDefKind::Type(ty) = param.kind {\n-                        if !ty.has_default {\n-                            count += 1\n-                        }\n-                    }\n-                }\n-                count\n-            };\n-\n-            check_type_argument_count(tcx,\n-                span,\n-                num_types_provided,\n-                ty_param_defs,\n-                type_params_without_defaults - own_self);\n+        if !infer_types || ty_provided > ty_range.0 {\n+            check_type_argument_count(tcx, span, ty_provided, ty_range);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n@@ -259,6 +258,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n+        let own_self = self_ty.is_some() as usize;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - own_self;\n             if let Some(lifetime) = parameters.lifetimes.get(i) {\n@@ -279,8 +279,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 _ => unreachable!()\n             };\n \n-            let i = i - (own_counts.lifetimes + own_self);\n-            if i < num_types_provided {\n+            let i = i - (lt_accepted + own_self);\n+            if i < ty_provided {\n                 // A provided type parameter.\n                 self.ast_ty_to_ty(&parameters.types[i])\n             } else if infer_types {\n@@ -1327,11 +1327,9 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n fn check_type_argument_count(tcx: TyCtxt,\n                              span: Span,\n                              supplied: usize,\n-                             ty_param_defs: usize,\n-                             ty_param_defs_without_default: usize)\n+                             ty_range: (usize, usize))\n {\n-    let accepted = ty_param_defs;\n-    let required = ty_param_defs_without_default;\n+    let (required, accepted) = ty_range;\n     if supplied < required {\n         let expected = if required < accepted {\n             \"expected at least\""}, {"sha": "70d29c60a101a6ec7bc83ff816d940d166a07e9b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b575c18992394f9723ddacee49665351874c7b30", "patch": "@@ -4923,32 +4923,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Check provided parameters.\n-        let (ty_req_len, accepted, lt_req_len) =\n-            segment.map_or((0, 0, 0), |(_, generics)| {\n-                let own_counts = generics.own_counts();\n-\n-                let own_self = (generics.parent.is_none() && generics.has_self) as usize;\n-                let type_params = own_counts.types - own_self;\n-                let type_params_without_defaults = {\n-                    let mut count = 0;\n-                    for param in generics.params.iter() {\n-                        if let ty::GenericParamDefKind::Type(ty) = param.kind {\n+        let ((ty_required, ty_accepted), lt_accepted) =\n+            segment.map_or(((0, 0), 0), |(_, generics)| {\n+                let mut lt_accepted = 0;\n+                let mut ty_range = (0, 0);\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n+                            lt_accepted += 1;\n+                        }\n+                        GenericParamDefKind::Type(ty) => {\n+                            ty_range.1 += 1;\n                             if !ty.has_default {\n-                                count += 1\n+                                ty_range.0 += 1;\n                             }\n                         }\n-                    }\n-                    count\n-                };\n-                let type_params_barring_defaults =\n-                    type_params_without_defaults - own_self;\n+                    };\n+                }\n+                if generics.parent.is_none() && generics.has_self {\n+                    ty_range.0 -= 1;\n+                    ty_range.1 -= 1;\n+                }\n \n-                (type_params_barring_defaults, type_params, own_counts.lifetimes)\n+                ((ty_range.0, ty_range.1), lt_accepted)\n             });\n \n-        if types.len() > accepted {\n-            let span = types[accepted].span;\n-            let expected_text = count_type_params(accepted);\n+        if types.len() > ty_accepted {\n+            let span = types[ty_accepted].span;\n+            let expected_text = count_type_params(ty_accepted);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0087,\n                              \"too many type parameters provided: \\\n@@ -4961,8 +4963,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if types.len() < ty_req_len && !infer_types && !supress_mismatch_error {\n-            let expected_text = count_type_params(ty_req_len);\n+        } else if types.len() < ty_required && !infer_types && !supress_mismatch_error {\n+            let expected_text = count_type_params(ty_required);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0089,\n                              \"too few type parameters provided: \\\n@@ -4984,8 +4986,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let primary_msg = \"cannot specify lifetime arguments explicitly \\\n                                if late bound lifetime parameters are present\";\n             let note_msg = \"the late bound lifetime parameter is introduced here\";\n-            if !is_method_call && (lifetimes.len() > lt_req_len ||\n-                                   lifetimes.len() < lt_req_len && !infer_lifetimes) {\n+            if !is_method_call && (lifetimes.len() > lt_accepted ||\n+                                   lifetimes.len() < lt_accepted && !infer_lifetimes) {\n                 let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n                 err.span_note(span_late, note_msg);\n                 err.emit();\n@@ -4999,18 +5001,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if lifetimes.len() > lt_req_len {\n-            let span = lifetimes[lt_req_len].span;\n-            let expected_text = count_lifetime_params(lt_req_len);\n+        if lifetimes.len() > lt_accepted {\n+            let span = lifetimes[lt_accepted].span;\n+            let expected_text = count_lifetime_params(lt_accepted);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0088,\n                              \"too many lifetime parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n                 .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n-        } else if lifetimes.len() < lt_req_len && !infer_lifetimes {\n-            let expected_text = count_lifetime_params(lt_req_len);\n+        } else if lifetimes.len() < lt_accepted && !infer_lifetimes {\n+            let expected_text = count_lifetime_params(lt_accepted);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0090,\n                              \"too few lifetime parameters provided: \\"}, {"sha": "d4f9fb948fe4fc200fd6537ae9e62edaabfd58fd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b575c18992394f9723ddacee49665351874c7b30", "patch": "@@ -903,7 +903,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n \n     // Now create the real type parameters.\n-    let type_start = params.len() as u32;\n+    let type_start = own_start - has_self as u32 + params.len() as u32;\n     params.extend(ast_generics.ty_params().enumerate().map(|(i, p)| {\n         if p.name == keywords::SelfType.name() {\n             span_bug!(p.span, \"`Self` should not be the name of a regular parameter\");"}, {"sha": "17f2c47562f74b7864302f227e4e8c61cc893043", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575c18992394f9723ddacee49665351874c7b30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b575c18992394f9723ddacee49665351874c7b30", "patch": "@@ -1339,11 +1339,15 @@ impl Clean<TyParam> for hir::TyParam {\n impl<'tcx> Clean<TyParam> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n+        let has_default = match self.kind {\n+            ty::GenericParamDefKind::Type(ty) => ty.has_default,\n+            _ => panic!(\"tried to convert a non-type GenericParamDef as a type\")\n+        };\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n             bounds: vec![], // these are filled in from the where-clauses\n-            default: if self.to_type().has_default {\n+            default: if has_default {\n                 Some(cx.tcx.type_of(self.def_id).clean(cx))\n             } else {\n                 None"}]}