{"sha": "748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OGVjYjEyMzVkMWNmYTFhZWFhMGU1NDI0YzQ1NDgzNzA4OWY2Y2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-28T15:19:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-28T15:19:33Z"}, "message": "Auto merge of #35086 - Manishearth:rollup, r=Manishearth\n\nRollup of 7 pull requests\n\n- Successful merges: #34951, #34963, #34969, #35013, #35037, #35040, #35058\n- Failed merges:", "tree": {"sha": "23d7d4b006aeb8c65c530f72874d139fd9b808c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23d7d4b006aeb8c65c530f72874d139fd9b808c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "html_url": "https://github.com/rust-lang/rust/commit/748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "html_url": "https://github.com/rust-lang/rust/commit/cec262e55a92ad15196c4ea6d490fb6ef6bccab4"}, {"sha": "bc283bb8aedafe538a12febf330ed798550b6de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc283bb8aedafe538a12febf330ed798550b6de8", "html_url": "https://github.com/rust-lang/rust/commit/bc283bb8aedafe538a12febf330ed798550b6de8"}], "stats": {"total": 398, "additions": 242, "deletions": 156}, "files": [{"sha": "125f815feda6fa6d902bea13a91be128cb1a603c", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -32,22 +32,27 @@ use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n-pub struct Bivariate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Bivariate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Bivariate<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Bivariate<'a, 'gcx, 'tcx> {\n-        Bivariate { fields: fields }\n+impl<'combine, 'infcx, 'gcx, 'tcx> Bivariate<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Bivariate { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Bivariate<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -86,12 +91,12 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx>\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, BiTo, a_id)?;\n+                self.fields.instantiate(b, BiTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, BiTo, b_id)?;\n+                self.fields.instantiate(a, BiTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "b4818f963b3ba76e4b6ae71f2ad4f381dbbd1616", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -52,21 +52,20 @@ use syntax::ast;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n-pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub a_is_expected: bool,\n+pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    pub infcx: &'infcx InferCtxt<'infcx, 'gcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     pub fn super_combine_tys<R>(&self,\n                                 relation: &mut R,\n                                 a: Ty<'tcx>,\n                                 b: Ty<'tcx>)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>\n+        where R: TypeRelation<'infcx, 'gcx, 'tcx>\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -150,42 +149,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn switch_expected(&self) -> CombineFields<'a, 'gcx, 'tcx> {\n-        CombineFields {\n-            a_is_expected: !self.a_is_expected,\n-            ..(*self).clone()\n-        }\n-    }\n-\n-    pub fn equate(&self) -> Equate<'a, 'gcx, 'tcx> {\n-        Equate::new(self.clone())\n+    pub fn equate<'a>(&'a mut self, a_is_expected: bool) -> Equate<'a, 'infcx, 'gcx, 'tcx> {\n+        Equate::new(self, a_is_expected)\n     }\n \n-    pub fn bivariate(&self) -> Bivariate<'a, 'gcx, 'tcx> {\n-        Bivariate::new(self.clone())\n+    pub fn bivariate<'a>(&'a mut self, a_is_expected: bool) -> Bivariate<'a, 'infcx, 'gcx, 'tcx> {\n+        Bivariate::new(self, a_is_expected)\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'gcx, 'tcx> {\n-        Sub::new(self.clone())\n+    pub fn sub<'a>(&'a mut self, a_is_expected: bool) -> Sub<'a, 'infcx, 'gcx, 'tcx> {\n+        Sub::new(self, a_is_expected)\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'gcx, 'tcx> {\n-        Lub::new(self.clone())\n+    pub fn lub<'a>(&'a mut self, a_is_expected: bool) -> Lub<'a, 'infcx, 'gcx, 'tcx> {\n+        Lub::new(self, a_is_expected)\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'gcx, 'tcx> {\n-        Glb::new(self.clone())\n+    pub fn glb<'a>(&'a mut self, a_is_expected: bool) -> Glb<'a, 'infcx, 'gcx, 'tcx> {\n+        Glb::new(self, a_is_expected)\n     }\n \n-    pub fn instantiate(&self,\n+    pub fn instantiate(&mut self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n-                       b_vid: ty::TyVid)\n+                       b_vid: ty::TyVid,\n+                       a_is_expected: bool)\n                        -> RelateResult<'tcx, ()>\n     {\n         let mut stack = Vec::new();\n@@ -255,10 +248,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n-                BiTo => self.bivariate().relate(&a_ty, &b_ty),\n-                EqTo => self.equate().relate(&a_ty, &b_ty),\n-                SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n-                SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n+                BiTo => self.bivariate(a_is_expected).relate(&a_ty, &b_ty),\n+                EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n+                SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+                SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                    ty::Contravariant, &a_ty, &b_ty),\n             }?;\n         }\n "}, {"sha": "e06f7303acb2927ac99950a43b087c39f9c6c7ac", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -15,29 +15,29 @@ use super::type_variable::{EqTo};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Equate<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Equate<'a, 'gcx, 'tcx> {\n-        Equate { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Equate<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Equate<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Equate { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Equate<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              _: ty::Variance,\n@@ -63,12 +63,12 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, EqTo, a_id)?;\n+                self.fields.instantiate(b, EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, EqTo, b_id)?;\n+                self.fields.instantiate(a, EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n@@ -93,7 +93,7 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_sub(a, b)?;\n-        self.fields.higher_ranked_sub(b, a)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n+        self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n     }\n }"}, {"sha": "5dd85a31a9a2087effd0487c3e1393c0b058107c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -15,29 +15,29 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Glb<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Glb<'a, 'gcx, 'tcx> {\n-        Glb { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Glb<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Glb<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Glb { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -46,10 +46,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.lub().relate(a, b),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.fields.lub(self.a_is_expected).relate(a, b),\n         }\n     }\n \n@@ -71,17 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_glb(a, b)\n+        self.fields.higher_ranked_glb(a, b, self.a_is_expected)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n+    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n+{\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n \n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n-        let mut sub = self.fields.sub();\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&v, &a)?;\n         sub.relate(&v, &b)?;\n         Ok(())"}, {"sha": "743d6135fbb5b555a9c61b151a023626a2325dd1", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -40,7 +40,7 @@ pub struct HrMatchResult<U> {\n }\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_sub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -77,11 +77,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub().relate(&a_prime, &b_prime)?;\n+            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!self.a_is_expected, span, &skol_map, snapshot)?;\n+            self.infcx.leak_check(!a_is_expected, span, &skol_map, snapshot)?;\n \n             // We are finished with the skolemized regions now so pop\n             // them off.\n@@ -106,10 +106,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     /// NB. It should not happen that there are LBR appearing in `U`\n     /// that do not appear in `T`. If that happens, those regions are\n     /// unconstrained, and this routine replaces them with `'static`.\n-    pub fn higher_ranked_match<T, U>(&self,\n+    pub fn higher_ranked_match<T, U>(&mut self,\n                                      span: Span,\n                                      a_pair: &Binder<(T, U)>,\n-                                     b_match: &T)\n+                                     b_match: &T,\n+                                     a_is_expected: bool)\n                                      -> RelateResult<'tcx, HrMatchResult<U>>\n         where T: Relate<'tcx>,\n               U: TypeFoldable<'tcx>\n@@ -129,7 +130,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n \n             // Equate types now that bound regions have been replaced.\n-            try!(self.equate().relate(&a_match, &b_match));\n+            try!(self.equate(a_is_expected).relate(&a_match, &b_match));\n \n             // Map each skolemized region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n@@ -221,7 +222,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_lub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -239,7 +240,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                self.lub().relate(&a_with_fresh, &b_with_fresh)?;\n+                self.lub(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {:?}\", result0);\n@@ -311,7 +312,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+    pub fn higher_ranked_glb<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n                                 -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'tcx>\n     {\n@@ -333,7 +334,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                self.glb().relate(&a_with_fresh, &b_with_fresh)?;\n+                self.glb(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {:?}\", result0);"}, {"sha": "eda78428e61ad41c4690fccc8adf8668e8ad6ed2", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -40,7 +40,7 @@ pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx>\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,"}, {"sha": "ad1b32ffaeb320ac18159277ee07d34df3a016c7", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -15,29 +15,29 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>\n+pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Lub<'a, 'gcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Lub<'a, 'gcx, 'tcx> {\n-        Lub { fields: fields }\n-    }\n-\n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+impl<'combine, 'infcx, 'gcx, 'tcx> Lub<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Lub<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Lub { fields: fields, a_is_expected: a_is_expected }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n@@ -46,10 +46,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.glb().relate(a, b),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.fields.glb(self.a_is_expected).relate(a, b),\n         }\n     }\n \n@@ -71,17 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_lub(a, b)\n+        self.fields.higher_ranked_lub(a, b, self.a_is_expected)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n+    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n+    fn infcx(&self) -> &'infcx InferCtxt<'infcx, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n \n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n-        let mut sub = self.fields.sub();\n+    fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&a, &v)?;\n         sub.relate(&b, &v)?;\n         Ok(())"}, {"sha": "be9adf7085cd4aee2780ccc5fd00719f656ab1a7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -48,18 +48,18 @@ use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::unify_key::ToType;\n \n-pub mod bivariate;\n-pub mod combine;\n-pub mod equate;\n+mod bivariate;\n+mod combine;\n+mod equate;\n pub mod error_reporting;\n-pub mod glb;\n+mod glb;\n mod higher_ranked;\n pub mod lattice;\n-pub mod lub;\n+mod lub;\n pub mod region_inference;\n pub mod resolve;\n mod freshen;\n-pub mod sub;\n+mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n@@ -821,11 +821,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         return variables;\n     }\n \n-    fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+    fn combine_fields(&'a self, trace: TypeTrace<'tcx>)\n                       -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n-            a_is_expected: a_is_expected,\n             trace: trace,\n             cause: None,\n             obligations: PredicateObligations::new(),\n@@ -836,36 +835,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut equate = self.combine_fields(a_is_expected, trace).equate();\n-        let result = equate.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: equate.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.equate(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut sub = self.combine_fields(a_is_expected, trace).sub();\n-        let result = sub.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: sub.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.sub(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut lub = self.combine_fields(a_is_expected, trace).lub();\n-        let result = lub.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: lub.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.lub(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n         where T: Relate<'tcx>\n     {\n-        let mut glb = self.combine_fields(a_is_expected, trace).glb();\n-        let result = glb.relate(a, b);\n-        result.map(|t| InferOk { value: t, obligations: glb.obligations() })\n+        let mut fields = self.combine_fields(trace);\n+        let result = fields.glb(a_is_expected).relate(a, b);\n+        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -1614,8 +1613,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n-        let combine = self.combine_fields(true, trace);\n-        let result = combine.higher_ranked_match(span, &match_pair, &match_b)?;\n+        let mut combine = self.combine_fields(trace);\n+        let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n "}, {"sha": "2f7f5254727db15d1f245be227498b046bc307fc", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -15,28 +15,35 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'gcx, 'tcx>,\n+pub struct Sub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n+    fields: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Sub<'a, 'gcx, 'tcx> {\n-    pub fn new(f: CombineFields<'a, 'gcx, 'tcx>) -> Sub<'a, 'gcx, 'tcx> {\n-        Sub { fields: f }\n+impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n+    pub fn new(f: &'combine mut CombineFields<'infcx, 'gcx, 'tcx>, a_is_expected: bool)\n+        -> Sub<'combine, 'infcx, 'gcx, 'tcx>\n+    {\n+        Sub { fields: f, a_is_expected: a_is_expected }\n     }\n \n-    pub fn obligations(self) -> PredicateObligations<'tcx> {\n-        self.fields.obligations\n+    fn with_expected_switched<R, F: FnOnce(&mut Self) -> R>(&mut self, f: F) -> R {\n+        self.a_is_expected = !self.a_is_expected;\n+        let result = f(self);\n+        self.a_is_expected = !self.a_is_expected;\n+        result\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n+impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n+    for Sub<'combine, 'infcx, 'gcx, 'tcx>\n+{\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.infcx.tcx }\n-    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n         where F: FnOnce(&mut Self) -> R\n@@ -56,10 +63,10 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n                                              -> RelateResult<'tcx, T>\n     {\n         match variance {\n-            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => self.fields.bivariate().relate(a, b),\n-            ty::Contravariant => self.fields.switch_expected().sub().relate(b, a),\n+            ty::Bivariant => self.fields.bivariate(self.a_is_expected).relate(a, b),\n+            ty::Contravariant => self.with_expected_switched(|this| { this.relate(b, a) }),\n         }\n     }\n \n@@ -80,12 +87,11 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n                 self.fields\n-                    .switch_expected()\n-                    .instantiate(b, SupertypeOf, a_id)?;\n+                    .instantiate(b, SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, SubtypeOf, b_id)?;\n+                self.fields.instantiate(a, SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n@@ -116,6 +122,6 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>\n     {\n-        self.fields.higher_ranked_sub(a, b)\n+        self.fields.higher_ranked_sub(a, b, self.a_is_expected)\n     }\n }"}, {"sha": "88cd29a3ccfa721b11e0dc0df3a1a988dbf09158", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -2274,7 +2274,7 @@ impl<'a> Resolver<'a> {\n         let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n                                                                         qself, path, namespace) {\n             if resolution.depth == 0 {\n-                if expected_fn(resolution.base_def) {\n+                if expected_fn(resolution.base_def) || resolution.base_def == Def::Err {\n                     resolution\n                 } else {\n                     resolve_error(\n@@ -2345,7 +2345,7 @@ impl<'a> Resolver<'a> {\n                                 );\n                                 None\n                             }\n-                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) => {\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n                                 None"}, {"sha": "e4e886c85334771b60c5a655ca0340e6d5e38579", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -2409,10 +2409,13 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n-        write!(w, \"{}{}\", *g, WhereClause(g))?\n+        write!(w, \"{}\", g)?\n     }\n     match ty {\n         doctree::Plain => {\n+            if let Some(g) = g {\n+                write!(w, \"{}\", WhereClause(g))?\n+            }\n             write!(w, \" {{\\n{}\", tab)?;\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n@@ -2445,9 +2448,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     _ => unreachable!()\n                 }\n             }\n-            write!(w, \");\")?;\n+            write!(w, \")\")?;\n+            if let Some(g) = g {\n+                write!(w, \"{}\", WhereClause(g))?\n+            }\n+            write!(w, \";\")?;\n         }\n         doctree::Unit => {\n+            // Needed for PhantomData.\n+            if let Some(g) = g {\n+                write!(w, \"{}\", WhereClause(g))?\n+            }\n             write!(w, \";\")?;\n         }\n     }"}, {"sha": "a825cf866a878309eeac575eca99db0a140c079d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -124,7 +124,7 @@ pub fn strip_unconfigured_items(mut krate: ast::Crate, sess: &ParseSess, should_\n         };\n \n         let err_count = sess.span_diagnostic.err_count();\n-        let krate_attrs = strip_unconfigured.process_cfg_attrs(krate.attrs.clone());\n+        let krate_attrs = strip_unconfigured.configure(krate.attrs.clone()).unwrap_or_default();\n         features = get_features(&sess.span_diagnostic, &krate_attrs);\n         if err_count < sess.span_diagnostic.err_count() {\n             krate.attrs = krate_attrs.clone(); // Avoid reconfiguring malformed `cfg_attr`s"}, {"sha": "8173f69191da8af6d46c5304423d4ea40928992c", "filename": "src/test/compile-fail/unresolved-import-recovery.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Fcompile-fail%2Funresolved-import-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Fcompile-fail%2Funresolved-import-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import-recovery.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that unresolved imports do not create additional errors and ICEs\n+\n+mod m {\n+    pub use unresolved; //~ ERROR unresolved import `unresolved`\n+\n+    fn f() {\n+        let unresolved = 0; // OK\n+    }\n+}\n+\n+fn main() {\n+    match 0u8 {\n+        m::unresolved => {} // OK\n+        m::unresolved(..) => {} // OK\n+        m::unresolved{..} => {} // OK\n+    }\n+}"}, {"sha": "c2f6b4c4ac446674347865327547a70cb503bbf7", "filename": "src/test/run-pass-valgrind/coerce-match-calls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match-calls.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "previous_filename": "src/test/run-pass/coerce-match-calls.rs"}, {"sha": "6bf5c4d596f08ce1471d77696b574a22c3351ca0", "filename": "src/test/run-pass-valgrind/coerce-match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcoerce-match.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "previous_filename": "src/test/run-pass/coerce-match.rs"}, {"sha": "e83939e7aec6be6308c627022d2cede26064124a", "filename": "src/test/run-pass/issue-34932.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass%2Fissue-34932.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frun-pass%2Fissue-34932.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34932.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+// rustc-env:RUSTC_BOOTSTRAP_KEY=\n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n+#![cfg(any())] // This test should be configured away\n+#![feature(rustc_attrs)] // Test that this is allowed on stable/beta\n+#![feature(iter_arith_traits)] // Test that this is not unused\n+#![deny(unused_features)]\n+\n+#[test]\n+fn dummy() {\n+    let () = \"this should not reach type-checking\";\n+}"}, {"sha": "b2104a0c80f5deea72a9c776449cc3f14b39633f", "filename": "src/test/rustdoc/issue-34928.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frustdoc%2Fissue-34928.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frustdoc%2Fissue-34928.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-34928.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+pub trait Bar {}\n+\n+// @has foo/struct.Foo.html '//pre' 'pub struct Foo<T>(pub T) where T: Bar;'\n+pub struct Foo<T>(pub T) where T: Bar;"}, {"sha": "d8dc115abf91e1039fa8b30561540c43ed79a753", "filename": "src/test/rustdoc/where.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frustdoc%2Fwhere.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748ecb1235d1cfa1aeaa0e5424c454837089f6cc/src%2Ftest%2Frustdoc%2Fwhere.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhere.rs?ref=748ecb1235d1cfa1aeaa0e5424c454837089f6cc", "patch": "@@ -12,7 +12,7 @@\n \n pub trait MyTrait { fn dummy(&self) { } }\n \n-// @has foo/struct.Alpha.html '//pre' \"pub struct Alpha<A> where A: MyTrait\"\n+// @has foo/struct.Alpha.html '//pre' \"pub struct Alpha<A>(_) where A: MyTrait\"\n pub struct Alpha<A>(A) where A: MyTrait;\n // @has foo/trait.Bravo.html '//pre' \"pub trait Bravo<B> where B: MyTrait\"\n pub trait Bravo<B> where B: MyTrait { fn get(&self, B: B); }"}]}