{"sha": "e33c0b4b5e24eb5035520fd582b9c02672b40481", "node_id": "C_kwDOAAsO6NoAKGUzM2MwYjRiNWUyNGViNTAzNTUyMGZkNTgyYjljMDI2NzJiNDA0ODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T16:09:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-30T16:09:46Z"}, "message": "Auto merge of #14842 - alibektas:internal/ast-make-improve, r=Veykril\n\nImprove ast::make\n\nAdd `ty_alias` and make `impl_trait` , `fn` and `impl_` have more coverage.", "tree": {"sha": "c626d4edeb414d78b9a78a466d095312b462ad3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c626d4edeb414d78b9a78a466d095312b462ad3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33c0b4b5e24eb5035520fd582b9c02672b40481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33c0b4b5e24eb5035520fd582b9c02672b40481", "html_url": "https://github.com/rust-lang/rust/commit/e33c0b4b5e24eb5035520fd582b9c02672b40481", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33c0b4b5e24eb5035520fd582b9c02672b40481/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76d86502f726ff3be705e43e3c3e8c4d4c567a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d86502f726ff3be705e43e3c3e8c4d4c567a4f", "html_url": "https://github.com/rust-lang/rust/commit/76d86502f726ff3be705e43e3c3e8c4d4c567a4f"}, {"sha": "51ec2ced69901f34b3097a6af12b7dd102ed504c", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ec2ced69901f34b3097a6af12b7dd102ed504c", "html_url": "https://github.com/rust-lang/rust/commit/51ec2ced69901f34b3097a6af12b7dd102ed504c"}], "stats": {"total": 160, "additions": 126, "deletions": 34}, "files": [{"sha": "3667fc375b439551f8e936ec242df90d00954f95", "filename": "crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=e33c0b4b5e24eb5035520fd582b9c02672b40481", "patch": "@@ -119,12 +119,25 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                 );\n                 let ret_type = method_source.ret_type();\n                 let is_async = method_source.async_token().is_some();\n+                let is_const = method_source.const_token().is_some();\n+                let is_unsafe = method_source.unsafe_token().is_some();\n                 let tail_expr_finished =\n                     if is_async { make::expr_await(tail_expr) } else { tail_expr };\n                 let body = make::block_expr([], Some(tail_expr_finished));\n-                let f = make::fn_(vis, name, type_params, None, params, body, ret_type, is_async)\n-                    .indent(ast::edit::IndentLevel(1))\n-                    .clone_for_update();\n+                let f = make::fn_(\n+                    vis,\n+                    name,\n+                    type_params,\n+                    None,\n+                    params,\n+                    body,\n+                    ret_type,\n+                    is_async,\n+                    is_const,\n+                    is_unsafe,\n+                )\n+                .indent(ast::edit::IndentLevel(1))\n+                .clone_for_update();\n \n                 let cursor = Cursor::Before(f.syntax());\n \n@@ -156,8 +169,16 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                         let name = &strukt_name.to_string();\n                         let params = strukt.generic_param_list();\n                         let ty_params = params.clone();\n-                        let impl_def = make::impl_(make::ext::ident_path(name), params, ty_params)\n-                            .clone_for_update();\n+                        let where_clause = strukt.where_clause();\n+\n+                        let impl_def = make::impl_(\n+                            ty_params,\n+                            None,\n+                            make::ty_path(make::ext::ident_path(name)),\n+                            where_clause,\n+                            None,\n+                        )\n+                        .clone_for_update();\n                         let assoc_items = impl_def.get_or_create_assoc_item_list();\n                         assoc_items.add_item(f.clone().into());\n "}, {"sha": "850be21c300ca0f73f36f11c01220678dc8fd4d9", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=e33c0b4b5e24eb5035520fd582b9c02672b40481", "patch": "@@ -378,6 +378,8 @@ impl FunctionBuilder {\n             fn_body,\n             self.ret_type,\n             self.is_async,\n+            false, // FIXME : const and unsafe are not handled yet.\n+            false,\n         );\n         let leading_ws;\n         let trailing_ws;"}, {"sha": "a07561e79a28ba644f801f347dd66e388710b5b0", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 98, "deletions": 29, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33c0b4b5e24eb5035520fd582b9c02672b40481/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=e33c0b4b5e24eb5035520fd582b9c02672b40481", "patch": "@@ -158,13 +158,6 @@ fn ty_from_text(text: &str) -> ast::Type {\n     ast_from_text(&format!(\"type _T = {text};\"))\n }\n \n-/// Related goto [link](https://doc.rust-lang.org/reference/items/type-aliases.html)\n-/// Type Alias syntax is\n-/// ```\n-/// TypeAlias :\n-/// type IDENTIFIER GenericParams? ( : TypeParamBounds )? WhereClause? ( = Type WhereClause?)? ;\n-/// ```\n-/// FIXME : ident should be of type ast::Ident\n pub fn ty_alias(\n     ident: &str,\n     generic_param_list: Option<ast::GenericParamList>,\n@@ -173,7 +166,7 @@ pub fn ty_alias(\n     assignment: Option<(ast::Type, Option<ast::WhereClause>)>,\n ) -> ast::TypeAlias {\n     let mut s = String::new();\n-    s.push_str(&format!(\"type {}\", ident));\n+    s.push_str(&format!(\"type {} \", ident));\n \n     if let Some(list) = generic_param_list {\n         s.push_str(&list.to_string());\n@@ -203,33 +196,106 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {}\")\n }\n \n-// FIXME: `ty_params` should be `ast::GenericArgList`\n+fn merge_gen_params(\n+    ps: Option<ast::GenericParamList>,\n+    bs: Option<ast::GenericParamList>,\n+) -> Option<ast::GenericParamList> {\n+    match (ps, bs) {\n+        (None, None) => None,\n+        (None, Some(bs)) => Some(bs),\n+        (Some(ps), None) => Some(ps),\n+        (Some(ps), Some(bs)) => {\n+            for b in bs.generic_params() {\n+                ps.add_generic_param(b);\n+            }\n+            Some(ps)\n+        }\n+    }\n+}\n+\n pub fn impl_(\n-    ty: ast::Path,\n-    params: Option<ast::GenericParamList>,\n-    ty_params: Option<ast::GenericParamList>,\n+    generic_params: Option<ast::GenericParamList>,\n+    generic_args: Option<ast::GenericParamList>,\n+    path_type: ast::Type,\n+    where_clause: Option<ast::WhereClause>,\n+    body: Option<Vec<either::Either<ast::Attr, ast::AssocItem>>>,\n ) -> ast::Impl {\n-    let params = match params {\n-        Some(params) => params.to_string(),\n-        None => String::new(),\n+    let (gen_params, tr_gen_args) = match (generic_params, generic_args) {\n+        (None, None) => (String::new(), String::new()),\n+        (None, Some(args)) => (String::new(), args.to_generic_args().to_string()),\n+        (Some(params), None) => (params.to_string(), params.to_generic_args().to_string()),\n+        (Some(params), Some(args)) => match merge_gen_params(Some(params.clone()), Some(args)) {\n+            Some(merged) => (params.to_string(), merged.to_generic_args().to_string()),\n+            None => (params.to_string(), String::new()),\n+        },\n     };\n-    let ty_params = match ty_params {\n-        Some(params) => params.to_string(),\n+\n+    let where_clause = match where_clause {\n+        Some(pr) => pr.to_string(),\n+        None => \" \".to_string(),\n+    };\n+\n+    let body = match body {\n+        Some(bd) => bd.iter().map(|elem| elem.to_string()).join(\"\"),\n         None => String::new(),\n     };\n-    ast_from_text(&format!(\"impl{params} {ty}{ty_params} {{}}\"))\n+\n+    ast_from_text(&format!(\"impl{gen_params} {path_type}{tr_gen_args}{where_clause}{{{}}}\", body))\n }\n \n+// FIXME : We must make *_gen_args' type ast::GenericArgList but in order to do so we must implement in `edit_in_place.rs`\n+// `add_generic_arg()` just like `add_generic_param()`\n+// is implemented for `ast::GenericParamList`\n pub fn impl_trait(\n-    trait_: ast::Path,\n-    ty: ast::Path,\n-    ty_params: Option<ast::GenericParamList>,\n+    is_unsafe: bool,\n+    trait_gen_params: Option<ast::GenericParamList>,\n+    trait_gen_args: Option<ast::GenericParamList>,\n+    type_gen_params: Option<ast::GenericParamList>,\n+    type_gen_args: Option<ast::GenericParamList>,\n+    is_negative: bool,\n+    path_type: ast::Type,\n+    ty: ast::Type,\n+    trait_where_clause: Option<ast::WhereClause>,\n+    ty_where_clause: Option<ast::WhereClause>,\n+    body: Option<Vec<either::Either<ast::Attr, ast::AssocItem>>>,\n ) -> ast::Impl {\n-    // TODO : If this function is now correct we can also change `impl_` accordingly`\n-    let ty_params_str = ty_params.as_ref().map_or_else(String::new, |params| params.to_string());\n-    let ty_genargs_str =\n-        ty_params.map_or_else(String::new, |params| params.to_generic_args().to_string());\n-    ast_from_text(&format!(\"impl{ty_params_str} {trait_} for {ty}{ty_genargs_str} {{}}\"))\n+    let is_unsafe = if is_unsafe { \"unsafe \" } else { \"\" };\n+    let ty_gen_args = match merge_gen_params(type_gen_params.clone(), type_gen_args) {\n+        Some(pars) => pars.to_generic_args().to_string(),\n+        None => String::new(),\n+    };\n+\n+    let tr_gen_args = match merge_gen_params(trait_gen_params.clone(), trait_gen_args) {\n+        Some(pars) => pars.to_generic_args().to_string(),\n+        None => String::new(),\n+    };\n+\n+    let gen_params = match merge_gen_params(trait_gen_params, type_gen_params) {\n+        Some(pars) => pars.to_string(),\n+        None => String::new(),\n+    };\n+\n+    let is_negative = if is_negative { \"! \" } else { \"\" };\n+\n+    let where_clause = match (ty_where_clause, trait_where_clause) {\n+        (None, None) => \" \".to_string(),\n+        (None, Some(tr)) => format!(\"\\n{}\\n\", tr).to_string(),\n+        (Some(ty), None) => format!(\"\\n{}\\n\", ty).to_string(),\n+        (Some(ty), Some(tr)) => {\n+            let updated = ty.clone_for_update();\n+            tr.predicates().for_each(|p| {\n+                ty.add_predicate(p);\n+            });\n+            format!(\"\\n{}\\n\", updated).to_string()\n+        }\n+    };\n+\n+    let body = match body {\n+        Some(bd) => bd.iter().map(|elem| elem.to_string()).join(\"\"),\n+        None => String::new(),\n+    };\n+\n+    ast_from_text(&format!(\"{is_unsafe}impl{gen_params} {is_negative}{path_type}{tr_gen_args} for {ty}{ty_gen_args}{where_clause}{{{}}}\" , body))\n }\n \n pub fn impl_trait_type(bounds: ast::TypeBoundList) -> ast::ImplTraitType {\n@@ -875,6 +941,8 @@ pub fn fn_(\n     body: ast::BlockExpr,\n     ret_type: Option<ast::RetType>,\n     is_async: bool,\n+    is_const: bool,\n+    is_unsafe: bool,\n ) -> ast::Fn {\n     let type_params = match type_params {\n         Some(type_params) => format!(\"{type_params}\"),\n@@ -894,12 +962,13 @@ pub fn fn_(\n     };\n \n     let async_literal = if is_async { \"async \" } else { \"\" };\n+    let const_literal = if is_const { \"const \" } else { \"\" };\n+    let unsafe_literal = if is_unsafe { \"unsafe \" } else { \"\" };\n \n     ast_from_text(&format!(\n-        \"{visibility}{async_literal}fn {fn_name}{type_params}{params} {ret_type}{where_clause}{body}\",\n+        \"{visibility}{async_literal}{const_literal}{unsafe_literal}fn {fn_name}{type_params}{params} {ret_type}{where_clause}{body}\",\n     ))\n }\n-\n pub fn struct_(\n     visibility: Option<ast::Visibility>,\n     strukt_name: ast::Name,\n@@ -949,7 +1018,7 @@ pub mod tokens {\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| {\n         SourceFile::parse(\n-            \"const C: <()>::Item = (1 != 1, 2 == 2, 3 < 3, 4 <= 4, 5 > 5, 6 >= 6, !true, *p)\\n;\\n\\n\",\n+            \"const C: <()>::Item = (1 != 1, 2 == 2, 3 < 3, 4 <= 4, 5 > 5, 6 >= 6, !true, *p, &p , &mut p)\\n;\\n\\n\",\n         )\n     });\n "}]}