{"sha": "a8437a0accccc4140731b1a73c13ada7305883ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NDM3YTBhY2NjY2M0MTQwNzMxYjFhNzNjMTNhZGE3MzA1ODgzYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-07T14:59:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-07T14:59:24Z"}, "message": "Auto merge of #46509 - nikomatsakis:nll-master-to-rust-master-3, r=arielb1\n\nclosure handling for NLL\n\nThis branch overhauls how we handle closures and universally quantified regions in the NLL code. The goal is to lay the groundwork for \"region erasure\" by the HIR-based type checker, as well as to avoid \"crazy hacks\" when it comes to closures. This means that when we type-check a closure, we cannot make use of *any* of the precise values of free regions in its signature, since those are inferred by the HIR type-checker. Therefore, the new code handles closures by:\n\n- Creating fresh regions for every free region that appears in the closure's type, which now includes both its signature and the types of all upvars.\n    - This means that the closure is type-checked without knowing about the connections.\n- When we encounter some region relationship that we can't locally verify, we propagate it to the closure's creator.\n- During MIR typeck, the closure creators then validates those relationships.\n\nFor a good example and explanation, see e.g. the test `src/test/nll/closure-requirements/propagate-despite-same-free-region.rs`.\n\nUpcoming changes in the next NLL PR (not included in this PR in order to keep it manageable):\n\n- Improvements to the MIR type checker so that it handles a lot of stuff presently overlooked\n- Refactor how we store region values to make it more efficient, better encapsulated\n- Propagate \"type-outlives\" relationships like `T: 'a` in a similar fashion to the one covered in this PR (still in the works, but close)\n- Improvements to error reporting (still in the works)\n\nr? @arielb1 or @pnkfelix", "tree": {"sha": "07db205b8c7d799194822c0faad75c41a6bfb385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07db205b8c7d799194822c0faad75c41a6bfb385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8437a0accccc4140731b1a73c13ada7305883ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8437a0accccc4140731b1a73c13ada7305883ac", "html_url": "https://github.com/rust-lang/rust/commit/a8437a0accccc4140731b1a73c13ada7305883ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8437a0accccc4140731b1a73c13ada7305883ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee25791df5f025378e9ddebef661e25cb75d9172", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee25791df5f025378e9ddebef661e25cb75d9172", "html_url": "https://github.com/rust-lang/rust/commit/ee25791df5f025378e9ddebef661e25cb75d9172"}, {"sha": "1db58d7fa5b5665d12b25ac3695bb3fa9606276e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1db58d7fa5b5665d12b25ac3695bb3fa9606276e", "html_url": "https://github.com/rust-lang/rust/commit/1db58d7fa5b5665d12b25ac3695bb3fa9606276e"}], "stats": {"total": 3643, "additions": 3288, "deletions": 355}, "files": [{"sha": "beee34e11b724b7e0a6bada0ddfcb703bed846f0", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -572,3 +572,15 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n }\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n+\n+impl_stable_hash_for!(struct mir::ClosureRegionRequirements {\n+    num_external_vids,\n+    outlives_requirements\n+});\n+\n+impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement {\n+    free_region,\n+    outlived_free_region,\n+    blame_span\n+});\n+"}, {"sha": "2655e2acbbdfb369f19437a1c9c35bff1e53149a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -84,6 +84,16 @@ for ty::RegionKind {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "f5595d07340bb88024ce595ba64038fe81274b28", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -1062,6 +1062,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n     }\n \n+    /// Number of region variables created so far.\n+    pub fn num_region_vars(&self) -> usize {\n+        self.borrow_region_constraints().var_origins().len()\n+    }\n+\n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n     pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n                                -> ty::Region<'tcx> {\n@@ -1475,38 +1480,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a function or closure.\n-    /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n-    /// work during the type-checking of the enclosing function and\n-    /// return the closure signature in its partially inferred state.\n-    pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        // Do we have an in-progress set of tables we are inferring?\n-        if let Some(tables) = self.in_progress_tables {\n-            // Is this a local item?\n-            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                // Is it a local *closure*?\n-                if self.tcx.is_closure(def_id) {\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                    // Is this local closure contained within the tables we are inferring?\n-                    if tables.borrow().local_id_root == Some(DefId::local(hir_id.owner)) {\n-                        // if so, extract signature from there.\n-                        let closure_ty = tables.borrow().node_id_to_type(hir_id);\n-                        let (closure_def_id, closure_substs) = match closure_ty.sty {\n-                            ty::TyClosure(closure_def_id, closure_substs) =>\n-                                (closure_def_id, closure_substs),\n-                            _ =>\n-                                bug!(\"closure with non-closure type: {:?}\", closure_ty),\n-                        };\n-                        assert_eq!(def_id, closure_def_id);\n-                        let closure_sig_ty = closure_substs.closure_sig_ty(def_id, self.tcx);\n-                        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n-                        return closure_sig_ty.fn_sig(self.tcx);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.tcx.fn_sig(def_id)\n+    /// Obtain the signature of a closure.  For closures, unlike\n+    /// `tcx.fn_sig(def_id)`, this method will work during the\n+    /// type-checking of the enclosing function and return the closure\n+    /// signature in its partially inferred state.\n+    pub fn closure_sig(\n+        &self,\n+        def_id: DefId,\n+        substs: ty::ClosureSubsts<'tcx>\n+    ) -> ty::PolyFnSig<'tcx> {\n+        let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+        closure_sig_ty.fn_sig(self.tcx)\n     }\n \n     /// Normalizes associated types in `value`, potentially returning"}, {"sha": "720d831a245335a4a3e22e023c56296b10315e71", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -1789,6 +1789,75 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+/// After we borrow check a closure, we are left with various\n+/// requirements that we have inferred between the free regions that\n+/// appear in the closure's signature or on its field types.  These\n+/// requirements are then verified and proved by the closure's\n+/// creating function. This struct encodes those requirements.\n+///\n+/// The requirements are listed as being between various\n+/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n+/// vids refer to the free regions that appear in the closure (or\n+/// generator's) type, in order of appearance. (This numbering is\n+/// actually defined by the `UniversalRegions` struct in the NLL\n+/// region checker. See for example\n+/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n+/// regions in the closure's type \"as if\" they were erased, so their\n+/// precise identity is not important, only their position.\n+///\n+/// Example: If type check produces a closure with the closure substs:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'a String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// here, there is one unique free region (`'a`) but it appears\n+/// twice. We would \"renumber\" each occurence to a unique vid, as follows:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'2 String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// Now the code might impose a requirement like `'1: '2`. When an\n+/// instance of the closure is created, the corresponding free regions\n+/// can be extracted from its type and constrained to have the given\n+/// outlives relationship.\n+#[derive(Clone, Debug)]\n+pub struct ClosureRegionRequirements {\n+    /// The number of external regions defined on the closure.  In our\n+    /// example above, it would be 3 -- one for `'static`, then `'1`\n+    /// and `'2`. This is just used for a sanity check later on, to\n+    /// make sure that the number of regions we see at the callsite\n+    /// matches.\n+    pub num_external_vids: usize,\n+\n+    /// Requirements between the various free regions defined in\n+    /// indices.\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement>,\n+}\n+\n+/// Indicates an outlives constraint between two free-regions declared\n+/// on the closure.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ClosureOutlivesRequirement {\n+    // This region ...\n+    pub free_region: ty::RegionVid,\n+\n+    // .. must outlive this one.\n+    pub outlived_free_region: ty::RegionVid,\n+\n+    // If not, report an error here.\n+    pub blame_span: Span,\n+}\n+\n /*\n  * TypeFoldable implementations for MIR types\n  */"}, {"sha": "3342d13dd6e5fa230b691ef6def7d6eebf13ccb9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -1339,26 +1339,27 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.fn_sig(vtable.closure_def_id)\n-        .subst(selcx.tcx(), vtable.substs.substs);\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n+    let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n+    let closure_sig = infcx.shallow_resolve(&closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n-        value: closure_type,\n+        value: closure_sig,\n         obligations\n     } = normalize_with_depth(selcx,\n                              obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n-                             &closure_type);\n+                             &closure_sig);\n \n-    debug!(\"confirm_closure_candidate: obligation={:?},closure_type={:?},obligations={:?}\",\n+    debug!(\"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n            obligation,\n-           closure_type,\n+           closure_sig,\n            obligations);\n \n     confirm_callable_candidate(selcx,\n                                obligation,\n-                               closure_type,\n+                               closure_sig,\n                                util::TupleArgumentsFlag::No)\n         .with_addl_obligations(vtable.nested)\n         .with_addl_obligations(obligations)"}, {"sha": "e70de0e566e41c3daa75ad43c6aa911147fac00e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -3183,8 +3183,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let closure_type = self.infcx.fn_sig(closure_def_id)\n-            .subst(self.tcx(), substs.substs);\n+        let closure_type = self.infcx.closure_sig(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n             self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                          obligation.predicate.0.self_ty(), // (1)"}, {"sha": "177c25ac5dba04808bee172041c22b5d5d3fbb82", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n-use ty::subst::{Kind, Subst};\n+use ty::subst::Kind;\n use traits;\n use syntax::abi::Abi;\n use util::ppaux;\n@@ -311,7 +311,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs(["}, {"sha": "848d2a0a7def71d9a7adef2bca3fcaa72eff0fd2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -190,8 +190,10 @@ define_maps! { <'tcx>\n     [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n     [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n-    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n+\n+    /// Borrow checks the function body. If this is a closure, returns\n+    /// additional requirements that the closure's creator must verify.\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "4f733b8f68a3604a0464c23d693f0575180d06c2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -356,13 +356,17 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_kind()`.\n     pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n     /// Extracts the signature from the closure; only usable outside\n     /// of an inference context, because in that context we know that\n     /// there are no type variables.\n+    ///\n+    /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         match self.closure_sig_ty(def_id, tcx).sty {\n             ty::TyFnPtr(sig) => sig,\n@@ -646,6 +650,17 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n+    /// Wraps `value` in a binder, asserting that `value` does not\n+    /// contain any bound regions that would be bound by the\n+    /// binder. This is commonly used to 'inject' a value T into a\n+    /// different binding level.\n+    pub fn dummy<'tcx>(value: T) -> Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        assert!(!value.has_escaping_regions());\n+        Binder(value)\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n@@ -700,6 +715,32 @@ impl<T> Binder<T> {\n             Some(self.skip_binder().clone())\n         }\n     }\n+\n+    /// Given two things that have the same binder level,\n+    /// and an operation that wraps on their contents, execute the operation\n+    /// and then wrap its result.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return value.\n+    pub fn fuse<U,F,R>(self, u: Binder<U>, f: F) -> Binder<R>\n+        where F: FnOnce(T, U) -> R\n+    {\n+        ty::Binder(f(self.0, u.0))\n+    }\n+\n+    /// Split the contents into two things that share the same binder\n+    /// level as the original, returning two distinct binders.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return values.\n+    pub fn split<U,V,F>(self, f: F) -> (Binder<U>, Binder<V>)\n+        where F: FnOnce(T) -> (U, V)\n+    {\n+        let (u, v) = f(self.0);\n+        (ty::Binder(u), ty::Binder(v))\n+    }\n }\n \n /// Represents the projection of an associated type. In explicit UFCS\n@@ -799,6 +840,9 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n+    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx Slice<Ty<'tcx>>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n+    }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n     }"}, {"sha": "b0f61e9a19177cfe21bcce6ff29b57b2f1708879", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -1069,7 +1069,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n \n         time(time_passes,\n              \"MIR borrow checking\",\n-             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n+             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id); });\n \n         time(time_passes,\n              \"MIR effect checking\","}, {"sha": "97d8a677fe8f15e0fe4454ef1362cdac6d2a3ab3", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::maps::Providers;\n use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Local, Location, Place};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n@@ -51,29 +52,34 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn mir_borrowck<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Option<ClosureRegionRequirements> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if {\n         !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.borrowck_mode.use_mir()\n             && !tcx.sess.opts.debugging_opts.nll\n     } {\n-        return;\n+        return None;\n     }\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_mir: &Mir = &input_mir.borrow();\n-        do_mir_borrowck(&infcx, input_mir, def_id);\n+        do_mir_borrowck(&infcx, input_mir, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n+\n+    opt_closure_req\n }\n \n fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) {\n+) -> Option<ClosureRegionRequirements> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -91,7 +97,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         let mir = &mut mir;\n \n         // Replace all regions with fresh inference variables.\n-        Some(nll::replace_regions_in_mir(infcx, def_id, mir))\n+        Some(nll::replace_regions_in_mir(infcx, def_id, param_env, mir))\n     };\n     let mir = &mir;\n \n@@ -177,19 +183,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let opt_regioncx = if let Some(free_regions) = free_regions {\n-        Some(nll::compute_regions(\n+    let (opt_regioncx, opt_closure_req) = if let Some(free_regions) = free_regions {\n+        let (regioncx, opt_closure_req) = nll::compute_regions(\n             infcx,\n             def_id,\n             free_regions,\n             mir,\n             param_env,\n             &mut flow_inits,\n             &mdpe.move_data,\n-        ))\n+        );\n+        (Some(regioncx), opt_closure_req)\n     } else {\n         assert!(!tcx.sess.opts.debugging_opts.nll);\n-        None\n+        (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n \n@@ -226,6 +233,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     );\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+\n+    opt_closure_req\n }\n \n #[allow(dead_code)]"}, {"sha": "4ff299efb95558f26dc24f86e7eebf0710be94ab", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 125, "deletions": 22, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::Mir;\n+use rustc::mir::{ClosureRegionRequirements, Mir};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n+use std::io;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n@@ -22,6 +23,7 @@ use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n+use util::pretty::{self, ALIGN};\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n@@ -35,20 +37,26 @@ use self::region_infer::RegionInferenceContext;\n mod renumber;\n \n /// Rewrites the regions in the MIR to use NLL variables, also\n-/// scraping out the set of free regions (e.g., region parameters)\n+/// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n /// `compute_regions`.\n pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) -> UniversalRegions<'tcx> {\n-    // Compute named region information.\n-    let universal_regions = universal_regions::universal_regions(infcx, def_id);\n+    debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n-    // Replace all regions with fresh inference variables.\n+    // Compute named region information. This also renumbers the inputs/outputs.\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n+\n+    // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, &universal_regions, mir);\n \n+    let source = MirSource::item(def_id);\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, mir, |_, _| Ok(()));\n+\n     universal_regions\n }\n \n@@ -63,21 +71,19 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) -> RegionInferenceContext<'tcx> {\n+) -> (\n+    RegionInferenceContext<'tcx>,\n+    Option<ClosureRegionRequirements>,\n+) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, &universal_regions, mir);\n-    subtype_constraint_generation::generate(\n-        &mut regioncx,\n-        &universal_regions,\n-        mir,\n-        constraint_sets,\n-    );\n+    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -110,13 +116,24 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     );\n \n     // Solve the region constraints.\n-    regioncx.solve(infcx, &mir);\n+    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n-    // write unit-tests.\n-    dump_mir_results(infcx, liveness, MirSource::item(def_id), &mir, &regioncx);\n+    // write unit-tests, as well as helping with debugging.\n+    dump_mir_results(\n+        infcx,\n+        liveness,\n+        MirSource::item(def_id),\n+        &mir,\n+        &regioncx,\n+        &closure_region_requirements,\n+    );\n \n-    regioncx\n+    // We also have a `#[rustc_nll]` annotation that causes us to dump\n+    // information\n+    dump_annotation(infcx, &mir, def_id, &regioncx, &closure_region_requirements);\n+\n+    (regioncx, closure_region_requirements)\n }\n \n struct LivenessResults {\n@@ -130,6 +147,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n+    closure_region_requirements: &Option<ClosureRegionRequirements>,\n ) {\n     if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n         return;\n@@ -164,9 +182,17 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n     mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n-            PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(out, \"| {:?}: {}\", region, regioncx.region_value_str(region))?;\n-            },\n+            PassWhere::BeforeCFG => {\n+                regioncx.dump_mir(out)?;\n+\n+                if let Some(closure_region_requirements) = closure_region_requirements {\n+                    writeln!(out, \"|\")?;\n+                    writeln!(out, \"| Free Region Constraints\")?;\n+                    for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+                        writeln!(out, \"| {}\", msg)\n+                    })?;\n+                }\n+            }\n \n             // Before each basic block, dump out the values\n             // that are live on entry to the basic block.\n@@ -180,19 +206,96 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                     &regular_liveness_per_location[&location],\n                     &drop_liveness_per_location[&location],\n                 );\n-                writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n+                writeln!(\n+                    out,\n+                    \"{:ALIGN$} | Live variables on entry to {:?}: {}\",\n+                    \"\",\n+                    location,\n+                    s,\n+                    ALIGN = ALIGN\n+                )?;\n             }\n \n             PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n         }\n         Ok(())\n     });\n+\n+    // Also dump the inference graph constraints as a graphviz file.\n+    let _: io::Result<()> = do catch {\n+        let mut file =\n+            pretty::create_dump_file(infcx.tcx, \"regioncx.dot\", None, \"nll\", &0, source)?;\n+        regioncx.dump_graphviz(&mut file)\n+    };\n+}\n+\n+fn dump_annotation<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    mir_def_id: DefId,\n+    regioncx: &RegionInferenceContext,\n+    closure_region_requirements: &Option<ClosureRegionRequirements>,\n+) {\n+    let tcx = infcx.tcx;\n+    let base_def_id = tcx.closure_base_def_id(mir_def_id);\n+    if !tcx.has_attr(base_def_id, \"rustc_regions\") {\n+        return;\n+    }\n+\n+    // When the enclosing function is tagged with `#[rustc_regions]`,\n+    // we dump out various bits of state as warnings. This is useful\n+    // for verifying that the compiler is behaving as expected.  These\n+    // warnings focus on the closure region requirements -- for\n+    // viewing the intraprocedural state, the -Zdump-mir output is\n+    // better.\n+\n+    if let Some(closure_region_requirements) = closure_region_requirements {\n+        let mut err = tcx.sess\n+            .diagnostic()\n+            .span_note_diag(mir.span, \"External requirements\");\n+\n+        regioncx.annotate(&mut err);\n+\n+        err.note(&format!(\n+            \"number of external vids: {}\",\n+            closure_region_requirements.num_external_vids\n+        ));\n+\n+        // Dump the region constraints we are imposing *between* those\n+        // newly created variables.\n+        for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+            err.note(msg);\n+            Ok(())\n+        }).unwrap();\n+\n+        err.emit();\n+    } else {\n+        let mut err = tcx.sess\n+            .diagnostic()\n+            .span_note_diag(mir.span, \"No external requirements\");\n+        regioncx.annotate(&mut err);\n+        err.emit();\n+    }\n+}\n+\n+fn for_each_region_constraint(\n+    closure_region_requirements: &ClosureRegionRequirements,\n+    with_msg: &mut FnMut(&str) -> io::Result<()>,\n+) -> io::Result<()> {\n+    for req in &closure_region_requirements.outlives_requirements {\n+        with_msg(&format!(\n+            \"where {:?}: {:?}\",\n+            req.free_region,\n+            req.outlived_free_region,\n+        ))?;\n+    }\n+    Ok(())\n }\n \n /// Right now, we piggy back on the `ReVar` to store our NLL inference\n /// regions. These are indexed with `RegionVid`. This method will\n /// assert that the region is a `ReVar` and extract its interal index.\n-/// This is reasonable because in our MIR we replace all free regions\n+/// This is reasonable because in our MIR we replace all universal regions\n /// with inference variables.\n pub trait ToRegionVid {\n     fn to_region_vid(&self) -> RegionVid;"}, {"sha": "906efaef887c38c54131781c3c726a55c09e98db", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! As part of the NLL unit tests, you can annotate a function with\n+//! `#[rustc_regions]`, and we will emit information about the region\n+//! inference context and -- in particular -- the external constraints\n+//! that this region imposes on others. The methods in this file\n+//! handle the part about dumping the inference context internal\n+//! state.\n+\n+use rustc::ty;\n+use rustc_errors::DiagnosticBuilder;\n+use super::RegionInferenceContext;\n+\n+impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out our state into the `.mir` files.\n+    pub(crate) fn annotate(&self, err: &mut DiagnosticBuilder<'_>) {\n+        match self.universal_regions.defining_ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with closure substs {:#?}\",\n+                    def_id,\n+                    &substs.substs[..]\n+                ));\n+            }\n+            ty::TyFnDef(def_id, substs) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with substs {:#?}\",\n+                    def_id,\n+                    &substs[..]\n+                ));\n+            }\n+            _ => {\n+                err.note(&format!(\n+                    \"defining type: {:?}\",\n+                    self.universal_regions.defining_ty\n+                ));\n+            }\n+        }\n+    }\n+}"}, {"sha": "5477308bde948e7904862ce9bc22341015c2cdab", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! As part of generating the regions, if you enable `-Zdump-mir=nll`,\n+//! we will generate an annotated copy of the MIR that includes the\n+//! state of region inference. This code handles emitting the region\n+//! context internal state.\n+\n+use std::io::{self, Write};\n+use super::{Constraint, RegionInferenceContext};\n+\n+// Room for \"'_#NNNNr\" before things get misaligned.\n+// Easy enough to fix if this ever doesn't seem like\n+// enough.\n+const REGION_WIDTH: usize = 8;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out our state into the `.mir` files.\n+    pub(crate) fn dump_mir(&self, out: &mut Write) -> io::Result<()> {\n+        writeln!(out, \"| Free Region Mapping\")?;\n+\n+        for region in self.regions() {\n+            if self.definitions[region].is_universal {\n+                let classification = self.universal_regions.region_classification(region).unwrap();\n+                let outlived_by = self.universal_regions.regions_outlived_by(region);\n+                writeln!(\n+                    out,\n+                    \"| {r:rw$} | {c:cw$} | {ob}\",\n+                    r = format!(\"{:?}\", region),\n+                    rw = REGION_WIDTH,\n+                    c = format!(\"{:?}\", classification),\n+                    cw = 8, // \"External\" at most\n+                    ob = format!(\"{:?}\", outlived_by)\n+                )?;\n+            }\n+        }\n+\n+        writeln!(out, \"|\")?;\n+        writeln!(out, \"| Inferred Region Values\")?;\n+        for region in self.regions() {\n+            writeln!(\n+                out,\n+                \"| {r:rw$} | {v}\",\n+                r = format!(\"{:?}\", region),\n+                rw = REGION_WIDTH,\n+                v = self.region_value_str(region),\n+            )?;\n+        }\n+\n+        writeln!(out, \"|\")?;\n+        writeln!(out, \"| Inference Constraints\")?;\n+        self.for_each_constraint(&mut |msg| writeln!(out, \"| {}\", msg))?;\n+\n+        Ok(())\n+    }\n+\n+    /// Debugging aid: Invokes the `with_msg` callback repeatedly with\n+    /// our internal region constraints.  These are dumped into the\n+    /// -Zdump-mir file so that we can figure out why the region\n+    /// inference resulted in the values that it did when debugging.\n+    fn for_each_constraint(\n+        &self,\n+        with_msg: &mut FnMut(&str) -> io::Result<()>,\n+    ) -> io::Result<()> {\n+        for region in self.definitions.indices() {\n+            let value = self.region_value_str_from_matrix(&self.liveness_constraints, region);\n+            if value != \"{}\" {\n+                with_msg(&format!(\"{:?} live at {}\", region, value))?;\n+            }\n+        }\n+\n+        let mut constraints: Vec<_> = self.constraints.iter().collect();\n+        constraints.sort();\n+        for constraint in &constraints {\n+            let Constraint {\n+                sup,\n+                sub,\n+                point,\n+                span,\n+            } = constraint;\n+            with_msg(&format!(\n+                \"{:?}: {:?} @ {:?} due to {:?}\",\n+                sup,\n+                sub,\n+                point,\n+                span\n+            ))?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+"}, {"sha": "7923b159d80dc44ffed9f54a29035f7459d3fb53", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides linkage between RegionInferenceContext and\n+//! libgraphviz traits, specialized to attaching borrowck analysis\n+//! data to rendered labels.\n+\n+use dot::{self, IntoCow};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::borrow::Cow;\n+use std::io::{self, Write};\n+use super::*;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Write out the region constraint graph.\n+    pub(crate) fn dump_graphviz(&self, mut w: &mut Write) -> io::Result<()> {\n+        dot::render(self, &mut w)\n+    }\n+}\n+\n+impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n+    type Node = RegionVid;\n+    type Edge = Constraint;\n+\n+    fn graph_id(&'this self) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"RegionInferenceContext\")).unwrap()\n+    }\n+    fn node_id(&'this self, n: &RegionVid) -> dot::Id<'this> {\n+        dot::Id::new(format!(\"r{}\", n.index())).unwrap()\n+    }\n+    fn node_shape(&'this self, _node: &RegionVid) -> Option<dot::LabelText<'this>> {\n+        Some(dot::LabelText::LabelStr(Cow::Borrowed(\"box\")))\n+    }\n+    fn node_label(&'this self, n: &RegionVid) -> dot::LabelText<'this> {\n+        dot::LabelText::LabelStr(format!(\"{:?}\", n).into_cow())\n+    }\n+    fn edge_label(&'this self, e: &Constraint) -> dot::LabelText<'this> {\n+        dot::LabelText::LabelStr(format!(\"{:?}\", e.point).into_cow())\n+    }\n+}\n+\n+impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n+    type Node = RegionVid;\n+    type Edge = Constraint;\n+\n+    fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n+        let vids: Vec<RegionVid> = self.definitions.indices().collect();\n+        vids.into_cow()\n+    }\n+    fn edges(&'this self) -> dot::Edges<'this, Constraint> {\n+        (&self.constraints[..]).into_cow()\n+    }\n+\n+    // Render `a: b` as `a <- b`, indicating the flow\n+    // of data during inference.\n+\n+    fn source(&'this self, edge: &Constraint) -> RegionVid {\n+        edge.sub\n+    }\n+\n+    fn target(&'this self, edge: &Constraint) -> RegionVid {\n+        edge.sup\n+    }\n+}"}, {"sha": "b2e2ccc5d0b720d889fa3598b02d87627d8e66b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 239, "deletions": 66, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::infer::RegionVariableOrigin;\n use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::VarOrigins;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::mir::{Location, Mir};\n+use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n@@ -24,6 +25,10 @@ use std::collections::BTreeMap;\n use std::fmt;\n use syntax_pos::Span;\n \n+mod annotation;\n+mod dump_mir;\n+mod graphviz;\n+\n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionVid`). The\n@@ -52,12 +57,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the free regions.)\n     point_indices: BTreeMap<Location, usize>,\n \n-    /// Number of universally quantified regions. This is used to\n-    /// determine the meaning of the bits in `inferred_values` and\n-    /// friends.\n-    num_universal_regions: usize,\n-\n-    free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    /// Information about the universally quantified regions in scope\n+    /// on this function and their (known) relations to one another.\n+    universal_regions: UniversalRegions<'tcx>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -67,9 +69,15 @@ struct RegionDefinition<'tcx> {\n     /// late-bound-regions).\n     origin: RegionVariableOrigin,\n \n-    /// If this is a free-region, then this is `Some(X)` where `X` is\n-    /// the name of the region.\n-    name: Option<ty::Region<'tcx>>,\n+    /// True if this is a universally quantified region. This means a\n+    /// lifetime parameter that appears in the function signature (or,\n+    /// in the case of a closure, in the closure environment, which of\n+    /// course is also in the function signature).\n+    is_universal: bool,\n+\n+    /// If this is 'static or an early-bound region, then this is\n+    /// `Some(X)` where `X` is the name of the region.\n+    external_name: Option<ty::Region<'tcx>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -98,11 +106,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// regions defined in `universal_regions`.\n     pub fn new(\n         var_origins: VarOrigins,\n-        universal_regions: &UniversalRegions<'tcx>,\n+        universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n         let num_region_variables = var_origins.len();\n-        let num_universal_regions = universal_regions.indices.len();\n+        let num_universal_regions = universal_regions.len();\n \n         let mut num_points = 0;\n         let mut point_indices = BTreeMap::new();\n@@ -133,11 +141,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             inferred_values: None,\n             constraints: Vec::new(),\n             point_indices,\n-            num_universal_regions,\n-            free_region_map: universal_regions.free_region_map,\n+            universal_regions,\n         };\n \n-        result.init_universal_regions(universal_regions);\n+        result.init_universal_regions();\n \n         result\n     }\n@@ -159,25 +166,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///     R1 = { CFG, R0, R1 } // 'b\n     ///\n     /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n-    /// and (b) any free regions that it outlives, which in this case\n-    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n-    /// hence contains R0 and R1.\n-    fn init_universal_regions(&mut self, universal_regions: &UniversalRegions<'tcx>) {\n-        let UniversalRegions {\n-            indices,\n-            free_region_map: _,\n-        } = universal_regions;\n+    /// and (b) any universally quantified regions that it outlives,\n+    /// which in this case is just itself. R1 (`'b`) in contrast also\n+    /// outlives `'a` and hence contains R0 and R1.\n+    fn init_universal_regions(&mut self) {\n+        // Update the names (if any)\n+        for (external_name, variable) in self.universal_regions.named_universal_regions() {\n+            self.definitions[variable].external_name = Some(external_name);\n+        }\n \n         // For each universally quantified region X:\n-        for (free_region, &variable) in indices {\n+        for variable in self.universal_regions.universal_regions() {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n                 RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n                 _ => false,\n             });\n \n-            // Initialize the name and a few other details.\n-            self.definitions[variable].name = Some(free_region);\n+            self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n             for (_location, point_index) in &self.point_indices {\n@@ -196,6 +202,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.definitions.indices()\n     }\n \n+    /// Given a universal region in scope on the MIR, returns the\n+    /// corresponding index.\n+    ///\n+    /// (Panics if `r` is not a registered universal region.)\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.universal_regions.to_region_vid(r)\n+    }\n+\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n@@ -237,19 +251,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n+        self.region_value_str_from_matrix(inferred_values, r)\n+    }\n+\n+    fn region_value_str_from_matrix(&self,\n+                                    matrix: &BitMatrix,\n+                                    r: RegionVid) -> String {\n         let mut result = String::new();\n         result.push_str(\"{\");\n         let mut sep = \"\";\n \n         for &point in self.point_indices.keys() {\n-            if self.region_contains_point_in_matrix(inferred_values, r, point) {\n+            if self.region_contains_point_in_matrix(matrix, r, point) {\n                 result.push_str(&format!(\"{}{:?}\", sep, point));\n                 sep = \", \";\n             }\n         }\n \n-        for fr in (0..self.num_universal_regions).map(RegionVid::new) {\n-            if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n+        for fr in (0..self.universal_regions.len()).map(RegionVid::new) {\n+            if self.region_contains_region_in_matrix(matrix, r, fr) {\n                 result.push_str(&format!(\"{}{:?}\", sep, fr));\n                 sep = \", \";\n             }\n@@ -289,8 +309,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve(&mut self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n+    pub(super) fn solve(\n+        &mut self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+    ) -> Option<ClosureRegionRequirements> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        let tcx = infcx.tcx;\n \n         // Find the minimal regions that can solve the constraints. This is infallible.\n         self.propagate_constraints(mir);\n@@ -310,57 +336,135 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let free_region_definitions = self.definitions\n+        let universal_definitions = self.definitions\n             .iter_enumerated()\n-            .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n+            .take_while(|(_, fr_definition)| fr_definition.is_universal);\n+\n+        // Go through each of the universal regions `fr` and check that\n+        // they did not grow too large, accumulating any requirements\n+        // for our caller into the `outlives_requirements` vector.\n+        let mut outlives_requirements = vec![];\n+        for (fr, _) in universal_definitions {\n+            self.check_universal_region(infcx, fr, &mut outlives_requirements);\n+        }\n \n-        for (fr, fr_definition) in free_region_definitions {\n-            self.check_free_region(infcx, fr, fr_definition);\n+        // If this is not a closure, then there is no caller to which we can\n+        // \"pass the buck\". So if there are any outlives-requirements that were\n+        // not satisfied, we just have to report a hard error here.\n+        if !tcx.is_closure(mir_def_id) {\n+            for outlives_requirement in outlives_requirements {\n+                self.report_error(\n+                    infcx,\n+                    outlives_requirement.free_region,\n+                    outlives_requirement.outlived_free_region,\n+                    outlives_requirement.blame_span,\n+                );\n+            }\n+            return None;\n         }\n+\n+        let num_external_vids = self.universal_regions.num_global_and_external_regions();\n+\n+        Some(ClosureRegionRequirements {\n+            num_external_vids,\n+            outlives_requirements,\n+        })\n     }\n \n-    fn check_free_region(\n+    /// Check the final value for the free region `fr` to see if it\n+    /// grew too large. In particular, examine what `end(X)` points\n+    /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n+    /// fr`, we want to check that `fr: X`. If not, that's either an\n+    /// error, or something we have to propagate to our creator.\n+    ///\n+    /// Things that are to be propagated are accumulated into the\n+    /// `outlives_requirements` vector.\n+    fn check_universal_region(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         longer_fr: RegionVid,\n-        longer_definition: &RegionDefinition<'tcx>,\n+        outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n-        let longer_name = longer_definition.name.unwrap();\n         let longer_value = inferred_values.iter(longer_fr.index());\n \n-        // Find every region `shorter` such that `longer: shorter`\n-        // (because `longer` includes `end(shorter)`).\n-        for shorter_fr in longer_value.take_while(|&i| i < self.num_universal_regions) {\n-            let shorter_fr = RegionVid::new(shorter_fr);\n+        debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n-            // `fr` includes `end(fr)`, that's not especially\n-            // interesting.\n-            if longer_fr == shorter_fr {\n+        // Find every region `o` such that `fr: o`\n+        // (because `fr` includes `end(o)`).\n+        let shorter_frs = longer_value\n+            .take_while(|&i| i < self.universal_regions.len())\n+            .map(RegionVid::new);\n+        for shorter_fr in shorter_frs {\n+            // If it is known that `fr: o`, carry on.\n+            if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;\n             }\n \n-            let shorter_definition = &self.definitions[shorter_fr];\n-            let shorter_name = shorter_definition.name.unwrap();\n-\n-            // Check that `o <= fr`. If not, report an error.\n-            if !self.free_region_map\n-                .sub_free_regions(shorter_name, longer_name)\n-            {\n-                // FIXME: worst error msg ever\n-                let blame_span = self.blame_span(longer_fr, shorter_fr);\n-                infcx.tcx.sess.span_err(\n-                    blame_span,\n-                    &format!(\n-                        \"free region `{}` does not outlive `{}`\",\n-                        longer_name,\n-                        shorter_name\n-                    ),\n+            debug!(\n+                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n+                longer_fr,\n+                shorter_fr,\n+            );\n+\n+            let blame_span = self.blame_span(longer_fr, shorter_fr);\n+\n+            // Shrink `fr` until we find a non-local region (if we do).\n+            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+            if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                // Grow `shorter_fr` until we find a non-local\n+                // regon. (We always will.)  We'll call that\n+                // `shorter_fr+` -- it's ever so slightly larger than\n+                // `fr`.\n+                let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n                 );\n+\n+                // Push the constraint `fr-: shorter_fr+`\n+                outlives_requirements.push(ClosureOutlivesRequirement {\n+                    free_region: fr_minus,\n+                    outlived_free_region: shorter_fr_plus,\n+                    blame_span: blame_span,\n+                });\n+                return;\n             }\n+\n+            // If we could not shrink `fr` to something smaller that\n+            // the external users care about, then we can't pass the\n+            // buck; just report an error.\n+            self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    fn report_error(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        blame_span: Span,\n+    ) {\n+        // Obviously uncool error reporting.\n+\n+        let fr_string = match self.definitions[fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", fr),\n+        };\n+\n+        let outlived_fr_string = match self.definitions[outlived_fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", outlived_fr),\n+        };\n+\n+        infcx.tcx.sess.span_err(\n+            blame_span,\n+            &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+        );\n+    }\n+\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n@@ -421,8 +525,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         stack.push(start_point);\n         while let Some(p) = stack.pop() {\n-            debug!(\"        copy: p={:?}\", p);\n-\n             if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n@@ -464,7 +566,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // and make sure they are included in the `to_region`.\n                 let universal_region_indices = inferred_values\n                     .iter(from_region.index())\n-                    .take_while(|&i| i < self.num_universal_regions)\n+                    .take_while(|&i| i < self.universal_regions.len())\n                     .collect::<Vec<_>>();\n                 for fr in &universal_region_indices {\n                     changed |= inferred_values.add(to_region.index(), *fr);\n@@ -535,7 +637,11 @@ impl<'tcx> RegionDefinition<'tcx> {\n         // Create a new region definition. Note that, for free\n         // regions, these fields get updated later in\n         // `init_universal_regions`.\n-        Self { origin, name: None }\n+        Self {\n+            origin,\n+            is_universal: false,\n+            external_name: None,\n+        }\n     }\n }\n \n@@ -551,3 +657,70 @@ impl fmt::Debug for Constraint {\n         )\n     }\n }\n+\n+pub trait ClosureRegionRequirementsExt {\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    );\n+}\n+\n+impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n+    /// Given an instance T of the closure type, this method\n+    /// instantiates the \"extra\" requirements that we computed for the\n+    /// closure into the inference context. This has the effect of\n+    /// adding new subregion obligations to existing variables.\n+    ///\n+    /// As described on `ClosureRegionRequirements`, the extra\n+    /// requirements are expressed in terms of regionvids that index\n+    /// into the free regions that appear on the closure type. So, to\n+    /// do this, we first copy those regions out from the type T into\n+    /// a vector. Then we can just index into that vector to extract\n+    /// out the corresponding region from T and apply the\n+    /// requirements.\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) {\n+        let tcx = infcx.tcx;\n+\n+        debug!(\n+            \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+            location,\n+            closure_def_id,\n+            closure_substs\n+        );\n+\n+        // Get Tu.\n+        let user_closure_ty = tcx.mk_closure(closure_def_id, closure_substs);\n+        debug!(\"apply_requirements: user_closure_ty={:?}\", user_closure_ty);\n+\n+        // Extract the values of the free regions in `user_closure_ty`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping =\n+            UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n+\n+        // Create the predicates.\n+        for outlives_requirement in &self.outlives_requirements {\n+            let region = closure_mapping[outlives_requirement.free_region];\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            debug!(\n+                \"apply_requirements: region={:?} outlived_region={:?} outlives_requirements={:?}\",\n+                region,\n+                outlived_region,\n+                outlives_requirement\n+            );\n+            // FIXME, this origin is not entirely suitable.\n+            let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n+            infcx.sub_regions(origin, outlived_region, region);\n+        }\n+    }\n+}"}, {"sha": "1262c238a132cee55492a3b281fdc8b38c22784e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::{self, ClosureSubsts, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n+use rustc::mir::RETURN_PLACE;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -25,34 +26,31 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     universal_regions: &UniversalRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) {\n-    // Create inference variables for each of the free regions\n-    // declared on the function signature.\n-    let free_region_inference_vars = (0..universal_regions.indices.len())\n-        .map(RegionVid::new)\n-        .map(|vid_expected| {\n-            let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n-            assert_eq!(vid_expected, r.to_region_vid());\n-            r\n-        })\n-        .collect();\n-\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: universal_regions={:#?}\", universal_regions);\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n+    // Update the return type and types of the arguments based on the\n+    // `universal_regions` computation.\n+    debug!(\"renumber_mir: output_ty={:?}\", universal_regions.output_ty);\n+    mir.local_decls[RETURN_PLACE].ty = universal_regions.output_ty;\n+    for (&input_ty, local) in universal_regions\n+        .input_tys\n+        .iter()\n+        .zip((1..).map(Local::new))\n+    {\n+        debug!(\"renumber_mir: input_ty={:?} local={:?}\", input_ty, local);\n+        mir.local_decls[local].ty = input_ty;\n+    }\n+\n     let mut visitor = NLLVisitor {\n         infcx,\n-        universal_regions,\n-        free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n     visitor.visit_mir(mir);\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    universal_regions: &'a UniversalRegions<'tcx>,\n-    free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n \n@@ -74,20 +72,17 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    /// Renumbers the regions appearing in `value`, but those regions\n-    /// are expected to be free regions from the function signature.\n-    fn renumber_universal_regions<T>(&mut self, value: &T) -> T\n+    /// Checks that all the regions appearing in `value` have already\n+    /// been renumbered. `FreeRegions` code should have done this.\n+    fn assert_free_regions_are_renumbered<T>(&self, value: &T)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_universal_regions(value={:?})\", value);\n+        debug!(\"assert_free_regions_are_renumbered(value={:?})\", value);\n \n-        self.infcx\n-            .tcx\n-            .fold_regions(value, &mut false, |region, _depth| {\n-                let index = self.universal_regions.indices[&region];\n-                self.free_region_inference_vars[index]\n-            })\n+        self.infcx.tcx.for_each_free_region(value, |region| {\n+            region.to_region_vid(); // will panic if `region` is not renumbered\n+        });\n     }\n \n     fn is_argument_or_return_slot(&self, local: Local) -> bool {\n@@ -110,12 +105,12 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             ty_context\n         );\n \n-        let old_ty = *ty;\n-        *ty = if is_arg {\n-            self.renumber_universal_regions(&old_ty)\n+        if is_arg {\n+            self.assert_free_regions_are_renumbered(ty);\n         } else {\n-            self.renumber_regions(ty_context, &old_ty)\n-        };\n+            *ty = self.renumber_regions(ty_context, ty);\n+        }\n+\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n@@ -138,6 +133,11 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_region: region={:?}\", region);\n     }\n \n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, location: Location) {\n+        let ty_context = TyContext::Location(location);\n+        *constant = self.renumber_regions(ty_context, &*constant);\n+    }\n+\n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n         debug!(\n             \"visit_closure_substs(substs={:?}, location={:?})\","}, {"sha": "c98a94fa8bc106b20a35d25102adec0aba6a435c", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -15,7 +15,6 @@ use rustc::ty;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::universal_regions::UniversalRegions;\n use super::region_infer::RegionInferenceContext;\n \n /// When the MIR type-checker executes, it validates all the types in\n@@ -25,20 +24,17 @@ use super::region_infer::RegionInferenceContext;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n-    universal_regions: &UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n     SubtypeConstraintGenerator {\n         regioncx,\n-        universal_regions,\n         mir,\n     }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    universal_regions: &'cx UniversalRegions<'tcx>,\n     mir: &'cx Mir<'tcx>,\n }\n \n@@ -106,7 +102,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n         if let ty::ReVar(vid) = r {\n             *vid\n         } else {\n-            self.universal_regions.indices[&r]\n+            self.regioncx.to_region_vid(r)\n         }\n     }\n }"}, {"sha": "857a620cead65ea12c90da1d8ffa8185114c7c6a", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 658, "deletions": 46, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -22,69 +22,681 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n+use rustc::hir::HirId;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::ty::{self, RegionVid};\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::outlives::bounds::{self, OutlivesBound};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use std::iter;\n+use syntax::ast;\n+\n+use super::ToRegionVid;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n-    /// Given a universally quantified region defined on this function\n-    /// (either early- or late-bound), this maps it to its internal\n-    /// region index. When the region context is created, the first N\n-    /// variables will be created based on these indices.\n-    pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n-\n-    /// The map from the typeck tables telling us how to relate universal regions.\n-    pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    indices: UniversalRegionIndices<'tcx>,\n+\n+    /// The vid assigned to `'static`\n+    pub fr_static: RegionVid,\n+\n+    /// We create region variables such that they are ordered by their\n+    /// `RegionClassification`. The first block are globals, then\n+    /// externals, then locals. So things from:\n+    /// - `FIRST_GLOBAL_INDEX..first_extern_index` are global;\n+    /// - `first_extern_index..first_local_index` are external; and\n+    /// - first_local_index..num_universals` are local.\n+    first_extern_index: usize,\n+\n+    /// See `first_extern_index`.\n+    first_local_index: usize,\n+\n+    /// The total number of universal region variables instantiated.\n+    num_universals: usize,\n+\n+    /// The \"defining\" type for this function, with all universal\n+    /// regions instantiated.  For a closure or generator, this is the\n+    /// closure type, but for a top-level function it's the `TyFnDef`.\n+    pub defining_ty: Ty<'tcx>,\n+\n+    /// The return type of this function, with all regions replaced\n+    /// by their universal `RegionVid` equivalents.\n+    pub output_ty: Ty<'tcx>,\n+\n+    /// The fully liberated input types of this function, with all\n+    /// regions replaced by their universal `RegionVid` equivalents.\n+    pub input_tys: &'tcx [Ty<'tcx>],\n+\n+    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n+    /// be true. These encode relationships like `T: 'a` that are\n+    /// added via implicit bounds.\n+    ///\n+    /// Each region here is guaranteed to be a key in the `indices`\n+    /// map.  We use the \"original\" regions (i.e., the keys from the\n+    /// map, and not the values) because the code in\n+    /// `process_registered_region_obligations` has some special-cased\n+    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+    /// our special inference variable there, we would mess that up.\n+    pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    relations: UniversalRegionRelations,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionIndices<'tcx> {\n+    /// For those regions that may appear in the parameter environment\n+    /// ('static and early-bound regions), we maintain a map from the\n+    /// `ty::Region` to the internal `RegionVid` we are using. This is\n+    /// used because trait matching and type-checking will feed us\n+    /// region constraints that reference those regions and we need to\n+    /// be able to map them our internal `RegionVid`. This is\n+    /// basically equivalent to a `Substs`, except that it also\n+    /// contains an entry for `ReStatic` -- it might be nice to just\n+    /// use a substs, and then handle `ReStatic` another way.\n+    indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionRelations {\n+    /// Stores the outlives relations that are known to hold from the\n+    /// implied bounds, in-scope where clauses, and that sort of\n+    /// thing.\n+    outlives: TransitiveRelation<RegionVid>,\n+\n+    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n+    /// and we store that here. This is useful when figuring out how\n+    /// to express some local region in terms of external regions our\n+    /// caller will understand.\n+    inverse_outlives: TransitiveRelation<RegionVid>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum RegionClassification {\n+    /// A **global** region is one that can be named from\n+    /// anywhere. There is only one, `'static`.\n+    Global,\n+\n+    /// An **external** region is only relevant for closures. In that\n+    /// case, it refers to regions that are free in the closure type\n+    /// -- basically, something bound in the surrounding context.\n+    ///\n+    /// Consider this example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(a: &'a u32, b: &'b u32, c: &'static u32) {\n+    ///   let closure = for<'x> |x: &'x u32| { .. };\n+    ///                 ^^^^^^^ pretend this were legal syntax\n+    ///                         for declaring a late-bound region in\n+    ///                         a closure signature\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, the lifetimes `'a` and `'b` would be **external** to the\n+    /// closure.\n+    ///\n+    /// If we are not analyzing a closure, there are no external\n+    /// lifetimes.\n+    External,\n+\n+    /// A **local** lifetime is one about which we know the full set\n+    /// of relevant constraints (that is, relationships to other named\n+    /// regions).  For a closure, this includes any region bound in\n+    /// the closure's signature.  For a fn item, this includes all\n+    /// regions other than global ones.\n+    ///\n+    /// Continuing with the example from `External`, if we were\n+    /// analyzing the closure, then `'x` would be local (and `'a` and\n+    /// `'b` are external).  If we are analyzing the function item\n+    /// `foo`, then `'a` and `'b` are local (and `'x` is not in\n+    /// scope).\n+    Local,\n }\n \n-pub fn universal_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    item_def_id: DefId,\n-) -> UniversalRegions<'tcx> {\n-    debug!(\"universal_regions(item_def_id={:?})\", item_def_id);\n+const FIRST_GLOBAL_INDEX: usize = 0;\n+\n+impl<'tcx> UniversalRegions<'tcx> {\n+    /// Creates a new and fully initialized `UniversalRegions` that\n+    /// contains indices for all the free regions found in the given\n+    /// MIR -- that is, all the regions that appear in the function's\n+    /// signature. This will also compute the relationships that are\n+    /// known between those regions.\n+    pub fn new(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        let tcx = infcx.tcx;\n+        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+        let mir_hir_id = tcx.hir.node_to_hir_id(mir_node_id);\n+        UniversalRegionsBuilder {\n+            infcx,\n+            mir_def_id,\n+            mir_node_id,\n+            mir_hir_id,\n+            param_env,\n+            region_bound_pairs: vec![],\n+            relations: UniversalRegionRelations {\n+                outlives: TransitiveRelation::new(),\n+                inverse_outlives: TransitiveRelation::new(),\n+            },\n+        }.build()\n+    }\n+\n+    /// Given a reference to a closure type, extracts all the values\n+    /// from its free regions and returns a vector with them. This is\n+    /// used when the closure's creator checks that the\n+    /// `ClosureRegionRequirements` are met. The requirements from\n+    /// `ClosureRegionRequirements` are expressed in terms of\n+    /// `RegionVid` entries that map into the returned vector `V`: so\n+    /// if the `ClosureRegionRequirements` contains something like\n+    /// `'1: '2`, then the caller would impose the constraint that\n+    /// `V[1]: V[2]`.\n+    pub fn closure_mapping(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        closure_ty: Ty<'tcx>,\n+        expected_num_vars: usize,\n+    ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n+        let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n+        region_mapping.push(infcx.tcx.types.re_static);\n+        infcx.tcx.for_each_free_region(&closure_ty, |fr| {\n+            region_mapping.push(fr);\n+        });\n+\n+        assert_eq!(\n+            region_mapping.len(),\n+            expected_num_vars,\n+            \"index vec had unexpected number of variables\"\n+        );\n \n-    let mut indices = FxHashMap();\n+        region_mapping\n+    }\n \n-    // `'static` is always free.\n-    insert_free_region(&mut indices, infcx.tcx.types.re_static);\n+    /// True if `r` is a member of this set of universal regions.\n+    pub fn is_universal_region(&self, r: RegionVid) -> bool {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).contains(r.index())\n+    }\n \n-    // Extract the early regions.\n-    let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n-    for item_subst in item_substs {\n-        if let Some(region) = item_subst.as_region() {\n-            insert_free_region(&mut indices, region);\n+    /// Classifies `r` as a universal region, returning `None` if this\n+    /// is not a member of this set of universal regions.\n+    pub fn region_classification(&self, r: RegionVid) -> Option<RegionClassification> {\n+        let index = r.index();\n+        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(index) {\n+            Some(RegionClassification::Global)\n+        } else if (self.first_extern_index..self.first_local_index).contains(index) {\n+            Some(RegionClassification::External)\n+        } else if (self.first_local_index..self.num_universals).contains(index) {\n+            Some(RegionClassification::Local)\n+        } else {\n+            None\n         }\n     }\n \n-    // Extract the late-bound regions. Use the liberated fn sigs,\n-    // where the late-bound regions will have been converted into free\n-    // regions, and add them to the map.\n-    let item_id = infcx.tcx.hir.as_local_node_id(item_def_id).unwrap();\n-    let fn_hir_id = infcx.tcx.hir.node_to_hir_id(item_id);\n-    let tables = infcx.tcx.typeck_tables_of(item_def_id);\n-    let fn_sig = tables.liberated_fn_sigs()[fn_hir_id].clone();\n-    infcx\n-        .tcx\n-        .for_each_free_region(&fn_sig.inputs_and_output, |region| {\n-            if let ty::ReFree(_) = *region {\n-                insert_free_region(&mut indices, region);\n+    /// Returns an iterator over all the RegionVids corresponding to\n+    /// universally quantified free regions.\n+    pub fn universal_regions(&self) -> impl Iterator<Item = RegionVid> {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n+    }\n+\n+    /// True if `r` is classied as a global region.\n+    pub fn is_global_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Global)\n+    }\n+\n+    /// True if `r` is classied as an external region.\n+    pub fn is_extern_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::External)\n+    }\n+\n+    /// True if `r` is classied as an local region.\n+    pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Local)\n+    }\n+\n+    /// Returns the number of universal regions created in any category.\n+    pub fn len(&self) -> usize {\n+        self.num_universals\n+    }\n+\n+    /// Finds an \"upper bound\" for `fr` that is not local. In other\n+    /// words, returns the smallest (*) known region `fr1` that (a)\n+    /// outlives `fr` and (b) is not local. This cannot fail, because\n+    /// we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.inverse_outlives, fr)\n+            .unwrap_or(self.fr_static)\n+    }\n+\n+    /// Finds a \"lower bound\" for `fr` that is not local. In other\n+    /// words, returns the largest (*) known region `fr1` that (a) is\n+    /// outlived by `fr` and (b) is not local. This cannot fail,\n+    /// because we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.outlives, fr)\n+    }\n+\n+    /// Returns the number of global plus external universal regions.\n+    /// For closures, these are the regions that appear free in the\n+    /// closure type (versus those bound in the closure\n+    /// signature). They are therefore the regions between which the\n+    /// closure may impose constraints that its creator must verify.\n+    pub fn num_global_and_external_regions(&self) -> usize {\n+        self.first_local_index\n+    }\n+\n+    /// Helper for `non_local_upper_bound` and\n+    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns None if we\n+    /// never do so.\n+    fn non_local_bound(\n+        &self,\n+        relation: &TransitiveRelation<RegionVid>,\n+        fr0: RegionVid,\n+    ) -> Option<RegionVid> {\n+        let mut external_parents = vec![];\n+        let mut queue = vec![&fr0];\n+\n+        // Keep expanding `fr` into its parents until we reach\n+        // non-local regions.\n+        while let Some(fr) = queue.pop() {\n+            if !self.is_local_free_region(*fr) {\n+                external_parents.push(fr);\n+                continue;\n             }\n-        });\n \n-    debug!(\"universal_regions: indices={:#?}\", indices);\n+            queue.extend(relation.parents(fr));\n+        }\n+\n+        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = relation\n+            .mutual_immediate_postdominator(external_parents)\n+            .cloned();\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom.and_then(|post_dom| {\n+            // If the mutual immediate postdom is not local, then\n+            // there is no non-local result we can return.\n+            if !self.is_local_free_region(post_dom) {\n+                Some(post_dom)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// True if fr1 is known to outlive fr2.\n+    ///\n+    /// This will only ever be true for universally quantified regions.\n+    pub fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        self.relations.outlives.contains(&fr1, &fr2)\n+    }\n+\n+    /// Returns a vector of free regions `x` such that `fr1: x` is\n+    /// known to hold.\n+    pub fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n+        self.relations.outlives.reachable_from(&fr1)\n+    }\n+\n+    /// Get an iterator over all the early-bound regions that have names.\n+    pub fn named_universal_regions<'s>(\n+        &'s self,\n+    ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {\n+        self.indices.indices.iter().map(|(&r, &v)| (r, v))\n+    }\n+\n+    /// See `UniversalRegionIndices::to_region_vid`.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.indices.to_region_vid(r)\n+    }\n+}\n+\n+struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    mir_def_id: DefId,\n+    mir_hir_id: HirId,\n+    mir_node_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+    relations: UniversalRegionRelations,\n+}\n+\n+const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n+\n+impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n+    fn build(mut self) -> UniversalRegions<'tcx> {\n+        debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n+\n+        let param_env = self.param_env;\n+        debug!(\"build: param_env={:?}\", param_env);\n+\n+        assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n+\n+        // Create the \"global\" region that is always free in all contexts: 'static.\n+        let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+\n+        // We've now added all the global regions. The next ones we\n+        // add will be external.\n+        let first_extern_index = self.infcx.num_region_vars();\n+\n+        let defining_ty = self.defining_ty();\n+        debug!(\"build: defining_ty={:?}\", defining_ty);\n+\n+        let indices = self.compute_indices(fr_static, defining_ty);\n+        debug!(\"build: indices={:?}\", indices);\n+\n+        let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n+\n+        // \"Liberate\" the late-bound regions. These correspond to\n+        // \"local\" free regions.\n+        let first_local_index = self.infcx.num_region_vars();\n+        let inputs_and_output = self.infcx\n+            .replace_bound_regions_with_nll_infer_vars(FR, &bound_inputs_and_output);\n+        let num_universals = self.infcx.num_region_vars();\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        self.add_outlives_bounds(&indices, bounds::explicit_outlives_bounds(param_env));\n+\n+        // Add the implied bounds from inputs and outputs.\n+        for ty in inputs_and_output {\n+            debug!(\"build: input_or_output={:?}\", ty);\n+            self.add_implied_bounds(&indices, ty);\n+        }\n+\n+        // Finally, outlives is reflexive, and static outlives every\n+        // other free region.\n+        for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n+            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            self.relations.relate_universal_regions(fr, fr);\n+            self.relations.relate_universal_regions(fr_static, fr);\n+        }\n+\n+        let (output_ty, input_tys) = inputs_and_output.split_last().unwrap();\n+\n+        // we should not have created any more variables\n+        assert_eq!(self.infcx.num_region_vars(), num_universals);\n+\n+        debug!(\"build: global regions = {}..{}\",\n+               FIRST_GLOBAL_INDEX,\n+               first_extern_index);\n+        debug!(\"build: extern regions = {}..{}\",\n+               first_extern_index,\n+               first_local_index);\n+        debug!(\"build: local regions  = {}..{}\",\n+               first_local_index,\n+               num_universals);\n+\n+        UniversalRegions {\n+            indices,\n+            fr_static,\n+            first_extern_index,\n+            first_local_index,\n+            num_universals,\n+            defining_ty,\n+            output_ty,\n+            input_tys,\n+            region_bound_pairs: self.region_bound_pairs,\n+            relations: self.relations,\n+        }\n+    }\n+\n+    fn defining_ty(&self) -> ty::Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+\n+        let defining_ty = if self.mir_def_id == closure_base_def_id {\n+            tcx.type_of(closure_base_def_id)\n+        } else {\n+            let tables = tcx.typeck_tables_of(self.mir_def_id);\n+            tables.node_id_to_type(self.mir_hir_id)\n+        };\n+\n+        self.infcx\n+            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n+    }\n+\n+    fn compute_indices(\n+        &self,\n+        fr_static: RegionVid,\n+        defining_ty: Ty<'tcx>,\n+    ) -> UniversalRegionIndices<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n+        let fr_substs = match defining_ty.sty {\n+            ty::TyClosure(_, substs) | ty::TyGenerator(_, substs, ..) => {\n+                // In the case of closures, we rely on the fact that\n+                // the first N elements in the ClosureSubsts are\n+                // inherited from the `closure_base_def_id`.\n+                // Therefore, when we zip together (below) with\n+                // `identity_substs`, we will get only those regions\n+                // that correspond to early-bound regions declared on\n+                // the `closure_base_def_id`.\n+                assert!(substs.substs.len() >= identity_substs.len());\n+                substs.substs\n+            }\n+            ty::TyFnDef(_, substs) => substs,\n+            _ => bug!(),\n+        };\n+\n+        let global_mapping = iter::once((gcx.types.re_static, fr_static));\n+        let subst_mapping = identity_substs\n+            .regions()\n+            .zip(fr_substs.regions().map(|r| r.to_region_vid()));\n+\n+        UniversalRegionIndices {\n+            indices: global_mapping.chain(subst_mapping).collect(),\n+        }\n+    }\n+\n+    fn compute_inputs_and_output(\n+        &self,\n+        indices: &UniversalRegionIndices<'tcx>,\n+        defining_ty: Ty<'tcx>,\n+    ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n+        let tcx = self.infcx.tcx;\n+        match defining_ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n+                let inputs_and_output = closure_sig.inputs_and_output();\n+                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+                ty::Binder::fuse(\n+                    closure_ty,\n+                    inputs_and_output,\n+                    |closure_ty, inputs_and_output| {\n+                        // The \"inputs\" of the closure in the\n+                        // signature appear as a tuple.  The MIR side\n+                        // flattens this tuple.\n+                        let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n+                        assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                        let inputs = match tuplized_inputs[0].sty {\n+                            ty::TyTuple(inputs, _) => inputs,\n+                            _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                        };\n \n-    UniversalRegions { indices, free_region_map: &tables.free_region_map }\n+                        tcx.mk_type_list(\n+                            iter::once(closure_ty)\n+                                .chain(inputs.iter().cloned())\n+                                .chain(iter::once(output)),\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::TyGenerator(def_id, substs, ..) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let output = substs.generator_return_ty(def_id, tcx);\n+                let inputs_and_output = self.infcx.tcx.intern_type_list(&[defining_ty, output]);\n+                ty::Binder::dummy(inputs_and_output)\n+            }\n+\n+            ty::TyFnDef(def_id, _) => {\n+                let sig = tcx.fn_sig(def_id);\n+                let sig = indices.fold_to_region_vids(tcx, &sig);\n+                return sig.inputs_and_output();\n+            }\n+\n+            _ => span_bug!(\n+                tcx.def_span(self.mir_def_id),\n+                \"unexpected defining type: {:?}\",\n+                defining_ty\n+            ),\n+        }\n+    }\n+\n+    /// Update the type of a single local, which should represent\n+    /// either the return type of the MIR or one of its arguments. At\n+    /// the same time, compute and add any implied bounds that come\n+    /// from this local.\n+    ///\n+    /// Assumes that `universal_regions` indices map is fully constructed.\n+    fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n+        debug!(\"add_implied_bounds(ty={:?})\", ty);\n+        let span = self.infcx.tcx.def_span(self.mir_def_id);\n+        let bounds = self.infcx\n+            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        self.add_outlives_bounds(indices, bounds);\n+    }\n+\n+    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n+    /// the outlives relation as well as the region-bound pairs\n+    /// listing.\n+    fn add_outlives_bounds<I>(&mut self, indices: &UniversalRegionIndices<'tcx>, outlives_bounds: I)\n+    where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n+\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n+                    let r1 = indices.to_region_vid(r1);\n+                    let r2 = indices.to_region_vid(r2);\n+                    self.relations.relate_universal_regions(r2, r1);\n+                }\n+\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl UniversalRegionRelations {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\n+            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n+            fr_a,\n+            fr_b\n+        );\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+}\n+\n+pub(crate) trait InferCtxtExt<'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |_region, _depth| self.next_nll_region_var(origin),\n+        )\n+    }\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (value, _map) = self.tcx\n+            .replace_late_bound_regions(value, |_br| self.next_nll_region_var(origin));\n+        value\n+    }\n }\n \n-fn insert_free_region<'tcx>(\n-    universal_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n-    region: ty::Region<'tcx>,\n-) {\n-    let next = RegionVid::new(universal_regions.len());\n-    universal_regions.entry(region).or_insert(next);\n+impl<'tcx> UniversalRegionIndices<'tcx> {\n+    /// Converts `r` into a local inference variable: `r` can either\n+    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// variable) or it can be `'static` or some early-bound\n+    /// region. This is useful when taking the results from\n+    /// type-checking and trait-matching, which may sometimes\n+    /// reference those regions from the `ParamEnv`. It is also used\n+    /// during initialization. Relies on the `indices` map having been\n+    /// fully initialized.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        match r {\n+            ty::ReEarlyBound(..) | ty::ReStatic => *self.indices.get(&r).unwrap(),\n+            ty::ReVar(..) => r.to_region_vid(),\n+            _ => bug!(\"cannot convert `{:?}` to a region vid\", r),\n+        }\n+    }\n+\n+    /// Replace all free regions in `value` with region vids, as\n+    /// returned by `to_region_vid`.\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))),\n+        )\n+    }\n }"}, {"sha": "1a74f32700151c55e4567839372010801456b14b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -11,6 +11,7 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n@@ -110,6 +111,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n+        self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n     }\n \n@@ -159,6 +161,52 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Checks that the constant's `ty` field matches up with what\n+    /// would be expected from its literal.\n+    fn sanitize_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        debug!(\n+            \"sanitize_constant(constant={:?}, location={:?})\",\n+            constant,\n+            location\n+        );\n+\n+        let expected_ty = match constant.literal {\n+            Literal::Value { value } => value.ty,\n+            Literal::Promoted { .. } => {\n+                // FIXME -- promoted MIR return types reference\n+                // various \"free regions\" (e.g., scopes and things)\n+                // that they ought not to do. We have to figure out\n+                // how best to handle that -- probably we want treat\n+                // promoted MIR much like closures, renumbering all\n+                // their free regions and propagating constraints\n+                // upwards. We have the same acyclic guarantees, so\n+                // that should be possible. But for now, ignore them.\n+                //\n+                // let promoted_mir = &self.mir.promoted[index];\n+                // promoted_mir.return_ty()\n+                return;\n+            }\n+        };\n+\n+        debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n+\n+        if let Err(terr) = self.cx\n+            .eq_types(expected_ty, constant.ty, location.at_self())\n+        {\n+            span_mirbug!(\n+                self,\n+                constant,\n+                \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n+                constant,\n+                expected_ty,\n+                constant.ty,\n+                terr,\n+            );\n+        }\n+    }\n+\n+    /// Checks that the types internal to the `place` match up with\n+    /// what would be expected.\n     fn sanitize_place(\n         &mut self,\n         place: &Place<'tcx>,\n@@ -1088,14 +1136,45 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         operands: &[Operand<'tcx>],\n         location: Location,\n     ) {\n+        let tcx = self.tcx();\n+\n         match aggregate_kind {\n             // tuple rvalue field type is always the type of the op. Nothing to check here.\n             AggregateKind::Tuple => return,\n+\n+            // For closures, we have some **extra requirements** we\n+            // have to check. In particular, in their upvars and\n+            // signatures, closures often reference various regions\n+            // from the surrounding function -- we call those the\n+            // closure's free regions. When we borrow-check (and hence\n+            // region-check) closures, we may find that the closure\n+            // requires certain relationships between those free\n+            // regions. However, because those free regions refer to\n+            // portions of the CFG of their caller, the closure is not\n+            // in a position to verify those relationships. In that\n+            // case, the requirements get \"propagated\" to us, and so\n+            // we have to solve them here where we instantiate the\n+            // closure.\n+            //\n+            // Despite the opacity of the previous parapgrah, this is\n+            // actually relatively easy to understand in terms of the\n+            // desugaring. A closure gets desugared to a struct, and\n+            // these extra requirements are basically like where\n+            // clauses on the struct.\n+            AggregateKind::Closure(def_id, substs) => {\n+                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                    closure_region_requirements.apply_requirements(\n+                        self.infcx,\n+                        location,\n+                        *def_id,\n+                        *substs,\n+                    );\n+                }\n+            }\n+\n             _ => {}\n         }\n \n-        let tcx = self.tcx();\n-\n         for (i, operand) in operands.iter().enumerate() {\n             let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n                 Ok(field_ty) => field_ty,"}, {"sha": "37f59773cd6f03b2295c4395b5b985b32349624f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 114, "deletions": 26, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -11,7 +11,8 @@\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::mir::*;\n-use rustc::ty::TyCtxt;\n+use rustc::mir::visit::Visitor;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -56,9 +57,19 @@ pub enum PassWhere {\n /// where `<filter>` takes the following forms:\n ///\n /// - `all` -- dump MIR for all fns, all passes, all everything\n-/// - `substring1&substring2,...` -- `&`-separated list of substrings\n-///   that can appear in the pass-name or the `item_path_str` for the given\n-///   node-id. If any one of the substrings match, the data is dumped out.\n+/// - a filter defined by a set of substrings combined with `&` and `|`\n+///   (`&` has higher precedence). At least one of the `|`-separated groups\n+///   must match; an `|`-separated group matches if all of its `&`-separated\n+///   substrings are matched.\n+///\n+/// Example:\n+///\n+/// - `nll` == match if `nll` appears in the name\n+/// - `foo & nll` == match if `foo` and `nll` both appear in the name\n+/// - `foo & nll | typeck` == match if `foo` and `nll` both appear in the name\n+///   or `typeck` appears in the name.\n+/// - `foo & nll | bar & typeck` == match if `foo` and `nll` both appear in the name\n+///   or `typeck` and `bar` both appear in the name.\n pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pass_num: Option<&Display>,\n@@ -103,8 +114,10 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    filters.split(\"&\").any(|filter| {\n-        filter == \"all\" || pass_name.contains(filter) || node_path.contains(filter)\n+    filters.split(\"|\").any(|or_filter| {\n+        or_filter.split(\"&\").all(|and_filter| {\n+            and_filter == \"all\" || pass_name.contains(and_filter) || node_path.contains(and_filter)\n+        })\n     })\n }\n \n@@ -125,14 +138,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     let _: io::Result<()> = do catch {\n-        let mut file = create_dump_file(\n-            tcx,\n-            \"mir\",\n-            pass_num,\n-            pass_name,\n-            disambiguator,\n-            source,\n-        )?;\n+        let mut file = create_dump_file(tcx, \"mir\", pass_num, pass_name, disambiguator, source)?;\n         writeln!(file, \"// MIR for `{}`\", node_path)?;\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n@@ -148,15 +154,9 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     };\n \n     if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n-    let _: io::Result<()> = do catch {\n-            let mut file = create_dump_file(\n-                tcx,\n-                \"dot\",\n-                pass_num,\n-                pass_name,\n-                disambiguator,\n-                source,\n-            )?;\n+        let _: io::Result<()> = do catch {\n+            let mut file =\n+                create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n             write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n             Ok(())\n         };\n@@ -297,10 +297,10 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<F>(\n-    tcx: TyCtxt,\n+pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     block: BasicBlock,\n-    mir: &Mir,\n+    mir: &Mir<'tcx>,\n     extra_data: &mut F,\n     w: &mut Write,\n ) -> io::Result<()>\n@@ -330,6 +330,11 @@ where\n             comment(tcx, statement.source_info),\n             A = ALIGN,\n         )?;\n+\n+        write_extra(tcx, w, |visitor| {\n+            visitor.visit_statement(current_location.block, statement, current_location);\n+        })?;\n+\n         extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n         current_location.statement_index += 1;\n@@ -346,11 +351,94 @@ where\n         comment(tcx, data.terminator().source_info),\n         A = ALIGN,\n     )?;\n+\n+    write_extra(tcx, w, |visitor| {\n+        visitor.visit_terminator(current_location.block, data.terminator(), current_location);\n+    })?;\n+\n     extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n+/// After we print the main statement, we sometimes dump extra\n+/// information. There's often a lot of little things \"nuzzled up\" in\n+/// a statement.\n+fn write_extra<'cx, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    write: &mut Write,\n+    mut visit_op: F,\n+) -> io::Result<()>\n+where\n+    F: FnMut(&mut ExtraComments<'cx, 'gcx, 'tcx>),\n+{\n+    let mut extra_comments = ExtraComments {\n+        _tcx: tcx,\n+        comments: vec![],\n+    };\n+    visit_op(&mut extra_comments);\n+    for comment in extra_comments.comments {\n+        writeln!(write, \"{:A$} // {}\", \"\", comment, A = ALIGN)?;\n+    }\n+    Ok(())\n+}\n+\n+struct ExtraComments<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    _tcx: TyCtxt<'cx, 'gcx, 'tcx>, // don't need it now, but bet we will soon\n+    comments: Vec<String>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ExtraComments<'cx, 'gcx, 'tcx> {\n+    fn push(&mut self, lines: &str) {\n+        for line in lines.split(\"\\n\") {\n+            self.comments.push(line.to_string());\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        self.super_constant(constant, location);\n+        let Constant { span, ty, literal } = constant;\n+        self.push(&format!(\"mir::Constant\"));\n+        self.push(&format!(\"\u2514 span: {:?}\", span));\n+        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n+        self.push(&format!(\"\u2514 literal: {:?}\", literal));\n+    }\n+\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n+        self.super_const(constant);\n+        let ty::Const { ty, val } = constant;\n+        self.push(&format!(\"ty::Const\"));\n+        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n+        self.push(&format!(\"\u2514 val: {:?}\", val));\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+        match rvalue {\n+            Rvalue::Aggregate(kind, _) => match **kind {\n+                AggregateKind::Closure(def_id, substs) => {\n+                    self.push(&format!(\"closure\"));\n+                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n+                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n+                }\n+\n+                AggregateKind::Generator(def_id, substs, interior) => {\n+                    self.push(&format!(\"generator\"));\n+                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n+                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n+                    self.push(&format!(\"\u2514 interior: {:?}\", interior));\n+                }\n+\n+                _ => {}\n+            },\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\","}, {"sha": "762cf7a0055d5f7010ace28986f386ea3bd02a4f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -29,7 +29,7 @@ use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n@@ -393,7 +393,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n         ty::TyClosure(def_id, substs) => {\n             let tcx = ccx.tcx();\n-            let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n+            let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n             sig.map_bound(|sig| tcx.mk_fn_sig("}, {"sha": "0799a388a8becf207a37b58af9932ddc7a3dacdf", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::tcx::PlaceTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc::ty::subst::{Kind, Substs};\n use rustc_apfloat::{ieee, Float, Status};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use base;\n@@ -658,8 +658,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     .find(|it| it.kind == ty::AssociatedKind::Method)\n                                     .unwrap().def_id;\n                                 // Now create its substs [Closure, Tuple]\n-                                let input = tcx.fn_sig(def_id)\n-                                    .subst(tcx, substs.substs).input(0);\n+                                let input = substs.closure_sig(def_id, tcx).input(0);\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));"}, {"sha": "d586d1ac31506aa63676a5350435b1e9085424e2", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::Kind;\n use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::ty::Instance;\n@@ -34,7 +34,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n \n-    let sig = tcx.fn_sig(closure_did).subst(tcx, substs.substs);\n+    let sig = substs.closure_sig(closure_did, tcx);\n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     assert_eq!(sig.inputs().len(), 1);\n     let substs = tcx.mk_substs(["}, {"sha": "df1694a601056b8e0c66414ef2753b9959599710", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -16,7 +16,6 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, LvaluePreference, Ty};\n-use rustc::ty::subst::Subst;\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n@@ -109,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n-                    let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n+                    let closure_ty = self.closure_sig(def_id, substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n                                                                    &closure_ty)"}, {"sha": "dc5d3141d4ca29323a34412faf411d1bf6c3c758", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -74,7 +74,6 @@ use rustc::ty::{self, LvaluePreference, TypeAndMut,\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::Subst;\n use errors::DiagnosticBuilder;\n use syntax::abi;\n use syntax::feature_gate;\n@@ -670,7 +669,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n-                let sig = self.fn_sig(def_id_a).subst(self.tcx, substs_a.substs);\n+                let sig = self.closure_sig(def_id_a, substs_a);\n                 let converted_sig = sig.map_bound(|s| {\n                     let params_iter = match s.inputs()[0].sty {\n                         ty::TyTuple(params, _) => {"}, {"sha": "85b926a707db3da1c8694bd4f6a3fef707a8da3e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -1268,15 +1268,23 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n-            let tables = tcx.typeck_tables_of(def_id);\n-            match tables.node_id_to_type(hir_id).sty {\n-                ty::TyClosure(closure_def_id, closure_substs) => {\n-                    assert_eq!(def_id, closure_def_id);\n-                    return closure_substs.closure_sig(closure_def_id, tcx);\n-                }\n-                ref t => bug!(\"closure with non-closure type: {:?}\", t),\n-            }\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+            // Closure signatures are not like other function\n+            // signatures and cannot be accessed through `fn_sig`. For\n+            // example, a closure signature excludes the `self`\n+            // argument. In any case they are embedded within the\n+            // closure type as part of the `ClosureSubsts`.\n+            //\n+            // To get\n+            // the signature of a closure, you should use the\n+            // `closure_sig` method on the `ClosureSubsts`:\n+            //\n+            //    closure_substs.closure_sig(def_id, tcx)\n+            //\n+            // or, inside of an inference context, you can use\n+            //\n+            //    infcx.closure_sig(def_id, closure_substs)\n+            bug!(\"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\");\n         }\n \n         x => {"}, {"sha": "22cef25320ed30317b824dbc592bc9c07c8ef8c2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -717,6 +717,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                       is just used for rustc unit tests \\\n                                       and will never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_regions\", Normal, Gated(Stability::Unstable,\n+                                    \"rustc_attrs\",\n+                                    \"the `#[rustc_regions]` attribute \\\n+                                     is just used for rustc unit tests \\\n+                                     and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n     (\"rustc_error\", Whitelisted, Gated(Stability::Unstable,\n                                        \"rustc_attrs\",\n                                        \"the `#[rustc_error]` attribute \\"}, {"sha": "7276036071103c5cb2a49f9915820543ccca6ae7", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -123,7 +123,12 @@ impl<'a> From<&'a str> for Symbol {\n \n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}({})\", self, self.0)\n+        let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));\n+        if is_gensymed {\n+            write!(f, \"{}({})\", self, self.0)\n+        } else {\n+            write!(f, \"{}\", self)\n+        }\n     }\n }\n \n@@ -201,6 +206,10 @@ impl Interner {\n         Symbol(!0 - self.gensyms.len() as u32 + 1)\n     }\n \n+    fn is_gensymed(&mut self, symbol: Symbol) -> bool {\n+        symbol.0 as usize >= self.strings.len()\n+    }\n+\n     pub fn get(&self, symbol: Symbol) -> &str {\n         match self.strings.get(symbol.0 as usize) {\n             Some(ref string) => string,"}, {"sha": "9de8ca196f8ce9a021cf37d99607ec25da4f721a", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -8,17 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ll nll\n+//[nll] compile-flags: -Znll -Zborrowck=mir\n+\n fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'static { t }\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n-    t //~ ERROR E0312\n+    t //[ll]~ ERROR E0312\n+        //[nll]~^ WARNING not reporting region error due to -Znll\n+        //[nll]~| ERROR free region `'a` does not outlive free region `'static`\n }\n \n fn error(u: &(), v: &()) {\n-    static_id(&u); //~ ERROR cannot infer an appropriate lifetime\n-    static_id_indirect(&v); //~ ERROR cannot infer an appropriate lifetime\n+    static_id(&u); //[ll]~ ERROR cannot infer an appropriate lifetime\n+    //[nll]~^ WARNING not reporting region error due to -Znll\n+    static_id_indirect(&v); //[ll]~ ERROR cannot infer an appropriate lifetime\n+    //[nll]~^ WARNING not reporting region error due to -Znll\n+\n+    // FIXME(#45827) -- MIR type checker shortcomings mean we don't\n+    // see these errors (yet) in nll mode.\n }\n \n fn main() {}"}, {"sha": "09288cf69ff586064efc7116894ccf6d5257dc89", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -28,18 +28,18 @@ fn main() {\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb0: []\n //    bb0: {\n-//            | Live variables at bb0[0]: []\n+//            | Live variables on entry to bb0[0]: []\n //        StorageLive(_1);\n-//            | Live variables at bb0[1]: []\n+//            | Live variables on entry to bb0[1]: []\n //        _1 = const <std::boxed::Box<T>>::new(const 22usize) -> [return: bb2, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb2: [_1 (drop)]\n //    bb2: {\n-//            | Live variables at bb2[0]: [_1 (drop)]\n+//            | Live variables on entry to bb2[0]: [_1 (drop)]\n //        StorageLive(_2);\n-//            | Live variables at bb2[1]: [_1 (drop)]\n+//            | Live variables on entry to bb2[1]: [_1 (drop)]\n //        _2 = const can_panic() -> [return: bb3, unwind: bb4];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "b060222a95f1701ea42b1c9a5c7ec44b91db1556", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -27,15 +27,15 @@ fn main() {\n // START rustc.main.nll.0.mir\n //    | Live variables on entry to bb2: []\n //    bb2: {\n-//            | Live variables at bb2[0]: []\n+//            | Live variables on entry to bb2[0]: []\n //        _1 = const 55usize;\n-//            | Live variables at bb2[1]: [_1]\n+//            | Live variables on entry to bb2[1]: [_1]\n //        StorageLive(_3);\n-//            | Live variables at bb2[2]: [_1]\n+//            | Live variables on entry to bb2[2]: [_1]\n //        StorageLive(_4);\n-//            | Live variables at bb2[3]: [_1]\n+//            | Live variables on entry to bb2[3]: [_1]\n //        _4 = _1;\n-//            | Live variables at bb2[4]: [_4]\n+//            | Live variables on entry to bb2[4]: [_4]\n //        _3 = const use_x(move _4) -> [return: bb3, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "671f5e5292aa439029b6e98221ed7e51bb9da502", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -31,18 +31,18 @@ fn main() {\n // START rustc.main.nll.0.mir\n //     | Live variables on entry to bb3: [_1]\n //     bb3: {\n-//             | Live variables at bb3[0]: [_1]\n+//             | Live variables on entry to bb3[0]: [_1]\n //         StorageLive(_4);\n-//             | Live variables at bb3[1]: [_1]\n+//             | Live variables on entry to bb3[1]: [_1]\n //         _4 = _1;\n-//             | Live variables at bb3[2]: [_4]\n+//             | Live variables on entry to bb3[2]: [_4]\n //         _3 = const make_live(move _4) -> [return: bb5, unwind: bb1];\n //     }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //     | Live variables on entry to bb4: []\n //     bb4: {\n-//             | Live variables at bb4[0]: []\n+//             | Live variables on entry to bb4[0]: []\n //         _5 = const make_dead() -> [return: bb6, unwind: bb1];\n //     }\n // END rustc.main.nll.0.mir"}, {"sha": "0c42585a528e0c3d4c4f927109af14aeb9c2e5f4", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -26,9 +26,18 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n-// | '_#0r: {bb0[0], bb0[1], '_#0r}\n-// | '_#1r: {bb0[0], bb0[1], '_#1r}\n-// | '_#2r: {bb0[0], bb0[1], '_#2r}\n-// | '_#3r: {bb0[0], bb0[1], '_#3r}\n+// | Free Region Mapping\n+// | '_#0r    | Global   | ['_#2r, '_#1r, '_#0r, '_#3r]\n+// | '_#1r    | External | ['_#1r]\n+// | '_#2r    | External | ['_#2r, '_#1r]\n+// | '_#3r    | Local    | ['_#3r]\n+// |\n+// | Inferred Region Values\n+// | '_#0r    | {bb0[0], bb0[1], '_#0r}\n+// | '_#1r    | {bb0[0], bb0[1], '_#1r}\n+// | '_#2r    | {bb0[0], bb0[1], '_#2r}\n+// | '_#3r    | {bb0[0], bb0[1], '_#3r}\n+// |\n+// ...\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}, {"sha": "d203472f20c737d5bb29a556a32abf17c7b3b41b", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -28,11 +28,10 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#6r: {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#6r    | {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// ...\n+// | '_#8r    | {bb0[11], bb0[12], bb0[13], bb0[14]}\n // ...\n-// | '_#8r: {bb0[11], bb0[12], bb0[13], bb0[14]}\n-// END rustc.main.nll.0.mir\n-// START rustc.main.nll.0.mir\n // let _2: &'_#6r mut i32;\n // ...\n // let _4: &'_#8r mut i32;"}, {"sha": "c04cedbc04b4d95e1de5163bb4e1138c0489ee8e", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -31,26 +31,26 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n-// | '_#2r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[1], bb3[0], bb3[1]}\n // ...\n //             let _2: &'_#2r usize;\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb2: {\n-//            | Live variables at bb2[0]: [_1, _3]\n+//            | Live variables on entry to bb2[0]: [_1, _3]\n //        _2 = &'_#1r _1[_3];\n-//            | Live variables at bb2[1]: [_2]\n+//            | Live variables on entry to bb2[1]: [_2]\n //        switchInt(const true) -> [0u8: bb4, otherwise: bb3];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb3: {\n-//            | Live variables at bb3[0]: [_2]\n+//            | Live variables on entry to bb3[0]: [_2]\n //        StorageLive(_7);\n-//            | Live variables at bb3[1]: [_2]\n+//            | Live variables on entry to bb3[1]: [_2]\n //        _7 = (*_2);\n-//            | Live variables at bb3[2]: [_7]\n+//            | Live variables on entry to bb3[2]: [_7]\n //        _6 = const use_x(move _7) -> [return: bb5, unwind: bb1];\n //    }\n // END rustc.main.nll.0.mir"}, {"sha": "e2ad49a443625f57c6b88e7c77622b1c7040bdf6", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -44,5 +44,5 @@ unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r: {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1]}\n+// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir"}, {"sha": "e0272a51d03d996459411d05db1d4ece24598c81", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -46,5 +46,5 @@ impl<T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r: {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1], bb3[2], bb4[0], bb5[0], bb5[1], bb5[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n+// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1], bb3[2], bb4[0], bb5[0], bb5[1], bb5[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n // END rustc.main.nll.0.mir"}, {"sha": "8aa0eb1a3a90eb0f15e403a8f9233f26e01728c5", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -36,10 +36,10 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n // ...\n-// | '_#3r: {bb8[1], bb8[2], bb8[3], bb8[4]}\n-// | '_#4r: {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n+// | '_#3r    | {bb8[1], bb8[2], bb8[3], bb8[4]}\n+// | '_#4r    | {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n // ...\n // let mut _2: &'_#4r usize;\n // ..."}, {"sha": "2bc165bd3c4a3a6d6d47d602538fd2b507602c21", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -32,9 +32,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#2r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#3r: {bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#1r    | {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#3r    | {bb2[5], bb2[6], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _2: &'_#2r usize;"}, {"sha": "00a0c94d2218ab9dfcf34079f04432b574f370d2", "filename": "src/test/ui/nll/capture-ref-in-struct.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+\n+// Test that a structure which tries to store a pointer to `y` into\n+// `p` (indirectly) fails to compile.\n+\n+#![feature(rustc_attrs)]\n+\n+struct SomeStruct<'a, 'b: 'a> {\n+    p: &'a mut &'b i32,\n+    y: &'b i32,\n+}\n+\n+fn test() {\n+    let x = 44;\n+    let mut p = &x;\n+\n+    {\n+        let y = 22;\n+\n+        let closure = SomeStruct {\n+            p: &mut p,\n+            y: &y,\n+        };\n+\n+        closure.invoke();\n+    }\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    deref(p);\n+}\n+\n+impl<'a, 'b> SomeStruct<'a, 'b> {\n+    fn invoke(self) {\n+        *self.p = self.y;\n+    }\n+}\n+\n+fn deref(_: &i32) { }\n+\n+fn main() { }"}, {"sha": "f10e52e05f19ddb3a042cb83d32b466236cabcfb", "filename": "src/test/ui/nll/capture-ref-in-struct.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/capture-ref-in-struct.rs:36:6\n+   |\n+28 |         let y = 22;\n+   |             - temporary value created here\n+...\n+36 |     }\n+   |      ^ temporary value dropped here while still borrowed\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "1e34aaf1ea03003e92c37f0138ed0c030b7f1be9", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test closure that:\n+//\n+// - takes an argument `y` with lifetime `'a` (in the code, it's anonymous)\n+// - stores `y` into another, longer-lived spot with lifetime `'b`\n+//\n+// Because `'a` and `'b` are two different, unrelated higher-ranked\n+// regions with no relationship to one another, this is an error. This\n+// error is reported by the closure itself and is not propagated to\n+// its creator: this is because `'a` and `'b` are higher-ranked\n+// (late-bound) regions and the closure is not allowed to propagate\n+// additional where clauses between higher-ranked regions, only those\n+// that appear free in its type (hence, we see it before the closure's\n+// \"external requirements\" report).\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn test() {\n+    let x = 44;\n+    let mut p = &x;\n+\n+    {\n+        let y = 22;\n+        let mut closure = expect_sig(|p, y| *p = y);\n+        //~^ ERROR free region `'_#4r` does not outlive free region `'_#3r`\n+        //~| WARNING not reporting region error due to -Znll\n+        closure(&mut p, &y);\n+    }\n+\n+    deref(p);\n+}\n+\n+fn expect_sig<F>(f: F) -> F\n+    where F: FnMut(&mut &i32, &i32)\n+{\n+    f\n+}\n+\n+fn deref(_p: &i32) { }\n+\n+fn main() { }"}, {"sha": "c842d51a2ad749554a4a1864ad258c2887051ef0", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,40 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/escape-argument-callee.rs:36:50\n+   |\n+36 |         let mut closure = expect_sig(|p, y| *p = y);\n+   |                                                  ^\n+\n+error: free region `'_#4r` does not outlive free region `'_#3r`\n+  --> $DIR/escape-argument-callee.rs:36:45\n+   |\n+36 |         let mut closure = expect_sig(|p, y| *p = y);\n+   |                                             ^^^^^^\n+\n+note: External requirements\n+  --> $DIR/escape-argument-callee.rs:36:38\n+   |\n+36 |         let mut closure = expect_sig(|p, y| *p = y);\n+   |                                      ^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:9 ~ escape_argument_callee[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) mut &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) i32))\n+           ]\n+   = note: number of external vids: 1\n+\n+note: No external requirements\n+  --> $DIR/escape-argument-callee.rs:30:1\n+   |\n+30 | / fn test() {\n+31 | |     let x = 44;\n+32 | |     let mut p = &x;\n+33 | |\n+...  |\n+42 | |     deref(p);\n+43 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:3 ~ escape_argument_callee[317d]::test[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d8a916345e2227a7599d007443943c2727b7ab6", "filename": "src/test/ui/nll/closure-requirements/escape-argument.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test closure that:\n+//\n+// - takes an argument `y`\n+// - stores `y` into another, longer-lived spot\n+//\n+// but is invoked with a spot that doesn't live long\n+// enough to store `y`.\n+//\n+// The error is reported in the caller: invoking the closure links the\n+// lifetime of the variable that is given as `y` (via subtyping) and\n+// thus forces the corresponding borrow to live too long. This is\n+// basically checking that the MIR type checker correctly enforces the\n+// closure signature.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn test() {\n+    let x = 44;\n+    let mut p = &x;\n+\n+    {\n+        let y = 22;\n+        let mut closure = expect_sig(|p, y| *p = y);\n+        closure(&mut p, &y);\n+    }\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    deref(p);\n+}\n+\n+fn expect_sig<F>(f: F) -> F\n+    where F: for<'a, 'b> FnMut(&'a mut &'b i32, &'b i32)\n+{\n+    f\n+}\n+\n+fn deref(_p: &i32) { }\n+\n+fn main() { }"}, {"sha": "e5c7139573eb958af42422cbf4db1d187bf88c7d", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,39 @@\n+note: External requirements\n+  --> $DIR/escape-argument.rs:36:38\n+   |\n+36 |         let mut closure = expect_sig(|p, y| *p = y);\n+   |                                      ^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:9 ~ escape_argument[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) mut &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32))\n+           ]\n+   = note: number of external vids: 1\n+\n+note: No external requirements\n+  --> $DIR/escape-argument.rs:30:1\n+   |\n+30 | / fn test() {\n+31 | |     let x = 44;\n+32 | |     let mut p = &x;\n+33 | |\n+...  |\n+41 | |     deref(p);\n+42 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:3 ~ escape_argument[317d]::test[0]) with substs []\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/escape-argument.rs:38:6\n+   |\n+35 |         let y = 22;\n+   |             - temporary value created here\n+...\n+38 |     }\n+   |      ^ temporary value dropped here while still borrowed\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "9f4585bfbab8e599d32b5c9e281e0d7d5a7d0998", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As in `escape-upvar-ref.rs`, test closure that:\n+//\n+// - captures a variable `y`\n+// - stores reference to `y` into another, longer-lived spot\n+//\n+// except that the closure does so via a second closure.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn test() {\n+    let x = 44;\n+    let mut p = &x;\n+\n+    {\n+        let y = 22;\n+\n+        let mut closure = || {\n+            let mut closure1 = || p = &y;\n+            closure1();\n+        };\n+\n+        closure();\n+    } //~ ERROR borrowed value does not live long enough\n+\n+    deref(p);\n+}\n+\n+fn deref(_p: &i32) { }\n+\n+fn main() { }"}, {"sha": "201590f01f38ee0dccc3c23ba0254182b0451d16", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,61 @@\n+note: External requirements\n+  --> $DIR/escape-upvar-nested.rs:31:32\n+   |\n+31 |             let mut closure1 = || p = &y;\n+   |                                ^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:10 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               extern \"rust-call\" fn(()),\n+               &'_#1r mut &'_#2r i32,\n+               &'_#3r i32\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#3r: '_#2r\n+\n+note: External requirements\n+  --> $DIR/escape-upvar-nested.rs:30:27\n+   |\n+30 |           let mut closure = || {\n+   |  ___________________________^\n+31 | |             let mut closure1 = || p = &y;\n+32 | |             closure1();\n+33 | |         };\n+   | |_________^\n+   |\n+   = note: defining type: DefId(0/1:9 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               extern \"rust-call\" fn(()),\n+               &'_#1r mut &'_#2r i32,\n+               &'_#3r i32\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#3r: '_#2r\n+\n+note: No external requirements\n+  --> $DIR/escape-upvar-nested.rs:23:1\n+   |\n+23 | / fn test() {\n+24 | |     let x = 44;\n+25 | |     let mut p = &x;\n+26 | |\n+...  |\n+38 | |     deref(p);\n+39 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:3 ~ escape_upvar_nested[317d]::test[0]) with substs []\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/escape-upvar-nested.rs:36:6\n+   |\n+28 |         let y = 22;\n+   |             - temporary value created here\n+...\n+36 |     } //~ ERROR borrowed value does not live long enough\n+   |      ^ temporary value dropped here while still borrowed\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "548a5ae59690c0bac938a6a1acf402d32ca71465", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test closure that:\n+//\n+// - captures a variable `y` by reference\n+// - stores that reference to `y` into another, longer-lived place (`p`)\n+//\n+// Both of these are upvars of reference type (the capture of `y` is\n+// of type `&'a i32`, the capture of `p` is of type `&mut &'b\n+// i32`). The closure thus computes a relationship between `'a` and\n+// `'b`.  This relationship is propagated to the closure creator,\n+// which reports an error.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn test() {\n+    let x = 44;\n+    let mut p = &x;\n+\n+    {\n+        let y = 22;\n+        let mut closure = || p = &y;\n+        closure();\n+    } //~ ERROR borrowed value does not live long enough\n+\n+    deref(p);\n+}\n+\n+fn deref(_p: &i32) { }\n+\n+fn main() { }"}, {"sha": "47ba66ade6533ed4bed408710cb97f1cf828cf3a", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,42 @@\n+note: External requirements\n+  --> $DIR/escape-upvar-ref.rs:33:27\n+   |\n+33 |         let mut closure = || p = &y;\n+   |                           ^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:9 ~ escape_upvar_ref[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               extern \"rust-call\" fn(()),\n+               &'_#1r mut &'_#2r i32,\n+               &'_#3r i32\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#3r: '_#2r\n+\n+note: No external requirements\n+  --> $DIR/escape-upvar-ref.rs:27:1\n+   |\n+27 | / fn test() {\n+28 | |     let x = 44;\n+29 | |     let mut p = &x;\n+30 | |\n+...  |\n+37 | |     deref(p);\n+38 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:3 ~ escape_upvar_ref[317d]::test[0]) with substs []\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/escape-upvar-ref.rs:35:6\n+   |\n+32 |         let y = 22;\n+   |             - temporary value created here\n+...\n+35 |     } //~ ERROR borrowed value does not live long enough\n+   |      ^ temporary value dropped here while still borrowed\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "c2f071cc029e6898731aacf62844533ea28d3ab9", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we fail to approximate due to demanding a postdom\n+// relationship between our upper bounds.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'x: 'a\n+// 'x: 'b\n+// 'c: 'y\n+//\n+// we have to prove that `'x: 'y`. We currently can only approximate\n+// via a postdominator -- hence we fail to choose between `'a` and\n+// `'b` here and report the error in the closure.\n+fn establish_relationships<'a, 'b, 'c, F>(\n+    _cell_a: Cell<&'a u32>,\n+    _cell_b: Cell<&'b u32>,\n+    _cell_c: Cell<&'c u32>,\n+    _closure: F,\n+) where\n+    F: for<'x, 'y> FnMut(\n+        Cell<&'a &'x u32>, // shows that 'x: 'a\n+        Cell<&'b &'x u32>, // shows that 'x: 'b\n+        Cell<&'y &'c u32>, // shows that 'c: 'y\n+        Cell<&'x u32>,\n+        Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: Cell<&'x u32>, _cell_y: Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell<&'c u32>) {\n+    establish_relationships(\n+        cell_a,\n+        cell_b,\n+        cell_c,\n+        |_outlives1, _outlives2, _outlives3, x, y| {\n+            // Only works if 'x: 'y:\n+            let p = x.get();\n+            //~^ WARN not reporting region error due to -Znll\n+            demand_y(x, y, p)\n+            //~^ ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+        },\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "d581622c4c63e87b438f6c9e4368c31fb80d34a0", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,46 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n+   |\n+55 |             let p = x.get();\n+   |                     ^^^^^^^\n+\n+error: free region `'_#5r` does not outlive free region `'_#6r`\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:25\n+   |\n+57 |             demand_y(x, y, p)\n+   |                         ^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n+   |\n+53 | /         |_outlives1, _outlives2, _outlives3, x, y| {\n+54 | |             // Only works if 'x: 'y:\n+55 | |             let p = x.get();\n+56 | |             //~^ WARN not reporting region error due to -Znll\n+57 | |             demand_y(x, y, p)\n+58 | |             //~^ ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+59 | |         },\n+   | |_________^\n+   |\n+   = note: defining type: DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n+           ]\n+   = note: number of external vids: 4\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:48:1\n+   |\n+48 | / fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell<&'c u32>) {\n+49 | |     establish_relationships(\n+50 | |         cell_a,\n+51 | |         cell_b,\n+...  |\n+60 | |     );\n+61 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "76a0762461a2b2197a3782a320c7e757f043ca01", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Rather convoluted setup where we infer a relationship between two\n+// free regions in the closure signature (`'a` and `'b`) on the basis\n+// of a relationship between two bound regions (`'x` and `'y`).\n+//\n+// The idea is that, thanks to invoking `demand_y`, `'x: 'y` must\n+// hold, where `'x` and `'y` are bound regions. The closure can't\n+// prove that directly, and because `'x` and `'y` are bound it cannot\n+// ask the caller to prove it either. But it has bounds on `'x` and\n+// `'y` in terms of `'a` and `'b`, and it can propagate a relationship\n+// between `'a` and `'b` to the caller.\n+//\n+// Note: the use of `Cell` here is to introduce invariance. One less\n+// variable.\n+//\n+// FIXME(#45827): The `supply` function *ought* to generate an error, but it\n+// currently does not. This is I believe a shortcoming of the MIR type\n+// checker: the closure inference is expressing the correct\n+// requirement, as you can see from the `#[rustc_regions]` output.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'x: 'a\n+// 'b: 'y\n+//\n+// so if we are going to ensure that `'x: 'y`, then `'a: 'b` must\n+// hold.\n+fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        &Cell<&'a &'x u32>, // shows that 'x: 'a\n+        &Cell<&'y &'b u32>, // shows that 'b: 'y\n+        &Cell<&'x u32>,\n+        &Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(x, y, x.get())\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "7553ac5b0c3054a3b996cededf37c784f5ccf93c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,36 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-ref.rs:60:9\n+   |\n+60 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-ref.rs:58:47\n+   |\n+58 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n+59 | |         // Only works if 'x: 'y:\n+60 | |         demand_y(x, y, x.get())\n+61 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_approximated_ref[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) &'_#2r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't3)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-ref.rs:57:1\n+   |\n+57 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+58 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+59 | |         // Only works if 'x: 'y:\n+60 | |         demand_y(x, y, x.get())\n+61 | |     });\n+62 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_ref[317d]::supply[0]) with substs []\n+"}, {"sha": "0a47ee80256b5a4f886ff50c92e243f078e9ac75", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where we setup relationships like `'x: 'a` or `'a: 'x`,\n+// where `'x` is bound in closure type but `'a` is free. This forces\n+// us to approximate `'x` one way or the other.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+fn foo<'a, F>(_cell: Cell<&'a u32>, _f: F)\n+where\n+    F: for<'x> FnOnce(Cell<&'a u32>, Cell<&'x u32>),\n+{\n+}\n+\n+#[rustc_regions]\n+fn case1() {\n+    let a = 0;\n+    let cell = Cell::new(&a);\n+    foo(cell, |cell_a, cell_x| {\n+        //~^ WARNING not reporting region error due to -Znll\n+        cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n+        //~^ ERROR free region `'_#2r` does not outlive free region `'_#1r`\n+    })\n+}\n+\n+#[rustc_regions]\n+fn case2() {\n+    let a = 0;\n+    let cell = Cell::new(&a);\n+\n+    // As you can see in the stderr output, this closure propoagates a\n+    // requirement that `'a: 'static'.\n+    //\n+    // FIXME(#45827) However, because of shortcomings in the MIR type\n+    // checker, this does not result in errors later on (yet).\n+    foo(cell, |cell_a, cell_x| {\n+        cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n+    })\n+}\n+\n+fn main() { }"}, {"sha": "e2de72ffe933fd3fcdc1de504cc99ae8c899b95d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,75 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:5\n+   |\n+31 |     foo(cell, |cell_a, cell_x| {\n+   |     ^^^\n+\n+error: free region `'_#2r` does not outlive free region `'_#1r`\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n+   |\n+33 |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n+   |         ^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15\n+   |\n+31 |       foo(cell, |cell_a, cell_x| {\n+   |  _______________^\n+32 | |         //~^ WARNING not reporting region error due to -Znll\n+33 | |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n+34 | |         //~^ ERROR free region `'_#2r` does not outlive free region `'_#1r`\n+35 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:12 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case1[0]::{{closure}}[0]) with closure substs [\n+               i32,\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>))\n+           ]\n+   = note: number of external vids: 2\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:28:1\n+   |\n+28 | / fn case1() {\n+29 | |     let a = 0;\n+30 | |     let cell = Cell::new(&a);\n+31 | |     foo(cell, |cell_a, cell_x| {\n+...  |\n+35 | |     })\n+36 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:5 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case1[0]) with substs []\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:48:15\n+   |\n+48 |       foo(cell, |cell_a, cell_x| {\n+   |  _______________^\n+49 | |         cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n+50 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:13 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case2[0]::{{closure}}[0]) with closure substs [\n+               i32,\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where '_#1r: '_#0r\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:39:1\n+   |\n+39 | / fn case2() {\n+40 | |     let a = 0;\n+41 | |     let cell = Cell::new(&a);\n+42 | |\n+...  |\n+50 | |     })\n+51 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case2[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "f776ddc8b153f08e613814abbd23214ccbe4ab48", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where we are trying to prove `'x: 'y` and are forced to\n+// approximate the shorter end-point (`'y`) to with `'static`. This is\n+// because `'y` is higher-ranked but we know of no relations to other\n+// regions. Note that `'static` shows up in the stderr output as `'0`.\n+//\n+// FIXME(#45827) Because of shortcomings in the MIR type checker,\n+// these errors are not (yet) reported.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'x: 'a\n+//\n+// so the only way we can ensure that `'x: 'y` is to show that\n+// `'a: 'static`.\n+fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        &Cell<&'a &'x u32>, // shows that 'x: 'a\n+        &Cell<&'x u32>,\n+        &Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(x, y, x.get())\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "8d1b9a94ea6a123631b80640286dc234b66ca3cd", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,36 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:47:9\n+   |\n+47 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n+   |\n+45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |  _______________________________________________^\n+46 | |         // Only works if 'x: 'y:\n+47 | |         demand_y(x, y, x.get())\n+48 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) u32>))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where '_#1r: '_#0r\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1\n+   |\n+44 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+45 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+46 | |         // Only works if 'x: 'y:\n+47 | |         demand_y(x, y, x.get())\n+48 | |     });\n+49 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]) with substs []\n+"}, {"sha": "54b501c9ab6be3fb640d9c6ebb6961645e9998a9", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where we are trying to prove `'x: 'y` and are forced to\n+// approximate the shorter end-point (`'y`) to with `'static`. This is\n+// because `'y` is higher-ranked but we know of only irrelevant\n+// relations to other regions. Note that `'static` shows up in the\n+// stderr output as `'0`.\n+//\n+// FIXME(#45827) Because of shortcomings in the MIR type checker,\n+// these errors are not (yet) reported.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'x: 'a\n+// 'y: 'b\n+//\n+// so the only way we can ensure that `'x: 'y` is to show that\n+// `'a: 'static`.\n+fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        &Cell<&'a &'x u32>, // shows that 'x: 'a\n+        &Cell<&'b &'y u32>, // shows that 'y: 'b\n+        &Cell<&'x u32>,\n+        &Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(x, y, x.get())\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "9d318a63d8fcba2fe990f7f56e1275f7e4898153", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,36 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:50:9\n+   |\n+50 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n+   |\n+48 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n+49 | |         // Only works if 'x: 'y:\n+50 | |         demand_y(x, y, x.get())\n+51 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't3)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#0r\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1\n+   |\n+47 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+48 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+49 | |         // Only works if 'x: 'y:\n+50 | |         demand_y(x, y, x.get())\n+51 | |     });\n+52 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]) with substs []\n+"}, {"sha": "48d446b00af8bb7c045fe35e4bbf25dea58bdd35", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simpler variant of `outlives-from-argument` where cells are\n+// passed by value.\n+//\n+// This is simpler because there are no \"extraneous\" region\n+// relationships. In the 'main' variant, there are a number of\n+// anonymous regions as well.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'x: 'a\n+// 'b: 'y\n+//\n+// so if we are going to ensure that `'x: 'y`, then `'a: 'b` must\n+// hold.\n+fn establish_relationships<'a, 'b, F>(_cell_a: Cell<&'a u32>, _cell_b: Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        Cell<&'a &'x u32>, // shows that 'x: 'a\n+        Cell<&'y &'b u32>, // shows that 'b: 'y\n+        Cell<&'x u32>,\n+        Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_outlives1: Cell<&&'x u32>, _outlives2: Cell<&'y &u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(outlives1, outlives2, x.get())\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "ae5ad6f4b9602d6065b31c6e93a8202f84764fc8", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,36 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-val.rs:48:9\n+   |\n+48 |         demand_y(outlives1, outlives2, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-approximated-val.rs:46:45\n+   |\n+46 |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+   |  _____________________________________________^\n+47 | |         // Only works if 'x: 'y:\n+48 | |         demand_y(outlives1, outlives2, x.get())\n+49 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_approximated_val[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-val.rs:45:1\n+   |\n+45 | / fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+46 | |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+47 | |         // Only works if 'x: 'y:\n+48 | |         demand_y(outlives1, outlives2, x.get())\n+49 | |     });\n+50 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_val[317d]::test[0]) with substs []\n+"}, {"sha": "a28b5f4c0f949139e039f78bea8e0bd5fc07207d", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we might in theory be able to see that the relationship\n+// between two bound regions is true within closure and hence have no\n+// need to propagate; but in fact we do because identity of free\n+// regions is erased.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// In theory, callee knows that:\n+//\n+// 'x: 'a\n+// 'a: 'y\n+//\n+// and hence could satisfy that `'x: 'y` locally. However, in our\n+// checking, we ignore the precise free regions that come into the\n+// region and just assign each position a distinct universally bound\n+// region. Hence, we propagate a constraint to our caller that will\n+// wind up being solvable.\n+fn establish_relationships<'a, F>(\n+    _cell_a: Cell<&'a u32>,\n+    _closure: F,\n+) where\n+    F: for<'x, 'y> FnMut(\n+        Cell<&'a &'x u32>, // shows that 'x: 'a\n+        Cell<&'y &'a u32>, // shows that 'a: 'y\n+        Cell<&'x u32>,\n+        Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: Cell<&'x u32>, _cell_y: Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a>(cell_a: Cell<&'a u32>) {\n+    establish_relationships(\n+        cell_a,\n+        |_outlives1, _outlives2, x, y| {\n+            // Only works if 'x: 'y:\n+            let p = x.get();\n+            demand_y(x, y, p)\n+        },\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "64f3bb08c620cf42a0d85d8bcc86f0baf3f95cc9", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,37 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-despite-same-free-region.rs:53:21\n+   |\n+53 |             let p = x.get();\n+   |                     ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-despite-same-free-region.rs:51:9\n+   |\n+51 | /         |_outlives1, _outlives2, x, y| {\n+52 | |             // Only works if 'x: 'y:\n+53 | |             let p = x.get();\n+54 | |             demand_y(x, y, p)\n+55 | |         },\n+   | |_________^\n+   |\n+   = note: defining type: DefId(0/1:16 ~ propagate_despite_same_free_region[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+\n+note: No external requirements\n+  --> $DIR/propagate-despite-same-free-region.rs:48:1\n+   |\n+48 | / fn supply<'a>(cell_a: Cell<&'a u32>) {\n+49 | |     establish_relationships(\n+50 | |         cell_a,\n+51 | |         |_outlives1, _outlives2, x, y| {\n+...  |\n+56 | |     );\n+57 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_despite_same_free_region[317d]::supply[0]) with substs []\n+"}, {"sha": "4bbdcc4494486040f42bb0e41ccc18f97ce69888", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Similarly to escape-argument-callee, a test case where the closure\n+// requires a relationship between 2 unrelated higher-ranked regions,\n+// with no helpful relations between the HRRs and free regions.\n+//\n+// In this case, the error is reported by the closure itself. This is\n+// because it is unable to approximate the higher-ranked region `'x`,\n+// as it knows of no relationships between `'x` and any\n+// non-higher-ranked regions.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'b: 'y\n+//\n+// but this doesn't really help us in proving that `'x: 'y`, so closure gets an error.\n+fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        &Cell<&'y &'b u32>, // shows that 'b: 'y\n+        &Cell<&'x u32>,\n+        &Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(x, y, x.get())\n+        //~^ WARN not reporting region error due to -Znll\n+        //~| ERROR free region `'_#6r` does not outlive free region `'_#4r`\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "6094f9aad81da7683ccb97532b5173b700615eb5", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,46 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n+   |\n+47 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `'_#6r` does not outlive free region `'_#4r`\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:21\n+   |\n+47 |         demand_y(x, y, x.get())\n+   |                     ^\n+\n+note: External requirements\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47\n+   |\n+45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |  _______________________________________________^\n+46 | |         // Only works if 'x: 'y:\n+47 | |         demand_y(x, y, x.get())\n+48 | |         //~^ WARN not reporting region error due to -Znll\n+49 | |         //~| ERROR free region `'_#6r` does not outlive free region `'_#4r`\n+50 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n+           ]\n+   = note: number of external vids: 2\n+\n+note: No external requirements\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:44:1\n+   |\n+44 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+45 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+46 | |         // Only works if 'x: 'y:\n+47 | |         demand_y(x, y, x.get())\n+...  |\n+50 | |     });\n+51 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "69fad354792f08775bc1585addd96a8e4988b6af", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Similarly to escape-argument-callee, a test case where the closure\n+// requires a relationship between 2 unrelated higher-ranked regions,\n+// with no helpful relations between the HRRs and free regions.\n+//\n+// In this case, the error is reported by the closure itself. This is\n+// because it is unable to approximate the higher-ranked region `'x`,\n+// as it only knows of regions that `'x` is outlived by, and none that\n+// `'x` outlives.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Callee knows that:\n+//\n+// 'a: 'x\n+// 'b: 'y\n+//\n+// but this doesn't really help us in proving that `'x: 'y`, so\n+// closure gets an error.  In particular, we would need to know that\n+// `'x: 'a`, so that we could approximate `'x` \"downwards\" to `'a`.\n+fn establish_relationships<'a, 'b, F>(_cell_a: &Cell<&'a u32>, _cell_b: &Cell<&'b u32>, _closure: F)\n+where\n+    F: for<'x, 'y> FnMut(\n+        &Cell<&'x &'a u32>, // shows that 'a: 'x\n+        &Cell<&'y &'b u32>, // shows that 'b: 'y\n+        &Cell<&'x u32>,\n+        &Cell<&'y u32>,\n+    ),\n+{\n+}\n+\n+fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u32) {}\n+\n+#[rustc_regions]\n+fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+    establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+        // Only works if 'x: 'y:\n+        demand_y(x, y, x.get())\n+        //~^ WARN not reporting region error due to -Znll\n+        //~| ERROR free region `'_#5r` does not outlive free region `'_#7r`\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "6658ee63abd9dc2d74bdada139aa8e82b67a15bc", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,46 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n+   |\n+51 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `'_#5r` does not outlive free region `'_#7r`\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:21\n+   |\n+51 |         demand_y(x, y, x.get())\n+   |                     ^\n+\n+note: External requirements\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47\n+   |\n+49 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n+50 | |         // Only works if 'x: 'y:\n+51 | |         demand_y(x, y, x.get())\n+52 | |         //~^ WARN not reporting region error due to -Znll\n+53 | |         //~| ERROR free region `'_#5r` does not outlive free region `'_#7r`\n+54 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) &'_#2r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't3)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>))\n+           ]\n+   = note: number of external vids: 3\n+\n+note: No external requirements\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:48:1\n+   |\n+48 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+49 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+50 | |         // Only works if 'x: 'y:\n+51 | |         demand_y(x, y, x.get())\n+...  |\n+54 | |     });\n+55 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "c61cf8a940f95dcc1361735ae20205126b40a721", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+fn foo(x: &u32) -> &'static u32 {\n+    &*x\n+        //~^ WARN not reporting region error due to -Znll\n+        //~| ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+}\n+\n+fn main() { }"}, {"sha": "ef7ea9239127bccde3aa7500a924c3b43d963e91", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/region-lbr-anon-does-not-outlive-static.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: free region `'_#1r` does not outlive free region `ReStatic`\n+  --> $DIR/region-lbr-anon-does-not-outlive-static.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fcda5c5420bfe4a8046f7a66d2eb6060c71b7ad9", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test ought to\n+// report an error due to a reborrowing constraint. Right now, we get\n+// a variety of errors from the older, AST-based machinery (notably\n+// borrowck), and then we get the NLL error at the end.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+fn foo<'a>(x: &'a u32) -> &'static u32 {\n+    &*x\n+        //~^ WARN not reporting region error due to -Znll\n+        //~| ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+}\n+\n+fn main() { }"}, {"sha": "6dcb8e7cf122d55f6da98b59e850a314c1ef4b41", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/region-lbr-named-does-not-outlive-static.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: free region `'_#1r` does not outlive free region `ReStatic`\n+  --> $DIR/region-lbr-named-does-not-outlive-static.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c1e4dee00656ba61dce2d15406add294dfaa37c6", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -13,12 +13,12 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n \n fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n-    &*x //~ ERROR free region `'a` does not outlive `'b`\n-    //~^ ERROR `*x` does not live long enough\n-    //~| WARN not reporting region error due to -Znll\n+    &*x\n+        //~^ WARN not reporting region error due to -Znll\n+        //~| ERROR free region `'_#1r` does not outlive free region `'_#2r`\n }\n \n fn main() { }", "previous_filename": "src/test/ui/nll/named-region-basic.rs"}, {"sha": "c1b2f440309497c6d6238af5aae96cb0f56decfe", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/region-lbr1-does-not-outlive-ebr2.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: free region `'_#1r` does not outlive free region `'_#2r`\n+  --> $DIR/region-lbr1-does-not-outlive-ebr2.rs:19:5\n+   |\n+19 |     &*x\n+   |     ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ffb1935e75e3250e50acb450ba957e6b57457ea2", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-outlive-lbr2-because-implied-bound.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for free regions in the NLL code. This test does not\n+// report an error because of the (implied) bound that `'b: 'a`.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+#![allow(warnings)]\n+\n+fn foo<'a, 'b>(x: &'a &'b u32) -> &'a u32 {\n+    &**x\n+}\n+\n+fn main() { }"}, {"sha": "9314bbf94322256db21fd4c6819c5f039becc649", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test closure that takes two references and is supposed to return\n+// the first, but actually returns the second. This should fail within\n+// the closure.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn test() {\n+    expect_sig(|a, b| b); // ought to return `a`\n+    //~^ WARN not reporting region error due to -Znll\n+    //~| ERROR free region `'_#3r` does not outlive free region `'_#2r`\n+}\n+\n+fn expect_sig<F>(f: F) -> F\n+    where F: for<'a> FnMut(&'a i32, &i32) -> &'a i32\n+{\n+    f\n+}\n+\n+fn deref(_p: &i32) { }\n+\n+fn main() { }"}, {"sha": "8999f69e8ded64284bb8a1ecf09e422c6e28626a", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -0,0 +1,38 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/return-wrong-bound-region.rs:21:23\n+   |\n+21 |     expect_sig(|a, b| b); // ought to return `a`\n+   |                       ^\n+\n+error: free region `'_#3r` does not outlive free region `'_#2r`\n+  --> $DIR/return-wrong-bound-region.rs:21:23\n+   |\n+21 |     expect_sig(|a, b| b); // ought to return `a`\n+   |                       ^\n+\n+note: External requirements\n+  --> $DIR/return-wrong-bound-region.rs:21:16\n+   |\n+21 |     expect_sig(|a, b| b); // ought to return `a`\n+   |                ^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:9 ~ return_wrong_bound_region[317d]::test[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32)) -> &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) i32\n+           ]\n+   = note: number of external vids: 1\n+\n+note: No external requirements\n+  --> $DIR/return-wrong-bound-region.rs:20:1\n+   |\n+20 | / fn test() {\n+21 | |     expect_sig(|a, b| b); // ought to return `a`\n+22 | |     //~^ WARN not reporting region error due to -Znll\n+23 | |     //~| ERROR free region `'_#3r` does not outlive free region `'_#2r`\n+24 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:3 ~ return_wrong_bound_region[317d]::test[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "9c1de6c366cc92afc94e8c4d68e9dbdbc8b9e1c7", "filename": "src/test/ui/nll/named-region-basic.stderr", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ee25791df5f025378e9ddebef661e25cb75d9172/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee25791df5f025378e9ddebef661e25cb75d9172/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnamed-region-basic.stderr?ref=ee25791df5f025378e9ddebef661e25cb75d9172", "patch": "@@ -1,31 +0,0 @@\n-warning: not reporting region error due to -Znll\n-  --> $DIR/named-region-basic.rs:19:5\n-   |\n-19 |     &*x //~ ERROR free region `'a` does not outlive `'b`\n-   |     ^^^\n-\n-error[E0597]: `*x` does not live long enough\n-  --> $DIR/named-region-basic.rs:19:6\n-   |\n-19 |     &*x //~ ERROR free region `'a` does not outlive `'b`\n-   |      ^^ does not live long enough\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-note: ...but borrowed value is only valid for the lifetime 'a as defined on the function body at 18:1\n-  --> $DIR/named-region-basic.rs:18:1\n-   |\n-18 | / fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n-19 | |     &*x //~ ERROR free region `'a` does not outlive `'b`\n-20 | |     //~^ ERROR `*x` does not live long enough\n-21 | |     //~| WARN not reporting region error due to -Znll\n-22 | | }\n-   | |_^\n-\n-error: free region `'a` does not outlive `'b`\n-  --> $DIR/named-region-basic.rs:19:5\n-   |\n-19 |     &*x //~ ERROR free region `'a` does not outlive `'b`\n-   |     ^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "a18f4ec1aadb469b83e6762d447699ed9eb04098", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8437a0accccc4140731b1a73c13ada7305883ac/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a8437a0accccc4140731b1a73c13ada7305883ac", "patch": "@@ -2535,7 +2535,10 @@ impl<'test> TestCx<'test> {\n         let mut dumped_file = fs::File::open(output_file.clone()).unwrap();\n         let mut dumped_string = String::new();\n         dumped_file.read_to_string(&mut dumped_string).unwrap();\n-        let mut dumped_lines = dumped_string.lines().filter(|l| !l.is_empty());\n+        let mut dumped_lines = dumped_string\n+            .lines()\n+            .map(|l| nocomment_mir_line(l))\n+            .filter(|l| !l.is_empty());\n         let mut expected_lines = expected_content\n             .iter()\n             .filter(|&l| {\n@@ -2573,7 +2576,7 @@ impl<'test> TestCx<'test> {\n                 .join(\"\\n\");\n             panic!(\n                 \"Did not find expected line, error: {}\\n\\\n-                 Actual Line: {:?}\\n\\\n+                 Expected Line: {:?}\\n\\\n                  Expected:\\n{}\\n\\\n                  Actual:\\n{}\",\n                 extra_msg,\n@@ -2599,7 +2602,9 @@ impl<'test> TestCx<'test> {\n                         error(\n                             expected_line,\n                             format!(\n-                                \"Mismatch in lines\\nCurrnt block: {}\\nExpected Line: {:?}\",\n+                                \"Mismatch in lines\\n\\\n+                                 Current block: {}\\n\\\n+                                 Actual Line: {:?}\",\n                                 start_block_line.unwrap_or(\"None\"),\n                                 dumped_line\n                             ),"}]}