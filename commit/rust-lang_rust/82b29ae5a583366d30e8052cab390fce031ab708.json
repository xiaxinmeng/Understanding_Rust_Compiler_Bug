{"sha": "82b29ae5a583366d30e8052cab390fce031ab708", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYjI5YWU1YTU4MzM2NmQzMGU4MDUyY2FiMzkwZmNlMDMxYWI3MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T01:25:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T01:25:24Z"}, "message": "auto merge of #7864 : brson/rust/start-on-main-thread, r=brson\n\nApplications that need to use the GUI can override start and set up the runtime using\r\nthis function.", "tree": {"sha": "b417359833b7c9b243490c87860c936f5f556000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b417359833b7c9b243490c87860c936f5f556000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b29ae5a583366d30e8052cab390fce031ab708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b29ae5a583366d30e8052cab390fce031ab708", "html_url": "https://github.com/rust-lang/rust/commit/82b29ae5a583366d30e8052cab390fce031ab708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b29ae5a583366d30e8052cab390fce031ab708/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b027c5fce3e74dfa5583224967e38ef40518ecfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b027c5fce3e74dfa5583224967e38ef40518ecfb", "html_url": "https://github.com/rust-lang/rust/commit/b027c5fce3e74dfa5583224967e38ef40518ecfb"}, {"sha": "34a27db8bf90d9cc3727a1c6654eccdc7018eb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a27db8bf90d9cc3727a1c6654eccdc7018eb29", "html_url": "https://github.com/rust-lang/rust/commit/34a27db8bf90d9cc3727a1c6654eccdc7018eb29"}], "stats": {"total": 92, "additions": 82, "deletions": 10}, "files": [{"sha": "4eaf772d41ae5994151bfcbc872f5e3eb3897c71", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/82b29ae5a583366d30e8052cab390fce031ab708/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b29ae5a583366d30e8052cab390fce031ab708/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=82b29ae5a583366d30e8052cab390fce031ab708", "patch": "@@ -65,11 +65,11 @@ use clone::Clone;\n use container::Container;\n use iter::Times;\n use iterator::IteratorUtil;\n-use option::Some;\n+use option::{Some, None};\n use ptr::RawPtr;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n-use rt::task::Task;\n+use rt::task::{Task, Sched};\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n@@ -187,6 +187,19 @@ pub fn start(argc: int, argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n     return exit_code;\n }\n \n+/// Like `start` but creates an additional scheduler on the current thread,\n+/// which in most cases will be the 'main' thread, and pins the main task to it.\n+///\n+/// This is appropriate for running code that must execute on the main thread,\n+/// such as the platform event loop and GUI.\n+pub fn start_on_main_thread(argc: int, argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n+    init(argc, argv, crate_map);\n+    let exit_code = run_on_main_thread(main);\n+    cleanup();\n+\n+    return exit_code;\n+}\n+\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing\n@@ -217,10 +230,17 @@ pub fn cleanup() {\n /// using a task scheduler with the same number of threads as cores.\n /// Returns a process exit code.\n pub fn run(main: ~fn()) -> int {\n+    run_(main, false)\n+}\n+\n+pub fn run_on_main_thread(main: ~fn()) -> int {\n+    run_(main, true)\n+}\n \n+fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     static DEFAULT_ERROR_CODE: int = 101;\n \n-    let nthreads = util::default_sched_threads();\n+    let nscheds = util::default_sched_threads();\n \n     // The shared list of sleeping schedulers. Schedulers wake each other\n     // occassionally to do new work.\n@@ -234,7 +254,7 @@ pub fn run(main: ~fn()) -> int {\n     // sent the Shutdown message to terminate the schedulers.\n     let mut handles = ~[];\n \n-    for nthreads.times {\n+    for nscheds.times {\n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n@@ -244,6 +264,21 @@ pub fn run(main: ~fn()) -> int {\n         handles.push(handle);\n     }\n \n+    // If we need a main-thread task then create a main thread scheduler\n+    // that will reject any task that isn't pinned to it\n+    let mut main_sched = if use_main_sched {\n+        let main_loop = ~UvEventLoop::new();\n+        let mut main_sched = ~Scheduler::new_special(main_loop,\n+                                                     work_queue.clone(),\n+                                                     sleepers.clone(),\n+                                                     false);\n+        let main_handle = main_sched.make_handle();\n+        handles.push(main_handle);\n+        Some(main_sched)\n+    } else {\n+        None\n+    };\n+\n     // Create a shared cell for transmitting the process exit\n     // code from the main task to this function.\n     let exit_code = UnsafeAtomicRcBox::new(AtomicInt::new(0));\n@@ -273,12 +308,22 @@ pub fn run(main: ~fn()) -> int {\n         }\n     };\n \n-    // Create and enqueue the main task.\n-    let main_cell = Cell::new(main);\n-    let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                    main_cell.take());\n-    main_task.death.on_exit = Some(on_exit);\n-    scheds[0].enqueue_task(main_task);\n+    // Build the main task and queue it up\n+    match main_sched {\n+        None => {\n+            // The default case where we don't need a scheduler on the main thread.\n+            // Just put an unpinned task onto one of the default schedulers.\n+            let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, main);\n+            main_task.death.on_exit = Some(on_exit);\n+            scheds[0].enqueue_task(main_task);\n+        }\n+        Some(ref mut main_sched) => {\n+            let home = Sched(main_sched.make_handle());\n+            let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool, home, main);\n+            main_task.death.on_exit = Some(on_exit);\n+            main_sched.enqueue_task(main_task);\n+        }\n+    };\n \n     // Run each scheduler in a thread.\n     let mut threads = ~[];\n@@ -293,6 +338,12 @@ pub fn run(main: ~fn()) -> int {\n         threads.push(thread);\n     }\n \n+    // Run the main-thread scheduler\n+    match main_sched {\n+        Some(sched) => { let _ = sched.run(); },\n+        None => ()\n+    }\n+\n     // Wait for schedulers\n     { let _threads = threads; }\n "}, {"sha": "8328e7416c57951faf201d39137c31a75c46f4e6", "filename": "src/test/run-pass/rt-start-main-thread.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82b29ae5a583366d30e8052cab390fce031ab708/src%2Ftest%2Frun-pass%2Frt-start-main-thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b29ae5a583366d30e8052cab390fce031ab708/src%2Ftest%2Frun-pass%2Frt-start-main-thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-start-main-thread.rs?ref=82b29ae5a583366d30e8052cab390fce031ab708", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+#[start]\n+fn start(argc: int, argv: **u8, crate_map: *u8) -> int {\n+    do std::rt::start_on_main_thread(argc, argv, crate_map) {\n+        info!(\"running on main thread\");\n+        do spawn {\n+            info!(\"running on another thread\");\n+        }\n+    }\n+}\n\\ No newline at end of file"}]}