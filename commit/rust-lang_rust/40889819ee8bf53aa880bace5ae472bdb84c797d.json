{"sha": "40889819ee8bf53aa880bace5ae472bdb84c797d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwODg5ODE5ZWU4YmY1M2FhODgwYmFjZTVhZTQ3MmJkYjg0Yzc5N2Q=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-12T18:46:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-12T18:46:11Z"}, "message": "Rollup merge of #78857 - SkiFire13:bheap-opt, r=KodrAus\n\nImprove BinaryHeap performance\n\nBy changing the condition in the loops from `child < end` to `child < end - 1` we're guaranteed that `right = child + 1 < end` and since finding the index of the biggest sibling can be done with an arithmetic operation we can remove a branch from the loop body. The case where there's no right child, i.e. `child == end - 1` is instead handled outside the loop, after it ends; note that if the loops ends early we can use `return` instead of `break` since the check `child == end - 1` will surely fail.\n\nI've also removed a call to `<[T]>::swap` that was hiding a bound check that [wasn't being optimized by LLVM](https://godbolt.org/z/zrhdGM).\n\nA quick benchmarks on my pc shows that the gains are pretty significant:\n\n|name                 |before ns/iter  |after ns/iter  |diff ns/iter  |diff %    |speedup |\n|---------------------|----------------|---------------|--------------|----------|--------|\n|find_smallest_1000   | 352,565        | 260,098       |     -92,467  | -26.23%  | x 1.36 |\n|from_vec             | 676,795        | 473,934       |    -202,861  | -29.97%  | x 1.43 |\n|into_sorted_vec      | 469,511        | 304,275       |    -165,236  | -35.19%  | x 1.54 |\n|pop                  | 483,198        | 373,778       |    -109,420  | -22.64%  | x 1.29 |\n\nThe other 2 benchmarks for `BinaryHeap` (`peek_mut_deref_mut` and `push`) weren't impacted and as such didn't show any significant change.", "tree": {"sha": "b1d5fd0b6300b5ad4b1f03424d880df26dfbdc40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1d5fd0b6300b5ad4b1f03424d880df26dfbdc40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40889819ee8bf53aa880bace5ae472bdb84c797d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrYL0CRBK7hj4Ov3rIwAAdHIIAD5hcNtImQmpN1M4zF53PsmK\nVrkbgV7/yd3eQeNlhVS2ybPfSRXgKfpGe1JpYJc6eS+YMPRCd/iJrNpzAtxZI/6y\nJwL7MoyjiZPM9erWmsjqQL5nJ6AXQgro6gTakdtUzkQzgZnhx2bpve9sJhlV7k/x\nKpleWl3eXkP6m8I28J3fJ/kkZIplnb0fnJZzZCW7blUFS0dk7uG6pGb5JaKNGR9l\n4Z8bcDwxoq8LfRwT4gU7Er2WKQ8JsXrO8h1Od8GHmLV0QzRbQ6VYsqeiVVVSNlxl\nP+CCvGS2jhNkkEDWx6TFOeAb9p6FkwKzwk1kEoTcAol9XyKff3RtecR+i0NhWKU=\n=zJCf\n-----END PGP SIGNATURE-----\n", "payload": "tree b1d5fd0b6300b5ad4b1f03424d880df26dfbdc40\nparent 755dd14e00fd9007a67779b129e81b47c6435113\nparent 387568cd564317ca7491e6960ddcbe13beecae13\nauthor Mara Bos <m-ou.se@m-ou.se> 1605206771 +0100\ncommitter GitHub <noreply@github.com> 1605206771 +0100\n\nRollup merge of #78857 - SkiFire13:bheap-opt, r=KodrAus\n\nImprove BinaryHeap performance\n\nBy changing the condition in the loops from `child < end` to `child < end - 1` we're guaranteed that `right = child + 1 < end` and since finding the index of the biggest sibling can be done with an arithmetic operation we can remove a branch from the loop body. The case where there's no right child, i.e. `child == end - 1` is instead handled outside the loop, after it ends; note that if the loops ends early we can use `return` instead of `break` since the check `child == end - 1` will surely fail.\n\nI've also removed a call to `<[T]>::swap` that was hiding a bound check that [wasn't being optimized by LLVM](https://godbolt.org/z/zrhdGM).\n\nA quick benchmarks on my pc shows that the gains are pretty significant:\n\n|name                 |before ns/iter  |after ns/iter  |diff ns/iter  |diff %    |speedup |\n|---------------------|----------------|---------------|--------------|----------|--------|\n|find_smallest_1000   | 352,565        | 260,098       |     -92,467  | -26.23%  | x 1.36 |\n|from_vec             | 676,795        | 473,934       |    -202,861  | -29.97%  | x 1.43 |\n|into_sorted_vec      | 469,511        | 304,275       |    -165,236  | -35.19%  | x 1.54 |\n|pop                  | 483,198        | 373,778       |    -109,420  | -22.64%  | x 1.29 |\n\nThe other 2 benchmarks for `BinaryHeap` (`peek_mut_deref_mut` and `push`) weren't impacted and as such didn't show any significant change.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40889819ee8bf53aa880bace5ae472bdb84c797d", "html_url": "https://github.com/rust-lang/rust/commit/40889819ee8bf53aa880bace5ae472bdb84c797d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40889819ee8bf53aa880bace5ae472bdb84c797d/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755dd14e00fd9007a67779b129e81b47c6435113", "url": "https://api.github.com/repos/rust-lang/rust/commits/755dd14e00fd9007a67779b129e81b47c6435113", "html_url": "https://github.com/rust-lang/rust/commit/755dd14e00fd9007a67779b129e81b47c6435113"}, {"sha": "387568cd564317ca7491e6960ddcbe13beecae13", "url": "https://api.github.com/repos/rust-lang/rust/commits/387568cd564317ca7491e6960ddcbe13beecae13", "html_url": "https://github.com/rust-lang/rust/commit/387568cd564317ca7491e6960ddcbe13beecae13"}], "stats": {"total": 32, "additions": 19, "deletions": 13}, "files": [{"sha": "97ebc12175f73c6149a0b49189636b9d74cd2651", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/40889819ee8bf53aa880bace5ae472bdb84c797d/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40889819ee8bf53aa880bace5ae472bdb84c797d/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=40889819ee8bf53aa880bace5ae472bdb84c797d", "patch": "@@ -495,7 +495,14 @@ impl<T: Ord> BinaryHeap<T> {\n         let mut end = self.len();\n         while end > 1 {\n             end -= 1;\n-            self.data.swap(0, end);\n+            // SAFETY: `end` goes from `self.len() - 1` to 1 (both included),\n+            //  so it's always a valid index to access.\n+            //  It is safe to access index 0 (i.e. `ptr`), because\n+            //  1 <= end < self.len(), which means self.len() >= 2.\n+            unsafe {\n+                let ptr = self.data.as_mut_ptr();\n+                ptr::swap(ptr, ptr.add(end));\n+            }\n             self.sift_down_range(0, end);\n         }\n         self.into_vec()\n@@ -531,19 +538,19 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe {\n             let mut hole = Hole::new(&mut self.data, pos);\n             let mut child = 2 * pos + 1;\n-            while child < end {\n-                let right = child + 1;\n+            while child < end - 1 {\n                 // compare with the greater of the two children\n-                if right < end && hole.get(child) <= hole.get(right) {\n-                    child = right;\n-                }\n+                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n                 // if we are already in order, stop.\n                 if hole.element() >= hole.get(child) {\n-                    break;\n+                    return;\n                 }\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n+            if child == end - 1 && hole.element() < hole.get(child) {\n+                hole.move_to(child);\n+            }\n         }\n     }\n \n@@ -563,15 +570,14 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe {\n             let mut hole = Hole::new(&mut self.data, pos);\n             let mut child = 2 * pos + 1;\n-            while child < end {\n-                let right = child + 1;\n-                // compare with the greater of the two children\n-                if right < end && hole.get(child) <= hole.get(right) {\n-                    child = right;\n-                }\n+            while child < end - 1 {\n+                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n+            if child == end - 1 {\n+                hole.move_to(child);\n+            }\n             pos = hole.pos;\n         }\n         self.sift_up(start, pos);"}]}