{"sha": "c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "node_id": "C_kwDOAAsO6NoAKGM3NTgxN2IwYTc1ZDRiNmIwMWVlMTA5MDBiYTVkMDFkNDkxNWU2YTg", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-08-23T05:13:07Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-14T00:18:04Z"}, "message": "Better errors for implied static bound", "tree": {"sha": "ce26bd55c144205f49c53ef0b7b1e92480f37a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce26bd55c144205f49c53ef0b7b1e92480f37a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "html_url": "https://github.com/rust-lang/rust/commit/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff623ffc390aa124eff96d1f6a1d6e22c8e40af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff623ffc390aa124eff96d1f6a1d6e22c8e40af1", "html_url": "https://github.com/rust-lang/rust/commit/ff623ffc390aa124eff96d1f6a1d6e22c8e40af1"}], "stats": {"total": 444, "additions": 345, "deletions": 99}, "files": [{"sha": "1c01e78abd422ed097b440c49ce32bb56a54863b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -38,6 +38,7 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         span: Span,\n         region_name: RegionName,\n         opt_place_desc: Option<String>,\n+        extra_info: Vec<ExtraConstraintInfo>,\n     },\n     Unexplained,\n }\n@@ -243,6 +244,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 ref region_name,\n                 ref opt_place_desc,\n                 from_closure: _,\n+                ref extra_info,\n             } => {\n                 region_name.highlight_region_name(err);\n \n@@ -268,6 +270,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     );\n                 };\n \n+                for extra in extra_info {\n+                    match extra {\n+                        ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                        }\n+                    }\n+                }\n+\n                 self.add_lifetime_bound_suggestion_to_diagnostic(err, &category, span, region_name);\n             }\n             _ => {}\n@@ -309,16 +319,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n-        let BlameConstraint { category, from_closure, cause, variance_info: _ } = self\n-            .regioncx\n-            .best_blame_constraint(borrow_region, NllRegionVariableOrigin::FreeRegion, |r| {\n-                self.regioncx.provides_universal_region(r, borrow_region, outlived_region)\n-            });\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+        let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n+            borrow_region,\n+            NllRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+        let BlameConstraint { category, from_closure, cause, .. } = blame_constraint;\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, cause.span, outlived_fr_name)\n+        (category, from_closure, cause.span, outlived_fr_name, extra_info)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the\n@@ -390,7 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) =\n+                    let (category, from_closure, span, region_name, extra_info) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n@@ -400,6 +411,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             span,\n                             region_name,\n                             opt_place_desc,\n+                            extra_info,\n                         }\n                     } else {\n                         debug!(\"Could not generate a region name\");"}, {"sha": "c276719c227b011f91b8b4a3eb4e606541aa0011", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -354,10 +354,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n-            self.regioncx.best_blame_constraint(fr, fr_origin, |r| {\n+        let BlameConstraint { category, cause, variance_info, .. } = self\n+            .regioncx\n+            .best_blame_constraint(fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n-            });\n+            })\n+            .0;\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n "}, {"sha": "244e6e3422d83d0dcdee8ff0b7214727e530cb1c", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -245,6 +245,11 @@ enum Trace<'tcx> {\n     NotVisited,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum ExtraConstraintInfo {\n+    PlaceholderFromPredicate(Span),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -1818,10 +1823,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n-        let BlameConstraint { category, cause, .. } =\n-            self.best_blame_constraint(fr1, fr1_origin, |r| {\n-                self.provides_universal_region(r, fr1, fr2)\n-            });\n+        let BlameConstraint { category, cause, .. } = self\n+            .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n+            .0;\n         (category, cause)\n     }\n \n@@ -2010,7 +2014,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> BlameConstraint<'tcx> {\n+    ) -> (BlameConstraint<'tcx>, Vec<ExtraConstraintInfo>) {\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n@@ -2026,6 +2030,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n+        let mut extra_info = vec![];\n+        for constraint in path.iter() {\n+            let outlived = constraint.sub;\n+            let Some(origin) = self.var_infos.get(outlived) else { continue; };\n+            let RegionVariableOrigin::Nll(NllRegionVariableOrigin::Placeholder(p)) = origin.origin else { continue; };\n+            debug!(?constraint, ?p);\n+            let ConstraintCategory::Predicate(span) = constraint.category else { continue; };\n+            extra_info.push(ExtraConstraintInfo::PlaceholderFromPredicate(span));\n+            // We only want to point to one\n+            break;\n+        }\n+\n         // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n         // Instead, we use it to produce an improved `ObligationCauseCode`.\n         // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n@@ -2073,6 +2089,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     from_closure,\n                     cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n                     variance_info: constraint.variance_info,\n+                    outlives_constraint: *constraint,\n                 }\n             })\n             .collect();\n@@ -2174,7 +2191,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(?best_choice, ?blame_source);\n+        debug!(?best_choice, ?blame_source, ?extra_info);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2183,7 +2200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return next.clone();\n+                    return (next.clone(), extra_info);\n                 }\n             }\n \n@@ -2203,7 +2220,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            return categorized_path[i].clone();\n+            return (categorized_path[i].clone(), extra_info);\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -2213,7 +2230,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n-        categorized_path.remove(0)\n+        (categorized_path.remove(0), extra_info)\n     }\n \n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -2295,7 +2312,13 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             region, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(\n+                                region.into(),\n+                                outlived_region,\n+                            )),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n@@ -2305,7 +2328,10 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             ty, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n                 }\n             })\n@@ -2319,4 +2345,5 @@ pub struct BlameConstraint<'tcx> {\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+    pub outlives_constraint: OutlivesConstraint<'tcx>,\n }"}, {"sha": "8a3972a12c5431cfbe2a189e99185e088fe0daf7", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     #[instrument(skip(self, op), level = \"trace\")]\n-    pub(super) fn fully_perform_op<R, Op>(\n+    pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n@@ -39,6 +39,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n+        debug!(?output, ?constraints);\n+\n         if let Some(data) = constraints {\n             self.push_region_constraints(locations, category, data);\n         }"}, {"sha": "71eae0583cb483870b4a612d8442a36436602310", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -98,15 +98,18 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // region constraints like `for<'a> 'a: 'b`. At some point\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) = query_constraint.no_bound_vars().unwrap_or_else(|| {\n-            bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-        });\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n+            });\n+\n+        let constraint_category = query_constraint.1;\n \n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n-                self.add_outlives(r1_vid, r2_vid);\n+                self.add_outlives(r1_vid, r2_vid, constraint_category);\n             }\n \n             GenericArgKind::Type(t1) => {\n@@ -121,7 +124,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                     Some(implicit_region_bound),\n                     param_env,\n                 )\n-                .type_must_outlive(origin, t1, r2);\n+                .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n             GenericArgKind::Const(_) => {\n@@ -168,10 +171,19 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n+    fn add_outlives(\n+        &mut self,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        category: ConstraintCategory<'tcx>,\n+    ) {\n+        let category = match self.category {\n+            ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n+            _ => self.category,\n+        };\n         self.constraints.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n-            category: self.category,\n+            category,\n             span: self.span,\n             sub,\n             sup,\n@@ -191,10 +203,11 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n-        self.add_outlives(b, a);\n+        self.add_outlives(b, a, constraint_category);\n     }\n \n     fn push_verify("}, {"sha": "1143dd5489d9b9931a02eab3cf29cc5aeed5ddda", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -2560,7 +2560,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {\n                     let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n                             bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                         });\n "}, {"sha": "65371a285911e22f03a45c7cb8a1811b9593f63c", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -110,6 +110,7 @@ infer_relate_param_bound = ...so that the type `{$name}` will meet its required\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n infer_nothing = {\"\"}\n "}, {"sha": "56e83489879516f0659329050dfb4848fa218c40", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -22,6 +22,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -129,7 +130,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n                 region_constraints,\n             )\n         });\n@@ -248,6 +251,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n \n+        let constraint_category = cause.to_constraint_category();\n+\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n@@ -263,12 +268,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n+                            constraint_category,\n+                        ));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n+                            constraint_category,\n+                        ));\n                     }\n                 }\n \n@@ -314,7 +321,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,7 +566,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -574,7 +581,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n+        let predicate = predicate.0.rebind(atom).to_predicate(self.tcx);\n \n         Obligation::new(cause, param_env, predicate)\n     }\n@@ -625,7 +632,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -638,26 +645,31 @@ pub fn make_query_region_constraints<'tcx>(\n \n     let outlives: Vec<_> = constraints\n         .iter()\n-        .map(|(k, _)| match *k {\n-            // Swap regions because we are going from sub (<=) to outlives\n-            // (>=).\n-            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                tcx.mk_region(ty::ReVar(v2)).into(),\n-                tcx.mk_region(ty::ReVar(v1)),\n-            ),\n-            Constraint::VarSubReg(v1, r2) => {\n-                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-            }\n-            Constraint::RegSubVar(r1, v2) => {\n-                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-            }\n-            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        .map(|(k, origin)| {\n+            // no bound vars in the code above\n+            let constraint = ty::Binder::dummy(match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            });\n+            (constraint, origin.to_constraint_category())\n         })\n-        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n-                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-                .map(ty::Binder::dummy), // no bound vars in the code above\n+                // no bound vars in the code above\n+                .map(|(ty, r, constraint_category)| {\n+                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n+                }),\n         )\n         .collect();\n "}, {"sha": "adaa47c01402303a297990a385fb1910f0826a55", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -77,6 +77,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n         }\n     }\n \n@@ -356,6 +363,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 err\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n         }\n     }\n "}, {"sha": "efcb6c92998b0a8cce7013762aef963be195fbff", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -408,20 +409,36 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplItemObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n+    CompareImplItemObligation {\n+        span: Span,\n+        impl_item_def_id: LocalDefId,\n+        trait_item_def_id: DefId,\n+    },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n+impl<'tcx> SubregionOrigin<'tcx> {\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self {\n+            Self::Subtype(type_trace) => type_trace.cause.to_constraint_category(),\n+            Self::AscribeUserTypeProvePredicate(span) => ConstraintCategory::Predicate(*span),\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n+}\n+\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -1991,6 +2008,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,\n+            AscribeUserTypeProvePredicate(span) => span,\n             CheckAssociatedTypeBounds { ref parent, .. } => parent.span(),\n         }\n     }\n@@ -2023,6 +2041,10 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 parent: Box::new(default()),\n             },\n \n+            traits::ObligationCauseCode::AscribeUserTypeProvePredicate(span) => {\n+                SubregionOrigin::AscribeUserTypeProvePredicate(span)\n+            }\n+\n             _ => default(),\n         }\n     }"}, {"sha": "b65080e74c4fde65c467857ba73dc3ecc7e2bb80", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -69,6 +69,7 @@ use crate::infer::{\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n@@ -163,7 +164,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let outlives =\n                 &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-            outlives.type_must_outlive(origin, sup_type, sub_region);\n+            let category = origin.to_constraint_category();\n+            outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }\n     }\n \n@@ -207,6 +209,7 @@ pub trait TypeOutlivesDelegate<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     );\n \n     fn push_verify(\n@@ -255,25 +258,27 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];\n         push_outlives_components(self.tcx, ty, &mut components);\n-        self.components_must_outlive(origin, &components, region);\n+        self.components_must_outlive(origin, &components, region, category);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, *region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, *region1, category);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n@@ -282,7 +287,7 @@ where\n                     self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, &subcomponents, region);\n+                    self.components_must_outlive(origin, &subcomponents, region, category);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n@@ -392,10 +397,20 @@ where\n             for k in projection_ty.substs {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(lt) => {\n-                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n+                        self.delegate.push_sub_region_constraint(\n+                            origin.clone(),\n+                            region,\n+                            lt,\n+                            origin.to_constraint_category(),\n+                        );\n                     }\n                     GenericArgKind::Type(ty) => {\n-                        self.type_must_outlive(origin.clone(), ty, region);\n+                        self.type_must_outlive(\n+                            origin.clone(),\n+                            ty,\n+                            region,\n+                            origin.to_constraint_category(),\n+                        );\n                     }\n                     GenericArgKind::Const(_) => {\n                         // Const parameters don't impose constraints.\n@@ -433,7 +448,8 @@ where\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            self.delegate.push_sub_region_constraint(origin, region, unique_bound);\n+            let category = origin.to_constraint_category();\n+            self.delegate.push_sub_region_constraint(origin, region, unique_bound, category);\n             return;\n         }\n \n@@ -455,6 +471,7 @@ impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        _constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         self.sub_regions(origin, a, b)\n     }"}, {"sha": "e467ca13c8e50d21288f09ae79b4f241f4d1029d", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -22,6 +22,7 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::MemberConstraint;\n+use crate::mir::ConstraintCategory;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n use rustc_index::vec::IndexVec;\n@@ -290,8 +291,10 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+pub type QueryOutlivesConstraint<'tcx> = (\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n+    ConstraintCategory<'tcx>,\n+);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "d89efe2b3f024a68a19ab18cb42ea3fd57f94f2b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -327,7 +327,7 @@ rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n ///\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, Lift, TypeVisitable, TypeFoldable)]\n pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n@@ -369,7 +369,7 @@ pub enum ConstraintCategory<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(Field),"}, {"sha": "68a7af0b8c8d75669028135952d7f8e921431d45", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -10,6 +10,7 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n+use crate::mir::ConstraintCategory;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -183,6 +184,16 @@ impl<'tcx> ObligationCause<'tcx> {\n             variant(DerivedObligationCause { parent_trait_pred, parent_code: self.code }).into();\n         self\n     }\n+\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self.code() {\n+            MatchImpl(cause, _) => cause.to_constraint_category(),\n+            AscribeUserTypeProvePredicate(predicate_span) => {\n+                ConstraintCategory::Predicate(*predicate_span)\n+            }\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n@@ -418,6 +429,8 @@ pub enum ObligationCauseCode<'tcx> {\n         is_lit: bool,\n         output_ty: Option<Ty<'tcx>>,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "37f88016f6013aac9917bf1bc951a2be3e1944d0", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -3,7 +3,7 @@\n //! hand, though we've recently added some macros and proc-macros to help with the tedium.\n \n use crate::mir::interpret;\n-use crate::mir::ProjectionKind;\n+use crate::mir::{Field, ProjectionKind};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -648,6 +648,20 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     }\n }\n \n+impl<'tcx> Lift<'tcx> for Field {\n+    type Lifted = Field;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some(self)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for crate::mir::ReturnConstraint {\n+    type Lifted = crate::mir::ReturnConstraint;\n+    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some(self)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n "}, {"sha": "99c5ab6aacd678256838eb131b8b109f358e8610", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -2256,7 +2256,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::QuestionMark\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n-            | ObligationCauseCode::BinOp { .. } => {}\n+            | ObligationCauseCode::BinOp { .. }\n+            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "18988861add136646170b71408ee69b9efc297e0", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -23,7 +23,7 @@ impl<F, G> CustomTypeOp<F, G> {\n     }\n }\n \n-impl<'tcx, F, R, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n     F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n@@ -89,8 +89,8 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         infcx.tcx,\n         region_obligations\n             .iter()\n-            .map(|r_o| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n+            .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category()))\n+            .map(|(ty, r, cc)| (infcx.resolve_vars_if_possible(ty), r, cc)),\n         &region_constraint_data,\n     );\n "}, {"sha": "8a79165702ca3f6f52252063db779268241c0a9b", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -26,7 +26,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n-    type Output;\n+    type Output: fmt::Debug;\n     type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,"}, {"sha": "1a63f853211ed77ba87a71df5abbaec89a6c22f4", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n+use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n@@ -22,6 +22,7 @@ use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n+use std::iter::zip;\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -61,14 +62,15 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         mir_ty, def_id, user_substs\n     );\n \n-    let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs, span)?;\n+    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    span: Span,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n@@ -79,7 +81,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n     {\n         self.infcx\n             .partially_normalize_associated_types_in(\n-                ObligationCause::misc(DUMMY_SP, hir::CRATE_HIR_ID),\n+                ObligationCause::misc(self.span, hir::CRATE_HIR_ID),\n                 self.param_env,\n                 value,\n             )\n@@ -91,18 +93,13 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         T: ToTrace<'tcx>,\n     {\n         self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n+            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n             .relate(a, variance, b)?\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, span: Option<Span>) {\n-        let cause = if let Some(span) = span {\n-            ObligationCause::dummy_with_span(span)\n-        } else {\n-            ObligationCause::dummy()\n-        };\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n             Obligation::new(cause, self.param_env, predicate),\n@@ -126,7 +123,6 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n-        span: Option<Span>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n@@ -145,10 +141,20 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+        let cause = ObligationCause::dummy_with_span(self.span);\n+\n         debug!(?instantiated_predicates);\n-        for instantiated_predicate in instantiated_predicates.predicates {\n-            let instantiated_predicate = self.normalize(instantiated_predicate);\n-            self.prove_predicate(instantiated_predicate, span);\n+        for (instantiated_predicate, predicate_span) in\n+            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+        {\n+            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n+            let cause = ObligationCause::new(\n+                span,\n+                hir::CRATE_HIR_ID,\n+                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+            );\n+            self.prove_predicate(instantiated_predicate, cause);\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n@@ -161,7 +167,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n                     .to_predicate(self.tcx()),\n-                span,\n+                cause.clone(),\n             );\n         }\n \n@@ -178,7 +184,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // which...could happen with normalization...\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n-            span,\n+            cause,\n         );\n         Ok(())\n     }"}, {"sha": "27b3da8ab3dfa7af14518069da365100021c6b7a", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -663,7 +664,7 @@ fn ty_known_to_outlive<'tcx>(\n     resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n         let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(infcx, tcx, region_bound_pairs, None, param_env);\n-        outlives.type_must_outlive(origin, ty, region);\n+        outlives.type_must_outlive(origin, ty, region, ConstraintCategory::BoringNoLocation);\n     })\n }\n \n@@ -681,7 +682,12 @@ fn region_known_to_outlive<'tcx>(\n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n         let origin = infer::RelateRegionParamBound(DUMMY_SP);\n         // `region_a: region_b` -> `region_b <= region_a`\n-        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+        infcx.push_sub_region_constraint(\n+            origin,\n+            region_b,\n+            region_a,\n+            ConstraintCategory::BoringNoLocation,\n+        );\n     })\n }\n "}, {"sha": "719d1bd5a4c7dabf518cdb41e5718b511632d482", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -0,0 +1,35 @@\n+// check-fail\n+// known-bug\n+\n+// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n+// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n+\n+use std::fmt::Debug;\n+\n+pub trait LendingIterator {\n+    type Item<'this>\n+    where\n+        Self: 'this;\n+}\n+\n+pub struct WindowsMut<'x> {\n+    slice: &'x (),\n+}\n+\n+impl<'y> LendingIterator for WindowsMut<'y> {\n+    type Item<'this> = &'this mut () where 'y: 'this;\n+}\n+\n+fn print_items<I>(_iter: I)\n+where\n+    I: LendingIterator,\n+    for<'a> I::Item<'a>: Debug,\n+{\n+}\n+\n+fn main() {\n+    let slice = &mut ();\n+    //~^ temporary value dropped while borrowed\n+    let windows = WindowsMut { slice };\n+    print_items::<WindowsMut<'_>>(windows);\n+}"}, {"sha": "414999881d4701cb5ab2a7e72b72e86ad1e7934a", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -0,0 +1,20 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/hrtb-implied-1.rs:31:22\n+   |\n+LL |     let slice = &mut ();\n+   |                      ^^ creates a temporary which is freed while still in use\n+...\n+LL |     print_items::<WindowsMut<'_>>(windows);\n+   |     -------------------------------------- argument requires that borrow lasts for `'static`\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-implied-1.rs:26:26\n+   |\n+LL |     for<'a> I::Item<'a>: Debug,\n+   |                          ^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "f5c10f3ddea0ea0686342e06ab87b16a6b4d63fb", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c75817b0a75d4b6b01ee10900ba5d01d4915e6a8/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr?ref=c75817b0a75d4b6b01ee10900ba5d01d4915e6a8", "patch": "@@ -9,6 +9,12 @@ LL |     assert_static_via_hrtb(&local);\n LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:15:53\n+   |\n+LL | fn assert_static_via_hrtb<G>(_: G) where for<'a> G: Outlives<'a> {}\n+   |                                                     ^^^^^^^^^^^^\n \n error[E0597]: `local` does not live long enough\n   --> $DIR/local-outlives-static-via-hrtb.rs:25:45\n@@ -20,6 +26,12 @@ LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n    |     argument requires that `local` is borrowed for `'static`\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:19:20\n+   |\n+LL |     for<'a> &'a T: Reference<AssociatedType = &'a ()>,\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}