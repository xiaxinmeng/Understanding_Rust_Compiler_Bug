{"sha": "86f337484eeabb5e74060d3549974b3bd85e7f3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZjMzNzQ4NGVlYWJiNWU3NDA2MGQzNTQ5OTc0YjNiZDg1ZTdmM2I=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-28T00:36:37Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-28T19:12:08Z"}, "message": "Change macro syntax to accept a single expr, not a sequence of exprs.", "tree": {"sha": "0685f587648b05ad133da83132d40fb85411437e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0685f587648b05ad133da83132d40fb85411437e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86f337484eeabb5e74060d3549974b3bd85e7f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86f337484eeabb5e74060d3549974b3bd85e7f3b", "html_url": "https://github.com/rust-lang/rust/commit/86f337484eeabb5e74060d3549974b3bd85e7f3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86f337484eeabb5e74060d3549974b3bd85e7f3b/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7016ae9575a36fd96ec264274bbe0c660a7758", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7016ae9575a36fd96ec264274bbe0c660a7758", "html_url": "https://github.com/rust-lang/rust/commit/3d7016ae9575a36fd96ec264274bbe0c660a7758"}], "stats": {"total": 158, "additions": 80, "deletions": 78}, "files": [{"sha": "e09be2b3f335285a3eb567b44e41ee48b44a0f24", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -333,7 +333,7 @@ tag expr_ {\n type mac = spanned[mac_];\n \n tag mac_ {\n-    mac_invoc(path, (@expr)[], option::t[str]);\n+    mac_invoc(path, @expr, option::t[str]);\n     mac_embed_type(@ty);\n     mac_embed_block(blk);\n     mac_ellipsis;"}, {"sha": "b83a03c4343dd4a8efef302113ec93cf39e3a2fb", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -7,10 +7,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn(&ext_ctxt, span, &(@ast::expr)[], option::t[str]) -> @ast::expr ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t[str]) -> @ast::expr ;\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn(&ext_ctxt, span, &(@ast::expr)[], option::t[str]) -> macro_def ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t[str]) -> macro_def ;\n \n tag syntax_extension {\n     normal(syntax_expander);"}, {"sha": "c6fe7237d2a02ab22b5fadf5008ebb1bd622252f", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -12,8 +12,12 @@ import std::generic_os;\n import base::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, args: &(@ast::expr)[],\n+fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n+    let args: (@ast::expr)[] = alt arg.node {\n+      ast::expr_vec(elts, _, _) { elts }\n+      _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n+    };\n     if ivec::len[@ast::expr](args) != 1u {\n         cx.span_fatal(sp, \"malformed #env call\");\n     }"}, {"sha": "10281a9934d49ff781bb9b412feee7c44d979dc2", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -16,8 +16,12 @@ import base::*;\n import codemap::span;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: span, args: &(@ast::expr)[],\n+fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n                      body: option::t[str]) -> @ast::expr {\n+    let args: (@ast::expr)[] = alt arg.node {\n+      ast::expr_vec(elts, _, _) { elts }\n+      _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }\n+    };\n     if ivec::len[@ast::expr](args) == 0u {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }"}, {"sha": "4fa169545e25476d314b96320e26230fd4e1c7f7", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -42,7 +42,7 @@ fn path_to_ident(pth: &path) -> option::t[ident] {\n }\n \n //an ivec of binders might be a little big.\n-type clause = {params: binders[], body: @expr};\n+type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n tag arb_depth[T] { leaf(T); seq(vec[arb_depth[T]], span); }\n@@ -107,6 +107,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &(@expr)[]) -> option::t[@expr] {\n                 }\n                 ret some(elts.(0));\n               }\n+              _ { }\n             }\n           }\n           _ { }\n@@ -179,19 +180,19 @@ selectors. */\n \n fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t[bindings] {\n     let res = new_str_hash[arb_depth[matchable]]();\n+    //need to do this first, to check vec lengths.\n+    for sel: selector  in b.literal_ast_matchers {\n+        alt sel(match_expr(e)) { none. { ret none; } _ { } }\n+    }\n     let never_mind: bool = false;\n     for each pair: @{key: ident, val: selector}  in b.real_binders.items() {\n         alt pair.val(match_expr(e)) {\n           none. { never_mind = true; }\n           some(mtc) { res.insert(pair.key, mtc); }\n         }\n     }\n-    if never_mind {\n-        ret none; //HACK: `ret` doesn't work in `for each`\n-    }\n-    for sel: selector  in b.literal_ast_matchers {\n-        alt sel(match_expr(e)) { none. { ret none; } _ { } }\n-    }\n+    //HACK: `ret` doesn't work in `for each`\n+    if never_mind { ret none; }\n     ret some(res);\n }\n \n@@ -537,8 +538,8 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                           _ { none }\n                         }\n                 }\n-                b.real_binders.insert(id,\n-                                      bind select_pt_1(cx, _, select_pt_2));\n+                let final_step = bind select_pt_1(cx, _, select_pt_2);\n+                b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n               none. { no_des(cx, pth.span, \"under `#<>`\"); }\n             }\n@@ -557,7 +558,8 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                       _ { none }\n                     }\n             }\n-            b.real_binders.insert(id, bind select_pt_1(cx, _, select_pt_2));\n+            let final_step = bind select_pt_1(cx, _, select_pt_2);\n+            b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n           none. { no_des(cx, blk.span, \"under `#{}`\"); }\n         }\n@@ -576,7 +578,7 @@ fn ivec_to_vec[T](v: &T[]) -> vec[T] {\n fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, s: &selector,\n                     b: &binders) {\n     fn select(cx: &ext_ctxt, repeat_me: @expr, m: &matchable) ->\n-       match_result {\n+        match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n@@ -640,8 +642,15 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], s: &selector,\n     }\n }\n \n-fn add_new_extension(cx: &ext_ctxt, sp: span, args: &(@expr)[],\n+fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                      body: option::t[str]) -> base::macro_def {\n+    let args: (@ast::expr)[] = alt arg.node {\n+      ast::expr_vec(elts, _, _) { elts }\n+      _ {\n+        cx.span_fatal(sp, \"#macro requires arguments of the form `[...]`.\")\n+      }\n+    };\n+\n     let macro_name: option::t[str] = none;\n     let clauses: clause[] = ~[];\n     for arg: @expr  in args {\n@@ -657,19 +666,16 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, args: &(@expr)[],\n             alt elts.(0u).node {\n               expr_mac(mac) {\n                 alt mac.node {\n-                  mac_invoc(pth, invoc_args, body) {\n+                  mac_invoc(pth, invoc_arg, body) {\n                     alt path_to_ident(pth) {\n                       some(id) { macro_name = some(id); }\n                       none. {\n                         cx.span_fatal(pth.span,\n-                                      \"macro name \" + \"must not be a path\");\n+                                      \"macro name must not be a path\");\n                       }\n                     }\n-                    let bdrses = ~[];\n-                    for arg: @expr  in invoc_args {\n-                        bdrses += ~[pattern_to_selectors(cx, arg)];\n-                    }\n-                    clauses += ~[{params: bdrses, body: elts.(1u)}];\n+                    clauses += ~[{params: pattern_to_selectors(cx, invoc_arg),\n+                                  body: elts.(1u)}];\n                     // FIXME: check duplicates (or just simplify\n                     // the macro arg situation)\n                   }\n@@ -702,32 +708,15 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, args: &(@expr)[],\n              },\n          ext: normal(ext)};\n \n-\n-    fn generic_extension(cx: &ext_ctxt, sp: span, args: &(@expr)[],\n+    fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n                          body: option::t[str], clauses: clause[]) -> @expr {\n-\n-\n         for c: clause  in clauses {\n-            if ivec::len(args) != ivec::len(c.params) { cont; }\n-            let i: uint = 0u;\n-            let bdgs: bindings = new_str_hash[arb_depth[matchable]]();\n-            let abort: bool = false;\n-            while i < ivec::len(args) {\n-                alt use_selectors_to_bind(c.params.(i), args.(i)) {\n-                  some(new_bindings) {\n-\n-                    /* ick; I wish macros just took one expr */\n-                    for each it: @{key: ident, val: arb_depth[matchable]}  in\n-                             new_bindings.items() {\n-                        bdgs.insert(it.key, it.val);\n-                    }\n-                  }\n-                  none. { abort = true; }\n-                }\n-                i += 1u;\n+            alt use_selectors_to_bind(c.params, arg) {\n+              some(bindings) {\n+                ret transcribe(cx, bindings, c.body)\n+              }\n+              none. { cont; }\n             }\n-            if abort { cont; }\n-            ret transcribe(cx, bdgs, c.body);\n         }\n         cx.span_fatal(sp, \"no clauses match macro invocation\");\n     }"}, {"sha": "57b9ca78ff6f8b32806214c9fb4b5b5d603d90fe", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -130,15 +130,14 @@ fn fold_arg_(a: &arg, fld: ast_fold) -> arg {\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: &mac, fld: ast_fold) -> mac {\n     ret {node:\n-             alt m.node {\n-               mac_invoc(pth, args, body) {\n-                 mac_invoc(fld.fold_path(pth),\n-                           fld.map_exprs(fld.fold_expr, args), body)\n-               }\n-               mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n-               mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n-               mac_ellipsis. { mac_ellipsis }\n-             },\n+         alt m.node {\n+           mac_invoc(pth, arg, body) {\n+             mac_invoc(fld.fold_path(pth), fld.fold_expr(arg), body)\n+           }\n+           mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n+           mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n+           mac_ellipsis. { mac_ellipsis }\n+         },\n          span: m.span};\n }\n "}, {"sha": "e24a51270741f4168ecb28031504fbc54fbc2921", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -1021,11 +1021,18 @@ fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n     if ivec::len(pth.node.idents) == 0u {\n         p.fatal(\"expected a syntax expander name\");\n     }\n-    let es =\n+    //temporary for a backwards-compatible cycle:\n+    let es = if p.peek() == token::LPAREN {\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                  parse_expr, p);\n+                  parse_expr, p)\n+    } else {\n+        parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n+                  parse_expr, p)\n+    };\n     let hi = es.span.hi;\n-    ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, es.node, none));\n+    let e = mk_expr(p, es.span.lo, hi,\n+                    ast::expr_vec(es.node, ast::imm, ast::sk_rc));\n+    ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, e, none));\n }\n \n fn parse_self_method(p: &parser) -> @ast::expr {"}, {"sha": "0b76f3c27ddb19284ff2652c815e29eff79cd094", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -642,16 +642,15 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n \n fn print_mac(s: &ps, m: &ast::mac) {\n     alt m.node {\n-      ast::mac_invoc(path, args, body) {\n+      ast::mac_invoc(path, arg, body) {\n         word(s.s, \"#\");\n         print_path(s, path);\n-        if ivec::len(args) > 0u {\n-            popen(s);\n-            commasep_exprs(s, inconsistent, args);\n-            pclose(s);\n+        alt (arg.node) {\n+          ast::expr_vec(_,_,_) {}\n+          _ { word(s.s, \" \"); }\n         }\n+        print_expr(s, arg);\n         // FIXME: extension 'body'\n-\n       }\n       ast::mac_embed_type(ty) {\n         word(s.s, \"#<\");"}, {"sha": "2b42cfa5651ef11a9273319201bd9e89954892cd", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -239,7 +239,7 @@ fn visit_exprs[E](exprs: &(@expr)[], e: &E, v: &vt[E]) {\n \n fn visit_mac[E](m: mac, e: &E, v: &vt[E]) {\n     alt m.node {\n-      ast::mac_invoc(pth, args, body) { visit_exprs(args, e, v); }\n+      ast::mac_invoc(pth, arg, body) { visit_expr(arg, e, v); }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n       ast::mac_embed_block(blk) { v.visit_block(blk, e, v); }\n       ast::mac_ellipsis. { }"}, {"sha": "30dbaa058585e35a94e8da78b8a5f2502dbcd1af", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -262,7 +262,7 @@ fn walk_exprs(v: &ast_visitor, exprs: &(@ast::expr)[]) {\n \n fn walk_mac(v: &ast_visitor, mac: ast::mac) {\n     alt mac.node {\n-      ast::mac_invoc(pth, args, body) { walk_exprs(v, args); }\n+      ast::mac_invoc(pth, arg, body) { walk_expr(v, arg); }\n       ast::mac_embed_type(ty) { walk_ty(v, ty); }\n       ast::mac_embed_block(blk) { walk_block(v, blk); }\n       ast::mac_ellipsis. { }"}, {"sha": "5fde2f49e18da521c84ffe6be0bdf6c93baa7754", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f337484eeabb5e74060d3549974b3bd85e7f3b/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=86f337484eeabb5e74060d3549974b3bd85e7f3b", "patch": "@@ -1,34 +1,34 @@\n fn main() {\n-    #macro([#zip_or_unzip([[x, ...], [y, ...]]), [[x, y], ...]],\n-           [#zip_or_unzip([[xx, yy], ...]), [[xx, ...], [yy, ...]]]);\n+    #macro([#zip_or_unzip[[x, ...], [y, ...]], [[x, y], ...]],\n+           [#zip_or_unzip[[xx, yy], ...], [[xx, ...], [yy, ...]]]);\n \n \n-    assert (#zip_or_unzip([[1, 2, 3, 4], [5, 6, 7, 8]]) ==\n+    assert (#zip_or_unzip[[1, 2, 3, 4], [5, 6, 7, 8]] ==\n                 [[1, 5], [2, 6], [3, 7], [4, 8]]);\n-    assert (#zip_or_unzip([[1, 5], [2, 6], [3, 7], [4, 8]]) ==\n+    assert (#zip_or_unzip[[1, 5], [2, 6], [3, 7], [4, 8]] ==\n                 [[1, 2, 3, 4], [5, 6, 7, 8]]);\n \n \n-    #macro([#nested([[[x, ...], ...], [[y, ...], ...]]),\n+    #macro([#nested[[[x, ...], ...], [[y, ...], ...]],\n             [[[x, y], ...], ...]]);\n-    assert (#nested([[[1, 2, 3, 4, 5], [7, 8, 9, 10, 11, 12]],\n-                     [[-1, -2, -3, -4, -5], [-7, -8, -9, -10, -11, -12]]]) ==\n+    assert (#nested[[[1, 2, 3, 4, 5], [7, 8, 9, 10, 11, 12]],\n+                    [[-1, -2, -3, -4, -5], [-7, -8, -9, -10, -11, -12]]] ==\n                 [[[1, -1], [2, -2], [3, -3], [4, -4], [5, -5]],\n                  [[7, -7], [8, -8], [9, -9], [10, -10], [11, -11],\n                   [12, -12]]]);\n \n-    #macro([#dup([y, [x, ...]]), [[y, x], ...]]);\n+    #macro([#dup[y, [x, ...]], [[y, x], ...]]);\n \n-    assert (#dup([1, [1, 2, 3, 4]]) == [[1, 1], [1, 2], [1, 3], [1, 4]]);\n+    assert (#dup[1, [1, 2, 3, 4]] == [[1, 1], [1, 2], [1, 3], [1, 4]]);\n \n \n-    #macro([#lambda(x, #<t>, body, #<s>),\n+    #macro([#lambda[x, #<t>, body, #<s>],\n             {\n                 fn result(x: t) -> s { ret body }\n                 result\n             }]);\n \n \n-    assert (#lambda(i, #<uint>, i + 4u, #<uint>)(12u) == 16u)\n+    assert ((#lambda[i, #<uint>, i + 4u, #<uint>])(12u) == 16u)\n \n }\n\\ No newline at end of file"}]}