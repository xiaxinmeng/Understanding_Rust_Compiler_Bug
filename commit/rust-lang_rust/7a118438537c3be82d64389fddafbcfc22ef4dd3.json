{"sha": "7a118438537c3be82d64389fddafbcfc22ef4dd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMTE4NDM4NTM3YzNiZTgyZDY0Mzg5ZmRkYWZiY2ZjMjJlZjRkZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-23T10:23:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-23T10:23:52Z"}, "message": "Auto merge of #4439 - lzutao:fix-format, r=phansch\n\nRe-factor format lint\n\ncc #4432\n\nchangelog: none", "tree": {"sha": "c6212542792d7d8ac03fc4a9f745a45248c8cc0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6212542792d7d8ac03fc4a9f745a45248c8cc0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a118438537c3be82d64389fddafbcfc22ef4dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a118438537c3be82d64389fddafbcfc22ef4dd3", "html_url": "https://github.com/rust-lang/rust/commit/7a118438537c3be82d64389fddafbcfc22ef4dd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a118438537c3be82d64389fddafbcfc22ef4dd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e4aa666b3f75821b778f283478fe1e8ddee35fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4aa666b3f75821b778f283478fe1e8ddee35fb", "html_url": "https://github.com/rust-lang/rust/commit/6e4aa666b3f75821b778f283478fe1e8ddee35fb"}, {"sha": "ab335eacb4ac87c30907fc536c509c70c66c8d8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab335eacb4ac87c30907fc536c509c70c66c8d8f", "html_url": "https://github.com/rust-lang/rust/commit/ab335eacb4ac87c30907fc536c509c70c66c8d8f"}], "stats": {"total": 245, "additions": 141, "deletions": 104}, "files": [{"sha": "1df6b9294d7b304f169f1445bc3624cd15c66223", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 98, "deletions": 90, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -5,7 +5,6 @@ use crate::utils::{\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n@@ -38,56 +37,16 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let Some(span) = is_expn_of(expr.span, \"format\") {\n-            if span.from_expansion() {\n-                return;\n-            }\n-            match expr.node {\n-                // `format!(\"{}\", foo)` expansion\n-                ExprKind::Call(ref fun, ref args) => {\n-                    if_chain! {\n-                        if let ExprKind::Path(ref qpath) = fun.node;\n-                        if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-                        let new_v1 = match_def_path(cx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        let new_v1_fmt = match_def_path(cx,\n-                            fun_def_id,\n-                            &paths::FMT_ARGUMENTS_NEWV1FORMATTED\n-                        );\n-                        if new_v1 || new_v1_fmt;\n-                        if check_single_piece(&args[0]);\n-                        if let Some(format_arg) = get_single_string_arg(cx, &args[1]);\n-                        if new_v1 || check_unformatted(&args[2]);\n-                        if let ExprKind::AddrOf(_, ref format_arg) = format_arg.node;\n-                        then {\n-                            let (message, sugg) = if_chain! {\n-                                if let ExprKind::MethodCall(ref path, _, _) = format_arg.node;\n-                                if path.ident.as_interned_str().as_symbol() == sym!(to_string);\n-                                then {\n-                                    (\"`to_string()` is enough\",\n-                                    snippet(cx, format_arg.span, \"<arg>\").to_string())\n-                                } else {\n-                                    (\"consider using .to_string()\",\n-                                    format!(\"{}.to_string()\", snippet(cx, format_arg.span, \"<arg>\")))\n-                                }\n-                            };\n+        let span = match is_expn_of(expr.span, \"format\") {\n+            Some(s) if !s.from_expansion() => s,\n+            _ => return,\n+        };\n \n-                            span_useless_format(cx, span, message, sugg);\n-                        }\n-                    }\n-                },\n-                // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprKind::Match(ref matchee, _, _) => {\n-                    if let ExprKind::Tup(ref tup) = matchee.node {\n-                        if tup.is_empty() {\n-                            let actual_snippet = snippet(cx, expr.span, \"<expr>\").to_string();\n-                            let actual_snippet = actual_snippet.replace(\"{{}}\", \"{}\");\n-                            let sugg = format!(\"{}.to_string()\", actual_snippet);\n-                            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n-                        }\n-                    }\n-                },\n-                _ => (),\n-            }\n+        // Operate on the only argument of `alloc::fmt::format`.\n+        if let Some(sugg) = on_new_v1(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n+        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n         }\n     }\n }\n@@ -111,56 +70,102 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-/// Checks if the expressions matches `&[\"\"]`\n-fn check_single_piece(expr: &Expr) -> bool {\n+fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'a [Arm]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n-        if exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = exprs[0].node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n+        if let ExprKind::AddrOf(_, ref format_args) = expr.node;\n+        if let ExprKind::Array(ref elems) = arms[0].body.node;\n+        if elems.len() == 1;\n+        if let ExprKind::Call(ref fun, ref args) = elems[0].node;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTV1_NEW);\n+        // matches `core::fmt::Display::fmt`\n+        if args.len() == 2;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n+        if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n+        if arms[0].pats.len() == 1;\n+        // check `(arg0,)` in match block\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pats[0].node;\n+        if pats.len() == 1;\n         then {\n-            return lit.as_str().is_empty();\n+            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));\n+            if ty.sty != rustc::ty::Str && !match_type(cx, ty, &paths::STRING) {\n+                return None;\n+            }\n+            if let ExprKind::Lit(ref lit) = format_args.node {\n+                if let LitKind::Str(ref s, _) = lit.node {\n+                    return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+                }\n+            } else {\n+                let snip = snippet(cx, format_args.span, \"<arg>\");\n+                if let ExprKind::MethodCall(ref path, _, _) = format_args.node {\n+                    if path.ident.name == sym!(to_string) {\n+                        return Some(format!(\"{}\", snip));\n+                    }\n+                } else if let ExprKind::Binary(..) = format_args.node {\n+                    return Some(format!(\"{}\", snip));\n+                }\n+                return Some(format!(\"{}.to_string()\", snip));\n+            }\n         }\n     }\n-\n-    false\n+    None\n }\n \n-/// Checks if the expressions matches\n-/// ```rust,ignore\n-/// &match (&\"arg\",) {\n-/// (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0,\n-/// ::std::fmt::Display::fmt)],\n-/// }\n-/// ```\n-/// and that the type of `__arg0` is `&str` or `String`,\n-/// then returns the span of first element of the matched tuple.\n-fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n+fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n-        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n-        if arms.len() == 1;\n-        if arms[0].pats.len() == 1;\n-        if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n-        if pat.len() == 1;\n-        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n-        if exprs.len() == 1;\n-        if let ExprKind::Call(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].node;\n-        if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1);\n+        // Argument 1 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(ref s, _) = lit.node;\n+        // Argument 2 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-            if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {\n-                if let ExprKind::Tup(ref values) = match_expr.node {\n-                    return Some(&values[0]);\n-                }\n+            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n+            if tup.is_empty() {\n+                return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+            } else if s.as_str().is_empty() {\n+                return on_argumentv1_new(cx, &tup[0], arms);\n             }\n         }\n     }\n+    None\n+}\n \n+fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n+        if args.len() == 3;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n+        if check_unformatted(&args[2]);\n+        // Argument 1 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(..) = lit.node;\n+        // Argument 2 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n+        then {\n+            return on_argumentv1_new(cx, &tup[0], arms);\n+        }\n+    }\n     None\n }\n \n@@ -169,6 +174,7 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n /// &[_ {\n ///    format: _ {\n ///         width: _::Implied,\n+///         precision: _::Implied,\n ///         ...\n ///    },\n ///    ...,\n@@ -179,15 +185,17 @@ fn check_unformatted(expr: &Expr) -> bool {\n         if let ExprKind::AddrOf(_, ref expr) = expr.node;\n         if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n+        // struct `core::fmt::rt::v1::Argument`\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n-        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.node;\n         if last_path_segment(precision_path).ident.name == sym!(Implied);\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n+        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         then {\n             return true;\n         }"}, {"sha": "55e1387fe99eb3e2459112802303fb44a5e4d149", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -27,8 +27,9 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n-pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEWV1FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];"}, {"sha": "b7a6e486f0bfba4d7d7863fd7e6cd9494f84be21", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -1879,7 +1879,7 @@ pub const ALL_LINTS: [Lint; 311] = [\n     Lint {\n         name: \"unicode_not_nfc\",\n         group: \"pedantic\",\n-        desc: \"using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\",\n+        desc: \"using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\",\n         deprecation: None,\n         module: \"unicode\",\n     },"}, {"sha": "6e100230a3ad338626ef7d2ab2b35e0a881a520f", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -13,6 +13,7 @@ fn main() {\n     \"foo\".to_string();\n     \"{}\".to_string();\n     \"{} abc {}\".to_string();\n+    \"foo {}\\n\\\" bar\".to_string();\n \n     \"foo\".to_string();\n     format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n@@ -59,4 +60,8 @@ fn main() {\n     42.to_string();\n     let x = std::path::PathBuf::from(\"/bar/foo/qux\");\n     x.display().to_string();\n+\n+    // False positive\n+    let a = \"foo\".to_string();\n+    let _ = Some(a + \"bar\");\n }"}, {"sha": "1fae6603ac099debbc7b1509f635da5fa7997f5a", "filename": "tests/ui/format.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -13,6 +13,10 @@ fn main() {\n     format!(\"foo\");\n     format!(\"{{}}\");\n     format!(\"{{}} abc {{}}\");\n+    format!(\n+        r##\"foo {{}}\n+\" bar\"##\n+    );\n \n     format!(\"{}\", \"foo\");\n     format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n@@ -59,4 +63,8 @@ fn main() {\n     format!(\"{}\", 42.to_string());\n     let x = std::path::PathBuf::from(\"/bar/foo/qux\");\n     format!(\"{}\", x.display().to_string());\n+\n+    // False positive\n+    let a = \"foo\".to_string();\n+    let _ = Some(format!(\"{}\", a + \"bar\"));\n }"}, {"sha": "9736f34b03b4a86d6c78c58a05dc9559a902e0b4", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a118438537c3be82d64389fddafbcfc22ef4dd3/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=7a118438537c3be82d64389fddafbcfc22ef4dd3", "patch": "@@ -19,52 +19,67 @@ LL |     format!(\"{{}} abc {{}}\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"{} abc {}\".to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:17:5\n+  --> $DIR/format.rs:16:5\n+   |\n+LL | /     format!(\n+LL | |         r##\"foo {{}}\n+LL | | \" bar\"##\n+LL | |     );\n+   | |______^ help: consider using .to_string(): `\"foo {}/n/\" bar\".to_string();`\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:21:5\n    |\n LL |     format!(\"{}\", \"foo\");\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:21:5\n+  --> $DIR/format.rs:25:5\n    |\n LL |     format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:22:5\n+  --> $DIR/format.rs:26:5\n    |\n LL |     format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:27:5\n+  --> $DIR/format.rs:31:5\n    |\n LL |     format!(\"{}\", arg);\n    |     ^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:31:5\n+  --> $DIR/format.rs:35:5\n    |\n LL |     format!(\"{:+}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:32:5\n+  --> $DIR/format.rs:36:5\n    |\n LL |     format!(\"{:<}\", arg); // Warn when the format makes no difference.\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:59:5\n+  --> $DIR/format.rs:63:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `42.to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `42.to_string();`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:61:5\n+  --> $DIR/format.rs:65:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `x.display().to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `x.display().to_string();`\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:69:18\n+   |\n+LL |     let _ = Some(format!(\"{}\", a + \"bar\"));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `a + \"bar\"`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 13 previous errors\n "}]}