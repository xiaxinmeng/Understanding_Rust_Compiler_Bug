{"sha": "d4e986c1f0c41951a61d35e198e0f45586b1894d", "node_id": "C_kwDOAAsO6NoAKGQ0ZTk4NmMxZjBjNDE5NTFhNjFkMzVlMTk4ZTBmNDU1ODZiMTg5NGQ", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-08T09:04:52Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-15T13:32:43Z"}, "message": "derive various Lift impl instead of hand rolling them", "tree": {"sha": "b18f7bd68a80539feecbaf9c32a76ce1949864cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b18f7bd68a80539feecbaf9c32a76ce1949864cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4e986c1f0c41951a61d35e198e0f45586b1894d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e986c1f0c41951a61d35e198e0f45586b1894d", "html_url": "https://github.com/rust-lang/rust/commit/d4e986c1f0c41951a61d35e198e0f45586b1894d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4e986c1f0c41951a61d35e198e0f45586b1894d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00fcc82df204ab81cd887da7d04c023a201afd5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/00fcc82df204ab81cd887da7d04c023a201afd5b", "html_url": "https://github.com/rust-lang/rust/commit/00fcc82df204ab81cd887da7d04c023a201afd5b"}], "stats": {"total": 417, "additions": 32, "deletions": 385}, "files": [{"sha": "ac5fddb7ad1eb9f2ffe29c4d7c869e8e3e8418e8", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -8,7 +8,7 @@ use rustc_apfloat::{\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n \n-use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n+use crate::ty::{ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{\n     AllocId, AllocRange, ConstAllocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n@@ -27,7 +27,7 @@ pub struct ConstAlloc<'tcx> {\n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI.\n     ///\n@@ -53,22 +53,6 @@ pub enum ConstValue<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstValue<'_>, 32);\n \n-impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n-    type Lifted = ConstValue<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ConstValue<'tcx>> {\n-        Some(match self {\n-            ConstValue::Scalar(s) => ConstValue::Scalar(s),\n-            ConstValue::ZeroSized => ConstValue::ZeroSized,\n-            ConstValue::Slice { data, start, end } => {\n-                ConstValue::Slice { data: tcx.lift(data)?, start, end }\n-            }\n-            ConstValue::ByRef { alloc, offset } => {\n-                ConstValue::ByRef { alloc: tcx.lift(alloc)?, offset }\n-            }\n-        })\n-    }\n-}\n-\n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar<AllocId>> {"}, {"sha": "dc72d40947363c6436c9155137f7eb8741e6f08c", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -192,12 +192,6 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)"}, {"sha": "2963c3273ab9083aaed6f2e7b7bccb2147089afd", "filename": "compiler/rustc_middle/src/mir/type_visitable.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -149,12 +149,6 @@ impl<'tcx> TypeVisitable<'tcx> for PlaceElem<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for Field {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n impl<'tcx> TypeVisitable<'tcx> for GeneratorSavedLocal {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE"}, {"sha": "b809f176760d6d720384db62881b6de6cdb87724", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -77,7 +77,7 @@ pub enum PointerCast {\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., `Box<[i32; 4]>` ->\n ///    `Box<[i32]>` is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n@@ -89,7 +89,7 @@ impl<'tcx> Adjustment<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -108,7 +108,7 @@ pub enum Adjust<'tcx> {\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n #[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n+#[derive(TypeFoldable, TypeVisitable, Lift)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -167,7 +167,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n }\n \n #[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n+#[derive(TypeFoldable, TypeVisitable, Lift)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),"}, {"sha": "4a9fbc5511c1ddff0e13f350f6ea017bfe6a59ed", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -1820,7 +1820,9 @@ nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariable\n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n-CloneLiftImpls! { for<'tcx> { Constness, traits::WellFormedLoc, } }\n+CloneLiftImpls! { for<'tcx> {\n+    Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n+} }\n \n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};"}, {"sha": "01e1e97b21a0b43ab11d507cf4f587da6351e365", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi;\n use std::borrow::Cow;\n use std::fmt;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n     pub found: T,\n@@ -31,7 +31,7 @@ impl<T> ExpectedFound<T> {\n }\n \n // Data structures used in type unification\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n #[rustc_pass_by_value]\n pub enum TypeError<'tcx> {\n     Mismatch,"}, {"sha": "2a7b5cb06c853357e09697549f4d0b6034a84767", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -27,7 +27,7 @@ pub struct Instance<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///"}, {"sha": "49486caa7c85ff8a1afca369a1451fa5e9f30e15", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -636,7 +636,7 @@ impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -808,7 +808,7 @@ impl<'tcx> Predicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n \n@@ -888,7 +888,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n@@ -899,7 +899,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicat\n /// whether the `a` type is the type that we should label as \"expected\" when\n /// presenting user diagnostics.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n     pub a: Ty<'tcx>,\n@@ -909,7 +909,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<'tcx, SubtypePredicate<'tcx>>;\n \n /// Encodes that we have to coerce *from* the `a` type to the `b` type.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct CoercePredicate<'tcx> {\n     pub a: Ty<'tcx>,\n     pub b: Ty<'tcx>,\n@@ -1058,7 +1058,7 @@ impl<'tcx> TermKind<'tcx> {\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub term: Term<'tcx>,\n@@ -1692,7 +1692,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub struct ParamEnvAnd<'tcx, T> {\n     pub param_env: ParamEnv<'tcx>,\n     pub value: T,"}, {"sha": "32b9783082f92e3b9565cdd1d09099019f33a0f9", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 330, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -238,6 +238,9 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::Variance,\n     ::rustc_span::Span,\n     ::rustc_errors::ErrorGuaranteed,\n+    Field,\n+    interpret::Scalar,\n+    rustc_target::abi::Size,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -312,35 +315,6 @@ impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n-    type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n-    type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n-    type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::ExistentialPredicate::Trait(x) => tcx.lift(x).map(ty::ExistentialPredicate::Trait),\n-            ty::ExistentialPredicate::Projection(x) => {\n-                tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n-            }\n-            ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                Some(ty::ExistentialPredicate::AutoTrait(def_id))\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Term<'a> {\n     type Lifted = ty::Term<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -353,121 +327,6 @@ impl<'a, 'tcx> Lift<'tcx> for Term<'a> {\n         )\n     }\n }\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n-    type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n-            trait_ref,\n-            constness: self.constness,\n-            polarity: self.polarity,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n-    type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n-        tcx.lift((self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n-            a_is_expected: self.a_is_expected,\n-            a,\n-            b,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::CoercePredicate<'a> {\n-    type Lifted = ty::CoercePredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::CoercePredicate<'tcx>> {\n-        tcx.lift((self.a, self.b)).map(|(a, b)| ty::CoercePredicate { a, b })\n-    }\n-}\n-\n-impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n-    type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift((self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n-    type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n-        tcx.lift(self.substs)\n-            .map(|substs| ty::ProjectionTy { item_def_id: self.item_def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n-    type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift((self.projection_ty, self.term))\n-            .map(|(projection_ty, term)| ty::ProjectionPredicate { projection_ty, term })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n-    type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ExistentialProjection {\n-            substs,\n-            term: tcx.lift(self.term).expect(\"type must lift when substs do\"),\n-            item_def_id: self.item_def_id,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n-    type Lifted = ty::PredicateKind<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::PredicateKind::Trait(data) => tcx.lift(data).map(ty::PredicateKind::Trait),\n-            ty::PredicateKind::Subtype(data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n-            ty::PredicateKind::Coerce(data) => tcx.lift(data).map(ty::PredicateKind::Coerce),\n-            ty::PredicateKind::RegionOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n-            }\n-            ty::PredicateKind::TypeOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::TypeOutlives)\n-            }\n-            ty::PredicateKind::Projection(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::Projection)\n-            }\n-            ty::PredicateKind::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateKind::WellFormed),\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                tcx.lift(closure_substs).map(|closure_substs| {\n-                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n-                })\n-            }\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n-            }\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                tcx.lift(uv).map(|uv| ty::PredicateKind::ConstEvaluatable(uv))\n-            }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n-            }\n-            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n-                tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<'a, T>\n-where\n-    <T as Lift<'tcx>>::Lifted: TypeVisitable<'tcx>,\n-{\n-    type Lifted = ty::Binder<'tcx, T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let bound_vars = tcx.lift(self.bound_vars());\n-        tcx.lift(self.skip_binder())\n-            .zip(bound_vars)\n-            .map(|(value, vars)| ty::Binder::bind_with_vars(value, vars))\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -476,192 +335,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     }\n }\n \n-impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n-    type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.param_env).and_then(|param_env| {\n-            tcx.lift(self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n-    type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ClosureSubsts { substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n-    type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::GeneratorSubsts { substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n-    type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let ty::adjustment::Adjustment { kind, target } = self;\n-        tcx.lift(kind).and_then(|kind| {\n-            tcx.lift(target).map(|target| ty::adjustment::Adjustment { kind, target })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n-    type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::adjustment::Adjust::NeverToAny => Some(ty::adjustment::Adjust::NeverToAny),\n-            ty::adjustment::Adjust::Pointer(ptr) => Some(ty::adjustment::Adjust::Pointer(ptr)),\n-            ty::adjustment::Adjust::Deref(overloaded) => {\n-                tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n-            }\n-            ty::adjustment::Adjust::Borrow(autoref) => {\n-                tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n-    type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.region).map(|region| ty::adjustment::OverloadedDeref {\n-            region,\n-            mutbl: self.mutbl,\n-            span: self.span,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n-    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                tcx.lift(r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(m) => Some(ty::adjustment::AutoBorrow::RawPtr(m)),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n-    type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift((self.resume_ty, self.yield_ty, self.return_ty))\n-            .map(|(resume_ty, yield_ty, return_ty)| ty::GenSig { resume_ty, yield_ty, return_ty })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n-    type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.inputs_and_output).map(|x| ty::FnSig {\n-            inputs_and_output: x,\n-            c_variadic: self.c_variadic,\n-            unsafety: self.unsafety,\n-            abi: self.abi,\n-        })\n-    }\n-}\n-\n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n-    type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let ty::error::ExpectedFound { expected, found } = self;\n-        tcx.lift(expected).and_then(|expected| {\n-            tcx.lift(found).map(|found| ty::error::ExpectedFound { expected, found })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n-    type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        use crate::ty::error::TypeError::*;\n-\n-        Some(match self {\n-            Mismatch => Mismatch,\n-            ConstnessMismatch(x) => ConstnessMismatch(x),\n-            PolarityMismatch(x) => PolarityMismatch(x),\n-            UnsafetyMismatch(x) => UnsafetyMismatch(x),\n-            AbiMismatch(x) => AbiMismatch(x),\n-            Mutability => Mutability,\n-            ArgumentMutability(i) => ArgumentMutability(i),\n-            TupleSize(x) => TupleSize(x),\n-            FixedArraySize(x) => FixedArraySize(x),\n-            ArgCount => ArgCount,\n-            FieldMisMatch(x, y) => FieldMisMatch(x, y),\n-            RegionsDoesNotOutlive(a, b) => {\n-                return tcx.lift((a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n-            }\n-            RegionsInsufficientlyPolymorphic(a, b) => {\n-                return tcx.lift(b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n-            }\n-            RegionsOverlyPolymorphic(a, b) => {\n-                return tcx.lift(b).map(|b| RegionsOverlyPolymorphic(a, b));\n-            }\n-            RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n-            IntMismatch(x) => IntMismatch(x),\n-            FloatMismatch(x) => FloatMismatch(x),\n-            Traits(x) => Traits(x),\n-            VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => return tcx.lift(t).map(|t| CyclicTy(t)),\n-            CyclicConst(ct) => return tcx.lift(ct).map(|ct| CyclicConst(ct)),\n-            ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ArgumentSorts(x, i) => return tcx.lift(x).map(|x| ArgumentSorts(x, i)),\n-            Sorts(x) => return tcx.lift(x).map(Sorts),\n-            ExistentialMismatch(x) => return tcx.lift(x).map(ExistentialMismatch),\n-            ConstMismatch(x) => return tcx.lift(x).map(ConstMismatch),\n-            IntrinsicCast => IntrinsicCast,\n-            TargetFeatureCast(x) => TargetFeatureCast(x),\n-            ObjectUnsafeCoercion(x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n-    type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::InstanceDef::Item(def_id) => Some(ty::InstanceDef::Item(def_id)),\n-            ty::InstanceDef::VTableShim(def_id) => Some(ty::InstanceDef::VTableShim(def_id)),\n-            ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n-            ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n-            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n-                Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?))\n-            }\n-            ty::InstanceDef::Virtual(def_id, n) => Some(ty::InstanceDef::Virtual(def_id, n)),\n-            ty::InstanceDef::ClosureOnceShim { call_once, track_caller } => {\n-                Some(ty::InstanceDef::ClosureOnceShim { call_once, track_caller })\n-            }\n-            ty::InstanceDef::DropGlue(def_id, ty) => {\n-                Some(ty::InstanceDef::DropGlue(def_id, tcx.lift(ty)?))\n-            }\n-            ty::InstanceDef::CloneShim(def_id, ty) => {\n-                Some(ty::InstanceDef::CloneShim(def_id, tcx.lift(ty)?))\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Lift<'tcx> for Field {\n-    type Lifted = Field;\n-    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(self)\n-    }\n-}\n-\n-impl<'tcx> Lift<'tcx> for crate::mir::ReturnConstraint {\n-    type Lifted = crate::mir::ReturnConstraint;\n-    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(self)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n "}, {"sha": "36e560850390451d2fbbb9681cc9d0824d078970", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e986c1f0c41951a61d35e198e0f45586b1894d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d4e986c1f0c41951a61d35e198e0f45586b1894d", "patch": "@@ -202,7 +202,7 @@ static_assert_size!(TyKind<'_>, 32);\n /// * `GR`: The \"return type\", which is the type of value returned upon\n ///   completion of the generator.\n /// * `GW`: The \"generator witness\".\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with a tuple containing the types of the upvars.\n@@ -333,7 +333,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n }\n \n /// Similar to `ClosureSubsts`; see the above documentation for more.\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -660,7 +660,7 @@ impl<'tcx> InlineConstSubsts<'tcx> {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n     Trait(ExistentialTraitRef<'tcx>),\n@@ -789,7 +789,7 @@ impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -867,7 +867,7 @@ impl rustc_errors::IntoDiagnosticArg for PolyTraitRef<'_> {\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -1023,7 +1023,7 @@ impl BoundVariableKind {\n ///\n /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub struct Binder<'tcx, T>(T, &'tcx List<BoundVariableKind>);\n \n impl<'tcx, T> Binder<'tcx, T>\n@@ -1185,7 +1185,7 @@ impl<'tcx, T> Binder<'tcx, Option<T>> {\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: SubstsRef<'tcx>,\n@@ -1237,7 +1237,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct GenSig<'tcx> {\n     pub resume_ty: Ty<'tcx>,\n     pub yield_ty: Ty<'tcx>,\n@@ -1253,7 +1253,7 @@ pub type PolyGenSig<'tcx> = Binder<'tcx, GenSig<'tcx>>;\n /// - `output`: is the return type.\n /// - `c_variadic`: indicates whether this is a C-variadic function.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n     pub c_variadic: bool,\n@@ -1435,7 +1435,7 @@ impl From<BoundVar> for BoundTy {\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}]}