{"sha": "83c17887b7b9968538df6aed5cc1ef4c441b2e23", "node_id": "C_kwDOAAsO6NoAKDgzYzE3ODg3YjdiOTk2ODUzOGRmNmFlZDVjYzFlZjRjNDQxYjJlMjM", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-05-25T17:15:49Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-07-14T00:12:44Z"}, "message": "Make outlives::{components,verify} agree", "tree": {"sha": "0474647ca4a5cf8b6984d02fd596634f4e376274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0474647ca4a5cf8b6984d02fd596634f4e376274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83c17887b7b9968538df6aed5cc1ef4c441b2e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83c17887b7b9968538df6aed5cc1ef4c441b2e23", "html_url": "https://github.com/rust-lang/rust/commit/83c17887b7b9968538df6aed5cc1ef4c441b2e23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83c17887b7b9968538df6aed5cc1ef4c441b2e23/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9775fe17893cba641a071de7e0a7c8f478c41b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9775fe17893cba641a071de7e0a7c8f478c41b", "html_url": "https://github.com/rust-lang/rust/commit/5b9775fe17893cba641a071de7e0a7c8f478c41b"}], "stats": {"total": 176, "additions": 123, "deletions": 53}, "files": [{"sha": "7f6878fc740c1aa0cc590060f31f8aefff115238", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83c17887b7b9968538df6aed5cc1ef4c441b2e23/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c17887b7b9968538df6aed5cc1ef4c441b2e23/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=83c17887b7b9968538df6aed5cc1ef4c441b2e23", "patch": "@@ -190,7 +190,11 @@ fn compute_components<'tcx>(\n         }\n }\n \n-fn compute_components_recursive<'tcx>(\n+/// Collect [Component]s for *all* the substs of `parent`.\n+///\n+/// This should not be used to get the components of `parent` itself.\n+/// Use [push_outlives_components] instead.\n+pub(super) fn compute_components_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     parent: GenericArg<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,"}, {"sha": "faa0a18f93d9a5cfd08a3e6a9c8661beda1035a4", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/83c17887b7b9968538df6aed5cc1ef4c441b2e23/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c17887b7b9968538df6aed5cc1ef4c441b2e23/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=83c17887b7b9968538df6aed5cc1ef4c441b2e23", "patch": "@@ -1,12 +1,15 @@\n+use crate::infer::outlives::components::{compute_components_recursive, Component};\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::region_constraints::VerifyIfEq;\n use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n use rustc_middle::ty::{self, EarlyBinder, Ty, TyCtxt};\n \n+use smallvec::smallvec;\n+\n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n /// described on the module comment. The final constraints are emitted\n@@ -47,43 +50,6 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn type_bound(\n-        &self,\n-        ty: Ty<'tcx>,\n-        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n-    ) -> VerifyBound<'tcx> {\n-        match *ty.kind() {\n-            ty::Param(p) => self.param_bound(p),\n-            ty::Projection(data) => self.projection_bound(data, visited),\n-            ty::FnDef(_, substs) => {\n-                // HACK(eddyb) ignore lifetimes found shallowly in `substs`.\n-                // This is inconsistent with `ty::Adt` (including all substs),\n-                // but consistent with previous (accidental) behavior.\n-                // See https://github.com/rust-lang/rust/issues/70917\n-                // for further background and discussion.\n-                let mut bounds = substs\n-                    .iter()\n-                    .filter_map(|child| match child.unpack() {\n-                        GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n-                        GenericArgKind::Lifetime(_) => None,\n-                        GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n-                    })\n-                    .filter(|bound| {\n-                        // Remove bounds that must hold, since they are not interesting.\n-                        !bound.must_hold()\n-                    });\n-\n-                match (bounds.next(), bounds.next()) {\n-                    (Some(first), None) => first,\n-                    (first, second) => VerifyBound::AllBounds(\n-                        first.into_iter().chain(second).chain(bounds).collect(),\n-                    ),\n-                }\n-            }\n-            _ => self.recursive_bound(ty.into(), visited),\n-        }\n-    }\n-\n     fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         debug!(\"param_bound(param_ty={:?})\", param_ty);\n \n@@ -188,27 +154,24 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n             .map(|r| VerifyBound::OutlivedBy(r));\n \n         // see the extensive comment in projection_must_outlive\n-        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_bound(ty.into(), visited);\n+        let recursive_bound = {\n+            let mut components = smallvec![];\n+            let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+            compute_components_recursive(self.tcx, ty.into(), &mut components, visited);\n+            self.bound_from_components(&components, visited)\n+        };\n \n         VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n-    fn recursive_bound(\n+    fn bound_from_components(\n         &self,\n-        parent: GenericArg<'tcx>,\n+        components: &[Component<'tcx>],\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n-        let mut bounds = parent\n-            .walk_shallow(visited)\n-            .filter_map(|child| match child.unpack() {\n-                GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n-                GenericArgKind::Lifetime(lt) => {\n-                    // Ignore late-bound regions.\n-                    if !lt.is_late_bound() { Some(VerifyBound::OutlivedBy(lt)) } else { None }\n-                }\n-                GenericArgKind::Const(_) => Some(self.recursive_bound(child, visited)),\n-            })\n+        let mut bounds = components\n+            .iter()\n+            .map(|component| self.bound_from_single_component(component, visited))\n             .filter(|bound| {\n                 // Remove bounds that must hold, since they are not interesting.\n                 !bound.must_hold()\n@@ -222,6 +185,32 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn bound_from_single_component(\n+        &self,\n+        component: &Component<'tcx>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n+    ) -> VerifyBound<'tcx> {\n+        match *component {\n+            Component::Region(lt) => VerifyBound::OutlivedBy(lt),\n+            Component::Param(param_ty) => self.param_bound(param_ty),\n+            Component::Projection(projection_ty) => self.projection_bound(projection_ty, visited),\n+            Component::EscapingProjection(ref components) => {\n+                self.bound_from_components(components, visited)\n+            }\n+            Component::UnresolvedInferenceVariable(v) => {\n+                // ignore this, we presume it will yield an error\n+                // later, since if a type variable is not resolved by\n+                // this point it never will be\n+                self.tcx.sess.delay_span_bug(\n+                    rustc_span::DUMMY_SP,\n+                    &format!(\"unresolved inference variable in outlives: {:?}\", v),\n+                );\n+                // add a bound that never holds\n+                VerifyBound::AnyBound(vec![])\n+            }\n+        }\n+    }\n+\n     /// Searches the environment for where-clauses like `G: 'a` where\n     /// `G` is either some type parameter `T` or a projection like\n     /// `T::Item`. Returns a vector of the `'a` bounds it can find."}, {"sha": "e567d5c2723f2c2b631730abe978dbaa380b09ac", "filename": "src/test/ui/regions/closure-in-projection-issue-97405.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/83c17887b7b9968538df6aed5cc1ef4c441b2e23/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83c17887b7b9968538df6aed5cc1ef4c441b2e23/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.rs?ref=83c17887b7b9968538df6aed5cc1ef4c441b2e23", "patch": "@@ -0,0 +1,32 @@\n+// Regression test for #97405.\n+// In `good_generic_fn` the param `T` ends up in the substs of closures/generators,\n+// but we should be able to prove `<Gen<T> as Iterator>::Item: 'static` without\n+// requiring `T: 'static`\n+\n+// edition:2018\n+// check-fail\n+\n+fn opaque<F>(_: F) -> impl Iterator { b\"\".iter() }\n+\n+fn assert_static<T: 'static>(_: T) {}\n+\n+fn good_generic_fn<T>() {\n+    // Previously, proving `<OpaqueTy<type_of(async {})> as Iterator>::Item: 'static`\n+    // used to require `T: 'static`.\n+    assert_static(opaque(async {}).next());\n+    assert_static(opaque(|| {}).next());\n+    assert_static(opaque(opaque(async {}).next()).next());\n+}\n+\n+\n+// This should fail because `T` ends up in the upvars of the closure.\n+fn bad_generic_fn<T: Copy>(t: T) {\n+    assert_static(opaque(async move { t; }).next());\n+    //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+    assert_static(opaque(move || { t; }).next());\n+    //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+    assert_static(opaque(opaque(async move { t; }).next()).next());\n+    //~^ ERROR the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "08ac0a647725ec1100458a5c3361d88175966f54", "filename": "src/test/ui/regions/closure-in-projection-issue-97405.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/83c17887b7b9968538df6aed5cc1ef4c441b2e23/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83c17887b7b9968538df6aed5cc1ef4c441b2e23/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fclosure-in-projection-issue-97405.stderr?ref=83c17887b7b9968538df6aed5cc1ef4c441b2e23", "patch": "@@ -0,0 +1,45 @@\n+error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+  --> $DIR/closure-in-projection-issue-97405.rs:24:5\n+   |\n+LL |     assert_static(opaque(async move { t; }).next());\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n+   = note: ...so that the type `Option<<impl Iterator as Iterator>::Item>` will meet its required lifetime bounds...\n+note: ...that is required by this bound\n+  --> $DIR/closure-in-projection-issue-97405.rs:11:21\n+   |\n+LL | fn assert_static<T: 'static>(_: T) {}\n+   |                     ^^^^^^^\n+\n+error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+  --> $DIR/closure-in-projection-issue-97405.rs:26:5\n+   |\n+LL |     assert_static(opaque(move || { t; }).next());\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n+   = note: ...so that the type `Option<<impl Iterator as Iterator>::Item>` will meet its required lifetime bounds...\n+note: ...that is required by this bound\n+  --> $DIR/closure-in-projection-issue-97405.rs:11:21\n+   |\n+LL | fn assert_static<T: 'static>(_: T) {}\n+   |                     ^^^^^^^\n+\n+error[E0310]: the associated type `<impl Iterator as Iterator>::Item` may not live long enough\n+  --> $DIR/closure-in-projection-issue-97405.rs:28:5\n+   |\n+LL |     assert_static(opaque(opaque(async move { t; }).next()).next());\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<impl Iterator as Iterator>::Item: 'static`...\n+   = note: ...so that the type `Option<<impl Iterator as Iterator>::Item>` will meet its required lifetime bounds...\n+note: ...that is required by this bound\n+  --> $DIR/closure-in-projection-issue-97405.rs:11:21\n+   |\n+LL | fn assert_static<T: 'static>(_: T) {}\n+   |                     ^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0310`."}]}