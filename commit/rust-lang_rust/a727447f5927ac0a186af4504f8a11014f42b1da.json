{"sha": "a727447f5927ac0a186af4504f8a11014f42b1da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3Mjc0NDdmNTkyN2FjMGExODZhZjQ1MDRmOGExMTAxNGY0MmIxZGE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-03-27T14:06:47Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-04-03T17:43:14Z"}, "message": "Refactor to use a dry-run config instead of cfg(test)\n\nThis ensures that each build will support the testing design of \"dry\nrunning\" builds. It's also checked that a dry run build is equivalent\nstep-wise to a \"wet\" run build; the graphs we generate when running are\ndirectly compared node/node and edge/edge, both for order and contents.", "tree": {"sha": "15c5889a504c938586d745540df5917bfdb0009b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15c5889a504c938586d745540df5917bfdb0009b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a727447f5927ac0a186af4504f8a11014f42b1da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a727447f5927ac0a186af4504f8a11014f42b1da", "html_url": "https://github.com/rust-lang/rust/commit/a727447f5927ac0a186af4504f8a11014f42b1da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a727447f5927ac0a186af4504f8a11014f42b1da/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0dbc7c15d4f3027410b3836154da1ae63e0a7d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0dbc7c15d4f3027410b3836154da1ae63e0a7d3", "html_url": "https://github.com/rust-lang/rust/commit/b0dbc7c15d4f3027410b3836154da1ae63e0a7d3"}], "stats": {"total": 686, "additions": 393, "deletions": 293}, "files": [{"sha": "3f5ec4933d02b23d31469b3ea022b46fb1f0b323", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -413,8 +413,9 @@ impl<'a> Builder<'a> {\n         builder\n     }\n \n-    pub fn execute_cli(&self) {\n+    pub fn execute_cli(&self) -> Graph<String, bool> {\n         self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n+        self.graph.borrow().clone()\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n@@ -910,13 +911,20 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod __test {\n     use config::Config;\n+    use std::thread;\n     use super::*;\n \n     fn configure(host: &[&str], target: &[&str]) -> Config {\n         let mut config = Config::default_opts();\n         // don't save toolstates\n         config.save_toolstates = None;\n         config.run_host_only = true;\n+        config.dry_run = true;\n+        // try to avoid spurious failures in dist where we create/delete each others file\n+        let dir = config.out.join(\"tmp-rustbuild-tests\")\n+            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        t!(fs::create_dir_all(&dir));\n+        config.out = dir;\n         config.build = INTERNER.intern_str(\"A\");\n         config.hosts = vec![config.build].clone().into_iter()\n             .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();"}, {"sha": "a39fad67ebea4ac967bffe828dd8d39c7375b624", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -53,7 +53,7 @@ impl Step for Std {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n@@ -102,7 +102,7 @@ impl Step for Rustc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n@@ -143,7 +143,7 @@ impl Step for Test {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n "}, {"sha": "872c29085289a1bcfbe17c9a9bda8f31510717ac", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -30,7 +30,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n+use util::{exe, libdir, is_dylib, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n@@ -130,7 +130,7 @@ fn copy_musl_third_party_objects(build: &Build,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        build.copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -220,13 +220,13 @@ impl Step for StdLink {\n                 target_compiler.host,\n                 target);\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n \n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(&build, &build.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n@@ -237,15 +237,15 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(build: &Build, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        copy(&src_path, &into.join(filename));\n+        build.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -301,15 +301,15 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            build.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(build,\n                                     build.cc(target),\n                                     target,\n                                     obj);\n-            copy(&src, &sysroot_dir.join(obj));\n+            build.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n@@ -420,7 +420,7 @@ impl Step for TestLink {\n                 &compiler.host,\n                 target_compiler.host,\n                 target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -575,7 +575,7 @@ impl Step for RustcLink {\n                  &compiler.host,\n                  target_compiler.host,\n                  target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -690,7 +690,7 @@ impl Step for CodegenBackend {\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n                               false);\n-        if cfg!(test) {\n+        if builder.config.dry_run {\n             return;\n         }\n         let mut files = files.into_iter()\n@@ -736,6 +736,10 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     let dst = builder.sysroot_codegen_backends(target_compiler);\n     t!(fs::create_dir_all(&dst));\n \n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(build, compiler, target, *backend);\n         let mut dylib = String::new();\n@@ -751,7 +755,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                     backend,\n                     &filename[dot..])\n         };\n-        copy(&file, &dst.join(target_filename));\n+        build.copy(&file, &dst.join(target_filename));\n     }\n }\n \n@@ -767,7 +771,7 @@ fn copy_lld_to_sysroot(builder: &Builder,\n     t!(fs::create_dir_all(&dst));\n \n     let exe = exe(\"lld\", &target);\n-    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+    builder.copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -936,10 +940,10 @@ impl Step for Assemble {\n         let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n-        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n@@ -957,7 +961,7 @@ impl Step for Assemble {\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n-        copy(&rustc, &compiler);\n+        builder.copy(&rustc, &compiler);\n \n         target_compiler\n     }\n@@ -967,10 +971,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(build: &Build, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in read_stamp_file(stamp) {\n-        copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in build.read_stamp_file(stamp) {\n+        build.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -1000,6 +1004,10 @@ fn stderr_isatty() -> bool {\n pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool)\n     -> Vec<PathBuf>\n {\n+    if build.config.dry_run {\n+        return Vec::new();\n+    }\n+\n     // `target_root_dir` looks like $dir/$target/release\n     let target_root_dir = stamp.parent().unwrap();\n     // `target_deps_dir` looks like $dir/$target/release/deps\n@@ -1141,6 +1149,9 @@ pub fn stream_cargo(\n     cargo: &mut Command,\n     cb: &mut FnMut(CargoMessage),\n ) -> bool {\n+    if build.config.dry_run {\n+        return true;\n+    }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")"}, {"sha": "76672df5c570deeeccd747d9c809c56839dabe29", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -15,7 +15,7 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -69,6 +69,7 @@ pub struct Config {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub dry_run: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -362,8 +363,15 @@ impl Config {\n         config.jobs = flags.jobs;\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n+        config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n \n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n+\n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n         config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n "}, {"sha": "86ef5c35cd7f419d5a00544ea2842d8bb4e5a24d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 102, "deletions": 134, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -20,15 +20,15 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n+use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -103,7 +103,7 @@ impl Step for Docs {\n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n         let src = build.doc_out(host);\n-        cp_r(&src, &dst);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -118,7 +118,7 @@ impl Step for Docs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n@@ -166,7 +166,7 @@ impl Step for RustcDocs {\n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n         let src = build.compiler_doc_out(host);\n-        cp_r(&src, &dst);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -181,7 +181,7 @@ impl Step for RustcDocs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n@@ -292,31 +292,25 @@ fn make_win_dist(\n     let rustc_dlls = find_files(&rustc_dlls, &bin_path);\n     let target_libs = find_files(&target_libs, &lib_path);\n \n-    fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap();\n-        let dest = dest_folder.join(file_name);\n-        copy(src, &dest);\n-    }\n-\n-    //Copy runtime dlls next to rustc.exe\n+    // Copy runtime dlls next to rustc.exe\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        copy_to_folder(&src, &dist_bin_dir);\n+        build.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        copy_to_folder(&src, &target_bin_dir);\n+        build.copy_to_folder(&src, &target_bin_dir);\n     }\n \n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        copy_to_folder(&src, &target_lib_dir);\n+        build.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n@@ -417,17 +411,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &overlay, 0o644);\n+            build.install(&build.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -445,7 +439,7 @@ impl Step for Rustc {\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            build.cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -462,8 +456,8 @@ impl Step for Rustc {\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        t!(fs::remove_dir_all(&overlay));\n+        build.remove_dir(&image);\n+        build.remove_dir(&overlay);\n \n         return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n \n@@ -475,17 +469,17 @@ impl Step for Rustc {\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            build.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            build.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                for entry in build.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            install(&entry.path(), &image.join(libdir), 0o644);\n+                            build.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n@@ -496,7 +490,7 @@ impl Step for Rustc {\n             let backends_rel = backends_src.strip_prefix(&src).unwrap();\n             let backends_dst = image.join(&backends_rel);\n             t!(fs::create_dir_all(&backends_dst));\n-            cp_r(&backends_src, &backends_dst);\n+            build.cp_r(&backends_src, &backends_dst);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -511,7 +505,7 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                copy(&src, &dst);\n+                build.copy(&src, &dst);\n             }\n \n             // Man pages\n@@ -521,13 +515,12 @@ impl Step for Rustc {\n             let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for entry_result in t!(fs::read_dir(man_src)) {\n-                let file_entry = t!(entry_result);\n+            for file_entry in build.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                replace_in_file(&page_dst,\n+                build.replace_in_file(&page_dst,\n                                 &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n@@ -540,7 +533,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                build.install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -578,11 +571,11 @@ impl Step for DebuggerScripts {\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            build.install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -592,14 +585,14 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n@@ -659,7 +652,7 @@ impl Step for Std {\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_filtered(&src, &dst, &|path| {\n+        build.cp_filtered(&src, &dst, &|path| {\n             let name = path.file_name().and_then(|s| s.to_str());\n             name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n                 name != Some(\"bin\")\n@@ -678,7 +671,7 @@ impl Step for Std {\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -738,7 +731,7 @@ impl Step for Analysis {\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n         println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-        cp_r(&image_src, &dst);\n+        build.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -752,7 +745,7 @@ impl Step for Analysis {\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -796,7 +789,7 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        build.cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n@@ -870,7 +863,7 @@ impl Step for Src {\n \n         copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            copy(&build.src.join(file), &dst_src.join(file));\n+            build.copy(&build.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -887,7 +880,7 @@ impl Step for Src {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n \n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n@@ -943,13 +936,13 @@ impl Step for PlainSourceTarball {\n \n         // Copy the files normally\n         for item in &src_files {\n-            copy(&build.src.join(item), &plain_dst_src.join(item));\n+            build.copy(&build.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        build.create(&plain_dst_src.join(\"version\"), &build.rust_version());\n         if let Some(sha) = build.rust_sha() {\n-            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+            build.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n@@ -990,7 +983,7 @@ impl Step for PlainSourceTarball {\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            t!(fs::create_dir_all(dir));\n+            build.create_dir(&dir);\n         }\n         println!(\"running installer\");\n         let mut cmd = rust_installer(builder);\n@@ -1004,26 +997,6 @@ impl Step for PlainSourceTarball {\n     }\n }\n \n-fn install(src: &Path, dstdir: &Path, perms: u32) {\n-    let dst = dstdir.join(src.file_name().unwrap());\n-    t!(fs::create_dir_all(dstdir));\n-    drop(fs::remove_file(&dst));\n-    {\n-        let mut s = t!(fs::File::open(&src));\n-        let mut d = t!(fs::File::create(&dst));\n-        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n-    }\n-    chmod(&dst, perms);\n-}\n-\n-#[cfg(unix)]\n-fn chmod(path: &Path, perms: u32) {\n-    use std::os::unix::fs::*;\n-    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n-}\n-#[cfg(windows)]\n-fn chmod(_path: &Path, _perms: u32) {}\n-\n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n pub fn sanitize_sh(path: &Path) -> String {\n@@ -1043,11 +1016,6 @@ pub fn sanitize_sh(path: &Path) -> String {\n     }\n }\n \n-fn write_file(path: &Path, data: &[u8]) {\n-    let mut vf = t!(fs::File::create(path));\n-    t!(vf.write_all(data));\n-}\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub stage: u32,\n@@ -1084,38 +1052,38 @@ impl Step for Cargo {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n-        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        build.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        build.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n             compiler: builder.compiler(stage, build.build),\n             target\n         });\n-        install(&cargo, &image.join(\"bin\"), 0o755);\n+        build.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            build.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        build.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        build.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1181,20 +1149,20 @@ impl Step for Rls {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        install(&rls, &image.join(\"bin\"), 0o755);\n+        build.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1251,7 +1219,7 @@ impl Step for Rustfmt {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n@@ -1263,21 +1231,21 @@ impl Step for Rustfmt {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        build.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        build.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1355,15 +1323,15 @@ impl Step for Extended {\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1402,11 +1370,11 @@ impl Step for Extended {\n         build.run(&mut cmd);\n \n         let mut license = String::new();\n-        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license += &build.read(&build.src.join(\"COPYRIGHT\"));\n+        license += &build.read(&build.src.join(\"LICENSE-APACHE\"));\n+        license += &build.read(&build.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n \n         let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n         let mut rtf = rtf.to_string();\n@@ -1463,10 +1431,10 @@ impl Step for Extended {\n             };\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(pkg.join(name)));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                build.create_dir(&pkg.join(name));\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n                         &pkg.join(name));\n-                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1480,12 +1448,12 @@ impl Step for Extended {\n             }\n \n             // create an 'uninstall' package\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            t!(fs::create_dir_all(pkg.join(\"res\")));\n-            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            build.create_dir(&pkg.join(\"res\"));\n+            build.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            build.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n@@ -1501,15 +1469,15 @@ impl Step for Extended {\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(exe.join(name)));\n+                build.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n                             .join(dir),\n                         &exe.join(name));\n                 t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n@@ -1526,10 +1494,10 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            build.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            build.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n             t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n \n             // Generate exe installer\n@@ -1541,7 +1509,7 @@ impl Step for Extended {\n             }\n             add_env(build, &mut cmd, target);\n             build.run(&mut cmd);\n-            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n+            build.install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n                     &distdir(build),\n                     0o755);\n \n@@ -1666,8 +1634,8 @@ impl Step for Extended {\n             }\n \n             t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n             let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n@@ -1772,7 +1740,7 @@ impl Step for HashSign {\n         cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n-        t!(fs::create_dir_all(distdir(build)));\n+        build.create_dir(&distdir(build));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));"}, {"sha": "eeea6f0d01d2acb3cffe8fdeb21b993f4e8b3bc5", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -26,11 +26,12 @@ use std::path::{PathBuf, Path};\n use {Build, Mode};\n use build_helper::up_to_date;\n \n-use util::{cp_r, symlink_dir};\n+use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use tool::Tool;\n use compile;\n use cache::{INTERNER, Interned};\n+use config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -210,12 +211,13 @@ impl Step for RustbookSrc {\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n         println!(\"Rustbook ({}) - {}\", target, name);\n         let _ = fs::remove_dir_all(&out);\n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        build.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -370,7 +372,7 @@ impl Step for Standalone {\n         let version_input = build.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !up_to_date(&version_input, &version_info) {\n+        if !build.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n             let info = info.replace(\"VERSION\", &build.rust_release())\n@@ -394,7 +396,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               up_to_date(&rustdoc, &html) {\n+               (build.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -479,7 +481,7 @@ impl Step for Std {\n         // will also directly handle merging.\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&build.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n@@ -496,7 +498,7 @@ impl Step for Std {\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -551,12 +553,12 @@ impl Step for Test {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n         compile::test_cargo(build, &compiler, target, &mut cargo);\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -617,7 +619,7 @@ impl Step for WhitelistedRustc {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n@@ -631,7 +633,7 @@ impl Step for WhitelistedRustc {\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -693,7 +695,7 @@ impl Step for Rustc {\n         // We do not symlink to the same shared folder that already contains std library\n         // documentation from previous steps as we do not want to include that.\n         build.clear_if_dirty(&out, &rustdoc);\n-        t!(symlink_dir_force(&out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n@@ -806,8 +808,8 @@ impl Step for UnstableBookGen {\n \n         println!(\"Generating unstable book md files ({})\", target);\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n-        t!(fs::create_dir_all(&out));\n-        t!(fs::remove_dir_all(&out));\n+        build.create_dir(&out);\n+        build.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(out);\n@@ -816,7 +818,10 @@ impl Step for UnstableBookGen {\n     }\n }\n \n-fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()> {\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {\n             try!(fs::remove_dir_all(dst));\n@@ -829,5 +834,5 @@ fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n         }\n     }\n \n-    symlink_dir(src, dst)\n+    symlink_dir(config, src, dst)\n }"}, {"sha": "cd304fb26e0bfcb939cf226951a19c58c170d4f3", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -13,7 +13,6 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n@@ -42,6 +41,7 @@ pub struct Flags {\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub dry_run: bool,\n }\n \n pub enum Subcommand {\n@@ -112,6 +112,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n+        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n@@ -365,6 +366,7 @@ Arguments:\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n+            dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),"}, {"sha": "7b37c9cefa5cb5e1220a27816672c6a7b4049712", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 193, "deletions": 8, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -114,7 +114,7 @@\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n #![deny(warnings)]\n-#![feature(core_intrinsics)]\n+#![feature(conservative_impl_trait, fs_read_write, core_intrinsics)]\n #![feature(slice_concat_ext)]\n \n #[macro_use]\n@@ -143,13 +143,15 @@ extern crate libc;\n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs::{self, OpenOptions, File};\n+use std::io::{self, Seek, SeekFrom, Write, Read};\n use std::path::{PathBuf, Path};\n use std::process::{self, Command};\n use std::slice;\n+use std::str;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use filetime::FileTime;\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n@@ -404,13 +406,36 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        let builder = builder::Builder::new(&self);\n-        if let Some(path) = builder.paths.get(0) {\n-            if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n-                return;\n+        {\n+            let builder = builder::Builder::new(&self);\n+            if let Some(path) = builder.paths.get(0) {\n+                if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                    return;\n+                }\n             }\n         }\n-        builder.execute_cli();\n+\n+        if !self.config.dry_run {\n+            let dry_graph = {\n+                self.config.dry_run = true;\n+                let builder = builder::Builder::new(&self);\n+                builder.execute_cli()\n+            };\n+            self.config.dry_run = false;\n+            let builder = builder::Builder::new(&self);\n+            let act_graph = builder.execute_cli();\n+            assert_eq!(dry_graph.raw_nodes().iter().map(|i| &i.weight).collect::<Vec<_>>(),\n+                act_graph.raw_nodes().iter().map(|i| &i.weight).collect::<Vec<_>>());\n+            assert_eq!(dry_graph.raw_edges()\n+                .iter().map(|i| (&dry_graph[i.source()], &dry_graph[i.target()], &i.weight))\n+                .collect::<Vec<_>>(),\n+                act_graph.raw_edges()\n+                .iter().map(|i| (&act_graph[i.source()], &act_graph[i.target()], &i.weight))\n+                .collect::<Vec<_>>());\n+        } else {\n+            let builder = builder::Builder::new(&self);\n+            let _ = builder.execute_cli();\n+        }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n         let failures = self.delayed_failures.borrow();\n@@ -997,7 +1022,167 @@ impl Build {\n         }\n         ret\n     }\n+\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+        if self.config.dry_run {\n+            return Vec::new();\n+        }\n+\n+        let mut paths = Vec::new();\n+        let mut contents = Vec::new();\n+        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        // This is the method we use for extracting paths from the stamp file passed to us. See\n+        // run_cargo for more information (in compile.rs).\n+        for part in contents.split(|b| *b == 0) {\n+            if part.is_empty() {\n+                continue\n+            }\n+            let path = PathBuf::from(t!(str::from_utf8(part)));\n+            paths.push(path);\n+        }\n+        paths\n+    }\n+\n+    /// Copies a file from `src` to `dst`\n+    pub fn copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        let _ = fs::remove_file(&dst);\n+        // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+        // windows), but if that fails just fall back to a slow `copy` operation.\n+        if let Ok(()) = fs::hard_link(src, dst) {\n+            return\n+        }\n+        if let Err(e) = fs::copy(src, dst) {\n+            panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n+                dst.display(), e)\n+        }\n+        let metadata = t!(src.metadata());\n+        t!(fs::set_permissions(dst, metadata.permissions()));\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        t!(filetime::set_file_times(dst, atime, mtime));\n+    }\n+\n+    /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n+    /// new string for each replacement.)\n+    pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n+        if self.config.dry_run { return; }\n+        let mut contents = String::new();\n+        let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n+        t!(file.read_to_string(&mut contents));\n+        for &(target, replacement) in replacements {\n+            contents = contents.replace(target, replacement);\n+        }\n+        t!(file.seek(SeekFrom::Start(0)));\n+        t!(file.set_len(0));\n+        t!(file.write_all(contents.as_bytes()));\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called.\n+    pub fn cp_r(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            if t!(f.file_type()).is_dir() {\n+                t!(fs::create_dir_all(&dst));\n+                self.cp_r(&path, &dst);\n+            } else {\n+                let _ = fs::remove_file(&dst);\n+                self.copy(&path, &dst);\n+            }\n+        }\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called. Unwanted files or directories can be skipped\n+    /// by returning `false` from the filter function.\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n+        // Immediately recurse with an empty relative path\n+        self.recurse_(src, dst, Path::new(\"\"), filter)\n+    }\n+\n+    // Inner function does the actual work\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n+        for f in self.read_dir(src) {\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    self.create_dir(&dst);\n+                    self.recurse_(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    self.copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn copy_to_folder(&self, src: &Path, dest_folder: &Path) {\n+        let file_name = src.file_name().unwrap();\n+        let dest = dest_folder.join(file_name);\n+        self.copy(src, &dest);\n+    }\n+\n+    fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n+        if self.config.dry_run { return; }\n+        let dst = dstdir.join(src.file_name().unwrap());\n+        t!(fs::create_dir_all(dstdir));\n+        drop(fs::remove_file(&dst));\n+        {\n+            let mut s = t!(fs::File::open(&src));\n+            let mut d = t!(fs::File::create(&dst));\n+            io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+        }\n+        chmod(&dst, perms);\n+    }\n+\n+    fn create(&self, path: &Path, s: &str) {\n+        if self.config.dry_run { return; }\n+        t!(fs::write(path, s));\n+    }\n+\n+    fn read(&self, path: &Path) -> String {\n+        if self.config.dry_run { return String::new(); }\n+        t!(fs::read_string(path))\n+    }\n+\n+    fn create_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::create_dir_all(dir))\n+    }\n+\n+    fn remove_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::remove_dir_all(dir))\n+    }\n+\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+        let iter = match fs::read_dir(dir) {\n+            Ok(v) => v,\n+            Err(_) if self.config.dry_run => return vec![].into_iter(),\n+            Err(err) => panic!(\"could not read dir {:?}: {:?}\", dir, err),\n+        };\n+        iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn chmod(path: &Path, perms: u32) {\n+    use std::os::unix::fs::*;\n+    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n }\n+#[cfg(windows)]\n+fn chmod(_path: &Path, _perms: u32) {}\n+\n \n impl<'a> Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {"}, {"sha": "c49811d839a04dfdaf8c52ff68e7f2c2b384751d", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -60,9 +60,6 @@ impl Step for Llvm {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        if cfg!(test) {\n-            return PathBuf::from(\"llvm-config-test-generated\");\n-        }\n         let build = builder.build;\n         let target = self.target;\n         let emscripten = self.emscripten;\n@@ -220,6 +217,11 @@ impl Step for Llvm {\n         //        libraries here, e.g. we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n+\n+        if builder.config.dry_run {\n+            return build_llvm_config;\n+        }\n+\n         cfg.build();\n \n         t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n@@ -339,7 +341,7 @@ impl Step for Lld {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        if cfg!(test) {\n+        if builder.config.dry_run {\n             return PathBuf::from(\"lld-out-dir-test-gen\");\n         }\n         let target = self.target;\n@@ -395,7 +397,7 @@ impl Step for TestHelpers {\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n-        if cfg!(test) {\n+        if builder.config.dry_run {\n             return;\n         }\n         let build = builder.build;\n@@ -450,7 +452,7 @@ impl Step for Openssl {\n     }\n \n     fn run(self, builder: &Builder) {\n-        if cfg!(test) {\n+        if builder.config.dry_run {\n             return;\n         }\n         let build = builder.build;"}, {"sha": "2fb84db4d897e15d4193e6db4033349d03b683ae", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -1042,6 +1042,7 @@ impl Step for DocTest {\n         let _time = util::timeit();\n         let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n+        let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n@@ -1058,7 +1059,13 @@ impl Step for DocTest {\n                 continue;\n             }\n \n-            let test_result = markdown_test(builder, compiler, &p);\n+            files.push(p);\n+        }\n+\n+        files.sort();\n+\n+        for file in files {\n+            let test_result = markdown_test(builder, compiler, &file);\n             if self.is_ext_doc {\n                 let toolstate = if test_result {\n                     ToolState::TestPass"}, {"sha": "0b1616b9b4f90e419170e1ee98734b2d2cc9ff3e", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -17,7 +17,7 @@ use std::slice::SliceConcatExt;\n use Mode;\n use Compiler;\n use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{copy, exe, add_lib_path};\n+use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp};\n use native;\n use channel::GitInfo;\n@@ -207,7 +207,7 @@ impl Step for ToolBuild {\n             let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n                 .join(exe(tool, &compiler.host));\n             let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            copy(&cargo_out, &bin);\n+            build.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -443,7 +443,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            copy(&tool_rustdoc, &bin_rustdoc);\n+            build.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc"}, {"sha": "8a64b07496c96fd185fb956c09819866081780ce", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 5, "deletions": 101, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a727447f5927ac0a186af4504f8a11014f42b1da/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=a727447f5927ac0a186af4504f8a11014f42b1da", "patch": "@@ -15,13 +15,13 @@\n \n use std::env;\n use std::str;\n-use std::fs::{self, File, OpenOptions};\n-use std::io::{self, Read, Write, Seek, SeekFrom};\n+use std::fs;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use filetime::{self, FileTime};\n+use config::Config;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -32,102 +32,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`\n-pub fn copy(src: &Path, dst: &Path) {\n-    let _ = fs::remove_file(&dst);\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    if let Ok(()) = fs::hard_link(src, dst) {\n-        return\n-    }\n-    if let Err(e) = fs::copy(src, dst) {\n-        panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-               dst.display(), e)\n-    }\n-    let metadata = t!(src.metadata());\n-    t!(fs::set_permissions(dst, metadata.permissions()));\n-    let atime = FileTime::from_last_access_time(&metadata);\n-    let mtime = FileTime::from_last_modification_time(&metadata);\n-    t!(filetime::set_file_times(dst, atime, mtime));\n-}\n-\n-/// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n-/// new string for each replacement.)\n-pub fn replace_in_file(path: &Path, replacements: &[(&str, &str)]) {\n-    let mut contents = String::new();\n-    let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n-    t!(file.read_to_string(&mut contents));\n-    for &(target, replacement) in replacements {\n-        contents = contents.replace(target, replacement);\n-    }\n-    t!(file.seek(SeekFrom::Start(0)));\n-    t!(file.set_len(0));\n-    t!(file.write_all(contents.as_bytes()));\n-}\n-\n-pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n-    let mut paths = Vec::new();\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in compile.rs).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = PathBuf::from(t!(str::from_utf8(part)));\n-        paths.push(path);\n-    }\n-    paths\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called.\n-pub fn cp_r(src: &Path, dst: &Path) {\n-    for f in t!(fs::read_dir(src)) {\n-        let f = t!(f);\n-        let path = f.path();\n-        let name = path.file_name().unwrap();\n-        let dst = dst.join(name);\n-        if t!(f.file_type()).is_dir() {\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&path, &dst);\n-        } else {\n-            let _ = fs::remove_file(&dst);\n-            copy(&path, &dst);\n-        }\n-    }\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called. Unwanted files or directories can be skipped\n-/// by returning `false` from the filter function.\n-pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n-    // Inner function does the actual work\n-    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n-            let path = f.path();\n-            let name = path.file_name().unwrap();\n-            let dst = dst.join(name);\n-            let relative = relative.join(name);\n-            // Only copy file or directory if the filter function returns true\n-            if filter(&relative) {\n-                if t!(f.file_type()).is_dir() {\n-                    let _ = fs::remove_dir_all(&dst);\n-                    t!(fs::create_dir(&dst));\n-                    recurse(&path, &dst, &relative, filter);\n-                } else {\n-                    let _ = fs::remove_file(&dst);\n-                    copy(&path, &dst);\n-                }\n-            }\n-        }\n-    }\n-    // Immediately recurse with an empty relative path\n-    recurse(src, dst, Path::new(\"\"), filter)\n-}\n-\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n@@ -214,8 +118,8 @@ impl Drop for TimeIt {\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n-pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n-    if cfg!(test) { return Ok(()); }\n+pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n+    if config.dry_run { return Ok(()); }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n "}]}