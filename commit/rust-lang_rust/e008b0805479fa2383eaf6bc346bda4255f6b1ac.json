{"sha": "e008b0805479fa2383eaf6bc346bda4255f6b1ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMDhiMDgwNTQ3OWZhMjM4M2VhZjZiYzM0NmJkYTQyNTVmNmIxYWM=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T20:38:19Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T20:38:19Z"}, "message": "Support associated consts", "tree": {"sha": "c2c2f9c87a947aeef9e333fa265552c4bf7228af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2c2f9c87a947aeef9e333fa265552c4bf7228af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e008b0805479fa2383eaf6bc346bda4255f6b1ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e008b0805479fa2383eaf6bc346bda4255f6b1ac", "html_url": "https://github.com/rust-lang/rust/commit/e008b0805479fa2383eaf6bc346bda4255f6b1ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e008b0805479fa2383eaf6bc346bda4255f6b1ac/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ccf8b746ab2fd18d1f617a5236ac9851facf0fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccf8b746ab2fd18d1f617a5236ac9851facf0fa", "html_url": "https://github.com/rust-lang/rust/commit/3ccf8b746ab2fd18d1f617a5236ac9851facf0fa"}], "stats": {"total": 151, "additions": 133, "deletions": 18}, "files": [{"sha": "903f11e4fa65a21598604f27fbfefb8980540f3d", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 133, "deletions": 18, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e008b0805479fa2383eaf6bc346bda4255f6b1ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e008b0805479fa2383eaf6bc346bda4255f6b1ac/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e008b0805479fa2383eaf6bc346bda4255f6b1ac", "patch": "@@ -4,8 +4,8 @@ use crate::{\n };\n use hir::{\n     db::{DefDatabase, HirDatabase},\n-    AsAssocItem, AssocItem, AssocItemContainer, Crate, Function, ModPath, Module, ModuleDef,\n-    PathResolution, SourceAnalyzer, Trait, Type,\n+    AsAssocItem, AssocItem, AssocItemContainer, Crate, ModPath, Module, ModuleDef, PathResolution,\n+    SourceAnalyzer, Trait, Type,\n };\n use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n use ra_prof::profile;\n@@ -115,7 +115,7 @@ impl AutoImportAssets {\n         match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name) => name,\n             ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n-            ImportCandidate::TraitAssocItem(_, trait_function_name) => trait_function_name,\n+            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n             ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n         }\n     }\n@@ -126,8 +126,8 @@ impl AutoImportAssets {\n             ImportCandidate::QualifierStart(qualifier_start) => {\n                 format!(\"Import {}\", qualifier_start)\n             }\n-            ImportCandidate::TraitAssocItem(_, trait_function_name) => {\n-                format!(\"Import a trait for item {}\", trait_function_name)\n+            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n+                format!(\"Import a trait for item {}\", trait_assoc_item_name)\n             }\n             ImportCandidate::TraitMethod(_, trait_method_name) => {\n                 format!(\"Import a trait for method {}\", trait_method_name)\n@@ -142,16 +142,24 @@ impl AutoImportAssets {\n             .find_imports(&self.get_search_query())\n             .into_iter()\n             .map(|module_def| match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(function_callee, _) => {\n+                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n+                    let located_assoc_item = match module_def {\n+                        ModuleDef::Function(located_function) => {\n+                            Some(AssocItem::Function(located_function))\n+                        }\n+                        ModuleDef::Const(located_const) => Some(AssocItem::Const(located_const)),\n+                        _ => None,\n+                    };\n+\n                     let mut applicable_traits = Vec::new();\n-                    if let ModuleDef::Function(located_function) = module_def {\n+                    if let Some(located_assoc_item) = located_assoc_item {\n                         let trait_candidates: FxHashSet<_> =\n-                            Self::get_trait_candidates(db, located_function, current_crate)\n+                            Self::get_trait_candidates(db, located_assoc_item, current_crate)\n                                 .into_iter()\n                                 .map(|trait_candidate| trait_candidate.into())\n                                 .collect();\n                         if !trait_candidates.is_empty() {\n-                            function_callee.iterate_path_candidates(\n+                            assoc_item_type.iterate_path_candidates(\n                                 db,\n                                 current_crate,\n                                 &trait_candidates,\n@@ -175,11 +183,14 @@ impl AutoImportAssets {\n                 ImportCandidate::TraitMethod(function_callee, _) => {\n                     let mut applicable_traits = Vec::new();\n                     if let ModuleDef::Function(located_function) = module_def {\n-                        let trait_candidates: FxHashSet<_> =\n-                            Self::get_trait_candidates(db, located_function, current_crate)\n-                                .into_iter()\n-                                .map(|trait_candidate| trait_candidate.into())\n-                                .collect();\n+                        let trait_candidates: FxHashSet<_> = Self::get_trait_candidates(\n+                            db,\n+                            AssocItem::Function(located_function),\n+                            current_crate,\n+                        )\n+                        .into_iter()\n+                        .map(|trait_candidate| trait_candidate.into())\n+                        .collect();\n                         if !trait_candidates.is_empty() {\n                             function_callee.iterate_method_candidates(\n                                 db,\n@@ -215,7 +226,7 @@ impl AutoImportAssets {\n \n     fn get_trait_candidates(\n         db: &RootDatabase,\n-        called_function: Function,\n+        called_assoc_item: AssocItem,\n         root_crate: Crate,\n     ) -> FxHashSet<Trait> {\n         let _p = profile(\"auto_import::get_trait_candidates\");\n@@ -235,7 +246,7 @@ impl AutoImportAssets {\n                             if trait_candidate\n                                 .items(db)\n                                 .into_iter()\n-                                .any(|item| item == AssocItem::Function(called_function)) =>\n+                                .any(|item| item == called_assoc_item) =>\n                         {\n                             Some(trait_candidate)\n                         }\n@@ -302,9 +313,9 @@ impl ImportCandidate {\n                 } else {\n                     source_analyzer.resolve_path(db, &qualifier)?\n                 };\n-                if let PathResolution::Def(ModuleDef::Adt(function_callee)) = qualifier_resolution {\n+                if let PathResolution::Def(ModuleDef::Adt(assoc_item_path)) = qualifier_resolution {\n                     Some(ImportCandidate::TraitAssocItem(\n-                        function_callee.ty(db),\n+                        assoc_item_path.ty(db),\n                         segment.syntax().to_string(),\n                     ))\n                 } else {\n@@ -580,6 +591,39 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn associated_struct_const() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestStruct;\n+\n+            mod test_mod {\n+                pub struct TestStruct {}\n+                impl TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn associated_trait_function() {\n         check_assist(\n@@ -651,6 +695,77 @@ mod tests {\n         )\n     }\n \n+    #[test]\n+    fn associated_trait_const() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+            r\"\n+            use test_mod::TestTrait;\n+\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            fn main() {\n+                test_mod::TestStruct::TEST_CONST<|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_imported_trait_for_const() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod test_mod {\n+                pub trait TestTrait {\n+                    const TEST_CONST: u8;\n+                }\n+                pub trait TestTrait2 {\n+                    const TEST_CONST: f64;\n+                }\n+                pub enum TestEnum {\n+                    One,\n+                    Two,\n+                }\n+                impl TestTrait2 for TestEnum {\n+                    const TEST_CONST: f64 = 42.0;\n+                }\n+                impl TestTrait for TestEnum {\n+                    const TEST_CONST: u8 = 42;\n+                }\n+            }\n+\n+            use test_mod::TestTrait2;\n+            fn main() {\n+                test_mod::TestEnum::TEST_CONST<|>;\n+            }\n+            \",\n+        )\n+    }\n+\n     #[test]\n     fn trait_method() {\n         check_assist("}]}