{"sha": "54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "node_id": "C_kwDOAAsO6NoAKDU0YWIzNTdhNWIzMDQxYWNmNzdjZmNiOTlkZGRkYWRmOTQ1ZmU1YWE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-18T02:27:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-18T02:27:14Z"}, "message": "ptr_get_alloc_id: don't return an actual Pointer", "tree": {"sha": "366d5de71499fff3fb99aeef8ce233348c2ce5ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366d5de71499fff3fb99aeef8ce233348c2ce5ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "html_url": "https://github.com/rust-lang/rust/commit/54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54ab357a5b3041acf77cfcb99ddddadf945fe5aa/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad4e98ed7dc535d161886b17f7792501baa82c9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4e98ed7dc535d161886b17f7792501baa82c9b", "html_url": "https://github.com/rust-lang/rust/commit/ad4e98ed7dc535d161886b17f7792501baa82c9b"}], "stats": {"total": 59, "additions": 29, "deletions": 30}, "files": [{"sha": "4de2f3b9abbea96e3bb2bc484c94553b50da906c", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/54ab357a5b3041acf77cfcb99ddddadf945fe5aa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ab357a5b3041acf77cfcb99ddddadf945fe5aa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -255,14 +255,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // This will also call the access hooks.\n         self.mem_copy(\n-            ptr.into(),\n+            ptr,\n             Align::ONE,\n             new_ptr.into(),\n             Align::ONE,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate_ptr(ptr.into(), old_size_and_align, kind)?;\n+        self.deallocate_ptr(ptr, old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n@@ -274,7 +274,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -330,7 +330,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             *self.tcx,\n             &mut self.machine,\n             &mut alloc.extra,\n-            ptr.provenance,\n+            tag,\n             alloc_range(Size::ZERO, size),\n         )?;\n \n@@ -350,17 +350,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n+    ) -> InterpResult<'tcx, Option<(AllocId, Size, M::PointerTag)>> {\n         let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let (size, align) =\n                     self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n-                Ok((size, align, (alloc_id, offset, ptr)))\n+                Ok((size, align, (alloc_id, offset, tag)))\n             },\n         )\n     }\n@@ -404,7 +404,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         alloc_size: impl FnOnce(\n             AllocId,\n             Size,\n-            Pointer<M::PointerTag>,\n+            M::PointerTag,\n         ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n@@ -433,8 +433,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 None\n             }\n-            Ok((alloc_id, offset, ptr)) => {\n-                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, ptr)?;\n+            Ok((alloc_id, offset, tag)) => {\n+                let (alloc_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, tag)?;\n                 // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. Also check for overflow!\n                 if offset.checked_add(size, &self.tcx).map_or(true, |end| end > alloc_size) {\n@@ -450,10 +450,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n                     if M::force_int_for_alignment_check(self) {\n-                        let addr = Scalar::from_pointer(ptr, &self.tcx)\n-                            .to_machine_usize(&self.tcx)\n-                            .expect(\"ptr-to-int cast for align check should never fail\");\n-                        check_offset_align(addr, align)?;\n+                        assert!(M::PointerTag::OFFSET_IS_ADDR, \"ptr-to-int cast for align check should never fail\");\n+                        let (_, addr) = ptr.into_parts(); // we checked that offset is absolute\n+                        check_offset_align(addr.bytes(), align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n@@ -569,14 +568,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |alloc_id, offset, ptr| {\n+            |alloc_id, offset, tag| {\n                 let alloc = self.get_alloc_raw(alloc_id)?;\n-                Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n+                Ok((alloc.size(), alloc.align, (alloc_id, offset, tag, alloc)))\n             },\n         )?;\n-        if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n+        if let Some((alloc_id, offset, tag, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(*self.tcx, &self.machine, &alloc.extra, ptr.provenance, range)?;\n+            M::memory_read(*self.tcx, &self.machine, &alloc.extra, tag, range)?;\n             Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n@@ -631,13 +630,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n-        if let Some((alloc_id, offset, ptr)) = parts {\n+        if let Some((alloc_id, offset, tag)) = parts {\n             let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n             let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(tcx, machine, &mut alloc.extra, ptr.provenance, range)?;\n+            M::memory_written(tcx, machine, &mut alloc.extra, tag, range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -732,7 +731,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n+        let (alloc_id, offset, _tag) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n@@ -1009,16 +1008,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let Some((src_alloc_id, src_offset, src)) = src_parts else {\n+        let Some((src_alloc_id, src_offset, src_tag)) = src_parts else {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n         let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(*tcx, &self.machine, &src_alloc.extra, src.provenance, src_range)?;\n+        M::memory_read(*tcx, &self.machine, &src_alloc.extra, src_tag, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n+        let Some((dest_alloc_id, dest_offset, dest_tag)) = dest_parts else {\n             // Zero-sized *destination*.\n             return Ok(());\n         };\n@@ -1040,7 +1039,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Destination alloc preparations and access hooks.\n         let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n-        M::memory_written(*tcx, extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n+        M::memory_written(*tcx, extra, &mut dest_alloc.extra, dest_tag, dest_range)?;\n         let dest_bytes = dest_alloc\n             .get_bytes_mut_ptr(&tcx, dest_range)\n             .map_err(|e| e.to_interp_error(dest_alloc_id))?\n@@ -1159,11 +1158,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n+    ) -> Result<(AllocId, Size, M::PointerTag), u64> {\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => {\n                 let (alloc_id, offset) = M::ptr_get_alloc(self, ptr);\n-                Ok((alloc_id, offset, ptr))\n+                Ok((alloc_id, offset, ptr.provenance))\n             }\n             Err(addr) => Err(addr.bytes()),\n         }\n@@ -1174,7 +1173,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n-    ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n+    ) -> InterpResult<'tcx, (AllocId, Size, M::PointerTag)> {\n         self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })"}, {"sha": "71d29be97d5ec38e99b544bee0532d2c58ad4400", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54ab357a5b3041acf77cfcb99ddddadf945fe5aa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ab357a5b3041acf77cfcb99ddddadf945fe5aa/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=54ab357a5b3041acf77cfcb99ddddadf945fe5aa", "patch": "@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n+            if let Ok((alloc_id, _offset, _tag)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {"}]}