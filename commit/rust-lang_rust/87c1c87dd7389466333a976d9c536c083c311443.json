{"sha": "87c1c87dd7389466333a976d9c536c083c311443", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YzFjODdkZDczODk0NjYzMzNhOTc2ZDljNTM2YzA4M2MzMTE0NDM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-10T03:56:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:47Z"}, "message": "Make drop-glue translation collector-driven.", "tree": {"sha": "6b405b0a4eca4d2fa03ab6784991842ac6d6b6c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b405b0a4eca4d2fa03ab6784991842ac6d6b6c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c1c87dd7389466333a976d9c536c083c311443", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c1c87dd7389466333a976d9c536c083c311443", "html_url": "https://github.com/rust-lang/rust/commit/87c1c87dd7389466333a976d9c536c083c311443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c1c87dd7389466333a976d9c536c083c311443/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c8c94b8488405ac3ade9c358e00fe96da9c72b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8c94b8488405ac3ade9c358e00fe96da9c72b8", "html_url": "https://github.com/rust-lang/rust/commit/6c8c94b8488405ac3ade9c358e00fe96da9c72b8"}], "stats": {"total": 328, "additions": 178, "deletions": 150}, "files": [{"sha": "6c2a09f8060c5a4b36fb87e1701d74bff6f62ed7", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -229,6 +229,7 @@ impl ArgType {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n+#[derive(Clone)]\n pub struct FnType {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType>,"}, {"sha": "ebb6e0baf20a00e8c837a18249c5e9853e706caf", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -304,6 +304,19 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n+pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                                    t: ty::Ty<'tcx>,\n+                                                    prefix: &str)\n+                                                    -> String {\n+    let empty_def_path = DefPath {\n+        data: vec![],\n+        krate: cstore::LOCAL_CRATE,\n+    };\n+    let hash = get_symbol_hash(scx, &empty_def_path, t, &[]);\n+    let path = [token::intern_and_get_ident(prefix)];\n+    mangle(path.iter().cloned(), Some(&hash[..]))\n+}\n+\n /// Only symbols that are invisible outside their compilation unit should use a\n /// name generated by this function.\n pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "5dc319aa5f9bc1c9373bd2ec549937a3d79ff33a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -2182,52 +2182,6 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     }\n }\n \n-/// Set the appropriate linkage for an LLVM `ValueRef` (function or global).\n-/// If the `llval` is the direct translation of a specific Rust item, `id`\n-/// should be set to the `NodeId` of that item.  (This mapping should be\n-/// 1-to-1, so monomorphizations and drop/visit glue should have `id` set to\n-/// `None`.)\n-pub fn update_linkage(ccx: &CrateContext,\n-                      llval: ValueRef,\n-                      id: Option<ast::NodeId>) {\n-    if let Some(id) = id {\n-        let item = ccx.tcx().map.get(id);\n-        if let hir_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(&i.attrs, \"linkage\") {\n-                if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                    llvm::SetLinkage(llval, linkage);\n-                } else {\n-                    ccx.sess().span_fatal(i.span, \"invalid linkage specified\");\n-                }\n-                return;\n-            }\n-        }\n-    }\n-\n-    let (is_reachable, is_generic) = if let Some(id) = id {\n-        (ccx.reachable().contains(&id), false)\n-    } else {\n-        (false, true)\n-    };\n-\n-    // We need external linkage for items reachable from other translation units, this include\n-    // other codegen units in case of parallel compilations.\n-    if is_reachable || ccx.sess().opts.cg.codegen_units > 1 {\n-        if is_generic {\n-            // This only happens with multiple codegen units, in which case we need to use weak_odr\n-            // linkage because other crates might expose the same symbol. We cannot use\n-            // linkonce_odr here because the symbol might then get dropped before the other codegen\n-            // units get to link it.\n-            llvm::SetUniqueComdat(ccx.llmod(), llval);\n-            llvm::SetLinkage(llval, llvm::WeakODRLinkage);\n-        } else {\n-            llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-        }\n-    } else {\n-        llvm::SetLinkage(llval, llvm::InternalLinkage);\n-    }\n-}\n-\n pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n@@ -2673,24 +2627,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // ... and now that we have everything pre-defined, fill out those definitions.\n     for ccx in crate_context_list.iter() {\n-        for (&trans_item, _) in &ccx.codegen_unit().items {\n-            match trans_item {\n-                TransItem::Static(node_id) => {\n-                    let item = ccx.tcx().map.expect_item(node_id);\n-                    if let hir::ItemStatic(_, m, ref expr) = item.node {\n-                        match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n-                            Ok(_) => { /* Cool, everything's alright. */ },\n-                            Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n-                        };\n-                    } else {\n-                        span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n-                    }\n-                }\n-                TransItem::Fn(instance) => {\n-                    trans_instance(&ccx, instance);\n-                }\n-                _ => { }\n-            }\n+        for (trans_item, _) in &ccx.codegen_unit().items {\n+           trans_item.define(&ccx);\n         }\n     }\n \n@@ -2927,7 +2865,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(scx);\n+                let mut output = i.to_string(scx.tcx());\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);"}, {"sha": "aff50e5e1f404c6aba4e0caf64d01c0104ae9acf", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -325,7 +325,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n@@ -396,7 +396,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -637,7 +637,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                             let operand_ty = monomorphize::apply_param_substs(tcx,\n                                                                               self.param_substs,\n                                                                               &mt.ty);\n-                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(operand_ty)));\n+                            let ty = glue::get_drop_glue_type(tcx, operand_ty);\n+                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                         } else {\n                             bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n                         }\n@@ -1271,7 +1272,7 @@ pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n         let mut item_keys = FnvHashMap();\n \n         for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(scx);\n+            let k = item.to_string(scx.tcx());\n \n             if item_keys.contains_key(&k) {\n                 let prev: (TransItem, TransItemState) = item_keys[&k];\n@@ -1299,7 +1300,7 @@ pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n     let mut generated = FnvHashSet();\n \n     for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(scx);\n+        let item_key = item.to_string(scx.tcx());\n \n         match *item_state {\n             TransItemState::PredictedAndGenerated => {"}, {"sha": "7f6e8fa035ab735e3dff6b8fd0f1c81b117dc9e2", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -36,7 +36,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -46,6 +46,7 @@ use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n+use abi::FnType;\n \n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n@@ -80,8 +81,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     mir_map: &'a MirMap<'tcx>,\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n-    available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n \n     translation_items: RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>>,\n@@ -99,7 +98,7 @@ pub struct LocalCrateContext<'tcx> {\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -413,8 +412,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             },\n             check_overflow: check_overflow,\n             check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n-            available_monomorphizations: RefCell::new(FnvHashSet()),\n-            available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashMap()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n@@ -730,7 +727,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().fn_pointer_shims\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self)\n+                          -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>> {\n         &self.local().drop_glues\n     }\n \n@@ -816,14 +814,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.stats\n     }\n \n-    pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n-        &self.shared.available_monomorphizations\n-    }\n-\n-    pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {\n-        &self.shared.available_drop_glues\n-    }\n-\n     pub fn int_type(&self) -> Type {\n         self.local().int_type\n     }"}, {"sha": "2746d3fb6b0b6788e76397504e968b60d460491f", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -138,24 +138,34 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n     }\n }\n \n-\n /// Declare a Rust function with an intention to define it.\n ///\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    name: &str,\n-                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n+pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           name: &str,\n+                           fn_type: ty::Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n         ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        let llfn = declare_fn(ccx, name, fn_type);\n-        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n-        llfn\n+        declare_fn(ccx, name, fn_type)\n     }\n }\n \n+/// Declare a Rust function with an intention to define it.\n+///\n+/// Use this function when you intend to define a function. This function will\n+/// return panic if the name already has a definition associated with it. This\n+/// can happen with #[no_mangle] or #[export_name], for example.\n+pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    name: &str,\n+                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n+    let llfn = define_fn(ccx, name, fn_type);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+    llfn\n+}\n+\n \n /// Get declared value by name.\n pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {"}, {"sha": "30eb71a90064c45e122a9e6c0b3665e87bfdb6fd", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -14,15 +14,12 @@\n \n use std;\n \n-use attributes;\n-use back::symbol_names;\n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use abi::{Abi, FnType};\n use adt;\n use adt::GetDtorType; // for tcx.dtor_type()\n use base::*;\n@@ -33,7 +30,6 @@ use cleanup::CleanupMethods;\n use collector;\n use common::*;\n use debuginfo::DebugLoc;\n-use declare;\n use expr;\n use machine::*;\n use monomorphize;\n@@ -236,57 +232,28 @@ impl<'tcx> DropGlueKind<'tcx> {\n \n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {:?}\", g);\n     let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n-    debug!(\"drop glue type {:?}\", g);\n     match ccx.drop_glues().borrow().get(&g) {\n-        Some(&glue) => return glue,\n-        _ => { }\n+        Some(&(glue, _)) => glue,\n+        None => { bug!(\"Could not find drop glue for {:?} -- {} -- {}\",\n+                       g,\n+                       TransItem::DropGlue(g).to_raw_string(),\n+                       ccx.codegen_unit().name) }\n     }\n-    let t = g.ty();\n+}\n \n+pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     g: DropGlueKind<'tcx>) {\n     let tcx = ccx.tcx();\n-    let sig = ty::FnSig {\n-        inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n-        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n-        variadic: false,\n-    };\n-    // Create a FnType for fn(*mut i8) and substitute the real type in\n-    // later - that prevents FnType from splitting fat pointers up.\n-    let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n-    fn_ty.args[0].original_ty = type_of(ccx, t).ptr_to();\n-    let llfnty = fn_ty.llvm_type(ccx);\n-\n-    // To avoid infinite recursion, don't `make_drop_glue` until after we've\n-    // added the entry to the `drop_glues` cache.\n-    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n-        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty);\n-        ccx.drop_glues().borrow_mut().insert(g, llfn);\n-        return llfn;\n-    };\n-\n-    let suffix = match g {\n-        DropGlueKind::Ty(_) => \"drop\",\n-        DropGlueKind::TyContents(_) => \"drop_contents\",\n-    };\n-\n-    let fn_nm = symbol_names::internal_name_from_type_and_suffix(ccx, t, suffix);\n-    assert!(declare::get_defined_value(ccx, &fn_nm).is_none());\n-    let llfn = declare::declare_cfn(ccx, &fn_nm, llfnty);\n-    attributes::set_frame_pointer_elimination(ccx, llfn);\n-    ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n-    ccx.drop_glues().borrow_mut().insert(g, llfn);\n-\n-    let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n+    assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n+    let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n \n     let bcx = fcx.init(false, None);\n \n-    update_linkage(ccx, llfn, None);\n-\n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n@@ -298,10 +265,9 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n     fcx.finish(bcx, DebugLoc::None);\n-\n-    llfn\n }\n \n+\n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n                                       struct_data: ValueRef)"}, {"sha": "a0360a8ed226ecbe26e840d327458f6f1e3c111b", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -165,10 +165,14 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                 trans_items,\n                                                                 reachable);\n \n+    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -177,6 +181,9 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // local functions the definition of which is marked with #[inline].\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n+\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n+\n     post_inlining.0\n }\n \n@@ -484,3 +491,23 @@ fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString\n         NUMBERED_CODEGEN_UNIT_MARKER,\n         index)[..])\n }\n+\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               label: &str,\n+                               cgus: I)\n+    where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n+          'tcx: 'a + 'b\n+{\n+    if cfg!(debug_assertions) {\n+        debug!(\"{}\", label);\n+        for cgu in cgus {\n+            debug!(\"CodegenUnit {}:\", cgu.name);\n+\n+            for (trans_item, linkage) in &cgu.items {\n+                debug!(\" - {} [{:?}]\", trans_item.to_string(tcx), linkage);\n+            }\n+\n+            debug!(\"\");\n+        }\n+    }\n+}"}, {"sha": "a07deda2b1e5e8c20c7fda052999499d425b6cc9", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 95, "deletions": 13, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c1c87dd7389466333a976d9c536c083c311443/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=87c1c87dd7389466333a976d9c536c083c311443", "patch": "@@ -16,7 +16,8 @@\n \n use attributes;\n use base;\n-use context::{SharedCrateContext, CrateContext};\n+use consts;\n+use context::CrateContext;\n use declare;\n use glue::DropGlueKind;\n use llvm;\n@@ -32,7 +33,9 @@ use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n use syntax::parse::token;\n use type_of;\n-\n+use glue;\n+use abi::{Abi, FnType};\n+use back::symbol_names;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n@@ -64,20 +67,63 @@ impl<'tcx> Hash for TransItem<'tcx> {\n \n impl<'a, 'tcx> TransItem<'tcx> {\n \n+    pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n+\n+        debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n+                  self.to_string(ccx.tcx()),\n+                  self.to_raw_string(),\n+                  ccx.codegen_unit().name);\n+\n+        match *self {\n+            TransItem::Static(node_id) => {\n+                let item = ccx.tcx().map.expect_item(node_id);\n+                if let hir::ItemStatic(_, m, ref expr) = item.node {\n+                    match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n+                        Ok(_) => { /* Cool, everything's alright. */ },\n+                        Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+                    };\n+                } else {\n+                    span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n+                }\n+            }\n+            TransItem::Fn(instance) => {\n+                base::trans_instance(&ccx, instance);\n+            }\n+            TransItem::DropGlue(dg) => {\n+                glue::implement_drop_glue(&ccx, dg);\n+            }\n+        }\n+\n+        debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n+    }\n+\n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n                      linkage: llvm::Linkage) {\n+        debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n+\n         match *self {\n             TransItem::Static(node_id) => {\n                 TransItem::predefine_static(ccx, node_id, linkage);\n             }\n             TransItem::Fn(instance) => {\n                 TransItem::predefine_fn(ccx, instance, linkage);\n             }\n-            _ => {\n-                // Not yet implemented\n+            TransItem::DropGlue(dg) => {\n+                TransItem::predefine_drop_glue(ccx, dg, linkage);\n             }\n         }\n+\n+        debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n+               self.to_string(ccx.tcx()),\n+               self.to_raw_string(),\n+               ccx.codegen_unit().name);\n     }\n \n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n@@ -93,7 +139,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             }) => {\n                 let instance = Instance::mono(ccx.shared(), def_id);\n                 let sym = instance.symbol_name(ccx.shared());\n-                debug!(\"making {}\", sym);\n+                debug!(\"symbol {}\", sym);\n \n                 let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n                     ccx.sess().span_fatal(span,\n@@ -110,8 +156,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n                     instance: Instance<'tcx>,\n                     linkage: llvm::Linkage) {\n-        let unit = ccx.codegen_unit();\n-        debug!(\"predefine_fn[cg={}](instance={:?})\", &unit.name[..], instance);\n         assert!(!instance.substs.types.needs_infer() &&\n                 !instance.substs.types.has_param_types());\n \n@@ -143,10 +187,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 ref attrs, node: hir::ImplItemKind::Method(..), ..\n             }) => {\n                 let symbol = instance.symbol_name(ccx.shared());\n-                let lldecl = declare::declare_fn(ccx, &symbol, mono_ty);\n+                debug!(\"symbol {}\", symbol);\n \n-                attributes::from_fn_attrs(ccx, attrs, lldecl);\n+                let lldecl = declare::declare_fn(ccx, &symbol, mono_ty);\n                 llvm::SetLinkage(lldecl, linkage);\n+                attributes::from_fn_attrs(ccx, attrs, lldecl);\n                 base::set_link_section(ccx, lldecl, attrs);\n \n                 ccx.instances().borrow_mut().insert(instance, lldecl);\n@@ -156,6 +201,39 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     }\n \n+    fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,\n+                           dg: glue::DropGlueKind<'tcx>,\n+                           linkage: llvm::Linkage) {\n+        let tcx = ccx.tcx();\n+        assert_eq!(dg.ty(), glue::get_drop_glue_type(tcx, dg.ty()));\n+        let t = dg.ty();\n+\n+        let sig = ty::FnSig {\n+            inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n+            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            variadic: false,\n+        };\n+\n+        // Create a FnType for fn(*mut i8) and substitute the real type in\n+        // later - that prevents FnType from splitting fat pointers up.\n+        let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+        fn_ty.args[0].original_ty = type_of::type_of(ccx, t).ptr_to();\n+        let llfnty = fn_ty.llvm_type(ccx);\n+\n+        let prefix = match dg {\n+            DropGlueKind::Ty(_) => \"drop\",\n+            DropGlueKind::TyContents(_) => \"drop_contents\",\n+        };\n+\n+        let symbol =\n+            symbol_names::exported_name_from_type_and_prefix(ccx.shared(), t, prefix);\n+        debug!(\" symbol: {}\", symbol);\n+        assert!(declare::get_defined_value(ccx, &symbol).is_none());\n+        let llfn = declare::declare_cfn(ccx, &symbol, llfnty);\n+        attributes::set_frame_pointer_elimination(ccx, llfn);\n+        llvm::SetLinkage(llfn, linkage);\n+        ccx.drop_glues().borrow_mut().insert(dg, (llfn, fn_ty));\n+    }\n \n     pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n@@ -216,8 +294,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string(&self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n-        let tcx = scx.tcx();\n+    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         let hir_map = &tcx.map;\n \n         return match *self {\n@@ -235,7 +312,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(scx, def_id);\n+                let instance = Instance::new(def_id,\n+                                             tcx.mk_substs(subst::Substs::empty()));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n         };\n@@ -254,7 +332,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n     pub fn to_raw_string(&self) -> String {\n         match *self {\n             TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n+                let prefix = match dg {\n+                    DropGlueKind::Ty(_) => \"Ty\",\n+                    DropGlueKind::TyContents(_) => \"TyContents\",\n+                };\n+                format!(\"DropGlue({}: {})\", prefix, dg.ty() as *const _ as usize)\n             }\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\","}]}