{"sha": "aa33a6fca27f0b9183146e191ba565e37e7644eb", "node_id": "C_kwDOAAsO6NoAKGFhMzNhNmZjYTI3ZjBiOTE4MzE0NmUxOTFiYTU2NWUzN2U3NjQ0ZWI", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-03-09T18:06:44Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-04-04T15:50:07Z"}, "message": "Move and document escape_literal function", "tree": {"sha": "1f3d4cd6b56f5cff83bd77c19e2592283675c36a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f3d4cd6b56f5cff83bd77c19e2592283675c36a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa33a6fca27f0b9183146e191ba565e37e7644eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa33a6fca27f0b9183146e191ba565e37e7644eb", "html_url": "https://github.com/rust-lang/rust/commit/aa33a6fca27f0b9183146e191ba565e37e7644eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa33a6fca27f0b9183146e191ba565e37e7644eb/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e813b6d6e1ef76a94a68f98316d76517d7ce0719", "url": "https://api.github.com/repos/rust-lang/rust/commits/e813b6d6e1ef76a94a68f98316d76517d7ce0719", "html_url": "https://github.com/rust-lang/rust/commit/e813b6d6e1ef76a94a68f98316d76517d7ce0719"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "212fea47437d20a682f5ad06dce5186a41cd6ac5", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aa33a6fca27f0b9183146e191ba565e37e7644eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa33a6fca27f0b9183146e191ba565e37e7644eb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=aa33a6fca27f0b9183146e191ba565e37e7644eb", "patch": "@@ -89,6 +89,28 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n+/// Makes a valid string literal from a string by escaping special characters (\" and \\),\n+/// unless they are already escaped.\n+fn escape_literal(s: &str) -> String {\n+    let mut escaped = String::with_capacity(s.len());\n+    let mut chrs = s.chars().peekable();\n+    while let Some(first) = chrs.next() {\n+        match (first, chrs.peek()) {\n+            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n+                escaped.push('\\\\');\n+                escaped.push(delim);\n+                chrs.next();\n+            }\n+            ('\"' | '\\'', _) => {\n+                escaped.push('\\\\');\n+                escaped.push(first)\n+            }\n+            (c, _) => escaped.push(c),\n+        };\n+    }\n+    escaped\n+}\n+\n /// A helper for building type related errors. The `typeck_results`\n /// field is only populated during an in-progress typeck.\n /// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n@@ -1904,25 +1926,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         terr: TypeError<'tcx>,\n     ) -> Vec<Error0308Subdiags> {\n         use crate::traits::ObligationCauseCode::MatchExpressionArm;\n-        fn escape_literal(s: &str) -> String {\n-            let mut escaped = String::with_capacity(s.len());\n-            let mut chrs = s.chars().peekable();\n-            while let Some(first) = chrs.next() {\n-                match (first, chrs.peek()) {\n-                    ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n-                        escaped.push('\\\\');\n-                        escaped.push(delim);\n-                        chrs.next();\n-                    }\n-                    ('\"' | '\\'', _) => {\n-                        escaped.push('\\\\');\n-                        escaped.push(first)\n-                    }\n-                    (c, _) => escaped.push(c),\n-                };\n-            }\n-            escaped\n-        }\n         let mut suggestions = Vec::new();\n         let span = trace.cause.span();\n         if let Some((expected, found)) = trace.values.ty() {"}]}