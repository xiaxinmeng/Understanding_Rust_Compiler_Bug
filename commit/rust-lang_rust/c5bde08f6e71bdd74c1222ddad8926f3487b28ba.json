{"sha": "c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YmRlMDhmNmU3MWJkZDc0YzEyMjJkZGFkODkyNmYzNDg3YjI4YmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-07T15:42:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-07T15:42:26Z"}, "message": "Merge #9806\n\n9806: Add proc_macro crate for the 1.56 ABI r=lnicola a=alexjg\n\nI've copied the latest proc macro source from Rust nightly and modified it to compile on `stable`. This fixes #9795 . Almost everything here is uninteresting copy and paste, the interesting stuff is in `crates/proc_macro_srv/src/abis/mod.rs`. I've left the 1.55 ABI implementation in for now. We did discuss only supporting one nightly ABI so we may want to remove 1.55. That will break code which is pinned to older nightly releases but that seems acceptable to me, what do people think?\n\nCo-authored-by: Alex Good <alex@memoryandthought.me>", "tree": {"sha": "0c7b74f14e71663c5b56da6a397721bd558f9091", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c7b74f14e71663c5b56da6a397721bd558f9091"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhDqnjCRBK7hj4Ov3rIwAA2kMIAF2OV7U9UmuQhG9jwhLwxURL\nKOB6IDq6PaegThyxkUzsht1aHsiTOR6sUiH4/IDkg+aySwV6AZdLKEy94N2ThIbR\nNE37cXng0PmdEuHyk22eaFjlEbD2duwAcqZRIcV5slEIJZnSyHRVkBZUaJf9GZ3t\ndhAIvaD3xt2oXIMIix17g45c+qzDsdY8q+EwXGV4RXuXulDNaK24mx9mupPZ7Iee\nUotr35G1xpVwEyyv4qddEdo9dVjvmHaPEWzsGJARKYmz37n2DbDnbUuyur4cZ1AI\nhEK66Wr0NfPPHoiL98HtncS4bkLTTQkNFSEf3828l6pT/qS93bfCufPY7CAICTA=\n=sVTJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0c7b74f14e71663c5b56da6a397721bd558f9091\nparent a9f115b36f9d35a93b16d4b054980b3f3a133f3a\nparent b111357b546aa3a7a8ee337ac585772be6364363\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628350946 +0000\ncommitter GitHub <noreply@github.com> 1628350946 +0000\n\nMerge #9806\n\n9806: Add proc_macro crate for the 1.56 ABI r=lnicola a=alexjg\n\nI've copied the latest proc macro source from Rust nightly and modified it to compile on `stable`. This fixes #9795 . Almost everything here is uninteresting copy and paste, the interesting stuff is in `crates/proc_macro_srv/src/abis/mod.rs`. I've left the 1.55 ABI implementation in for now. We did discuss only supporting one nightly ABI so we may want to remove 1.55. That will break code which is pinned to older nightly releases but that seems acceptable to me, what do people think?\n\nCo-authored-by: Alex Good <alex@memoryandthought.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "html_url": "https://github.com/rust-lang/rust/commit/c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f115b36f9d35a93b16d4b054980b3f3a133f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f115b36f9d35a93b16d4b054980b3f3a133f3a", "html_url": "https://github.com/rust-lang/rust/commit/a9f115b36f9d35a93b16d4b054980b3f3a133f3a"}, {"sha": "b111357b546aa3a7a8ee337ac585772be6364363", "url": "https://api.github.com/repos/rust-lang/rust/commits/b111357b546aa3a7a8ee337ac585772be6364363", "html_url": "https://github.com/rust-lang/rust/commit/b111357b546aa3a7a8ee337ac585772be6364363"}], "stats": {"total": 4166, "additions": 4165, "deletions": 1}, "files": [{"sha": "921beca1438b40b2d412cca04856680a6cdffb08", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/mod.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,104 @@\n+//! Macro ABI for version 1.56 of rustc\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod proc_macro;\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod rustc_server;\n+use libloading::Library;\n+\n+use proc_macro_api::ProcMacroKind;\n+\n+use super::PanicMessage;\n+\n+pub(crate) struct Abi {\n+    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n+}\n+\n+impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n+    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n+        Self { message: p.as_str().map(|s| s.to_string()) }\n+    }\n+}\n+\n+impl Abi {\n+    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n+        let macros: libloading::Symbol<&&[proc_macro::bridge::client::ProcMacro]> =\n+            lib.get(symbol_name.as_bytes())?;\n+        Ok(Self { exported_macros: macros.to_vec() })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        let parsed_body = rustc_server::TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes.map_or(rustc_server::TokenStream::new(), |attr| {\n+            rustc_server::TokenStream::with_subtree(attr.clone())\n+        });\n+\n+        for proc_macro in &self.exported_macros {\n+            match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive {\n+                    trait_name, client, ..\n+                } if *trait_name == macro_name => {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        rustc_server::Rustc::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                        false,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                _ => continue,\n+            }\n+        }\n+\n+        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n+    }\n+\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.exported_macros\n+            .iter()\n+            .map(|proc_macro| match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "d82669d3e2336622942d127aaf5ca0c2ad501e9e", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/buffer.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,143 @@\n+//! Buffer management for same-process client<->server communication.\n+\n+use std::io::{self, Write};\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::slice;\n+\n+#[repr(C)]\n+pub struct Buffer<T: Copy> {\n+    data: *mut T,\n+    len: usize,\n+    capacity: usize,\n+    reserve: extern \"C\" fn(Buffer<T>, usize) -> Buffer<T>,\n+    drop: extern \"C\" fn(Buffer<T>),\n+}\n+\n+unsafe impl<T: Copy + Sync> Sync for Buffer<T> {}\n+unsafe impl<T: Copy + Send> Send for Buffer<T> {}\n+\n+impl<T: Copy> Default for Buffer<T> {\n+    fn default() -> Self {\n+        Self::from(vec![])\n+    }\n+}\n+\n+impl<T: Copy> Deref for Buffer<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.data as *const T, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> DerefMut for Buffer<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n+    }\n+}\n+\n+impl<T: Copy> Buffer<T> {\n+    pub(super) fn new() -> Self {\n+        Self::default()\n+    }\n+\n+    pub(super) fn clear(&mut self) {\n+        self.len = 0;\n+    }\n+\n+    pub(super) fn take(&mut self) -> Self {\n+        mem::take(self)\n+    }\n+\n+    // We have the array method separate from extending from a slice. This is\n+    // because in the case of small arrays, codegen can be more efficient\n+    // (avoiding a memmove call). With extend_from_slice, LLVM at least\n+    // currently is not able to make that optimization.\n+    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[T; N]) {\n+        if xs.len() > (self.capacity - self.len) {\n+            let b = self.take();\n+            *self = (b.reserve)(b, xs.len());\n+        }\n+        unsafe {\n+            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n+            self.len += xs.len();\n+        }\n+    }\n+\n+    pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n+        if xs.len() > (self.capacity - self.len) {\n+            let b = self.take();\n+            *self = (b.reserve)(b, xs.len());\n+        }\n+        unsafe {\n+            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n+            self.len += xs.len();\n+        }\n+    }\n+\n+    pub(super) fn push(&mut self, v: T) {\n+        // The code here is taken from Vec::push, and we know that reserve()\n+        // will panic if we're exceeding isize::MAX bytes and so there's no need\n+        // to check for overflow.\n+        if self.len == self.capacity {\n+            let b = self.take();\n+            *self = (b.reserve)(b, 1);\n+        }\n+        unsafe {\n+            *self.data.add(self.len) = v;\n+            self.len += 1;\n+        }\n+    }\n+}\n+\n+impl Write for Buffer<u8> {\n+    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n+        self.extend_from_slice(xs);\n+        Ok(xs.len())\n+    }\n+\n+    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n+        self.extend_from_slice(xs);\n+        Ok(())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Copy> Drop for Buffer<T> {\n+    fn drop(&mut self) {\n+        let b = self.take();\n+        (b.drop)(b);\n+    }\n+}\n+\n+impl<T: Copy> From<Vec<T>> for Buffer<T> {\n+    fn from(mut v: Vec<T>) -> Self {\n+        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n+        mem::forget(v);\n+\n+        // This utility function is nested in here because it can *only*\n+        // be safely called on `Buffer`s created by *this* `proc_macro`.\n+        fn to_vec<T: Copy>(b: Buffer<T>) -> Vec<T> {\n+            unsafe {\n+                let Buffer { data, len, capacity, .. } = b;\n+                mem::forget(b);\n+                Vec::from_raw_parts(data, len, capacity)\n+            }\n+        }\n+\n+        extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n+            let mut v = to_vec(b);\n+            v.reserve(additional);\n+            Buffer::from(v)\n+        }\n+\n+        extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n+            mem::drop(to_vec(b));\n+        }\n+\n+        Buffer { data, len, capacity, reserve, drop }\n+    }\n+}"}, {"sha": "ed0e91da36178c9a176139be56cce14cef2301cf", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/client.rs", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclient.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,485 @@\n+//! Client-side types.\n+\n+use super::*;\n+\n+macro_rules! define_handles {\n+    (\n+        'owned: $($oty:ident,)*\n+        'interned: $($ity:ident,)*\n+    ) => {\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub struct HandleCounters {\n+            $($oty: AtomicUsize,)*\n+            $($ity: AtomicUsize,)*\n+        }\n+\n+        impl HandleCounters {\n+            // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n+            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n+            extern \"C\" fn get() -> &'static Self {\n+                static COUNTERS: HandleCounters = HandleCounters {\n+                    $($oty: AtomicUsize::new(1),)*\n+                    $($ity: AtomicUsize::new(1),)*\n+                };\n+                &COUNTERS\n+            }\n+        }\n+\n+        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+        #[repr(C)]\n+        #[allow(non_snake_case)]\n+        pub(super) struct HandleStore<S: server::Types> {\n+            $($oty: handle::OwnedStore<S::$oty>,)*\n+            $($ity: handle::InternedStore<S::$ity>,)*\n+        }\n+\n+        impl<S: server::Types> HandleStore<S> {\n+            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n+                HandleStore {\n+                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n+                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n+                }\n+            }\n+        }\n+\n+        $(\n+            #[repr(C)]\n+            pub(crate) struct $oty(handle::Handle);\n+\n+            // Forward `Drop::drop` to the inherent `drop` method.\n+            impl Drop for $oty {\n+                fn drop(&mut self) {\n+                    $oty(self.0).drop();\n+                }\n+            }\n+\n+            impl<S> Encode<S> for $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    let handle = self.0;\n+                    mem::forget(self);\n+                    handle.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &$oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<'s, S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s Marked<S::$oty, $oty>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    &s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S> Encode<S> for &mut $oty {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<'s, S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n+                for &'s mut Marked<S::$oty, $oty>\n+            {\n+                fn decode(\n+                    r: &mut Reader<'_>,\n+                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n+                ) -> Self {\n+                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$oty, $oty>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$oty.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $oty {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                    $oty(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+\n+        $(\n+            #[repr(C)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+            pub(crate) struct $ity(handle::Handle);\n+\n+            impl<S> Encode<S> for $ity {\n+                fn encode(self, w: &mut Writer, s: &mut S) {\n+                    self.0.encode(w, s);\n+                }\n+            }\n+\n+            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n+                }\n+            }\n+\n+            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n+                for Marked<S::$ity, $ity>\n+            {\n+                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n+                    s.$ity.alloc(self).encode(w, s);\n+                }\n+            }\n+\n+            impl<S> DecodeMut<'_, '_, S> for $ity {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                    $ity(handle::Handle::decode(r, s))\n+                }\n+            }\n+        )*\n+    }\n+}\n+define_handles! {\n+    'owned:\n+    FreeFunctions,\n+    TokenStream,\n+    TokenStreamBuilder,\n+    TokenStreamIter,\n+    Group,\n+    Literal,\n+    SourceFile,\n+    MultiSpan,\n+    Diagnostic,\n+\n+    'interned:\n+    Punct,\n+    Ident,\n+    Span,\n+}\n+\n+// FIXME(eddyb) generate these impls by pattern-matching on the\n+// names of methods - also could use the presence of `fn drop`\n+// to distinguish between 'owned and 'interned, above.\n+// Alternatively, special 'modes\" could be listed of types in with_api\n+// instead of pattern matching on methods, here and in server decl.\n+\n+impl Clone for TokenStream {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for TokenStreamIter {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Group {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl Clone for Literal {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Literal\")\n+            // format the kind without quotes, as in `kind: Float`\n+            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n+            .field(\"symbol\", &self.symbol())\n+            // format `Some(\"...\")` on one line even in {:#?} mode\n+            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+impl Clone for SourceFile {\n+    fn clone(&self) -> Self {\n+        self.clone()\n+    }\n+}\n+\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.debug())\n+    }\n+}\n+\n+macro_rules! define_client_side {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)?) => {\n+        $(impl $name {\n+            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n+                Bridge::with(|bridge| {\n+                    let mut b = bridge.cached_buffer.take();\n+\n+                    b.clear();\n+                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut b, &mut ());\n+                    reverse_encode!(b; $($arg),*);\n+\n+                    b = bridge.dispatch.call(b);\n+\n+                    let r = Result::<_, PanicMessage>::decode(&mut &b[..], &mut ());\n+\n+                    bridge.cached_buffer = b;\n+\n+                    r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n+                })\n+            })*\n+        })*\n+    }\n+}\n+with_api!(self, self, define_client_side);\n+\n+enum BridgeState<'a> {\n+    /// No server is currently connected to this client.\n+    NotConnected,\n+\n+    /// A server is connected and available for requests.\n+    Connected(Bridge<'a>),\n+\n+    /// Access to the bridge is being exclusively acquired\n+    /// (e.g., during `BridgeState::with`).\n+    InUse,\n+}\n+\n+enum BridgeStateL {}\n+\n+impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n+    type Out = BridgeState<'a>;\n+}\n+\n+thread_local! {\n+    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n+        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n+}\n+\n+impl BridgeState<'_> {\n+    /// Take exclusive control of the thread-local\n+    /// `BridgeState`, and pass it to `f`, mutably.\n+    /// The state will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    ///\n+    /// N.B., while `f` is running, the thread-local state\n+    /// is `BridgeState::InUse`.\n+    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n+        BRIDGE_STATE.with(|state| {\n+            state.replace(BridgeState::InUse, |mut state| {\n+                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n+                f(&mut *state)\n+            })\n+        })\n+    }\n+}\n+\n+impl Bridge<'_> {\n+    pub(crate) fn is_available() -> bool {\n+        BridgeState::with(|state| match state {\n+            BridgeState::Connected(_) | BridgeState::InUse => true,\n+            BridgeState::NotConnected => false,\n+        })\n+    }\n+\n+    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n+        let force_show_panics = self.force_show_panics;\n+        // Hide the default panic output within `proc_macro` expansions.\n+        // NB. the server can't do this because it may use a different libstd.\n+        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n+        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n+            let prev = panic::take_hook();\n+            panic::set_hook(Box::new(move |info| {\n+                let show = BridgeState::with(|state| match state {\n+                    BridgeState::NotConnected => true,\n+                    BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n+                });\n+                if show {\n+                    prev(info)\n+                }\n+            }));\n+        });\n+\n+        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n+    }\n+\n+    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n+        BridgeState::with(|state| match state {\n+            BridgeState::NotConnected => {\n+                panic!(\"procedural macro API is used outside of a procedural macro\");\n+            }\n+            BridgeState::InUse => {\n+                panic!(\"procedural macro API is used while it's already in use\");\n+            }\n+            BridgeState::Connected(bridge) => f(bridge),\n+        })\n+    }\n+}\n+\n+/// A client-side \"global object\" (usually a function pointer),\n+/// which may be using a different `proc_macro` from the one\n+/// used by the server, but can be interacted with compatibly.\n+///\n+/// N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).\n+/// The call ABI of function pointers used for `F` doesn't\n+/// need to match between server and client, since it's only\n+/// passed between them and (eventually) called by the client.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct Client<F> {\n+    // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n+    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n+    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n+    pub(super) f: F,\n+}\n+\n+/// Client-side helper for handling client panics, entering the bridge,\n+/// deserializing input and serializing output.\n+// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n+fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n+    mut bridge: Bridge<'_>,\n+    f: impl FnOnce(A) -> R,\n+) -> Buffer<u8> {\n+    // The initial `cached_buffer` contains the input.\n+    let mut b = bridge.cached_buffer.take();\n+\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        bridge.enter(|| {\n+            let reader = &mut &b[..];\n+            let input = A::decode(reader, &mut ());\n+\n+            // Put the `cached_buffer` back in the `Bridge`, for requests.\n+            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n+\n+            let output = f(input);\n+\n+            // Take the `cached_buffer` back out, for the output value.\n+            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+            // having handles outside the `bridge.enter(|| ...)` scope, and\n+            // to catch panics that could happen while encoding the success.\n+            //\n+            // Note that panics should be impossible beyond this point, but\n+            // this is defensively trying to avoid any accidental panicking\n+            // reaching the `extern \"C\"` (which should `abort` but might not\n+            // at the moment, so this is also potentially preventing UB).\n+            b.clear();\n+            Ok::<_, ()>(output).encode(&mut b, &mut ());\n+        })\n+    }))\n+    .map_err(PanicMessage::from)\n+    .unwrap_or_else(|e| {\n+        b.clear();\n+        Err::<(), _>(e).encode(&mut b, &mut ());\n+    });\n+    b\n+}\n+\n+impl Client<fn(super::super::TokenStream) -> super::super::TokenStream> {\n+    pub fn expand1(f: fn(super::super::TokenStream) -> super::super::TokenStream) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(super::super::TokenStream) -> super::super::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |input| f(super::super::TokenStream(input)).0)\n+        }\n+        Client { get_handle_counters: HandleCounters::get, run, f }\n+    }\n+}\n+\n+impl Client<fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream> {\n+    pub fn expand2(\n+        f: fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream,\n+    ) -> Self {\n+        extern \"C\" fn run(\n+            bridge: Bridge<'_>,\n+            f: impl FnOnce(\n+                super::super::TokenStream,\n+                super::super::TokenStream,\n+            ) -> super::super::TokenStream,\n+        ) -> Buffer<u8> {\n+            run_client(bridge, |(input, input2)| {\n+                f(super::super::TokenStream(input), super::super::TokenStream(input2)).0\n+            })\n+        }\n+        Client { get_handle_counters: HandleCounters::get, run, f }\n+    }\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum ProcMacro {\n+    CustomDerive {\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        client: Client<fn(super::super::TokenStream) -> super::super::TokenStream>,\n+    },\n+\n+    Attr {\n+        name: &'static str,\n+        client: Client<\n+            fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream,\n+        >,\n+    },\n+\n+    Bang {\n+        name: &'static str,\n+        client: Client<fn(super::super::TokenStream) -> super::super::TokenStream>,\n+    },\n+}\n+\n+impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, .. } => name,\n+        }\n+    }\n+\n+    pub fn custom_derive(\n+        trait_name: &'static str,\n+        attributes: &'static [&'static str],\n+        expand: fn(super::super::TokenStream) -> super::super::TokenStream,\n+    ) -> Self {\n+        ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n+    }\n+\n+    pub fn attr(\n+        name: &'static str,\n+        expand: fn(\n+            super::super::TokenStream,\n+            super::super::TokenStream,\n+        ) -> super::super::TokenStream,\n+    ) -> Self {\n+        ProcMacro::Attr { name, client: Client::expand2(expand) }\n+    }\n+\n+    pub fn bang(\n+        name: &'static str,\n+        expand: fn(super::super::TokenStream) -> super::super::TokenStream,\n+    ) -> Self {\n+        ProcMacro::Bang { name, client: Client::expand1(expand) }\n+    }\n+}"}, {"sha": "5be71cc3d70136c46f71483e57ca59428dbf358d", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/closure.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,24 @@\n+//! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n+\n+#[repr(C)]\n+pub struct Closure<'a, A, R> {\n+    call: unsafe extern \"C\" fn(&mut Env, A) -> R,\n+    env: &'a mut Env,\n+}\n+\n+struct Env;\n+\n+impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n+    fn from(f: &'a mut F) -> Self {\n+        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: &mut Env, arg: A) -> R {\n+            (*(env as *mut _ as *mut F))(arg)\n+        }\n+        Closure { call: call::<A, R, F>, env: unsafe { &mut *(f as *mut _ as *mut Env) } }\n+    }\n+}\n+\n+impl<'a, A, R> Closure<'a, A, R> {\n+    pub fn call(&mut self, arg: A) -> R {\n+        unsafe { (self.call)(self.env, arg) }\n+    }\n+}"}, {"sha": "bcbb86812470a3e9702c0291cea97dec0efc9c26", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/handle.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,70 @@\n+//! Server-side handles and storage for per-handle data.\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+use std::num::NonZeroU32;\n+use std::ops::{Index, IndexMut};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub(super) type Handle = NonZeroU32;\n+\n+pub(super) struct OwnedStore<T: 'static> {\n+    counter: &'static AtomicUsize,\n+    data: BTreeMap<Handle, T>,\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        // Ensure the handle counter isn't 0, which would panic later,\n+        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n+        assert_ne!(counter.load(Ordering::SeqCst), 0);\n+\n+        OwnedStore { counter, data: BTreeMap::new() }\n+    }\n+}\n+\n+impl<T> OwnedStore<T> {\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n+        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n+        assert!(self.data.insert(handle, x).is_none());\n+        handle\n+    }\n+\n+    pub(super) fn take(&mut self, h: Handle) -> T {\n+        self.data.remove(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> Index<Handle> for OwnedStore<T> {\n+    type Output = T;\n+    fn index(&self, h: Handle) -> &T {\n+        self.data.get(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+impl<T> IndexMut<Handle> for OwnedStore<T> {\n+    fn index_mut(&mut self, h: Handle) -> &mut T {\n+        self.data.get_mut(&h).expect(\"use-after-free in `proc_macro` handle\")\n+    }\n+}\n+\n+pub(super) struct InternedStore<T: 'static> {\n+    owned: OwnedStore<T>,\n+    interner: HashMap<T, Handle>,\n+}\n+\n+impl<T: Copy + Eq + Hash> InternedStore<T> {\n+    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n+        InternedStore { owned: OwnedStore::new(counter), interner: HashMap::new() }\n+    }\n+\n+    pub(super) fn alloc(&mut self, x: T) -> Handle {\n+        let owned = &mut self.owned;\n+        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n+    }\n+\n+    pub(super) fn copy(&mut self, h: Handle) -> T {\n+        self.owned[h]\n+    }\n+}"}, {"sha": "fc20f7df66565a4cd09e61090cc5a215e4b1dc8b", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/mod.rs", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fmod.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,426 @@\n+//! Internal interface for communicating between a `proc_macro` client\n+//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n+//!\n+//! Serialization (with C ABI buffers) and unique integer handles are employed\n+//! to allow safely interfacing between two copies of `proc_macro` built\n+//! (from the same source) by different compilers with potentially mismatching\n+//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n+\n+#![deny(unsafe_code)]\n+\n+pub use super::{Delimiter, Level, LineColumn, Spacing};\n+use std::fmt;\n+use std::hash::Hash;\n+use std::marker;\n+use std::mem;\n+use std::ops::Bound;\n+use std::panic;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Once;\n+use std::thread;\n+\n+/// Higher-order macro describing the server RPC API, allowing automatic\n+/// generation of type-safe Rust APIs, both client-side and server-side.\n+///\n+/// `with_api!(MySelf, my_self, my_macro)` expands to:\n+/// ```rust,ignore (pseudo-code)\n+/// my_macro! {\n+///     // ...\n+///     Literal {\n+///         // ...\n+///         fn character(ch: char) -> MySelf::Literal;\n+///         // ...\n+///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n+///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n+///     },\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// The first two arguments serve to customize the arguments names\n+/// and argument/return types, to enable several different usecases:\n+///\n+/// If `my_self` is just `self`, then each `fn` signature can be used\n+/// as-is for a method. If it's anything else (`self_` in practice),\n+/// then the signatures don't have a special `self` argument, and\n+/// can, therefore, have a different one introduced.\n+///\n+/// If `MySelf` is just `Self`, then the types are only valid inside\n+/// a trait or a trait impl, where the trait has associated types\n+/// for each of the API types. If non-associated types are desired,\n+/// a module name (`self` in practice) can be used instead of `Self`.\n+macro_rules! with_api {\n+    ($S:ident, $self:ident, $m:ident) => {\n+        $m! {\n+            FreeFunctions {\n+                fn drop($self: $S::FreeFunctions);\n+                fn track_env_var(var: &str, value: Option<&str>);\n+                fn track_path(path: &str);\n+            },\n+            TokenStream {\n+                fn drop($self: $S::TokenStream);\n+                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n+                fn new() -> $S::TokenStream;\n+                fn is_empty($self: &$S::TokenStream) -> bool;\n+                fn from_str(src: &str) -> $S::TokenStream;\n+                fn to_string($self: &$S::TokenStream) -> String;\n+                fn from_token_tree(\n+                    tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n+                ) -> $S::TokenStream;\n+                fn into_iter($self: $S::TokenStream) -> $S::TokenStreamIter;\n+            },\n+            TokenStreamBuilder {\n+                fn drop($self: $S::TokenStreamBuilder);\n+                fn new() -> $S::TokenStreamBuilder;\n+                fn push($self: &mut $S::TokenStreamBuilder, stream: $S::TokenStream);\n+                fn build($self: $S::TokenStreamBuilder) -> $S::TokenStream;\n+            },\n+            TokenStreamIter {\n+                fn drop($self: $S::TokenStreamIter);\n+                fn clone($self: &$S::TokenStreamIter) -> $S::TokenStreamIter;\n+                fn next(\n+                    $self: &mut $S::TokenStreamIter,\n+                ) -> Option<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n+            },\n+            Group {\n+                fn drop($self: $S::Group);\n+                fn clone($self: &$S::Group) -> $S::Group;\n+                fn new(delimiter: Delimiter, stream: $S::TokenStream) -> $S::Group;\n+                fn delimiter($self: &$S::Group) -> Delimiter;\n+                fn stream($self: &$S::Group) -> $S::TokenStream;\n+                fn span($self: &$S::Group) -> $S::Span;\n+                fn span_open($self: &$S::Group) -> $S::Span;\n+                fn span_close($self: &$S::Group) -> $S::Span;\n+                fn set_span($self: &mut $S::Group, span: $S::Span);\n+            },\n+            Punct {\n+                fn new(ch: char, spacing: Spacing) -> $S::Punct;\n+                fn as_char($self: $S::Punct) -> char;\n+                fn spacing($self: $S::Punct) -> Spacing;\n+                fn span($self: $S::Punct) -> $S::Span;\n+                fn with_span($self: $S::Punct, span: $S::Span) -> $S::Punct;\n+            },\n+            Ident {\n+                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n+                fn span($self: $S::Ident) -> $S::Span;\n+                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n+            },\n+            Literal {\n+                fn drop($self: $S::Literal);\n+                fn clone($self: &$S::Literal) -> $S::Literal;\n+                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n+                fn to_string($self: &$S::Literal) -> String;\n+                fn debug_kind($self: &$S::Literal) -> String;\n+                fn symbol($self: &$S::Literal) -> String;\n+                fn suffix($self: &$S::Literal) -> Option<String>;\n+                fn integer(n: &str) -> $S::Literal;\n+                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n+                fn float(n: &str) -> $S::Literal;\n+                fn f32(n: &str) -> $S::Literal;\n+                fn f64(n: &str) -> $S::Literal;\n+                fn string(string: &str) -> $S::Literal;\n+                fn character(ch: char) -> $S::Literal;\n+                fn byte_string(bytes: &[u8]) -> $S::Literal;\n+                fn span($self: &$S::Literal) -> $S::Span;\n+                fn set_span($self: &mut $S::Literal, span: $S::Span);\n+                fn subspan(\n+                    $self: &$S::Literal,\n+                    start: Bound<usize>,\n+                    end: Bound<usize>,\n+                ) -> Option<$S::Span>;\n+            },\n+            SourceFile {\n+                fn drop($self: $S::SourceFile);\n+                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n+                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n+                fn path($self: &$S::SourceFile) -> String;\n+                fn is_real($self: &$S::SourceFile) -> bool;\n+            },\n+            MultiSpan {\n+                fn drop($self: $S::MultiSpan);\n+                fn new() -> $S::MultiSpan;\n+                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n+            },\n+            Diagnostic {\n+                fn drop($self: $S::Diagnostic);\n+                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n+                fn sub(\n+                    $self: &mut $S::Diagnostic,\n+                    level: Level,\n+                    msg: &str,\n+                    span: $S::MultiSpan,\n+                );\n+                fn emit($self: $S::Diagnostic);\n+            },\n+            Span {\n+                fn debug($self: $S::Span) -> String;\n+                fn def_site() -> $S::Span;\n+                fn call_site() -> $S::Span;\n+                fn mixed_site() -> $S::Span;\n+                fn source_file($self: $S::Span) -> $S::SourceFile;\n+                fn parent($self: $S::Span) -> Option<$S::Span>;\n+                fn source($self: $S::Span) -> $S::Span;\n+                fn start($self: $S::Span) -> LineColumn;\n+                fn end($self: $S::Span) -> LineColumn;\n+                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n+                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n+                fn source_text($self: $S::Span) -> Option<String>;\n+                fn save_span($self: $S::Span) -> usize;\n+                fn recover_proc_macro_span(id: usize) -> $S::Span;\n+            },\n+        }\n+    };\n+}\n+\n+// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_encode {\n+    ($writer:ident;) => {};\n+    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n+        reverse_encode!($writer; $($rest),*);\n+        $first.encode(&mut $writer, &mut ());\n+    }\n+}\n+\n+// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n+// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+macro_rules! reverse_decode {\n+    ($reader:ident, $s:ident;) => {};\n+    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n+        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n+        let $first = <$first_ty>::decode(&mut $reader, $s);\n+    }\n+}\n+\n+#[allow(unsafe_code)]\n+mod buffer;\n+#[forbid(unsafe_code)]\n+pub mod client;\n+#[allow(unsafe_code)]\n+mod closure;\n+#[forbid(unsafe_code)]\n+mod handle;\n+#[macro_use]\n+#[forbid(unsafe_code)]\n+mod rpc;\n+#[allow(unsafe_code)]\n+mod scoped_cell;\n+#[forbid(unsafe_code)]\n+pub mod server;\n+\n+use buffer::Buffer;\n+pub use rpc::PanicMessage;\n+use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n+\n+/// An active connection between a server and a client.\n+/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n+/// then passes it to the client through the function pointer in the `run`\n+/// field of `client::Client`. The client holds its copy of the `Bridge`\n+/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n+#[repr(C)]\n+pub struct Bridge<'a> {\n+    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n+    /// used for making requests, but also for passing input to client.\n+    cached_buffer: Buffer<u8>,\n+\n+    /// Server-side function that the client uses to make requests.\n+    dispatch: closure::Closure<'a, Buffer<u8>, Buffer<u8>>,\n+\n+    /// If 'true', always invoke the default panic hook\n+    force_show_panics: bool,\n+}\n+\n+#[forbid(unsafe_code)]\n+#[allow(non_camel_case_types)]\n+mod api_tags {\n+    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n+\n+    macro_rules! declare_tags {\n+        ($($name:ident {\n+            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+        }),* $(,)?) => {\n+            $(\n+                pub(super) enum $name {\n+                    $($method),*\n+                }\n+                rpc_encode_decode!(enum $name { $($method),* });\n+            )*\n+\n+\n+            pub(super) enum Method {\n+                $($name($name)),*\n+            }\n+            rpc_encode_decode!(enum Method { $($name(m)),* });\n+        }\n+    }\n+    with_api!(self, self, declare_tags);\n+}\n+\n+/// Helper to wrap associated types to allow trait impl dispatch.\n+/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n+/// can overlap, but if the impls are, instead, on types like\n+/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n+trait Mark {\n+    type Unmarked;\n+    fn mark(unmarked: Self::Unmarked) -> Self;\n+}\n+\n+/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n+trait Unmark {\n+    type Unmarked;\n+    fn unmark(self) -> Self::Unmarked;\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct Marked<T, M> {\n+    value: T,\n+    _marker: marker::PhantomData<M>,\n+}\n+\n+impl<T, M> Mark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        Marked { value: unmarked, _marker: marker::PhantomData }\n+    }\n+}\n+impl<T, M> Unmark for Marked<T, M> {\n+    type Unmarked = T;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.value\n+    }\n+}\n+impl<'a, T, M> Unmark for &'a Marked<T, M> {\n+    type Unmarked = &'a T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &self.value\n+    }\n+}\n+impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n+    type Unmarked = &'a mut T;\n+    fn unmark(self) -> Self::Unmarked {\n+        &mut self.value\n+    }\n+}\n+\n+impl<T: Mark> Mark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark)\n+    }\n+}\n+impl<T: Unmark> Unmark for Option<T> {\n+    type Unmarked = Option<T::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark)\n+    }\n+}\n+\n+impl<T: Mark, E: Mark> Mark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        unmarked.map(T::mark).map_err(E::mark)\n+    }\n+}\n+impl<T: Unmark, E: Unmark> Unmark for Result<T, E> {\n+    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        self.map(T::unmark).map_err(E::unmark)\n+    }\n+}\n+\n+macro_rules! mark_noop {\n+    ($($ty:ty),* $(,)?) => {\n+        $(\n+            impl Mark for $ty {\n+                type Unmarked = Self;\n+                fn mark(unmarked: Self::Unmarked) -> Self {\n+                    unmarked\n+                }\n+            }\n+            impl Unmark for $ty {\n+                type Unmarked = Self;\n+                fn unmark(self) -> Self::Unmarked {\n+                    self\n+                }\n+            }\n+        )*\n+    }\n+}\n+mark_noop! {\n+    (),\n+    bool,\n+    char,\n+    &'_ [u8],\n+    &'_ str,\n+    String,\n+    usize,\n+    Delimiter,\n+    Level,\n+    LineColumn,\n+    Spacing,\n+    Bound<usize>,\n+}\n+\n+rpc_encode_decode!(\n+    enum Delimiter {\n+        Parenthesis,\n+        Brace,\n+        Bracket,\n+        None,\n+    }\n+);\n+rpc_encode_decode!(\n+    enum Level {\n+        Error,\n+        Warning,\n+        Note,\n+        Help,\n+    }\n+);\n+rpc_encode_decode!(struct LineColumn { line, column });\n+rpc_encode_decode!(\n+    enum Spacing {\n+        Alone,\n+        Joint,\n+    }\n+);\n+\n+#[derive(Clone)]\n+pub enum TokenTree<G, P, I, L> {\n+    Group(G),\n+    Punct(P),\n+    Ident(I),\n+    Literal(L),\n+}\n+\n+impl<G: Mark, P: Mark, I: Mark, L: Mark> Mark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn mark(unmarked: Self::Unmarked) -> Self {\n+        match unmarked {\n+            TokenTree::Group(tt) => TokenTree::Group(G::mark(tt)),\n+            TokenTree::Punct(tt) => TokenTree::Punct(P::mark(tt)),\n+            TokenTree::Ident(tt) => TokenTree::Ident(I::mark(tt)),\n+            TokenTree::Literal(tt) => TokenTree::Literal(L::mark(tt)),\n+        }\n+    }\n+}\n+impl<G: Unmark, P: Unmark, I: Unmark, L: Unmark> Unmark for TokenTree<G, P, I, L> {\n+    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n+    fn unmark(self) -> Self::Unmarked {\n+        match self {\n+            TokenTree::Group(tt) => TokenTree::Group(tt.unmark()),\n+            TokenTree::Punct(tt) => TokenTree::Punct(tt.unmark()),\n+            TokenTree::Ident(tt) => TokenTree::Ident(tt.unmark()),\n+            TokenTree::Literal(tt) => TokenTree::Literal(tt.unmark()),\n+        }\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum TokenTree<G, P, I, L> {\n+        Group(tt),\n+        Punct(tt),\n+        Ident(tt),\n+        Literal(tt),\n+    }\n+);"}, {"sha": "d50564d01a5d2d9371f16355055d5c18604b68b1", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/rpc.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Frpc.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,305 @@\n+//! Serialization for client-server communication.\n+\n+use std::any::Any;\n+use std::char;\n+use std::io::Write;\n+use std::num::NonZeroU32;\n+use std::ops::Bound;\n+use std::str;\n+\n+pub(super) type Writer = super::buffer::Buffer<u8>;\n+\n+pub(super) trait Encode<S>: Sized {\n+    fn encode(self, w: &mut Writer, s: &mut S);\n+}\n+\n+pub(super) type Reader<'a> = &'a [u8];\n+\n+pub(super) trait Decode<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n+}\n+\n+pub(super) trait DecodeMut<'a, 's, S>: Sized {\n+    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n+}\n+\n+macro_rules! rpc_encode_decode {\n+    (le $ty:ty) => {\n+        impl<S> Encode<S> for $ty {\n+            fn encode(self, w: &mut Writer, _: &mut S) {\n+                w.extend_from_array(&self.to_le_bytes());\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $ty {\n+            fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n+                const N: usize = ::std::mem::size_of::<$ty>();\n+\n+                let mut bytes = [0; N];\n+                bytes.copy_from_slice(&r[..N]);\n+                *r = &r[N..];\n+\n+                Self::from_le_bytes(bytes)\n+            }\n+        }\n+    };\n+    (struct $name:ident { $($field:ident),* $(,)? }) => {\n+        impl<S> Encode<S> for $name {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                $(self.$field.encode(w, s);)*\n+            }\n+        }\n+\n+        impl<S> DecodeMut<'_, '_, S> for $name {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+                $name {\n+                    $($field: DecodeMut::decode(r, s)),*\n+                }\n+            }\n+        }\n+    };\n+    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n+        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n+            fn encode(self, w: &mut Writer, s: &mut S) {\n+                // HACK(eddyb): `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[allow(non_upper_case_globals)]\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n+\n+                match self {\n+                    $($name::$variant $(($field))* => {\n+                        tag::$variant.encode(w, s);\n+                        $($field.encode(w, s);)*\n+                    })*\n+                }\n+            }\n+        }\n+\n+        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n+            for $name $(<$($T),+>)?\n+        {\n+            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+                // HACK(eddyb): `Tag` enum duplicated between the\n+                // two impls as there's no other place to stash it.\n+                #[allow(non_upper_case_globals)]\n+                mod tag {\n+                    #[repr(u8)] enum Tag { $($variant),* }\n+\n+                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n+                }\n+\n+                match u8::decode(r, s) {\n+                    $(tag::$variant => {\n+                        $(let $field = DecodeMut::decode(r, s);)*\n+                        $name::$variant $(($field))*\n+                    })*\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for () {\n+    fn encode(self, _: &mut Writer, _: &mut S) {}\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for () {\n+    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n+}\n+\n+impl<S> Encode<S> for u8 {\n+    fn encode(self, w: &mut Writer, _: &mut S) {\n+        w.push(self);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for u8 {\n+    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n+        let x = r[0];\n+        *r = &r[1..];\n+        x\n+    }\n+}\n+\n+rpc_encode_decode!(le u32);\n+rpc_encode_decode!(le usize);\n+\n+impl<S> Encode<S> for bool {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u8).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for bool {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        match u8::decode(r, s) {\n+            0 => false,\n+            1 => true,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for char {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        (self as u32).encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for char {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        char::from_u32(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for NonZeroU32 {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.get().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        Self::new(u32::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.0.encode(w, s);\n+        self.1.encode(w, s);\n+    }\n+}\n+\n+impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n+    for (A, B)\n+{\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n+    }\n+}\n+\n+rpc_encode_decode!(\n+    enum Bound<T> {\n+        Included(x),\n+        Excluded(x),\n+        Unbounded,\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Option<T> {\n+        None,\n+        Some(x),\n+    }\n+);\n+\n+rpc_encode_decode!(\n+    enum Result<T, E> {\n+        Ok(x),\n+        Err(e),\n+    }\n+);\n+\n+impl<S> Encode<S> for &[u8] {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.len().encode(w, s);\n+        w.write_all(self).unwrap();\n+    }\n+}\n+\n+impl<'a, S> DecodeMut<'a, '_, S> for &'a [u8] {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        let len = usize::decode(r, s);\n+        let xs = &r[..len];\n+        *r = &r[len..];\n+        xs\n+    }\n+}\n+\n+impl<S> Encode<S> for &str {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_bytes().encode(w, s);\n+    }\n+}\n+\n+impl<'a, S> DecodeMut<'a, '_, S> for &'a str {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n+    }\n+}\n+\n+impl<S> Encode<S> for String {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self[..].encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for String {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        <&str>::decode(r, s).to_string()\n+    }\n+}\n+\n+/// Simplified version of panic payloads, ignoring\n+/// types other than `&'static str` and `String`.\n+pub enum PanicMessage {\n+    StaticStr(&'static str),\n+    String(String),\n+    Unknown,\n+}\n+\n+impl From<Box<dyn Any + Send>> for PanicMessage {\n+    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n+        if let Some(s) = payload.downcast_ref::<&'static str>() {\n+            return PanicMessage::StaticStr(s);\n+        }\n+        if let Ok(s) = payload.downcast::<String>() {\n+            return PanicMessage::String(*s);\n+        }\n+        PanicMessage::Unknown\n+    }\n+}\n+\n+impl Into<Box<dyn Any + Send>> for PanicMessage {\n+    fn into(self) -> Box<dyn Any + Send> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Box::new(s),\n+            PanicMessage::String(s) => Box::new(s),\n+            PanicMessage::Unknown => {\n+                struct UnknownPanicMessage;\n+                Box::new(UnknownPanicMessage)\n+            }\n+        }\n+    }\n+}\n+\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<&str> {\n+        match self {\n+            PanicMessage::StaticStr(s) => Some(s),\n+            PanicMessage::String(s) => Some(s),\n+            PanicMessage::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl<S> Encode<S> for PanicMessage {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.as_str().encode(w, s);\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        match Option::<String>::decode(r, s) {\n+            Some(s) => PanicMessage::String(s),\n+            None => PanicMessage::Unknown,\n+        }\n+    }\n+}"}, {"sha": "b0c2e5b9c26b1c69189d6281684e9646cdcb39cf", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/scoped_cell.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,81 @@\n+//! `Cell` variant for (scoped) existential lifetimes.\n+\n+use std::cell::Cell;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+\n+/// Type lambda application, with a lifetime.\n+#[allow(unused_lifetimes)]\n+pub trait ApplyL<'a> {\n+    type Out;\n+}\n+\n+/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n+pub trait LambdaL: for<'a> ApplyL<'a> {}\n+\n+impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n+\n+// HACK(eddyb) work around projection limitations with a newtype\n+// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n+pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n+\n+impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n+    type Target = <T as ApplyL<'b>>::Out;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+\n+impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.0\n+    }\n+}\n+\n+pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n+\n+impl<T: LambdaL> ScopedCell<T> {\n+    pub fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n+        ScopedCell(Cell::new(value))\n+    }\n+\n+    /// Sets the value in `self` to `replacement` while\n+    /// running `f`, which gets the old value, mutably.\n+    /// The old value will be restored after `f` exits, even\n+    /// by panic, including modifications made to it by `f`.\n+    pub fn replace<'a, R>(\n+        &self,\n+        replacement: <T as ApplyL<'a>>::Out,\n+        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n+    ) -> R {\n+        /// Wrapper that ensures that the cell always gets filled\n+        /// (with the original state, optionally changed by `f`),\n+        /// even if `f` had panicked.\n+        struct PutBackOnDrop<'a, T: LambdaL> {\n+            cell: &'a ScopedCell<T>,\n+            value: Option<<T as ApplyL<'static>>::Out>,\n+        }\n+\n+        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n+            fn drop(&mut self) {\n+                self.cell.0.set(self.value.take().unwrap());\n+            }\n+        }\n+\n+        let mut put_back_on_drop = PutBackOnDrop {\n+            cell: self,\n+            value: Some(self.0.replace(unsafe {\n+                let erased = mem::transmute_copy(&replacement);\n+                mem::forget(replacement);\n+                erased\n+            })),\n+        };\n+\n+        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n+    }\n+\n+    /// Sets the value in `self` to `value` while running `f`.\n+    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n+        self.replace(value, |_| f())\n+    }\n+}"}, {"sha": "06a19791351a485674dd4ed2843c43bfdb5e9356", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/bridge/server.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fbridge%2Fserver.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,352 @@\n+//! Server-side traits.\n+\n+use super::*;\n+\n+// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n+use super::client::HandleStore;\n+\n+/// Declare an associated item of one of the traits below, optionally\n+/// adjusting it (i.e., adding bounds to types and default bodies to methods).\n+macro_rules! associated_item {\n+    (type FreeFunctions) =>\n+        (type FreeFunctions: 'static;);\n+    (type TokenStream) =>\n+        (type TokenStream: 'static + Clone;);\n+    (type TokenStreamBuilder) =>\n+        (type TokenStreamBuilder: 'static;);\n+    (type TokenStreamIter) =>\n+        (type TokenStreamIter: 'static + Clone;);\n+    (type Group) =>\n+        (type Group: 'static + Clone;);\n+    (type Punct) =>\n+        (type Punct: 'static + Copy + Eq + Hash;);\n+    (type Ident) =>\n+        (type Ident: 'static + Copy + Eq + Hash;);\n+    (type Literal) =>\n+        (type Literal: 'static + Clone;);\n+    (type SourceFile) =>\n+        (type SourceFile: 'static + Clone;);\n+    (type MultiSpan) =>\n+        (type MultiSpan: 'static;);\n+    (type Diagnostic) =>\n+        (type Diagnostic: 'static;);\n+    (type Span) =>\n+        (type Span: 'static + Copy + Eq + Hash;);\n+    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n+        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n+    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n+        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n+    ($($item:tt)*) => ($($item)*;)\n+}\n+\n+macro_rules! declare_server_traits {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        pub trait Types {\n+            $(associated_item!(type $name);)*\n+        }\n+\n+        $(pub trait $name: Types {\n+            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+        })*\n+\n+        pub trait Server: Types $(+ $name)* {}\n+        impl<S: Types $(+ $name)*> Server for S {}\n+    }\n+}\n+with_api!(Self, self_, declare_server_traits);\n+\n+pub(super) struct MarkedTypes<S: Types>(S);\n+\n+macro_rules! define_mark_types_impls {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        impl<S: Types> Types for MarkedTypes<S> {\n+            $(type $name = Marked<S::$name, client::$name>;)*\n+        }\n+\n+        $(impl<S: $name> $name for MarkedTypes<S> {\n+            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n+                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n+            })*\n+        })*\n+    }\n+}\n+with_api!(Self, self_, define_mark_types_impls);\n+\n+struct Dispatcher<S: Types> {\n+    handle_store: HandleStore<S>,\n+    server: S,\n+}\n+\n+macro_rules! define_dispatcher_impl {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n+        pub trait DispatcherTrait {\n+            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n+            $(type $name;)*\n+            fn dispatch(&mut self, b: Buffer<u8>) -> Buffer<u8>;\n+        }\n+\n+        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n+            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n+            fn dispatch(&mut self, mut b: Buffer<u8>) -> Buffer<u8> {\n+                let Dispatcher { handle_store, server } = self;\n+\n+                let mut reader = &b[..];\n+                match api_tags::Method::decode(&mut reader, &mut ()) {\n+                    $(api_tags::Method::$name(m) => match m {\n+                        $(api_tags::$name::$method => {\n+                            let mut call_method = || {\n+                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n+                                $name::$method(server, $($arg),*)\n+                            };\n+                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n+                            // If client and server happen to use the same `libstd`,\n+                            // `catch_unwind` asserts that the panic counter was 0,\n+                            // even when the closure passed to it didn't panic.\n+                            let r = if thread::panicking() {\n+                                Ok(call_method())\n+                            } else {\n+                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n+                                    .map_err(PanicMessage::from)\n+                            };\n+\n+                            b.clear();\n+                            r.encode(&mut b, handle_store);\n+                        })*\n+                    }),*\n+                }\n+                b\n+            }\n+        }\n+    }\n+}\n+with_api!(Self, self_, define_dispatcher_impl);\n+\n+pub trait ExecutionStrategy {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+        force_show_panics: bool,\n+    ) -> Buffer<u8>;\n+}\n+\n+pub struct SameThread;\n+\n+impl ExecutionStrategy for SameThread {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+        force_show_panics: bool,\n+    ) -> Buffer<u8> {\n+        let mut dispatch = |b| dispatcher.dispatch(b);\n+\n+        run_client(\n+            Bridge { cached_buffer: input, dispatch: (&mut dispatch).into(), force_show_panics },\n+            client_data,\n+        )\n+    }\n+}\n+\n+// NOTE(eddyb) Two implementations are provided, the second one is a bit\n+// faster but neither is anywhere near as fast as same-thread execution.\n+\n+pub struct CrossThread1;\n+\n+impl ExecutionStrategy for CrossThread1 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+        force_show_panics: bool,\n+    ) -> Buffer<u8> {\n+        use std::sync::mpsc::channel;\n+\n+        let (req_tx, req_rx) = channel();\n+        let (res_tx, res_rx) = channel();\n+\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                req_tx.send(b).unwrap();\n+                res_rx.recv().unwrap()\n+            };\n+\n+            run_client(\n+                Bridge {\n+                    cached_buffer: input,\n+                    dispatch: (&mut dispatch).into(),\n+                    force_show_panics,\n+                },\n+                client_data,\n+            )\n+        });\n+\n+        for b in req_rx {\n+            res_tx.send(dispatcher.dispatch(b)).unwrap();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+pub struct CrossThread2;\n+\n+impl ExecutionStrategy for CrossThread2 {\n+    fn run_bridge_and_client<D: Copy + Send + 'static>(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        client_data: D,\n+        force_show_panics: bool,\n+    ) -> Buffer<u8> {\n+        use std::sync::{Arc, Mutex};\n+\n+        enum State<T> {\n+            Req(T),\n+            Res(T),\n+        }\n+\n+        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n+\n+        let server_thread = thread::current();\n+        let state2 = state.clone();\n+        let join_handle = thread::spawn(move || {\n+            let mut dispatch = |b| {\n+                *state2.lock().unwrap() = State::Req(b);\n+                server_thread.unpark();\n+                loop {\n+                    thread::park();\n+                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n+                        break b.take();\n+                    }\n+                }\n+            };\n+\n+            let r = run_client(\n+                Bridge {\n+                    cached_buffer: input,\n+                    dispatch: (&mut dispatch).into(),\n+                    force_show_panics,\n+                },\n+                client_data,\n+            );\n+\n+            // Wake up the server so it can exit the dispatch loop.\n+            drop(state2);\n+            server_thread.unpark();\n+\n+            r\n+        });\n+\n+        // Check whether `state2` was dropped, to know when to stop.\n+        while Arc::get_mut(&mut state).is_none() {\n+            thread::park();\n+            let mut b = match &mut *state.lock().unwrap() {\n+                State::Req(b) => b.take(),\n+                _ => continue,\n+            };\n+            b = dispatcher.dispatch(b.take());\n+            *state.lock().unwrap() = State::Res(b);\n+            join_handle.thread().unpark();\n+        }\n+\n+        join_handle.join().unwrap()\n+    }\n+}\n+\n+fn run_server<\n+    S: Server,\n+    I: Encode<HandleStore<MarkedTypes<S>>>,\n+    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n+    D: Copy + Send + 'static,\n+>(\n+    strategy: &impl ExecutionStrategy,\n+    handle_counters: &'static client::HandleCounters,\n+    server: S,\n+    input: I,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+    client_data: D,\n+    force_show_panics: bool,\n+) -> Result<O, PanicMessage> {\n+    let mut dispatcher =\n+        Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n+\n+    let mut b = Buffer::new();\n+    input.encode(&mut b, &mut dispatcher.handle_store);\n+\n+    b = strategy.run_bridge_and_client(\n+        &mut dispatcher,\n+        b,\n+        run_client,\n+        client_data,\n+        force_show_panics,\n+    );\n+\n+    Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n+}\n+\n+impl client::Client<fn(super::super::TokenStream) -> super::super::TokenStream> {\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+        force_show_panics: bool,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client { get_handle_counters, run, f } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+            run,\n+            f,\n+            force_show_panics,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}\n+\n+impl\n+    client::Client<\n+        fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream,\n+    >\n+{\n+    pub fn run<S: Server>(\n+        &self,\n+        strategy: &impl ExecutionStrategy,\n+        server: S,\n+        input: S::TokenStream,\n+        input2: S::TokenStream,\n+        force_show_panics: bool,\n+    ) -> Result<S::TokenStream, PanicMessage> {\n+        let client::Client { get_handle_counters, run, f } = *self;\n+        run_server(\n+            strategy,\n+            get_handle_counters(),\n+            server,\n+            (\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n+                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n+            ),\n+            run,\n+            f,\n+            force_show_panics,\n+        )\n+        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+    }\n+}"}, {"sha": "6953b1ecf4cb1ac459c7b83f9b96b4a9a01af367", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/diagnostic.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fdiagnostic.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,167 @@\n+//! lib-proc-macro diagnostic\n+//!\n+//! Copy from <https://github.com/rust-lang/rust/blob/6050e523bae6de61de4e060facc43dc512adaccd/src/libproc_macro/diagnostic.rs>\n+//! augmented with removing unstable features\n+\n+use super::Span;\n+\n+/// An enum representing a diagnostic level.\n+#[derive(Copy, Clone, Debug)]\n+#[non_exhaustive]\n+pub enum Level {\n+    /// An error.\n+    Error,\n+    /// A warning.\n+    Warning,\n+    /// A note.\n+    Note,\n+    /// A help message.\n+    Help,\n+}\n+\n+/// Trait implemented by types that can be converted into a set of `Span`s.\n+pub trait MultiSpan {\n+    /// Converts `self` into a `Vec<Span>`.\n+    fn into_spans(self) -> Vec<Span>;\n+}\n+\n+impl MultiSpan for Span {\n+    fn into_spans(self) -> Vec<Span> {\n+        vec![self]\n+    }\n+}\n+\n+impl MultiSpan for Vec<Span> {\n+    fn into_spans(self) -> Vec<Span> {\n+        self\n+    }\n+}\n+\n+impl<'a> MultiSpan for &'a [Span] {\n+    fn into_spans(self) -> Vec<Span> {\n+        self.to_vec()\n+    }\n+}\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    spans: Vec<Span>,\n+    children: Vec<Diagnostic>,\n+}\n+\n+macro_rules! diagnostic_child_methods {\n+    ($spanned:ident, $regular:ident, $level:expr) => {\n+        /// Adds a new child diagnostic message to `self` with the level\n+        /// identified by this method's name with the given `spans` and\n+        /// `message`.\n+        pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n+        where\n+            S: MultiSpan,\n+            T: Into<String>,\n+        {\n+            self.children.push(Diagnostic::spanned(spans, $level, message));\n+            self\n+        }\n+\n+        /// Adds a new child diagnostic message to `self` with the level\n+        /// identified by this method's name with the given `message`.\n+        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n+            self.children.push(Diagnostic::new($level, message));\n+            self\n+        }\n+    };\n+}\n+\n+/// Iterator over the children diagnostics of a `Diagnostic`.\n+#[derive(Debug, Clone)]\n+pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n+\n+impl<'a> Iterator for Children<'a> {\n+    type Item = &'a Diagnostic;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+impl Diagnostic {\n+    /// Creates a new diagnostic with the given `level` and `message`.\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n+    }\n+\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n+    /// the given set of `spans`.\n+    pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n+    where\n+        S: MultiSpan,\n+        T: Into<String>,\n+    {\n+        Diagnostic { level, message: message.into(), spans: spans.into_spans(), children: vec![] }\n+    }\n+\n+    diagnostic_child_methods!(span_error, error, Level::Error);\n+    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n+    diagnostic_child_methods!(span_note, note, Level::Note);\n+    diagnostic_child_methods!(span_help, help, Level::Help);\n+\n+    /// Returns the diagnostic `level` for `self`.\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Sets the level in `self` to `level`.\n+    pub fn set_level(&mut self, level: Level) {\n+        self.level = level;\n+    }\n+\n+    /// Returns the message in `self`.\n+    pub fn message(&self) -> &str {\n+        &self.message\n+    }\n+\n+    /// Sets the message in `self` to `message`.\n+    pub fn set_message<T: Into<String>>(&mut self, message: T) {\n+        self.message = message.into();\n+    }\n+\n+    /// Returns the `Span`s in `self`.\n+    pub fn spans(&self) -> &[Span] {\n+        &self.spans\n+    }\n+\n+    /// Sets the `Span`s in `self` to `spans`.\n+    pub fn set_spans<S: MultiSpan>(&mut self, spans: S) {\n+        self.spans = spans.into_spans();\n+    }\n+\n+    /// Returns an iterator over the children diagnostics of `self`.\n+    pub fn children(&self) -> Children<'_> {\n+        Children(self.children.iter())\n+    }\n+\n+    /// Emit the diagnostic.\n+    pub fn emit(self) {\n+        fn to_internal(spans: Vec<Span>) -> super::bridge::client::MultiSpan {\n+            let mut multi_span = super::bridge::client::MultiSpan::new();\n+            for span in spans {\n+                multi_span.push(span.0);\n+            }\n+            multi_span\n+        }\n+\n+        let mut diag = super::bridge::client::Diagnostic::new(\n+            self.level,\n+            &self.message[..],\n+            to_internal(self.spans),\n+        );\n+        for c in self.children {\n+            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n+        }\n+        diag.emit();\n+    }\n+}"}, {"sha": "86657442c065f72635c70c02d4eaa2cc11a22c58", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/mod.rs", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fmod.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,1013 @@\n+//! A support library for macro authors when defining new macros.\n+//!\n+//! This library, provided by the standard distribution, provides the types\n+//! consumed in the interfaces of procedurally defined macro definitions such as\n+//! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n+//! custom derive attributes`#[proc_macro_derive]`.\n+//!\n+//! See [the book] for more.\n+//!\n+//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n+\n+#[doc(hidden)]\n+pub mod bridge;\n+\n+mod diagnostic;\n+\n+pub use diagnostic::{Diagnostic, Level, MultiSpan};\n+\n+use std::cmp::Ordering;\n+use std::ops::{Bound, RangeBounds};\n+use std::path::PathBuf;\n+use std::str::FromStr;\n+use std::{error, fmt, iter, mem};\n+\n+/// Determines whether proc_macro has been made accessible to the currently\n+/// running program.\n+///\n+/// The proc_macro crate is only intended for use inside the implementation of\n+/// procedural macros. All the functions in this crate panic if invoked from\n+/// outside of a procedural macro, such as from a build script or unit test or\n+/// ordinary Rust binary.\n+///\n+/// With consideration for Rust libraries that are designed to support both\n+/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n+/// non-panicking way to detect whether the infrastructure required to use the\n+/// API of proc_macro is presently available. Returns true if invoked from\n+/// inside of a procedural macro, false if invoked from any other binary.\n+pub fn is_available() -> bool {\n+    bridge::Bridge::is_available()\n+}\n+\n+/// The main type provided by this crate, representing an abstract stream of\n+/// tokens, or, more specifically, a sequence of token trees.\n+/// The type provide interfaces for iterating over those token trees and, conversely,\n+/// collecting a number of token trees into one stream.\n+///\n+/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n+/// and `#[proc_macro_derive]` definitions.\n+#[derive(Clone)]\n+pub struct TokenStream(bridge::client::TokenStream);\n+\n+/// Error returned from `TokenStream::from_str`.\n+#[non_exhaustive]\n+#[derive(Debug)]\n+pub struct LexError;\n+\n+impl LexError {\n+    fn new() -> Self {\n+        LexError\n+    }\n+}\n+\n+impl fmt::Display for LexError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"cannot parse string into token stream\")\n+    }\n+}\n+\n+impl error::Error for LexError {}\n+\n+impl TokenStream {\n+    /// Returns an empty `TokenStream` containing no token trees.\n+    pub fn new() -> TokenStream {\n+        TokenStream(bridge::client::TokenStream::new())\n+    }\n+\n+    /// Checks if this `TokenStream` is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n+/// Attempts to break the string into tokens and parse those tokens into a token stream.\n+/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+/// or characters not existing in the language.\n+/// All tokens in the parsed stream get `Span::call_site()` spans.\n+///\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// change these errors into `LexError`s later.\n+impl FromStr for TokenStream {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+        Ok(TokenStream(bridge::client::TokenStream::from_str(src)))\n+    }\n+}\n+\n+/// Prints the token stream as a string that is supposed to be losslessly convertible back\n+/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+/// Prints token in a form convenient for debugging.\n+impl fmt::Debug for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"TokenStream \")?;\n+        f.debug_list().entries(self.clone()).finish()\n+    }\n+}\n+\n+impl Default for TokenStream {\n+    fn default() -> Self {\n+        TokenStream::new()\n+    }\n+}\n+\n+pub use quote::{quote, quote_span};\n+\n+/// Creates a token stream containing a single token tree.\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream(bridge::client::TokenStream::from_token_tree(match tree {\n+            TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n+            TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n+            TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n+            TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n+        }))\n+    }\n+}\n+\n+/// Collects a number of token trees into a single stream.\n+impl iter::FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n+        trees.into_iter().map(TokenStream::from).collect()\n+    }\n+}\n+\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+impl iter::FromIterator<TokenStream> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n+        let mut builder = bridge::client::TokenStreamBuilder::new();\n+        streams.into_iter().for_each(|stream| builder.push(stream.0));\n+        TokenStream(builder.build())\n+    }\n+}\n+\n+impl Extend<TokenTree> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n+        self.extend(trees.into_iter().map(TokenStream::from));\n+    }\n+}\n+\n+impl Extend<TokenStream> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n+        // FIXME(eddyb) Use an optimized implementation if/when possible.\n+        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n+    }\n+}\n+\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n+pub mod token_stream {\n+    use super::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n+\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n+    #[derive(Clone)]\n+    pub struct IntoIter(bridge::client::TokenStreamIter);\n+\n+    impl Iterator for IntoIter {\n+        type Item = TokenTree;\n+\n+        fn next(&mut self) -> Option<TokenTree> {\n+            self.0.next().map(|tree| match tree {\n+                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n+                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n+                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n+                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n+            })\n+        }\n+    }\n+\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = IntoIter;\n+\n+        fn into_iter(self) -> IntoIter {\n+            IntoIter(self.0.into_iter())\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+mod quote;\n+\n+/// A region of source code, along with macro expansion information.\n+#[derive(Copy, Clone)]\n+pub struct Span(bridge::client::Span);\n+\n+macro_rules! diagnostic_method {\n+    ($name:ident, $level:expr) => {\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n+        /// `self`.\n+        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n+            Diagnostic::spanned(self, $level, message)\n+        }\n+    };\n+}\n+\n+impl Span {\n+    /// A span that resolves at the macro definition site.\n+    pub fn def_site() -> Span {\n+        Span(bridge::client::Span::def_site())\n+    }\n+\n+    /// The span of the invocation of the current procedural macro.\n+    /// Identifiers created with this span will be resolved as if they were written\n+    /// directly at the macro call location (call-site hygiene) and other code\n+    /// at the macro call site will be able to refer to them as well.\n+    pub fn call_site() -> Span {\n+        Span(bridge::client::Span::call_site())\n+    }\n+\n+    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n+    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n+    /// call site (everything else).\n+    /// The span location is taken from the call-site.\n+    pub fn mixed_site() -> Span {\n+        Span(bridge::client::Span::mixed_site())\n+    }\n+\n+    /// The original source file into which this span points.\n+    pub fn source_file(&self) -> SourceFile {\n+        SourceFile(self.0.source_file())\n+    }\n+\n+    /// The `Span` for the tokens in the previous macro expansion from which\n+    /// `self` was generated from, if any.\n+    pub fn parent(&self) -> Option<Span> {\n+        self.0.parent().map(Span)\n+    }\n+\n+    /// The span for the origin source code that `self` was generated from. If\n+    /// this `Span` wasn't generated from other macro expansions then the return\n+    /// value is the same as `*self`.\n+    pub fn source(&self) -> Span {\n+        Span(self.0.source())\n+    }\n+\n+    /// Gets the starting line/column in the source file for this span.\n+    pub fn start(&self) -> LineColumn {\n+        self.0.start().add_1_to_column()\n+    }\n+\n+    /// Gets the ending line/column in the source file for this span.\n+    pub fn end(&self) -> LineColumn {\n+        self.0.end().add_1_to_column()\n+    }\n+\n+    /// Creates a new span encompassing `self` and `other`.\n+    ///\n+    /// Returns `None` if `self` and `other` are from different files.\n+    pub fn join(&self, other: Span) -> Option<Span> {\n+        self.0.join(other.0).map(Span)\n+    }\n+\n+    /// Creates a new span with the same line/column information as `self` but\n+    /// that resolves symbols as though it were at `other`.\n+    pub fn resolved_at(&self, other: Span) -> Span {\n+        Span(self.0.resolved_at(other.0))\n+    }\n+\n+    /// Creates a new span with the same name resolution behavior as `self` but\n+    /// with the line/column information of `other`.\n+    pub fn located_at(&self, other: Span) -> Span {\n+        other.resolved_at(*self)\n+    }\n+\n+    /// Compares to spans to see if they're equal.\n+    pub fn eq(&self, other: &Span) -> bool {\n+        self.0 == other.0\n+    }\n+\n+    /// Returns the source text behind a span. This preserves the original source\n+    /// code, including spaces and comments. It only returns a result if the span\n+    /// corresponds to real source code.\n+    ///\n+    /// Note: The observable result of a macro should only rely on the tokens and\n+    /// not on this source text. The result of this function is a best effort to\n+    /// be used for diagnostics only.\n+    pub fn source_text(&self) -> Option<String> {\n+        self.0.source_text()\n+    }\n+\n+    // Used by the implementation of `Span::quote`\n+    #[doc(hidden)]\n+    pub fn save_span(&self) -> usize {\n+        self.0.save_span()\n+    }\n+\n+    // Used by the implementation of `Span::quote`\n+    #[doc(hidden)]\n+    pub fn recover_proc_macro_span(id: usize) -> Span {\n+        Span(bridge::client::Span::recover_proc_macro_span(id))\n+    }\n+\n+    diagnostic_method!(error, Level::Error);\n+    diagnostic_method!(warning, Level::Warning);\n+    diagnostic_method!(note, Level::Note);\n+    diagnostic_method!(help, Level::Help);\n+}\n+\n+/// Prints a span in a form convenient for debugging.\n+impl fmt::Debug for Span {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+/// A line-column pair representing the start or end of a `Span`.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineColumn {\n+    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n+    pub line: usize,\n+    /// The 1-indexed column (number of bytes in UTF-8 encoding) in the source\n+    /// file on which the span starts or ends (inclusive).\n+    pub column: usize,\n+}\n+\n+impl LineColumn {\n+    fn add_1_to_column(self) -> Self {\n+        LineColumn { line: self.line, column: self.column + 1 }\n+    }\n+}\n+\n+impl Ord for LineColumn {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.line.cmp(&other.line).then(self.column.cmp(&other.column))\n+    }\n+}\n+\n+impl PartialOrd for LineColumn {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+/// The source file of a given `Span`.\n+#[derive(Clone)]\n+pub struct SourceFile(bridge::client::SourceFile);\n+\n+impl SourceFile {\n+    /// Gets the path to this source file.\n+    ///\n+    /// ### Note\n+    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n+    /// macro, this might not be an actual path on the filesystem. Use [`is_real`] to check.\n+    ///\n+    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n+    /// the command line, the path as given might not actually be valid.\n+    ///\n+    /// [`is_real`]: Self::is_real\n+    pub fn path(&self) -> PathBuf {\n+        PathBuf::from(self.0.path())\n+    }\n+\n+    /// Returns `true` if this source file is a real source file, and not generated by an external\n+    /// macro's expansion.\n+    pub fn is_real(&self) -> bool {\n+        // This is a hack until intercrate spans are implemented and we can have real source files\n+        // for spans generated in external macros.\n+        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n+        self.0.is_real()\n+    }\n+}\n+\n+impl fmt::Debug for SourceFile {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SourceFile\")\n+            .field(\"path\", &self.path())\n+            .field(\"is_real\", &self.is_real())\n+            .finish()\n+    }\n+}\n+\n+impl PartialEq for SourceFile {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.eq(&other.0)\n+    }\n+}\n+\n+impl Eq for SourceFile {}\n+\n+/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n+#[derive(Clone)]\n+pub enum TokenTree {\n+    /// A token stream surrounded by bracket delimiters.\n+    Group(Group),\n+    /// An identifier.\n+    Ident(Ident),\n+    /// A single punctuation character (`+`, `,`, `$`, etc.).\n+    Punct(Punct),\n+    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n+    Literal(Literal),\n+}\n+\n+impl TokenTree {\n+    /// Returns the span of this tree, delegating to the `span` method of\n+    /// the contained token or a delimited stream.\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            TokenTree::Group(ref t) => t.span(),\n+            TokenTree::Ident(ref t) => t.span(),\n+            TokenTree::Punct(ref t) => t.span(),\n+            TokenTree::Literal(ref t) => t.span(),\n+        }\n+    }\n+\n+    /// Configures the span for *only this token*.\n+    ///\n+    /// Note that if this token is a `Group` then this method will not configure\n+    /// the span of each of the internal tokens, this will simply delegate to\n+    /// the `set_span` method of each variant.\n+    pub fn set_span(&mut self, span: Span) {\n+        match *self {\n+            TokenTree::Group(ref mut t) => t.set_span(span),\n+            TokenTree::Ident(ref mut t) => t.set_span(span),\n+            TokenTree::Punct(ref mut t) => t.set_span(span),\n+            TokenTree::Literal(ref mut t) => t.set_span(span),\n+        }\n+    }\n+}\n+\n+/// Prints token tree in a form convenient for debugging.\n+impl fmt::Debug for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Each of these has the name in the struct type in the derived debug,\n+        // so don't bother with an extra layer of indirection\n+        match *self {\n+            TokenTree::Group(ref tt) => tt.fmt(f),\n+            TokenTree::Ident(ref tt) => tt.fmt(f),\n+            TokenTree::Punct(ref tt) => tt.fmt(f),\n+            TokenTree::Literal(ref tt) => tt.fmt(f),\n+        }\n+    }\n+}\n+\n+impl From<Group> for TokenTree {\n+    fn from(g: Group) -> TokenTree {\n+        TokenTree::Group(g)\n+    }\n+}\n+\n+impl From<Ident> for TokenTree {\n+    fn from(g: Ident) -> TokenTree {\n+        TokenTree::Ident(g)\n+    }\n+}\n+\n+impl From<Punct> for TokenTree {\n+    fn from(g: Punct) -> TokenTree {\n+        TokenTree::Punct(g)\n+    }\n+}\n+\n+impl From<Literal> for TokenTree {\n+    fn from(g: Literal) -> TokenTree {\n+        TokenTree::Literal(g)\n+    }\n+}\n+\n+/// Prints the token tree as a string that is supposed to be losslessly convertible back\n+/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n+impl fmt::Display for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+/// A delimited token stream.\n+///\n+/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n+#[derive(Clone)]\n+pub struct Group(bridge::client::Group);\n+\n+/// Describes how a sequence of token trees is delimited.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Delimiter {\n+    /// `( ... )`\n+    Parenthesis,\n+    /// `{ ... }`\n+    Brace,\n+    /// `[ ... ]`\n+    Bracket,\n+    /// `\u00d8 ... \u00d8`\n+    /// An implicit delimiter, that may, for example, appear around tokens coming from a\n+    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n+    /// `$var * 3` where `$var` is `1 + 2`.\n+    /// Implicit delimiters might not survive roundtrip of a token stream through a string.\n+    None,\n+}\n+\n+impl Group {\n+    /// Creates a new `Group` with the given delimiter and token stream.\n+    ///\n+    /// This constructor will set the span for this group to\n+    /// `Span::call_site()`. To change the span you can use the `set_span`\n+    /// method below.\n+    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n+        Group(bridge::client::Group::new(delimiter, stream.0))\n+    }\n+\n+    /// Returns the delimiter of this `Group`\n+    pub fn delimiter(&self) -> Delimiter {\n+        self.0.delimiter()\n+    }\n+\n+    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n+    ///\n+    /// Note that the returned token stream does not include the delimiter\n+    /// returned above.\n+    pub fn stream(&self) -> TokenStream {\n+        TokenStream(self.0.stream())\n+    }\n+\n+    /// Returns the span for the delimiters of this token stream, spanning the\n+    /// entire `Group`.\n+    ///\n+    /// ```text\n+    /// pub fn span(&self) -> Span {\n+    ///            ^^^^^^^\n+    /// ```\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Returns the span pointing to the opening delimiter of this group.\n+    ///\n+    /// ```text\n+    /// pub fn span_open(&self) -> Span {\n+    ///                 ^\n+    /// ```\n+    pub fn span_open(&self) -> Span {\n+        Span(self.0.span_open())\n+    }\n+\n+    /// Returns the span pointing to the closing delimiter of this group.\n+    ///\n+    /// ```text\n+    /// pub fn span_close(&self) -> Span {\n+    ///                        ^\n+    /// ```\n+    pub fn span_close(&self) -> Span {\n+        Span(self.0.span_close())\n+    }\n+\n+    /// Configures the span for this `Group`'s delimiters, but not its internal\n+    /// tokens.\n+    ///\n+    /// This method will **not** set the span of all the internal tokens spanned\n+    /// by this group, but rather it will only set the span of the delimiter\n+    /// tokens at the level of the `Group`.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0.set_span(span.0);\n+    }\n+}\n+\n+/// Prints the group as a string that should be losslessly convertible back\n+/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n+impl fmt::Display for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Group\")\n+            .field(\"delimiter\", &self.delimiter())\n+            .field(\"stream\", &self.stream())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+/// A `Punct` is a single punctuation character such as `+`, `-` or `#`.\n+///\n+/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n+/// forms of `Spacing` returned.\n+#[derive(Clone)]\n+pub struct Punct(bridge::client::Punct);\n+\n+/// Describes whether a `Punct` is followed immediately by another `Punct` ([`Spacing::Joint`]) or\n+/// by a different token or whitespace ([`Spacing::Alone`]).\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Spacing {\n+    /// A `Punct` is not immediately followed by another `Punct`.\n+    /// E.g. `+` is `Alone` in `+ =`, `+ident` and `+()`.\n+    Alone,\n+    /// A `Punct` is immediately followed by another `Punct`.\n+    /// E.g. `+` is `Joint` in `+=` and `++`.\n+    ///\n+    /// Additionally, single quote `'` can join with identifiers to form lifetimes: `'ident`.\n+    Joint,\n+}\n+\n+impl Punct {\n+    /// Creates a new `Punct` from the given character and spacing.\n+    /// The `ch` argument must be a valid punctuation character permitted by the language,\n+    /// otherwise the function will panic.\n+    ///\n+    /// The returned `Punct` will have the default span of `Span::call_site()`\n+    /// which can be further configured with the `set_span` method below.\n+    pub fn new(ch: char, spacing: Spacing) -> Punct {\n+        Punct(bridge::client::Punct::new(ch, spacing))\n+    }\n+\n+    /// Returns the value of this punctuation character as `char`.\n+    pub fn as_char(&self) -> char {\n+        self.0.as_char()\n+    }\n+\n+    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n+    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n+    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n+    /// (`Alone`) so the operator has certainly ended.\n+    pub fn spacing(&self) -> Spacing {\n+        self.0.spacing()\n+    }\n+\n+    /// Returns the span for this punctuation character.\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configure the span for this punctuation character.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+/// Prints the punctuation character as a string that should be losslessly convertible\n+/// back into the same character.\n+impl fmt::Display for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Punct\")\n+            .field(\"ch\", &self.as_char())\n+            .field(\"spacing\", &self.spacing())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+impl PartialEq<char> for Punct {\n+    fn eq(&self, rhs: &char) -> bool {\n+        self.as_char() == *rhs\n+    }\n+}\n+\n+impl PartialEq<Punct> for char {\n+    fn eq(&self, rhs: &Punct) -> bool {\n+        *self == rhs.as_char()\n+    }\n+}\n+\n+/// An identifier (`ident`).\n+#[derive(Clone)]\n+pub struct Ident(bridge::client::Ident);\n+\n+impl Ident {\n+    /// Creates a new `Ident` with the given `string` as well as the specified\n+    /// `span`.\n+    /// The `string` argument must be a valid identifier permitted by the\n+    /// language (including keywords, e.g. `self` or `fn`). Otherwise, the function will panic.\n+    ///\n+    /// Note that `span`, currently in rustc, configures the hygiene information\n+    /// for this identifier.\n+    ///\n+    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved as if they were written\n+    /// directly at the location of the macro call, and other code at the macro call site will be\n+    /// able to refer to them as well.\n+    ///\n+    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved at the location of the\n+    /// macro definition and other code at the macro call site will not be able to refer to them.\n+    ///\n+    /// Due to the current importance of hygiene this constructor, unlike other\n+    /// tokens, requires a `Span` to be specified at construction.\n+    pub fn new(string: &str, span: Span) -> Ident {\n+        Ident(bridge::client::Ident::new(string, span.0, false))\n+    }\n+\n+    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n+    /// The `string` argument be a valid identifier permitted by the language\n+    /// (including keywords, e.g. `fn`). Keywords which are usable in path segments\n+    /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n+    pub fn new_raw(string: &str, span: Span) -> Ident {\n+        Ident(bridge::client::Ident::new(string, span.0, true))\n+    }\n+\n+    /// Returns the span of this `Ident`, encompassing the entire string returned\n+    /// by [`to_string`](Self::to_string).\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0 = self.0.with_span(span.0);\n+    }\n+}\n+\n+/// Prints the identifier as a string that should be losslessly convertible\n+/// back into the same identifier.\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Ident\")\n+            .field(\"ident\", &self.to_string())\n+            .field(\"span\", &self.span())\n+            .finish()\n+    }\n+}\n+\n+/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n+/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n+/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n+/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n+#[derive(Clone)]\n+pub struct Literal(bridge::client::Literal);\n+\n+macro_rules! suffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new suffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1u32` where the integer\n+        /// value specified is the first part of the token and the integral is\n+        /// also suffixed at the end.\n+        /// Literals created from negative numbers might not survive round-trips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n+        pub fn $name(n: $kind) -> Literal {\n+            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n+        }\n+    )*)\n+}\n+\n+macro_rules! unsuffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new unsuffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1` where the integer\n+        /// value specified is the first part of the token. No suffix is\n+        /// specified on this token, meaning that invocations like\n+        /// `Literal::i8_unsuffixed(1)` are equivalent to\n+        /// `Literal::u32_unsuffixed(1)`.\n+        /// Literals created from negative numbers might not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n+        pub fn $name(n: $kind) -> Literal {\n+            Literal(bridge::client::Literal::integer(&n.to_string()))\n+        }\n+    )*)\n+}\n+\n+impl Literal {\n+    suffixed_int_literals! {\n+        u8_suffixed => u8,\n+        u16_suffixed => u16,\n+        u32_suffixed => u32,\n+        u64_suffixed => u64,\n+        u128_suffixed => u128,\n+        usize_suffixed => usize,\n+        i8_suffixed => i8,\n+        i16_suffixed => i16,\n+        i32_suffixed => i32,\n+        i64_suffixed => i64,\n+        i128_suffixed => i128,\n+        isize_suffixed => isize,\n+    }\n+\n+    unsuffixed_int_literals! {\n+        u8_unsuffixed => u8,\n+        u16_unsuffixed => u16,\n+        u32_unsuffixed => u32,\n+        u64_unsuffixed => u64,\n+        u128_unsuffixed => u128,\n+        usize_unsuffixed => usize,\n+        i8_unsuffixed => i8,\n+        i16_unsuffixed => i16,\n+        i32_unsuffixed => i32,\n+        i64_unsuffixed => i64,\n+        i128_unsuffixed => i128,\n+        isize_unsuffixed => isize,\n+    }\n+\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers might not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f32_unsuffixed(n: f32) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n+    }\n+\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This constructor will create a literal like `1.0f32` where the value\n+    /// specified is the preceding part of the token and `f32` is the suffix of\n+    /// the token. This token will always be inferred to be an `f32` in the\n+    /// compiler.\n+    /// Literals created from negative numbers might not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f32_suffixed(n: f32) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::f32(&n.to_string()))\n+    }\n+\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers might not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f64_unsuffixed(n: f64) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::float(&n.to_string()))\n+    }\n+\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This constructor will create a literal like `1.0f64` where the value\n+    /// specified is the preceding part of the token and `f64` is the suffix of\n+    /// the token. This token will always be inferred to be an `f64` in the\n+    /// compiler.\n+    /// Literals created from negative numbers might not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    pub fn f64_suffixed(n: f64) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        Literal(bridge::client::Literal::f64(&n.to_string()))\n+    }\n+\n+    /// String literal.\n+    pub fn string(string: &str) -> Literal {\n+        Literal(bridge::client::Literal::string(string))\n+    }\n+\n+    /// Character literal.\n+    pub fn character(ch: char) -> Literal {\n+        Literal(bridge::client::Literal::character(ch))\n+    }\n+\n+    /// Byte string literal.\n+    pub fn byte_string(bytes: &[u8]) -> Literal {\n+        Literal(bridge::client::Literal::byte_string(bytes))\n+    }\n+\n+    /// Returns the span encompassing this literal.\n+    pub fn span(&self) -> Span {\n+        Span(self.0.span())\n+    }\n+\n+    /// Configures the span associated for this literal.\n+    pub fn set_span(&mut self, span: Span) {\n+        self.0.set_span(span.0);\n+    }\n+\n+    /// Returns a `Span` that is a subset of `self.span()` containing only the\n+    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n+    /// span is outside the bounds of `self`.\n+    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n+    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n+    // occur elsewhere when the source text is printed.\n+    // FIXME(SergioBenitez): there is no way for the user to know what\n+    // `self.span()` actually maps to, so this method can currently only be\n+    // called blindly. For example, `to_string()` for the character 'c' returns\n+    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n+    // was 'c' or whether it was '\\u{63}'.\n+    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n+        // HACK(eddyb) something akin to `Option::cloned`, but for `Bound<&T>`.\n+        fn cloned_bound<T: Clone>(bound: Bound<&T>) -> Bound<T> {\n+            match bound {\n+                Bound::Included(x) => Bound::Included(x.clone()),\n+                Bound::Excluded(x) => Bound::Excluded(x.clone()),\n+                Bound::Unbounded => Bound::Unbounded,\n+            }\n+        }\n+\n+        self.0.subspan(cloned_bound(range.start_bound()), cloned_bound(range.end_bound())).map(Span)\n+    }\n+}\n+\n+/// Parse a single literal from its stringified representation.\n+///\n+/// In order to parse successfully, the input string must not contain anything\n+/// but the literal token. Specifically, it must not contain whitespace or\n+/// comments in addition to the literal.\n+///\n+/// The resulting literal token will have a `Span::call_site()` span.\n+///\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We\n+/// reserve the right to change these errors into `LexError`s later.\n+impl FromStr for Literal {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<Self, LexError> {\n+        match bridge::client::Literal::from_str(src) {\n+            Ok(literal) => Ok(Literal(literal)),\n+            Err(()) => Err(LexError::new()),\n+        }\n+    }\n+}\n+\n+/// Prints the literal as a string that should be losslessly convertible\n+/// back into the same literal (except for possible rounding for floating point literals).\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(&self.to_string())\n+    }\n+}\n+\n+impl fmt::Debug for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+/// Tracked access to environment variables.\n+pub mod tracked_env {\n+    use std::env::{self, VarError};\n+    use std::ffi::OsStr;\n+\n+    /// Retrieve an environment variable and add it to build dependency info.\n+    /// Build system executing the compiler will know that the variable was accessed during\n+    /// compilation, and will be able to rerun the build when the value of that variable changes.\n+    /// Besides the dependency tracking this function should be equivalent to `env::var` from the\n+    /// standard library, except that the argument must be UTF-8.\n+    pub fn var<K: AsRef<OsStr> + AsRef<str>>(key: K) -> Result<String, VarError> {\n+        let key: &str = key.as_ref();\n+        let value = env::var(key);\n+        super::bridge::client::FreeFunctions::track_env_var(key, value.as_deref().ok());\n+        value\n+    }\n+}\n+\n+/// Tracked access to additional files.\n+pub mod tracked_path {\n+\n+    /// Track a file explicitly.\n+    ///\n+    /// Commonly used for tracking asset preprocessing.\n+    pub fn path<P: AsRef<str>>(path: P) {\n+        let path: &str = path.as_ref();\n+        super::bridge::client::FreeFunctions::track_path(path);\n+    }\n+}"}, {"sha": "b539ab9c0c6d6b236de6995f626013743bd21864", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/proc_macro/quote.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fproc_macro%2Fquote.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,140 @@\n+//! # Quasiquoter\n+//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n+\n+//! This quasiquoter uses macros 2.0 hygiene to reliably access\n+//! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n+\n+use super::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+\n+macro_rules! quote_tt {\n+    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n+    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n+    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n+    (,) => { Punct::new(',', Spacing::Alone) };\n+    (.) => { Punct::new('.', Spacing::Alone) };\n+    (:) => { Punct::new(':', Spacing::Alone) };\n+    (;) => { Punct::new(';', Spacing::Alone) };\n+    (!) => { Punct::new('!', Spacing::Alone) };\n+    (<) => { Punct::new('<', Spacing::Alone) };\n+    (>) => { Punct::new('>', Spacing::Alone) };\n+    (&) => { Punct::new('&', Spacing::Alone) };\n+    (=) => { Punct::new('=', Spacing::Alone) };\n+    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n+}\n+\n+macro_rules! quote_ts {\n+    ((@ $($t:tt)*)) => { $($t)* };\n+    (::) => {\n+        [\n+            TokenTree::from(Punct::new(':', Spacing::Joint)),\n+            TokenTree::from(Punct::new(':', Spacing::Alone)),\n+        ].iter()\n+            .cloned()\n+            .map(|mut x| {\n+                x.set_span(Span::def_site());\n+                x\n+            })\n+            .collect::<TokenStream>()\n+    };\n+    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n+}\n+\n+/// Simpler version of the real `quote!` macro, implemented solely\n+/// through `macro_rules`, for bootstrapping the real implementation\n+/// (see the `quote` function), which does not have access to the\n+/// real `quote!` macro due to the `proc_macro` crate not being\n+/// able to depend on itself.\n+///\n+/// Note: supported tokens are a subset of the real `quote!`, but\n+/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n+macro_rules! quote {\n+    () => { TokenStream::new() };\n+    ($($t:tt)*) => {\n+        [\n+            $(TokenStream::from(quote_ts!($t)),)*\n+        ].iter().cloned().collect::<TokenStream>()\n+    };\n+}\n+\n+/// Quote a `TokenStream` into a `TokenStream`.\n+/// This is the actual implementation of the `quote!()` proc macro.\n+///\n+/// It is loaded by the compiler in `register_builtin_macros`.\n+pub fn quote(stream: TokenStream) -> TokenStream {\n+    if stream.is_empty() {\n+        return quote!(crate::TokenStream::new());\n+    }\n+    let proc_macro_crate = quote!(crate);\n+    let mut after_dollar = false;\n+    let tokens = stream\n+        .into_iter()\n+        .filter_map(|tree| {\n+            if after_dollar {\n+                after_dollar = false;\n+                match tree {\n+                    TokenTree::Ident(_) => {\n+                        return Some(quote!(Into::<crate::TokenStream>::into(\n+                        Clone::clone(&(@ tree))),));\n+                    }\n+                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n+                    _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n+                }\n+            } else if let TokenTree::Punct(ref tt) = tree {\n+                if tt.as_char() == '$' {\n+                    after_dollar = true;\n+                    return None;\n+                }\n+            }\n+\n+            Some(quote!(crate::TokenStream::from((@ match tree {\n+                TokenTree::Punct(tt) => quote!(crate::TokenTree::Punct(crate::Punct::new(\n+                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n+                    (@ match tt.spacing() {\n+                        Spacing::Alone => quote!(crate::Spacing::Alone),\n+                        Spacing::Joint => quote!(crate::Spacing::Joint),\n+                    }),\n+                ))),\n+                TokenTree::Group(tt) => quote!(crate::TokenTree::Group(crate::Group::new(\n+                    (@ match tt.delimiter() {\n+                        Delimiter::Parenthesis => quote!(crate::Delimiter::Parenthesis),\n+                        Delimiter::Brace => quote!(crate::Delimiter::Brace),\n+                        Delimiter::Bracket => quote!(crate::Delimiter::Bracket),\n+                        Delimiter::None => quote!(crate::Delimiter::None),\n+                    }),\n+                    (@ quote(tt.stream())),\n+                ))),\n+                TokenTree::Ident(tt) => quote!(crate::TokenTree::Ident(crate::Ident::new(\n+                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n+                    (@ quote_span(proc_macro_crate.clone(), tt.span())),\n+                ))),\n+                TokenTree::Literal(tt) => quote!(crate::TokenTree::Literal({\n+                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n+                        .parse::<crate::TokenStream>()\n+                        .unwrap()\n+                        .into_iter();\n+                    if let (Some(crate::TokenTree::Literal(mut lit)), None) =\n+                        (iter.next(), iter.next())\n+                    {\n+                        lit.set_span((@ quote_span(proc_macro_crate.clone(), tt.span())));\n+                        lit\n+                    } else {\n+                        unreachable!()\n+                    }\n+                }))\n+            })),))\n+        })\n+        .collect::<TokenStream>();\n+\n+    if after_dollar {\n+        panic!(\"unexpected trailing `$` in `quote!`\");\n+    }\n+\n+    quote!([(@ tokens)].iter().cloned().collect::<crate::TokenStream>())\n+}\n+\n+/// Quote a `Span` into a `TokenStream`.\n+/// This is needed to implement a custom quoter.\n+pub fn quote_span(proc_macro_crate: TokenStream, span: Span) -> TokenStream {\n+    let id = span.save_span();\n+    quote!((@ proc_macro_crate ) ::Span::recover_proc_macro_span((@ TokenTree::from(Literal::usize_unsuffixed(id)))))\n+}"}, {"sha": "562ee69e3770a3e4ce295adf0bada6b04b8eaae2", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/rustc_server.rs", "status": "added", "additions": 846, "deletions": 0, "changes": 846, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Frustc_server.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -0,0 +1,846 @@\n+//! Rustc proc-macro server implementation with tt\n+//!\n+//! Based on idea from <https://github.com/fedochet/rust-proc-macro-expander>\n+//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n+//! we could provide any TokenStream implementation.\n+//! The original idea from fedochet is using proc-macro2 as backend,\n+//! we use tt instead for better integration with RA.\n+//!\n+//! FIXME: No span and source file information is implemented yet\n+\n+use super::proc_macro::bridge::{self, server};\n+\n+use std::collections::HashMap;\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+use std::ops::Bound;\n+use std::{ascii, vec::IntoIter};\n+\n+type Group = tt::Subtree;\n+type TokenTree = tt::TokenTree;\n+type Punct = tt::Punct;\n+type Spacing = tt::Spacing;\n+type Literal = tt::Literal;\n+type Span = tt::TokenId;\n+\n+#[derive(Debug, Clone)]\n+pub struct TokenStream {\n+    pub token_trees: Vec<TokenTree>,\n+}\n+\n+impl TokenStream {\n+    pub fn new() -> Self {\n+        TokenStream { token_trees: Default::default() }\n+    }\n+\n+    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+        if subtree.delimiter.is_some() {\n+            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n+        } else {\n+            TokenStream { token_trees: subtree.token_trees }\n+        }\n+    }\n+\n+    pub fn into_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.token_trees.is_empty()\n+    }\n+}\n+\n+/// Creates a token stream containing a single token tree.\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream { token_trees: vec![tree] }\n+    }\n+}\n+\n+/// Collects a number of token trees into a single stream.\n+impl FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n+        trees.into_iter().map(TokenStream::from).collect()\n+    }\n+}\n+\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+impl FromIterator<TokenStream> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n+        let mut builder = TokenStreamBuilder::new();\n+        streams.into_iter().for_each(|stream| builder.push(stream));\n+        builder.build()\n+    }\n+}\n+\n+impl Extend<TokenTree> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n+        self.extend(trees.into_iter().map(TokenStream::from));\n+    }\n+}\n+\n+impl Extend<TokenStream> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n+        for item in streams {\n+            for tkn in item {\n+                match tkn {\n+                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n+                        self.token_trees.extend(subtree.token_trees);\n+                    }\n+                    _ => {\n+                        self.token_trees.push(tkn);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+type Level = super::proc_macro::Level;\n+type LineColumn = super::proc_macro::LineColumn;\n+type SourceFile = super::proc_macro::SourceFile;\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    spans: Vec<Span>,\n+    children: Vec<Diagnostic>,\n+}\n+\n+impl Diagnostic {\n+    /// Creates a new diagnostic with the given `level` and `message`.\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n+    }\n+}\n+\n+// Rustc Server Ident has to be `Copyable`\n+// We use a stub here for bypassing\n+#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n+pub struct IdentId(u32);\n+\n+#[derive(Clone, Hash, Eq, PartialEq)]\n+struct IdentData(tt::Ident);\n+\n+#[derive(Default)]\n+struct IdentInterner {\n+    idents: HashMap<IdentData, u32>,\n+    ident_data: Vec<IdentData>,\n+}\n+\n+impl IdentInterner {\n+    fn intern(&mut self, data: &IdentData) -> u32 {\n+        if let Some(index) = self.idents.get(data) {\n+            return *index;\n+        }\n+\n+        let index = self.idents.len() as u32;\n+        self.ident_data.push(data.clone());\n+        self.idents.insert(data.clone(), index);\n+        index\n+    }\n+\n+    fn get(&self, index: u32) -> &IdentData {\n+        &self.ident_data[index as usize]\n+    }\n+\n+    #[allow(unused)]\n+    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n+        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n+    }\n+}\n+\n+pub struct TokenStreamBuilder {\n+    acc: TokenStream,\n+}\n+\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n+pub mod token_stream {\n+    use std::str::FromStr;\n+\n+    use super::{TokenStream, TokenTree};\n+\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = super::IntoIter<TokenTree>;\n+\n+        fn into_iter(self) -> Self::IntoIter {\n+            self.token_trees.into_iter()\n+        }\n+    }\n+\n+    type LexError = String;\n+\n+    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n+    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+    /// or characters not existing in the language.\n+    /// All tokens in the parsed stream get `Span::call_site()` spans.\n+    ///\n+    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n+    /// change these errors into `LexError`s later.\n+    impl FromStr for TokenStream {\n+        type Err = LexError;\n+\n+        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+            let (subtree, _token_map) =\n+                mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n+\n+            let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n+            Ok(TokenStream::with_subtree(subtree))\n+        }\n+    }\n+\n+    impl ToString for TokenStream {\n+        fn to_string(&self) -> String {\n+            return tokentrees_to_text(&self.token_trees[..]);\n+\n+            fn tokentrees_to_text(tkns: &[tt::TokenTree]) -> String {\n+                tkns.iter()\n+                    .fold((String::new(), true), |(last, last_to_joint), tkn| {\n+                        let s = [last, tokentree_to_text(tkn)].join(if last_to_joint {\n+                            \"\"\n+                        } else {\n+                            \" \"\n+                        });\n+                        let mut is_joint = false;\n+                        if let tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) = tkn {\n+                            if punct.spacing == tt::Spacing::Joint {\n+                                is_joint = true;\n+                            }\n+                        }\n+                        (s, is_joint)\n+                    })\n+                    .0\n+            }\n+\n+            fn tokentree_to_text(tkn: &tt::TokenTree) -> String {\n+                match tkn {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => ident.text.clone().into(),\n+                    tt::TokenTree::Leaf(tt::Leaf::Literal(literal)) => literal.text.clone().into(),\n+                    tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => format!(\"{}\", punct.char),\n+                    tt::TokenTree::Subtree(subtree) => {\n+                        let content = tokentrees_to_text(&subtree.token_trees);\n+                        let (open, close) = match subtree.delimiter.map(|it| it.kind) {\n+                            None => (\"\", \"\"),\n+                            Some(tt::DelimiterKind::Brace) => (\"{\", \"}\"),\n+                            Some(tt::DelimiterKind::Parenthesis) => (\"(\", \")\"),\n+                            Some(tt::DelimiterKind::Bracket) => (\"[\", \"]\"),\n+                        };\n+                        format!(\"{}{}{}\", open, content, close)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n+        tt::Subtree {\n+            delimiter: subtree\n+                .delimiter\n+                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n+            token_trees: subtree\n+                .token_trees\n+                .into_iter()\n+                .map(token_tree_replace_token_ids_with_unspecified)\n+                .collect(),\n+        }\n+    }\n+\n+    fn token_tree_replace_token_ids_with_unspecified(tt: tt::TokenTree) -> tt::TokenTree {\n+        match tt {\n+            tt::TokenTree::Leaf(leaf) => {\n+                tt::TokenTree::Leaf(leaf_replace_token_ids_with_unspecified(leaf))\n+            }\n+            tt::TokenTree::Subtree(subtree) => {\n+                tt::TokenTree::Subtree(subtree_replace_token_ids_with_unspecified(subtree))\n+            }\n+        }\n+    }\n+\n+    fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n+        match leaf {\n+            tt::Leaf::Literal(lit) => {\n+                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n+            }\n+            tt::Leaf::Punct(punct) => {\n+                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n+            }\n+            tt::Leaf::Ident(ident) => {\n+                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n+            }\n+        }\n+    }\n+}\n+\n+impl TokenStreamBuilder {\n+    fn new() -> TokenStreamBuilder {\n+        TokenStreamBuilder { acc: TokenStream::new() }\n+    }\n+\n+    fn push(&mut self, stream: TokenStream) {\n+        self.acc.extend(stream.into_iter())\n+    }\n+\n+    fn build(self) -> TokenStream {\n+        self.acc\n+    }\n+}\n+\n+pub struct FreeFunctions;\n+\n+#[derive(Clone)]\n+pub struct TokenStreamIter {\n+    trees: IntoIter<TokenTree>,\n+}\n+\n+#[derive(Default)]\n+pub struct Rustc {\n+    ident_interner: IdentInterner,\n+    // FIXME: store span information here.\n+}\n+\n+impl server::Types for Rustc {\n+    type FreeFunctions = FreeFunctions;\n+    type TokenStream = TokenStream;\n+    type TokenStreamBuilder = TokenStreamBuilder;\n+    type TokenStreamIter = TokenStreamIter;\n+    type Group = Group;\n+    type Punct = Punct;\n+    type Ident = IdentId;\n+    type Literal = Literal;\n+    type SourceFile = SourceFile;\n+    type Diagnostic = Diagnostic;\n+    type Span = Span;\n+    type MultiSpan = Vec<Span>;\n+}\n+\n+impl server::FreeFunctions for Rustc {\n+    fn track_env_var(&mut self, _var: &str, _value: Option<&str>) {\n+        // FIXME: track env var accesses\n+        // https://github.com/rust-lang/rust/pull/71858\n+    }\n+    fn track_path(&mut self, _path: &str) {}\n+}\n+\n+impl server::TokenStream for Rustc {\n+    fn new(&mut self) -> Self::TokenStream {\n+        Self::TokenStream::new()\n+    }\n+\n+    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n+        stream.is_empty()\n+    }\n+    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n+        use std::str::FromStr;\n+\n+        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n+    }\n+    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n+        stream.to_string()\n+    }\n+    fn from_token_tree(\n+        &mut self,\n+        tree: bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n+    ) -> Self::TokenStream {\n+        match tree {\n+            bridge::TokenTree::Group(group) => {\n+                let tree = TokenTree::from(group);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Ident(IdentId(index)) => {\n+                let IdentData(ident) = self.ident_interner.get(index).clone();\n+                let ident: tt::Ident = ident;\n+                let leaf = tt::Leaf::from(ident);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Literal(literal) => {\n+                let leaf = tt::Leaf::from(literal);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Punct(p) => {\n+                let leaf = tt::Leaf::from(p);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+        }\n+    }\n+\n+    fn into_iter(&mut self, stream: Self::TokenStream) -> Self::TokenStreamIter {\n+        let trees: Vec<TokenTree> = stream.into_iter().collect();\n+        TokenStreamIter { trees: trees.into_iter() }\n+    }\n+}\n+\n+impl server::TokenStreamBuilder for Rustc {\n+    fn new(&mut self) -> Self::TokenStreamBuilder {\n+        Self::TokenStreamBuilder::new()\n+    }\n+    fn push(&mut self, builder: &mut Self::TokenStreamBuilder, stream: Self::TokenStream) {\n+        builder.push(stream)\n+    }\n+    fn build(&mut self, builder: Self::TokenStreamBuilder) -> Self::TokenStream {\n+        builder.build()\n+    }\n+}\n+\n+impl server::TokenStreamIter for Rustc {\n+    fn next(\n+        &mut self,\n+        iter: &mut Self::TokenStreamIter,\n+    ) -> Option<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        iter.trees.next().map(|tree| match tree {\n+            TokenTree::Subtree(group) => bridge::TokenTree::Group(group),\n+            TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n+            }\n+            TokenTree::Leaf(tt::Leaf::Literal(literal)) => bridge::TokenTree::Literal(literal),\n+            TokenTree::Leaf(tt::Leaf::Punct(punct)) => bridge::TokenTree::Punct(punct),\n+        })\n+    }\n+}\n+\n+fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n+    let kind = match d {\n+        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n+        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n+        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n+        bridge::Delimiter::None => return None,\n+    };\n+    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n+}\n+\n+fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n+    match d.map(|it| it.kind) {\n+        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n+        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n+        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n+        None => bridge::Delimiter::None,\n+    }\n+}\n+\n+fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n+    match spacing {\n+        bridge::Spacing::Alone => Spacing::Alone,\n+        bridge::Spacing::Joint => Spacing::Joint,\n+    }\n+}\n+\n+fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n+    match spacing {\n+        Spacing::Alone => bridge::Spacing::Alone,\n+        Spacing::Joint => bridge::Spacing::Joint,\n+    }\n+}\n+\n+impl server::Group for Rustc {\n+    fn new(&mut self, delimiter: bridge::Delimiter, stream: Self::TokenStream) -> Self::Group {\n+        Self::Group { delimiter: delim_to_internal(delimiter), token_trees: stream.token_trees }\n+    }\n+    fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n+        delim_to_external(group.delimiter)\n+    }\n+\n+    // NOTE: Return value of do not include delimiter\n+    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n+        TokenStream { token_trees: group.token_trees.clone() }\n+    }\n+\n+    fn span(&mut self, group: &Self::Group) -> Self::Span {\n+        group.delimiter.map(|it| it.id).unwrap_or_else(tt::TokenId::unspecified)\n+    }\n+\n+    fn set_span(&mut self, _group: &mut Self::Group, _span: Self::Span) {\n+        // FIXME handle span\n+    }\n+\n+    fn span_open(&mut self, _group: &Self::Group) -> Self::Span {\n+        // FIXME handle span\n+        // MySpan(self.span_interner.intern(&MySpanData(group.span_open())))\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn span_close(&mut self, _group: &Self::Group) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+}\n+\n+impl server::Punct for Rustc {\n+    fn new(&mut self, ch: char, spacing: bridge::Spacing) -> Self::Punct {\n+        tt::Punct {\n+            char: ch,\n+            spacing: spacing_to_internal(spacing),\n+            id: tt::TokenId::unspecified(),\n+        }\n+    }\n+    fn as_char(&mut self, punct: Self::Punct) -> char {\n+        punct.char\n+    }\n+    fn spacing(&mut self, punct: Self::Punct) -> bridge::Spacing {\n+        spacing_to_external(punct.spacing)\n+    }\n+    fn span(&mut self, _punct: Self::Punct) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn with_span(&mut self, punct: Self::Punct, _span: Self::Span) -> Self::Punct {\n+        // FIXME handle span\n+        punct\n+    }\n+}\n+\n+impl server::Ident for Rustc {\n+    fn new(&mut self, string: &str, _span: Self::Span, _is_raw: bool) -> Self::Ident {\n+        IdentId(\n+            self.ident_interner.intern(&IdentData(tt::Ident {\n+                text: string.into(),\n+                id: tt::TokenId::unspecified(),\n+            })),\n+        )\n+    }\n+\n+    fn span(&mut self, _ident: Self::Ident) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn with_span(&mut self, ident: Self::Ident, _span: Self::Span) -> Self::Ident {\n+        // FIXME handle span\n+        ident\n+    }\n+}\n+\n+impl server::Literal for Rustc {\n+    fn debug_kind(&mut self, _literal: &Self::Literal) -> String {\n+        // r-a: debug_kind and suffix are unsupported; corresponding client code has been changed to not call these.\n+        // They must still be present to be ABI-compatible and work with upstream proc_macro.\n+        \"\".to_owned()\n+    }\n+    fn from_str(&mut self, _s: &str) -> Result<Self::Literal, ()> {\n+        unimplemented!()\n+    }\n+    fn symbol(&mut self, literal: &Self::Literal) -> String {\n+        literal.text.to_string()\n+    }\n+    fn suffix(&mut self, _literal: &Self::Literal) -> Option<String> {\n+        None\n+    }\n+\n+    fn to_string(&mut self, _literal: &Self::Literal) -> String {\n+        _literal.to_string()\n+    }\n+\n+    fn integer(&mut self, n: &str) -> Self::Literal {\n+        let n = if let Ok(n) = n.parse::<i128>() {\n+            n.to_string()\n+        } else {\n+            n.parse::<u128>().unwrap().to_string()\n+        };\n+        Literal { text: n.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n+        macro_rules! def_suffixed_integer {\n+            ($kind:ident, $($ty:ty),*) => {\n+                match $kind {\n+                    $(\n+                        stringify!($ty) => {\n+                            let n: $ty = n.parse().unwrap();\n+                            format!(concat!(\"{}\", stringify!($ty)), n)\n+                        }\n+                    )*\n+                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n+                }\n+            }\n+        }\n+\n+        let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n+\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn float(&mut self, n: &str) -> Self::Literal {\n+        let n: f64 = n.parse().unwrap();\n+        let mut text = f64::to_string(&n);\n+        if !text.contains('.') {\n+            text += \".0\"\n+        }\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn f32(&mut self, n: &str) -> Self::Literal {\n+        let n: f32 = n.parse().unwrap();\n+        let text = format!(\"{}f32\", n);\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn f64(&mut self, n: &str) -> Self::Literal {\n+        let n: f64 = n.parse().unwrap();\n+        let text = format!(\"{}f64\", n);\n+        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn string(&mut self, string: &str) -> Self::Literal {\n+        let mut escaped = String::new();\n+        for ch in string.chars() {\n+            escaped.extend(ch.escape_debug());\n+        }\n+        Literal { text: format!(\"\\\"{}\\\"\", escaped).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn character(&mut self, ch: char) -> Self::Literal {\n+        Literal { text: format!(\"'{}'\", ch).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n+        let string = bytes\n+            .iter()\n+            .cloned()\n+            .flat_map(ascii::escape_default)\n+            .map(Into::<char>::into)\n+            .collect::<String>();\n+\n+        Literal { text: format!(\"b\\\"{}\\\"\", string).into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n+        literal.id\n+    }\n+\n+    fn set_span(&mut self, _literal: &mut Self::Literal, _span: Self::Span) {\n+        // FIXME handle span\n+    }\n+\n+    fn subspan(\n+        &mut self,\n+        _literal: &Self::Literal,\n+        _start: Bound<usize>,\n+        _end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        // FIXME handle span\n+        None\n+    }\n+}\n+\n+impl server::SourceFile for Rustc {\n+    fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n+        file1.eq(file2)\n+    }\n+    fn path(&mut self, file: &Self::SourceFile) -> String {\n+        String::from(\n+            file.path().to_str().expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\"),\n+        )\n+    }\n+    fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n+        file.is_real()\n+    }\n+}\n+\n+impl server::Diagnostic for Rustc {\n+    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n+        let mut diag = Diagnostic::new(level, msg);\n+        diag.spans = spans;\n+        diag\n+    }\n+\n+    fn sub(\n+        &mut self,\n+        _diag: &mut Self::Diagnostic,\n+        _level: Level,\n+        _msg: &str,\n+        _spans: Self::MultiSpan,\n+    ) {\n+        // FIXME handle diagnostic\n+        //\n+    }\n+\n+    fn emit(&mut self, _diag: Self::Diagnostic) {\n+        // FIXME handle diagnostic\n+        // diag.emit()\n+    }\n+}\n+\n+impl server::Span for Rustc {\n+    fn debug(&mut self, span: Self::Span) -> String {\n+        format!(\"{:?}\", span.0)\n+    }\n+    fn def_site(&mut self) -> Self::Span {\n+        // MySpan(self.span_interner.intern(&MySpanData(Span::def_site())))\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn call_site(&mut self) -> Self::Span {\n+        // MySpan(self.span_interner.intern(&MySpanData(Span::call_site())))\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n+        // let MySpanData(span) = self.span_interner.get(span.0);\n+        unimplemented!()\n+    }\n+    fn save_span(&mut self, _span: Self::Span) -> usize {\n+        unimplemented!()\n+    }\n+    fn recover_proc_macro_span(&mut self, _id: usize) -> Self::Span {\n+        unimplemented!()\n+    }\n+    /// Recent feature, not yet in the proc_macro\n+    ///\n+    /// See PR:\n+    /// https://github.com/rust-lang/rust/pull/55780\n+    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n+        None\n+    }\n+\n+    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n+        // FIXME handle span\n+        None\n+    }\n+    fn source(&mut self, span: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        span\n+    }\n+    fn start(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn end(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn join(&mut self, _first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n+        None\n+    }\n+    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn mixed_site(&mut self) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+}\n+\n+impl server::MultiSpan for Rustc {\n+    fn new(&mut self) -> Self::MultiSpan {\n+        // FIXME handle span\n+        vec![]\n+    }\n+\n+    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n+        //TODP\n+        other.push(span)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::super::proc_macro::bridge::server::Literal;\n+    use super::*;\n+\n+    #[test]\n+    fn test_rustc_server_literals() {\n+        let mut srv = Rustc { ident_interner: IdentInterner::default() };\n+        assert_eq!(srv.integer(\"1234\").text, \"1234\");\n+\n+        assert_eq!(srv.typed_integer(\"12\", \"u8\").text, \"12u8\");\n+        assert_eq!(srv.typed_integer(\"255\", \"u16\").text, \"255u16\");\n+        assert_eq!(srv.typed_integer(\"1234\", \"u32\").text, \"1234u32\");\n+        assert_eq!(srv.typed_integer(\"15846685\", \"u64\").text, \"15846685u64\");\n+        assert_eq!(srv.typed_integer(\"15846685258\", \"u128\").text, \"15846685258u128\");\n+        assert_eq!(srv.typed_integer(\"156788984\", \"usize\").text, \"156788984usize\");\n+        assert_eq!(srv.typed_integer(\"127\", \"i8\").text, \"127i8\");\n+        assert_eq!(srv.typed_integer(\"255\", \"i16\").text, \"255i16\");\n+        assert_eq!(srv.typed_integer(\"1234\", \"i32\").text, \"1234i32\");\n+        assert_eq!(srv.typed_integer(\"15846685\", \"i64\").text, \"15846685i64\");\n+        assert_eq!(srv.typed_integer(\"15846685258\", \"i128\").text, \"15846685258i128\");\n+        assert_eq!(srv.float(\"0\").text, \"0.0\");\n+        assert_eq!(srv.float(\"15684.5867\").text, \"15684.5867\");\n+        assert_eq!(srv.f32(\"15684.58\").text, \"15684.58f32\");\n+        assert_eq!(srv.f64(\"15684.58\").text, \"15684.58f64\");\n+\n+        assert_eq!(srv.string(\"hello_world\").text, \"\\\"hello_world\\\"\");\n+        assert_eq!(srv.character('c').text, \"'c'\");\n+        assert_eq!(srv.byte_string(b\"1234586\\x88\").text, \"b\\\"1234586\\\\x88\\\"\");\n+\n+        // u128::max\n+        assert_eq!(\n+            srv.integer(\"340282366920938463463374607431768211455\").text,\n+            \"340282366920938463463374607431768211455\"\n+        );\n+        // i128::min\n+        assert_eq!(\n+            srv.integer(\"-170141183460469231731687303715884105728\").text,\n+            \"-170141183460469231731687303715884105728\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rustc_server_to_string() {\n+        let s = TokenStream {\n+            token_trees: vec![\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"struct\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"T\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n+                        id: tt::TokenId::unspecified(),\n+                        kind: tt::DelimiterKind::Brace,\n+                    }),\n+                    token_trees: vec![],\n+                }),\n+            ],\n+        };\n+\n+        assert_eq!(s.to_string(), \"struct T {}\");\n+    }\n+\n+    #[test]\n+    fn test_rustc_server_from_str() {\n+        use std::str::FromStr;\n+        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n+            delimiter: Some(tt::Delimiter {\n+                id: tt::TokenId::unspecified(),\n+                kind: tt::DelimiterKind::Parenthesis,\n+            }),\n+            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                text: \"a\".into(),\n+                id: tt::TokenId::unspecified(),\n+            }))],\n+        });\n+\n+        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n+        assert_eq!(t1.token_trees.len(), 1);\n+        assert_eq!(t1.token_trees[0], subtree_paren_a);\n+\n+        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n+        assert_eq!(t2.token_trees.len(), 2);\n+        assert_eq!(t2.token_trees[0], subtree_paren_a);\n+\n+        let underscore = TokenStream::from_str(\"_\").unwrap();\n+        assert_eq!(\n+            underscore.token_trees[0],\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                text: \"_\".into(),\n+                id: tt::TokenId::unspecified(),\n+            }))\n+        );\n+    }\n+}"}, {"sha": "73a017d3625ab435a1c1338b0d4b28e28617ebf8", "filename": "crates/proc_macro_srv/src/abis/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bde08f6e71bdd74c1222ddad8926f3487b28ba/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fmod.rs?ref=c5bde08f6e71bdd74c1222ddad8926f3487b28ba", "patch": "@@ -26,10 +26,12 @@\n // pub(crate) so tests can use the TokenStream, more notes in test/utils.rs\n pub(crate) mod abi_1_47;\n mod abi_1_55;\n+mod abi_1_56;\n \n use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_47::Abi as Abi_1_47;\n pub(crate) use abi_1_55::Abi as Abi_1_55;\n+pub(crate) use abi_1_56::Abi as Abi_1_56;\n use libloading::Library;\n use proc_macro_api::{ProcMacroKind, RustCInfo};\n \n@@ -46,6 +48,7 @@ impl PanicMessage {\n pub(crate) enum Abi {\n     Abi1_47(Abi_1_47),\n     Abi1_55(Abi_1_55),\n+    Abi1_56(Abi_1_56),\n }\n \n impl Abi {\n@@ -70,9 +73,12 @@ impl Abi {\n         } else if info.version.1 < 54 {\n             let inner = unsafe { Abi_1_47::from_lib(lib, symbol_name) }?;\n             Ok(Abi::Abi1_47(inner))\n-        } else {\n+        } else if info.version.1 < 56 {\n             let inner = unsafe { Abi_1_55::from_lib(lib, symbol_name) }?;\n             Ok(Abi::Abi1_55(inner))\n+        } else {\n+            let inner = unsafe { Abi_1_56::from_lib(lib, symbol_name) }?;\n+            Ok(Abi::Abi1_56(inner))\n         }\n     }\n \n@@ -85,13 +91,15 @@ impl Abi {\n         match self {\n             Self::Abi1_55(abi) => abi.expand(macro_name, macro_body, attributes),\n             Self::Abi1_47(abi) => abi.expand(macro_name, macro_body, attributes),\n+            Self::Abi1_56(abi) => abi.expand(macro_name, macro_body, attributes),\n         }\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n         match self {\n             Self::Abi1_47(abi) => abi.list_macros(),\n             Self::Abi1_55(abi) => abi.list_macros(),\n+            Self::Abi1_56(abi) => abi.list_macros(),\n         }\n     }\n }"}]}