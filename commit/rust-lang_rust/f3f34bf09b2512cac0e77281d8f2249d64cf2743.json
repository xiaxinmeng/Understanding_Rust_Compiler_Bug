{"sha": "f3f34bf09b2512cac0e77281d8f2249d64cf2743", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZjM0YmYwOWIyNTEyY2FjMGU3NzI4MWQ4ZjIyNDlkNjRjZjI3NDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-17T23:03:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-20T04:01:11Z"}, "message": "correct universally_quantify to use structure_of, and introduce a test for this", "tree": {"sha": "db8bd95b729829e68e29b248b578360bce5361b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db8bd95b729829e68e29b248b578360bce5361b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3f34bf09b2512cac0e77281d8f2249d64cf2743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f34bf09b2512cac0e77281d8f2249d64cf2743", "html_url": "https://github.com/rust-lang/rust/commit/f3f34bf09b2512cac0e77281d8f2249d64cf2743", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3f34bf09b2512cac0e77281d8f2249d64cf2743/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbfb83c2c5501ce3944ea77e7610b83a3bdbfc04", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbfb83c2c5501ce3944ea77e7610b83a3bdbfc04", "html_url": "https://github.com/rust-lang/rust/commit/bbfb83c2c5501ce3944ea77e7610b83a3bdbfc04"}], "stats": {"total": 111, "additions": 60, "deletions": 51}, "files": [{"sha": "b3e407b0c47bdc44b903ff9c830090d539c63d8a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f3f34bf09b2512cac0e77281d8f2249d64cf2743/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f34bf09b2512cac0e77281d8f2249d64cf2743/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=f3f34bf09b2512cac0e77281d8f2249d64cf2743", "patch": "@@ -1975,13 +1975,17 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n                                  bound_tys: [ty::t],\n                                  sty: ty::sty) -> ty::t {\n \n-    let tcx = fcx.tcx();\n-    let isr = collect_named_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n-        fcx.next_region_var()\n-    };\n-    let anon_r = fcx.next_region_var();\n-    ty::fold_sty_to_ty(fcx.ccx.tcx, sty) {|t|\n-        replace_bound_regions(tcx, span, anon_r, isr, t)\n+    #debug[\"universally_quantify_from_sty(bound_tys=%?)\",\n+           bound_tys.map {|x| fcx.ty_to_str(x) }];\n+    indent {||\n+        let tcx = fcx.tcx();\n+        let isr = collect_named_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n+            fcx.next_region_var()\n+        };\n+        let anon_r = fcx.next_region_var();\n+        ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n+            replace_bound_regions(tcx, span, anon_r, isr, t)\n+        }\n     }\n }\n \n@@ -2000,7 +2004,9 @@ fn universally_quantify_regions(fcx: @fn_ctxt,\n fn universally_quantify_before_call(fcx: @fn_ctxt,\n                                     span: span,\n                                     ty: ty::t) -> ty::t {\n-    if !ty::type_has_regions(ty) { ret ty; }\n+\n+    #debug[\"universally_quantify_before_call(ty=%s)\",\n+           fcx.ty_to_str(ty)];\n \n     // This is subtle: we expect `ty` to be a function type, which normally\n     // introduce a level of binding.  In this case, we want to process the\n@@ -2018,12 +2024,14 @@ fn universally_quantify_before_call(fcx: @fn_ctxt,\n     // - Finally, we can use fold_sty_to_ty() and replace_bound_regions()\n     //   to replace the bound regions as well as the bound anonymous region.\n     //   We have to use fold_sty_to_ty() to ignore the outer fn().\n-    alt ty::get(ty).struct {\n+    alt structure_of(fcx, span, ty) {\n       sty @ ty::ty_fn(fty) {\n         let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n         universally_quantify_from_sty(fcx, span, all_tys, sty)\n       }\n-      _ {\n+      sty {\n+        #debug[\"not a fn ty: %?\", sty];\n+\n         // if not a function type, we're gonna' report an error\n         // at some point, since the user is trying to call this thing\n         ty\n@@ -2719,45 +2727,44 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let fty = universally_quantify_before_call(fcx, sp, fty);\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.ty_to_str(fty)];\n-        let sty = structure_of(fcx, sp, fty);\n+\n+        let supplied_arg_count = vec::len(args);\n+\n         // Grab the argument types\n-        let mut arg_tys = alt sty {\n-          ty::ty_fn({inputs: arg_tys, _}) { arg_tys }\n+        let arg_tys = alt structure_of(fcx, sp, fty) {\n+          ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n+            let expected_arg_count = vec::len(arg_tys);\n+            if expected_arg_count == supplied_arg_count {\n+                arg_tys.map { |a| a.ty }\n+            } else {\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp, #fmt[\"this function takes %u parameter%s but %u \\\n+                              parameter%s supplied\", expected_arg_count,\n+                             if expected_arg_count == 1u {\n+                                 \"\"\n+                             } else {\n+                                 \"s\"\n+                             },\n+                             supplied_arg_count,\n+                             if supplied_arg_count == 1u {\n+                                 \" was\"\n+                             } else {\n+                                 \"s were\"\n+                             }]);\n+                fcx.next_ty_vars(supplied_arg_count)\n+            }\n+          }\n+\n           _ {\n+            // I would like to make this span_err, but it's really hard due to\n+            // the way that expr_bind() is written.\n             fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n                                              expected function or native \\\n                                              function but found \"\n-                                        + fcx.ty_to_str(fty))\n+                                        + fcx.ty_to_str(fty));\n           }\n         };\n \n-        // Check that the correct number of arguments were supplied.\n-        let expected_arg_count = vec::len(arg_tys);\n-        let supplied_arg_count = vec::len(args);\n-        if expected_arg_count != supplied_arg_count {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp, #fmt[\"this function takes %u parameter%s but %u \\\n-                          parameter%s supplied\", expected_arg_count,\n-                         if expected_arg_count == 1u {\n-                             \"\"\n-                         } else {\n-                             \"s\"\n-                         },\n-                         supplied_arg_count,\n-                         if supplied_arg_count == 1u {\n-                             \" was\"\n-                         } else {\n-                             \"s were\"\n-                         }]);\n-\n-            // Just use fresh type variables for the types,\n-            // since we don't know them.\n-            arg_tys = vec::from_fn(supplied_arg_count) {|_i|\n-                {mode: ast::expl(ast::by_ref),\n-                 ty: fcx.next_ty_var()}\n-            };\n-        }\n-\n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n         // that are not anonymous functions, then we typecheck the anonymous\n@@ -2775,7 +2782,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                       _ { false }\n                     };\n                     if is_block == check_blocks {\n-                        let arg_ty = arg_tys[i].ty;\n+                        let arg_ty = arg_tys[i];\n                         bot |= check_expr_with_unifier(fcx, a, arg_ty) {||\n                             demand::assign(fcx, a.span, arg_ty, a);\n                         };"}, {"sha": "2b1cf04c1db29601483191225c5dfd35a5284a35", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3f34bf09b2512cac0e77281d8f2249d64cf2743/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f34bf09b2512cac0e77281d8f2249d64cf2743/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=f3f34bf09b2512cac0e77281d8f2249d64cf2743", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-\n fn with<T>(t: T, f: fn(T)) { f(t) }\n \n fn nested(x: &x.int) {  // (1)\n@@ -26,15 +24,19 @@ fn nested(x: &x.int) {  // (1)\n                                         //!^ ERROR mismatched types: expected `&x.int` but found `&y.int`\n             fail;\n         }\n-    ) {|f|\n+    ) {|foo|\n+\n+        let a: &x.int = foo(x, x) { |_x, _y, z| z };\n+        let b: &x.int = foo(x, a) { |_x, _y, z| z };\n+        let c: &x.int = foo(a, a) { |_x, _y, z| z };\n \n-        let a: &x.int = f(x, x) { |_x, _y, z| z };\n-        let b: &x.int = f(x, a) { |_x, _y, z| z };\n-        let c: &x.int = f(a, a) { |_x, _y, z| z };\n+        let z = 3;\n+        let d: &x.int = foo(x, x) { |_x, _y, z| z };\n+        let e: &x.int = foo(x, &z) { |_x, _y, z| z };\n+        let f: &x.int = foo(&z, &z) { |_x, _y, z| z }; //! ERROR mismatched types: expected `&x.int` but found\n \n-        let d: &x.int = f(x, x) { |_x, _y, z| z };\n-        let e: &x.int = f(x, &a) { |_x, _y, z| z };\n-        let f: &x.int = f(&a, &a) { |_x, _y, z| z };\n+        foo(x, &z) { |x, _y, _z| x }; //! ERROR mismatched types: expected `&z.int` but found `&x.int`\n+        foo(x, &z) { |_x, y, _z| y }; //! ERROR mismatched types: expected `&z.int` but found `&<block at\n     }\n }\n "}]}