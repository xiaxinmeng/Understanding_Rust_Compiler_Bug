{"sha": "89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjhhOTdhZWFkNGFhMzY2ZWIyNTg3ZmZkY2ZhN2RmMzlmMzgxNWE=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-09-20T12:46:07Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-09-27T13:10:48Z"}, "message": "Refactor memchr to allow optimization", "tree": {"sha": "aa68710476e7e51620211c8c72f50cc3c39ef898", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa68710476e7e51620211c8c72f50cc3c39ef898"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "html_url": "https://github.com/rust-lang/rust/commit/89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9e8864032a3bfefa6f69c33fd99e0383a414af", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9e8864032a3bfefa6f69c33fd99e0383a414af", "html_url": "https://github.com/rust-lang/rust/commit/5b9e8864032a3bfefa6f69c33fd99e0383a414af"}], "stats": {"total": 105, "additions": 89, "deletions": 16}, "files": [{"sha": "ed26c59c17c432af3fca1ea54caa21fa058ead29", "filename": "library/core/src/slice/cmp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs?ref=89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "patch": "@@ -268,12 +268,14 @@ where\n }\n \n impl SliceContains for u8 {\n+    #[inline]\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         memchr::memchr(*self, x).is_some()\n     }\n }\n \n impl SliceContains for i8 {\n+    #[inline]\n     fn slice_contains(&self, x: &[Self]) -> bool {\n         let byte = *self as u8;\n         // SAFETY: `i8` and `u8` have the same memory layout, thus casting `x.as_ptr()`"}, {"sha": "0c0f1750264eb2dbe21418b3cdadf023077ff6c6", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "patch": "@@ -12,6 +12,7 @@ const HI_U64: u64 = 0x8080808080808080;\n // Use truncation.\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n+const USIZE_BYTES: usize = mem::size_of::<usize>();\n \n /// Returns `true` if `x` contains any zero byte.\n ///\n@@ -38,19 +39,29 @@ fn repeat_byte(b: u8) -> usize {\n }\n \n /// Returns the first index matching the byte `x` in `text`.\n+#[inline]\n pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+    // Fast path for small slices\n+    if text.len() < 2 * USIZE_BYTES {\n+        return text.iter().position(|elt| *elt == x);\n+    }\n+\n+    memchr_general_case(x, text)\n+}\n+\n+fn memchr_general_case(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n     // Split `text` in three parts\n     // - unaligned initial part, before the first word aligned address in text\n     // - body, scan by 2 words at a time\n     // - the last remaining part, < 2 word size\n+\n+    // search up to an aligned boundary\n     let len = text.len();\n     let ptr = text.as_ptr();\n-    let usize_bytes = mem::size_of::<usize>();\n+    let mut offset = ptr.align_offset(USIZE_BYTES);\n \n-    // search up to an aligned boundary\n-    let mut offset = ptr.align_offset(usize_bytes);\n     if offset > 0 {\n         offset = cmp::min(offset, len);\n         if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n@@ -60,22 +71,19 @@ pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n \n     // search the body of the text\n     let repeated_x = repeat_byte(x);\n+    while offset <= len - 2 * USIZE_BYTES {\n+        unsafe {\n+            let u = *(ptr.add(offset) as *const usize);\n+            let v = *(ptr.add(offset + USIZE_BYTES) as *const usize);\n \n-    if len >= 2 * usize_bytes {\n-        while offset <= len - 2 * usize_bytes {\n-            unsafe {\n-                let u = *(ptr.add(offset) as *const usize);\n-                let v = *(ptr.add(offset + usize_bytes) as *const usize);\n-\n-                // break if there is a matching byte\n-                let zu = contains_zero_byte(u ^ repeated_x);\n-                let zv = contains_zero_byte(v ^ repeated_x);\n-                if zu || zv {\n-                    break;\n-                }\n+            // break if there is a matching byte\n+            let zu = contains_zero_byte(u ^ repeated_x);\n+            let zv = contains_zero_byte(v ^ repeated_x);\n+            if zu || zv {\n+                break;\n             }\n-            offset += usize_bytes * 2;\n         }\n+        offset += USIZE_BYTES * 2;\n     }\n \n     // Find the byte after the point the body loop stopped."}, {"sha": "8ffd94369fc293664b65a00fcde60b3e52efbc27", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "patch": "@@ -1633,6 +1633,7 @@ impl<T> [T] {\n     /// assert!(!v.iter().any(|e| e == \"hi\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn contains(&self, x: &T) -> bool\n     where\n         T: PartialEq,"}, {"sha": "8a4b7ef8c4337ce007a80ba8b781615690378efc", "filename": "src/test/codegen/issue-75659.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/src%2Ftest%2Fcodegen%2Fissue-75659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b8a97aead4aa366eb2587ffdcfa7df39f3815a/src%2Ftest%2Fcodegen%2Fissue-75659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-75659.rs?ref=89b8a97aead4aa366eb2587ffdcfa7df39f3815a", "patch": "@@ -0,0 +1,62 @@\n+// This test checks that the call to memchr/slice_contains is optimized away\n+// when searching in small slices.\n+\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @foo1\n+#[no_mangle]\n+pub fn foo1(x: u8, data: &[u8; 1]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo2\n+#[no_mangle]\n+pub fn foo2(x: u8, data: &[u8; 2]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo3\n+#[no_mangle]\n+pub fn foo3(x: u8, data: &[u8; 3]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo4\n+#[no_mangle]\n+pub fn foo4(x: u8, data: &[u8; 4]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo8\n+#[no_mangle]\n+pub fn foo8(x: u8, data: &[u8; 8]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    data.contains(&x)\n+}\n+\n+// CHECK-LABEL: @foo8_i8\n+#[no_mangle]\n+pub fn foo8_i8(x: i8, data: &[i8; 8]) -> bool {\n+    // CHECK-NOT: memchr\n+    // CHECK-NOT: slice_contains\n+    !data.contains(&x)\n+}\n+\n+// Check that the general case isn't inlined\n+// CHECK-LABEL: @foo80\n+#[no_mangle]\n+pub fn foo80(x: u8, data: &[u8; 80]) -> bool {\n+    // CHECK: call core::slice::memchr\n+    data.contains(&x)\n+}"}]}