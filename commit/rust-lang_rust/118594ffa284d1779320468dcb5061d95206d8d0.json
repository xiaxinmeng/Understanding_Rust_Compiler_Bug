{"sha": "118594ffa284d1779320468dcb5061d95206d8d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExODU5NGZmYTI4NGQxNzc5MzIwNDY4ZGNiNTA2MWQ5NTIwNmQ4ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-09T16:04:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-09T16:04:26Z"}, "message": "Auto merge of #5291 - ThibsG:FixSingleBinding, r=flip1995\n\nFix match single binding when in a let stmt\n\nFix bad suggestion when `match_single_binding` lints when inside a local (let) statement.\n\nFixes #5267\n\nchangelog: none", "tree": {"sha": "12251c19798238e163a15f22b24a328c61256e33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12251c19798238e163a15f22b24a328c61256e33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/118594ffa284d1779320468dcb5061d95206d8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/118594ffa284d1779320468dcb5061d95206d8d0", "html_url": "https://github.com/rust-lang/rust/commit/118594ffa284d1779320468dcb5061d95206d8d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/118594ffa284d1779320468dcb5061d95206d8d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5477c500c91e96cbc6a301d48c7aad30926ef0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5477c500c91e96cbc6a301d48c7aad30926ef0a", "html_url": "https://github.com/rust-lang/rust/commit/a5477c500c91e96cbc6a301d48c7aad30926ef0a"}, {"sha": "40a04f26572cf69c74c8790830a49d6a1d16c3fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a04f26572cf69c74c8790830a49d6a1d16c3fb", "html_url": "https://github.com/rust-lang/rust/commit/40a04f26572cf69c74c8790830a49d6a1d16c3fb"}], "stats": {"total": 107, "additions": 84, "deletions": 23}, "files": [{"sha": "b0aae5e30e6e8cc1ef970487f9b92fd050942687", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/118594ffa284d1779320468dcb5061d95206d8d0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118594ffa284d1779320468dcb5061d95206d8d0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=118594ffa284d1779320468dcb5061d95206d8d0", "patch": "@@ -14,8 +14,8 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    print, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Pat, PatKind,\n-    QPath, RangeEnd,\n+    print, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -882,7 +882,7 @@ fn check_wild_in_or_pats(cx: &LateContext<'_, '_>, arms: &[Arm<'_>]) {\n     }\n }\n \n-fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+fn check_match_single_binding<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n@@ -914,19 +914,38 @@ fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[A\n     let mut applicability = Applicability::MaybeIncorrect;\n     match arms[0].pat.kind {\n         PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            // If this match is in a local (`let`) stmt\n+            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n+                (\n+                    parent_let_node.span,\n+                    format!(\n+                        \"let {} = {};\\n{}let {} = {};\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n+                        snippet_body\n+                    ),\n+                )\n+            } else {\n+                (\n+                    expr.span,\n+                    format!(\n+                        \"let {} = {};\\n{}{}\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_body\n+                    ),\n+                )\n+            };\n             span_lint_and_sugg(\n                 cx,\n                 MATCH_SINGLE_BINDING,\n-                expr.span,\n+                target_span,\n                 \"this match could be written as a `let` statement\",\n                 \"consider using `let` statement\",\n-                format!(\n-                    \"let {} = {};\\n{}{}\",\n-                    snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                    snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                    \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                    snippet_body,\n-                ),\n+                sugg,\n                 applicability,\n             );\n         },\n@@ -945,6 +964,19 @@ fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[A\n     }\n }\n \n+/// Returns true if the `ex` match expression is in a local (`let`) statement\n+fn opt_parent_let<'a>(cx: &LateContext<'_, 'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    if_chain! {\n+        let map = &cx.tcx.hir();\n+        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n+        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n+        then {\n+            return Some(parent_let_expr);\n+        }\n+    }\n+    None\n+}\n+\n /// Gets all arms that are unbounded `PatRange`s.\n fn all_ranges<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,"}, {"sha": "bc2346a8dbf0b9b83ff8eea22e518987bfafe9c8", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=118594ffa284d1779320468dcb5061d95206d8d0", "patch": "@@ -1,13 +1,17 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+#![allow(unused_variables, clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n \n struct Point {\n     x: i32,\n     y: i32,\n }\n \n+fn coords() -> Point {\n+    Point { x: 1, y: 2 }\n+}\n+\n fn main() {\n     let a = 1;\n     let b = 2;\n@@ -60,4 +64,7 @@ fn main() {\n     let mut x = 5;\n     let ref mut mr = x;\n     println!(\"Got a mutable reference to {}\", mr);\n+    // Lint\n+    let Point { x, y } = coords();\n+    let product = x * y;\n }"}, {"sha": "0517b3bbfbf939976b1754d8a255fbc31c090259", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=118594ffa284d1779320468dcb5061d95206d8d0", "patch": "@@ -1,13 +1,17 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+#![allow(unused_variables, clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n \n struct Point {\n     x: i32,\n     y: i32,\n }\n \n+fn coords() -> Point {\n+    Point { x: 1, y: 2 }\n+}\n+\n fn main() {\n     let a = 1;\n     let b = 2;\n@@ -72,4 +76,8 @@ fn main() {\n     match x {\n         ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n     }\n+    // Lint\n+    let product = match coords() {\n+        Point { x, y } => x * y,\n+    };\n }"}, {"sha": "05ba9e5f7f3cd5ae7a03bca6f2c965d92e57abe3", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/118594ffa284d1779320468dcb5061d95206d8d0/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=118594ffa284d1779320468dcb5061d95206d8d0", "patch": "@@ -1,5 +1,5 @@\n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:16:5\n+  --> $DIR/match_single_binding.rs:20:5\n    |\n LL | /     match (a, b, c) {\n LL | |         (x, y, z) => {\n@@ -18,7 +18,7 @@ LL |     }\n    |\n \n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:22:5\n+  --> $DIR/match_single_binding.rs:26:5\n    |\n LL | /     match (a, b, c) {\n LL | |         (x, y, z) => println!(\"{} {} {}\", x, y, z),\n@@ -32,15 +32,15 @@ LL |     println!(\"{} {} {}\", x, y, z);\n    |\n \n error: this match could be replaced by its body itself\n-  --> $DIR/match_single_binding.rs:37:5\n+  --> $DIR/match_single_binding.rs:41:5\n    |\n LL | /     match a {\n LL | |         _ => println!(\"whatever\"),\n LL | |     }\n    | |_____^ help: consider using the match body instead: `println!(\"whatever\");`\n \n error: this match could be replaced by its body itself\n-  --> $DIR/match_single_binding.rs:41:5\n+  --> $DIR/match_single_binding.rs:45:5\n    |\n LL | /     match a {\n LL | |         _ => {\n@@ -59,7 +59,7 @@ LL |     }\n    |\n \n error: this match could be replaced by its body itself\n-  --> $DIR/match_single_binding.rs:48:5\n+  --> $DIR/match_single_binding.rs:52:5\n    |\n LL | /     match a {\n LL | |         _ => {\n@@ -81,7 +81,7 @@ LL |     }\n    |\n \n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:58:5\n+  --> $DIR/match_single_binding.rs:62:5\n    |\n LL | /     match p {\n LL | |         Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n@@ -95,7 +95,7 @@ LL |     println!(\"Coords: ({}, {})\", x, y);\n    |\n \n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:62:5\n+  --> $DIR/match_single_binding.rs:66:5\n    |\n LL | /     match p {\n LL | |         Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n@@ -109,7 +109,7 @@ LL |     println!(\"Coords: ({}, {})\", x1, y1);\n    |\n \n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:67:5\n+  --> $DIR/match_single_binding.rs:71:5\n    |\n LL | /     match x {\n LL | |         ref r => println!(\"Got a reference to {}\", r),\n@@ -123,7 +123,7 @@ LL |     println!(\"Got a reference to {}\", r);\n    |\n \n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:72:5\n+  --> $DIR/match_single_binding.rs:76:5\n    |\n LL | /     match x {\n LL | |         ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n@@ -136,5 +136,19 @@ LL |     let ref mut mr = x;\n LL |     println!(\"Got a mutable reference to {}\", mr);\n    |\n \n-error: aborting due to 9 previous errors\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:80:5\n+   |\n+LL | /     let product = match coords() {\n+LL | |         Point { x, y } => x * y,\n+LL | |     };\n+   | |______^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let Point { x, y } = coords();\n+LL |     let product = x * y;\n+   |\n+\n+error: aborting due to 10 previous errors\n "}]}