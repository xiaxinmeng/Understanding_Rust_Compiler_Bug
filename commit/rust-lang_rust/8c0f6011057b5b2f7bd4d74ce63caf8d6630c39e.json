{"sha": "8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMGY2MDExMDU3YjViMmY3YmQ0ZDc0Y2U2M2NhZjhkNjYzMGMzOWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T10:57:44Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-09-16T10:33:47Z"}, "message": "fix Miri discriminant load/store when overflows are involved", "tree": {"sha": "d61e8db614c35fa184e927dffeb3cd59349afb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d61e8db614c35fa184e927dffeb3cd59349afb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "html_url": "https://github.com/rust-lang/rust/commit/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e3e06dfdd2a5c601ae69be7558c1a9fbf4f32d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3e06dfdd2a5c601ae69be7558c1a9fbf4f32d8", "html_url": "https://github.com/rust-lang/rust/commit/3e3e06dfdd2a5c601ae69be7558c1a9fbf4f32d8"}], "stats": {"total": 82, "additions": 65, "deletions": 17}, "files": [{"sha": "3b07202f898ba24846aace8bd511033d61aa2c7e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "patch": "@@ -609,15 +609,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        let (discr_kind, discr_index) = match rval.layout.variants {\n+        let (discr_layout, discr_kind, discr_index) = match rval.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = rval.layout.ty.discriminant_for_variant(*self.tcx, index).map_or(\n                     index.as_u32() as u128,\n                     |discr| discr.val);\n                 return Ok((discr_val, index));\n             }\n-            layout::Variants::Multiple { ref discr_kind, discr_index, .. } =>\n-                (discr_kind, discr_index),\n+            layout::Variants::Multiple {\n+                discr: ref discr_layout,\n+                ref discr_kind,\n+                discr_index,\n+                ..\n+            } =>\n+                (discr_layout, discr_kind, discr_index),\n         };\n \n         // read raw discriminant value\n@@ -634,7 +639,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .map_err(|_| err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the layout discriminant\n+                    // requires first sign extending with the discriminant layout\n                     let sexted = sign_extend(bits_discr, discr_val.layout.size) as i128;\n                     // and then zeroing with the typeck discriminant type\n                     let discr_ty = rval.layout.ty\n@@ -682,8 +687,31 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n                     Ok(raw_discr) => {\n-                        let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n-                            .wrapping_add(variants_start);\n+                        // FIXME: WTF, some discriminants don't have integer type.\n+                        use layout::Primitive;\n+                        let discr_layout = self.layout_of(match discr_layout.value {\n+                            Primitive::Int(int, signed) => int.to_ty(*self.tcx, signed),\n+                            Primitive::Pointer => self.tcx.types.usize,\n+                            Primitive::Float(..) => bug!(\"there are no float discriminants\"),\n+                        })?;\n+                        let discr_val = ImmTy::from_uint(raw_discr, discr_layout);\n+                        // We need to use machine arithmetic.\n+                        let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                        let variants_start_val = ImmTy::from_uint(variants_start, discr_layout);\n+                        let adjusted_discr = self.binary_op(\n+                            mir::BinOp::Sub,\n+                            discr_val,\n+                            niche_start_val,\n+                        )?;\n+                        let adjusted_discr = self.binary_op(\n+                            mir::BinOp::Add,\n+                            adjusted_discr,\n+                            variants_start_val,\n+                        )?;\n+                        let adjusted_discr = adjusted_discr\n+                            .to_scalar()?\n+                            .assert_bits(discr_val.layout.size);\n+                        // Check if this is in the range that indicates an actual discriminant.\n                         if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n                             let index = adjusted_discr as usize;\n                             assert_eq!(index as u128, adjusted_discr);"}, {"sha": "0a23c1222b4bff096ed1cdb297e9e3df31c9da4d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8c0f6011057b5b2f7bd4d74ce63caf8d6630c39e", "patch": "@@ -8,7 +8,9 @@ use std::hash::Hash;\n use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx};\n+use rustc::ty::layout::{\n+    self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, IntegerExt\n+};\n use rustc::ty::TypeFoldable;\n \n use super::{\n@@ -1027,7 +1029,7 @@ where\n             }\n             layout::Variants::Multiple {\n                 discr_kind: layout::DiscriminantKind::Tag,\n-                ref discr,\n+                discr: ref discr_layout,\n                 discr_index,\n                 ..\n             } => {\n@@ -1038,7 +1040,7 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = discr.value.size(self);\n+                let size = discr_layout.value.size(self);\n                 let discr_val = truncate(discr_val, size);\n \n                 let discr_dest = self.place_field(dest, discr_index as u64)?;\n@@ -1050,22 +1052,40 @@ where\n                     ref niche_variants,\n                     niche_start,\n                 },\n+                discr: ref discr_layout,\n                 discr_index,\n                 ..\n             } => {\n                 assert!(\n                     variant_index.as_usize() < dest.layout.ty.ty_adt_def().unwrap().variants.len(),\n                 );\n                 if variant_index != dataful_variant {\n-                    let niche_dest =\n-                        self.place_field(dest, discr_index as u64)?;\n-                    let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                    let niche_value = (niche_value as u128)\n-                        .wrapping_add(niche_start);\n-                    self.write_scalar(\n-                        Scalar::from_uint(niche_value, niche_dest.layout.size),\n-                        niche_dest\n+                    // FIXME: WTF, some discriminants don't have integer type.\n+                    use layout::Primitive;\n+                    let discr_layout = self.layout_of(match discr_layout.value {\n+                        Primitive::Int(int, signed) => int.to_ty(*self.tcx, signed),\n+                        Primitive::Pointer => self.tcx.types.usize,\n+                        Primitive::Float(..) => bug!(\"there are no float discriminants\"),\n+                    })?;\n+\n+                    // We need to use machine arithmetic.\n+                    let variants_start = niche_variants.start().as_u32();\n+                    let variants_start_val = ImmTy::from_uint(variants_start, discr_layout);\n+                    let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                    let variant_index_val = ImmTy::from_uint(variant_index.as_u32(), discr_layout);\n+                    let niche_val = self.binary_op(\n+                        mir::BinOp::Sub,\n+                        variant_index_val,\n+                        variants_start_val,\n+                    )?;\n+                    let niche_val = self.binary_op(\n+                        mir::BinOp::Add,\n+                        niche_val,\n+                        niche_start_val,\n                     )?;\n+                    // Write result.\n+                    let niche_dest = self.place_field(dest, discr_index as u64)?;\n+                    self.write_immediate(*niche_val, niche_dest)?;\n                 }\n             }\n         }"}]}