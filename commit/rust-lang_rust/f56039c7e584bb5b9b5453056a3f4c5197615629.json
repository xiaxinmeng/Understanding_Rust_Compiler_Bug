{"sha": "f56039c7e584bb5b9b5453056a3f4c5197615629", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NjAzOWM3ZTU4NGJiNWI5YjU0NTMwNTZhM2Y0YzUxOTc2MTU2Mjk=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-10T05:54:13Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-03-11T22:54:12Z"}, "message": "Use rewrite_assign_rhs for rewriting bounds", "tree": {"sha": "ef34e4cde531a54435ce022f910956fe03883cca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef34e4cde531a54435ce022f910956fe03883cca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f56039c7e584bb5b9b5453056a3f4c5197615629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f56039c7e584bb5b9b5453056a3f4c5197615629", "html_url": "https://github.com/rust-lang/rust/commit/f56039c7e584bb5b9b5453056a3f4c5197615629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f56039c7e584bb5b9b5453056a3f4c5197615629/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f7a90fbefd68a919cd6f4214829208798583199", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f7a90fbefd68a919cd6f4214829208798583199", "html_url": "https://github.com/rust-lang/rust/commit/8f7a90fbefd68a919cd6f4214829208798583199"}], "stats": {"total": 187, "additions": 85, "deletions": 102}, "files": [{"sha": "2484756fc56aff1b61bd134bc92fdb0bd22051bf", "filename": "src/items.rs", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f56039c7e584bb5b9b5453056a3f4c5197615629/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f56039c7e584bb5b9b5453056a3f4c5197615629/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=f56039c7e584bb5b9b5453056a3f4c5197615629", "patch": "@@ -23,13 +23,14 @@ use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle};\n-use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, ExprType};\n+use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n+           rewrite_assign_rhs_with, ExprType, RhsTactics};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use overflow;\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use types::join_bounds;\n+use types::TraitTyParamBounds;\n use utils::{colon_spaces, contains_skip, first_line_width, format_abi, format_constness,\n             format_defaultness, format_mutability, format_unsafety, format_visibility,\n             is_attributes_extendable, last_line_contains_single_line_comment,\n@@ -919,20 +920,19 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 return None;\n             }\n         }\n-        let trait_bound_str = rewrite_trait_bounds(\n-            context,\n-            type_param_bounds,\n-            Shape::indented(offset, context.config),\n-        )?;\n-        // If the trait, generics, and trait bound cannot fit on the same line,\n-        // put the trait bounds on an indented new line\n-        if offset.width() + last_line_width(&result) + trait_bound_str.len()\n-            > context.config.comment_width()\n-        {\n-            let trait_indent = offset.block_only().block_indent(context.config);\n-            result.push_str(&trait_indent.to_string_with_newline(context.config));\n+        if !type_param_bounds.is_empty() {\n+            let shape = Shape {\n+                indent: shape.indent.block_unindent(context.config),\n+                ..shape\n+            };\n+            result = rewrite_assign_rhs_with(\n+                context,\n+                result + \":\",\n+                &TraitTyParamBounds::new(type_param_bounds),\n+                shape,\n+                RhsTactics::ForceNextLine,\n+            )?;\n         }\n-        result.push_str(&trait_bound_str);\n \n         let where_density =\n             if context.config.indent_style() == IndentStyle::Block && result.is_empty() {\n@@ -1585,16 +1585,12 @@ pub fn rewrite_associated_type(\n     let prefix = format!(\"type {}\", ident);\n \n     let type_bounds_str = if let Some(bounds) = ty_param_bounds_opt {\n-        // 2 = \": \".len()\n-        let shape = Shape::indented(indent, context.config).offset_left(prefix.len() + 2)?;\n-        let bound_str = bounds\n-            .iter()\n-            .map(|ty_bound| ty_bound.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n-        if !bounds.is_empty() {\n-            format!(\": {}\", join_bounds(context, shape, &bound_str))\n-        } else {\n+        if bounds.is_empty() {\n             String::new()\n+        } else {\n+            // 2 = \": \".len()\n+            let shape = Shape::indented(indent, context.config).offset_left(prefix.len() + 2)?;\n+            bounds.rewrite(context, shape).map(|s| format!(\": {}\", s))?\n         }\n     } else {\n         String::new()\n@@ -2329,21 +2325,6 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n     }\n }\n \n-fn rewrite_trait_bounds(\n-    context: &RewriteContext,\n-    bounds: &[ast::TyParamBound],\n-    shape: Shape,\n-) -> Option<String> {\n-    if bounds.is_empty() {\n-        return Some(String::new());\n-    }\n-    let bound_str = bounds\n-        .iter()\n-        .map(|ty_bound| ty_bound.rewrite(context, shape))\n-        .collect::<Option<Vec<_>>>()?;\n-    Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n-}\n-\n fn rewrite_where_clause_rfc_style(\n     context: &RewriteContext,\n     where_clause: &ast::WhereClause,"}, {"sha": "80ff8ce498aef6a34637d67ac5b709b97b88d7ea", "filename": "src/types.rs", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f56039c7e584bb5b9b5453056a3f4c5197615629/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f56039c7e584bb5b9b5453056a3f4c5197615629/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=f56039c7e584bb5b9b5453056a3f4c5197615629", "patch": "@@ -18,7 +18,8 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr};\n+use expr::{rewrite_assign_rhs, rewrite_pair, rewrite_tuple, rewrite_unary_prefix,\n+           PairParts, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n@@ -431,64 +432,35 @@ impl Rewrite for ast::WherePredicate {\n                 ..\n             }) => {\n                 let type_str = bounded_ty.rewrite(context, shape)?;\n-\n-                let colon = type_bound_colon(context);\n-\n-                if let Some(lifetime_str) =\n+                let colon = type_bound_colon(context).trim_right();\n+                let lhs = if let Some(lifetime_str) =\n                     rewrite_lifetime_param(context, shape, bound_generic_params)\n                 {\n-                    // 6 = \"for<> \".len()\n-                    let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n-                    let ty_shape = shape.offset_left(used_width)?;\n-                    let bounds = bounds\n-                        .iter()\n-                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                        .collect::<Option<Vec<_>>>()?;\n-                    let bounds_str = join_bounds(context, ty_shape, &bounds);\n-\n                     if context.config.spaces_within_parens_and_brackets()\n                         && !lifetime_str.is_empty()\n                     {\n-                        format!(\n-                            \"for< {} > {}{}{}\",\n-                            lifetime_str, type_str, colon, bounds_str\n-                        )\n+                        format!(\"for< {} > {}{}\", lifetime_str, type_str, colon)\n                     } else {\n-                        format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n+                        format!(\"for<{}> {}{}\", lifetime_str, type_str, colon)\n                     }\n                 } else {\n-                    let used_width = type_str.len() + colon.len();\n-                    let ty_shape = match context.config.indent_style() {\n-                        IndentStyle::Visual => shape.block_left(used_width)?,\n-                        IndentStyle::Block => shape,\n-                    };\n-                    let bounds = bounds\n-                        .iter()\n-                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                        .collect::<Option<Vec<_>>>()?;\n-                    let overhead = type_str.len() + colon.len();\n-                    let bounds_str = join_bounds(context, ty_shape.sub_width(overhead)?, &bounds);\n-\n-                    format!(\"{}{}{}\", type_str, colon, bounds_str)\n-                }\n+                    format!(\"{}{}\", type_str, colon)\n+                };\n+\n+                rewrite_assign_rhs(context, lhs, bounds, shape)?\n             }\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n                 ref lifetime,\n                 ref bounds,\n                 ..\n-            }) => rewrite_bounded_lifetime(lifetime, bounds.iter(), context, shape)?,\n+            }) => rewrite_bounded_lifetime(lifetime, bounds, context, shape)?,\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                 ref lhs_ty,\n                 ref rhs_ty,\n                 ..\n             }) => {\n-                let lhs_ty_str = lhs_ty.rewrite(context, shape)?;\n-                // 3 = \" = \".len()\n-                let used_width = 3 + lhs_ty_str.len();\n-                let budget = shape.width.checked_sub(used_width)?;\n-                let rhs_ty_str =\n-                    rhs_ty.rewrite(context, Shape::legacy(budget, shape.indent + used_width))?;\n-                format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n+                let lhs_ty_str = lhs_ty.rewrite(context, shape).map(|lhs| lhs + \" =\")?;\n+                rewrite_assign_rhs(context, lhs_ty_str, &**rhs_ty, shape)?\n             }\n         };\n \n@@ -498,26 +470,23 @@ impl Rewrite for ast::WherePredicate {\n \n impl Rewrite for ast::LifetimeDef {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        rewrite_bounded_lifetime(&self.lifetime, self.bounds.iter(), context, shape)\n+        rewrite_bounded_lifetime(&self.lifetime, &self.bounds, context, shape)\n     }\n }\n \n-fn rewrite_bounded_lifetime<'b, I>(\n+fn rewrite_bounded_lifetime(\n     lt: &ast::Lifetime,\n-    bounds: I,\n+    bounds: &[ast::Lifetime],\n     context: &RewriteContext,\n     shape: Shape,\n-) -> Option<String>\n-where\n-    I: ExactSizeIterator<Item = &'b ast::Lifetime>,\n-{\n+) -> Option<String> {\n     let result = lt.rewrite(context, shape)?;\n \n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n         let appendix = bounds\n-            .into_iter()\n+            .iter()\n             .map(|b| b.rewrite(context, shape))\n             .collect::<Option<Vec<_>>>()?;\n         let colon = type_bound_colon(context);\n@@ -526,7 +495,7 @@ where\n             \"{}{}{}\",\n             result,\n             colon,\n-            join_bounds(context, shape.sub_width(overhead)?, &appendix)\n+            join_bounds(context, shape.sub_width(overhead)?, bounds, &appendix, true)?\n         );\n         Some(result)\n     }\n@@ -552,12 +521,28 @@ impl Rewrite for ast::Lifetime {\n     }\n }\n \n+/// A simple wrapper over type param bounds in trait.\n+#[derive(new)]\n+pub struct TraitTyParamBounds<'a> {\n+    inner: &'a ast::TyParamBounds,\n+}\n+\n+impl<'a> Rewrite for TraitTyParamBounds<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let strs = self.inner\n+            .iter()\n+            .map(|b| b.rewrite(context, shape))\n+            .collect::<Option<Vec<_>>>()?;\n+        join_bounds(context, shape, self.inner, &strs, false)\n+    }\n+}\n+\n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let strs = self.iter()\n             .map(|b| b.rewrite(context, shape))\n             .collect::<Option<Vec<_>>>()?;\n-        Some(join_bounds(context, shape, &strs))\n+        join_bounds(context, shape, self, &strs, true)\n     }\n }\n \n@@ -572,11 +557,7 @@ impl Rewrite for ast::TyParam {\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));\n-            let strs = self.bounds\n-                .iter()\n-                .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                .collect::<Option<Vec<_>>>()?;\n-            result.push_str(&join_bounds(context, shape, &strs));\n+            result.push_str(&self.bounds.rewrite(context, shape)?)\n         }\n         if let Some(ref def) = self.default {\n             let eq_str = match context.config.type_punctuation_density() {\n@@ -794,20 +775,41 @@ fn rewrite_bare_fn(\n     Some(result)\n }\n \n-pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String]) -> String {\n+fn join_bounds<T>(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    items: &[T],\n+    type_strs: &[String],\n+    need_indent: bool,\n+) -> Option<String>\n+where\n+    T: Rewrite,\n+{\n     // Try to join types in a single line\n     let joiner = match context.config.type_punctuation_density() {\n         TypeDensity::Compressed => \"+\",\n         TypeDensity::Wide => \" + \",\n     };\n     let result = type_strs.join(joiner);\n-    if result.contains('\\n') || result.len() > shape.width {\n-        let joiner_indent = shape.indent.block_indent(context.config);\n-        let joiner = format!(\"{}+ \", joiner_indent.to_string_with_newline(context.config));\n-        type_strs.join(&joiner)\n-    } else {\n-        result\n+    if items.len() == 1 || (!result.contains('\\n') && result.len() <= shape.width) {\n+        return Some(result);\n     }\n+\n+    // We need to use multiple lines.\n+    let (type_strs, offset) = if need_indent {\n+        // Rewrite with additional indentation.\n+        let nested_shape = shape.block_indent(context.config.tab_spaces());\n+        let type_strs = items\n+            .iter()\n+            .map(|item| item.rewrite(context, nested_shape))\n+            .collect::<Option<Vec<_>>>()?;\n+        (type_strs, nested_shape.indent)\n+    } else {\n+        (type_strs.to_vec(), shape.indent)\n+    };\n+\n+    let joiner = format!(\"{}+ \", offset.to_string_with_newline(context.config));\n+    Some(type_strs.join(&joiner))\n }\n \n pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {"}]}