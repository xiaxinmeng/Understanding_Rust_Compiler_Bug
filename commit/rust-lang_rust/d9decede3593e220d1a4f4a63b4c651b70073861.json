{"sha": "d9decede3593e220d1a4f4a63b4c651b70073861", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZGVjZWRlMzU5M2UyMjBkMWE0ZjRhNjNiNGM2NTFiNzAwNzM4NjE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-07T11:28:52Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-07T17:41:39Z"}, "message": "instance: polymorphize upvar closures/generators\n\nThis commit modifies how instances are polymorphized so that closures\nand generators have any closures or generators captured within their\nupvars also polymorphized - this avoids symbol clashes with the new\nsymbol mangling scheme.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "9c7bb0a05d779607a05e0f3935e2b070147f3f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c7bb0a05d779607a05e0f3935e2b070147f3f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9decede3593e220d1a4f4a63b4c651b70073861", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl8tklMACgkQJZLnbIc4\nH9n6ehAAkdxx3aex4lxV6BRTFC2LV9mRHNEW0z5prBBm/Xyfu35oyolUHJKzOsbf\nWay3Gaweki1zTd93KBOsUOuRalMmCeU3h0VlwydHptjtRy6MVH6bI950yt3eAZh8\nEFDIO+Sh0mQzhi3zsFUadTXqVmYe4flvYWM1WwO081QN2cr9BOtSKwGXuxXHFitV\nu1vjwiwXr7VgF8kvBfLdbXrlqcB3LC29gqd7zT1Zn22VdCMlsvvbo/uijyc1E6mu\nZVfllq7w6Z8Jo+gP3hu20YezInXVqR0HB3TlSba2rZB+DBwqlQPvUvgcVDLSjA8B\nfLcYxMUD9E0vKjNJM3Q3p/MOuri5vagEtO7/uQ9bFnm4eSdF8j+0f0B3izaMkBB6\n+37yzGTs1qWDcDhXmNVkLfMg3K3mFjhcemkmE88lCnmoiFcVdW6xNAJTGUOn7CgE\n8qbxlA6eoqdkTQZZ2SCwmH15vyiSYXkd4cjoSTO4gw6KJVpbnn8aFFcjU5VGfnQF\ndTi+P54P5e4jlbsJ6EbjFj4U8YYSutQ7t0ACW+yQ0rmm2hpit/7Ml5mU6ivgsyKb\nKtxA3cx8+FlK8jBEoa4wlorajLWaQMa5ocDcXWqeLm1pQz1Qp7aIh4lbpYS9Hl5x\nlHs9D3GV1cev/oP0xMQSq3yrI8lT4BAl1MCiykhh+X6RM9t+xyk=\n=n7Y8\n-----END PGP SIGNATURE-----", "payload": "tree 9c7bb0a05d779607a05e0f3935e2b070147f3f10\nparent 3cfc7fe78eccc754b16981704a098d7bd520e2fd\nauthor David Wood <david@davidtw.co> 1596799732 +0100\ncommitter David Wood <david@davidtw.co> 1596822099 +0100\n\ninstance: polymorphize upvar closures/generators\n\nThis commit modifies how instances are polymorphized so that closures\nand generators have any closures or generators captured within their\nupvars also polymorphized - this avoids symbol clashes with the new\nsymbol mangling scheme.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9decede3593e220d1a4f4a63b4c651b70073861", "html_url": "https://github.com/rust-lang/rust/commit/d9decede3593e220d1a4f4a63b4c651b70073861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9decede3593e220d1a4f4a63b4c651b70073861/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfc7fe78eccc754b16981704a098d7bd520e2fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfc7fe78eccc754b16981704a098d7bd520e2fd", "html_url": "https://github.com/rust-lang/rust/commit/3cfc7fe78eccc754b16981704a098d7bd520e2fd"}], "stats": {"total": 242, "additions": 222, "deletions": 20}, "files": [{"sha": "bdacc04c291f440688e7a2a778296647c2d3b259", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=d9decede3593e220d1a4f4a63b4c651b70073861", "patch": "@@ -474,26 +474,7 @@ impl<'tcx> Instance<'tcx> {\n         }\n \n         if let InstanceDef::Item(def) = self.def {\n-            let unused = tcx.unused_generic_params(def.did);\n-\n-            if unused.is_empty() {\n-                // Exit early if every parameter was used.\n-                return self;\n-            }\n-\n-            debug!(\"polymorphize: unused={:?}\", unused);\n-            let polymorphized_substs =\n-                InternalSubsts::for_item(tcx, def.did, |param, _| match param.kind {\n-                // If parameter is a const or type parameter..\n-                ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n-                    // ..and is within range and unused..\n-                    unused.contains(param.index).unwrap_or(false) =>\n-                        // ..then use the identity for this parameter.\n-                        tcx.mk_param_from_def(param),\n-                // Otherwise, use the parameter as before.\n-                _ => self.substs[param.index as usize],\n-            });\n-\n+            let polymorphized_substs = polymorphize(tcx, def.did, self.substs);\n             debug!(\"polymorphize: self={:?} polymorphized_substs={:?}\", self, polymorphized_substs);\n             Self { def: self.def, substs: polymorphized_substs }\n         } else {\n@@ -502,6 +483,92 @@ impl<'tcx> Instance<'tcx> {\n     }\n }\n \n+fn polymorphize<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> SubstsRef<'tcx> {\n+    debug!(\"polymorphize({:?}, {:?})\", def_id, substs);\n+    let unused = tcx.unused_generic_params(def_id);\n+    debug!(\"polymorphize: unused={:?}\", unused);\n+\n+    if unused.is_empty() {\n+        // Exit early if every parameter was used.\n+        return substs;\n+    }\n+\n+    // If this is a closure or generator then we need to handle the case where another closure\n+    // from the function is captured as an upvar and hasn't been polymorphized. In this case,\n+    // the unpolymorphized upvar closure would result in a polymorphized closure producing\n+    // multiple mono items (and eventually symbol clashes).\n+    let upvars_ty = if tcx.is_closure(def_id) {\n+        Some(substs.as_closure().tupled_upvars_ty())\n+    } else if tcx.type_of(def_id).is_generator() {\n+        Some(substs.as_generator().tupled_upvars_ty())\n+    } else {\n+        None\n+    };\n+    let has_upvars = upvars_ty.map(|ty| ty.tuple_fields().count() > 0).unwrap_or(false);\n+    debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n+\n+    struct PolymorphizationFolder<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+    };\n+\n+    impl ty::TypeFolder<'tcx> for PolymorphizationFolder<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            debug!(\"fold_ty: ty={:?}\", ty);\n+            match ty.kind {\n+                ty::Closure(def_id, substs) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    self.tcx.mk_closure(def_id, polymorphized_substs)\n+                }\n+                ty::Generator(def_id, substs, movability) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n+                }\n+                _ => ty.super_fold_with(self),\n+            }\n+        }\n+    }\n+\n+    InternalSubsts::for_item(tcx, def_id, |param, _| {\n+        let is_unused = unused.contains(param.index).unwrap_or(false);\n+        debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n+        match param.kind {\n+            // Upvar case: If parameter is a type parameter..\n+            ty::GenericParamDefKind::Type { .. } if\n+                // ..and has upvars..\n+                has_upvars &&\n+                // ..and this param has the same type as the tupled upvars..\n+                upvars_ty == Some(substs[param.index as usize].expect_ty()) => {\n+                    // ..then double-check that polymorphization marked it used..\n+                    debug_assert!(!is_unused);\n+                    // ..and polymorphize any closures/generators captured as upvars.\n+                    let upvars_ty = upvars_ty.unwrap();\n+                    let polymorphized_upvars_ty = upvars_ty.fold_with(\n+                        &mut PolymorphizationFolder { tcx });\n+                    debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n+                    ty::GenericArg::from(polymorphized_upvars_ty)\n+                },\n+\n+            // Simple case: If parameter is a const or type parameter..\n+            ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n+                // ..and is within range and unused..\n+                unused.contains(param.index).unwrap_or(false) =>\n+                    // ..then use the identity for this parameter.\n+                    tcx.mk_param_from_def(param),\n+\n+            // Otherwise, use the parameter as before.\n+            _ => substs[param.index as usize],\n+        }\n+    })\n+}\n+\n fn needs_fn_once_adapter_shim(\n     actual_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,"}, {"sha": "b0b39dbd3df61c630e009bd35c93c4ba435a8cb2", "filename": "src/test/ui/polymorphization/closure_in_upvar/fn.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffn.rs?ref=d9decede3593e220d1a4f4a63b4c651b70073861", "patch": "@@ -0,0 +1,29 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    let x = |_: ()| ();\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "ba75f6c5a1099dc7530965e56ea94e28b9357d30", "filename": "src/test/ui/polymorphization/closure_in_upvar/fnmut.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnmut.rs?ref=d9decede3593e220d1a4f4a63b4c651b70073861", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    // Mutate an upvar from `x` so that it implements `FnMut`.\n+    let mut outer = 3;\n+    let mut x = |_: ()| {\n+        outer = 4;\n+        ()\n+    };\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let mut y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "e9761ad0bcb20653d44bf470cde48ceb7258054e", "filename": "src/test/ui/polymorphization/closure_in_upvar/fnonce.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Ffnonce.rs?ref=d9decede3593e220d1a4f4a63b4c651b70073861", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn foo(f: impl Fn()) {\n+    // Move a non-copy type into `x` so that it implements `FnOnce`.\n+    let outer = Vec::<u32>::new();\n+    let x = move |_: ()| {\n+        let inner = outer;\n+        ()\n+    };\n+\n+    // Don't use `f` in `y`, but refer to `x` so that the closure substs contain a reference to\n+    // `x` that will differ for each instantiation despite polymorphisation of the varying\n+    // argument.\n+    let y = || x(());\n+\n+    // Consider `f` used in `foo`.\n+    f();\n+    // Use `y` so that it is visited in monomorphisation collection.\n+    y();\n+}\n+\n+fn entry_a() {\n+    foo(|| ());\n+}\n+\n+fn entry_b() {\n+    foo(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}, {"sha": "7614aa83fcd1541fecd0734b45719e383bb6b6e1", "filename": "src/test/ui/polymorphization/closure_in_upvar/other.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9decede3593e220d1a4f4a63b4c651b70073861/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fclosure_in_upvar%2Fother.rs?ref=d9decede3593e220d1a4f4a63b4c651b70073861", "patch": "@@ -0,0 +1,38 @@\n+// build-pass\n+// compile-flags:-Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+fn y_uses_f(f: impl Fn()) {\n+    let x = |_: ()| ();\n+\n+    let y = || {\n+        f();\n+        x(());\n+    };\n+\n+    f();\n+    y();\n+}\n+\n+fn x_uses_f(f: impl Fn()) {\n+    let x = |_: ()| { f(); };\n+\n+    let y = || x(());\n+\n+    f();\n+    y();\n+}\n+\n+fn entry_a() {\n+    x_uses_f(|| ());\n+    y_uses_f(|| ());\n+}\n+\n+fn entry_b() {\n+    x_uses_f(|| ());\n+    y_uses_f(|| ());\n+}\n+\n+fn main() {\n+    entry_a();\n+    entry_b();\n+}"}]}