{"sha": "d73be851fbcaa2887d390192c6774b3792411c9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3M2JlODUxZmJjYWEyODg3ZDM5MDE5MmM2Nzc0YjM3OTI0MTFjOWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T10:06:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:21Z"}, "message": "extract `regionck_outlives` into a separate helper function\n\nThis helps make its inputs and outputs more clear.", "tree": {"sha": "6cad96481c59f9ee2784df07f12b4e68fedbfd96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cad96481c59f9ee2784df07f12b4e68fedbfd96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d73be851fbcaa2887d390192c6774b3792411c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d73be851fbcaa2887d390192c6774b3792411c9f", "html_url": "https://github.com/rust-lang/rust/commit/d73be851fbcaa2887d390192c6774b3792411c9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d73be851fbcaa2887d390192c6774b3792411c9f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c925008a5ce44fd5f4755279793c64bb9ccb50f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c925008a5ce44fd5f4755279793c64bb9ccb50f4", "html_url": "https://github.com/rust-lang/rust/commit/c925008a5ce44fd5f4755279793c64bb9ccb50f4"}], "stats": {"total": 865, "additions": 498, "deletions": 367}, "files": [{"sha": "c76d098bd6995f6fa0d9fb7177e4ad405869695b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d73be851fbcaa2887d390192c6774b3792411c9f", "patch": "@@ -1451,6 +1451,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.generator_sig(def_id)\n     }\n+\n+    /// Normalizes associated types in `value`, potentially returning\n+    /// new obligations that must further be processed.\n+    pub fn partially_normalize_associated_types_in<T>(&self,\n+                                                  span: Span,\n+                                                  body_id: ast::NodeId,\n+                                                  param_env: ty::ParamEnv<'tcx>,\n+                                                  value: &T)\n+                                                  -> InferOk<'tcx, T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, value);\n+        debug!(\"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value,\n+            obligations);\n+        InferOk { value, obligations }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "0c4a5512dd601ec36f982451424ca641ab3da0b6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d73be851fbcaa2887d390192c6774b3792411c9f", "patch": "@@ -136,7 +136,8 @@ mod autoderef;\n pub mod dropck;\n pub mod _match;\n pub mod writeback;\n-pub mod regionck;\n+mod regionck;\n+mod regionck_outlives;\n pub mod coercion;\n pub mod demand;\n pub mod method;\n@@ -657,29 +658,10 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, param_env, value);\n+        let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n \n-    fn normalize_associated_types_in_as_infer_ok<T>(&self,\n-                                                    span: Span,\n-                                                    body_id: ast::NodeId,\n-                                                    param_env: ty::ParamEnv<'tcx>,\n-                                                    value: &T)\n-                                                    -> InferOk<'tcx, T>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value,\n-            obligations);\n-        InferOk { value, obligations }\n-    }\n-\n     /// Replace any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     fn liberate_late_bound_regions<T>(&self,\n@@ -1970,10 +1952,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in_as_infer_ok(span,\n-                                                           self.body_id,\n-                                                           self.param_env,\n-                                                           value)\n+        self.inh.partially_normalize_associated_types_in(span,\n+                                                         self.body_id,\n+                                                         self.param_env,\n+                                                         value)\n     }\n \n     pub fn require_type_meets(&self,"}, {"sha": "77a34023df3df58733a49675fce21d2daf302bc8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 24, "deletions": 342, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d73be851fbcaa2887d390192c6774b3792411c9f", "patch": "@@ -92,7 +92,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, SubregionOrigin};\n use rustc::ty::adjustment;\n use rustc::ty::outlives::Component;\n use rustc::ty::wf;\n@@ -105,6 +105,8 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n+use super::regionck_outlives::RegionckOutlives;\n+\n // a variation on try that just returns unit\n macro_rules! ignore_err {\n     ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n@@ -1132,6 +1134,27 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n+    /// Adds constraints to inference such that `T: 'a` holds (or\n+    /// reports an error if it cannot).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`, the reason we need this constraint\n+    /// - `ty`, the type `T`\n+    /// - `region`, the region `'a`\n+    pub fn type_must_outlive(&self,\n+                             origin: infer::SubregionOrigin<'tcx>,\n+                             ty: Ty<'tcx>,\n+                             region: ty::Region<'tcx>)\n+    {\n+        let outlives = RegionckOutlives::new(&self.infcx,\n+                                             &self.region_bound_pairs,\n+                                             self.implicit_region_bound,\n+                                             self.param_env,\n+                                             self.body_id);\n+        self.register_infer_ok_obligations(outlives.type_must_outlive(origin, ty, region));\n+    }\n+\n     /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n     /// resulting pointer is linked to the lifetime of its guarantor (if any).\n     fn link_addr_of(&mut self, expr: &hir::Expr,\n@@ -1487,345 +1510,4 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n     }\n-\n-    /// Ensures that type is well-formed in `region`, which implies (among\n-    /// other things) that all borrowed data reachable via `ty` outlives\n-    /// `region`.\n-    pub fn type_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             ty: Ty<'tcx>,\n-                             region: ty::Region<'tcx>)\n-    {\n-        let ty = self.resolve_type(ty);\n-\n-        debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n-               ty,\n-               region,\n-               origin);\n-\n-        assert!(!ty.has_escaping_regions());\n-\n-        let components = self.tcx.outlives_components(ty);\n-        self.components_must_outlive(origin, components, region);\n-    }\n-\n-    fn components_must_outlive(&self,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               components: Vec<Component<'tcx>>,\n-                               region: ty::Region<'tcx>)\n-    {\n-        for component in components {\n-            let origin = origin.clone();\n-            match component {\n-                Component::Region(region1) => {\n-                    self.sub_regions(origin, region, region1);\n-                }\n-                Component::Param(param_ty) => {\n-                    self.param_ty_must_outlive(origin, region, param_ty);\n-                }\n-                Component::Projection(projection_ty) => {\n-                    self.projection_must_outlive(origin, region, projection_ty);\n-                }\n-                Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, subcomponents, region);\n-                }\n-                Component::UnresolvedInferenceVariable(v) => {\n-                    // ignore this, we presume it will yield an error\n-                    // later, since if a type variable is not resolved by\n-                    // this point it never will be\n-                    self.tcx.sess.delay_span_bug(\n-                        origin.span(),\n-                        &format!(\"unresolved inference variable in outlives: {:?}\", v));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn param_ty_must_outlive(&self,\n-                             origin: infer::SubregionOrigin<'tcx>,\n-                             region: ty::Region<'tcx>,\n-                             param_ty: ty::ParamTy) {\n-        debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n-               region, param_ty, origin);\n-\n-        let verify_bound = self.param_bound(param_ty);\n-        let generic = GenericKind::Param(param_ty);\n-        self.verify_generic_bound(origin, generic, region, verify_bound);\n-    }\n-\n-    fn projection_must_outlive(&self,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               region: ty::Region<'tcx>,\n-                               projection_ty: ty::ProjectionTy<'tcx>)\n-    {\n-        debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n-               region, projection_ty, origin);\n-\n-        // This case is thorny for inference. The fundamental problem is\n-        // that there are many cases where we have choice, and inference\n-        // doesn't like choice (the current region inference in\n-        // particular). :) First off, we have to choose between using the\n-        // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n-        // OutlivesProjectionComponent rules, any one of which is\n-        // sufficient.  If there are no inference variables involved, it's\n-        // not hard to pick the right rule, but if there are, we're in a\n-        // bit of a catch 22: if we picked which rule we were going to\n-        // use, we could add constraints to the region inference graph\n-        // that make it apply, but if we don't add those constraints, the\n-        // rule might not apply (but another rule might). For now, we err\n-        // on the side of adding too few edges into the graph.\n-\n-        // Compute the bounds we can derive from the environment or trait\n-        // definition.  We know that the projection outlives all the\n-        // regions in this list.\n-        let env_bounds = self.projection_declared_bounds(origin.span(), projection_ty);\n-\n-        debug!(\"projection_must_outlive: env_bounds={:?}\",\n-               env_bounds);\n-\n-        // If we know that the projection outlives 'static, then we're\n-        // done here.\n-        if env_bounds.contains(&&ty::ReStatic) {\n-            debug!(\"projection_must_outlive: 'static as declared bound\");\n-            return;\n-        }\n-\n-        // If declared bounds list is empty, the only applicable rule is\n-        // OutlivesProjectionComponent. If there are inference variables,\n-        // then, we can break down the outlives into more primitive\n-        // components without adding unnecessary edges.\n-        //\n-        // If there are *no* inference variables, however, we COULD do\n-        // this, but we choose not to, because the error messages are less\n-        // good. For example, a requirement like `T::Item: 'r` would be\n-        // translated to a requirement that `T: 'r`; when this is reported\n-        // to the user, it will thus say \"T: 'r must hold so that T::Item:\n-        // 'r holds\". But that makes it sound like the only way to fix\n-        // the problem is to add `T: 'r`, which isn't true. So, if there are no\n-        // inference variables, we use a verify constraint instead of adding\n-        // edges, which winds up enforcing the same condition.\n-        let needs_infer = projection_ty.needs_infer();\n-        if env_bounds.is_empty() && needs_infer {\n-            debug!(\"projection_must_outlive: no declared bounds\");\n-\n-            for component_ty in projection_ty.substs.types() {\n-                self.type_must_outlive(origin.clone(), component_ty, region);\n-            }\n-\n-            for r in projection_ty.substs.regions() {\n-                self.sub_regions(origin.clone(), region, r);\n-            }\n-\n-            return;\n-        }\n-\n-        // If we find that there is a unique declared bound `'b`, and this bound\n-        // appears in the trait reference, then the best action is to require that `'b:'r`,\n-        // so do that. This is best no matter what rule we use:\n-        //\n-        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n-        // the requirement that `'b:'r`\n-        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n-        // other conditions\n-        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n-            let unique_bound = env_bounds[0];\n-            debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.substs.regions().any(|r| env_bounds.contains(&r)) {\n-                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.sub_regions(origin.clone(), region, unique_bound);\n-                return;\n-            }\n-        }\n-\n-        // Fallback to verifying after the fact that there exists a\n-        // declared bound, or that all the components appearing in the\n-        // projection outlive; in some cases, this may add insufficient\n-        // edges into the inference graph, leading to inference failures\n-        // even though a satisfactory solution exists.\n-        let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n-        let generic = GenericKind::Projection(projection_ty);\n-        self.verify_generic_bound(origin, generic.clone(), region, verify_bound);\n-    }\n-\n-    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.sty {\n-            ty::TyParam(p) => {\n-                self.param_bound(p)\n-            }\n-            ty::TyProjection(data) => {\n-                let declared_bounds = self.projection_declared_bounds(span, data);\n-                self.projection_bound(span, declared_bounds, data)\n-            }\n-            _ => {\n-                self.recursive_type_bound(span, ty)\n-            }\n-        }\n-    }\n-\n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        debug!(\"param_bound(param_ty={:?})\",\n-               param_ty);\n-\n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n-\n-        // Add in the default bound of fn body that applies to all in\n-        // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n-\n-        VerifyBound::AnyRegion(param_bounds)\n-    }\n-\n-    fn projection_declared_bounds(&self,\n-                                  span: Span,\n-                                  projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<ty::Region<'tcx>>\n-    {\n-        // First assemble bounds from where clauses and traits.\n-\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n-\n-        declared_bounds.extend_from_slice(\n-            &self.declared_projection_bounds_from_trait(span, projection_ty));\n-\n-        declared_bounds\n-    }\n-\n-    fn projection_bound(&self,\n-                        span: Span,\n-                        declared_bounds: Vec<ty::Region<'tcx>>,\n-                        projection_ty: ty::ProjectionTy<'tcx>)\n-                        -> VerifyBound<'tcx> {\n-        debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-               declared_bounds, projection_ty);\n-\n-        // see the extensive comment in projection_must_outlive\n-        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-        let recursive_bound = self.recursive_type_bound(span, ty);\n-\n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n-    }\n-\n-    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = vec![];\n-\n-        for subty in ty.walk_shallow() {\n-            bounds.push(self.type_bound(span, subty));\n-        }\n-\n-        let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n-\n-        // remove bounds that must hold, since they are not interesting\n-        bounds.retain(|b| !b.must_hold());\n-\n-        if bounds.len() == 1 {\n-            bounds.pop().unwrap()\n-        } else {\n-            VerifyBound::AllBounds(bounds)\n-        }\n-    }\n-\n-    fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<ty::Region<'tcx>>\n-    {\n-        let param_env = &self.param_env;\n-\n-        // To start, collect bounds from user:\n-        let mut param_bounds = self.tcx.required_region_bounds(generic.to_ty(self.tcx),\n-                                                               param_env.caller_bounds.to_vec());\n-\n-        // Next, collect regions we scraped from the well-formedness\n-        // constraints in the fn signature. To do that, we walk the list\n-        // of known relations from the fn ctxt.\n-        //\n-        // This is crucial because otherwise code like this fails:\n-        //\n-        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n-        //\n-        // The problem is that the type of `x` is `&'a A`. To be\n-        // well-formed, then, A must be lower-generic by `'a`, but we\n-        // don't know that this holds from first principles.\n-        for &(r, p) in &self.region_bound_pairs {\n-            debug!(\"generic={:?} p={:?}\",\n-                   generic,\n-                   p);\n-            if generic == p {\n-                param_bounds.push(r);\n-            }\n-        }\n-\n-        param_bounds\n-    }\n-\n-    fn declared_projection_bounds_from_trait(&self,\n-                                             span: Span,\n-                                             projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<ty::Region<'tcx>>\n-    {\n-        debug!(\"projection_bounds(projection_ty={:?})\",\n-               projection_ty);\n-        let ty = self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n-\n-        // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n-        // in looking for a trait definition like:\n-        //\n-        // ```\n-        // trait SomeTrait<'a> {\n-        //     type SomeType : 'a;\n-        // }\n-        // ```\n-        //\n-        // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-        let trait_predicates = self.tcx.predicates_of(projection_ty.trait_ref(self.tcx).def_id);\n-        assert_eq!(trait_predicates.parent, None);\n-        let predicates = trait_predicates.predicates.as_slice().to_vec();\n-        traits::elaborate_predicates(self.tcx, predicates)\n-            .filter_map(|predicate| {\n-                // we're only interesting in `T : 'a` style predicates:\n-                let outlives = match predicate {\n-                    ty::Predicate::TypeOutlives(data) => data,\n-                    _ => { return None; }\n-                };\n-\n-                debug!(\"projection_bounds: outlives={:?} (1)\",\n-                       outlives);\n-\n-                // apply the substitutions (and normalize any projected types)\n-                let outlives = self.instantiate_type_scheme(span,\n-                                                            projection_ty.substs,\n-                                                            &outlives);\n-\n-                debug!(\"projection_bounds: outlives={:?} (2)\",\n-                       outlives);\n-\n-                let region_result = self.commit_if_ok(|_| {\n-                    let (outlives, _) =\n-                        self.replace_late_bound_regions_with_fresh_var(\n-                            span,\n-                            infer::AssocTypeProjection(projection_ty.item_def_id),\n-                            &outlives);\n-\n-                    debug!(\"projection_bounds: outlives={:?} (3)\",\n-                           outlives);\n-\n-                    // check whether this predicate applies to our current projection\n-                    let cause = self.fcx.misc(span);\n-                    match self.at(&cause, self.fcx.param_env).eq(outlives.0, ty) {\n-                        Ok(ok) => Ok((ok, outlives.1)),\n-                        Err(_) => Err(())\n-                    }\n-                }).map(|(ok, result)| {\n-                    self.register_infer_ok_obligations(ok);\n-                    result\n-                });\n-\n-                debug!(\"projection_bounds: region_result={:?}\",\n-                       region_result);\n-\n-                region_result.ok()\n-            })\n-            .collect()\n-    }\n }"}, {"sha": "9bd7384a48e151c891887f09ecfd431a5e3c45c7", "filename": "src/librustc_typeck/check/regionck_outlives.rs", "status": "added", "additions": 445, "deletions": 0, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Fcheck%2Fregionck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck_outlives.rs?ref=d73be851fbcaa2887d390192c6774b3792411c9f", "patch": "@@ -0,0 +1,445 @@\n+//! Temporary holding spot for some code I want to factor out.\n+\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, PredicateObligations};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::infer::{self, GenericKind, InferCtxt, InferOk, VerifyBound};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::outlives::Component;\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+pub struct RegionckOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    // Context provided by the caller:\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_id: ast::NodeId,\n+\n+    // Obligations that we accrue as we go:\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> RegionckOutlives<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            body_id,\n+            obligations: vec![],\n+        }\n+    }\n+\n+    /// Adds constraints to inference such that `T: 'a` holds (or\n+    /// reports an error if it cannot).\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`, the reason we need this constraint\n+    /// - `ty`, the type `T`\n+    /// - `region`, the region `'a`\n+    pub fn type_must_outlive(\n+        mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> InferOk<'tcx, ()> {\n+        self.type_must_outlive_pushing_obligations(origin, ty, region);\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations,\n+        }\n+    }\n+\n+    /// Internal helper: ensure that `ty_must_outlive` and push obligations onto\n+    /// our internal vector.\n+    fn type_must_outlive_pushing_obligations(\n+        &mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+\n+        debug!(\n+            \"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n+            ty,\n+            region,\n+            origin\n+        );\n+\n+        assert!(!ty.has_escaping_regions());\n+\n+        let components = self.tcx().outlives_components(ty);\n+        self.components_must_outlive(origin, components, region);\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn components_must_outlive(\n+        &mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        components: Vec<Component<'tcx>>,\n+        region: ty::Region<'tcx>,\n+    ) {\n+        for component in components {\n+            let origin = origin.clone();\n+            match component {\n+                Component::Region(region1) => {\n+                    self.infcx.sub_regions(origin, region, region1);\n+                }\n+                Component::Param(param_ty) => {\n+                    self.param_ty_must_outlive(origin, region, param_ty);\n+                }\n+                Component::Projection(projection_ty) => {\n+                    self.projection_must_outlive(origin, region, projection_ty);\n+                }\n+                Component::EscapingProjection(subcomponents) => {\n+                    self.components_must_outlive(origin, subcomponents, region);\n+                }\n+                Component::UnresolvedInferenceVariable(v) => {\n+                    // ignore this, we presume it will yield an error\n+                    // later, since if a type variable is not resolved by\n+                    // this point it never will be\n+                    self.infcx.tcx.sess.delay_span_bug(\n+                        origin.span(),\n+                        &format!(\"unresolved inference variable in outlives: {:?}\", v),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn param_ty_must_outlive(\n+        &mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        param_ty: ty::ParamTy,\n+    ) {\n+        debug!(\n+            \"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n+            region,\n+            param_ty,\n+            origin\n+        );\n+\n+        let verify_bound = self.param_bound(param_ty);\n+        let generic = GenericKind::Param(param_ty);\n+        self.infcx\n+            .verify_generic_bound(origin, generic, region, verify_bound);\n+    }\n+\n+    fn projection_must_outlive(\n+        &mut self,\n+        origin: infer::SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) {\n+        debug!(\n+            \"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n+            region,\n+            projection_ty,\n+            origin\n+        );\n+\n+        // This case is thorny for inference. The fundamental problem is\n+        // that there are many cases where we have choice, and inference\n+        // doesn't like choice (the current region inference in\n+        // particular). :) First off, we have to choose between using the\n+        // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n+        // OutlivesProjectionComponent rules, any one of which is\n+        // sufficient.  If there are no inference variables involved, it's\n+        // not hard to pick the right rule, but if there are, we're in a\n+        // bit of a catch 22: if we picked which rule we were going to\n+        // use, we could add constraints to the region inference graph\n+        // that make it apply, but if we don't add those constraints, the\n+        // rule might not apply (but another rule might). For now, we err\n+        // on the side of adding too few edges into the graph.\n+\n+        // Compute the bounds we can derive from the environment or trait\n+        // definition.  We know that the projection outlives all the\n+        // regions in this list.\n+        let env_bounds = self.projection_declared_bounds(origin.span(), projection_ty);\n+\n+        debug!(\"projection_must_outlive: env_bounds={:?}\", env_bounds);\n+\n+        // If we know that the projection outlives 'static, then we're\n+        // done here.\n+        if env_bounds.contains(&&ty::ReStatic) {\n+            debug!(\"projection_must_outlive: 'static as declared bound\");\n+            return;\n+        }\n+\n+        // If declared bounds list is empty, the only applicable rule is\n+        // OutlivesProjectionComponent. If there are inference variables,\n+        // then, we can break down the outlives into more primitive\n+        // components without adding unnecessary edges.\n+        //\n+        // If there are *no* inference variables, however, we COULD do\n+        // this, but we choose not to, because the error messages are less\n+        // good. For example, a requirement like `T::Item: 'r` would be\n+        // translated to a requirement that `T: 'r`; when this is reported\n+        // to the user, it will thus say \"T: 'r must hold so that T::Item:\n+        // 'r holds\". But that makes it sound like the only way to fix\n+        // the problem is to add `T: 'r`, which isn't true. So, if there are no\n+        // inference variables, we use a verify constraint instead of adding\n+        // edges, which winds up enforcing the same condition.\n+        let needs_infer = projection_ty.needs_infer();\n+        if env_bounds.is_empty() && needs_infer {\n+            debug!(\"projection_must_outlive: no declared bounds\");\n+\n+            for component_ty in projection_ty.substs.types() {\n+                self.type_must_outlive_pushing_obligations(origin.clone(), component_ty, region);\n+            }\n+\n+            for r in projection_ty.substs.regions() {\n+                self.infcx.sub_regions(origin.clone(), region, r);\n+            }\n+\n+            return;\n+        }\n+\n+        // If we find that there is a unique declared bound `'b`, and this bound\n+        // appears in the trait reference, then the best action is to require that `'b:'r`,\n+        // so do that. This is best no matter what rule we use:\n+        //\n+        // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n+        // the requirement that `'b:'r`\n+        // - OutlivesProjectionComponent: this would require `'b:'r` in addition to\n+        // other conditions\n+        if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n+            let unique_bound = env_bounds[0];\n+            debug!(\n+                \"projection_must_outlive: unique declared bound = {:?}\",\n+                unique_bound\n+            );\n+            if projection_ty\n+                .substs\n+                .regions()\n+                .any(|r| env_bounds.contains(&r))\n+            {\n+                debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+                self.infcx.sub_regions(origin.clone(), region, unique_bound);\n+                return;\n+            }\n+        }\n+\n+        // Fallback to verifying after the fact that there exists a\n+        // declared bound, or that all the components appearing in the\n+        // projection outlive; in some cases, this may add insufficient\n+        // edges into the inference graph, leading to inference failures\n+        // even though a satisfactory solution exists.\n+        let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n+        let generic = GenericKind::Projection(projection_ty);\n+        self.infcx\n+            .verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+    }\n+\n+    fn type_bound(&mut self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        match ty.sty {\n+            ty::TyParam(p) => self.param_bound(p),\n+            ty::TyProjection(data) => {\n+                let declared_bounds = self.projection_declared_bounds(span, data);\n+                self.projection_bound(span, declared_bounds, data)\n+            }\n+            _ => self.recursive_type_bound(span, ty),\n+        }\n+    }\n+\n+    fn param_bound(&mut self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n+        debug!(\"param_bound(param_ty={:?})\", param_ty);\n+\n+        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n+\n+        // Add in the default bound of fn body that applies to all in\n+        // scope type parameters:\n+        param_bounds.extend(self.implicit_region_bound);\n+\n+        VerifyBound::AnyRegion(param_bounds)\n+    }\n+\n+    fn projection_declared_bounds(\n+        &mut self,\n+        span: Span,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        // First assemble bounds from where clauses and traits.\n+\n+        let mut declared_bounds =\n+            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n+\n+        declared_bounds\n+            .extend_from_slice(&mut self.declared_projection_bounds_from_trait(span, projection_ty));\n+\n+        declared_bounds\n+    }\n+\n+    fn projection_bound(\n+        &mut self,\n+        span: Span,\n+        declared_bounds: Vec<ty::Region<'tcx>>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> VerifyBound<'tcx> {\n+        debug!(\n+            \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n+            declared_bounds,\n+            projection_ty\n+        );\n+\n+        // see the extensive comment in projection_must_outlive\n+        let ty = self.infcx\n+            .tcx\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+        let recursive_bound = self.recursive_type_bound(span, ty);\n+\n+        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+    }\n+\n+    fn recursive_type_bound(&mut self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n+        let mut bounds = vec![];\n+\n+        for subty in ty.walk_shallow() {\n+            bounds.push(self.type_bound(span, subty));\n+        }\n+\n+        let mut regions = ty.regions();\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n+        bounds.push(VerifyBound::AllRegions(regions));\n+\n+        // remove bounds that must hold, since they are not interesting\n+        bounds.retain(|b| !b.must_hold());\n+\n+        if bounds.len() == 1 {\n+            bounds.pop().unwrap()\n+        } else {\n+            VerifyBound::AllBounds(bounds)\n+        }\n+    }\n+\n+    fn declared_generic_bounds_from_env(\n+        &mut self,\n+        generic: GenericKind<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // To start, collect bounds from user:\n+        let mut param_bounds =\n+            tcx.required_region_bounds(generic.to_ty(tcx), self.param_env.caller_bounds.to_vec());\n+\n+        // Next, collect regions we scraped from the well-formedness\n+        // constraints in the fn signature. To do that, we walk the list\n+        // of known relations from the fn ctxt.\n+        //\n+        // This is crucial because otherwise code like this fails:\n+        //\n+        //     fn foo<'a, A>(x: &'a A) { x.bar() }\n+        //\n+        // The problem is that the type of `x` is `&'a A`. To be\n+        // well-formed, then, A must be lower-generic by `'a`, but we\n+        // don't know that this holds from first principles.\n+        for &(r, p) in self.region_bound_pairs {\n+            debug!(\"generic={:?} p={:?}\", generic, p);\n+            if generic == p {\n+                param_bounds.push(r);\n+            }\n+        }\n+\n+        param_bounds\n+    }\n+\n+    fn declared_projection_bounds_from_trait(\n+        &mut self,\n+        span: Span,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n+        let ty = self.tcx()\n+            .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+\n+        // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n+        // in looking for a trait definition like:\n+        //\n+        // ```\n+        // trait SomeTrait<'a> {\n+        //     type SomeType : 'a;\n+        // }\n+        // ```\n+        //\n+        // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n+        let trait_predicates = self.tcx()\n+            .predicates_of(projection_ty.trait_ref(self.tcx()).def_id);\n+        assert_eq!(trait_predicates.parent, None);\n+        let predicates = trait_predicates.predicates.as_slice().to_vec();\n+        traits::elaborate_predicates(self.tcx(), predicates)\n+            .filter_map(|predicate| {\n+                // we're only interesting in `T : 'a` style predicates:\n+                let outlives = match predicate {\n+                    ty::Predicate::TypeOutlives(data) => data,\n+                    _ => {\n+                        return None;\n+                    }\n+                };\n+\n+                debug!(\"projection_bounds: outlives={:?} (1)\", outlives);\n+\n+                // apply the substitutions (and normalize any projected types)\n+                let outlives = outlives.subst(self.tcx(), projection_ty.substs);\n+                let outlives = self.infcx.partially_normalize_associated_types_in(\n+                    span,\n+                    self.body_id,\n+                    self.param_env,\n+                    &outlives,\n+                );\n+                let outlives = self.register_infer_ok_obligations(outlives);\n+\n+                debug!(\"projection_bounds: outlives={:?} (2)\", outlives);\n+\n+                let region_result = self.infcx\n+                    .commit_if_ok(|_| {\n+                        let (outlives, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                            span,\n+                            infer::AssocTypeProjection(projection_ty.item_def_id),\n+                            &outlives,\n+                        );\n+\n+                        debug!(\"projection_bounds: outlives={:?} (3)\", outlives);\n+\n+                        // check whether this predicate applies to our current projection\n+                        let cause = ObligationCause::new(\n+                            span,\n+                            self.body_id,\n+                            ObligationCauseCode::MiscObligation,\n+                        );\n+                        match self.infcx.at(&cause, self.param_env).eq(outlives.0, ty) {\n+                            Ok(ok) => Ok((ok, outlives.1)),\n+                            Err(_) => Err(()),\n+                        }\n+                    })\n+                    .map(|(ok, result)| {\n+                        self.register_infer_ok_obligations(ok);\n+                        result\n+                    });\n+\n+                debug!(\"projection_bounds: region_result={:?}\", region_result);\n+\n+                region_result.ok()\n+            })\n+            .collect()\n+    }\n+\n+    fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = infer_ok;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+}"}, {"sha": "014b8b14edb83942c1957c32c5a260c5fa878489", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73be851fbcaa2887d390192c6774b3792411c9f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d73be851fbcaa2887d390192c6774b3792411c9f", "patch": "@@ -75,6 +75,7 @@ This API is completely unstable and subject to change.\n #![feature(advanced_slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n #![feature(conservative_impl_trait)]\n #![feature(match_default_bindings)]\n #![feature(never_type)]"}]}