{"sha": "3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNWE0M2U1YjZmODU3YzcxYzZmNjZkYmJkNjQwYTQ3ZDM0YTBlN2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-29T21:20:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-29T21:23:44Z"}, "message": "Revert \"auto merge of #8645 : alexcrichton/rust/issue-6436-run-non-blocking, r=brson\"\n\nThis reverts commit b8d1fa399402c71331aefd634d710004e00b73a6, reversing\nchanges made to f22b4b169854c8a4ba86c16ee43327d6bcf94562.\n\nConflicts:\n\tmk/rt.mk\n\tsrc/libuv", "tree": {"sha": "c2bf9ab63ff4c20dbe5a43660fdd919ae822c9b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2bf9ab63ff4c20dbe5a43660fdd919ae822c9b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "html_url": "https://github.com/rust-lang/rust/commit/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "698873e3a829d764b451f657178403c704044721", "url": "https://api.github.com/repos/rust-lang/rust/commits/698873e3a829d764b451f657178403c704044721", "html_url": "https://github.com/rust-lang/rust/commit/698873e3a829d764b451f657178403c704044721"}], "stats": {"total": 2284, "additions": 1126, "deletions": 1158}, "files": [{"sha": "88ead6e608d5c4ee00212451f47c281d09d00846", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -4,5 +4,5 @@\n \tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n-\turl = https://github.com/alexcrichton/libuv.git\n+\turl = https://github.com/brson/libuv.git\n \tbranch = master"}, {"sha": "c260945cbc9b035bb11c4e76967c2c4097e2d1ad", "filename": "mk/rt.mk", "status": "modified", "additions": 10, "deletions": 36, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -168,58 +168,36 @@ LIBUV_DEPS := $$(wildcard \\\n               $$(S)src/libuv/*/*/*/*)\n endif\n \n-LIBUV_GYP := $$(S)src/libuv/build/gyp\n-LIBUV_MAKEFILE_$(1)_$(2) := $$(CFG_BUILD_DIR)rt/$(1)/stage$(2)/libuv/Makefile\n-LIBUV_NO_LOAD = run-benchmarks.target.mk run-tests.target.mk \\\n-\t\tuv_dtrace_header.target.mk uv_dtrace_provider.target.mk\n-\n-ifeq ($(OSTYPE_$(1)), linux-androideabi)\n-$$(LIBUV_MAKEFILE_$(1)_$(2)): $$(LIBUV_GYP)\n-\t(cd $(S)src/libuv/ && \\\n-\t $$(CFG_PYTHON) ./gyp_uv -f make -Dtarget_arch=$$(LIBUV_ARCH_$(1)) -D ninja -DOS=android \\\n-\t   -Goutput_dir=$$(@D) --generator-output $$(@D))\n-else\n-$$(LIBUV_MAKEFILE_$(1)_$(2)): $$(LIBUV_GYP)\n-\t(cd $(S)src/libuv/ && \\\n-\t $$(CFG_PYTHON) ./gyp_uv -f make -Dtarget_arch=$$(LIBUV_ARCH_$(1)) -D ninja \\\n-\t   -Goutput_dir=$$(@D) --generator-output $$(@D))\n-endif\n-\n # XXX: Shouldn't need platform-specific conditions here\n ifdef CFG_WINDOWSY_$(1)\n $$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n-\t$$(Q)rm -f $$(S)src/libuv/libuv.a\n-\t$$(Q)$$(MAKE) -C $$(S)src/libuv -f Makefile.mingw \\\n-\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n-\t\tAR=\"$$(AR_$(1))\" \\\n+\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n+\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n+\t\tOS=mingw \\\n \t\tV=$$(VERBOSE)\n-\t$$(Q)cp $$(S)src/libuv/libuv.a $$@\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n-\t$$(Q)$$(MAKE) -C $$(@D) \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n+\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t \tLINK=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n-\t\thost=android OS=linux \\\n \t\tPLATFORM=android \\\n-\t\tbuilddir=\".\" \\\n \t\tBUILDTYPE=Release \\\n-\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n+\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n+\t\thost=android OS=linux \\\n \t\tV=$$(VERBOSE)\n else\n-$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)_$(2))\n-\t$$(Q)$$(MAKE) -C $$(@D) \\\n+$$(LIBUV_LIB_$(1)_$(2)): $$(LIBUV_DEPS)\n+\t$$(Q)$$(MAKE) -C $$(S)src/libuv/ \\\n \t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tLDFLAGS=\"$$(CFG_GCCISH_LINK_FLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1)))\" \\\n \t\tCC=\"$$(CC_$(1))\" \\\n \t\tCXX=\"$$(CXX_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n-\t\tbuilddir=\".\" \\\n-\t\tBUILDTYPE=Release \\\n-\t\tNO_LOAD=\"$$(LIBUV_NO_LOAD)\" \\\n+\t\tbuilddir_name=\"$$(CFG_BUILD_DIR)/rt/$(1)/stage$(2)/libuv\" \\\n \t\tV=$$(VERBOSE)\n endif\n \n@@ -283,7 +261,3 @@ endef\n $(foreach stage,$(STAGES), \\\n \t$(foreach target,$(CFG_TARGET_TRIPLES), \\\n \t $(eval $(call DEF_RUNTIME_TARGETS,$(target),$(stage)))))\n-\n-$(LIBUV_GYP):\n-\tmkdir -p $(S)src/libuv/build\n-\tgit clone https://git.chromium.org/external/gyp.git $(S)src/libuv/build/gyp"}, {"sha": "45e4f756d7a15752a7e3d3e7ed672ac2547c8296", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -54,10 +54,10 @@ pub fn run(lib_path: &str,\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    }).unwrap();\n+    });\n \n     for input in input.iter() {\n-        proc.input().write(input.as_bytes());\n+        proc.input().write_str(*input);\n     }\n     let output = proc.finish_with_output();\n "}, {"sha": "05fd621e597781b0012d6ba6b87cd0d4c6c88947", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -20,16 +20,41 @@ use procsrv;\n use util;\n use util::logv;\n \n+use std::cell::Cell;\n use std::io;\n use std::os;\n use std::str;\n+use std::task::{spawn_sched, SingleThreaded};\n use std::vec;\n+use std::unstable::running_on_valgrind;\n \n use extra::test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n-    let mut _mm = MetricMap::new();\n-    run_metrics(config, testfile, &mut _mm);\n+    let config = Cell::new(config);\n+    let testfile = Cell::new(testfile);\n+    // FIXME #6436: Creating another thread to run the test because this\n+    // is going to call waitpid. The new scheduler has some strange\n+    // interaction between the blocking tasks and 'friend' schedulers\n+    // that destroys parallelism if we let normal schedulers block.\n+    // It should be possible to remove this spawn once std::run is\n+    // rewritten to be non-blocking.\n+    //\n+    // We do _not_ create another thread if we're running on V because\n+    // it serializes all threads anyways.\n+    if running_on_valgrind() {\n+        let config = config.take();\n+        let testfile = testfile.take();\n+        let mut _mm = MetricMap::new();\n+        run_metrics(config, testfile, &mut _mm);\n+    } else {\n+        do spawn_sched(SingleThreaded) {\n+            let config = config.take();\n+            let testfile = testfile.take();\n+            let mut _mm = MetricMap::new();\n+            run_metrics(config, testfile, &mut _mm);\n+        }\n+    }\n }\n \n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {"}, {"sha": "c13e85ea71659724ac3b46102a5b905125f458a2", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -104,14 +104,14 @@ fn pandoc_writer(\n     ];\n \n     do generic_writer |markdown| {\n+        use std::io::WriterUtil;\n+\n         debug!(\"pandoc cmd: %s\", pandoc_cmd);\n         debug!(\"pandoc args: %s\", pandoc_args.connect(\" \"));\n \n-        let proc = run::Process::new(pandoc_cmd, pandoc_args,\n-                                     run::ProcessOptions::new());\n-        let mut proc = proc.unwrap();\n+        let mut proc = run::Process::new(pandoc_cmd, pandoc_args, run::ProcessOptions::new());\n \n-        proc.input().write(markdown.as_bytes());\n+        proc.input().write_str(markdown);\n         let output = proc.finish_with_output();\n \n         debug!(\"pandoc result: %i\", output.status);"}, {"sha": "caa004a53b22879363807268745510a0926659bf", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -89,7 +89,7 @@ pub fn git_clone_general(source: &str, target: &Path, v: &Version) -> bool {\n \n fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput {\n     let mut prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n-                                ,..ProcessOptions::new()}).unwrap();\n+                                ,..ProcessOptions::new()});\n     prog.finish_with_output()\n }\n "}, {"sha": "98999da41c81633bad276bce6142f104889d20fe", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -112,14 +112,13 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> Path {\n \n fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n     let cwd = (*cwd).clone();\n-    let prog = run::Process::new(\"git\", args, run::ProcessOptions {\n+    let mut prog = run::Process::new(\"git\", args, run::ProcessOptions {\n         env: env,\n         dir: Some(&cwd),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n-    let mut prog = prog.unwrap();\n     let rslt = prog.finish_with_output();\n     if rslt.status != 0 {\n         fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n@@ -227,7 +226,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    }).unwrap();\n+    });\n     let output = prog.finish_with_output();\n     debug!(\"Output from command %s with args %? was %s {%s}[%?]\",\n                     cmd, args, str::from_bytes(output.output),\n@@ -1028,17 +1027,16 @@ fn test_extern_mod() {\n                      test_sysroot().to_str(),\n                      exec_file.to_str());\n \n-    let prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n-                                                  ~\"--sysroot\", test_sysroot().to_str(),\n-                                                  ~\"-o\", exec_file.to_str()],\n-                                 run::ProcessOptions {\n+    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n+                                                      ~\"--sysroot\", test_sysroot().to_str(),\n+                                               ~\"-o\", exec_file.to_str()],\n+                                     run::ProcessOptions {\n         env: env,\n         dir: Some(&dir),\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n-    let mut prog = prog.unwrap();\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n         fail!(\"output was %s, error was %s\","}, {"sha": "f4e9c4d7c11b5aae208a71f72469b9040750a470", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -71,6 +71,9 @@ pub struct FileStream {\n     last_nread: int,\n }\n \n+impl FileStream {\n+}\n+\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {"}, {"sha": "116d240308a36c9cabf988df7d4bfe93c6762f53", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -268,9 +268,6 @@ pub use self::extensions::WriterByteConversions;\n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n-/// Synchronous, in-memory I/O.\n-pub mod pipe;\n-\n /// Synchronous, non-blocking network I/O.\n pub mod net {\n     pub mod tcp;"}, {"sha": "9be5540de484a96357c83b4f0fcc5f8068e569fc", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -16,7 +16,7 @@ use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n                RtioSocket, RtioTcpListener,\n                RtioTcpListenerObject, RtioTcpStream,\n-               RtioTcpStreamObject, RtioStream};\n+               RtioTcpStreamObject};\n use rt::local::Local;\n \n pub struct TcpStream(~RtioTcpStreamObject);\n@@ -69,7 +69,7 @@ impl TcpStream {\n \n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match (***self).read(buf) {\n+        match (**self).read(buf) {\n             Ok(read) => Some(read),\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n@@ -86,7 +86,7 @@ impl Reader for TcpStream {\n \n impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) {\n-        match (***self).write(buf) {\n+        match (**self).write(buf) {\n             Ok(_) => (),\n             Err(ioerr) => io_error::cond.raise(ioerr),\n         }\n@@ -166,7 +166,7 @@ mod test {\n         do run_in_newsched_task {\n             let mut called = false;\n             do io_error::cond.trap(|e| {\n-                assert_eq!(e.kind, ConnectionRefused);\n+                assert!(e.kind == ConnectionRefused);\n                 called = true;\n             }).inside {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };"}, {"sha": "02b3d0fe57dc24856bf584093539c9af7ffd235c", "filename": "src/libstd/rt/io/pipe.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=698873e3a829d764b451f657178403c704044721", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous, in-memory pipes.\n-//!\n-//! Currently these aren't particularly useful, there only exists bindings\n-//! enough so that pipes can be created to child processes.\n-\n-use prelude::*;\n-use super::{Reader, Writer};\n-use rt::io::{io_error, read_error, EndOfFile};\n-use rt::local::Local;\n-use rt::rtio::{RtioPipeObject, RtioStream, IoFactoryObject, IoFactory};\n-use rt::uv::pipe;\n-\n-pub struct PipeStream(~RtioPipeObject);\n-\n-impl PipeStream {\n-    /// Creates a new pipe initialized, but not bound to any particular\n-    /// source/destination\n-    pub fn new() -> Option<PipeStream> {\n-        let pipe = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).pipe_init(false)\n-        };\n-        match pipe {\n-            Ok(p) => Some(PipeStream(p)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Extracts the underlying libuv pipe to be bound to another source.\n-    pub fn uv_pipe(&self) -> pipe::Pipe {\n-        // Did someone say multiple layers of indirection?\n-        (**self).uv_pipe()\n-    }\n-}\n-\n-impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match (***self).read(buf) {\n-            Ok(read) => Some(read),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    read_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    fn eof(&mut self) -> bool { fail!() }\n-}\n-\n-impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match (***self).write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n-\n-    fn flush(&mut self) { fail!() }\n-}"}, {"sha": "1788b7a04e33446c3e8c04b77671481eed5bea29", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc;\n use option::*;\n use result::*;\n use libc::c_int;\n \n use rt::io::IoError;\n use super::io::net::ip::{IpAddr, SocketAddr};\n-use rt::uv;\n use rt::uv::uvio;\n use path::Path;\n use super::io::support::PathLike;\n@@ -32,9 +30,6 @@ pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n-pub type RtioPipeObject = uvio::UvPipeStream;\n-pub type RtioProcessObject = uvio::UvProcess;\n-pub type RtioProcessConfig<'self> = uv::process::Config<'self>;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -77,13 +72,6 @@ pub trait IoFactory {\n     fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioPipeObject, IoError>;\n-    fn spawn(&mut self, config: &RtioProcessConfig) -> Result<~RtioProcessObject, IoError>;\n-}\n-\n-pub trait RtioStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -92,7 +80,9 @@ pub trait RtioTcpListener : RtioSocket {\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n \n-pub trait RtioTcpStream : RtioSocket + RtioStream {\n+pub trait RtioTcpStream : RtioSocket {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n     fn peer_name(&mut self) -> Result<SocketAddr, IoError>;\n     fn control_congestion(&mut self) -> Result<(), IoError>;\n     fn nodelay(&mut self) -> Result<(), IoError>;\n@@ -134,9 +124,3 @@ pub trait RtioFileStream {\n     fn tell(&self) -> Result<u64, IoError>;\n     fn flush(&mut self) -> Result<(), IoError>;\n }\n-\n-pub trait RtioProcess {\n-    fn id(&self) -> libc::pid_t;\n-    fn kill(&mut self, signal: int) -> Result<(), IoError>;\n-    fn wait(&mut self) -> int;\n-}"}, {"sha": "d0ca38317cbededd13675b41c17ad764ee7f982b", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -34,7 +34,7 @@ impl AsyncWatcher {\n \n         extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             let data = watcher.get_watcher_data();\n             let cb = data.async_cb.get_ref();\n             (*cb)(watcher, status);"}, {"sha": "405dfe0a7f099b6606a08c4a9f9d2897255b2f69", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -11,8 +11,8 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf, UvError};\n-use rt::uv::status_to_maybe_uv_error;\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n+             status_to_maybe_uv_error_with_loop, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n@@ -62,7 +62,7 @@ impl FsRequest {\n     pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int)\n           -> Result<int, UvError> {\n         let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(result)\n+        sync_cleanup(loop_, result)\n     }\n \n     fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n@@ -83,11 +83,11 @@ impl FsRequest {\n     }\n     pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n         let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(result);\n+        sync_cleanup(loop_, result);\n     }\n     pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n         let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(result)\n+        sync_cleanup(loop_, result)\n     }\n \n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n@@ -139,8 +139,9 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n         match self { &FsRequest(ptr) => ptr }\n     }\n }\n-    fn sync_cleanup(result: int) -> Result<int, UvError> {\n-        match status_to_maybe_uv_error(result as i32) {\n+    fn sync_cleanup(loop_: &Loop, result: int)\n+          -> Result<int, UvError> {\n+        match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n             Some(err) => Err(err),\n             None => Ok(result)\n         }\n@@ -183,7 +184,7 @@ impl FileDescriptor {\n     pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n+        sync_cleanup(loop_, result)\n     }\n \n     fn read_common(&mut self, loop_: &Loop, buf: Buf,\n@@ -211,7 +212,7 @@ impl FileDescriptor {\n     pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(result)\n+        sync_cleanup(loop_, result)\n     }\n \n     fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n@@ -233,11 +234,12 @@ impl FileDescriptor {\n     }\n     pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n         let result = self.close_common(loop_, None);\n-        sync_cleanup(result)\n+        sync_cleanup(loop_, result)\n     }\n }\n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n+    let loop_ = req.get_loop();\n     // pull the user cb out of the req data\n     let cb = {\n         let data = req.get_req_data();\n@@ -248,7 +250,8 @@ extern fn compl_cb(req: *uv_fs_t) {\n     // in uv_fs_open calls, the result will be the fd in the\n     // case of success, otherwise it's -1 indicating an error\n     let result = req.get_result();\n-    let status = status_to_maybe_uv_error(result);\n+    let status = status_to_maybe_uv_error_with_loop(\n+        loop_.native_handle(), result);\n     // we have a req and status, call the user cb..\n     // only giving the user a ref to the FsRequest, as we\n     // have to clean it up, afterwards (and they aren't really"}, {"sha": "a21146620ca823ec8643adfdb84c00f31a391b38", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -43,7 +43,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n             (*cb)(idle_watcher, status);\n         }\n     }\n@@ -57,7 +57,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n             (*cb)(idle_watcher, status);\n         }\n     }"}, {"sha": "75b9a5ac553e8eff77d5d096730081f2e12cd902", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -58,8 +58,6 @@ pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n-pub use self::process::Process;\n-pub use self::pipe::Pipe;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -72,8 +70,6 @@ pub mod net;\n pub mod idle;\n pub mod timer;\n pub mod async;\n-pub mod process;\n-pub mod pipe;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -130,8 +126,6 @@ pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n-// first int is exit_status, second is term_signal\n-pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n@@ -149,8 +143,7 @@ struct WatcherData {\n     timer_cb: Option<TimerCallback>,\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n-    udp_send_cb: Option<UdpSendCallback>,\n-    exit_cb: Option<ExitCallback>,\n+    udp_send_cb: Option<UdpSendCallback>\n }\n \n pub trait WatcherInterop {\n@@ -182,8 +175,7 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 timer_cb: None,\n                 async_cb: None,\n                 udp_recv_cb: None,\n-                udp_send_cb: None,\n-                exit_cb: None,\n+                udp_send_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);\n@@ -210,12 +202,12 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n // XXX: Need to define the error constants like EOF so they can be\n // compared to the UvError type\n \n-pub struct UvError(c_int);\n+pub struct UvError(uvll::uv_err_t);\n \n impl UvError {\n     pub fn name(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(a) => a };\n+            let inner = match self { &UvError(ref a) => a };\n             let name_str = uvll::err_name(inner);\n             assert!(name_str.is_not_null());\n             from_c_str(name_str)\n@@ -224,15 +216,15 @@ impl UvError {\n \n     pub fn desc(&self) -> ~str {\n         unsafe {\n-            let inner = match self { &UvError(a) => a };\n+            let inner = match self { &UvError(ref a) => a };\n             let desc_str = uvll::strerror(inner);\n             assert!(desc_str.is_not_null());\n             from_c_str(desc_str)\n         }\n     }\n \n     pub fn is_eof(&self) -> bool {\n-        **self == uvll::EOF\n+        self.code == uvll::EOF\n     }\n }\n \n@@ -244,30 +236,38 @@ impl ToStr for UvError {\n \n #[test]\n fn error_smoke_test() {\n-    let err: UvError = UvError(uvll::EOF);\n+    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n+    let err: UvError = UvError(err);\n     assert_eq!(err.to_str(), ~\"EOF: end of file\");\n }\n \n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n+    unsafe {\n+        let loop_ = watcher.event_loop();\n+        UvError(uvll::last_error(loop_.native_handle()))\n+    }\n+}\n+\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     unsafe {\n         // Importing error constants\n         use rt::uv::uvll::*;\n         use rt::io::*;\n \n         // uv error descriptions are static\n-        let c_desc = uvll::strerror(*uverr);\n+        let c_desc = uvll::strerror(&*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n-        let kind = match *uverr {\n+        let kind = match uverr.code {\n             UNKNOWN => OtherIoError,\n             OK => OtherIoError,\n             EOF => EndOfFile,\n             EACCES => PermissionDenied,\n             ECONNREFUSED => ConnectionRefused,\n             ECONNRESET => ConnectionReset,\n             EPIPE => BrokenPipe,\n-            err => {\n-                rtdebug!(\"uverr.code %d\", err as int);\n+            _ => {\n+                rtdebug!(\"uverr.code %u\", uverr.code as uint);\n                 // XXX: Need to map remaining uv error types\n                 OtherIoError\n             }\n@@ -281,12 +281,31 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     }\n }\n \n-/// Convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> {\n-    if status >= 0 {\n+/// Given a uv handle, convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error_with_loop(\n+    loop_: *uvll::uv_loop_t,\n+    status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n+/// Given a uv handle, convert a callback status to a UvError\n+pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n+                                                                 status: c_int) -> Option<UvError> {\n+    if status != -1 {\n         None\n     } else {\n-        Some(UvError(status))\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n+            status_to_maybe_uv_error_with_loop(loop_, status)\n+        }\n     }\n }\n "}, {"sha": "e8d0296e543a44afbc7e24ba5754a37016a4116c", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -16,6 +16,7 @@ use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n@@ -136,7 +137,7 @@ impl StreamWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n+            let status = status_to_maybe_uv_error(stream_watcher, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n     }\n@@ -166,7 +167,7 @@ impl StreamWatcher {\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             cb(stream_watcher, status);\n         }\n     }\n@@ -231,7 +232,7 @@ impl TcpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(UvError(result)),\n+                _ => Err(last_uv_error(self)),\n             }\n         }\n     }\n@@ -259,7 +260,7 @@ impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(status);\n+                let status = status_to_maybe_uv_error(stream_watcher, status);\n                 cb(stream_watcher, status);\n             }\n         }\n@@ -282,7 +283,7 @@ impl TcpWatcher {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             (*cb)(stream_watcher, status);\n         }\n     }\n@@ -326,7 +327,7 @@ impl UdpWatcher {\n             };\n             match result {\n                 0 => Ok(()),\n-                _ => Err(UvError(result)),\n+                _ => Err(last_uv_error(self)),\n             }\n         }\n     }\n@@ -359,7 +360,7 @@ impl UdpWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n+            let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n             let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n@@ -394,7 +395,7 @@ impl UdpWatcher {\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n             let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(udp_watcher, status);\n             cb(udp_watcher, status);\n         }\n     }"}, {"sha": "1147c731a60c5e312a1d055bf915cec8ad4bbd4c", "filename": "src/libstd/rt/uv/pipe.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=698873e3a829d764b451f657178403c704044721", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use libc;\n-\n-use rt::uv;\n-use rt::uv::net;\n-use rt::uv::uvll;\n-\n-pub struct Pipe(*uvll::uv_pipe_t);\n-\n-impl uv::Watcher for Pipe {}\n-\n-impl Pipe {\n-    pub fn new(loop_: &uv::Loop, ipc: bool) -> Pipe {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n-            assert!(handle.is_not_null());\n-            let ipc = ipc as libc::c_int;\n-            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n-            let mut ret: Pipe =\n-                    uv::NativeHandle::from_native_handle(handle);\n-            ret.install_watcher_data();\n-            ret\n-        }\n-    }\n-\n-    pub fn as_stream(&self) -> net::StreamWatcher {\n-        net::StreamWatcher(**self as *uvll::uv_stream_t)\n-    }\n-\n-    pub fn close(self, cb: uv::NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_pipe_t) {\n-            let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n-        }\n-    }\n-}\n-\n-impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {\n-    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n-        Pipe(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_pipe_t {\n-        match self { &Pipe(ptr) => ptr }\n-    }\n-}"}, {"sha": "a02cf67ec2699973cd6703ce0f34135c68c57674", "filename": "src/libstd/rt/uv/process.rs", "status": "removed", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/698873e3a829d764b451f657178403c704044721/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=698873e3a829d764b451f657178403c704044721", "patch": "@@ -1,264 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use prelude::*;\n-use libc;\n-use ptr;\n-use vec;\n-use cell::Cell;\n-\n-use rt::uv;\n-use rt::uv::net;\n-use rt::uv::pipe;\n-use rt::uv::uvll;\n-\n-/// A process wraps the handle of the underlying uv_process_t.\n-pub struct Process(*uvll::uv_process_t);\n-\n-/// This configuration describes how a new process should be spawned. This is\n-/// translated to libuv's own configuration\n-pub struct Config<'self> {\n-    /// Path to the program to run\n-    program: &'self str,\n-\n-    /// Arguments to pass to the program (doesn't include the program itself)\n-    args: &'self [~str],\n-\n-    /// Optional environment to specify for the program. If this is None, then\n-    /// it will inherit the current process's environment.\n-    env: Option<&'self [(~str, ~str)]>,\n-\n-    /// Optional working directory for the new process. If this is None, then\n-    /// the current directory of the running process is inherited.\n-    cwd: Option<&'self str>,\n-\n-    /// Any number of streams/file descriptors/pipes may be attached to this\n-    /// process. This list enumerates the file descriptors and such for the\n-    /// process to be spawned, and the file descriptors inherited will start at\n-    /// 0 and go to the length of this array.\n-    ///\n-    /// Standard file descriptors are:\n-    ///\n-    ///     0 - stdin\n-    ///     1 - stdout\n-    ///     2 - stderr\n-    io: &'self [StdioContainer]\n-}\n-\n-/// Describes what to do with a standard io stream for a child process.\n-pub enum StdioContainer {\n-    /// This stream will be ignored. This is the equivalent of attaching the\n-    /// stream to `/dev/null`\n-    Ignored,\n-\n-    /// The specified file descriptor is inherited for the stream which it is\n-    /// specified for.\n-    InheritFd(libc::c_int),\n-\n-    /// The specified libuv stream is inherited for the corresponding file\n-    /// descriptor it is assigned to.\n-    InheritStream(net::StreamWatcher),\n-\n-    /// Creates a pipe for the specified file descriptor which will be directed\n-    /// into the previously-initialized pipe passed in.\n-    ///\n-    /// The first boolean argument is whether the pipe is readable, and the\n-    /// second is whether it is writable. These properties are from the view of\n-    /// the *child* process, not the parent process.\n-    CreatePipe(pipe::Pipe, bool /* readable */, bool /* writable */),\n-}\n-\n-impl uv::Watcher for Process {}\n-\n-impl Process {\n-    /// Creates a new process, ready to spawn inside an event loop\n-    pub fn new() -> Process {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n-        assert!(handle.is_not_null());\n-        let mut ret: Process = uv::NativeHandle::from_native_handle(handle);\n-        ret.install_watcher_data();\n-        return ret;\n-    }\n-\n-    /// Spawn a new process inside the specified event loop.\n-    ///\n-    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n-    /// will be run only once, when the process exits.\n-    ///\n-    /// Returns either the corresponding process object or an error which\n-    /// occurred.\n-    pub fn spawn(&mut self, loop_: &uv::Loop, config: &Config,\n-                 exit_cb: uv::ExitCallback) -> Result<(), uv::UvError> {\n-        let cwd = config.cwd.map_move(|s| s.to_c_str());\n-\n-        extern fn on_exit(p: *uvll::uv_process_t,\n-                          exit_status: libc::c_int,\n-                          term_signal: libc::c_int) {\n-            let mut p: Process = uv::NativeHandle::from_native_handle(p);\n-            let err = match exit_status {\n-                0 => None,\n-                _ => uv::status_to_maybe_uv_error(-1)\n-            };\n-            p.get_watcher_data().exit_cb.take_unwrap()(p,\n-                                                       exit_status as int,\n-                                                       term_signal as int,\n-                                                       err);\n-        }\n-\n-        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(\n-                                config.io.len());\n-        unsafe {\n-            vec::raw::set_len(&mut stdio, config.io.len());\n-            for (slot, &other) in stdio.iter().zip(config.io.iter()) {\n-                set_stdio(slot as *uvll::uv_stdio_container_t, other);\n-            }\n-        }\n-\n-        let exit_cb = Cell::new(exit_cb);\n-        do with_argv(config.program, config.args) |argv| {\n-            do with_env(config.env) |envp| {\n-                let options = uvll::uv_process_options_t {\n-                    exit_cb: on_exit,\n-                    file: unsafe { *argv },\n-                    args: argv,\n-                    env: envp,\n-                    cwd: match cwd {\n-                        Some(ref cwd) => cwd.with_ref(|p| p),\n-                        None => ptr::null(),\n-                    },\n-                    flags: 0,\n-                    stdio_count: stdio.len() as libc::c_int,\n-                    stdio: stdio.as_imm_buf(|p, _| p),\n-                    uid: 0,\n-                    gid: 0,\n-                };\n-\n-                match unsafe {\n-                    uvll::spawn(loop_.native_handle(), **self, options)\n-                } {\n-                    0 => {\n-                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n-                        Ok(())\n-                    }\n-                    err => Err(uv::UvError(err))\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Sends a signal to this process.\n-    ///\n-    /// This is a wrapper around `uv_process_kill`\n-    pub fn kill(&self, signum: int) -> Result<(), uv::UvError> {\n-        match unsafe {\n-            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n-        } {\n-            0 => Ok(()),\n-            err => Err(uv::UvError(err))\n-        }\n-    }\n-\n-    /// Returns the process id of a spawned process\n-    pub fn pid(&self) -> libc::pid_t {\n-        unsafe { uvll::process_pid(**self) as libc::pid_t }\n-    }\n-\n-    /// Closes this handle, invoking the specified callback once closed\n-    pub fn close(self, cb: uv::NullCallback) {\n-        {\n-            let mut this = self;\n-            let data = this.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n-\n-        extern fn close_cb(handle: *uvll::uv_process_t) {\n-            let mut process: Process = uv::NativeHandle::from_native_handle(handle);\n-            process.get_watcher_data().close_cb.take_unwrap()();\n-            process.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *libc::c_void) }\n-        }\n-    }\n-}\n-\n-unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t, io: StdioContainer) {\n-    match io {\n-        Ignored => { uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE); }\n-        InheritFd(fd) => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n-            uvll::set_stdio_container_fd(dst, fd);\n-        }\n-        InheritStream(stream) => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_STREAM);\n-            uvll::set_stdio_container_stream(dst, stream.native_handle());\n-        }\n-        CreatePipe(pipe, readable, writable) => {\n-            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n-            if readable {\n-                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n-            }\n-            if writable {\n-                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n-            }\n-            uvll::set_stdio_container_flags(dst, flags);\n-            uvll::set_stdio_container_stream(dst,\n-                                             pipe.as_stream().native_handle());\n-        }\n-    }\n-}\n-\n-/// Converts the program and arguments to the argv array expected by libuv\n-fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n-    // First, allocation space to put all the C-strings (we need to have\n-    // ownership of them somewhere\n-    let mut c_strs = vec::with_capacity(args.len() + 1);\n-    c_strs.push(prog.to_c_str());\n-    for arg in args.iter() {\n-        c_strs.push(arg.to_c_str());\n-    }\n-\n-    // Next, create the char** array\n-    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n-    for s in c_strs.iter() {\n-        c_args.push(s.with_ref(|p| p));\n-    }\n-    c_args.push(ptr::null());\n-    c_args.as_imm_buf(|buf, _| f(buf))\n-}\n-\n-/// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n-    let env = match env {\n-        Some(s) => s,\n-        None => { return f(ptr::null()); }\n-    };\n-    // As with argv, create some temporary storage and then the actual array\n-    let mut envp = vec::with_capacity(env.len());\n-    for &(ref key, ref value) in env.iter() {\n-        envp.push(fmt!(\"%s=%s\", *key, *value).to_c_str());\n-    }\n-    let mut c_envp = vec::with_capacity(envp.len() + 1);\n-    for s in envp.iter() {\n-        c_envp.push(s.with_ref(|p| p));\n-    }\n-    c_envp.push(ptr::null());\n-    c_envp.as_imm_buf(|buf, _| f(buf))\n-}\n-\n-impl uv::NativeHandle<*uvll::uv_process_t> for Process {\n-    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n-        Process(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_process_t {\n-        match self { &Process(ptr) => ptr }\n-    }\n-}"}, {"sha": "eaa5e77a6da2fe71b3a67a11105dc5acee18c4f5", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -43,7 +43,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             (*cb)(watcher, status);\n         }\n     }"}, {"sha": "e620ab274b1ed238737f1a63625db5d935463caa", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 50, "deletions": 244, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -13,7 +13,7 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n-use libc::{c_int, c_uint, c_void, pid_t};\n+use libc::{c_int, c_uint, c_void};\n use ops::Drop;\n use option::*;\n use ptr;\n@@ -22,7 +22,6 @@ use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur, SeekEnd};\n-use rt::kill::BlockedTask;\n use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n@@ -149,7 +148,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n     };\n \n     if r != 0 {\n-        let status = status_to_maybe_uv_error(r);\n+        let status = status_to_maybe_uv_error(handle, r);\n         return Err(uv_error_to_io_error(status.unwrap()));\n     }\n \n@@ -592,63 +591,6 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n-\n-    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioPipeObject, IoError> {\n-        let home = get_handle_to_current_scheduler!();\n-        Ok(~UvPipeStream { pipe: Pipe::new(self.uv_loop(), ipc), home: home })\n-    }\n-\n-    fn spawn(&mut self,\n-             config: &process::Config) -> Result<~RtioProcessObject, IoError> {\n-        // Sadly, we must create the UvProcess before we actually call uv_spawn\n-        // so that the exit_cb can close over it and notify it when the process\n-        // has exited.\n-        let mut ret = ~UvProcess {\n-            process: Process::new(),\n-            home: None,\n-            exit_status: None,\n-            term_signal: None,\n-            exit_error: None,\n-            descheduled: None,\n-        };\n-        let ret_ptr = unsafe {\n-            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n-        };\n-\n-        // The purpose of this exit callback is to record the data about the\n-        // exit and then wake up the task which may be waiting for the process\n-        // to exit. This is all performed in the current io-loop, and the\n-        // implementation of UvProcess ensures that reading these fields always\n-        // occurs on the current io-loop.\n-        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n-            unsafe {\n-                assert!((*ret_ptr).exit_status.is_none());\n-                (*ret_ptr).exit_status = Some(exit_status);\n-                (*ret_ptr).term_signal = Some(term_signal);\n-                (*ret_ptr).exit_error = error;\n-                match (*ret_ptr).descheduled.take() {\n-                    Some(task) => {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        };\n-\n-        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n-            Ok(()) => {\n-                // Only now do we actually get a handle to this scheduler.\n-                ret.home = Some(get_handle_to_current_scheduler!());\n-                Ok(ret)\n-            }\n-            Err(uverr) => {\n-                // We still need to close the process handle we created, but\n-                // that's taken care for us in the destructor of UvProcess\n-                Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n }\n \n pub struct UvTcpListener {\n@@ -737,7 +679,7 @@ impl RtioTcpListener for UvTcpListener {\n                 uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -750,23 +692,48 @@ impl RtioTcpListener for UvTcpListener {\n                 uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n         }\n     }\n }\n \n-trait UvStream: HomingIO {\n-    fn as_stream(&mut self) -> StreamWatcher;\n+pub struct UvTcpStream {\n+    watcher: TcpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n-// FIXME(#3429) I would rather this be `impl<T: UvStream> RtioStream for T` but\n-//              that has conflicts with other traits that also have methods\n-//              called `read` and `write`\n-macro_rules! rtiostream(($t:ident) => {\n-impl RtioStream for $t {\n+impl Drop for UvTcpStream {\n+    fn drop(&self) {\n+        // XXX need mutable finalizer\n+        let this = unsafe { transmute::<&UvTcpStream, &mut UvTcpStream>(self) };\n+        do this.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioSocket for UvTcpStream {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n+    }\n+}\n+\n+impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         do self.home_for_io_with_sched |self_, scheduler| {\n             let result_cell = Cell::new_empty();\n@@ -780,7 +747,7 @@ impl RtioStream for $t {\n                 let alloc: AllocCallback = |_| unsafe {\n                     slice_to_uv_buf(*buf_ptr)\n                 };\n-                let mut watcher = self_.as_stream();\n+                let mut watcher = self_.watcher.as_stream();\n                 do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                     // Stop reading so that no read callbacks are\n@@ -816,7 +783,7 @@ impl RtioStream for $t {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let mut watcher = self_.as_stream();\n+                let mut watcher = self_.watcher.as_stream();\n                 do watcher.write(buf) |_watcher, status| {\n                     let result = if status.is_none() {\n                         Ok(())\n@@ -835,85 +802,7 @@ impl RtioStream for $t {\n             result_cell.take()\n         }\n     }\n-}\n-})\n-\n-rtiostream!(UvPipeStream)\n-rtiostream!(UvTcpStream)\n-\n-pub struct UvPipeStream {\n-    pipe: Pipe,\n-    home: SchedHandle,\n-}\n-\n-impl UvStream for UvPipeStream {\n-    fn as_stream(&mut self) -> StreamWatcher { self.pipe.as_stream() }\n-}\n-\n-impl HomingIO for UvPipeStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvPipeStream {\n-    fn drop(&self) {\n-        // FIXME(#4330): should not need a transmute\n-        let this = unsafe { cast::transmute_mut(self) };\n-        do this.home_for_io |self_| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.pipe.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl UvPipeStream {\n-    pub fn uv_pipe(&self) -> Pipe { self.pipe }\n-}\n \n-pub struct UvTcpStream {\n-    watcher: TcpWatcher,\n-    home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvTcpStream {\n-    fn drop(&self) {\n-        // FIXME(#4330): should not need a transmute\n-        let this = unsafe { cast::transmute_mut(self) };\n-        do this.home_for_io |self_| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl UvStream for UvTcpStream {\n-    fn as_stream(&mut self) -> StreamWatcher { self.watcher.as_stream() }\n-}\n-\n-impl RtioSocket for UvTcpStream {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n-    }\n-}\n-\n-impl RtioTcpStream for UvTcpStream {\n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n         do self.home_for_io |self_| {\n             socket_name(TcpPeer, self_.watcher)\n@@ -924,7 +813,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -935,7 +824,7 @@ impl RtioTcpStream for UvTcpStream {\n         do self.home_for_io |self_| {\n             let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -949,7 +838,7 @@ impl RtioTcpStream for UvTcpStream {\n                                     delay_in_seconds as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -962,7 +851,7 @@ impl RtioTcpStream for UvTcpStream {\n                 uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1074,7 +963,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1090,7 +979,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 }\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1104,7 +993,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1118,7 +1007,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1132,7 +1021,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1146,7 +1035,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1160,7 +1049,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1174,7 +1063,7 @@ impl RtioUdpSocket for UvUdpSocket {\n                 uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(r) {\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1361,89 +1250,6 @@ impl RtioFileStream for UvFileStream {\n     }\n }\n \n-pub struct UvProcess {\n-    process: process::Process,\n-\n-    // Sadly, this structure must be created before we return it, so in that\n-    // brief interim the `home` is None.\n-    home: Option<SchedHandle>,\n-\n-    // All None until the process exits (exit_error may stay None)\n-    priv exit_status: Option<int>,\n-    priv term_signal: Option<int>,\n-    priv exit_error: Option<UvError>,\n-\n-    // Used to store which task to wake up from the exit_cb\n-    priv descheduled: Option<BlockedTask>,\n-}\n-\n-impl HomingIO for UvProcess {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n-}\n-\n-impl Drop for UvProcess {\n-    fn drop(&self) {\n-        // FIXME(#4330): should not need a transmute\n-        let this = unsafe { cast::transmute_mut(self) };\n-\n-        let close = |self_: &mut UvProcess| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self_.process.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n-            }\n-        };\n-\n-        // If home is none, then this process never actually successfully\n-        // spawned, so there's no need to switch event loops\n-        if this.home.is_none() {\n-            close(this)\n-        } else {\n-            this.home_for_io(close)\n-        }\n-    }\n-}\n-\n-impl RtioProcess for UvProcess {\n-    fn id(&self) -> pid_t {\n-        self.process.pid()\n-    }\n-\n-    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.process.kill(signal) {\n-                Ok(()) => Ok(()),\n-                Err(uverr) => Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n-\n-    fn wait(&mut self) -> int {\n-        // Make sure (on the home scheduler) that we have an exit status listed\n-        do self.home_for_io |self_| {\n-            match self_.exit_status {\n-                Some(*) => {}\n-                None => {\n-                    // If there's no exit code previously listed, then the\n-                    // process's exit callback has yet to be invoked. We just\n-                    // need to deschedule ourselves and wait to be reawoken.\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        assert!(self_.descheduled.is_none());\n-                        self_.descheduled = Some(task);\n-                    }\n-                    assert!(self_.exit_status.is_some());\n-                }\n-            }\n-        }\n-\n-        self.exit_status.unwrap()\n-    }\n-}\n-\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {"}, {"sha": "1e189e90885501b981f635e81576b3f8ed77e95e", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 40, "deletions": 122, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -37,74 +37,28 @@ use libc::{malloc, free};\n use libc;\n use prelude::*;\n use ptr;\n+use str;\n use vec;\n \n-pub use self::errors::*;\n-\n+pub static UNKNOWN: c_int = -1;\n pub static OK: c_int = 0;\n-pub static EOF: c_int = -4095;\n-pub static UNKNOWN: c_int = -4094;\n-\n-// uv-errno.h redefines error codes for windows, but not for unix...\n-\n-#[cfg(windows)]\n-pub mod errors {\n-    use libc::c_int;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+pub static ECONNRESET: c_int = 13;\n+pub static EPIPE: c_int = 36;\n \n-    pub static EACCES: c_int = -4093;\n-    pub static ECONNREFUSED: c_int = -4079;\n-    pub static ECONNRESET: c_int = -4078;\n-    pub static EPIPE: c_int = -4048;\n+pub struct uv_err_t {\n+    code: c_int,\n+    sys_errno_: c_int\n }\n-#[cfg(not(windows))]\n-pub mod errors {\n-    use libc;\n-    use libc::c_int;\n-\n-    pub static EACCES: c_int = -libc::EACCES;\n-    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n-    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n-    pub static EPIPE: c_int = -libc::EPIPE;\n-}\n-\n-pub static PROCESS_SETUID: c_int = 1 << 0;\n-pub static PROCESS_SETGID: c_int = 1 << 1;\n-pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n-pub static PROCESS_DETACHED: c_int = 1 << 3;\n-pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n-\n-pub static STDIO_IGNORE: c_int = 0x00;\n-pub static STDIO_CREATE_PIPE: c_int = 0x01;\n-pub static STDIO_INHERIT_FD: c_int = 0x02;\n-pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n-pub static STDIO_READABLE_PIPE: c_int = 0x10;\n-pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n \n pub struct uv_buf_t {\n     base: *u8,\n     len: libc::size_t,\n }\n \n-pub struct uv_process_options_t {\n-    exit_cb: uv_exit_cb,\n-    file: *libc::c_char,\n-    args: **libc::c_char,\n-    env: **libc::c_char,\n-    cwd: *libc::c_char,\n-    flags: libc::c_uint,\n-    stdio_count: libc::c_int,\n-    stdio: *uv_stdio_container_t,\n-    uid: uv_uid_t,\n-    gid: uv_gid_t,\n-}\n-\n-// These fields are private because they must be interfaced with through the\n-// functions below.\n-pub struct uv_stdio_container_t {\n-    priv flags: libc::c_int,\n-    priv stream: *uv_stream_t,\n-}\n-\n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n@@ -118,8 +72,6 @@ pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n-pub type uv_process_t = c_void;\n-pub type uv_pipe_t = c_void;\n \n #[cfg(stage0)]\n pub type uv_idle_cb = *u8;\n@@ -145,8 +97,6 @@ pub type uv_connection_cb = *u8;\n pub type uv_timer_cb = *u8;\n #[cfg(stage0)]\n pub type uv_write_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_exit_cb = *u8;\n \n #[cfg(not(stage0))]\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n@@ -187,21 +137,12 @@ pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n #[cfg(not(stage0))]\n pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n                                      status: c_int);\n-#[cfg(not(stage0))]\n-pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n-                                    exit_status: c_int,\n-                                    term_signal: c_int);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n pub type sockaddr_storage = c_void;\n \n-#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n-#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n-#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n-#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n-\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -546,12 +487,20 @@ pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n     return rust_uv_read_stop(stream as *c_void);\n }\n \n-pub unsafe fn strerror(err: c_int) -> *c_char {\n+pub unsafe fn last_error(loop_handle: *c_void) -> uv_err_t {\n     #[fixed_stack_segment]; #[inline(never)];\n+\n+    return rust_uv_last_error(loop_handle);\n+}\n+\n+pub unsafe fn strerror(err: *uv_err_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_strerror(err);\n }\n-pub unsafe fn err_name(err: c_int) -> *c_char {\n+pub unsafe fn err_name(err: *uv_err_t) -> *c_char {\n     #[fixed_stack_segment]; #[inline(never)];\n+\n     return rust_uv_err_name(err);\n }\n \n@@ -705,45 +654,6 @@ pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n     rust_uv_fs_req_cleanup(req);\n }\n \n-pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n-                    options: uv_process_options_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_spawn(loop_ptr, result, options);\n-}\n-\n-pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_process_kill(p, signum);\n-}\n-\n-pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_process_pid(p);\n-}\n-\n-pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n-                                        flags: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_flags(c, flags);\n-}\n-\n-pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n-                                     fd: libc::c_int) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_fd(c, fd);\n-}\n-\n-pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                         stream: *uv_stream_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_set_stdio_container_stream(c, stream);\n-}\n-\n-pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_init(loop_ptr, p, ipc)\n-}\n-\n // data access helpers\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -810,6 +720,22 @@ pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n \n     return rust_uv_get_len_from_buf(buf);\n }\n+pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg);\n+}\n+\n+pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n+    let err = last_error(uv_loop);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n+    let err_name = str::raw::from_c_str(err_name(err_ptr));\n+    let err_msg = str::raw::from_c_str(strerror(err_ptr));\n+    uv_err_data { err_name: err_name, err_msg: err_msg }\n+}\n \n pub struct uv_err_data {\n     err_name: ~str,\n@@ -842,8 +768,9 @@ extern {\n                           cb: uv_async_cb) -> c_int;\n     fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n     fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_strerror(err: c_int) -> *c_char;\n-    fn rust_uv_err_name(err: c_int) -> *c_char;\n+    fn rust_uv_last_error(loop_handle: *c_void) -> uv_err_t;\n+    fn rust_uv_strerror(err: *uv_err_t) -> *c_char;\n+    fn rust_uv_err_name(err: *uv_err_t) -> *c_char;\n     fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n     fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n     fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n@@ -929,13 +856,4 @@ extern {\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n     fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n     fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n-    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n-                     options: uv_process_options_t) -> c_int;\n-    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n-    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n-    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n-    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n-    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                       stream: *uv_stream_t);\n-    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n }"}, {"sha": "7fc2deff97d8bd34538c1d3c4a236c05dcba0c03", "filename": "src/libstd/run.rs", "status": "modified", "additions": 891, "deletions": 208, "changes": 1099, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -10,21 +10,22 @@\n \n //! Process spawning.\n \n+#[allow(missing_doc)];\n+\n+use c_str::ToCStr;\n use cast;\n-use cell::Cell;\n+use clone::Clone;\n use comm::{stream, SharedChan, GenericChan, GenericPort};\n-#[cfg(not(windows))]\n+use io;\n+use libc::{pid_t, c_void, c_int};\n use libc;\n-use libc::{pid_t, c_int};\n+use option::{Some, None};\n+use os;\n use prelude::*;\n+use ptr;\n use task;\n use vec::ImmutableVector;\n \n-use rt::io;\n-use rt::local::Local;\n-use rt::rtio::{IoFactoryObject, RtioProcessObject, RtioProcess, IoFactory};\n-use rt::uv::process;\n-\n /**\n  * A value representing a child process.\n  *\n@@ -33,23 +34,28 @@ use rt::uv::process;\n  * for the process to terminate.\n  */\n pub struct Process {\n+\n     /// The unique id of the process (this should never be negative).\n     priv pid: pid_t,\n \n-    /// The internal handle to the underlying libuv process.\n-    priv handle: ~RtioProcessObject,\n+    /**\n+     * A handle to the process - on unix this will always be NULL, but on\n+     * windows it will be a HANDLE to the process, which will prevent the\n+     * pid being re-used until the handle is closed.\n+     */\n+    priv handle: *(),\n \n-    /// Some(fd), or None when stdin is being redirected from a fd not created\n-    /// by Process::new.\n-    priv input: Option<~io::Writer>,\n+    /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n+    priv input: Option<c_int>,\n \n-    /// Some(file), or None when stdout is being redirected to a fd not created\n-    /// by Process::new.\n-    priv output: Option<~io::Reader>,\n+    /// Some(file), or None when stdout is being redirected to a fd not created by Process::new.\n+    priv output: Option<*libc::FILE>,\n \n-    /// Some(file), or None when stderr is being redirected to a fd not created\n-    /// by Process::new.\n-    priv error: Option<~io::Reader>,\n+    /// Some(file), or None when stderr is being redirected to a fd not created by Process::new.\n+    priv error: Option<*libc::FILE>,\n+\n+    /// None until finish() is called.\n+    priv exit_code: Option<int>,\n }\n \n /// Options that can be given when starting a Process.\n@@ -87,27 +93,26 @@ pub struct ProcessOptions<'self> {\n      * If this is None then a new pipe will be created for the new program's\n      * output and Process.output() will provide a Reader to read from this pipe.\n      *\n-     * If this is Some(file-descriptor) then the new process will write its\n-     * output to the given file descriptor, Process.output_redirected() will\n-     * return true, and Process.output() will fail.\n+     * If this is Some(file-descriptor) then the new process will write its output\n+     * to the given file descriptor, Process.output_redirected() will return\n+     * true, and Process.output() will fail.\n      */\n     out_fd: Option<c_int>,\n \n     /**\n-     * If this is None then a new pipe will be created for the new progam's\n-     * error stream and Process.error() will provide a Reader to read from this\n-     * pipe.\n+     * If this is None then a new pipe will be created for the new program's\n+     * error stream and Process.error() will provide a Reader to read from this pipe.\n      *\n-     * If this is Some(file-descriptor) then the new process will write its\n-     * error output to the given file descriptor, Process.error_redirected()\n-     * will return true, and and Process.error() will fail.\n+     * If this is Some(file-descriptor) then the new process will write its error output\n+     * to the given file descriptor, Process.error_redirected() will return true, and\n+     * and Process.error() will fail.\n      */\n     err_fd: Option<c_int>,\n }\n \n-impl<'self> ProcessOptions<'self> {\n+impl <'self> ProcessOptions<'self> {\n     /// Return a ProcessOptions that has None in every field.\n-    pub fn new() -> ProcessOptions {\n+    pub fn new<'a>() -> ProcessOptions<'a> {\n         ProcessOptions {\n             env: None,\n             dir: None,\n@@ -120,6 +125,7 @@ impl<'self> ProcessOptions<'self> {\n \n /// The output of a finished process.\n pub struct ProcessOutput {\n+\n     /// The status (exit code) of the process.\n     status: int,\n \n@@ -142,159 +148,223 @@ impl Process {\n      *             the working directory and the standard IO streams.\n      */\n     pub fn new(prog: &str, args: &[~str],\n-               options: ProcessOptions) -> Option<Process> {\n-        // First, translate all the stdio options into their libuv equivalents\n-        let (uv_stdin, stdin) = match options.in_fd {\n-            Some(fd) => (process::InheritFd(fd), None),\n+               options: ProcessOptions)\n+               -> Process {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        let (in_pipe, in_fd) = match options.in_fd {\n             None => {\n-                let p = io::pipe::PipeStream::new().expect(\"need stdin pipe\");\n-                (process::CreatePipe(p.uv_pipe(), true, false),\n-                 Some(~p as ~io::Writer))\n-            }\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.input)\n+            },\n+            Some(fd) => (None, fd)\n         };\n-        let (uv_stdout, stdout) = match options.out_fd {\n-            Some(fd) => (process::InheritFd(fd), None),\n+        let (out_pipe, out_fd) = match options.out_fd {\n             None => {\n-                let p = io::pipe::PipeStream::new().expect(\"need stdout pipe\");\n-                (process::CreatePipe(p.uv_pipe(), false, true),\n-                 Some(~p as ~io::Reader))\n-            }\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n         };\n-        let (uv_stderr, stderr) = match options.err_fd {\n-            Some(fd) => (process::InheritFd(fd), None),\n+        let (err_pipe, err_fd) = match options.err_fd {\n             None => {\n-                let p = io::pipe::PipeStream::new().expect(\"need stderr pipe\");\n-                (process::CreatePipe(p.uv_pipe(), false, true),\n-                 Some(~p as ~io::Reader))\n-            }\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n         };\n \n-        // Next, massage our options into the libuv options\n-        let dir = options.dir.map(|d| d.to_str());\n-        let dir = dir.map(|d| d.as_slice());\n-        let config = process::Config {\n-            program: prog,\n-            args: args,\n-            env: options.env.map(|e| e.as_slice()),\n-            cwd: dir,\n-            io: [uv_stdin, uv_stdout, uv_stderr],\n-        };\n+        let res = spawn_process_os(prog, args, options.env.clone(), options.dir,\n+                                   in_fd, out_fd, err_fd);\n \n-        // Finally, actually spawn the process\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            match (*io).spawn(&config) {\n-                Ok(handle) => {\n-                    Some(Process {\n-                        pid: handle.id(),\n-                        handle: handle,\n-                        input: stdin,\n-                        output: stdout,\n-                        error: stderr,\n-                    })\n-                }\n-                Err(*) => { None }\n-            }\n+            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n+        }\n+\n+        Process {\n+            pid: res.pid,\n+            handle: res.handle,\n+            input: in_pipe.map(|pipe| pipe.out),\n+            output: out_pipe.map(|pipe| os::fdopen(pipe.input)),\n+            error: err_pipe.map(|pipe| os::fdopen(pipe.input)),\n+            exit_code: None,\n         }\n     }\n \n     /// Returns the unique id of the process\n     pub fn get_id(&self) -> pid_t { self.pid }\n \n+    fn input_fd(&mut self) -> c_int {\n+        match self.input {\n+            Some(fd) => fd,\n+            None => fail!(\"This Process's stdin was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n+\n+    fn output_file(&mut self) -> *libc::FILE {\n+        match self.output {\n+            Some(file) => file,\n+            None => fail!(\"This Process's stdout was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n+\n+    fn error_file(&mut self) -> *libc::FILE {\n+        match self.error {\n+            Some(file) => file,\n+            None => fail!(\"This Process's stderr was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n+\n     /**\n-     * Returns a rt::io::Writer that can be used to write to this Process's\n-     * stdin.\n+     * Returns whether this process is reading its stdin from an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n      *\n-     * Fails if this Process's stdin was redirected to an existing file\n-     * descriptor.\n+     * If this method returns true then self.input() will fail.\n      */\n-    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n-        let ret: &mut io::Writer = *self.input.get_mut_ref();\n-        return ret;\n+    pub fn input_redirected(&self) -> bool {\n+        self.input.is_none()\n     }\n \n     /**\n-     * Returns a rt::io::Reader that can be used to read from this Process's\n-     * stdout.\n+     * Returns whether this process is writing its stdout to an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n      *\n-     * Fails if this Process's stdout was redirected to an existing file\n-     * descriptor.\n+     * If this method returns true then self.output() will fail.\n      */\n-    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n-        let ret: &mut io::Reader = *self.output.get_mut_ref();\n-        return ret;\n+    pub fn output_redirected(&self) -> bool {\n+        self.output.is_none()\n     }\n \n     /**\n-     * Returns a rt::io::Reader that can be used to read from this Process's\n-     * stderr.\n+     * Returns whether this process is writing its stderr to an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n      *\n-     * Fails if this Process's stderr was redirected to an existing file\n-     * descriptor.\n+     * If this method returns true then self.error() will fail.\n      */\n-    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n-        let ret: &mut io::Reader = *self.error.get_mut_ref();\n-        return ret;\n+    pub fn error_redirected(&self) -> bool {\n+        self.error.is_none()\n     }\n \n     /**\n-     * Closes the handle to stdin, waits for the child process to terminate, and\n-     * returns the exit code.\n+     * Returns an io::Writer that can be used to write to this Process's stdin.\n      *\n-     * If the child has already been finished then the exit code is returned.\n+     * Fails if this Process's stdin was redirected to an existing file descriptor.\n      */\n-    pub fn finish(&mut self) -> int {\n-        // We're not going to be giving any more input, so close the input by\n-        // destroying it. Also, if the output is desired, then\n-        // finish_with_output is called so we discard all the outputs here. Note\n-        // that the process may not terminate if we don't destroy stdio because\n-        // it'll be waiting in a write which we'll just never read.\n-        self.input.take();\n-        self.output.take();\n-        self.error.take();\n+    pub fn input(&mut self) -> @io::Writer {\n+        // FIXME: the Writer can still be used after self is destroyed: #2625\n+       io::fd_writer(self.input_fd(), false)\n+    }\n \n-        self.handle.wait()\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's stdout.\n+     *\n+     * Fails if this Process's stdout was redirected to an existing file descriptor.\n+     */\n+    pub fn output(&mut self) -> @io::Reader {\n+        // FIXME: the Reader can still be used after self is destroyed: #2625\n+        io::FILE_reader(self.output_file(), false)\n     }\n \n     /**\n-     * Closes the handle to stdin, waits for the child process to terminate,\n-     * and reads and returns all remaining output of stdout and stderr, along\n-     * with the exit code.\n+     * Returns an io::Reader that can be used to read from this Process's stderr.\n      *\n-     * If the child has already been finished then the exit code and any\n-     * remaining unread output of stdout and stderr will be returned.\n+     * Fails if this Process's stderr was redirected to an existing file descriptor.\n+     */\n+    pub fn error(&mut self) -> @io::Reader {\n+        // FIXME: the Reader can still be used after self is destroyed: #2625\n+        io::FILE_reader(self.error_file(), false)\n+    }\n+\n+    /**\n+     * Closes the handle to the child process's stdin.\n      *\n-     * This method will fail if the child process's stdout or stderr streams\n-     * were redirected to existing file descriptors, or if this method has\n-     * already been called.\n+     * If this process is reading its stdin from an existing file descriptor, then this\n+     * method does nothing.\n      */\n-    pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        // This should probably be a helper method in rt::io\n-        fn read_everything(input: &mut io::Reader) -> ~[u8] {\n-            let mut result = ~[];\n-            let mut buf = [0u8, ..1024];\n-            loop {\n-                match input.read(buf) {\n-                    Some(i) => { result = result + buf.slice_to(i) }\n-                    None => break\n+    pub fn close_input(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        match self.input {\n+            Some(-1) | None => (),\n+            Some(fd) => {\n+                unsafe {\n+                    libc::close(fd);\n                 }\n+                self.input = Some(-1);\n             }\n-            return result;\n         }\n+    }\n+\n+    fn close_outputs(&mut self) {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        fclose_and_null(&mut self.output);\n+        fclose_and_null(&mut self.error);\n+\n+        fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n+            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n+            match *f_opt {\n+                Some(f) if !f.is_null() => {\n+                    unsafe {\n+                        libc::fclose(f);\n+                        *f_opt = Some(0 as *libc::FILE);\n+                    }\n+                },\n+                _ => ()\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes the handle to stdin, waits for the child process to terminate,\n+     * and returns the exit code.\n+     *\n+     * If the child has already been finished then the exit code is returned.\n+     */\n+    pub fn finish(&mut self) -> int {\n+        for &code in self.exit_code.iter() {\n+            return code;\n+        }\n+        self.close_input();\n+        let code = waitpid(self.pid);\n+        self.exit_code = Some(code);\n+        return code;\n+    }\n \n+    /**\n+     * Closes the handle to stdin, waits for the child process to terminate, and reads\n+     * and returns all remaining output of stdout and stderr, along with the exit code.\n+     *\n+     * If the child has already been finished then the exit code and any remaining\n+     * unread output of stdout and stderr will be returned.\n+     *\n+     * This method will fail if the child process's stdout or stderr streams were\n+     * redirected to existing file descriptors.\n+     */\n+    pub fn finish_with_output(&mut self) -> ProcessOutput {\n+        let output_file = self.output_file();\n+        let error_file = self.error_file();\n+\n+        // Spawn two entire schedulers to read both stdout and sterr\n+        // in parallel so we don't deadlock while blocking on one\n+        // or the other. FIXME (#2625): Surely there's a much more\n+        // clever way to do this.\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n-\n-        let stderr = Cell::new(self.error.take().unwrap());\n-        do task::spawn {\n-            let output = read_everything(stderr.take());\n-            ch.send((2, output));\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let errput = io::FILE_reader(error_file, false);\n+            ch.send((2, errput.read_whole_stream()));\n         }\n-        let stdout = Cell::new(self.output.take().unwrap());\n-        do task::spawn {\n-            let output = read_everything(stdout.take());\n-            ch_clone.send((1, output));\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let output = io::FILE_reader(output_file, false);\n+            ch_clone.send((1, output.read_whole_stream()));\n         }\n \n         let status = self.finish();\n@@ -312,19 +382,48 @@ impl Process {\n                               error: errs};\n     }\n \n+    fn destroy_internal(&mut self, force: bool) {\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        if self.exit_code.is_none() {\n+            killpid(self.pid, force);\n+            self.finish();\n+        }\n+\n+        #[cfg(windows)]\n+        fn killpid(pid: pid_t, _force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                libc::funcs::extra::kernel32::TerminateProcess(\n+                    cast::transmute(pid), 1);\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn killpid(pid: pid_t, force: bool) {\n+            #[fixed_stack_segment]; #[inline(never)];\n+\n+            let signal = if force {\n+                libc::consts::os::posix88::SIGKILL\n+            } else {\n+                libc::consts::os::posix88::SIGTERM\n+            };\n+\n+            unsafe {\n+                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            }\n+        }\n+    }\n+\n     /**\n      * Terminates the process, giving it a chance to clean itself up if\n      * this is supported by the operating system.\n      *\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) {\n-        #[cfg(windows)]      fn sigterm() -> int { 15 }\n-        #[cfg(not(windows))] fn sigterm() -> int { libc::SIGTERM as int }\n-        self.handle.kill(sigterm());\n-        self.finish();\n-    }\n+    pub fn destroy(&mut self) { self.destroy_internal(false); }\n \n     /**\n      * Terminates the process as soon as possible without giving it a\n@@ -333,22 +432,378 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) {\n-        #[cfg(windows)]      fn sigkill() -> int { 9 }\n-        #[cfg(not(windows))] fn sigkill() -> int { libc::SIGKILL as int }\n-        self.handle.kill(sigkill());\n-        self.finish();\n-    }\n+    pub fn force_destroy(&mut self) { self.destroy_internal(true); }\n }\n \n impl Drop for Process {\n     fn drop(&self) {\n         // FIXME(#4330) Need self by value to get mutability.\n         let mut_self: &mut Process = unsafe { cast::transmute(self) };\n+\n         mut_self.finish();\n+        mut_self.close_outputs();\n+        free_handle(self.handle);\n+    }\n+}\n+\n+struct SpawnProcessResult {\n+    pid: pid_t,\n+    handle: *(),\n+}\n+\n+#[cfg(windows)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use libc::consts::os::extra::{\n+        TRUE, FALSE,\n+        STARTF_USESTDHANDLES,\n+        INVALID_HANDLE_VALUE,\n+        DUPLICATE_SAME_ACCESS\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        GetCurrentProcess,\n+        DuplicateHandle,\n+        CloseHandle,\n+        CreateProcessA\n+    };\n+    use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+    use sys;\n+\n+    unsafe {\n+\n+        let mut si = zeroed_startupinfo();\n+        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n+\n+        let cur_proc = GetCurrentProcess();\n+\n+        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n+        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+        }\n+\n+        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n+        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+        }\n+\n+        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n+        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n+            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+        }\n+        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n+                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+        }\n+\n+        let cmd = make_command_line(prog, args);\n+        let mut pi = zeroed_process_information();\n+        let mut create_err = None;\n+\n+        do with_envp(env) |envp| {\n+            do with_dirp(dir) |dirp| {\n+                do cmd.with_c_str |cmdp| {\n+                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n+                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n+                                                 0, envp, dirp, &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(os::last_os_error());\n+                    }\n+                }\n+            }\n+        }\n+\n+        CloseHandle(si.hStdInput);\n+        CloseHandle(si.hStdOutput);\n+        CloseHandle(si.hStdError);\n+\n+        for msg in create_err.iter() {\n+            fail!(\"failure in CreateProcess: %s\", *msg);\n+        }\n+\n+        // We close the thread handle because we don't care about keeping the thread id valid,\n+        // and we aren't keeping the thread handle around to be able to close it later. We don't\n+        // close the process handle however because we want the process id to stay valid at least\n+        // until the calling code closes the process handle.\n+        CloseHandle(pi.hThread);\n+\n+        SpawnProcessResult {\n+            pid: pi.dwProcessId as pid_t,\n+            handle: pi.hProcess as *()\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::mut_null(),\n+        lpDesktop: ptr::mut_null(),\n+        lpTitle: ptr::mut_null(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::mut_null(),\n+        hStdInput: ptr::mut_null(),\n+        hStdOutput: ptr::mut_null(),\n+        hStdError: ptr::mut_null()\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::mut_null(),\n+        hThread: ptr::mut_null(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// FIXME: this is only pub so it can be tested (see issue #4536)\n+#[cfg(windows)]\n+pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n+    let mut cmd = ~\"\";\n+    append_arg(&mut cmd, prog);\n+    for arg in args.iter() {\n+        cmd.push_char(' ');\n+        append_arg(&mut cmd, *arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut ~str, arg: &str) {\n+        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+        for i in range(0u, arg.len()) {\n+            append_char_at(cmd, arg, i);\n+        }\n+        if quote {\n+            cmd.push_char('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+        match arg[i] as char {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push_char('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push_char(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n+        while i < s.len() && s[i] as char == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] as char == '\"';\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<~[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use libc::funcs::bsd44::getdtablesize;\n+\n+    mod rustrt {\n+        use libc::c_void;\n+\n+        #[abi = \"cdecl\"]\n+        extern {\n+            pub fn rust_unset_sigprocmask();\n+            pub fn rust_set_environ(envp: *c_void);\n+        }\n+    }\n+\n+    unsafe {\n+\n+        let pid = fork();\n+        if pid < 0 {\n+            fail!(\"failure in fork: %s\", os::last_os_error());\n+        } else if pid > 0 {\n+            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n+        }\n+\n+        rustrt::rust_unset_sigprocmask();\n+\n+        if dup2(in_fd, 0) == -1 {\n+            fail!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error());\n+        }\n+        if dup2(out_fd, 1) == -1 {\n+            fail!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error());\n+        }\n+        if dup2(err_fd, 2) == -1 {\n+            fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n+        }\n+        // close all other fds\n+        for fd in range(3, getdtablesize()).invert() {\n+            close(fd as c_int);\n+        }\n+\n+        do with_dirp(dir) |dirp| {\n+            if !dirp.is_null() && chdir(dirp) == -1 {\n+                fail!(\"failure in chdir: %s\", os::last_os_error());\n+            }\n+        }\n+\n+        do with_envp(env) |envp| {\n+            if !envp.is_null() {\n+                rustrt::rust_set_environ(envp);\n+            }\n+            do with_argv(prog, args) |argv| {\n+                execvp(*argv, argv);\n+                // execvp only returns if an error occurred\n+                fail!(\"failure in execvp: %s\", os::last_os_error());\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+    use vec;\n+\n+    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n+    // a reference to the intermediary byte buffers. So first build an array to\n+    // hold all the ~[u8] byte strings.\n+    let mut tmps = vec::with_capacity(args.len() + 1);\n+\n+    tmps.push(prog.to_c_str());\n+\n+    for arg in args.iter() {\n+        tmps.push(arg.to_c_str());\n+    }\n+\n+    // Next, convert each of the byte strings into a pointer. This is\n+    // technically unsafe as the caller could leak these pointers out of our\n+    // scope.\n+    let mut ptrs = do tmps.map |tmp| {\n+        tmp.with_ref(|buf| buf)\n+    };\n+\n+    // Finally, make sure we add a null pointer.\n+    ptrs.push(ptr::null());\n+\n+    ptrs.as_imm_buf(|buf, _| cb(buf))\n+}\n+\n+#[cfg(unix)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n+    use vec;\n+\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n+    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                // Use of match here is just to workaround limitations\n+                // in the stage0 irrefutable pattern impl.\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                tmps.push(kv.to_c_str());\n+            }\n+\n+            // Once again, this is unsafe.\n+            let mut ptrs = do tmps.map |tmp| {\n+                tmp.with_ref(|buf| buf)\n+            };\n+            ptrs.push(ptr::null());\n+\n+            do ptrs.as_imm_buf |buf, _| {\n+                unsafe { cb(cast::transmute(buf)) }\n+            }\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n+    // On win32 we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = ~[];\n+\n+            for pair in env.iter() {\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                blk.push_all(kv.as_bytes());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            do blk.as_imm_buf |p, _len| {\n+                unsafe { cb(cast::transmute(p)) }\n+            }\n+        }\n+        _ => cb(ptr::mut_null())\n+    }\n+}\n+\n+fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n+    match d {\n+      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn free_handle(handle: *()) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe {\n+        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n }\n \n+#[cfg(unix)]\n+fn free_handle(_handle: *()) {\n+    // unix has no process handle object, just a pid\n+}\n+\n /**\n  * Spawns a process and waits for it to terminate. The process will\n  * inherit the current stdin/stdout/stderr file descriptors.\n@@ -369,7 +824,7 @@ pub fn process_status(prog: &str, args: &[~str]) -> int {\n         in_fd: Some(0),\n         out_fd: Some(1),\n         err_fd: Some(2)\n-    }).unwrap();\n+    });\n     prog.finish()\n }\n \n@@ -386,38 +841,162 @@ pub fn process_status(prog: &str, args: &[~str]) -> int {\n  * The process's stdout/stderr output and exit code.\n  */\n pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n-    let mut prog = Process::new(prog, args, ProcessOptions::new()).unwrap();\n+    let mut prog = Process::new(prog, args, ProcessOptions::new());\n     prog.finish_with_output()\n }\n \n+/**\n+ * Waits for a process to exit and returns the exit code, failing\n+ * if there is no process with the specified id.\n+ *\n+ * Note that this is private to avoid race conditions on unix where if\n+ * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+ * and some_process.destroy() and some_process.finalize() will then either\n+ * operate on a none-existent process or, even worse, on a newer process\n+ * with the same id.\n+ */\n+fn waitpid(pid: pid_t) -> int {\n+    return waitpid_os(pid);\n+\n+    #[cfg(windows)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_FAILED\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject\n+        };\n+\n+        unsafe {\n+\n+            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+            if proc.is_null() {\n+                fail!(\"failure in OpenProcess: %s\", os::last_os_error());\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(proc, &mut status) == FALSE {\n+                    CloseHandle(proc);\n+                    fail!(\"failure in GetExitCodeProcess: %s\", os::last_os_error());\n+                }\n+                if status != STILL_ACTIVE {\n+                    CloseHandle(proc);\n+                    return status as int;\n+                }\n+                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n+                    CloseHandle(proc);\n+                    fail!(\"failure in WaitForSingleObject: %s\", os::last_os_error());\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    fn waitpid_os(pid: pid_t) -> int {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        use libc::funcs::posix01::wait::*;\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0xffi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0x7fi32) == 0i32\n+        }\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            (status >> 8i32) & 0xffi32\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            status >> 8i32\n+        }\n+\n+        let mut status = 0 as c_int;\n+        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+            fail!(\"failure in waitpid: %s\", os::last_os_error());\n+        }\n+\n+        return if WIFEXITED(status) {\n+            WEXITSTATUS(status) as int\n+        } else {\n+            1\n+        };\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use io;\n+    use libc::c_int;\n+    use option::{Option, None, Some};\n     use os;\n     use path::Path;\n-    use prelude::*;\n+    use run;\n     use str;\n-    use super::*;\n     use unstable::running_on_valgrind;\n \n+    #[test]\n+    #[cfg(windows)]\n+    fn test_make_command_line() {\n+        assert_eq!(\n+            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n+            ~\"prog aaa bbb ccc\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n+            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            run::make_command_line(\"echo\", [~\"a b c\"]),\n+            ~\"echo \\\"a b c\\\"\"\n+        );\n+    }\n+\n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_status() {\n-        assert_eq!(process_status(\"false\", []), 1);\n-        assert_eq!(process_status(\"true\", []), 0);\n+        assert_eq!(run::process_status(\"false\", []), 1);\n+        assert_eq!(run::process_status(\"true\", []), 0);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_process_status() {\n-        assert_eq!(process_status(\"/system/bin/sh\", [~\"-c\",~\"false\"]), 1);\n-        assert_eq!(process_status(\"/system/bin/sh\", [~\"-c\",~\"true\"]), 0);\n+        assert_eq!(run::process_status(\"/system/bin/sh\", [~\"-c\",~\"false\"]), 1);\n+        assert_eq!(run::process_status(\"/system/bin/sh\", [~\"-c\",~\"true\"]), 0);\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_output_output() {\n \n-        let ProcessOutput {status, output, error}\n-             = process_output(\"echo\", [~\"hello\"]);\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"echo\", [~\"hello\"]);\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -431,8 +1010,8 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_process_output_output() {\n \n-        let ProcessOutput {status, output, error}\n-             = process_output(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"]);\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"]);\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -447,8 +1026,8 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_output_error() {\n \n-        let ProcessOutput {status, output, error}\n-             = process_output(\"mkdir\", [~\".\"]);\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"mkdir\", [~\".\"]);\n \n         assert_eq!(status, 1);\n         assert_eq!(output, ~[]);\n@@ -458,40 +1037,90 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_process_output_error() {\n \n-        let ProcessOutput {status, output, error}\n-             = process_output(\"/system/bin/mkdir\", [~\".\"]);\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"/system/bin/mkdir\", [~\".\"]);\n \n         assert_eq!(status, 255);\n         assert_eq!(output, ~[]);\n         assert!(!error.is_empty());\n     }\n \n+    #[test]\n+    fn test_pipes() {\n+\n+        let pipe_in = os::pipe();\n+        let pipe_out = os::pipe();\n+        let pipe_err = os::pipe();\n+\n+        let mut proc = run::Process::new(\"cat\", [], run::ProcessOptions {\n+            dir: None,\n+            env: None,\n+            in_fd: Some(pipe_in.input),\n+            out_fd: Some(pipe_out.out),\n+            err_fd: Some(pipe_err.out)\n+        });\n+\n+        assert!(proc.input_redirected());\n+        assert!(proc.output_redirected());\n+        assert!(proc.error_redirected());\n+\n+        os::close(pipe_in.input);\n+        os::close(pipe_out.out);\n+        os::close(pipe_err.out);\n+\n+        let expected = ~\"test\";\n+        writeclose(pipe_in.out, expected);\n+        let actual = readclose(pipe_out.input);\n+        readclose(pipe_err.input);\n+        proc.finish();\n+\n+        assert_eq!(expected, actual);\n+    }\n+\n+    fn writeclose(fd: c_int, s: &str) {\n+        let writer = io::fd_writer(fd, false);\n+        writer.write_str(s);\n+        os::close(fd);\n+    }\n+\n+    fn readclose(fd: c_int) -> ~str {\n+        #[fixed_stack_segment]; #[inline(never)];\n+\n+        unsafe {\n+            let file = os::fdopen(fd);\n+            let reader = io::FILE_reader(file, false);\n+            let buf = reader.read_whole_stream();\n+            os::fclose(file);\n+            str::from_bytes(buf)\n+        }\n+    }\n+\n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_once() {\n-        let mut prog = Process::new(\"false\", [], ProcessOptions::new()).unwrap();\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n         assert_eq!(prog.finish(), 1);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_finish_once() {\n-        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n-                                    ProcessOptions::new()).unwrap();\n+        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n+                                         run::ProcessOptions::new());\n         assert_eq!(prog.finish(), 1);\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_twice() {\n-        let mut prog = Process::new(\"false\", [], ProcessOptions::new()).unwrap();\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n         assert_eq!(prog.finish(), 1);\n         assert_eq!(prog.finish(), 1);\n     }\n     #[test]\n     #[cfg(target_os=\"android\")]\n     fn test_finish_twice() {\n-        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n-                                    ProcessOptions::new()).unwrap();\n+        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"false\"],\n+                                         run::ProcessOptions::new());\n         assert_eq!(prog.finish(), 1);\n         assert_eq!(prog.finish(), 1);\n     }\n@@ -500,9 +1129,8 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     fn test_finish_with_output_once() {\n \n-        let prog = Process::new(\"echo\", [~\"hello\"], ProcessOptions::new());\n-        let mut prog = prog.unwrap();\n-        let ProcessOutput {status, output, error}\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n         let output_str = str::from_bytes(output);\n \n@@ -517,10 +1145,28 @@ mod tests {\n     #[cfg(target_os=\"android\")]\n     fn test_finish_with_output_once() {\n \n-        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                    ProcessOptions::new()).unwrap();\n-        let ProcessOutput {status, output, error}\n+        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n+                                         run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+        let output_str = str::from_bytes(output);\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(not(target_os=\"android\"))]\n+    fn test_finish_with_output_twice() {\n+\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n+\n         let output_str = str::from_bytes(output);\n \n         assert_eq!(status, 0);\n@@ -529,61 +1175,97 @@ mod tests {\n         if !running_on_valgrind() {\n             assert_eq!(error, ~[]);\n         }\n+\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+    }\n+    #[test]\n+    #[cfg(target_os=\"android\")]\n+    fn test_finish_with_output_twice() {\n+\n+        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n+                                         run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+\n+        let output_str = str::from_bytes(output);\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n     }\n \n     #[test]\n     #[should_fail]\n     #[cfg(not(windows),not(target_os=\"android\"))]\n     fn test_finish_with_output_redirected() {\n-        let mut prog = Process::new(\"echo\", [~\"hello\"], ProcessOptions {\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions {\n             env: None,\n             dir: None,\n             in_fd: Some(0),\n             out_fd: Some(1),\n             err_fd: Some(2)\n-        }).unwrap();\n-        // this should fail because it is not valid to read the output when it\n-        // was redirected\n+        });\n+        // this should fail because it is not valid to read the output when it was redirected\n         prog.finish_with_output();\n     }\n     #[test]\n     #[should_fail]\n     #[cfg(not(windows),target_os=\"android\")]\n     fn test_finish_with_output_redirected() {\n-        let mut prog = Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                    ProcessOptions {\n+        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n+                                         run::ProcessOptions {\n             env: None,\n             dir: None,\n             in_fd: Some(0),\n             out_fd: Some(1),\n             err_fd: Some(2)\n-        }).unwrap();\n-        // this should fail because it is not valid to read the output when it\n-        // was redirected\n+        });\n+        // this should fail because it is not valid to read the output when it was redirected\n         prog.finish_with_output();\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::new(\"pwd\", [], ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> run::Process {\n+        run::Process::new(\"pwd\", [], run::ProcessOptions {\n             dir: dir,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n     #[cfg(unix,target_os=\"android\")]\n-    fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> run::Process {\n+        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n             dir: dir,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n \n     #[cfg(windows)]\n-    fn run_pwd(dir: Option<&Path>) -> Process {\n-        Process::new(\"cmd\", [~\"/c\", ~\"cd\"], ProcessOptions {\n+    fn run_pwd(dir: Option<&Path>) -> run::Process {\n+        run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n             dir: dir,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n \n     #[test]\n@@ -619,26 +1301,26 @@ mod tests {\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::new(\"env\", [], ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n+        run::Process::new(\"env\", [], run::ProcessOptions {\n             env: env,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n     #[cfg(unix,target_os=\"android\")]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n+        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n             env: env,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n \n     #[cfg(windows)]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n-        Process::new(\"cmd\", [~\"/c\", ~\"set\"], ProcessOptions {\n+    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n+        run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n             env: env,\n-            .. ProcessOptions::new()\n-        }).unwrap()\n+            .. run::ProcessOptions::new()\n+        })\n     }\n \n     #[test]\n@@ -675,6 +1357,7 @@ mod tests {\n \n     #[test]\n     fn test_add_to_env() {\n+\n         let mut new_env = os::env();\n         new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n "}, {"sha": "dfae9c3e958dc086d9c0ab068cd76d196c95a433", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -1 +1 @@\n-Subproject commit d88cf5652a1afb23939da0bae86c70ec521b9921\n+Subproject commit dfae9c3e958dc086d9c0ab068cd76d196c95a433"}, {"sha": "8ef4572f8108f0170b577359475da5cde9fbad4b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -329,13 +329,20 @@ rust_uv_get_len_from_buf(uv_buf_t buf) {\n     return buf.len;\n }\n \n+extern \"C\" uv_err_t\n+rust_uv_last_error(uv_loop_t* loop) {\n+    return uv_last_error(loop);\n+}\n+\n extern \"C\" const char*\n-rust_uv_strerror(int err) {\n+rust_uv_strerror(uv_err_t* err_ptr) {\n+    uv_err_t err = *err_ptr;\n     return uv_strerror(err);\n }\n \n extern \"C\" const char*\n-rust_uv_err_name(int err) {\n+rust_uv_err_name(uv_err_t* err_ptr) {\n+    uv_err_t err = *err_ptr;\n     return uv_err_name(err);\n }\n \n@@ -546,37 +553,3 @@ extern \"C\" uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n }\n-extern \"C\" int\n-rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {\n-  return uv_spawn(loop, p, options);\n-}\n-\n-extern \"C\" int\n-rust_uv_process_kill(uv_process_t *p, int signum) {\n-  return uv_process_kill(p, signum);\n-}\n-\n-extern \"C\" void\n-rust_set_stdio_container_flags(uv_stdio_container_t *c, int flags) {\n-  c->flags = (uv_stdio_flags) flags;\n-}\n-\n-extern \"C\" void\n-rust_set_stdio_container_fd(uv_stdio_container_t *c, int fd) {\n-  c->data.fd = fd;\n-}\n-\n-extern \"C\" void\n-rust_set_stdio_container_stream(uv_stdio_container_t *c, uv_stream_t *stream) {\n-  c->data.stream = stream;\n-}\n-\n-extern \"C\" int\n-rust_uv_process_pid(uv_process_t* p) {\n-  return p->pid;\n-}\n-\n-extern \"C\" int\n-rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n-  return uv_pipe_init(loop, p, ipc);\n-}"}, {"sha": "b668d3944066252084add406d8c8043e66f6e0e8", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -47,6 +47,7 @@ rust_uv_timer_start\n rust_uv_timer_stop\n rust_uv_tcp_init\n rust_uv_buf_init\n+rust_uv_last_error\n rust_uv_strerror\n rust_uv_err_name\n rust_uv_ip4_addr\n@@ -190,11 +191,4 @@ rust_drop_global_args_lock\n rust_take_change_dir_lock\n rust_drop_change_dir_lock\n rust_get_test_int\n-rust_get_task\n-rust_uv_spawn\n-rust_uv_process_kill\n-rust_set_stdio_container_flags\n-rust_set_stdio_container_fd\n-rust_set_stdio_container_stream\n-rust_uv_process_pid\n-rust_uv_pipe_init\n+rust_get_task\n\\ No newline at end of file"}, {"sha": "2551d1a5cfcba32455e421de89a3cae23a37c9b8", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=3c5a43e5b6f857c71c6f66dbbd640a47d34a0e7e", "patch": "@@ -22,15 +22,13 @@ use std::str;\n \n #[test]\n fn test_destroy_once() {\n-    let p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n-    let mut p = p.unwrap();\n+    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n     p.destroy(); // this shouldn't crash (and nor should the destructor)\n }\n \n #[test]\n fn test_destroy_twice() {\n-    let p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n-    let mut p = p.unwrap();\n+    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n     p.destroy(); // this shouldnt crash...\n     p.destroy(); // ...and nor should this (and nor should the destructor)\n }\n@@ -76,8 +74,7 @@ fn test_destroy_actually_kills(force: bool) {\n     }\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n-    let mut p = p.unwrap();\n+    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n \n     assert!(process_exists(p.get_id()));\n "}]}