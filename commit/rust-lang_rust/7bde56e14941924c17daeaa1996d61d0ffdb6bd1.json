{"sha": "7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZGU1NmUxNDk0MTkyNGMxN2RhZWFhMTk5NmQ2MWQwZmZkYjZiZDE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2015-12-16T17:44:15Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-10T11:50:12Z"}, "message": "typestrong constant integers", "tree": {"sha": "e7690e75421bb80a98fe6f2e8968680f0fca8914", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7690e75421bb80a98fe6f2e8968680f0fca8914"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "html_url": "https://github.com/rust-lang/rust/commit/7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ac4076ac0e4276dce59cd254dfa2c5cf848dca8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac4076ac0e4276dce59cd254dfa2c5cf848dca8", "html_url": "https://github.com/rust-lang/rust/commit/3ac4076ac0e4276dce59cd254dfa2c5cf848dca8"}], "stats": {"total": 2531, "additions": 1614, "deletions": 917}, "files": [{"sha": "c4ab068f39be693ebf6d319a1994b4fd47301969", "filename": "mk/crates.mk", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -53,7 +53,7 @@ TARGET_CRATES := libc std term \\\n                  getopts collections test rand \\\n                  core alloc \\\n                  rustc_unicode rustc_bitflags \\\n-\t\t alloc_system alloc_jemalloc\n+\t\t alloc_system alloc_jemalloc rustc_const_eval\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_front rustc_platform_intrinsics \\\n@@ -91,8 +91,11 @@ DEPS_test := std getopts term native:rust_test_helpers\n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode\n DEPS_syntax_ext := syntax fmt_macros\n \n+DEPS_rustc_const_eval := std syntax\n+\n DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml rustc_front\\\n-              log graphviz rustc_llvm rustc_back rustc_data_structures\n+              log graphviz rustc_llvm rustc_back rustc_data_structures\\\n+\t\t  \t  rustc_const_eval\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n DEPS_rustc_data_structures := std log serialize\n@@ -103,16 +106,17 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_metadata := rustc rustc_front syntax rbml\n+DEPS_rustc_metadata := rustc rustc_front syntax rbml rustc_const_eval\n DEPS_rustc_passes := syntax rustc core rustc_front\n-DEPS_rustc_mir := rustc rustc_front syntax\n+DEPS_rustc_mir := rustc rustc_front syntax rustc_const_eval\n DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n DEPS_rustc_privacy := rustc rustc_front log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n-                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n-DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n+                    log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics \\\n+\t\t\t\t\trustc_const_eval\n+DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics rustc_const_eval\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_front"}, {"sha": "3988545c201e0ad7fd62e18ba2196e7c47186941", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -55,6 +55,7 @@ extern crate rustc_front;\n extern crate rustc_data_structures;\n extern crate serialize;\n extern crate collections;\n+extern crate rustc_const_eval;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "c3f8d7bf9598e16f5a7f6cf8b017331926f0975b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 257, "deletions": 442, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -23,10 +23,9 @@ use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::util::IntTypeExt;\n use middle::astconv_util::ast_ty_to_prim_ty;\n-use util::num::ToPrimitive;\n use util::nodemap::NodeMap;\n-use session::Session;\n \n use graphviz::IntoCow;\n use syntax::ast;\n@@ -43,10 +42,20 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::hash;\n use std::mem::transmute;\n-use std::{i8, i16, i32, i64, u8, u16, u32, u64};\n use std::rc::Rc;\n \n-fn lookup_variant_by_id<'a>(tcx: &'a TyCtxt,\n+use rustc_const_eval::*;\n+\n+macro_rules! math {\n+    ($e:expr, $op:expr) => {\n+        match $op {\n+            Ok(val) => val,\n+            Err(e) => signal!($e, Math(e)),\n+        }\n+    }\n+}\n+\n+fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n                             enum_def: DefId,\n                             variant_def: DefId)\n                             -> Option<&'a Expr> {\n@@ -248,8 +257,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ConstVal {\n     Float(f64),\n-    Int(i64),\n-    Uint(u64),\n+    Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n@@ -258,14 +266,14 @@ pub enum ConstVal {\n     Function(DefId),\n     Array(ast::NodeId, u64),\n     Repeat(ast::NodeId, u64),\n+    Char(char),\n }\n \n impl hash::Hash for ConstVal {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         match *self {\n             Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n-            Int(a) => a.hash(state),\n-            Uint(a) => a.hash(state),\n+            Integral(a) => a.hash(state),\n             Str(ref a) => a.hash(state),\n             ByteStr(ref a) => a.hash(state),\n             Bool(a) => a.hash(state),\n@@ -274,6 +282,7 @@ impl hash::Hash for ConstVal {\n             Function(a) => a.hash(state),\n             Array(a, n) => { a.hash(state); n.hash(state) },\n             Repeat(a, n) => { a.hash(state); n.hash(state) },\n+            Char(c) => c.hash(state),\n         }\n     }\n }\n@@ -286,8 +295,7 @@ impl PartialEq for ConstVal {\n     fn eq(&self, other: &ConstVal) -> bool {\n         match (self, other) {\n             (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n-            (&Int(a), &Int(b)) => a == b,\n-            (&Uint(a), &Uint(b)) => a == b,\n+            (&Integral(a), &Integral(b)) => a == b,\n             (&Str(ref a), &Str(ref b)) => a == b,\n             (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n             (&Bool(a), &Bool(b)) => a == b,\n@@ -296,6 +304,7 @@ impl PartialEq for ConstVal {\n             (&Function(a), &Function(b)) => a == b,\n             (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n             (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n+            (&Char(a), &Char(b)) => a == b,\n             _ => false,\n         }\n     }\n@@ -307,9 +316,7 @@ impl ConstVal {\n     pub fn description(&self) -> &'static str {\n         match *self {\n             Float(_) => \"float\",\n-            Int(i) if i < 0 => \"negative integer\",\n-            Int(_) => \"positive integer\",\n-            Uint(_) => \"unsigned integer\",\n+            Integral(i) => i.description(),\n             Str(_) => \"string literal\",\n             ByteStr(_) => \"byte string literal\",\n             Bool(_) => \"boolean\",\n@@ -318,6 +325,7 @@ impl ConstVal {\n             Function(_) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n+            Char(..) => \"char\",\n         }\n     }\n }\n@@ -402,7 +410,6 @@ pub enum ErrKind {\n     CannotCast,\n     CannotCastTo(&'static str),\n     InvalidOpForInts(hir::BinOp_),\n-    InvalidOpForUInts(hir::BinOp_),\n     InvalidOpForBools(hir::BinOp_),\n     InvalidOpForFloats(hir::BinOp_),\n     InvalidOpForIntUint(hir::BinOp_),\n@@ -442,6 +449,13 @@ pub enum ErrKind {\n     MiscCatchAll,\n \n     IndexOpFeatureGated,\n+    Math(ConstMathErr),\n+}\n+\n+impl From<ConstMathErr> for ErrKind {\n+    fn from(err: ConstMathErr) -> ErrKind {\n+        Math(err)\n+    }\n }\n \n impl ConstEvalErr {\n@@ -451,8 +465,7 @@ impl ConstEvalErr {\n         match self.kind {\n             CannotCast => \"can't cast this type\".into_cow(),\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n-            InvalidOpForInts(_) =>  \"can't do this op on signed integrals\".into_cow(),\n-            InvalidOpForUInts(_) =>  \"can't do this op on unsigned integrals\".into_cow(),\n+            InvalidOpForInts(_) =>  \"can't do this op on integrals\".into_cow(),\n             InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n             InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n             InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n@@ -492,6 +505,7 @@ impl ConstEvalErr {\n             MiscBinaryOp => \"bad operands for binary\".into_cow(),\n             MiscCatchAll => \"unsupported constant expr\".into_cow(),\n             IndexOpFeatureGated => \"the index operation on const values is unstable\".into_cow(),\n+            Math(ref err) => err.description().into_cow(),\n         }\n     }\n }\n@@ -536,276 +550,12 @@ impl<'tcx> EvalHint<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum IntTy { I8, I16, I32, I64 }\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum UintTy { U8, U16, U32, U64 }\n-\n-impl IntTy {\n-    pub fn from(tcx: &TyCtxt, t: ast::IntTy) -> IntTy {\n-        let t = if let ast::IntTy::Is = t {\n-            tcx.sess.target.int_type\n-        } else {\n-            t\n-        };\n-        match t {\n-            ast::IntTy::Is => unreachable!(),\n-            ast::IntTy::I8  => IntTy::I8,\n-            ast::IntTy::I16 => IntTy::I16,\n-            ast::IntTy::I32 => IntTy::I32,\n-            ast::IntTy::I64 => IntTy::I64,\n-        }\n-    }\n-}\n-\n-impl UintTy {\n-    pub fn from(tcx: &TyCtxt, t: ast::UintTy) -> UintTy {\n-        let t = if let ast::UintTy::Us = t {\n-            tcx.sess.target.uint_type\n-        } else {\n-            t\n-        };\n-        match t {\n-            ast::UintTy::Us => unreachable!(),\n-            ast::UintTy::U8  => UintTy::U8,\n-            ast::UintTy::U16 => UintTy::U16,\n-            ast::UintTy::U32 => UintTy::U32,\n-            ast::UintTy::U64 => UintTy::U64,\n-        }\n-    }\n-}\n-\n macro_rules! signal {\n     ($e:expr, $exn:expr) => {\n         return Err(ConstEvalErr { span: $e.span, kind: $exn })\n     }\n }\n \n-// The const_{int,uint}_checked_{neg,add,sub,mul,div,shl,shr} family\n-// of functions catch and signal overflow errors during constant\n-// evaluation.\n-//\n-// They all take the operator's arguments (`a` and `b` if binary), the\n-// overall expression (`e`) and, if available, whole expression's\n-// concrete type (`opt_ety`).\n-//\n-// If the whole expression's concrete type is None, then this is a\n-// constant evaluation happening before type check (e.g. in the check\n-// to confirm that a pattern range's left-side is not greater than its\n-// right-side). We do not do arithmetic modulo the type's bitwidth in\n-// such a case; we just do 64-bit arithmetic and assume that later\n-// passes will do it again with the type information, and thus do the\n-// overflow checks then.\n-\n-pub fn const_int_checked_neg<'a>(\n-    a: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-\n-    let (min,max) = match opt_ety {\n-        // (-i8::MIN is itself not an i8, etc, but this is an easy way\n-        // to allow literals to pass the check. Of course that does\n-        // not work for i64::MIN.)\n-        Some(IntTy::I8) =>  (-(i8::MAX as i64), -(i8::MIN as i64)),\n-        Some(IntTy::I16) => (-(i16::MAX as i64), -(i16::MIN as i64)),\n-        Some(IntTy::I32) => (-(i32::MAX as i64), -(i32::MIN as i64)),\n-        None | Some(IntTy::I64) => (-i64::MAX, -(i64::MIN+1)),\n-    };\n-\n-    let oflo = a < min || a > max;\n-    if oflo {\n-        signal!(e, NegateWithOverflow(a));\n-    } else {\n-        Ok(Int(-a))\n-    }\n-}\n-\n-pub fn const_uint_checked_neg<'a>(\n-    a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n-    // This always succeeds, and by definition, returns `(!a)+1`.\n-    Ok(Uint((!a).wrapping_add(1)))\n-}\n-\n-fn const_uint_not(a: u64, opt_ety: Option<UintTy>) -> ConstVal {\n-    let mask = match opt_ety {\n-        Some(UintTy::U8) => u8::MAX as u64,\n-        Some(UintTy::U16) => u16::MAX as u64,\n-        Some(UintTy::U32) => u32::MAX as u64,\n-        None | Some(UintTy::U64) => u64::MAX,\n-    };\n-    Uint(!a & mask)\n-}\n-\n-macro_rules! overflow_checking_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident,\n-     lhs: $to_8_lhs:ident $to_16_lhs:ident $to_32_lhs:ident,\n-     rhs: $to_8_rhs:ident $to_16_rhs:ident $to_32_rhs:ident $to_64_rhs:ident,\n-     $EnumTy:ident $T8: ident $T16: ident $T32: ident $T64: ident,\n-     $result_type: ident) => { {\n-        let (a,b,opt_ety) = ($a,$b,$ety);\n-        match opt_ety {\n-            Some($EnumTy::$T8) => match (a.$to_8_lhs(), b.$to_8_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            Some($EnumTy::$T16) => match (a.$to_16_lhs(), b.$to_16_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            Some($EnumTy::$T32) => match (a.$to_32_lhs(), b.$to_32_rhs()) {\n-                (Some(a), Some(b)) => {\n-                    let (a, oflo) = a.$overflowing_op(b);\n-                    (a as $result_type, oflo)\n-                }\n-                (None, _) | (_, None) => (0, true)\n-            },\n-            None | Some($EnumTy::$T64) => match b.$to_64_rhs() {\n-                Some(b) => a.$overflowing_op(b),\n-                None => (0, true),\n-            }\n-        }\n-    } }\n-}\n-\n-macro_rules! int_arith_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_i8 to_i16 to_i32,\n-            rhs: to_i8 to_i16 to_i32 to_i64, IntTy I8 I16 I32 I64, i64)\n-    }\n-}\n-\n-macro_rules! uint_arith_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_u8 to_u16 to_u32,\n-            rhs: to_u8 to_u16 to_u32 to_u64, UintTy U8 U16 U32 U64, u64)\n-    }\n-}\n-\n-macro_rules! int_shift_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_i8 to_i16 to_i32,\n-            rhs: to_u32 to_u32 to_u32 to_u32, IntTy I8 I16 I32 I64, i64)\n-    }\n-}\n-\n-macro_rules! uint_shift_body {\n-    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n-        overflow_checking_body!(\n-            $a, $b, $ety, $overflowing_op,\n-            lhs: to_u8 to_u16 to_u32,\n-            rhs: to_u32 to_u32 to_u32 to_u32, UintTy U8 U16 U32 U64, u64)\n-    }\n-}\n-\n-macro_rules! pub_fn_checked_op {\n-    {$fn_name:ident ($a:ident : $a_ty:ty, $b:ident : $b_ty:ty,.. $WhichTy:ident) {\n-        $ret_oflo_body:ident $overflowing_op:ident\n-            $const_ty:ident $signal_exn:expr\n-    }} => {\n-        pub fn $fn_name<'a>($a: $a_ty,\n-                            $b: $b_ty,\n-                            e: &'a Expr,\n-                            opt_ety: Option<$WhichTy>) -> EvalResult {\n-            let (ret, oflo) = $ret_oflo_body!($a, $b, opt_ety, $overflowing_op);\n-            if !oflo { Ok($const_ty(ret)) } else { signal!(e, $signal_exn) }\n-        }\n-    }\n-}\n-\n-pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_add Int AddiWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_sub Int SubiWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_mul Int MuliWithOverflow(a, b)\n-}}\n-\n-pub fn const_int_checked_div<'a>(\n-    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-    if b == 0 { signal!(e, DivideByZero); }\n-    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(Int(ret)) } else { signal!(e, DivideWithOverflow) }\n-}\n-\n-pub fn const_int_checked_rem<'a>(\n-    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n-    if b == 0 { signal!(e, ModuloByZero); }\n-    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(Int(ret)) } else { signal!(e, ModuloWithOverflow) }\n-}\n-\n-pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_add Uint AdduWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_sub Uint SubuWithOverflow(a, b)\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_mul Uint MuluWithOverflow(a, b)\n-}}\n-\n-pub fn const_uint_checked_div<'a>(\n-    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n-    if b == 0 { signal!(e, DivideByZero); }\n-    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(Uint(ret)) } else { signal!(e, DivideWithOverflow) }\n-}\n-\n-pub fn const_uint_checked_rem<'a>(\n-    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n-    if b == 0 { signal!(e, ModuloByZero); }\n-    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(Uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n-}\n-\n-pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n-}}\n-\n-pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n-}}\n-\n /// Evaluate a constant expression in a context where the expression isn't\n /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n /// but a few places need to evaluate constants during type-checking, like\n@@ -833,34 +583,57 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             tcx.expr_ty_opt(e)\n         }\n     };\n-\n-    // If type of expression itself is int or uint, normalize in these\n-    // bindings so that isize/usize is mapped to a type with an\n-    // inherently known bitwidth.\n-    let expr_int_type = ety.and_then(|ty| {\n-        if let ty::TyInt(t) = ty.sty {\n-            Some(IntTy::from(tcx, t)) } else { None }\n-    });\n-    let expr_uint_type = ety.and_then(|ty| {\n-        if let ty::TyUint(t) = ty.sty {\n-            Some(UintTy::from(tcx, t)) } else { None }\n-    });\n-\n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n+        // unary neg literals already got their sign during creation\n+        if let hir::ExprLit(ref lit) = inner.node {\n+            use syntax::ast::*;\n+            use syntax::ast::LitIntType::*;\n+            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n+            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n+            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n+            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            match (&lit.node, ety.map(|t| &t.sty)) {\n+                (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n+                (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n+                    return Ok(Integral(I8(::std::i8::MIN)))\n+                },\n+                (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n+                    return Ok(Integral(I16(::std::i16::MIN)))\n+                },\n+                (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n+                    return Ok(Integral(I32(::std::i32::MIN)))\n+                },\n+                (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n+                    return Ok(Integral(I64(::std::i64::MIN)))\n+                },\n+                (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n+                    match tcx.sess.target.int_type {\n+                        IntTy::I32 => if n == I32_OVERFLOW {\n+                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                        },\n+                        IntTy::I64 => if n == I64_OVERFLOW {\n+                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                        },\n+                        _ => unreachable!(),\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n         match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Float(f) => Float(-f),\n-          Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n-          Uint(i) => {\n-              try!(const_uint_checked_neg(i, e, expr_uint_type))\n-          }\n+          Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n-          Int(i) => Int(!i),\n-          Uint(i) => const_uint_not(i, expr_uint_type),\n+          Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n         }\n@@ -870,6 +643,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             hir::BiShl | hir::BiShr => ty_hint.checked_or(tcx.types.usize),\n             _ => ty_hint\n         };\n+        // technically, if we don't have type hints, but integral eval\n+        // gives us a type through a type-suffix, cast or const def type\n+        // we need to re-eval the other value of the BinOp if it was\n+        // not inferred\n         match (try!(eval_const_expr_partial(tcx, &a, ty_hint, fn_args)),\n                try!(eval_const_expr_partial(tcx, &b, b_ty, fn_args))) {\n           (Float(a), Float(b)) => {\n@@ -888,63 +665,28 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n               _ => signal!(e, InvalidOpForFloats(op.node)),\n             }\n           }\n-          (Int(a), Int(b)) => {\n+          (Integral(a), Integral(b)) => {\n+            use std::cmp::Ordering::*;\n             match op.node {\n-              hir::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n-              hir::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n-              hir::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n-              hir::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n-              hir::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n-              hir::BiBitAnd => Int(a & b),\n-              hir::BiBitOr => Int(a | b),\n-              hir::BiBitXor => Int(a ^ b),\n-              hir::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n-              hir::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n-              hir::BiEq => Bool(a == b),\n-              hir::BiLt => Bool(a < b),\n-              hir::BiLe => Bool(a <= b),\n-              hir::BiNe => Bool(a != b),\n-              hir::BiGe => Bool(a >= b),\n-              hir::BiGt => Bool(a > b),\n+              hir::BiAdd => Integral(math!(e, a + b)),\n+              hir::BiSub => Integral(math!(e, a - b)),\n+              hir::BiMul => Integral(math!(e, a * b)),\n+              hir::BiDiv => Integral(math!(e, a / b)),\n+              hir::BiRem => Integral(math!(e, a % b)),\n+              hir::BiBitAnd => Integral(math!(e, a & b)),\n+              hir::BiBitOr => Integral(math!(e, a | b)),\n+              hir::BiBitXor => Integral(math!(e, a ^ b)),\n+              hir::BiShl => Integral(math!(e, a << b)),\n+              hir::BiShr => Integral(math!(e, a >> b)),\n+              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n+              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n+              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n+              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n+              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n+              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n               _ => signal!(e, InvalidOpForInts(op.node)),\n             }\n           }\n-          (Uint(a), Uint(b)) => {\n-            match op.node {\n-              hir::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n-              hir::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n-              hir::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n-              hir::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n-              hir::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n-              hir::BiBitAnd => Uint(a & b),\n-              hir::BiBitOr => Uint(a | b),\n-              hir::BiBitXor => Uint(a ^ b),\n-              hir::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n-              hir::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n-              hir::BiEq => Bool(a == b),\n-              hir::BiLt => Bool(a < b),\n-              hir::BiLe => Bool(a <= b),\n-              hir::BiNe => Bool(a != b),\n-              hir::BiGe => Bool(a >= b),\n-              hir::BiGt => Bool(a > b),\n-              _ => signal!(e, InvalidOpForUInts(op.node)),\n-            }\n-          }\n-          // shifts can have any integral type as their rhs\n-          (Int(a), Uint(b)) => {\n-            match op.node {\n-              hir::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n-              hir::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n-              _ => signal!(e, InvalidOpForIntUint(op.node)),\n-            }\n-          }\n-          (Uint(a), Int(b)) => {\n-            match op.node {\n-              hir::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n-              hir::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n-              _ => signal!(e, InvalidOpForUintInt(op.node)),\n-            }\n-          }\n           (Bool(a), Bool(b)) => {\n             Bool(match op.node {\n               hir::BiAnd => a && b,\n@@ -962,7 +704,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &target_ty))\n+        let ety = ast_ty_to_prim_ty(tcx, &target_ty).or_else(|| ety)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -971,9 +713,6 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            // FIXME (#23833): the type-hint can cause problems,\n-            // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n-            // type to the sum, and thus no overflow is signaled.\n             match tcx.expr_ty_opt(&base) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n@@ -1103,10 +842,28 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n \n           let mut call_args = NodeMap();\n           for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+              let arg_hint = match ty_hint {\n+                  ExprTypeChecked => ExprTypeChecked,\n+                  UncheckedExprNoHint | UncheckedExprHint(_) => {\n+                      if let Some(hint) = tcx.ast_ty_to_ty_cache.borrow().get(&arg.ty.id) {\n+                          let mut new_ty_hint = UncheckedExprHint(hint);\n+                          for t in hint.walk() {\n+                              if let ty::TypeVariants::TyParam(_) = t.sty {\n+                                  // found a generic argument, but we are in typeck\n+                                  new_ty_hint = UncheckedExprNoHint;\n+                                  break;\n+                              }\n+                          }\n+                          new_ty_hint\n+                      } else {\n+                          UncheckedExprNoHint\n+                      }\n+                  },\n+              };\n               let arg_val = try!(eval_const_expr_partial(\n                   tcx,\n                   arg_expr,\n-                  sub_ty_hint,\n+                  arg_hint,\n                   fn_args\n               ));\n               debug!(\"const call arg: {:?}\", arg);\n@@ -1116,7 +873,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &lit, ety),\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety, lit.span) {\n+          Ok(val) => val,\n+          Err(err) => signal!(e, Math(err)),\n+      },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n@@ -1134,14 +894,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let arr = try!(eval_const_expr_partial(tcx, arr, arr_hint, fn_args));\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n         let idx = match try!(eval_const_expr_partial(tcx, idx, idx_hint, fn_args)) {\n-            Int(i) if i >= 0 => i as u64,\n-            Int(_) => signal!(idx, IndexNegative),\n-            Uint(i) => i,\n+            Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+            Integral(_) => unreachable!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n+        assert_eq!(idx as usize as u64, idx);\n         match arr {\n             Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n-            Array(v, _) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n+            Array(v, n) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n+                assert_eq!(n as usize as u64, n);\n                 try!(eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args))\n             } else {\n                 unreachable!()\n@@ -1155,13 +916,13 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 fn_args,\n             )),\n \n-            ByteStr(ref data) if idx as usize >= data.len()\n-                => signal!(e, IndexOutOfBounds),\n-            ByteStr(data) => Uint(data[idx as usize] as u64),\n+            ByteStr(ref data) if idx >= data.len() as u64 => signal!(e, IndexOutOfBounds),\n+            ByteStr(data) => {\n+                Integral(U8(data[idx as usize]))\n+            },\n \n-            Str(ref s) if idx as usize >= s.len()\n-                => signal!(e, IndexOutOfBounds),\n-            Str(_) => unimplemented!(), // there's no const_char type\n+            Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n+            Str(_) => unimplemented!(), // FIXME: return a const char\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n@@ -1171,9 +932,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           Repeat(\n               e.id,\n               match try!(eval_const_expr_partial(tcx, &n, len_hint, fn_args)) {\n-                  Int(i) if i >= 0 => i as u64,\n-                  Int(_) => signal!(e, RepeatCountNotNatural),\n-                  Uint(i) => i,\n+                  Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+                  Integral(_) => signal!(e, RepeatCountNotNatural),\n                   _ => signal!(e, RepeatCountNotInt),\n               },\n           )\n@@ -1184,7 +944,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         if let Tuple(tup_id) = c {\n             if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                 if index.node < fields.len() {\n-                    return eval_const_expr_partial(tcx, &fields[index.node], base_hint, fn_args)\n+                    return eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args)\n                 } else {\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n@@ -1205,7 +965,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    return eval_const_expr_partial(tcx, &f.expr, base_hint, fn_args)\n+                    return eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args)\n                 } else {\n                     signal!(e, MissingStructField);\n                 }\n@@ -1289,100 +1049,155 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n     }\n }\n \n-fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n-    macro_rules! convert_val {\n-        ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n-            match val {\n-                Bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n-                Uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                Int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                Float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n-            }\n-        }\n+fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+    let v = val.to_u64_unchecked();\n+    match ty.sty {\n+        ty::TyBool if v == 0 => Ok(Bool(false)),\n+        ty::TyBool if v == 1 => Ok(Bool(true)),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i32))),\n+        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n+        ty::TyInt(ast::IntTy::Is) => {\n+            Ok(Integral(Isize(try!(ConstIsize::new(v as i64, tcx.sess.target.int_type)))))\n+        },\n+        ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n+        ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n+        ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n+        ty::TyUint(ast::UintTy::Us) => {\n+            Ok(Integral(Usize(try!(ConstUsize::new(v, tcx.sess.target.uint_type)))))\n+        },\n+        ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n+            // FIXME: this could probably be prettier\n+            // there's no easy way to turn an `Infer` into a f64\n+            let val = try!((-val).map_err(Math));\n+            let val = val.to_u64().unwrap() as f64;\n+            let val = -val;\n+            Ok(Float(val))\n+        },\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(val.to_u64().unwrap() as f64)),\n+        ty::TyFloat(ast::FloatTy::F32) if val.is_negative() => {\n+            let val = try!((-val).map_err(Math));\n+            let val = val.to_u64().unwrap() as f32;\n+            let val = -val;\n+            Ok(Float(val as f64))\n+        },\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(val.to_u64().unwrap() as f32 as f64)),\n+        _ => Err(CannotCast),\n     }\n+}\n \n-    // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n-    match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I32, _) => return convert_val!(i32, Int, i64),\n-        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I64, _) => return convert_val!(i64, Int, i64),\n-        (&ty::TyInt(ast::IntTy::Is), _, _) => panic!(\"unexpected target.int_type\"),\n-\n-        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U32) => return convert_val!(u32, Uint, u64),\n-        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U64) => return convert_val!(u64, Uint, u64),\n-        (&ty::TyUint(ast::UintTy::Us), _, _) => panic!(\"unexpected target.uint_type\"),\n-\n-        _ => {}\n+fn cast_const_float<'tcx>(tcx: &ty::ctxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+    match ty.sty {\n+        ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n+        ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n+        ty::TyUint(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(f)),\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(f as f32 as f64)),\n+        _ => Err(CannotCast),\n     }\n+}\n \n-    match ty.sty {\n-        ty::TyInt(ast::IntTy::Is) => unreachable!(),\n-        ty::TyUint(ast::UintTy::Us) => unreachable!(),\n-\n-        ty::TyInt(ast::IntTy::I8) => convert_val!(i8, Int, i64),\n-        ty::TyInt(ast::IntTy::I16) => convert_val!(i16, Int, i64),\n-        ty::TyInt(ast::IntTy::I32) => convert_val!(i32, Int, i64),\n-        ty::TyInt(ast::IntTy::I64) => convert_val!(i64, Int, i64),\n-\n-        ty::TyUint(ast::UintTy::U8) => convert_val!(u8, Uint, u64),\n-        ty::TyUint(ast::UintTy::U16) => convert_val!(u16, Uint, u64),\n-        ty::TyUint(ast::UintTy::U32) => convert_val!(u32, Uint, u64),\n-        ty::TyUint(ast::UintTy::U64) => convert_val!(u64, Uint, u64),\n-\n-        ty::TyFloat(ast::FloatTy::F32) => convert_val!(f32, Float, f64),\n-        ty::TyFloat(ast::FloatTy::F64) => convert_val!(f64, Float, f64),\n-        _ => Err(ErrKind::CannotCast),\n+fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+    match val {\n+        Integral(i) => cast_const_int(tcx, i, ty),\n+        Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n+        Float(f) => cast_const_float(tcx, f, ty),\n+        Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        _ => Err(CannotCast),\n     }\n }\n \n-fn lit_to_const(sess: &Session, span: Span, lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n-    match lit.node {\n-        ast::LitKind::Str(ref s, _) => Str((*s).clone()),\n-        ast::LitKind::ByteStr(ref data) => {\n-            ByteStr(data.clone())\n-        }\n-        ast::LitKind::Byte(n) => Uint(n as u64),\n-        ast::LitKind::Char(n) => Uint(n as u64),\n-        ast::LitKind::Int(n, ast::LitIntType::Signed(_)) => Int(n as i64),\n-        ast::LitKind::Int(n, ast::LitIntType::Unsuffixed) => {\n-            match ty_hint.map(|ty| &ty.sty) {\n-                Some(&ty::TyUint(_)) => Uint(n),\n-                _ => Int(n as i64)\n+fn lit_to_const<'tcx>(lit: &ast::LitKind,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      ty_hint: Option<Ty<'tcx>>,\n+                      span: Span,\n+                      ) -> Result<ConstVal, ConstMathErr> {\n+    use syntax::ast::*;\n+    use syntax::ast::LitIntType::*;\n+    const I8MAX: u64 = ::std::i8::MAX as u64;\n+    const I16MAX: u64 = ::std::i16::MAX as u64;\n+    const I32MAX: u64 = ::std::i32::MAX as u64;\n+    const I64MAX: u64 = ::std::i64::MAX as u64;\n+    const U8MAX: u64 = ::std::u8::MAX as u64;\n+    const U16MAX: u64 = ::std::u16::MAX as u64;\n+    const U32MAX: u64 = ::std::u32::MAX as u64;\n+    const U64MAX: u64 = ::std::u64::MAX as u64;\n+    match *lit {\n+        LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n+        LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n+        LitKind::Byte(n) => Ok(Integral(U8(n))),\n+        LitKind::Int(n @ 0...I8MAX, Signed(IntTy::I8)) => Ok(Integral(I8(n as i8))),\n+        LitKind::Int(n @ 0...I16MAX, Signed(IntTy::I16)) => Ok(Integral(I16(n as i16))),\n+        LitKind::Int(n @ 0...I32MAX, Signed(IntTy::I32)) => Ok(Integral(I32(n as i32))),\n+        LitKind::Int(n @ 0...I64MAX, Signed(IntTy::I64)) => Ok(Integral(I64(n as i64))),\n+        LitKind::Int(n, Signed(IntTy::Is)) => {\n+            Ok(Integral(Isize(try!(ConstIsize::new(n as i64, tcx.sess.target.int_type)))))\n+        },\n+\n+        LitKind::Int(_, Signed(ty)) => Err(ConstMathErr::LitOutOfRange(ty)),\n+\n+        LitKind::Int(n, Unsuffixed) => {\n+            match ty_hint.map(|t| &t.sty) {\n+                Some(&ty::TyInt(ity)) => {\n+                    lit_to_const(&LitKind::Int(n, Signed(ity)), tcx, ty_hint, span)\n+                },\n+                Some(&ty::TyUint(uty)) => {\n+                    lit_to_const(&LitKind::Int(n, Unsigned(uty)), tcx, ty_hint, span)\n+                },\n+                None => Ok(Integral(Infer(n))),\n+                Some(&ty::TyEnum(ref adt, _)) => {\n+                    let hints = tcx.lookup_repr_hints(adt.did);\n+                    let int_ty = tcx.enum_repr_type(hints.iter().next());\n+                    lit_to_const(lit, tcx, Some(int_ty.to_ty(tcx)), span)\n+                },\n+                Some(ty_hint) => panic!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n-        }\n-        ast::LitKind::Int(n, ast::LitIntType::Unsigned(_)) => Uint(n),\n-        ast::LitKind::Float(ref n, _) |\n-        ast::LitKind::FloatUnsuffixed(ref n) => {\n+        },\n+        LitKind::Int(n @ 0...U8MAX, Unsigned(UintTy::U8)) => Ok(Integral(U8(n as u8))),\n+        LitKind::Int(n @ 0...U16MAX, Unsigned(UintTy::U16)) => Ok(Integral(U16(n as u16))),\n+        LitKind::Int(n @ 0...U32MAX, Unsigned(UintTy::U32)) => Ok(Integral(U32(n as u32))),\n+        LitKind::Int(n @ 0...U64MAX, Unsigned(UintTy::U64)) => Ok(Integral(U64(n as u64))),\n+\n+        LitKind::Int(n, Unsigned(UintTy::Us)) => {\n+            Ok(Integral(Usize(try!(ConstUsize::new(n as u64, tcx.sess.target.uint_type)))))\n+        },\n+        LitKind::Int(_, Unsigned(ty)) => Err(ConstMathErr::ULitOutOfRange(ty)),\n+\n+        LitKind::Float(ref n, _) |\n+        LitKind::FloatUnsuffixed(ref n) => {\n             if let Ok(x) = n.parse::<f64>() {\n-                Float(x)\n+                Ok(Float(x))\n             } else {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n+                tcx.sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n             }\n         }\n-        ast::LitKind::Bool(b) => Bool(b)\n+        LitKind::Bool(b) => Ok(Bool(b)),\n+        LitKind::Char(c) => Ok(Char(c)),\n     }\n }\n \n pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n-    Some(match (a, b) {\n-        (&Int(a), &Int(b)) => a.cmp(&b),\n-        (&Uint(a), &Uint(b)) => a.cmp(&b),\n+    match (a, b) {\n+        (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n         (&Float(a), &Float(b)) => {\n             // This is pretty bad but it is the existing behavior.\n-            if a == b {\n+            Some(if a == b {\n                 Ordering::Equal\n             } else if a < b {\n                 Ordering::Less\n             } else {\n                 Ordering::Greater\n-            }\n+            })\n         }\n-        (&Str(ref a), &Str(ref b)) => a.cmp(b),\n-        (&Bool(a), &Bool(b)) => a.cmp(&b),\n-        (&ByteStr(ref a), &ByteStr(ref b)) => a.cmp(b),\n-        _ => return None\n-    })\n+        (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n+        (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n+        (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n+        (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n+        _ => None,\n+    }\n }\n \n pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,"}, {"sha": "c98ae2cceabaa50d386b2ff6977548a566537296", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -50,6 +50,8 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n \n+use rustc_const_eval::ConstInt;\n+\n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait, PatKind};\n use rustc_front::intravisit::Visitor;\n@@ -100,8 +102,7 @@ mod ivar;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = u64;\n-pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n+pub type Disr = ConstInt;\n \n // Data types\n "}, {"sha": "c91441a3f8a4ba6ab21d25b2cce62a40634ca9ac", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 54, "deletions": 117, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -21,7 +21,8 @@ use middle::traits;\n use middle::ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use middle::ty::{Disr, ParameterEnvironment};\n use middle::ty::TypeVariants::*;\n-use util::num::ToPrimitive;\n+\n+use rustc_const_eval::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n@@ -34,11 +35,9 @@ use rustc_front::hir;\n \n pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n-    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n     fn disr_incr(&self, val: Disr) -> Option<Disr>;\n-    fn disr_string(&self, val: Disr) -> String;\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+    fn assert_ty_matches(&self, val: Disr);\n+    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n@@ -57,98 +56,48 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr {\n         match *self {\n-            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n+            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n+            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n+            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n+                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n+                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n+                _ => unreachable!(),\n+            },\n+            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n+            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n+            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n+            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n+                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n+                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n+                _ => unreachable!(),\n+            },\n         }\n     }\n \n-    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n+    fn assert_ty_matches(&self, val: Disr) {\n+        match (*self, val) {\n+            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n+            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n+            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n+            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n+            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n+            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n+            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n+            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n+            _ => panic!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }\n     }\n \n     fn disr_incr(&self, val: Disr) -> Option<Disr> {\n-        macro_rules! add1 {\n-            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n-        }\n-        match *self {\n-            // SignedInt repr means we *want* to reinterpret the bits\n-            // treating the highest bit of Disr as a sign-bit, so\n-            // cast to i64 before range-checking.\n-            SignedInt(ast::IntTy::I8)    => add1!((val as i64).to_i8()),\n-            SignedInt(ast::IntTy::I16)   => add1!((val as i64).to_i16()),\n-            SignedInt(ast::IntTy::I32)   => add1!((val as i64).to_i32()),\n-            SignedInt(ast::IntTy::I64)   => add1!(Some(val as i64)),\n-\n-            UnsignedInt(ast::UintTy::U8)  => add1!(val.to_u8()),\n-            UnsignedInt(ast::UintTy::U16) => add1!(val.to_u16()),\n-            UnsignedInt(ast::UintTy::U32) => add1!(val.to_u32()),\n-            UnsignedInt(ast::UintTy::U64) => add1!(Some(val)),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n-    }\n-\n-    // This returns a String because (1.) it is only used for\n-    // rendering an error message and (2.) a string can represent the\n-    // full range from `i64::MIN` through `u64::MAX`.\n-    fn disr_string(&self, val: Disr) -> String {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(ast::IntTy::I16)   => format!(\"{}\", val as i16),\n-            SignedInt(ast::IntTy::I32)   => format!(\"{}\", val as i32),\n-            SignedInt(ast::IntTy::I64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(ast::UintTy::U8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(ast::UintTy::U16) => format!(\"{}\", val as u16),\n-            UnsignedInt(ast::UintTy::U32) => format!(\"{}\", val as u32),\n-            UnsignedInt(ast::UintTy::U64) => format!(\"{}\", val as u64),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n-    }\n-\n-    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n-        macro_rules! add1 {\n-            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n-        }\n-        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => add1!(val as i8 ),\n-            SignedInt(ast::IntTy::I16)   => add1!(val as i16),\n-            SignedInt(ast::IntTy::I32)   => add1!(val as i32),\n-            SignedInt(ast::IntTy::I64)   => add1!(val as i64),\n-            UnsignedInt(ast::UintTy::U8)  => add1!(val as u8 ),\n-            UnsignedInt(ast::UintTy::U16) => add1!(val as u16),\n-            UnsignedInt(ast::UintTy::U32) => add1!(val as u32),\n-            UnsignedInt(ast::UintTy::U64) => add1!(val as u64),\n-\n-            UnsignedInt(ast::UintTy::Us) |\n-            SignedInt(ast::IntTy::Is) => unreachable!(),\n-        }\n+        self.assert_ty_matches(val);\n+        (val + ConstInt::Infer(1)).ok()\n     }\n }\n \n@@ -266,32 +215,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n-    /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n-    /// and `ty` is the original type (i.e. may include `isize` or\n-    /// `usize`).\n-    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>)\n-                          -> (attr::IntType, Ty<'tcx>) {\n-        let repr_type = match opt_hint {\n+    /// Returns the IntType representation.\n+    /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n+    /// by converting them to their actual types. That doesn't happen anymore.\n+    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n+        match opt_hint {\n             // Feed in the given type\n             Some(&attr::ReprInt(_, int_t)) => int_t,\n             // ... but provide sensible default if none provided\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n             // rustc_typeck::check would generate isize.\n             _ => SignedInt(ast::IntTy::Is),\n-        };\n-\n-        let repr_type_ty = repr_type.to_ty(self);\n-        let repr_type = match repr_type {\n-            SignedInt(ast::IntTy::Is) =>\n-                SignedInt(self.sess.target.int_type),\n-            UnsignedInt(ast::UintTy::Us) =>\n-                UnsignedInt(self.sess.target.uint_type),\n-            other => other\n-        };\n-\n-        (repr_type, repr_type_ty)\n+        }\n     }\n \n     /// Returns the deeply last field of nested structures, or the same type,\n@@ -335,15 +271,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn eval_repeat_count(&self, count_expr: &hir::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);\n         match const_eval::eval_const_expr_partial(self, count_expr, hint, None) {\n-            Ok(val) => {\n-                let found = match val {\n-                    ConstVal::Uint(count) => return count as usize,\n-                    ConstVal::Int(count) if count >= 0 => return count as usize,\n-                    const_val => const_val.description(),\n-                };\n+            Ok(ConstVal::Integral(ConstInt::Usize(count))) => {\n+                let val = count.as_u64(self.sess.target.uint_type);\n+                assert_eq!(val as usize as u64, val);\n+                val as usize\n+            },\n+            Ok(const_val) => {\n                 span_err!(self.sess, count_expr.span, E0306,\n-                    \"expected positive integer for repeat count, found {}\",\n-                    found);\n+                          \"expected positive integer for repeat count, found {}\",\n+                          const_val.description());\n+                0\n             }\n             Err(err) => {\n                 let err_msg = match count_expr.node {\n@@ -360,9 +297,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 };\n                 span_err!(self.sess, count_expr.span, E0307,\n                     \"expected constant integer for repeat count, {}\", err_msg);\n+                0\n             }\n         }\n-        0\n     }\n \n     /// Given a set of predicates that apply to an object type, returns"}, {"sha": "15f240755addad9be2206b6bc5afec09896235c3", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -10,6 +10,7 @@\n \n use graphviz::IntoCow;\n use middle::const_eval::ConstVal;\n+use rustc_const_eval::{ConstUsize, ConstInt};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -851,13 +852,12 @@ pub struct Constant<'tcx> {\n pub struct TypedConstVal<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub value: ConstVal\n+    pub value: ConstUsize,\n }\n \n impl<'tcx> Debug for TypedConstVal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"const \"));\n-        fmt_const_val(fmt, &self.value)\n+        write!(fmt, \"const {}\", ConstInt::Usize(self.value))\n     }\n }\n \n@@ -897,8 +897,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     use middle::const_eval::ConstVal::*;\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n-        Int(n) => write!(fmt, \"{:?}\", n),\n-        Uint(n) => write!(fmt, \"{:?}\", n),\n+        Integral(n) => write!(fmt, \"{}\", n),\n         Str(ref s) => write!(fmt, \"{:?}\", s),\n         ByteStr(ref bytes) => {\n             let escaped: String = bytes\n@@ -911,6 +910,8 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(node_id) | Tuple(node_id) | Array(node_id, _) | Repeat(node_id, _) =>\n             write!(fmt, \"{}\", node_to_string(node_id)),\n+        Char(c) => write!(fmt, \"{:?}\", c),\n+        Dummy => unreachable!(),\n     }\n }\n "}, {"sha": "b6b2694a7cbe1c2d3d53f4e8f148930a683794c3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -14,7 +14,6 @@\n  */\n \n use mir::repr::*;\n-use middle::const_eval::ConstVal;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_front::hir;\n@@ -144,12 +143,10 @@ impl<'tcx> Mir<'tcx> {\n         match *rvalue {\n             Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n             Rvalue::Repeat(ref operand, ref count) => {\n-                if let ConstVal::Uint(u) = count.value {\n-                    let op_ty = self.operand_ty(tcx, operand);\n-                    Some(tcx.mk_array(op_ty, u as usize))\n-                } else {\n-                    None\n-                }\n+                let op_ty = self.operand_ty(tcx, operand);\n+                let count = count.value.as_u64(tcx.sess.target.uint_type);\n+                assert_eq!(count as usize as u64, count);\n+                Some(tcx.mk_array(op_ty, count as usize))\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = self.lvalue_ty(tcx, lv).to_ty(tcx);"}, {"sha": "126b3824efec6940c4cd6c0949765bcbdd822a65", "filename": "src/librustc_const_eval/err.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Ferr.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum ConstMathErr {\n+    NotInRange,\n+    CmpBetweenUnequalTypes,\n+    UnequalTypes(Op),\n+    Overflow(Op),\n+    ShiftNegative,\n+    DivisionByZero,\n+    RemainderByZero,\n+    UnsignedNegation,\n+    ULitOutOfRange(ast::UintTy),\n+    LitOutOfRange(ast::IntTy),\n+}\n+pub use self::ConstMathErr::*;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Op {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    Shr,\n+    Shl,\n+    Neg,\n+    BitAnd,\n+    BitOr,\n+    BitXor,\n+}\n+\n+impl ConstMathErr {\n+    pub fn description(&self) -> &'static str {\n+        use self::Op::*;\n+        match *self {\n+            NotInRange => \"inferred value out of range\",\n+            CmpBetweenUnequalTypes => \"compared two integrals of different types\",\n+            UnequalTypes(Add) => \"tried to add two integrals of different types\",\n+            UnequalTypes(Sub) => \"tried to subtract two integrals of different types\",\n+            UnequalTypes(Mul) => \"tried to multiply two integrals of different types\",\n+            UnequalTypes(Div) => \"tried to divide two integrals of different types\",\n+            UnequalTypes(Rem) => {\n+                \"tried to calculate the remainder of two integrals of different types\"\n+            },\n+            UnequalTypes(BitAnd) => \"tried to bitand two integrals of different types\",\n+            UnequalTypes(BitOr) => \"tried to bitor two integrals of different types\",\n+            UnequalTypes(BitXor) => \"tried to xor two integrals of different types\",\n+            UnequalTypes(_) => unreachable!(),\n+            Overflow(Add) => \"attempted to add with overflow\",\n+            Overflow(Sub) => \"attempted to subtract with overflow\",\n+            Overflow(Mul) => \"attempted to multiply with overflow\",\n+            Overflow(Div) => \"attempted to divide with overflow\",\n+            Overflow(Rem) => \"attempted to calculate the remainder with overflow\",\n+            Overflow(Neg) => \"attempted to negate with overflow\",\n+            Overflow(Shr) => \"attempted to shift right with overflow\",\n+            Overflow(Shl) => \"attempted to shift left with overflow\",\n+            Overflow(_) => unreachable!(),\n+            ShiftNegative => \"attempted to shift by a negative amount\",\n+            DivisionByZero => \"attempted to divide by zero\",\n+            RemainderByZero => \"attempted to calculate the remainder with a divisor of zero\",\n+            UnsignedNegation => \"unary negation of unsigned integer\",\n+            ULitOutOfRange(ast::UintTy::U8) => \"literal out of range for u8\",\n+            ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n+            ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n+            ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n+            ULitOutOfRange(ast::UintTy::Us) => \"literal out of range for usize\",\n+            LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n+            LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n+            LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n+            LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n+            LitOutOfRange(ast::IntTy::Is) => \"literal out of range for isize\",\n+        }\n+    }\n+}"}, {"sha": "896d4a9b7d5e2c38ee67fc0e2bf2db0fddafd1f9", "filename": "src/librustc_const_eval/int.rs", "status": "added", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fint.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,551 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering;\n+\n+use super::is::*;\n+use super::us::*;\n+use super::err::*;\n+\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstInt {\n+    I8(i8),\n+    I16(i16),\n+    I32(i32),\n+    I64(i64),\n+    Isize(ConstIsize),\n+    U8(u8),\n+    U16(u16),\n+    U32(u32),\n+    U64(u64),\n+    Usize(ConstUsize),\n+    Infer(u64),\n+    InferSigned(i64),\n+}\n+pub use self::ConstInt::*;\n+\n+\n+macro_rules! bounds {\n+    ($($t:ident $min:ident $max:ident)*) => {\n+        mod as_u64 {\n+            $(\n+                #[allow(dead_code)]\n+                pub const $min: u64 = ::std::$t::MIN as u64;\n+                #[allow(dead_code)]\n+                pub const $max: u64 = ::std::$t::MAX as u64;\n+            )*\n+        }\n+        mod as_i64 {\n+            $(\n+                #[allow(dead_code)]\n+                pub const $min: i64 = ::std::$t::MIN as i64;\n+                #[allow(dead_code)]\n+                pub const $max: i64 = ::std::$t::MAX as i64;\n+            )*\n+        }\n+    }\n+}\n+\n+bounds!{\n+    i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX isize IMIN IMAX\n+    u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX usize UMIN UMAX\n+}\n+\n+impl ConstInt {\n+    /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n+    /// the other value. If both values have no type, don't do anything\n+    pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n+        let inferred = match (self, other) {\n+            (InferSigned(_), InferSigned(_))\n+            | (Infer(_), Infer(_)) => self, // no inference possible\n+            // kindof wrong, you could have had values > I64MAX during computation of a\n+            (Infer(a @ 0...as_u64::I64MAX), InferSigned(_)) => InferSigned(a as i64),\n+            (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n+            (_, InferSigned(_))\n+            | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n+\n+            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i8),\n+            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i16),\n+            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i32),\n+            (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n+            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i32)),\n+            (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n+            (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n+            (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),\n+            (Infer(a @ 0...as_u64::U32MAX), U32(_)) => U32(a as u32),\n+            (Infer(a), U64(_)) => U64(a),\n+            (Infer(a @ 0...as_u64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (Infer(a), Usize(Us64(_))) => Usize(Us64(a)),\n+\n+            (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n+\n+            (InferSigned(a @ as_i64::I8MIN...as_i64::I8MAX), I8(_)) => I8(a as i8),\n+            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), I16(_)) => I16(a as i16),\n+            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), I32(_)) => I32(a as i32),\n+            (InferSigned(a), I64(_)) => I64(a),\n+            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), Isize(Is32(_))) => {\n+                Isize(Is32(a as i32))\n+            },\n+            (InferSigned(a), Isize(Is64(_))) => Isize(Is64(a)),\n+            (InferSigned(a @ 0...as_i64::U8MAX), U8(_)) => U8(a as u8),\n+            (InferSigned(a @ 0...as_i64::U16MAX), U16(_)) => U16(a as u16),\n+            (InferSigned(a @ 0...as_i64::U32MAX), U32(_)) => U32(a as u32),\n+            (InferSigned(a @ 0...as_i64::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...as_i64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (InferSigned(a @ 0...as_i64::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n+            _ => self, // already known types\n+        };\n+        Ok((inferred, other))\n+    }\n+\n+    /// Turn this value into an `Infer` or an `InferSigned`\n+    pub fn erase_type(self) -> Self {\n+        match self {\n+            Infer(i) => Infer(i),\n+            InferSigned(i) if i < 0 => InferSigned(i),\n+            I8(i) if i < 0 => InferSigned(i as i64),\n+            I16(i) if i < 0 => InferSigned(i as i64),\n+            I32(i) if i < 0 => InferSigned(i as i64),\n+            I64(i) if i < 0 => InferSigned(i as i64),\n+            Isize(Is32(i)) if i < 0 => InferSigned(i as i64),\n+            Isize(Is64(i)) if i < 0 => InferSigned(i as i64),\n+            InferSigned(i) => Infer(i as u64),\n+            I8(i) => Infer(i as u64),\n+            I16(i) => Infer(i as u64),\n+            I32(i) => Infer(i as u64),\n+            I64(i) => Infer(i as u64),\n+            Isize(Is32(i)) => Infer(i as u64),\n+            Isize(Is64(i)) => Infer(i as u64),\n+            U8(i) => Infer(i as u64),\n+            U16(i) => Infer(i as u64),\n+            U32(i) => Infer(i as u64),\n+            U64(i) => Infer(i as u64),\n+            Usize(Us32(i)) => Infer(i as u64),\n+            Usize(Us64(i)) => Infer(i),\n+        }\n+    }\n+\n+    /// Description of the type, not the value\n+    pub fn description(&self) -> &'static str {\n+        match *self {\n+            Infer(_) => \"not yet inferred integral\",\n+            InferSigned(_) => \"not yet inferred signed integral\",\n+            I8(_) => \"i8\",\n+            I16(_) => \"i16\",\n+            I32(_) => \"i32\",\n+            I64(_) => \"i64\",\n+            Isize(_) => \"isize\",\n+            U8(_) => \"u8\",\n+            U16(_) => \"u16\",\n+            U32(_) => \"u32\",\n+            U64(_) => \"u64\",\n+            Usize(_) => \"usize\",\n+        }\n+    }\n+\n+    /// Erases the type and returns a u64.\n+    /// This is not the same as `-5i8 as u64` but as `-5i8 as i64 as u64`\n+    pub fn to_u64_unchecked(self) -> u64 {\n+        match self.erase_type() {\n+            ConstInt::Infer(i) => i,\n+            ConstInt::InferSigned(i) => i as u64,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n+    pub fn to_u32(&self) -> Option<u32> {\n+        match *self {\n+            I8(v) if v >= 0 => Some(v as u32),\n+            I16(v) if v >= 0 => Some(v as u32),\n+            I32(v) if v >= 0 => Some(v as u32),\n+            InferSigned(v)\n+            | Isize(Is64(v))\n+            | I64(v) if v >= 0 && v <= ::std::u32::MAX as i64 => Some(v as u32),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u32),\n+            U8(v) => Some(v as u32),\n+            U16(v) => Some(v as u32),\n+            U32(v) => Some(v),\n+            Infer(v)\n+            | Usize(Us64(v))\n+            | U64(v) if v <= ::std::u32::MAX as u64 => Some(v as u32),\n+            Usize(Us32(v)) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Converts the value to a `u64` if it's >= 0\n+    pub fn to_u64(&self) -> Option<u64> {\n+        match *self {\n+            Infer(v) => Some(v),\n+            InferSigned(v) if v >= 0 => Some(v as u64),\n+            I8(v) if v >= 0 => Some(v as u64),\n+            I16(v) if v >= 0 => Some(v as u64),\n+            I32(v) if v >= 0 => Some(v as u64),\n+            I64(v) if v >= 0 => Some(v as u64),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u64),\n+            Isize(Is64(v)) if v >= 0 => Some(v as u64),\n+            U8(v) => Some(v as u64),\n+            U16(v) => Some(v as u64),\n+            U32(v) => Some(v as u64),\n+            U64(v) => Some(v),\n+            Usize(Us32(v)) => Some(v as u64),\n+            Usize(Us64(v)) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_negative(&self) -> bool {\n+        match *self {\n+            I8(v) => v < 0,\n+            I16(v) => v < 0,\n+            I32(v) => v < 0,\n+            I64(v) => v < 0,\n+            Isize(Is32(v)) => v < 0,\n+            Isize(Is64(v)) => v < 0,\n+            InferSigned(v) => v < 0,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Compares the values if they are of the same type\n+    pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n+        match try!(self.infer(rhs)) {\n+            (I8(a), I8(b)) => Ok(a.cmp(&b)),\n+            (I16(a), I16(b)) => Ok(a.cmp(&b)),\n+            (I32(a), I32(b)) => Ok(a.cmp(&b)),\n+            (I64(a), I64(b)) => Ok(a.cmp(&b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n+            (U8(a), U8(b)) => Ok(a.cmp(&b)),\n+            (U16(a), U16(b)) => Ok(a.cmp(&b)),\n+            (U32(a), U32(b)) => Ok(a.cmp(&b)),\n+            (U64(a), U64(b)) => Ok(a.cmp(&b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n+            (Infer(a), Infer(b)) => Ok(a.cmp(&b)),\n+            (InferSigned(a), InferSigned(b)) => Ok(a.cmp(&b)),\n+            _ => Err(CmpBetweenUnequalTypes),\n+        }\n+    }\n+\n+    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n+    pub fn wrap_incr(self) -> Self {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) }\n+        }\n+        match self {\n+            ConstInt::I8(i) => ConstInt::I8(add1!(i)),\n+            ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n+            ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n+            ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n+            ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n+            ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n+            ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n+            ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n+            ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n+            ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n+            ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n+            ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n+            ConstInt::Infer(_) | ConstInt::InferSigned(_) => panic!(\"no type info for const int\"),\n+        }\n+    }\n+}\n+\n+impl ::std::cmp::PartialOrd for ConstInt {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.try_cmp(*other).ok()\n+    }\n+}\n+\n+impl ::std::cmp::Ord for ConstInt {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.try_cmp(*other).unwrap()\n+    }\n+}\n+\n+impl ::std::fmt::Display for ConstInt {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        match *self {\n+            Infer(i) => write!(fmt, \"{}\", i),\n+            InferSigned(i) => write!(fmt, \"{}\", i),\n+            I8(i) => write!(fmt, \"{}i8\", i),\n+            I16(i) => write!(fmt, \"{}i16\", i),\n+            I32(i) => write!(fmt, \"{}i32\", i),\n+            I64(i) => write!(fmt, \"{}i64\", i),\n+            Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n+            Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n+            U8(i) => write!(fmt, \"{}u8\", i),\n+            U16(i) => write!(fmt, \"{}u16\", i),\n+            U32(i) => write!(fmt, \"{}u32\", i),\n+            U64(i) => write!(fmt, \"{}u64\", i),\n+            Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n+            Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n+        }\n+    }\n+}\n+\n+macro_rules! overflowing {\n+    ($e:expr, $err:expr) => {{\n+        if $e.1 {\n+            return Err(Overflow($err));\n+        } else {\n+            $e.0\n+        }\n+    }}\n+}\n+\n+macro_rules! impl_binop {\n+    ($op:ident, $func:ident, $checked_func:ident) => {\n+        impl ::std::ops::$op for ConstInt {\n+            type Output = Result<Self, ConstMathErr>;\n+            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+                match try!(self.infer(rhs)) {\n+                    (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n+                    (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n+                    (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n+                    (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n+                    (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n+                    (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n+                    (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n+                    (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n+                    (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n+                    (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n+                    (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n+                    (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n+                    (Infer(a), Infer(b)) => a.$checked_func(b).map(Infer),\n+                    (InferSigned(a), InferSigned(b)) => a.$checked_func(b).map(InferSigned),\n+                    _ => return Err(UnequalTypes(Op::$op)),\n+                }.ok_or(Overflow(Op::$op))\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! derive_binop {\n+    ($op:ident, $func:ident) => {\n+        impl ::std::ops::$op for ConstInt {\n+            type Output = Result<Self, ConstMathErr>;\n+            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+                match try!(self.infer(rhs)) {\n+                    (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n+                    (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n+                    (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n+                    (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n+                    (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n+                    (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n+                    (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n+                    (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n+                    (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n+                    (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n+                    (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n+                    (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n+                    (Infer(a), Infer(b)) => Ok(Infer(a.$func(b))),\n+                    (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a.$func(b))),\n+                    _ => Err(UnequalTypes(Op::$op)),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_binop!(Add, add, checked_add);\n+impl_binop!(Sub, sub, checked_sub);\n+impl_binop!(Mul, mul, checked_mul);\n+derive_binop!(BitAnd, bitand);\n+derive_binop!(BitOr, bitor);\n+derive_binop!(BitXor, bitxor);\n+\n+fn check_division(\n+    lhs: ConstInt,\n+    rhs: ConstInt,\n+    op: Op,\n+    zerr: ConstMathErr,\n+) -> Result<(), ConstMathErr> {\n+    match (lhs, rhs) {\n+        (I8(_), I8(0)) => Err(zerr),\n+        (I16(_), I16(0)) => Err(zerr),\n+        (I32(_), I32(0)) => Err(zerr),\n+        (I64(_), I64(0)) => Err(zerr),\n+        (Isize(_), Isize(Is32(0))) => Err(zerr),\n+        (Isize(_), Isize(Is64(0))) => Err(zerr),\n+        (InferSigned(_), InferSigned(0)) => Err(zerr),\n+\n+        (U8(_), U8(0)) => Err(zerr),\n+        (U16(_), U16(0)) => Err(zerr),\n+        (U32(_), U32(0)) => Err(zerr),\n+        (U64(_), U64(0)) => Err(zerr),\n+        (Usize(_), Usize(Us32(0))) => Err(zerr),\n+        (Usize(_), Usize(Us64(0))) => Err(zerr),\n+        (Infer(_), Infer(0)) => Err(zerr),\n+\n+        (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n+        (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n+        (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n+        (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n+        (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n+        (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n+        (InferSigned(::std::i64::MIN), InferSigned(-1)) => Err(Overflow(op)),\n+\n+        _ => Ok(()),\n+    }\n+}\n+\n+impl ::std::ops::Div for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let (lhs, rhs) = try!(self.infer(rhs));\n+        try!(check_division(lhs, rhs, Op::Div, DivisionByZero));\n+        match (lhs, rhs) {\n+            (I8(a), I8(b)) => Ok(I8(a/b)),\n+            (I16(a), I16(b)) => Ok(I16(a/b)),\n+            (I32(a), I32(b)) => Ok(I32(a/b)),\n+            (I64(a), I64(b)) => Ok(I64(a/b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n+            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a/b)),\n+\n+            (U8(a), U8(b)) => Ok(U8(a/b)),\n+            (U16(a), U16(b)) => Ok(U16(a/b)),\n+            (U32(a), U32(b)) => Ok(U32(a/b)),\n+            (U64(a), U64(b)) => Ok(U64(a/b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n+            (Infer(a), Infer(b)) => Ok(Infer(a/b)),\n+\n+            _ => Err(UnequalTypes(Op::Div)),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Rem for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let (lhs, rhs) = try!(self.infer(rhs));\n+        // should INT_MIN%-1 be zero or an error?\n+        try!(check_division(lhs, rhs, Op::Rem, RemainderByZero));\n+        match (lhs, rhs) {\n+            (I8(a), I8(b)) => Ok(I8(a%b)),\n+            (I16(a), I16(b)) => Ok(I16(a%b)),\n+            (I32(a), I32(b)) => Ok(I32(a%b)),\n+            (I64(a), I64(b)) => Ok(I64(a%b)),\n+            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n+            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n+            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a%b)),\n+\n+            (U8(a), U8(b)) => Ok(U8(a%b)),\n+            (U16(a), U16(b)) => Ok(U16(a%b)),\n+            (U32(a), U32(b)) => Ok(U32(a%b)),\n+            (U64(a), U64(b)) => Ok(U64(a%b)),\n+            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n+            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n+            (Infer(a), Infer(b)) => Ok(Infer(a%b)),\n+\n+            _ => Err(UnequalTypes(Op::Rem)),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Shl<ConstInt> for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn shl(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n+            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Shr<ConstInt> for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn shr(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shl))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n+            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Neg for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn neg(self) -> Result<Self, ConstMathErr> {\n+        match self {\n+            I8(a) => Ok(I8(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n+            U8(0) => Ok(U8(0)),\n+            U16(0) => Ok(U16(0)),\n+            U32(0) => Ok(U32(0)),\n+            U64(0) => Ok(U64(0)),\n+            Usize(Us32(0)) => Ok(Usize(Us32(0))),\n+            Usize(Us64(0)) => Ok(Usize(Us64(0))),\n+            U8(_) => Err(UnsignedNegation),\n+            U16(_) => Err(UnsignedNegation),\n+            U32(_) => Err(UnsignedNegation),\n+            U64(_) => Err(UnsignedNegation),\n+            Usize(_) => Err(UnsignedNegation),\n+            Infer(a @ 0...as_u64::I64MAX) => Ok(InferSigned(-(a as i64))),\n+            Infer(_) => Err(Overflow(Op::Neg)),\n+            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n+        }\n+    }\n+}\n+\n+impl ::std::ops::Not for ConstInt {\n+    type Output = Result<Self, ConstMathErr>;\n+    fn not(self) -> Result<Self, ConstMathErr> {\n+        match self {\n+            I8(a) => Ok(I8(!a)),\n+            I16(a) => Ok(I16(!a)),\n+            I32(a) => Ok(I32(!a)),\n+            I64(a) => Ok(I64(!a)),\n+            Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n+            Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n+            U8(a) => Ok(U8(!a)),\n+            U16(a) => Ok(U16(!a)),\n+            U32(a) => Ok(U32(!a)),\n+            U64(a) => Ok(U64(!a)),\n+            Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n+            Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n+            Infer(a) => Ok(Infer(!a)),\n+            InferSigned(a) => Ok(InferSigned(!a)),\n+        }\n+    }\n+}"}, {"sha": "082c6510f8bc961308387571b40c2e2c71ffc5ce", "filename": "src/librustc_const_eval/is.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fis.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use super::err::*;\n+\n+/// Depending on the target only one variant is ever used in a compilation.\n+/// Anything else is an error. This invariant is checked at several locations\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstIsize {\n+    Is32(i32),\n+    Is64(i64),\n+}\n+pub use self::ConstIsize::*;\n+\n+impl ConstIsize {\n+    pub fn as_i64(self, target_int_ty: ast::IntTy) -> i64 {\n+        match (self, target_int_ty) {\n+            (Is32(i), ast::IntTy::I32) => i as i64,\n+            (Is64(i), ast::IntTy::I64) => i,\n+            _ => panic!(\"got invalid isize size for target\"),\n+        }\n+    }\n+    pub fn new(i: i64, target_int_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n+        match target_int_ty {\n+            ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n+            ast::IntTy::I32 => Err(LitOutOfRange(ast::IntTy::Is)),\n+            ast::IntTy::I64 => Ok(Is64(i)),\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "e4c702f643b201f9c694ef7c5d7bd26c91db453e", "filename": "src/librustc_const_eval/lib.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rusty Mathematics\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_const_eval\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+extern crate serialize as rustc_serialize; // used by deriving\n+\n+mod int;\n+mod us;\n+mod is;\n+mod err;\n+\n+pub use int::*;\n+pub use us::*;\n+pub use is::*;\n+pub use err::ConstMathErr;"}, {"sha": "e5a7086d43663c1ba93b889c5891ee0b8228bac1", "filename": "src/librustc_const_eval/us.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_const_eval%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fus.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use super::err::*;\n+\n+/// Depending on the target only one variant is ever used in a compilation.\n+/// Anything else is an error. This invariant is checked at several locations\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n+pub enum ConstUsize {\n+    Us32(u32),\n+    Us64(u64),\n+}\n+pub use self::ConstUsize::*;\n+\n+impl ConstUsize {\n+    pub fn as_u64(self, target_uint_ty: ast::UintTy) -> u64 {\n+        match (self, target_uint_ty) {\n+            (Us32(i), ast::UintTy::U32) => i as u64,\n+            (Us64(i), ast::UintTy::U64) => i,\n+            _ => panic!(\"got invalid usize size for target\"),\n+        }\n+    }\n+    pub fn new(i: u64, target_uint_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n+        match target_uint_ty {\n+            ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n+            ast::UintTy::U32 => Err(ULitOutOfRange(ast::UintTy::Us)),\n+            ast::UintTy::U64 => Ok(Us64(i)),\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "4d844bbf032b6f2d23b8fde149cad38dbcda9cc1", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -143,8 +143,11 @@ impl LateLintPass for TypeLimits {\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n-                                Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n-                                Ok(ConstVal::Uint(shift)) => { shift >= bits },\n+                                Ok(ConstVal::Integral(i)) => {\n+                                    i.is_negative() || i.to_u64()\n+                                                        .map(|i| i >= bits)\n+                                                        .unwrap_or(true)\n+                                },\n                                 _ => { false }\n                             }\n                         };"}, {"sha": "dfc794dc5b8744a225aaaa89f455243f8cf94e71", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -35,6 +35,8 @@ use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable, VariantKind};\n \n+use rustc_const_eval::ConstInt;\n+\n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n \n@@ -198,7 +200,7 @@ fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n     reader::tagged_docs(d, tag_items_data_item_reexport)\n }\n \n-fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n+fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n             str::from_utf8(data).ok().and_then(|s| s.parse().ok())\n@@ -396,7 +398,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                 did: did,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n-                disr_val: disr,\n+                disr_val: ConstInt::Infer(disr),\n                 kind: expect_variant_kind(item_family(item), tcx),\n             }\n         }).collect()\n@@ -432,7 +434,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             did: did,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n-            disr_val: 0,\n+            disr_val: ConstInt::Infer(0),\n             kind: expect_variant_kind(item_family(doc), tcx),\n         }\n     }"}, {"sha": "3dc0e53b254c428dc41c048430e5c94d913e1d76", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -26,6 +26,7 @@ use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::subst;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::util::IntTypeExt;\n \n use rustc::back::svh::Svh;\n use rustc::front::map::{LinkedPath, PathElem, PathElems};\n@@ -238,7 +239,8 @@ fn encode_symbol(ecx: &EncodeContext,\n fn encode_disr_val(_: &EncodeContext,\n                    rbml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n-    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_string());\n+    // convert to u64 so just the number is printed, without any type info\n+    rbml_w.wr_tagged_str(tag_disr_val, &disr_val.to_u64_unchecked().to_string());\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n@@ -262,13 +264,14 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n \n fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n-                                      id: NodeId,\n+                                      did: DefId,\n                                       vis: hir::Visibility,\n                                       index: &mut CrateIndex<'tcx>) {\n-    debug!(\"encode_enum_variant_info(id={})\", id);\n-\n-    let mut disr_val = 0;\n-    let def = ecx.tcx.lookup_adt_def(ecx.tcx.map.local_def_id(id));\n+    debug!(\"encode_enum_variant_info(did={:?})\", did);\n+    let repr_hints = ecx.tcx.lookup_repr_hints(did);\n+    let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n+    let mut disr_val = repr_type.initial_discriminant(&ecx.tcx);\n+    let def = ecx.tcx.lookup_adt_def(did);\n     for variant in &def.variants {\n         let vid = variant.did;\n         let variant_node_id = ecx.local_id(vid);\n@@ -290,7 +293,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             ty::VariantKind::Unit => 'w',\n         });\n         encode_name(rbml_w, variant.name);\n-        encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(id));\n+        encode_parent_item(rbml_w, did);\n         encode_visibility(rbml_w, vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n@@ -313,7 +316,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n-        disr_val = disr_val.wrapping_add(1);\n+        disr_val = disr_val.wrap_incr();\n     }\n }\n \n@@ -1035,7 +1038,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n-                                 item.id,\n+                                 def_id,\n                                  vis,\n                                  index);\n       }"}, {"sha": "f0f0fb847540a58303657908cdc5e12c76de031b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -36,6 +36,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_front;\n extern crate rustc_llvm;\n+extern crate rustc_const_eval;\n \n pub use rustc::middle;\n "}, {"sha": "9ecbf748d7c8311f4de4205a64e67e34946232fc", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -269,7 +269,7 @@ enum TestKind<'tcx> {\n \n     // test length of the slice is equal to len\n     Len {\n-        len: usize,\n+        len: u64,\n         op: BinOp,\n     },\n }"}, {"sha": "d42c8ff7bd79fab67f204babfd78e5ac6f8fb703", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -84,7 +84,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 };\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Len { len: len, op: op },\n+                    kind: TestKind::Len { len: len as u64, op: op },\n                 }\n             }\n "}, {"sha": "13ab26c358d6a6a9fd6d52637a22e42ff1c24e30", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -46,7 +46,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         Operand::Constant(constant)\n     }\n \n-    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: usize) -> Lvalue<'tcx> {\n+    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: u64) -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant("}, {"sha": "6d411b9c07b311dc5394b1bc2cc0c4b946d53f8c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -94,6 +94,8 @@ use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n@@ -517,7 +519,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }, Constant {\n             span: span,\n             ty: self.hir.tcx().types.u32,\n-            literal: self.hir.usize_literal(span_lines.line)\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::U32(span_lines.line as u32)),\n+            },\n         })\n     }\n "}, {"sha": "1f8a5da9c1b9d598d89e32719cbab9c8a5d9abbc", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -10,12 +10,13 @@\n \n use hair::*;\n use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_const_eval::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::def::Def;\n-use rustc::middle::const_eval;\n+use rustc::middle::const_eval::{self, ConstVal};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::pat_util;\n use rustc::middle::ty::{self, VariantDef, Ty};\n@@ -227,28 +228,37 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 }\n             }\n \n-            hir::ExprUnary(op, ref arg) => {\n+            hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n                 if cx.tcx.is_method_call(self.id) {\n                     overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n                                         PassArgs::ByValue, arg.to_ref(), vec![])\n                 } else {\n-                    // FIXME overflow\n-                    let op = match op {\n-                        hir::UnOp::UnNot => UnOp::Not,\n-                        hir::UnOp::UnNeg => UnOp::Neg,\n-                        hir::UnOp::UnDeref => {\n-                            cx.tcx.sess.span_bug(\n-                                self.span,\n-                                \"UnDeref should have been handled elsewhere\");\n-                        }\n-                    };\n                     ExprKind::Unary {\n-                        op: op,\n+                        op: UnOp::Not,\n                         arg: arg.to_ref(),\n                     }\n                 }\n             }\n \n+            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+                if cx.tcx.is_method_call(self.id) {\n+                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n+                                        PassArgs::ByValue, arg.to_ref(), vec![])\n+                } else {\n+                    // FIXME runtime-overflow\n+                    if let hir::ExprLit(_) = arg.node {\n+                        ExprKind::Literal {\n+                            literal: cx.const_eval_literal(self),\n+                        }\n+                    } else {\n+                        ExprKind::Unary {\n+                            op: UnOp::Neg,\n+                            arg: arg.to_ref(),\n+                        }\n+                    }\n+                }\n+            }\n+\n             hir::ExprStruct(_, ref fields, ref base) => {\n                 match expr_ty.sty {\n                     ty::TyStruct(adt, substs) => {\n@@ -338,7 +348,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 count: TypedConstVal {\n                     ty: cx.tcx.expr_ty(c),\n                     span: c.span,\n-                    value: const_eval::eval_const_expr(cx.tcx, c)\n+                    value: match const_eval::eval_const_expr(cx.tcx, c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => panic!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 }\n             },\n             hir::ExprRet(ref v) =>"}, {"sha": "fd4cf7c04734a6124966936ea0b463976aa1d5b0", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::ty::{self, Ty, TyCtxt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use rustc_front::hir;\n+use rustc_const_eval::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'tcx: 'a> {\n@@ -50,8 +51,11 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Uint(value as u64) }\n+    pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n+        match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Err(_) => panic!(\"usize literal out of range for target\"),\n+        }\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {"}, {"sha": "7c8c8945bbc9109dd2cf4c719ed3525fc00ce9d5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -31,6 +31,7 @@ extern crate rustc_data_structures;\n extern crate rustc_front;\n extern crate rustc_back;\n extern crate syntax;\n+extern crate rustc_const_eval;\n \n pub mod build;\n pub mod graphviz;"}, {"sha": "d7e79e46720b37749bf14110bc5ba8f8bcd2a38e", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -50,6 +50,7 @@ pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n+extern crate rustc_const_eval;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "320bb1eab3c63fb66cd64a6a89330b0117d44e13", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -1035,7 +1035,7 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n     match ity {\n         attr::UnsignedInt(_) => {\n             assert!(min <= discr);\n-            assert!(discr <= max)\n+            assert!(discr <= max);\n         },\n         attr::SignedInt(_) => {\n             assert!(min.0 as i64 <= discr.0 as i64);"}, {"sha": "ebe19aa972ce540b522ff2b4b143c57b57e469b0", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -15,15 +15,7 @@ use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use middle::cstore::LOCAL_CRATE;\n-use middle::const_eval::{self, ConstVal, ConstEvalErr};\n-use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n-use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n-use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n-use middle::const_eval::{const_int_checked_mul, const_uint_checked_mul};\n-use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n-use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n-use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n-use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n+use middle::const_eval::{self, ConstEvalErr};\n use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n@@ -42,9 +34,10 @@ use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n+use rustc_const_eval::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n \n use rustc_front::hir;\n \n@@ -469,35 +462,70 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n         // Catch this up front by looking for ExprLit directly,\n         // and just accepting it.\n         if let hir::ExprLit(_) = inner_e.node { return Ok(()); }\n-\n-        let result = match t.sty {\n-            ty::TyInt(int_type) => {\n-                let input = match const_to_opt_int(te) {\n-                    Some(v) => v,\n-                    None => return Ok(()),\n-                };\n-                const_int_checked_neg(\n-                    input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n-            }\n-            ty::TyUint(uint_type) => {\n-                let input = match const_to_opt_uint(te) {\n-                    Some(v) => v,\n-                    None => return Ok(()),\n-                };\n-                const_uint_checked_neg(\n-                    input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n-            }\n-            _ => return Ok(()),\n+        let cval = match to_const_int(te, t, cx.tcx()) {\n+            Some(v) => v,\n+            None => return Ok(()),\n         };\n-        const_err(cx, e, result, trueconst)\n+        match -cval {\n+            Ok(_) => return Ok(()),\n+            Err(err) => const_err(cx, e, Err(err), trueconst),\n+        }\n     } else {\n         Ok(())\n     }\n }\n \n+fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n+    match t.sty {\n+        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n+            ast::IntTy::I8 => {\n+                assert_eq!(input as i8 as i64, input);\n+                Some(ConstInt::I8(input as i8))\n+            },\n+            ast::IntTy::I16 => {\n+                assert_eq!(input as i16 as i64, input);\n+                Some(ConstInt::I16(input as i16))\n+            },\n+            ast::IntTy::I32 => {\n+                assert_eq!(input as i32 as i64, input);\n+                Some(ConstInt::I32(input as i32))\n+            },\n+            ast::IntTy::I64 => {\n+                Some(ConstInt::I64(input))\n+            },\n+            ast::IntTy::Is => {\n+                ConstIsize::new(input, tcx.sess.target.int_type)\n+                    .ok().map(ConstInt::Isize)\n+            },\n+        }),\n+        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n+            ast::UintTy::U8 => {\n+                assert_eq!(input as u8 as u64, input);\n+                Some(ConstInt::U8(input as u8))\n+            },\n+            ast::UintTy::U16 => {\n+                assert_eq!(input as u16 as u64, input);\n+                Some(ConstInt::U16(input as u16))\n+            },\n+            ast::UintTy::U32 => {\n+                assert_eq!(input as u32 as u64, input);\n+                Some(ConstInt::U32(input as u32))\n+            },\n+            ast::UintTy::U64 => {\n+                Some(ConstInt::U64(input))\n+            },\n+            ast::UintTy::Us => {\n+                ConstUsize::new(input, tcx.sess.target.uint_type)\n+                    .ok().map(ConstInt::Usize)\n+            },\n+        }),\n+        _ => None,\n+    }\n+}\n+\n fn const_err(cx: &CrateContext,\n              e: &hir::Expr,\n-             result: Result<ConstVal, ConstEvalErr>,\n+             result: Result<ConstInt, ConstMathErr>,\n              trueconst: TrueConst)\n              -> Result<(), ConstEvalFailure> {\n     match (result, trueconst) {\n@@ -506,10 +534,12 @@ fn const_err(cx: &CrateContext,\n             Ok(())\n         },\n         (Err(err), TrueConst::Yes) => {\n+            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n             cx.tcx().sess.span_err(e.span, &err.description());\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n+            let err = ConstEvalErr{ span: e.span, kind: const_eval::ErrKind::Math(err) };\n             cx.tcx().sess.span_warn(e.span, &err.description());\n             Err(Runtime(err))\n         },\n@@ -520,46 +550,18 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                               te1: ValueRef, te2: ValueRef,\n                               trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n     let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { unreachable!() };\n-\n-    let result = match t.sty {\n-        ty::TyInt(int_type) => {\n-            let (lhs, rhs) = match (const_to_opt_int(te1),\n-                                    const_to_opt_int(te2)) {\n-                (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return Ok(()),\n-            };\n-\n-            let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n-            match b.node {\n-                hir::BiAdd => const_int_checked_add(lhs, rhs, e, opt_ety),\n-                hir::BiSub => const_int_checked_sub(lhs, rhs, e, opt_ety),\n-                hir::BiMul => const_int_checked_mul(lhs, rhs, e, opt_ety),\n-                hir::BiDiv => const_int_checked_div(lhs, rhs, e, opt_ety),\n-                hir::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n-                hir::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n-                hir::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return Ok(()),\n-            }\n-        }\n-        ty::TyUint(uint_type) => {\n-            let (lhs, rhs) = match (const_to_opt_uint(te1),\n-                                    const_to_opt_uint(te2)) {\n-                (Some(v1), Some(v2)) => (v1, v2),\n-                _ => return Ok(()),\n-            };\n-\n-            let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n-            match b.node {\n-                hir::BiAdd => const_uint_checked_add(lhs, rhs, e, opt_ety),\n-                hir::BiSub => const_uint_checked_sub(lhs, rhs, e, opt_ety),\n-                hir::BiMul => const_uint_checked_mul(lhs, rhs, e, opt_ety),\n-                hir::BiDiv => const_uint_checked_div(lhs, rhs, e, opt_ety),\n-                hir::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n-                hir::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n-                hir::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n-                _ => return Ok(()),\n-            }\n-        }\n+    let (lhs, rhs) = match (to_const_int(te1, t, cx.tcx()), to_const_int(te2, t, cx.tcx())) {\n+        (Some(v1), Some(v2)) => (v1, v2),\n+        _ => return Ok(()),\n+    };\n+    let result = match b.node {\n+        hir::BiAdd => lhs + rhs,\n+        hir::BiSub => lhs - rhs,\n+        hir::BiMul => lhs * rhs,\n+        hir::BiDiv => lhs / rhs,\n+        hir::BiRem => lhs % rhs,\n+        hir::BiShl => lhs << rhs,\n+        hir::BiShr => lhs >> rhs,\n         _ => return Ok(()),\n     };\n     const_err(cx, e, result, trueconst)"}, {"sha": "e22d42e9d28da5f7f9faa28a363115cf7226c25b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -1597,7 +1597,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n-                    v.disr_val as u64)\n+                    v.disr_val.to_u64_unchecked())\n             }\n         })\n         .collect();"}, {"sha": "d74c1ac50ad74b14ec703ab494c53adb356c0178", "filename": "src/librustc_trans/trans/disr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -26,7 +26,7 @@ impl ::std::ops::BitAnd for Disr {\n \n impl From<::middle::ty::Disr> for Disr {\n     fn from(i: ::middle::ty::Disr) -> Disr {\n-        Disr(i)\n+        Disr(i.to_u64_unchecked())\n     }\n }\n "}, {"sha": "2c251a4cd578c9e32772bde91c59236c41098e65", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -12,13 +12,15 @@ use back::abi;\n use llvm::ValueRef;\n use middle::ty::{Ty, TypeFoldable};\n use rustc::middle::const_eval::{self, ConstVal};\n+use rustc_const_eval::ConstInt::*;\n use rustc::mir::repr as mir;\n use trans::common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n                     C_str_slice, C_nil, C_undef};\n use trans::consts;\n use trans::expr;\n use trans::inline;\n use trans::type_of;\n+use trans::type_::Type;\n \n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n@@ -63,8 +65,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match *cv {\n             ConstVal::Float(v) => C_floating_f64(v, llty),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Int(v) => C_integral(llty, v as u64, true),\n-            ConstVal::Uint(v) => C_integral(llty, v, false),\n+            ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n+            ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n+            ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n+            ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n+            ConstVal::Integral(Isize(v)) => {\n+                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n+                C_integral(Type::int(ccx), i as u64, true)\n+            },\n+            ConstVal::Integral(U8(v)) => C_integral(Type::i8(ccx), v as u64, false),\n+            ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n+            ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n+            ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n+            ConstVal::Integral(Usize(v)) => {\n+                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n+                C_integral(Type::int(ccx), u, false)\n+            },\n+            ConstVal::Integral(Infer(v)) => C_integral(llty, v as u64, false),\n+            ConstVal::Integral(InferSigned(v)) => C_integral(llty, v as u64, true),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(id) | ConstVal::Tuple(id) |\n@@ -74,6 +92,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     expr::trans(bcx, expr).datum.val\n                 })\n             },\n+            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Function(_) => C_nil(ccx)\n         }\n     }\n@@ -99,7 +118,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), def_id);\n                 let expr = const_eval::lookup_const_by_id(bcx.tcx(), def_id, None, Some(substs))\n-                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                            .expect(\"def was const, but lookup_const_by_id failed\").0;\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n                 let d = bcx.with_block(|bcx| {"}, {"sha": "ea80af14f1f2f18528d3470aca9ddab0d5124d71", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -11,6 +11,8 @@\n use llvm::ValueRef;\n use rustc::middle::ty::{self, Ty};\n use middle::ty::cast::{CastTy, IntTy};\n+use middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n use rustc::mir::repr as mir;\n \n use trans::asm;\n@@ -95,7 +97,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = self.trans_constval(&bcx, &count.value, count.ty).immediate();\n+                let count = ConstVal::Integral(ConstInt::Usize(count.value));\n+                let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n                 let bcx = bcx.map_block(|block| {\n                     let base = expr::get_dataptr(block, dest.llval);\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {"}, {"sha": "ba56c5d24ab6e286a431f1cbad2dc4527c719ed5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -65,6 +65,8 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::FnvHashSet;\n \n+use rustc_const_eval::ConstInt;\n+\n use syntax::{abi, ast};\n use syntax::codemap::{Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n@@ -1680,22 +1682,16 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         hir::TyFixedLengthVec(ref ty, ref e) => {\n             let hint = UncheckedExprHint(tcx.types.usize);\n             match const_eval::eval_const_expr_partial(tcx, &e, hint, None) {\n-                Ok(r) => {\n-                    match r {\n-                        ConstVal::Int(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n-                                         i as usize),\n-                        ConstVal::Uint(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n-                                         i as usize),\n-                        _ => {\n-                            span_err!(tcx.sess, ast_ty.span, E0249,\n-                                      \"expected constant integer expression \\\n-                                       for array length\");\n-                            this.tcx().types.err\n-                        }\n-                    }\n-                }\n+                Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n+                    let i = i.as_u64(tcx.sess.target.uint_type);\n+                    assert_eq!(i as usize as u64, i);\n+                    tcx.mk_array(ast_ty_to_ty(this, rscope, &ty), i as usize)\n+                },\n+                Ok(val) => {\n+                    span_err!(tcx.sess, ast_ty.span, E0249,\n+                              \"expected usize value for array length, got {}\", val.description());\n+                    this.tcx().types.err\n+                },\n                 Err(ref r) => {\n                     let mut err = struct_span_err!(tcx.sess, r.span, E0250,\n                                                    \"array length constant evaluation error: {}\","}, {"sha": "19731407d9e7a302cb03dc92aace2354d9aad701", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -94,15 +94,15 @@ use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{GenericPredicates, TypeScheme};\n-use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n+use middle::ty::{ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use middle::ty::{self, ToPolyTraitRef, Ty, TyCtxt};\n use middle::ty::{MethodCall, MethodCallee};\n use middle::ty::adjustment;\n use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::relate::TypeRelation;\n-use middle::ty::util::Representability;\n+use middle::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n@@ -4076,34 +4076,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     sp: Span,\n                                     vs: &'tcx [hir::Variant],\n                                     id: ast::NodeId) {\n-    // disr_in_range should be removed once we have forced type hints for consts\n-    fn disr_in_range(ccx: &CrateCtxt,\n-                     ty: attr::IntType,\n-                     disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n-            match ty {\n-                ast::UintTy::U8 => disr as u8 as Disr == disr,\n-                ast::UintTy::U16 => disr as u16 as Disr == disr,\n-                ast::UintTy::U32 => disr as u32 as Disr == disr,\n-                ast::UintTy::U64 => disr as u64 as Disr == disr,\n-                ast::UintTy::Us => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n-            }\n-        }\n-        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n-            match ty {\n-                ast::IntTy::I8 => disr as i8 as Disr == disr,\n-                ast::IntTy::I16 => disr as i16 as Disr == disr,\n-                ast::IntTy::I32 => disr as i32 as Disr == disr,\n-                ast::IntTy::I64 => disr as i64 as Disr == disr,\n-                ast::IntTy::Is => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n-            }\n-        }\n-        match ty {\n-            attr::UnsignedInt(ty) => uint_in_range(ccx, ty, disr),\n-            attr::SignedInt(ty) => int_in_range(ccx, ty, disr)\n-        }\n-    }\n-\n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                           vs: &'tcx [hir::Variant],\n                           id: ast::NodeId,\n@@ -4117,7 +4089,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let inh = static_inherited_fields(ccx, &tables);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-        let (_, repr_type_ty) = ccx.tcx.enum_repr_type(Some(&hint));\n+        let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(&ccx.tcx);\n         for v in vs {\n             if let Some(ref e) = v.node.disr_expr {\n                 check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n@@ -4142,23 +4114,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n                 None => {}\n             }\n-            // Check for unrepresentable discriminant values\n-            match hint {\n-                attr::ReprAny | attr::ReprExtern => {\n-                    disr_vals.push(current_disr_val);\n-                }\n-                attr::ReprInt(sp, ity) => {\n-                    if !disr_in_range(ccx, ity, current_disr_val) {\n-                        let mut err = struct_span_err!(ccx.tcx.sess, v.span, E0082,\n-                            \"discriminant value outside specified type\");\n-                        span_note!(&mut err, sp,\n-                            \"discriminant type specified here\");\n-                        err.emit();\n-                    }\n-                }\n-                // Error reported elsewhere.\n-                attr::ReprSimd | attr::ReprPacked => {}\n-            }\n+            disr_vals.push(current_disr_val);\n         }\n     }\n "}, {"sha": "e0d4e128cf5ccf98708be1c3b0367083aba5040f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -80,6 +80,8 @@ use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use write_ty_to_tcx;\n \n+use rustc_const_eval::ConstInt;\n+\n use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n@@ -1021,7 +1023,7 @@ fn convert_struct_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, ctor_id, it.name, 0, def)]\n+        vec![convert_struct_variant(tcx, ctor_id, it.name, ConstInt::Infer(0), def)]\n     )\n }\n \n@@ -1030,24 +1032,39 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n                           def: &hir::EnumDef)\n                           -> ty::AdtDefMaster<'tcx>\n {\n+    fn print_err(tcx: &TyCtxt, span: Span, ty: ty::Ty, cv: ConstVal) {\n+        span_err!(tcx.sess, span, E0079, \"mismatched types: expected `{}` got `{}`\",\n+                  ty, cv.description());\n+    }\n     fn evaluate_disr_expr<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                repr_ty: Ty<'tcx>,\n+                                repr_ty: attr::IntType,\n                                 e: &hir::Expr) -> Option<ty::Disr> {\n         debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n \n-        let hint = UncheckedExprHint(repr_ty);\n+        let ty_hint = repr_ty.to_ty(tcx);\n+        let hint = UncheckedExprHint(ty_hint);\n         match const_eval::eval_const_expr_partial(tcx, e, hint, None) {\n-            Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n-            Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n-            Ok(_) => {\n-                let sign_desc = if repr_ty.is_signed() {\n-                    \"signed\"\n-                } else {\n-                    \"unsigned\"\n-                };\n-                span_err!(tcx.sess, e.span, E0079,\n-                          \"expected {} integer constant\",\n-                          sign_desc);\n+            Ok(ConstVal::Integral(i)) => {\n+                // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n+                match (repr_ty, i) {\n+                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => Some(i),\n+                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => Some(i),\n+                    (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n+                    (_, i) => {\n+                        print_err(tcx, e.span, ty_hint, ConstVal::Integral(i));\n+                        None\n+                    },\n+                }\n+            },\n+            Ok(cv) => {\n+                print_err(tcx, e.span, ty_hint, cv);\n                 None\n             },\n             Err(err) => {\n@@ -1066,16 +1083,11 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     fn report_discrim_overflow(tcx: &TyCtxt,\n                                variant_span: Span,\n                                variant_name: &str,\n-                               repr_type: attr::IntType,\n                                prev_val: ty::Disr) {\n-        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n-        let computed_value = repr_type.disr_string(computed_value);\n-        let prev_val = repr_type.disr_string(prev_val);\n-        let repr_type = repr_type.to_ty(tcx);\n         span_err!(tcx.sess, variant_span, E0370,\n-                  \"enum discriminant overflowed on value after {}: {}; \\\n+                  \"enum discriminant overflowed on value after {}; \\\n                    set explicitly via {} = {} if that is desired outcome\",\n-                  prev_val, repr_type, variant_name, computed_value);\n+                  prev_val, variant_name, prev_val.wrap_incr());\n     }\n \n     fn next_disr(tcx: &TyCtxt,\n@@ -1085,12 +1097,11 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n         if let Some(prev_disr_val) = prev_disr_val {\n             let result = repr_type.disr_incr(prev_disr_val);\n             if let None = result {\n-                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(),\n-                                             repr_type, prev_disr_val);\n+                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(), prev_disr_val);\n             }\n             result\n         } else {\n-            Some(ty::INITIAL_DISCRIMINANT_VALUE)\n+            Some(repr_type.initial_discriminant(tcx))\n         }\n     }\n     fn convert_enum_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -1104,17 +1115,19 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n     let did = tcx.map.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n-    let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n+    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n     let mut prev_disr = None;\n     let variants = def.variants.iter().map(|v| {\n         let disr = match v.node.disr_expr {\n-            Some(ref e) => evaluate_disr_expr(tcx, repr_type_ty, e),\n+            Some(ref e) => evaluate_disr_expr(tcx, repr_type, e),\n             None => next_disr(tcx, v, repr_type, prev_disr)\n-        }.unwrap_or(repr_type.disr_wrap_incr(prev_disr));\n+        }.unwrap_or_else(|| {\n+            prev_disr.map(ty::Disr::wrap_incr)\n+                     .unwrap_or(repr_type.initial_discriminant(tcx))\n+        });\n \n-        let v = convert_enum_variant(tcx, v, disr);\n         prev_disr = Some(disr);\n-        v\n+        convert_enum_variant(tcx, v, disr)\n     }).collect();\n     tcx.intern_adt_def(tcx.map.local_def_id(it.id), ty::AdtKind::Enum, variants)\n }"}, {"sha": "125c3d426a8036283ee90a0f3271651da917cc4b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -91,6 +91,7 @@ extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n+extern crate rustc_const_eval;\n \n pub use rustc::dep_graph;\n pub use rustc::front;"}, {"sha": "5206f69337290e75dbf51f487ff121fe141398c4", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -16,13 +16,15 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_plugin;\n+extern crate rustc_const_eval;\n extern crate syntax;\n \n use rustc::mir::transform::MirPass;\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n use rustc::middle::infer::InferCtxt;\n use rustc::middle::const_eval::ConstVal;\n+use rustc_const_eval::ConstInt;\n use rustc_plugin::Registry;\n \n struct Pass;\n@@ -37,8 +39,10 @@ struct Visitor;\n \n impl<'tcx> MutVisitor<'tcx> for Visitor {\n     fn visit_literal(&mut self, literal: &mut Literal<'tcx>) {\n-        if let Literal::Value { value: ConstVal::Int(ref mut i @ 11) } = *literal {\n-            *i = 42;\n+        if let Literal::Value { ref mut value } = *literal {\n+            if let ConstVal::Integral(ConstInt::I32(ref mut i @ 11)) = *value {\n+                *i = 42;\n+            }\n         }\n     }\n }"}, {"sha": "4d156a49192fd403fb0b894aafb74292c4865eaf", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -25,9 +25,9 @@ fn main() {\n     //~^ WARN attempted to add with overflow\n     //~^^ WARN attempted to add with overflow\n     let c = 200u8 * 4;\n-    //~^ WARN attempted to mul with overflow\n+    //~^ WARN attempted to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n-    //~^ WARN attempted to sub with overflow\n+    //~^ WARN attempted to subtract with overflow\n     let _e = BLA;\n     black_box(a);\n     black_box(b);"}, {"sha": "07e27a7dc9a9a412b2eb14155044584b7980c325", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -21,10 +21,11 @@ const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n //~^ ERROR constant evaluation error: attempted to negate with overflow\n //~| ERROR attempted to negate with overflow\n+//~| ERROR attempted to negate with overflow\n \n fn main() {\n     match -128i8 {\n-        NEG_NEG_128 => println!(\"A\"),\n+        NEG_NEG_128 => println!(\"A\"), //~ NOTE in pattern here\n         _ => println!(\"B\"),\n     }\n }"}, {"sha": "33fa4aae61151caa7f947426ab10b0511f3f3fe8", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -17,7 +17,7 @@\n // self-hosted and a cross-compiled setup; therefore resorting to\n // error-pattern for now.\n \n-// error-pattern: expected constant integer for repeat count, but attempted to add with overflow\n+// error-pattern: expected constant integer for repeat count, but tried to add two integrals of\n \n #![allow(unused_imports)]\n \n@@ -36,4 +36,3 @@ fn main() {\n fn foo<T:fmt::Debug>(x: T) {\n     println!(\"{:?}\", x);\n }\n-"}, {"sha": "68ef1b4775189439463fd4e9c2f96b1e625e3cd5", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -21,8 +21,7 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR mismatched types\n-    //~| ERROR the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    //~^ ERROR tried to add two integrals of different types [E0250]\n     = [0; (i8::MAX as usize) + 1];\n \n fn main() {"}, {"sha": "3dfcb5bb29a24a68701b48d195f62aca3361240c", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -23,84 +23,84 @@ const VALS_I8: (i8, i8, i8, i8) =\n     (-i8::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i8::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i8::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i8::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I16: (i16, i16, i16, i16) =\n     (-i16::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i16::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i16::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i16::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I32: (i32, i32, i32, i32) =\n     (-i32::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i32::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i32::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i32::MIN * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_I64: (i64, i64, i64, i64) =\n     (-i64::MIN,\n      //~^ ERROR attempted to negate with overflow\n      i64::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      i64::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      i64::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n     (-(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u8::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u8::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n     (-(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u16::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u16::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n     (-(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u32::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u32::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n     (-(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n-     //~^ ERROR attempted to sub with overflow\n+     //~^ ERROR attempted to subtract with overflow\n      u64::MAX + 1,\n      //~^ ERROR attempted to add with overflow\n      u64::MAX * 2,\n-     //~^ ERROR attempted to mul with overflow\n+     //~^ ERROR attempted to multiply with overflow\n      );\n \n fn main() {"}, {"sha": "0d6cf3bab453fac0892aca6ff79efa9986f75507", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -8,32 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR: can't do this op on unsigned integrals\n+const X: usize = 42 && 39; //~ ERROR: can't do this op on integrals\n const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n \n-const X1: usize = 42 || 39; //~ ERROR: can't do this op on unsigned integrals\n+const X1: usize = 42 || 39; //~ ERROR: can't do this op on integrals\n const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n \n-// FIXME: the error should be `on signed integrals`\n-const X2: usize = -42 || -39; //~ ERROR: can't do this op on unsigned integrals\n+const X2: usize = -42 || -39; //~ ERROR: unary negation of unsigned integer\n const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n \n-// FIXME: the error should be `on signed integrals`\n-const X3: usize = -42 && -39; //~ ERROR: can't do this op on unsigned integrals\n+const X3: usize = -42 && -39; //~ ERROR: unary negation of unsigned integer\n const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n \n const Y: usize = 42.0 == 42.0;\n-const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected constant integer expression for array length\n+const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected constant integer expression for array length\n+const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n \n fn main() {\n     let _ = ARR;"}, {"sha": "9c6b774b99039811fb6482e80d2e98c649f5f6aa", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -15,7 +15,7 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+//~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();"}, {"sha": "d51f31087d0df1494c5cce1005433e6839109a92", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -16,5 +16,5 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+    //~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n }"}, {"sha": "9d3c432d14878de269cf86ba9616dc7cc7c9d7af", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -11,7 +11,7 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5 << 64;\n-//~^ ERROR: attempted left shift with overflow [E0250]\n+//~^ ERROR: attempted to shift left with overflow [E0250]\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "0ff740212e8fa46cec39e66a28c8b00de66ce70b", "filename": "src/test/compile-fail/discrim-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -24,7 +24,7 @@ fn f_i8() {\n     enum A {\n         Ok = i8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127i8; set explicitly via OhNo = -128i8 if that is desired outcome\n     }\n }\n \n@@ -33,7 +33,7 @@ fn f_u8() {\n     enum A {\n         Ok = u8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255u8; set explicitly via OhNo = 0u8 if that is desired outcome\n     }\n }\n "}, {"sha": "7316e737b6da8680379b2c617430e54b2703b4ad", "filename": "src/test/compile-fail/discrim-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -22,7 +22,7 @@ fn f_i8() {\n     enum A {\n         Ok = i8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127i8; set explicitly via OhNo = -128i8 if that is desired outcome\n     }\n \n     let x = A::Ok;\n@@ -33,7 +33,7 @@ fn f_u8() {\n     enum A {\n         Ok = u8::MAX - 1,\n         Ok2,\n-        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255u8; set explicitly via OhNo = 0u8 if that is desired outcome\n     }\n \n     let x = A::Ok;"}, {"sha": "d6ba09bb4c5bf072692b9677f3f4883dc99e4951", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -9,46 +9,32 @@\n // except according to those terms.\n \n \n-#[repr(u8)] //~ NOTE discriminant type specified here\n+#[repr(u8)]\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR discriminant value outside specified type\n+    Cu8 = -23, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(i8)] //~ NOTE discriminant type specified here\n-enum Ei8 {\n-    Ai8 = 23,\n-    Bi8 = -23,\n-    Ci8 = 223, //~ ERROR discriminant value outside specified type\n-}\n-\n-#[repr(u16)] //~ NOTE discriminant type specified here\n+#[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR discriminant value outside specified type\n-}\n-\n-#[repr(i16)] //~ NOTE discriminant type specified here\n-enum Ei16 {\n-    Ai16 = 23,\n-    Bi16 = -22333,\n-    Ci16 = 55555, //~ ERROR discriminant value outside specified type\n+    Cu16 = -22333, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(u32)] //~ NOTE discriminant type specified here\n+#[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR discriminant value outside specified type\n+    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n }\n \n-#[repr(i32)] //~ NOTE discriminant type specified here\n-enum Ei32 {\n-    Ai32 = 23,\n-    Bi32 = -2_000_000_000,\n-    Ci32 = 3_000_000_000, //~ ERROR discriminant value outside specified type\n+#[repr(u64)]\n+enum Eu64 {\n+    Au32 = 23,\n+    Bu32 = 3_000_000_000,\n+    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "a25d0a9e1871fdd1ded7a64c6100240acdeac2d4", "filename": "src/test/compile-fail/enum-discrim-too-small2.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small2.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(i8)]\n+enum Ei8 {\n+    Ai8 = 23,\n+    Bi8 = -23,\n+    Ci8 = 223, //~ ERROR literal out of range for i8 [E0080]\n+}\n+\n+#[repr(i16)]\n+enum Ei16 {\n+    Ai16 = 23,\n+    Bi16 = -22333,\n+    Ci16 = 55555, //~ ERROR literal out of range for i16 [E0080]\n+}\n+\n+#[repr(i32)]\n+enum Ei32 {\n+    Ai32 = 23,\n+    Bi32 = -2_000_000_000,\n+    Ci32 = 3_000_000_000, //~ ERROR literal out of range for i32 [E0080]\n+}\n+\n+#[repr(i64)]\n+enum Ei64 {\n+    Ai64 = 23,\n+    Bi64 = -9223372036854775808,\n+    Ci64 = 9223372036854775809, //~ ERROR literal out of range for i64 [E0080]\n+}\n+\n+// u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a\n+// little counterintuitive, but since the discriminant can store all the bits, and extracting it\n+// with a cast requires specifying the signedness, there is no loss of information in those cases.\n+// This also applies to isize and usize on 64-bit targets.\n+\n+pub fn main() { }"}, {"sha": "7ca274b81e574a5c6cf6962b926ddfb3ceff5b05", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -10,7 +10,8 @@\n \n enum test {\n     div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n-    rem_zero = 1%0  //~ERROR constant evaluation error: attempted remainder with a divisor of zero\n+    rem_zero = 1%0,\n+//~^ ERROR constant evaluation error: attempted to calculate the remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "546fc5e3c6063f91ae24b9d1f271697cbb817b76", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -21,22 +21,7 @@ const _MAX: usize = -1;\n //~| HELP use a cast or the `!` operator\n \n fn main() {\n-    let a = -1;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-    let _b : u8 = a; // for infering variable a to u8.\n-\n-    -a;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n-    let _d = -1u8;\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n-    for _ in -10..10u8 {}\n-    //~^ ERROR unary negation of unsigned integer\n-    //~| HELP use a cast or the `!` operator\n-\n+    let x = 5u8;\n+    let _y = -x; //~ ERROR unary negation of unsigned integer\n     -S; // should not trigger the gate; issue 26840\n }"}, {"sha": "05b194345d40534692d57eaa4072262d765c46e7", "filename": "src/test/compile-fail/feature-gate-negate-unsigned0.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that negating unsigned integers doesn't compile\n+\n+struct S;\n+impl std::ops::Neg for S {\n+    type Output = u32;\n+    fn neg(self) -> u32 { 0 }\n+}\n+\n+fn main() {\n+    let a = -1;\n+    //~^ ERROR unary negation of unsigned integer\n+    let _b : u8 = a; // for infering variable a to u8.\n+\n+    let _d = -1u8;\n+    //~^ ERROR unary negation of unsigned integer\n+\n+    for _ in -10..10u8 {}\n+    //~^ ERROR unary negation of unsigned integer\n+\n+    -S; // should not trigger the gate; issue 26840\n+}"}, {"sha": "bdf344dcdfe8da8377ba866e99756a1fb1ad3b39", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -12,12 +12,12 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    B = 1, //~ ERROR discriminant value `1` already exists\n+    B = 1, //~ ERROR discriminant value `1isize` already exists\n     //~^^ NOTE conflicting\n     C = 0,\n-    D, //~ ERROR discriminant value `1` already exists\n+    D, //~ ERROR discriminant value `1isize` already exists\n     //~^^^^^ NOTE conflicting\n-    E = N, //~ ERROR discriminant value `1` already exists\n+    E = N, //~ ERROR discriminant value `1isize` already exists\n     //~^^^^^^^ NOTE conflicting\n }\n "}, {"sha": "fe51d0b69987a5142775be84bf7f3b54364bcac4", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -35,23 +35,23 @@ fn main() {\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-    //~^ ERROR attempted remainder with overflow\n+    //~^ ERROR attempted to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n-    //~^ ERROR attempted remainder with a divisor of zero\n+    //~^ ERROR attempted to calculate the remainder with a divisor of zero\n }"}, {"sha": "da8bd1dc28d981fb60def3d3b819c3b498dd6e02", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -10,13 +10,9 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR mismatched types\n-    //~| expected `isize`\n-    //~| found `i64`\n+    //~^ ERROR mismatched types: expected `isize` got `i64`\n     B = 2u8\n-    //~^ ERROR mismatched types\n-    //~| expected `isize`\n-    //~| found `u8`\n+    //~^ ERROR mismatched types: expected `isize` got `u8`\n }\n \n fn main() {}"}, {"sha": "29929c120c30f75784f2e4bd67adce7ad37be3e1", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -24,11 +24,6 @@ fn bar() -> i8 {\n     return 123;\n }\n \n-fn baz() -> bool {\n-    128 > bar() //~ ERROR comparison is useless due to type limits\n-                //~^ WARNING literal out of range for i8\n-}\n-\n fn bleh() {\n     let u = 42u8;\n     let _ = u > 255; //~ ERROR comparison is useless due to type limits\n@@ -40,11 +35,3 @@ fn bleh() {\n     let _ = u >= 0; //~ ERROR comparison is useless due to type limits\n     let _ = 0 <= u; //~ ERROR comparison is useless due to type limits\n }\n-\n-fn qux() {\n-    let mut i = 1i8;\n-    while 200 != i { //~ ERROR comparison is useless due to type limits\n-                     //~^ WARNING literal out of range for i8\n-        i += 1;\n-    }\n-}"}, {"sha": "20e756c803a9c65757b63d4d39f6a026f9f6797d", "filename": "src/test/compile-fail/lint-type-limits2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits2.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// compile-flags: -D unused-comparisons\n+fn main() { }\n+\n+\n+fn bar() -> i8 {\n+    return 123;\n+}\n+\n+fn baz() -> bool {\n+    128 > bar() //~ ERROR literal out of range for i8\n+}"}, {"sha": "fed4143a6d7a2b1571fffd429684646717c54e27", "filename": "src/test/compile-fail/lint-type-limits3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits3.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// compile-flags: -D unused-comparisons\n+fn main() { }\n+\n+fn qux() {\n+    let mut i = 1i8;\n+    while 200 != i { //~ ERROR literal out of range for i8\n+        i += 1;\n+    }\n+}"}, {"sha": "ce336905c0139e77ea5b6fcd9f47b86e09c7188a", "filename": "src/test/compile-fail/lint-type-overflow.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -25,7 +25,6 @@ fn main() {\n \n     let x2: i8 = -128; // should be OK\n     let x1: i8 = 128; //~ error: literal out of range for i8\n-    let x2: i8 = --128; //~ error: literal out of range for i8\n \n     let x3: i8 = -129; //~ error: literal out of range for i8\n     let x3: i8 = -(129); //~ error: literal out of range for i8\n@@ -54,9 +53,4 @@ fn main() {\n     let x = 18446744073709551615_i64; //~ error: literal out of range for i64\n     let x: i64 = -9223372036854775809; //~ error: literal out of range for i64\n     let x = -9223372036854775809_i64; //~ error: literal out of range for i64\n-\n-    let x = -3.40282348e+38_f32; //~ error: literal out of range for f32\n-    let x =  3.40282348e+38_f32; //~ error: literal out of range for f32\n-    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n-    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n }"}, {"sha": "83300f18c3e95b6f401f8f506dbd7503dacbaabc", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+\n+#![deny(overflowing_literals)]\n+\n+#[allow(unused_variables)]\n+fn main() {\n+    let x2: i8 = --128; //~ error: literal out of range for i8\n+\n+    let x = -3.40282348e+38_f32; //~ error: literal out of range for f32\n+    let x =  3.40282348e+38_f32; //~ error: literal out of range for f32\n+    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+}"}, {"sha": "c0913be1354ca9cc21f1044ab226c0e68f99cd9e", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -44,12 +44,12 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n     //~| found `isize`\n-    //~| ERROR expected positive integer for repeat count, found negative integer [E0306]\n+    //~| ERROR expected positive integer for repeat count, found isize [E0306]\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n     //~| found `isize`\n-    //~| ERROR expected positive integer for repeat count, found negative integer [E0306]\n+    //~| ERROR expected positive integer for repeat count, found isize [E0306]\n     struct G {\n         g: (),\n     }"}, {"sha": "562040dc5620ba2fc54dea65eb878d5bc6bebcd5", "filename": "src/test/run-pass/const-fn.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -10,7 +10,7 @@\n \n // A very basic test of const fn functionality.\n \n-#![feature(const_fn)]\n+#![feature(const_fn, const_indexing)]\n \n const fn add(x: u32, y: u32) -> u32 {\n     x + y\n@@ -24,6 +24,14 @@ const unsafe fn div(x: u32, y: u32) -> u32 {\n     x / y\n }\n \n+const fn generic<T>(t: T) -> T {\n+    t\n+}\n+\n+const fn generic_arr<T: Copy>(t: [T; 1]) -> T {\n+    t[0]\n+}\n+\n const SUM: u32 = add(44, 22);\n const DIFF: u32 = sub(44, 22);\n const DIV: u32 = unsafe{div(44, 22)};\n@@ -36,4 +44,6 @@ fn main() {\n     assert_eq!(DIV, 2);\n \n     let _: [&'static str; sub(100, 99) as usize] = [\"hi\"];\n+    let _: [&'static str; generic(1)] = [\"hi\"];\n+    let _: [&'static str; generic_arr([1])] = [\"hi\"];\n }"}, {"sha": "afd82e7d8aced0ebdc8f53e4a6c5f74bd01fd7fb", "filename": "src/test/run-pass/const-negation.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(const_err)]\n+\n+fn main() {\n+    #[cfg(target_pointer_width = \"32\")]\n+    const I: isize = -2147483648isize;\n+    #[cfg(target_pointer_width = \"64\")]\n+    const I: isize = -9223372036854775808isize;\n+    assert_eq!(::std::i32::MIN as u64, 0xffffffff80000000);\n+    assert_eq!(-2147483648isize as u64, 0xffffffff80000000);\n+    assert_eq!(::std::i64::MIN as u64, 0x8000000000000000);\n+    assert_eq!(-9223372036854775808isize as u64, 0x8000000000000000);\n+    const J: usize = ::std::i32::MAX as usize;\n+    const K: usize = -1i32 as u32 as usize;\n+    const L: usize = ::std::i32::MIN as usize;\n+    const M: usize = ::std::i64::MIN as usize;\n+    match 5 {\n+        J => {},\n+        K => {},\n+        L => {},\n+        M => {},\n+        _ => {}\n+    }\n+    match 5 {\n+        I => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "7d63c41eb26e1215b00d9206bef0c4d07332b9ec", "filename": "src/test/run-pass/issue-23833.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fissue-23833.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fissue-23833.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23833.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 - 1i8) as usize]\n+    = [0; (i8::MAX as usize) - 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "1c8a1322ad2a9d793d383113c827bc955071a524", "filename": "src/test/run-pass/packed-struct-generic-layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-generic-layout.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -20,7 +20,7 @@ struct S<T, S> {\n \n pub fn main() {\n     unsafe {\n-        let s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as i32 };\n+        let s = S { a: 0xff_ff_ff_ffu32, b: 1, c: 0xaa_aa_aa_aa as u32 };\n         let transd : [u8; 9] = mem::transmute(s);\n         // Don't worry about endianness, the numbers are palindromic.\n         assert_eq!(transd,\n@@ -29,7 +29,7 @@ pub fn main() {\n                     0xaa, 0xaa, 0xaa, 0xaa]);\n \n \n-        let s = S { a: 1u8, b: 2u8, c: 0b10000001_10000001 as i16};\n+        let s = S { a: 1u8, b: 2u8, c: 0b10000001_10000001 as u16};\n         let transd : [u8; 4] = mem::transmute(s);\n         // Again, no endianness problems.\n         assert_eq!(transd,"}, {"sha": "5ca6a023099276f90b7da0e04bc24cbd391bfc0b", "filename": "src/test/run-pass/shift.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fshift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bde56e14941924c17daeaa1996d61d0ffdb6bd1/src%2Ftest%2Frun-pass%2Fshift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshift.rs?ref=7bde56e14941924c17daeaa1996d61d0ffdb6bd1", "patch": "@@ -45,7 +45,7 @@ fn test_expr() {\n     let v4 = 4 as isize;\n     let v2 = 2 as isize;\n     assert_eq!(v10 >> v2 as usize, v2 as i8);\n-    assert_eq!(v10 << v4 as usize, 160 as i8);\n+    assert_eq!(v10 << v2 as usize, 40 as i8);\n \n     let v10 = 10 as usize;\n     let v4 = 4 as isize;\n@@ -71,9 +71,9 @@ fn test_const() {\n     assert_eq!(r2_3, 160 as isize);\n \n     static r1_4: i8 = 10i8 >> 2_usize;\n-    static r2_4: i8 = 10i8 << 4_usize;\n+    static r2_4: i8 = 10i8 << 2_usize;\n     assert_eq!(r1_4, 2 as i8);\n-    assert_eq!(r2_4, 160 as i8);\n+    assert_eq!(r2_4, 40 as i8);\n \n     static r1_5: usize = 10_usize >> 2_usize;\n     static r2_5: usize = 10_usize << 4_usize;"}]}