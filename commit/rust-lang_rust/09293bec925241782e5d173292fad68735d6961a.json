{"sha": "09293bec925241782e5d173292fad68735d6961a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MjkzYmVjOTI1MjQxNzgyZTVkMTczMjkyZmFkNjg3MzVkNjk2MWE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-23T15:21:29Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-23T15:21:29Z"}, "message": "Handle anchors in intra doc links", "tree": {"sha": "5b4f148fc50a3cf25c865ceafa1bb6b95bf8fbbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b4f148fc50a3cf25c865ceafa1bb6b95bf8fbbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09293bec925241782e5d173292fad68735d6961a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09293bec925241782e5d173292fad68735d6961a", "html_url": "https://github.com/rust-lang/rust/commit/09293bec925241782e5d173292fad68735d6961a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09293bec925241782e5d173292fad68735d6961a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "html_url": "https://github.com/rust-lang/rust/commit/f1b882b55805c342e46ee4ca3beeef1d1fa2044b"}], "stats": {"total": 78, "additions": 67, "deletions": 11}, "files": [{"sha": "30e7d8d2954aeb709b8ebc62b6496c3c6ffe6893", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/09293bec925241782e5d173292fad68735d6961a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09293bec925241782e5d173292fad68735d6961a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=09293bec925241782e5d173292fad68735d6961a", "patch": "@@ -57,7 +57,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                path_str: &str,\n                ns: Namespace,\n                current_item: &Option<String>,\n-               parent_id: Option<hir::HirId>)\n+               parent_id: Option<hir::HirId>,\n+               extra_fragment: &Option<String>)\n         -> Result<(Res, Option<String>), ()>\n     {\n         let cx = self.cx;\n@@ -80,16 +81,23 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 let value = match res {\n                     Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssocConst, _) => true,\n                     Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n+                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res, extra_fragment),\n                     // Not a trait item; just return what we found.\n+                    Res::PrimTy(..) if extra_fragment.is_some() => {\n+                        // TODO: warn in here! (and don't return Ok)\n+                        return Ok((res, Some(path_str.to_owned())))\n+                    }\n                     Res::PrimTy(..) => return Ok((res, Some(path_str.to_owned()))),\n-                    _ => return Ok((res, None))\n+                    _ => return Ok((res, extra_fragment.clone()))\n                 };\n \n                 if value != (ns == ValueNS) {\n                     return Err(())\n                 }\n             } else if let Some(prim) = is_primitive(path_str, ns) {\n+                //if extra_fragment.is_some() {\n+                    // TODO: warn in here! (and don't return Ok)\n+                //}\n                 return Ok((prim, Some(path_str.to_owned())))\n             } else {\n                 // If resolution failed, it may still be a method\n@@ -153,6 +161,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n+                        //if extra_fragment.is_some() {\n+                            // TODO: warn in here! (and don't return Ok)\n+                        //}\n                         Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).kind {\n@@ -165,6 +176,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n+                                    //if extra_fragment.is_some() {\n+                                        // TODO: warn in here! (and don't return Ok)\n+                                    //}\n                                     Ok((ty_res,\n                                         Some(format!(\"{}.{}\",\n                                                      if def.is_enum() {\n@@ -199,6 +213,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             _ => return Err(())\n                         };\n \n+                        //if extra_fragment.is_some() {\n+                            // TODO: warn in here! (and don't return Ok)\n+                        //}\n                         Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n                     } else {\n                         Err(())\n@@ -289,6 +306,27 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n \n             let link = ori_link.replace(\"`\", \"\");\n+            let parts = link.split('#').collect::<Vec<_>>();\n+            let (link, extra_fragment) = if parts.len() > 2 {\n+                let mut diag = cx.tcx.struct_span_lint_hir(\n+                    lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+                    item_hir_id.unwrap(),\n+                    span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n+                    &format!(\"`[{}]` cannot be resolved, ignoring it...\", ori_link),\n+                );\n+                // TODO: use the correct span!\n+                diag.span_label(DUMMY_SP, \"only one `#` is allowed in a link\");\n+                diag.emit();\n+                continue;\n+            } else if parts.len() == 2 {\n+                if parts[0].trim().is_empty() {\n+                    // This is an anchor to an element of the current page, nothing to do in here!\n+                    continue;\n+                }\n+                (parts[0].to_owned(), Some(parts[1].to_owned()))\n+            } else {\n+                (parts[0].to_owned(), None)\n+            };\n             let (res, fragment) = {\n                 let mut kind = None;\n                 let path_str = if let Some(prefix) =\n@@ -341,7 +379,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match kind {\n                     Some(ns @ ValueNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node,\n+                                                      &extra_fragment) {\n                             res\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -352,7 +391,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(ns @ TypeNS) => {\n-                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node) {\n+                        if let Ok(res) = self.resolve(path_str, ns, &current_item, base_node,\n+                                                      &extra_fragment) {\n                             res\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -363,18 +403,27 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     None => {\n                         // Try everything!\n                         let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str).map(|res| (res, None)),\n+                            macro_ns: macro_resolve(cx, path_str)\n+                                        .map(|res| (res, extra_fragment.clone())),\n                             type_ns: self\n-                                .resolve(path_str, TypeNS, &current_item, base_node)\n+                                .resolve(path_str, TypeNS, &current_item, base_node, &extra_fragment)\n                                 .ok(),\n                             value_ns: self\n-                                .resolve(path_str, ValueNS, &current_item, base_node)\n+                                .resolve(path_str, ValueNS, &current_item, base_node, &extra_fragment)\n                                 .ok()\n                                 .and_then(|(res, fragment)| {\n                                     // Constructors are picked up in the type namespace.\n                                     match res {\n                                         Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => None,\n-                                        _ => Some((res, fragment))\n+                                        _ => match (fragment, extra_fragment) {\n+                                            (Some(fragment), Some(_)) => {\n+                                                // Shouldn't happen but who knows?\n+                                                Some((res, Some(fragment)))\n+                                            }\n+                                            (fragment, None) | (None, fragment) => {\n+                                                Some((res, fragment))\n+                                            }\n+                                        },\n                                     }\n                                 }),\n                         };\n@@ -402,7 +451,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     Some(MacroNS) => {\n                         if let Some(res) = macro_resolve(cx, path_str) {\n-                            (res, None)\n+                            (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n                             continue\n@@ -637,7 +686,11 @@ fn ambiguity_error(\n }\n \n /// Given an enum variant's res, return the res of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext<'_>, res: Res) -> Result<(Res, Option<String>), ()> {\n+fn handle_variant(\n+    cx: &DocContext<'_>,\n+    res: Res,\n+    extra_fragment: &Option<String>,\n+) -> Result<(Res, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n \n     let parent = if let Some(parent) = cx.tcx.parent(res.def_id()) {\n@@ -647,6 +700,9 @@ fn handle_variant(cx: &DocContext<'_>, res: Res) -> Result<(Res, Option<String>)\n     };\n     let parent_def = Res::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_res(res);\n+    if extra_fragment.is_some() {\n+        // TODO warn in here! (and don't return ok)\n+    }\n     Ok((parent_def, Some(format!(\"{}.v\", variant.ident.name))))\n }\n "}]}