{"sha": "891559e30d045606aa109f4991074f783a5e50f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MTU1OWUzMGQwNDU2MDZhYTEwOWY0OTkxMDc0Zjc4M2E1ZTUwZjg=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-10T05:00:13Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-12T15:04:31Z"}, "message": "Clean up core::num doc comments", "tree": {"sha": "eea8743a273954f7d2b96bc4846c5cd38b1057fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea8743a273954f7d2b96bc4846c5cd38b1057fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/891559e30d045606aa109f4991074f783a5e50f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/891559e30d045606aa109f4991074f783a5e50f8", "html_url": "https://github.com/rust-lang/rust/commit/891559e30d045606aa109f4991074f783a5e50f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/891559e30d045606aa109f4991074f783a5e50f8/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878bebfb63db6ea81f1fb738f4eeaa3afb8e55e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/878bebfb63db6ea81f1fb738f4eeaa3afb8e55e4", "html_url": "https://github.com/rust-lang/rust/commit/878bebfb63db6ea81f1fb738f4eeaa3afb8e55e4"}], "stats": {"total": 95, "additions": 45, "deletions": 50}, "files": [{"sha": "6ec6839f0a0a3a7e6bb02cc4e28bf93c82638fdc", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/891559e30d045606aa109f4991074f783a5e50f8/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891559e30d045606aa109f4991074f783a5e50f8/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=891559e30d045606aa109f4991074f783a5e50f8", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! Numeric traits and functions for generic mathematics\n+//! Numeric traits and functions for the built-in numeric types.\n \n #![allow(missing_docs)]\n \n@@ -33,45 +33,36 @@ pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n     (x / y, x % y)\n }\n \n-/// Useful functions for signed numbers (i.e. numbers that can be negative).\n+/// A built-in signed number.\n pub trait Signed: Neg<Self> {\n-    /// Computes the absolute value.\n-    ///\n-    /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.\n-    ///\n-    /// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n+    /// Computes the absolute value of `self`.\n     fn abs(self) -> Self;\n \n-    /// Returns the sign of the number.\n-    ///\n-    /// For `f32` and `f64`:\n-    ///\n-    /// * `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// * `NaN` if the number is `NaN`\n-    ///\n-    /// For signed integers:\n-    ///\n-    /// * `0` if the number is zero\n-    /// * `1` if the number is positive\n-    /// * `-1` if the number is negative\n+    /// Returns a number (either `-1`, `0` or `1`) representing sign of `self`.\n     fn signum(self) -> Self;\n \n-    /// Returns true if the number is positive and false if the number is zero or negative.\n+    /// Returns `true` if `self` is a positive value.\n     fn is_positive(self) -> bool;\n \n-    /// Returns true if the number is negative and false if the number is zero or positive.\n+    /// Returns `true` if `self` is a negative value.\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n         impl Signed for $T {\n+            /// Computes the absolute value. `Int::min_value()` will be returned\n+            /// if the number is `Int::min_value()`.\n             #[inline]\n             fn abs(self) -> $T {\n                 if self.is_negative() { -self } else { self }\n             }\n \n+            /// # Returns\n+            ///\n+            /// - `0` if the number is zero\n+            /// - `1` if the number is positive\n+            /// - `-1` if the number is negative\n             #[inline]\n             fn signum(self) -> $T {\n                 match self {\n@@ -81,9 +72,13 @@ macro_rules! signed_int_impl {\n                 }\n             }\n \n+            /// Returns `true` if `self` is positive and `false` if the number\n+            /// is zero or negative.\n             #[inline]\n             fn is_positive(self) -> bool { self > 0 }\n \n+            /// Returns `true` if `self` is negative and `false` if the number\n+            /// is zero or positive.\n             #[inline]\n             fn is_negative(self) -> bool { self < 0 }\n         }\n@@ -99,7 +94,8 @@ signed_int_impl!(int)\n macro_rules! signed_float_impl {\n     ($T:ty, $fabs:path, $fcopysign:path) => {\n         impl Signed for $T {\n-            /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+            /// Computes the absolute value. Returns `Float::nan()` if the\n+            /// number is `Float::nan()`.\n             #[inline]\n             fn abs(self) -> $T {\n                 unsafe { $fabs(self) }\n@@ -144,7 +140,7 @@ signed_float_impl!(f64,\n     intrinsics::fabsf64,\n     intrinsics::copysignf64)\n \n-/// Raises a value to the power of exp, using exponentiation by squaring.\n+/// Raises a `base` to the power of `exp`, using exponentiation by squaring.\n ///\n /// # Example\n ///\n@@ -169,8 +165,7 @@ pub fn pow<T: Int>(mut base: T, mut exp: uint) -> T {\n     }\n }\n \n-/// A primitive signed or unsigned integer equipped with various bitwise\n-/// operators, bit counting methods, and endian conversion functions.\n+/// A built-in signed or unsigned integer.\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -188,23 +183,23 @@ pub trait Int\n     + Shl<uint,Self>\n     + Shr<uint,Self>\n {\n-    /// Returns the `0` value of this integer.\n+    /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n     fn zero() -> Self;\n \n-    /// Returns the `1` value of this integer.\n+    /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n     fn one() -> Self;\n \n-    /// Returns the smallest value that can be represented by this integer.\n+    /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n     fn min_value() -> Self;\n \n-    /// Returns the largest value that can be represented by this integer.\n+    /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n     fn max_value() -> Self;\n \n-    /// Returns the number of ones in the binary representation of the integer.\n+    /// Returns the number of ones in the binary representation of `self`.\n     ///\n     /// # Example\n     ///\n@@ -215,7 +210,7 @@ pub trait Int\n     /// ```\n     fn count_ones(self) -> uint;\n \n-    /// Returns the number of zeros in the binary representation of the integer.\n+    /// Returns the number of zeros in the binary representation of `self`.\n     ///\n     /// # Example\n     ///\n@@ -230,7 +225,7 @@ pub trait Int\n     }\n \n     /// Returns the number of leading zeros in the binary representation\n-    /// of the integer.\n+    /// of `self`.\n     ///\n     /// # Example\n     ///\n@@ -242,7 +237,7 @@ pub trait Int\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n-    /// of the integer.\n+    /// of `self`.\n     ///\n     /// # Example\n     ///\n@@ -331,7 +326,7 @@ pub trait Int\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n     }\n \n-    /// Convert the integer to big endian from the target's endianness.\n+    /// Convert `self` to big endian from the target's endianness.\n     ///\n     /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n@@ -351,7 +346,7 @@ pub trait Int\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n     }\n \n-    /// Convert the integer to little endian from the target's endianness.\n+    /// Convert `self` to little endian from the target's endianness.\n     ///\n     /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n@@ -371,8 +366,8 @@ pub trait Int\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n     }\n \n-    /// Adds two numbers, checking for overflow. If overflow occurs, `None` is\n-    /// returned.\n+    /// Checked integer addition. Computes `self + other`, returning `None` if\n+    /// overflow occurred.\n     ///\n     /// # Example\n     ///\n@@ -384,8 +379,8 @@ pub trait Int\n     /// ```\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n-    /// Subtracts two numbers, checking for underflow. If underflow occurs,\n-    /// `None` is returned.\n+    /// Checked integer subtraction. Computes `self + other`, returning `None`\n+    /// if underflow occurred.\n     ///\n     /// # Example\n     ///\n@@ -397,8 +392,8 @@ pub trait Int\n     /// ```\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n-    /// Multiplies two numbers, checking for underflow or overflow. If underflow\n-    /// or overflow occurs, `None` is returned.\n+    /// Checked integer multiplication. Computes `self + other`, returning\n+    /// `None` if underflow or overflow occurred.\n     ///\n     /// # Example\n     ///\n@@ -410,8 +405,8 @@ pub trait Int\n     /// ```\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n-    /// Divides two numbers, checking for underflow, overflow and division by\n-    /// zero. If underflow occurs, `None` is returned.\n+    /// Checked integer division. Computes `self + other` returning `None` if\n+    /// `self == 0` or the operation results in underflow or overflow.\n     ///\n     /// # Example\n     ///\n@@ -425,8 +420,8 @@ pub trait Int\n     #[inline]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n-    /// Saturating addition. Returns `self + other`, saturating at the\n-    /// numeric bounds instead of overflowing.\n+    /// Saturating integer addition. Computes `self + other`, saturating at\n+    /// the numeric bounds instead of overflowing.\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -436,8 +431,8 @@ pub trait Int\n         }\n     }\n \n-    /// Saturating subtraction. Returns `self - other`, saturating at the\n-    /// numeric bounds instead of overflowing.\n+    /// Saturating integer subtraction. Computes `self - other`, saturating at\n+    /// the numeric bounds instead of overflowing.\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -685,7 +680,7 @@ int_impl!(int = i64, u64, 64,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow)\n \n-/// Unsigned integers\n+/// A built-in unsigned integer.\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n     fn is_power_of_two(self) -> bool {\n@@ -1229,7 +1224,7 @@ pub enum FPCategory {\n     FPNormal,\n }\n \n-/// Operations on the built-in floating point numbers.\n+/// A built-in floating point number.\n // FIXME(#5527): In a future version of Rust, many of these functions will\n //               become constants.\n //"}]}