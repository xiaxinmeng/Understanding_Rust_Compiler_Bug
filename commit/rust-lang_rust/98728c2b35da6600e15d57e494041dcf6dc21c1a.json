{"sha": "98728c2b35da6600e15d57e494041dcf6dc21c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NzI4YzJiMzVkYTY2MDBlMTVkNTdlNDk0MDQxZGNmNmRjMjFjMWE=", "commit": {"author": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-10T15:47:50Z"}, "committer": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-10T15:47:50Z"}, "message": "Implement changes suggested by tmiasko and davidtwco", "tree": {"sha": "575c194d960a22d7462daa76b6bb688268c26b94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/575c194d960a22d7462daa76b6bb688268c26b94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98728c2b35da6600e15d57e494041dcf6dc21c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98728c2b35da6600e15d57e494041dcf6dc21c1a", "html_url": "https://github.com/rust-lang/rust/commit/98728c2b35da6600e15d57e494041dcf6dc21c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98728c2b35da6600e15d57e494041dcf6dc21c1a/comments", "author": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee882b3a4b74f8b19146008900a3971968e1a5b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee882b3a4b74f8b19146008900a3971968e1a5b3", "html_url": "https://github.com/rust-lang/rust/commit/ee882b3a4b74f8b19146008900a3971968e1a5b3"}], "stats": {"total": 85, "additions": 42, "deletions": 43}, "files": [{"sha": "d3eb9fd95571400724496faf317b625e1dfa127f", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "patch": "@@ -25,20 +25,25 @@ pub enum Representability {\n pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> Representability {\n     debug!(\"is_type_representable: {:?}\", ty);\n     // To avoid a stack overflow when checking an enum variant or struct that\n-    // contains a different, structurally recursive type, maintain a stack\n-    // of seen types and check recursion for each of them (issues #3008, #3779).\n+    // contains a different, structurally recursive type, maintain a stack of\n+    // seen types and check recursion for each of them (issues #3008, #3779,\n+    // #74224, #84611). `shadow_seen` contains the full stack and `seen` only\n+    // the one for the current type (e.g. if we have structs A and B, B contains\n+    // a field of type A, and we're currently looking at B, then `seen` will be\n+    // cleared when recursing to check A, but `shadow_seen` won't, so that we\n+    // can catch cases of mutual recursion where A also contains B).\n     let mut seen: Vec<Ty<'_>> = Vec::new();\n-    let mut shadow_seen: Vec<Ty<'_>> = Vec::new();\n+    let mut shadow_seen: Vec<&'tcx ty::AdtDef> = Vec::new();\n     let mut representable_cache = FxHashMap::default();\n-    let mut f_res = false;\n+    let mut force_result = false;\n     let r = is_type_structurally_recursive(\n         tcx,\n         sp,\n         &mut seen,\n         &mut shadow_seen,\n         &mut representable_cache,\n         ty,\n-        &mut f_res,\n+        &mut force_result,\n     );\n     debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n     r\n@@ -58,10 +63,10 @@ fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n-    f_res: &mut bool,\n+    force_result: &mut bool,\n ) -> Representability {\n     debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n     match ty.kind() {\n@@ -75,7 +80,7 @@ fn are_inner_types_recursive<'tcx>(\n                     shadow_seen,\n                     representable_cache,\n                     ty,\n-                    f_res,\n+                    force_result,\n                 )\n             }))\n         }\n@@ -88,7 +93,7 @@ fn are_inner_types_recursive<'tcx>(\n             shadow_seen,\n             representable_cache,\n             ty,\n-            f_res,\n+            force_result,\n         ),\n         ty::Adt(def, substs) => {\n             // Find non representable fields with their spans\n@@ -125,22 +130,12 @@ fn are_inner_types_recursive<'tcx>(\n                 // case (shadow_seen.first() is the type we are originally\n                 // interested in, and if we ever encounter the same AdtDef again,\n                 // we know that it must be SelfRecursive) and \"forcibly\" returning\n-                // SelfRecursive (by setting f_res, which tells the calling\n+                // SelfRecursive (by setting force_result, which tells the calling\n                 // invocations of are_inner_types_representable to forward the\n                 // result without adjusting).\n-                if shadow_seen.len() > 1 && shadow_seen.len() > seen.len() {\n-                    match shadow_seen.first().map(|ty| ty.kind()) {\n-                        Some(ty::Adt(f_def, _)) => {\n-                            if f_def == def {\n-                                *f_res = true;\n-                                result = Some(Representability::SelfRecursive(vec![span]));\n-                            }\n-                        }\n-                        Some(_) => {\n-                            bug!(\"shadow_seen stack contains non-ADT type: {:?}\", ty);\n-                        }\n-                        None => unreachable!(),\n-                    }\n+                if shadow_seen.len() > seen.len() && shadow_seen.first() == Some(def) {\n+                    *force_result = true;\n+                    result = Some(Representability::SelfRecursive(vec![span]));\n                 }\n \n                 if result == None {\n@@ -154,15 +149,11 @@ fn are_inner_types_recursive<'tcx>(\n                     // If we have encountered an ADT definition that we have not seen\n                     // before (no need to check them twice), recurse to see whether that\n                     // definition is SelfRecursive. If so, we must be ContainsRecursive.\n-                    if shadow_seen.iter().len() > 1\n-                        && !shadow_seen.iter().take(shadow_seen.iter().len() - 1).any(|seen_ty| {\n-                            match seen_ty.kind() {\n-                                ty::Adt(seen_def, _) => seen_def == def,\n-                                _ => {\n-                                    bug!(\"seen stack contains non-ADT type: {:?}\", seen_ty);\n-                                }\n-                            }\n-                        })\n+                    if shadow_seen.len() > 1\n+                        && !shadow_seen\n+                            .iter()\n+                            .take(shadow_seen.len() - 1)\n+                            .any(|seen_def| seen_def == def)\n                     {\n                         let adt_def_id = def.did;\n                         let raw_adt_ty = tcx.type_of(adt_def_id);\n@@ -180,10 +171,10 @@ fn are_inner_types_recursive<'tcx>(\n                                 shadow_seen,\n                                 representable_cache,\n                                 raw_adt_ty,\n-                                f_res,\n+                                force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n-                                    if *f_res {\n+                                    if *force_result {\n                                         Representability::SelfRecursive(vec![span])\n                                     } else {\n                                         Representability::ContainsRecursive\n@@ -227,7 +218,7 @@ fn are_inner_types_recursive<'tcx>(\n                                 shadow_seen,\n                                 representable_cache,\n                                 ty,\n-                                f_res,\n+                                force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n                                     Representability::SelfRecursive(vec![span])\n@@ -263,10 +254,10 @@ fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n-    f_res: &mut bool,\n+    force_result: &mut bool,\n ) -> Representability {\n     debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n     if let Some(representability) = representable_cache.get(ty) {\n@@ -284,7 +275,7 @@ fn is_type_structurally_recursive<'tcx>(\n         shadow_seen,\n         representable_cache,\n         ty,\n-        f_res,\n+        force_result,\n     );\n \n     representable_cache.insert(ty, representability.clone());\n@@ -295,10 +286,10 @@ fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<&'tcx ty::AdtDef>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n-    f_res: &mut bool,\n+    force_result: &mut bool,\n ) -> Representability {\n     match ty.kind() {\n         ty::Adt(def, _) => {\n@@ -346,23 +337,31 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // For structs and enums, track all previously seen types by pushing them\n             // onto the 'seen' stack.\n             seen.push(ty);\n-            shadow_seen.push(ty);\n+            shadow_seen.push(def);\n             let out = are_inner_types_recursive(\n                 tcx,\n                 sp,\n                 seen,\n                 shadow_seen,\n                 representable_cache,\n                 ty,\n-                f_res,\n+                force_result,\n             );\n             shadow_seen.pop();\n             seen.pop();\n             out\n         }\n         _ => {\n             // No need to push in other cases.\n-            are_inner_types_recursive(tcx, sp, seen, shadow_seen, representable_cache, ty, f_res)\n+            are_inner_types_recursive(\n+                tcx,\n+                sp,\n+                seen,\n+                shadow_seen,\n+                representable_cache,\n+                ty,\n+                force_result,\n+            )\n         }\n     }\n }"}, {"sha": "f3b72c5df7f70b2617ddbe530bf235ebf0204fe7", "filename": "src/test/ui/structs-enums/struct-rec/issue-74224.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.rs?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/issues/issue-74224.rs"}, {"sha": "d61ab1952f9f1452acfe37cf5d31df7a8285952b", "filename": "src/test/ui/structs-enums/struct-rec/issue-74224.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/issues/issue-74224.stderr"}, {"sha": "4c356af3eb8a3244eeb5c534c7a37ee522a76291", "filename": "src/test/ui/structs-enums/struct-rec/issue-84611.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.rs?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/issues/issue-84611.rs"}, {"sha": "0a898e5c46dbefcf0e06c6afad4f8a2377c203b8", "filename": "src/test/ui/structs-enums/struct-rec/issue-84611.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/issues/issue-84611.stderr"}, {"sha": "cca97f43effc399c80b85c8f6554deaae2ff0301", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/mutual-struct-recursion.rs"}, {"sha": "efc4ba93f0a2bdf147c366ec149fbaac3949313b", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98728c2b35da6600e15d57e494041dcf6dc21c1a/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr?ref=98728c2b35da6600e15d57e494041dcf6dc21c1a", "previous_filename": "src/test/ui/mutual-struct-recursion.stderr"}]}