{"sha": "acb1ec0b6715a529e3f6a7053737d99f03971c27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYjFlYzBiNjcxNWE1MjllM2Y2YTcwNTM3MzdkOTlmMDM5NzFjMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-04T22:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-04T22:41:36Z"}, "message": "auto merge of #11230 : csherratt/rust/cow, r=alexcrichton\n\nThis allows patch adds a new arc type that allows for creation of copy-on-write data structures. The idea is that it is safe to mutate any data structure as long as it has only one reference to it. If there are multiple, it requires cloning of the data structure before mutation is possible.", "tree": {"sha": "4adf75d9d4e95504240dad7c6531f66f84d6f92a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4adf75d9d4e95504240dad7c6531f66f84d6f92a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acb1ec0b6715a529e3f6a7053737d99f03971c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acb1ec0b6715a529e3f6a7053737d99f03971c27", "html_url": "https://github.com/rust-lang/rust/commit/acb1ec0b6715a529e3f6a7053737d99f03971c27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acb1ec0b6715a529e3f6a7053737d99f03971c27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef53b7a97c58f65ac6967dfc6d30a4354afa34a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef53b7a97c58f65ac6967dfc6d30a4354afa34a3", "html_url": "https://github.com/rust-lang/rust/commit/ef53b7a97c58f65ac6967dfc6d30a4354afa34a3"}, {"sha": "4f462a05066ea4ddbe65d3033402e7c80247ddde", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f462a05066ea4ddbe65d3033402e7c80247ddde", "html_url": "https://github.com/rust-lang/rust/commit/4f462a05066ea4ddbe65d3033402e7c80247ddde"}], "stats": {"total": 116, "additions": 116, "deletions": 0}, "files": [{"sha": "7f8d64053d51cddb4b68fec7bb2ccf509771f3e6", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/acb1ec0b6715a529e3f6a7053737d99f03971c27/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb1ec0b6715a529e3f6a7053737d99f03971c27/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=acb1ec0b6715a529e3f6a7053737d99f03971c27", "patch": "@@ -554,6 +554,50 @@ impl<'a, T:Freeze + Send> RWReadMode<'a, T> {\n     }\n }\n \n+/****************************************************************************\n+ * Copy-on-write Arc\n+ ****************************************************************************/\n+\n+pub struct CowArc<T> { priv x: UnsafeArc<T> }\n+\n+/// A Copy-on-write Arc functions the same way as an `arc` except it allows\n+/// mutation of the contents if there is only a single reference to\n+/// the data. If there are multiple references the data is automatically\n+/// cloned and the task modifies the cloned data in place of the shared data.\n+impl<T:Clone+Send+Freeze> CowArc<T> {\n+    /// Create a copy-on-write atomically reference counted wrapper\n+    #[inline]\n+    pub fn new(data: T) -> CowArc<T> {\n+        CowArc { x: UnsafeArc::new(data) }\n+    }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.x.get_immut() }\n+    }\n+\n+    /// get a mutable reference to the contents. If there are more then one\n+    /// reference to the contents of the `CowArc` will be cloned\n+    /// and this reference updated to point to the cloned data.\n+    #[inline]\n+    pub fn get_mut<'a>(&'a mut self) -> &'a mut T {\n+        if !self.x.is_owned() {\n+            *self = CowArc::new(self.get().clone())\n+        }\n+        unsafe { &mut *self.x.get() }\n+    }\n+}\n+\n+impl<T:Clone+Send+Freeze> Clone for CowArc<T> {\n+    /// Duplicate a Copy-on-write Arc. See arc::clone for more details.\n+    #[inline]\n+    fn clone(&self) -> CowArc<T> {\n+        CowArc { x: self.x.clone() }\n+    }\n+}\n+\n+\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -963,4 +1007,68 @@ mod tests {\n         // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n         for _ in range(0, 8) { test_rw_write_cond_downgrade_read_race_helper(); }\n     }\n+\n+    #[test]\n+    fn test_cowarc_clone()\n+    {\n+        let cow0 = CowArc::new(75u);\n+        let cow1 = cow0.clone();\n+        let cow2 = cow1.clone();\n+\n+        assert!(75 == *cow0.get());\n+        assert!(75 == *cow1.get());\n+        assert!(75 == *cow2.get());\n+\n+        assert!(cow0.get() == cow1.get());\n+        assert!(cow0.get() == cow2.get());\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_get_mut()\n+    {\n+        let mut cow0 = CowArc::new(75u);\n+        let mut cow1 = cow0.clone();\n+        let mut cow2 = cow1.clone();\n+\n+        assert!(75 == *cow0.get_mut());\n+        assert!(75 == *cow1.get_mut());\n+        assert!(75 == *cow2.get_mut());\n+\n+        *cow0.get_mut() += 1;\n+        *cow1.get_mut() += 2;\n+        *cow2.get_mut() += 3;\n+\n+        assert!(76 == *cow0.get());\n+        assert!(77 == *cow1.get());\n+        assert!(78 == *cow2.get());\n+\n+        // none should point to the same backing memory\n+        assert!(cow0.get() != cow1.get());\n+        assert!(cow0.get() != cow2.get());\n+        assert!(cow1.get() != cow2.get());\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_get_mut2()\n+    {\n+        let mut cow0 = CowArc::new(75u);\n+        let cow1 = cow0.clone();\n+        let cow2 = cow1.clone();\n+\n+        assert!(75 == *cow0.get());\n+        assert!(75 == *cow1.get());\n+        assert!(75 == *cow2.get());\n+\n+        *cow0.get_mut() += 1;\n+\n+        assert!(76 == *cow0.get());\n+        assert!(75 == *cow1.get());\n+        assert!(75 == *cow2.get());\n+\n+        // cow1 and cow2 should share the same contents\n+        // cow0 should have a unique reference\n+        assert!(cow0.get() != cow1.get());\n+        assert!(cow0.get() != cow2.get());\n+        assert!(cow1.get() == cow2.get());\n+    }\n }"}, {"sha": "5c452018b9b7e5e4be9a713761ee81073c3ba475", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acb1ec0b6715a529e3f6a7053737d99f03971c27/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb1ec0b6715a529e3f6a7053737d99f03971c27/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=acb1ec0b6715a529e3f6a7053737d99f03971c27", "patch": "@@ -94,6 +94,14 @@ impl<T: Send> UnsafeArc<T> {\n             return &(*self.data).data as *T;\n         }\n     }\n+\n+    /// checks if this is the only reference to the arc protected data\n+    #[inline]\n+    pub fn is_owned(&self) -> bool {\n+        unsafe {\n+            (*self.data).count.load(Relaxed) == 1\n+        }\n+    }\n }\n \n impl<T: Send> Clone for UnsafeArc<T> {"}]}