{"sha": "dd481d5f462d8c7bd5e81438ccc1ef3013343408", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNDgxZDVmNDYyZDhjN2JkNWU4MTQzOGNjYzFlZjMwMTMzNDM0MDg=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-01-18T01:22:40Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-02-08T16:13:57Z"}, "message": "fix nested impl trait lifetimes", "tree": {"sha": "5e9c13678f9d5c2f6fcff52cf6c0a2b38d43507c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e9c13678f9d5c2f6fcff52cf6c0a2b38d43507c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd481d5f462d8c7bd5e81438ccc1ef3013343408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd481d5f462d8c7bd5e81438ccc1ef3013343408", "html_url": "https://github.com/rust-lang/rust/commit/dd481d5f462d8c7bd5e81438ccc1ef3013343408", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd481d5f462d8c7bd5e81438ccc1ef3013343408/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932c736479f43dc8893a924946e4335d8e308c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/932c736479f43dc8893a924946e4335d8e308c2e", "html_url": "https://github.com/rust-lang/rust/commit/932c736479f43dc8893a924946e4335d8e308c2e"}], "stats": {"total": 90, "additions": 79, "deletions": 11}, "files": [{"sha": "5201df2119dac8703de1aa9560586a813cbdf49c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 71, "deletions": 11, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/dd481d5f462d8c7bd5e81438ccc1ef3013343408/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd481d5f462d8c7bd5e81438ccc1ef3013343408/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=dd481d5f462d8c7bd5e81438ccc1ef3013343408", "patch": "@@ -270,6 +270,19 @@ enum Scope<'a> {\n         /// we should use for an early-bound region?\n         next_early_index: u32,\n \n+        /// Whether or not this binder would serve as the parent\n+        /// binder for abstract types introduced within. For example:\n+        ///\n+        ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n+        ///\n+        /// Here, the abstract types we create for the `impl Trait`\n+        /// and `impl Trait2` references will both have the `foo` item\n+        /// as their parent. When we get to `impl Trait2`, we find\n+        /// that it is nested within the `for<>` binder -- this flag\n+        /// allows us to skip that when looking for the parent binder\n+        /// of the resulting abstract type.\n+        abstract_type_parent: bool,\n+\n         s: ScopeRef<'a>,\n     },\n \n@@ -498,6 +511,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n+                    abstract_type_parent: true,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -541,6 +555,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .collect(),\n                     s: self.scope,\n                     next_early_index,\n+                    abstract_type_parent: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -614,7 +629,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref generics,\n                     ref bounds,\n                 } = *exist_ty;\n-                let mut index = self.next_early_index();\n+\n+                // We want to start our early-bound indices at the end of the parent scope,\n+                // not including any parent `impl Trait`s.\n+                let mut index = self.next_early_index_for_abstract_type();\n                 debug!(\"visit_ty: index = {}\", index);\n \n                 let mut elision = None;\n@@ -638,7 +656,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope\n                     };\n                     self.with(scope, |_old_scope, this| {\n-                        let scope = Scope::Binder { lifetimes, next_early_index, s: this.scope };\n+                        let scope = Scope::Binder {\n+                            lifetimes,\n+                            next_early_index,\n+                            s: this.scope,\n+                            abstract_type_parent: false,\n+                        };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n                             for bound in bounds {\n@@ -647,7 +670,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         });\n                     });\n                 } else {\n-                    let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                    let scope = Scope::Binder {\n+                        lifetimes,\n+                        next_early_index,\n+                        s: self.scope,\n+                        abstract_type_parent: false,\n+                    };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n                         for bound in bounds {\n@@ -681,7 +709,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params().count() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    abstract_type_parent: true,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     for bound in bounds {\n@@ -721,7 +754,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params().count() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    abstract_type_parent: true,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     this.visit_ty(ty);\n@@ -792,6 +830,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 .collect(),\n                             s: self.scope,\n                             next_early_index,\n+                            abstract_type_parent: false,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -853,6 +892,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .collect(),\n                 s: self.scope,\n                 next_early_index,\n+                abstract_type_parent: false,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n@@ -1046,6 +1086,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n@@ -1303,32 +1344,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n+            abstract_type_parent: true,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n             this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n \n-    /// Returns the next index one would use for an early-bound-region\n-    /// if extending the current scope.\n-    fn next_early_index(&self) -> u32 {\n+    fn next_early_index_helper(&self, only_abstract_type_parent: bool) -> u32 {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n                 Scope::Root => return 0,\n \n                 Scope::Binder {\n-                    next_early_index, ..\n-                } => return next_early_index,\n+                    next_early_index,\n+                    abstract_type_parent,\n+                    ..\n+                } if (!only_abstract_type_parent || abstract_type_parent)\n+                => return next_early_index,\n \n-                Scope::Body { s, .. }\n+                Scope::Binder { s, .. }\n+                | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }\n         }\n     }\n \n+    /// Returns the next index one would use for an early-bound-region\n+    /// if extending the current scope.\n+    fn next_early_index(&self) -> u32 {\n+        self.next_early_index_helper(true)\n+    }\n+\n+    /// Returns the next index one would use for an `impl Trait` that\n+    /// is being converted into an `abstract type`. This will be the\n+    /// next early index from the enclosing item, for the most\n+    /// part. See the `abstract_type_parent` field for more info.\n+    fn next_early_index_for_abstract_type(&self) -> u32 {\n+        self.next_early_index_helper(false)\n+    }\n+\n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n         // Walk up the scope chain, tracking the number of fn scopes\n@@ -1353,6 +1411,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n                         break Some(def.shifted(late_depth));\n@@ -2102,6 +2161,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes,\n                     s,\n                     next_early_index: _,\n+                    abstract_type_parent: _,\n                 } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();"}, {"sha": "213a46ded8e765d6ea782b4ed54de1b59de1eec1", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd481d5f462d8c7bd5e81438ccc1ef3013343408/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd481d5f462d8c7bd5e81438ccc1ef3013343408/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=dd481d5f462d8c7bd5e81438ccc1ef3013343408", "patch": "@@ -50,6 +50,14 @@ fn closure_hr_elided_return() -> impl Fn(&u32) -> &u32 { |x| x }\n fn closure_pass_through_elided_return(x: impl Fn(&u32) -> &u32) -> impl Fn(&u32) -> &u32 { x }\n fn closure_pass_through_reference_elided(x: &impl Fn(&u32) -> &u32) -> &impl Fn(&u32) -> &u32 { x }\n \n+fn nested_lifetime<'a>(input: &'a str)\n+    -> impl Iterator<Item = impl Iterator<Item = i32> + 'a> + 'a\n+{\n+    input.lines().map(|line| {\n+        line.split_whitespace().map(|cell| cell.parse().unwrap())\n+    })\n+}\n+\n fn pass_through_elision(x: &u32) -> impl Into<&u32> { x }\n fn pass_through_elision_with_fn_ptr(x: &fn(&u32) -> &u32) -> impl Into<&fn(&u32) -> &u32> { x }\n "}]}