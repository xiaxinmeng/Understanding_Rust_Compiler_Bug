{"sha": "7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOWViODM2YTlkMzc5NDNiYmQzZjNlYTI5ODY5ZTBhNTFjNWY4Yzg=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-05-15T12:26:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-15T12:26:54Z"}, "message": "Rollup merge of #49767 - ecstatic-morse:ptr-docs, r=steveklabnik\n\nRewrite docs for `std::ptr`\n\nThis PR attempts to resolve #29371.\n\nThis is a fairly major rewrite of the `std::ptr` docs, and deserves a fair bit of scrutiny. It adds links to the GNU libc docs for various instrinsics, adds internal links to types and functions referenced in the docs, adds new, more complex examples for many functions, and introduces a common template for discussing unsafety of functions in `std::ptr`.\n\nAll functions in `std::ptr` (with the exception of `ptr::eq`) are unsafe because they either read from or write to a raw pointer. The \"Safety\" section now informs that the function is unsafe because it dereferences a raw pointer and requires that any pointer to be read by the function points to \"a valid vaue of type `T`\".\n\nAdditionally, each function imposes some subset of the following conditions on its arguments.\n\n* The pointer points to valid memory.\n* The pointer points to initialized memory.\n* The pointer is properly aligned.\n\nThese requirements are discussed in the \"Undefined Behavior\" section along with the  consequences of using functions that perform bitwise copies without requiring `T: Copy`. I don't love my new descriptions of the consequences of making such copies. Perhaps the old ones were good enough?\n\nSome issues which still need to be addressed before this is merged:\n- [ ] The new docs assert that `drop_in_place` is equivalent to calling `read` and discarding the value. Is this correct?\n- [ ] Do `write_bytes` and `swap_nonoverlapping` require properly aligned pointers?\n- [ ] The new example for `drop_in_place` is a lackluster.\n- [ ] Should these docs rigorously define what `valid` memory is? Or should is that the job of the reference? Should we link to the reference?\n- [ ] Is it correct to require that pointers that will be read from refer to \"valid values of type `T`\"?\n- [x] I can't imagine ever using `{read,write}_volatile` with non-`Copy` types.  Should I just link to {read,write} and say that the same issues with non-`Copy` types apply?\n- [x] `write_volatile` doesn't link back to `read_volatile`.\n- [ ] Update docs for the unstable [`swap_nonoverlapping`](https://github.com/rust-lang/rust/issues/42818)\n- [ ] Update docs for the unstable [unsafe pointer methods RFC](https://github.com/rust-lang/rfcs/pull/1966)\n\nLooking forward to your feedback.\n\nr? @steveklabnik", "tree": {"sha": "e47ac47358387d941077227dd707d720a16df18d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47ac47358387d941077227dd707d720a16df18d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa+tIOCRBK7hj4Ov3rIwAAdHIIACwqf4hGfv4dJIsg5hYmwTLJ\nseDnq1ni0wtvEK2Qpen2NwPEq95ZzfPWG2CgNDFrFn+4PnngPUSXzC5+EpQuo1il\nTQkv3SWgLpN3/45tcMpbNsqgAggcV7QGuOq9j9doFtsq23tOrIBbDZaUE3s4GYwy\n2m6UkH8nxIeLk/iRtcZ/P96Wul5CDV2dFoB4HikPMwZmgExBCzpk1QTIC2Pj7a41\n3BYAfjnp8nbluRUhwzqYkn3w+vxfhYsrc0MmcvKjbYhKNfdMoab38gzomEi859kt\nsjQ2z7BbxRxaSsfsLbM68zzfd/s9kLlh5xE8Q3pQeVz6rYibvHiQlb4/E1TZcb4=\n=au9W\n-----END PGP SIGNATURE-----\n", "payload": "tree e47ac47358387d941077227dd707d720a16df18d\nparent 0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860\nparent 827251e92bef9bd613cf44e2dc074fa1dc71ea0f\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1526387214 +0200\ncommitter GitHub <noreply@github.com> 1526387214 +0200\n\nRollup merge of #49767 - ecstatic-morse:ptr-docs, r=steveklabnik\n\nRewrite docs for `std::ptr`\n\nThis PR attempts to resolve #29371.\n\nThis is a fairly major rewrite of the `std::ptr` docs, and deserves a fair bit of scrutiny. It adds links to the GNU libc docs for various instrinsics, adds internal links to types and functions referenced in the docs, adds new, more complex examples for many functions, and introduces a common template for discussing unsafety of functions in `std::ptr`.\n\nAll functions in `std::ptr` (with the exception of `ptr::eq`) are unsafe because they either read from or write to a raw pointer. The \"Safety\" section now informs that the function is unsafe because it dereferences a raw pointer and requires that any pointer to be read by the function points to \"a valid vaue of type `T`\".\n\nAdditionally, each function imposes some subset of the following conditions on its arguments.\n\n* The pointer points to valid memory.\n* The pointer points to initialized memory.\n* The pointer is properly aligned.\n\nThese requirements are discussed in the \"Undefined Behavior\" section along with the  consequences of using functions that perform bitwise copies without requiring `T: Copy`. I don't love my new descriptions of the consequences of making such copies. Perhaps the old ones were good enough?\n\nSome issues which still need to be addressed before this is merged:\n- [ ] The new docs assert that `drop_in_place` is equivalent to calling `read` and discarding the value. Is this correct?\n- [ ] Do `write_bytes` and `swap_nonoverlapping` require properly aligned pointers?\n- [ ] The new example for `drop_in_place` is a lackluster.\n- [ ] Should these docs rigorously define what `valid` memory is? Or should is that the job of the reference? Should we link to the reference?\n- [ ] Is it correct to require that pointers that will be read from refer to \"valid values of type `T`\"?\n- [x] I can't imagine ever using `{read,write}_volatile` with non-`Copy` types.  Should I just link to {read,write} and say that the same issues with non-`Copy` types apply?\n- [x] `write_volatile` doesn't link back to `read_volatile`.\n- [ ] Update docs for the unstable [`swap_nonoverlapping`](https://github.com/rust-lang/rust/issues/42818)\n- [ ] Update docs for the unstable [unsafe pointer methods RFC](https://github.com/rust-lang/rfcs/pull/1966)\n\nLooking forward to your feedback.\n\nr? @steveklabnik\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "html_url": "https://github.com/rust-lang/rust/commit/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "html_url": "https://github.com/rust-lang/rust/commit/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860"}, {"sha": "827251e92bef9bd613cf44e2dc074fa1dc71ea0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/827251e92bef9bd613cf44e2dc074fa1dc71ea0f", "html_url": "https://github.com/rust-lang/rust/commit/827251e92bef9bd613cf44e2dc074fa1dc71ea0f"}], "stats": {"total": 531, "additions": 430, "deletions": 101}, "files": [{"sha": "7d3e7af1a1884d2703efced9b9a365c04a2451e6", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 130, "deletions": 31, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "patch": "@@ -962,59 +962,122 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n-    /// and destination may *not* overlap.\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n     ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n+    /// For regions of memory which might overlap, use [`copy`] instead.\n+    ///\n+    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`].\n+    ///\n+    /// [`copy`]: ./fn.copy.html\n+    /// [`memcpy`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memcpy\n     ///\n     /// # Safety\n     ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `src` and\n-    /// `dst`. This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents\n-    /// of `src` from being dropped or used.\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `src` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n+    ///   initialized).\n+    ///\n+    /// * The two regions of memory must *not* overlap.\n+    ///\n+    /// * `src` must be properly aligned.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n+    /// region at `dst` can be used or dropped after calling\n+    /// `copy_nonoverlapping`.  `copy_nonoverlapping` creates bitwise copies of\n+    /// `T`, regardless of whether `T: Copy`, which can result in undefined\n+    /// behavior if both copies are used.\n+    ///\n+    /// [`Copy`]: ../marker/trait.Copy.html\n     ///\n     /// # Examples\n     ///\n-    /// A safe swap function:\n+    /// Manually implement [`Vec::append`]:\n     ///\n     /// ```\n-    /// use std::mem;\n     /// use std::ptr;\n     ///\n-    /// # #[allow(dead_code)]\n-    /// fn swap<T>(x: &mut T, y: &mut T) {\n+    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+    ///     let src_len = src.len();\n+    ///     let dst_len = dst.len();\n+    ///\n+    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+    ///     dst.reserve(src_len);\n+    ///\n     ///     unsafe {\n-    ///         // Give ourselves some scratch space to work with\n-    ///         let mut t: T = mem::uninitialized();\n+    ///         // The call to offset is always safe because `Vec` will never\n+    ///         // allocate more than `isize::MAX` bytes.\n+    ///         let dst = dst.as_mut_ptr().offset(dst_len as isize);\n+    ///         let src = src.as_ptr();\n+    ///\n+    ///         // The two regions cannot overlap becuase mutable references do\n+    ///         // not alias, and two different vectors cannot own the same\n+    ///         // memory.\n+    ///         ptr::copy_nonoverlapping(src, dst, src_len);\n+    ///     }\n     ///\n-    ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n-    ///         ptr::copy_nonoverlapping(y, x, 1);\n-    ///         ptr::copy_nonoverlapping(&t, y, 1);\n+    ///     unsafe {\n+    ///         // Truncate `src` without dropping its contents.\n+    ///         src.set_len(0);\n     ///\n-    ///         // y and t now point to the same thing, but we need to completely forget `t`\n-    ///         // because it's no longer relevant.\n-    ///         mem::forget(t);\n+    ///         // Notify `dst` that it now holds the contents of `src`.\n+    ///         dst.set_len(dst_len + src_len);\n     ///     }\n     /// }\n+    ///\n+    /// let mut a = vec!['r'];\n+    /// let mut b = vec!['u', 's', 't'];\n+    ///\n+    /// append(&mut a, &mut b);\n+    ///\n+    /// assert_eq!(a, &['r', 'u', 's', 't']);\n+    /// assert!(b.is_empty());\n     /// ```\n+    ///\n+    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// `copy` is semantically equivalent to C's `memmove`.\n+    /// If the source and destination will *never* overlap,\n+    /// [`copy_nonoverlapping`] can be used instead.\n+    ///\n+    /// `copy` is semantically equivalent to C's [`memmove`].\n+    ///\n+    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n+    /// [`memmove`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memmove\n     ///\n     /// # Safety\n     ///\n-    /// Care must be taken with the ownership of `src` and `dst`.\n-    /// This method semantically moves the values of `src` into `dst`.\n-    /// However it does not drop the contents of `dst`, or prevent the contents of `src`\n-    /// from being dropped or used.\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `src` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be *both* valid and initialized.\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count * size_of::<T>()` bytes must be valid (but may or may not be\n+    ///   initialized).\n+    ///\n+    /// * `src` must be properly aligned.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, if `T` is not [`Copy`], only the region at `src` *or* the\n+    /// region at `dst` can be used or dropped after calling `copy`. `copy`\n+    /// creates bitwise copies of `T`, regardless of whether `T: Copy`, which\n+    /// can result in undefined behavior if both copies are used.\n+    ///\n+    /// [`Copy`]: ../marker/trait.Copy.html\n     ///\n     /// # Examples\n     ///\n@@ -1031,15 +1094,34 @@ extern \"rust-intrinsic\" {\n     ///     dst\n     /// }\n     /// ```\n-    ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n \n-    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n-    /// bytes of memory starting at `dst` to `val`.\n+    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n+    /// `val`.\n+    ///\n+    /// `write_bytes` is semantically equivalent to C's [`memset`].\n+    ///\n+    /// [`memset`]: https://www.gnu.org/software/libc/manual/html_node/Copying-Strings-and-Arrays.html#index-memset\n+    ///\n+    /// # Safety\n+    ///\n+    /// Behavior is undefined if any of the following conditions are violated:\n+    ///\n+    /// * The region of memory which begins at `dst` and has a length of\n+    ///   `count` bytes must be valid.\n+    ///\n+    /// * `dst` must be properly aligned.\n+    ///\n+    /// Additionally, the caller must ensure that writing `count` bytes to the\n+    /// given region of memory results in a valid value of `T`. Creating an\n+    /// invalid value of `T` can result in undefined behavior. An example is\n+    /// provided below.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// use std::ptr;\n     ///\n@@ -1050,6 +1132,23 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n     /// ```\n+    ///\n+    /// Creating an invalid value:\n+    ///\n+    /// ```no_run\n+    /// use std::{mem, ptr};\n+    ///\n+    /// let mut v = Box::new(0i32);\n+    ///\n+    /// unsafe {\n+    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n+    ///     // a null pointer.\n+    ///     ptr::write_bytes(&mut v, 0, mem::size_of::<Box<i32>>());\n+    /// }\n+    ///\n+    /// // At this point, using or dropping `v` results in undefined behavior.\n+    /// // v = Box::new(0i32); // ERROR\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "83dfac7a3a2ea4f09b5e25aeb4033acc751c40d9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 300, "deletions": 70, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7a9eb836a9d37943bbd3f3ea29869e0a51c5f8c8", "patch": "@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Raw, unsafe pointers, `*const T`, and `*mut T`.\n+//! Manually manage memory through raw pointers.\n //!\n //! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n \n@@ -38,21 +38,62 @@ pub use intrinsics::write_bytes;\n \n /// Executes the destructor (if any) of the pointed-to value.\n ///\n-/// This has two use cases:\n+/// This is semantically equivalent to calling [`ptr::read`] and discarding\n+/// the result, but has the following advantages:\n ///\n /// * It is *required* to use `drop_in_place` to drop unsized types like\n ///   trait objects, because they can't be read out onto the stack and\n ///   dropped normally.\n ///\n-/// * It is friendlier to the optimizer to do this over `ptr::read` when\n+/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// [`ptr::read`]: ../ptr/fn.read.html\n+///\n /// # Safety\n ///\n-/// This has all the same safety problems as `ptr::read` with respect to\n-/// invalid pointers, types, and double drops.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `to_drop` must point to valid memory.\n+///\n+/// * `to_drop` must be properly aligned.\n+///\n+/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n+/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n+/// foo` counts as a use because it will cause the the value to be dropped\n+/// again. [`write`] can be used to overwrite data without causing it to be\n+/// dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write`]: ../ptr/fn.write.html\n+///\n+/// # Examples\n+///\n+/// Manually remove the last item from a vector:\n+///\n+/// ```\n+/// use std::ptr;\n+/// use std::rc::Rc;\n+///\n+/// let last = Rc::new(1);\n+/// let weak = Rc::downgrade(&last);\n+///\n+/// let mut v = vec![Rc::new(0), last];\n+///\n+/// unsafe {\n+///     // Without a call `drop_in_place`, the last item would never be dropped,\n+///     // and the memory it manages would be leaked.\n+///     ptr::drop_in_place(&mut v[1]);\n+///     v.set_len(1);\n+/// }\n+///\n+/// assert_eq!(v, &[0.into()]);\n+///\n+/// // Ensure that the last item was dropped.\n+/// assert!(weak.upgrade().is_none());\n+/// ```\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n@@ -93,17 +134,25 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///\n-/// The values pointed at by `x` and `y` may overlap, unlike `mem::swap` which\n-/// is otherwise equivalent. If the values do overlap, then the overlapping\n-/// region of memory from `x` will be used. This is demonstrated in the\n-/// examples section below.\n+/// But for the following two exceptions, this function is semantically\n+/// equivalent to [`mem::swap`]:\n+///\n+/// * It operates on raw pointers instead of references. When references are\n+///   available, [`mem::swap`] should be preferred.\n+///\n+/// * The two pointed-to values may overlap. If the values do overlap, then the\n+///   overlapping region of memory from `x` will be used. This is demonstrated\n+///   in the examples below.\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n ///\n /// # Safety\n ///\n-/// This function copies the memory through the raw pointers passed to it\n-/// as arguments.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// Ensure that these pointers are valid before calling `swap`.\n+/// * `x` and `y` must point to valid, initialized memory.\n+///\n+/// * `x` and `y` must be properly aligned.\n ///\n /// # Examples\n ///\n@@ -239,13 +288,39 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     }\n }\n \n-/// Replaces the value at `dest` with `src`, returning the old\n-/// value, without dropping either.\n+/// Replaces the value at `dest` with `src`, returning the old value, without\n+/// dropping either.\n+///\n+/// This function is semantically equivalent to [`mem::replace`] except that it\n+/// operates on raw pointers instead of references. When references are\n+/// available, [`mem::replace`] should be preferred.\n+///\n+/// [`mem::replace`]: ../mem/fn.replace.html\n ///\n /// # Safety\n ///\n-/// This is only unsafe because it accepts a raw pointer.\n-/// Otherwise, this operation is identical to `mem::replace`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dest` must point to valid, initialized memory.\n+///\n+/// * `dest` must be properly aligned.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut rust = vec!['b', 'u', 's', 't'];\n+///\n+/// // `mem::replace` would have the same effect without requiring the unsafe\n+/// // block.\n+/// let b = unsafe {\n+///     ptr::replace(&mut rust[0], 'r')\n+/// };\n+///\n+/// assert_eq!(b, 'b');\n+/// assert_eq!(rust, &['r', 'u', 's', 't']);\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n@@ -258,14 +333,23 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n+///   case.\n+///\n+/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n+/// pointed-to value can be used or dropped after calling `read`. `read` creates\n+/// a bitwise copy of `T`, regardless of whether `T: Copy`, which can result\n+/// in undefined behavior if both copies are used. Note that `*src = foo` counts\n+/// as a use because it will attempt to drop the value previously at `*src`.\n+/// [`write`] can be used to overwrite data without causing it to be dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+/// [`write`]: ./fn.write.html\n ///\n /// # Examples\n ///\n@@ -279,6 +363,44 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         // Create a bitwise copy of the value at `a` in `tmp`.\n+///         let tmp = ptr::read(a);\n+///\n+///         // Exiting at this point (either by explicitly returning or by\n+///         // calling a function which panics) would cause the value in `tmp` to\n+///         // be dropped while the same value is still referenced by `a`. This\n+///         // could trigger undefined behavior if `T` is not `Copy`.\n+///\n+///         // Create a bitwise copy of the value at `b` in `a`.\n+///         // This is safe because mutable references cannot alias.\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///\n+///         // As above, exiting here could trigger undefined behavior because\n+///         // the same value is referenced by `a` and `b`.\n+///\n+///         // Move `tmp` into `b`.\n+///         ptr::write(b, tmp);\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -290,28 +412,62 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// Reads the value from `src` without moving it. This leaves the\n /// memory in `src` unchanged.\n ///\n-/// Unlike `read`, the pointer may be unaligned.\n+/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n+///\n+/// [`read`]: ./fn.read.html\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// Additionally, if `T` is not [`Copy`], only the returned value *or* the\n+/// pointed-to value can be used or dropped after calling `read_unaligned`.\n+/// `read_unaligned` creates a bitwise copy of `T`, regardless of whether `T:\n+/// Copy`, and this can result in undefined behavior if both copies are used.\n+/// Note that `*src = foo` counts as a use because it will attempt to drop the\n+/// value previously at `*src`.  [`write_unaligned`] can be used to overwrite\n+/// data without causing it to be dropped.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access members of a packed struct by reference:\n ///\n /// ```\n-/// let x = 12;\n-/// let y = &x as *const i32;\n+/// use std::ptr;\n ///\n-/// unsafe {\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// #[repr(packed, C)]\n+/// #[derive(Default)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n /// }\n+///\n+/// let x = Packed {\n+///     _padding: 0x00,\n+///     unaligned: 0x01020304,\n+/// };\n+///\n+/// let v = unsafe {\n+///     // Take a reference to a 32-bit integer which is not aligned.\n+///     let unaligned = &x.unaligned;\n+///\n+///     // Dereferencing normally will emit an unaligned load instruction,\n+///     // causing undefined behavior.\n+///     // let v = *unaligned; // ERROR\n+///\n+///     // Instead, use `read_unaligned` to read improperly aligned values.\n+///     let v = ptr::read_unaligned(unaligned);\n+///\n+///     v\n+/// };\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n@@ -326,21 +482,28 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// # Safety\n-///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n-///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n /// allocations or resources, so care must be taken not to overwrite an object\n /// that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been [`read`] from.\n+///\n+/// [`read`]: ./fn.read.html\n+///\n+/// # Safety\n ///\n-/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dst` must point to valid memory.\n+///\n+/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n+///   case.\n+///\n+/// [`write_unaligned`]: ./fn.write_unaligned.html\n ///\n /// # Examples\n ///\n@@ -356,6 +519,30 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///     assert_eq!(std::ptr::read(y), 12);\n /// }\n /// ```\n+///\n+/// Manually implement [`mem::swap`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// fn swap<T>(a: &mut T, b: &mut T) {\n+///     unsafe {\n+///         let tmp = ptr::read(a);\n+///         ptr::copy_nonoverlapping(b, a, 1);\n+///         ptr::write(b, tmp);\n+///     }\n+/// }\n+///\n+/// let mut foo = \"foo\".to_owned();\n+/// let mut bar = \"bar\".to_owned();\n+///\n+/// swap(&mut foo, &mut bar);\n+///\n+/// assert_eq!(foo, \"bar\");\n+/// assert_eq!(bar, \"foo\");\n+/// ```\n+///\n+/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -365,36 +552,58 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike `write`, the pointer may be unaligned.\n-///\n-/// # Safety\n+/// Unlike [`write`], the pointer may be unaligned.\n ///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n-///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care must be taken not to overwrite\n+/// an object that should be dropped.\n ///\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n /// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// memory that has previously been read with [`read_unaligned`].\n+///\n+/// [`write`]: ./fn.write.html\n+/// [`read_unaligned`]: ./fn.read_unaligned.html\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dst` must point to valid memory.\n ///\n /// # Examples\n ///\n-/// Basic usage:\n+/// Access fields in a packed struct:\n ///\n /// ```\n-/// let mut x = 0;\n-/// let y = &mut x as *mut i32;\n-/// let z = 12;\n+/// use std::{mem, ptr};\n+///\n+/// #[repr(packed, C)]\n+/// #[derive(Default)]\n+/// struct Packed {\n+///     _padding: u8,\n+///     unaligned: u32,\n+/// }\n+///\n+/// let v = 0x01020304;\n+/// let mut x: Packed = unsafe { mem::zeroed() };\n ///\n /// unsafe {\n-///     std::ptr::write_unaligned(y, z);\n-///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+///     // Take a reference to a 32-bit integer which is not aligned.\n+///     let unaligned = &mut x.unaligned;\n+///\n+///     // Dereferencing normally will emit an unaligned store instruction,\n+///     // causing undefined behavior.\n+///     // *unaligned = v; // ERROR\n+///\n+///     // Instead, use `write_unaligned` to write improperly aligned values.\n+///     ptr::write_unaligned(unaligned, v);\n /// }\n-/// ```\n+///\n+/// // Accessing unaligned values directly is safe.\n+/// assert!(x.unaligned == v);\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n@@ -411,6 +620,11 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n+/// Memory read with `read_volatile` should almost always be written to using\n+/// [`write_volatile`].\n+///\n+/// [`write_volatile`]: ./fn.write_volatile.html\n+///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -427,12 +641,19 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// # Safety\n ///\n-/// Beyond accepting a raw pointer, this is unsafe because it semantically\n-/// moves the value out of `src` without preventing further usage of `src`.\n-/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-/// `src` is not used before the data is overwritten again (e.g. with `write`,\n-/// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n-/// because it will attempt to drop the value previously at `*src`.\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must point to valid, initialized memory.\n+///\n+/// * `src` must be properly aligned.\n+///\n+/// Like [`read`], `read_volatile` creates a bitwise copy of the pointed-to\n+/// object, regardless of whether `T` is [`Copy`]. Using both values can cause\n+/// undefined behavior. However, storing non-[`Copy`] data in I/O memory is\n+/// almost certainly incorrect.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read`]: ./fn.read.html\n ///\n /// # Examples\n ///\n@@ -459,6 +680,18 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n+/// Memory written with `write_volatile` should almost always be read from using\n+/// [`read_volatile`].\n+///\n+/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n+/// could leak allocations or resources, so care must be taken not to overwrite\n+/// an object that should be dropped.\n+///\n+/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n+/// location pointed to by `dst`.\n+///\n+/// [`read_volatile`]: ./fn.read_volatile.html\n+///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -475,14 +708,11 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// # Safety\n ///\n-/// This operation is marked unsafe because it accepts a raw pointer.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// It does not drop the contents of `dst`. This is safe, but it could leak\n-/// allocations or resources, so care must be taken not to overwrite an object\n-/// that should be dropped.\n+/// * `dst` must point to valid memory.\n ///\n-/// This is appropriate for initializing uninitialized memory, or overwriting\n-/// memory that has previously been `read` from.\n+/// * `dst` must be properly aligned.\n ///\n /// # Examples\n ///"}]}