{"sha": "10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZjRkNGI3NGNkN2UwNzJiZjVlOGQzZmI1N2M3NmYzNWVhMDNlMWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T11:11:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-27T12:02:06Z"}, "message": "Make nameresolution resilient to reparsing\n\nWe now store item id's instead of local syntax ptrs, and item ids\ndon't change if you type inside a single function.", "tree": {"sha": "ec9c94fa1bf857032b3914175d03fd179f74c660", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec9c94fa1bf857032b3914175d03fd179f74c660"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "html_url": "https://github.com/rust-lang/rust/commit/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d87799a4a73e5a58fce4e3caa88ad90347bdabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d87799a4a73e5a58fce4e3caa88ad90347bdabb", "html_url": "https://github.com/rust-lang/rust/commit/4d87799a4a73e5a58fce4e3caa88ad90347bdabb"}], "stats": {"total": 223, "additions": 139, "deletions": 84}, "files": [{"sha": "1faa70a18c640fd59287d6e3d011c3fe05df8e3e", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -46,9 +46,12 @@ pub(super) fn completions(\n                     .iter()\n                     .filter(|(_name, res)| {\n                         // Don't expose this item\n-                        match res.import_name {\n+                        match res.import {\n                             None => true,\n-                            Some(ptr) => !ptr.range().is_subrange(&name_ref.syntax().range()),\n+                            Some(import) => {\n+                                let range = import.range(db, module.source().file_id());\n+                                !range.is_subrange(&name_ref.syntax().range())\n+                            }\n                         }\n                     })\n                     .map(|(name, _res)| CompletionItem {"}, {"sha": "a5e956024a0374e8bd439ace739473cff9efc7c0", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -13,14 +13,15 @@ use crate::{\n     FileId,\n     db::SyntaxDatabase,\n     descriptors::function::{resolve_local_name, FnId, FnScopes},\n-    descriptors::module::{ModuleId, ModuleTree, ModuleSource, nameres::{ItemMap, InputModuleItems, FileItemId}},\n+    descriptors::module::{ModuleId, ModuleTree, ModuleSource, nameres::{ItemMap, InputModuleItems, FileItems}},\n     input::SourceRootId,\n     loc2id::IdDatabase,\n     syntax_ptr::LocalSyntaxPtr,\n     Cancelable,\n };\n \n pub(crate) use self::path::{Path, PathKind};\n+pub(crate) use self::module::nameres::FileItemId;\n \n salsa::query_group! {\n     pub(crate) trait DescriptorDatabase: SyntaxDatabase + IdDatabase {\n@@ -29,7 +30,7 @@ salsa::query_group! {\n             use fn function::imp::fn_scopes;\n         }\n \n-        fn _file_items(file_id: FileId) -> Arc<Vec<SyntaxNode>> {\n+        fn _file_items(file_id: FileId) -> Arc<FileItems> {\n             type FileItemsQuery;\n             storage volatile;\n             use fn module::nameres::file_items;"}, {"sha": "d347a69b01d1e604900bcacce85448b62b98c164", "filename": "crates/ra_analysis/src/descriptors/module/nameres.rs", "status": "modified", "additions": 120, "deletions": 62, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -17,12 +17,13 @@\n use std::{\n     sync::Arc,\n     time::Instant,\n+    ops::Index,\n };\n \n use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n-    SyntaxNode,\n+    SyntaxNode, SyntaxNodeRef, TextRange,\n     SmolStr, SyntaxKind::{self, *},\n     ast::{self, ModuleItemOwner, AstNode}\n };\n@@ -35,28 +36,62 @@ use crate::{\n         DescriptorDatabase,\n         module::{ModuleId, ModuleTree, ModuleSourceNode},\n     },\n-    syntax_ptr::{LocalSyntaxPtr},\n     input::SourceRootId,\n+    arena::{Arena, Id}\n };\n \n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+pub(crate) type FileItemId = Id<SyntaxNode>;\n \n-#[derive(Clone, Copy, Hash, PartialEq, Eq, Debug)]\n-pub(crate) struct FileItemId(u32);\n+/// Maps item's `SyntaxNode`s to `FileItemId` and back.\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub(crate) struct FileItems {\n+    arena: Arena<SyntaxNode>,\n+}\n+\n+impl FileItems {\n+    fn alloc(&mut self, item: SyntaxNode) -> FileItemId {\n+        self.arena.alloc(item)\n+    }\n+    fn id_of(&self, item: SyntaxNodeRef) -> FileItemId {\n+        let (id, _item) = self\n+            .arena\n+            .iter()\n+            .find(|(_id, i)| i.borrowed() == item)\n+            .unwrap();\n+        id\n+    }\n+}\n \n-pub(crate) fn file_items(db: &impl DescriptorDatabase, file_id: FileId) -> Arc<Vec<SyntaxNode>> {\n+impl Index<FileItemId> for FileItems {\n+    type Output = SyntaxNode;\n+    fn index(&self, idx: FileItemId) -> &SyntaxNode {\n+        &self.arena[idx]\n+    }\n+}\n+\n+pub(crate) fn file_items(db: &impl DescriptorDatabase, file_id: FileId) -> Arc<FileItems> {\n     let source_file = db.file_syntax(file_id);\n     let source_file = source_file.borrowed();\n-    let res = source_file.syntax().descendants()\n+    let mut res = FileItems::default();\n+    source_file\n+        .syntax()\n+        .descendants()\n         .filter_map(ast::ModuleItem::cast)\n         .map(|it| it.syntax().owned())\n-        .collect::<Vec<_>>();\n+        .for_each(|it| {\n+            res.alloc(it);\n+        });\n     Arc::new(res)\n }\n \n-pub(crate) fn file_item(db: &impl DescriptorDatabase, file_id: FileId, file_item_id: FileItemId) -> SyntaxNode {\n-    let items = db._file_items(file_id);\n-    let idx = file_item_id.0 as usize;\n-    items[idx].clone()\n+pub(crate) fn file_item(\n+    db: &impl DescriptorDatabase,\n+    file_id: FileId,\n+    file_item_id: FileItemId,\n+) -> SyntaxNode {\n+    db._file_items(file_id)[file_item_id].clone()\n }\n \n /// Item map is the result of the name resolution. Item map contains, for each\n@@ -83,17 +118,44 @@ pub(crate) struct InputModuleItems {\n     imports: Vec<Import>,\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+struct ModuleItem {\n+    id: FileItemId,\n+    name: SmolStr,\n+    kind: SyntaxKind,\n+    vis: Vis,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Vis {\n+    // Priv,\n+    Other,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct Import {\n     path: Path,\n     kind: ImportKind,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) struct NamedImport {\n+    file_item_id: FileItemId,\n+    relative_range: TextRange,\n+}\n+\n+impl NamedImport {\n+    pub(crate) fn range(&self, db: &impl DescriptorDatabase, file_id: FileId) -> TextRange {\n+        let syntax = db._file_item(file_id, self.file_item_id);\n+        let offset = syntax.borrowed().range().start();\n+        self.relative_range + offset\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n enum ImportKind {\n     Glob,\n-    // TODO: make offset independent\n-    Named(LocalSyntaxPtr),\n+    Named(NamedImport),\n }\n \n pub(crate) fn input_module_items(\n@@ -103,18 +165,19 @@ pub(crate) fn input_module_items(\n ) -> Cancelable<Arc<InputModuleItems>> {\n     let module_tree = db._module_tree(source_root)?;\n     let source = module_id.source(&module_tree);\n+    let file_items = db._file_items(source.file_id());\n     let res = match source.resolve(db) {\n         ModuleSourceNode::SourceFile(it) => {\n             let items = it.borrowed().items();\n-            InputModuleItems::new(items)\n+            InputModuleItems::new(&file_items, items)\n         }\n         ModuleSourceNode::Module(it) => {\n             let items = it\n                 .borrowed()\n                 .item_list()\n                 .into_iter()\n                 .flat_map(|it| it.items());\n-            InputModuleItems::new(items)\n+            InputModuleItems::new(&file_items, items)\n         }\n     };\n     Ok(Arc::new(res))\n@@ -133,7 +196,6 @@ pub(crate) fn item_map(\n             Ok((id, items))\n         })\n         .collect::<Cancelable<FxHashMap<_, _>>>()?;\n-\n     let mut resolver = Resolver {\n         db: db,\n         input: &input,\n@@ -155,8 +217,7 @@ pub(crate) struct Resolution {\n     /// None for unresolved\n     pub(crate) def_id: Option<DefId>,\n     /// ident by whitch this is imported into local scope.\n-    /// TODO: make this offset-independent.\n-    pub(crate) import_name: Option<LocalSyntaxPtr>,\n+    pub(crate) import: Option<NamedImport>,\n }\n \n // #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -171,69 +232,63 @@ pub(crate) struct Resolution {\n //     values: Option<T>,\n // }\n \n-#[derive(Debug, PartialEq, Eq)]\n-struct ModuleItem {\n-    ptr: LocalSyntaxPtr,\n-    name: SmolStr,\n-    kind: SyntaxKind,\n-    vis: Vis,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-enum Vis {\n-    // Priv,\n-    Other,\n-}\n-\n impl InputModuleItems {\n-    fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> InputModuleItems {\n+    fn new<'a>(\n+        file_items: &FileItems,\n+        items: impl Iterator<Item = ast::ModuleItem<'a>>,\n+    ) -> InputModuleItems {\n         let mut res = InputModuleItems::default();\n         for item in items {\n-            res.add_item(item);\n+            res.add_item(file_items, item);\n         }\n         res\n     }\n \n-    fn add_item(&mut self, item: ast::ModuleItem) -> Option<()> {\n+    fn add_item(&mut self, file_items: &FileItems, item: ast::ModuleItem) -> Option<()> {\n         match item {\n-            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n             ast::ModuleItem::ImplItem(_) => {\n                 // impls don't define items\n             }\n-            ast::ModuleItem::UseItem(it) => self.add_use_item(it),\n+            ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n             ast::ModuleItem::ExternCrateItem(_) => {\n                 // TODO\n             }\n-            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(it)?),\n-            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(it)?),\n+            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n+            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(file_items, it)?),\n         }\n         Some(())\n     }\n \n-    fn add_use_item(&mut self, item: ast::UseItem) {\n-        Path::expand_use_item(item, |path, ptr| {\n-            let kind = match ptr {\n+    fn add_use_item(&mut self, file_items: &FileItems, item: ast::UseItem) {\n+        let file_item_id = file_items.id_of(item.syntax());\n+        let start_offset = item.syntax().range().start();\n+        Path::expand_use_item(item, |path, range| {\n+            let kind = match range {\n                 None => ImportKind::Glob,\n-                Some(ptr) => ImportKind::Named(ptr),\n+                Some(range) => ImportKind::Named(NamedImport {\n+                    file_item_id,\n+                    relative_range: range - start_offset,\n+                }),\n             };\n             self.imports.push(Import { kind, path })\n         })\n     }\n }\n \n impl ModuleItem {\n-    fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n+    fn new<'a>(file_items: &FileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n         let name = item.name()?.text();\n-        let ptr = LocalSyntaxPtr::new(item.syntax());\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n+        let id = file_items.id_of(item.syntax());\n         let res = ModuleItem {\n-            ptr,\n+            id,\n             name,\n             kind,\n             vis,\n@@ -273,12 +328,12 @@ where\n \n         for import in input.imports.iter() {\n             if let Some(name) = import.path.segments.iter().last() {\n-                if let ImportKind::Named(ptr) = import.kind {\n+                if let ImportKind::Named(import) = import.kind {\n                     module_items.items.insert(\n                         name.clone(),\n                         Resolution {\n                             def_id: None,\n-                            import_name: Some(ptr),\n+                            import: Some(import),\n                         },\n                     );\n                 }\n@@ -290,12 +345,14 @@ where\n                 // handle submodules separatelly\n                 continue;\n             }\n-            let ptr = item.ptr.into_global(file_id);\n-            let def_loc = DefLoc::Item { ptr };\n+            let def_loc = DefLoc::Item {\n+                file_id,\n+                id: item.id,\n+            };\n             let def_id = self.db.id_maps().def_id(def_loc);\n             let resolution = Resolution {\n                 def_id: Some(def_id),\n-                import_name: None,\n+                import: None,\n             };\n             module_items.items.insert(item.name.clone(), resolution);\n         }\n@@ -308,7 +365,7 @@ where\n             let def_id = self.db.id_maps().def_id(def_loc);\n             let resolution = Resolution {\n                 def_id: Some(def_id),\n-                import_name: None,\n+                import: None,\n             };\n             module_items.items.insert(name, resolution);\n         }\n@@ -362,7 +419,7 @@ where\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n                         def_id: Some(def_id),\n-                        import_name: Some(ptr),\n+                        import: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);\n                 })\n@@ -473,10 +530,11 @@ mod tests {\n             let events = db.log_executed(|| {\n                 db._item_map(source_root).unwrap();\n             });\n-            // assert!(\n-            //     !format!(\"{:?}\", events).contains(\"_item_map\"),\n-            //     \"{:#?}\", events\n-            // )\n+            assert!(\n+                !format!(\"{:?}\", events).contains(\"_item_map\"),\n+                \"{:#?}\",\n+                events\n+            )\n         }\n     }\n }"}, {"sha": "8279daf4bf6e0a27a549f57c1d3cbbf0895d35f1", "filename": "crates/ra_analysis/src/descriptors/path.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fpath.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -1,6 +1,4 @@\n-use ra_syntax::{SmolStr, ast, AstNode};\n-\n-use crate::syntax_ptr::LocalSyntaxPtr;\n+use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(crate) struct Path {\n@@ -18,10 +16,7 @@ pub(crate) enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(\n-        item: ast::UseItem,\n-        mut cb: impl FnMut(Path, Option<LocalSyntaxPtr>),\n-    ) {\n+    pub(crate) fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n@@ -77,7 +72,7 @@ impl Path {\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,\n-    cb: &mut impl FnMut(Path, Option<LocalSyntaxPtr>),\n+    cb: &mut impl FnMut(Path, Option<TextRange>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -93,13 +88,13 @@ fn expand_use_tree(\n     } else {\n         if let Some(ast_path) = tree.path() {\n             if let Some(path) = convert_path(prefix, ast_path) {\n-                let ptr = if tree.has_star() {\n+                let range = if tree.has_star() {\n                     None\n                 } else {\n-                    let ptr = LocalSyntaxPtr::new(ast_path.segment().unwrap().syntax());\n-                    Some(ptr)\n+                    let range = ast_path.segment().unwrap().syntax().range();\n+                    Some(range)\n                 };\n-                cb(path, ptr)\n+                cb(path, range)\n             }\n         }\n     }"}, {"sha": "c7c799a91fe776e1d72e4f6c6125eb425ec7e383", "filename": "crates/ra_analysis/src/loc2id.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Floc2id.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -8,6 +8,8 @@ use std::{\n use rustc_hash::FxHashMap;\n \n use crate::{\n+    FileId,\n+    descriptors::FileItemId,\n     descriptors::module::ModuleId,\n     syntax_ptr::SyntaxPtr,\n     input::SourceRootId,\n@@ -102,7 +104,8 @@ pub(crate) enum DefLoc {\n         source_root: SourceRootId,\n     },\n     Item {\n-        ptr: SyntaxPtr,\n+        file_id: FileId,\n+        id: FileItemId,\n     },\n }\n "}, {"sha": "e45934ce099a98ed0e432c684fd33d24b307c9d7", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=10f4d4b74cd7e072bf5e8d3fb57c76f35ea03e1d", "patch": "@@ -62,11 +62,6 @@ impl LocalSyntaxPtr {\n             local: self,\n         }\n     }\n-\n-    // Seems unfortunate to expose\n-    pub(crate) fn range(self) -> TextRange {\n-        self.range\n-    }\n }\n \n #[test]"}]}