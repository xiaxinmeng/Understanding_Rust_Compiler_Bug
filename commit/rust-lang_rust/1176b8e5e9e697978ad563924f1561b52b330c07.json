{"sha": "1176b8e5e9e697978ad563924f1561b52b330c07", "node_id": "C_kwDOAAsO6NoAKDExNzZiOGU1ZTllNjk3OTc4YWQ1NjM5MjRmMTU2MWI1MmIzMzBjMDc", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-01T08:11:43Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-20T08:40:11Z"}, "message": "Handle closures with type annotations on args", "tree": {"sha": "5a27c0f9c06d229e5e3f587fc4e061bf294db334", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a27c0f9c06d229e5e3f587fc4e061bf294db334"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1176b8e5e9e697978ad563924f1561b52b330c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1176b8e5e9e697978ad563924f1561b52b330c07", "html_url": "https://github.com/rust-lang/rust/commit/1176b8e5e9e697978ad563924f1561b52b330c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1176b8e5e9e697978ad563924f1561b52b330c07/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff702cbb547ea02381820536b27a575f14ba59e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff702cbb547ea02381820536b27a575f14ba59e", "html_url": "https://github.com/rust-lang/rust/commit/2ff702cbb547ea02381820536b27a575f14ba59e"}], "stats": {"total": 212, "additions": 132, "deletions": 80}, "files": [{"sha": "7baae4faa235b25821b7325fb019f547d30a4d12", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -7,7 +7,7 @@ use clippy_utils::{get_parent_expr_for_hir, is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{self, ExprKind, HirId, PatKind};\n+use rustc_hir::{self, ExprKind, HirId, MutTy, PatKind, TyKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::place::ProjectionKind;\n@@ -52,26 +52,12 @@ pub(super) fn check<'tcx>(\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, binding_id, _, _) = strip_pat_refs(closure_arg.pat).kind {\n-                        // this binding is composed of at least two levels of references, so we need to remove one\n-                        let binding_type = cx.typeck_results().node_type(binding_id);\n-                        let innermost_is_ref = if let ty::Ref(_, inner,_) = binding_type.kind() {\n-                            matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_ref())\n-                        } else {\n-                            false\n-                        };\n-\n+                    } else if let PatKind::Binding(..) = strip_pat_refs(closure_arg.pat).kind {\n                         // `find()` provides a reference to the item, but `any` does not,\n                         // so we should fix item usages for suggestion\n-                        if let Some(closure_sugg) = get_closure_suggestion(cx, search_arg, closure_body) {\n+                        if let Some(closure_sugg) = get_closure_suggestion(cx, search_arg) {\n                             applicability = closure_sugg.applicability;\n-                            if innermost_is_ref {\n-                                Some(closure_sugg.suggestion.replacen('&', \"\", 1))\n-                            } else {\n-                                Some(closure_sugg.suggestion)\n-                            }\n-                        } else if innermost_is_ref {\n-                            Some(search_snippet.replacen('&', \"\", 1))\n+                            Some(closure_sugg.suggestion)\n                         } else {\n                             Some(search_snippet.to_string())\n                         }\n@@ -174,6 +160,7 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n+#[derive(Debug)]\n struct ClosureSugg {\n     applicability: Applicability,\n     suggestion: String,\n@@ -182,38 +169,45 @@ struct ClosureSugg {\n // Build suggestion gradually by handling closure arg specific usages,\n // such as explicit deref and borrowing cases.\n // Returns `None` if no such use cases have been triggered in closure body\n-fn get_closure_suggestion<'tcx>(\n-    cx: &LateContext<'_>,\n-    search_arg: &'tcx hir::Expr<'_>,\n-    closure_body: &hir::Body<'_>,\n-) -> Option<ClosureSugg> {\n-    let mut visitor = DerefDelegate {\n-        cx,\n-        closure_span: search_arg.span,\n-        next_pos: search_arg.span.lo(),\n-        suggestion_start: String::new(),\n-        applicability: Applicability::MachineApplicable,\n-    };\n+fn get_closure_suggestion<'tcx>(cx: &LateContext<'_>, search_expr: &'tcx hir::Expr<'_>) -> Option<ClosureSugg> {\n+    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = search_expr.kind {\n+        let closure_body = cx.tcx.hir().body(body_id);\n+        // is closure arg a double reference (i.e.: `|x: &&i32| ...`)\n+        let closure_arg_is_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind {\n+            matches!(ty.kind, TyKind::Rptr(_, MutTy { .. }))\n+        } else {\n+            false\n+        };\n+\n+        let mut visitor = DerefDelegate {\n+            cx,\n+            closure_span: search_expr.span,\n+            closure_arg_is_double_ref,\n+            next_pos: search_expr.span.lo(),\n+            suggestion_start: String::new(),\n+            applicability: Applicability::MachineApplicable,\n+        };\n \n-    let fn_def_id = cx.tcx.hir().local_def_id(search_arg.hir_id);\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n-            .consume_body(closure_body);\n-    });\n+        let fn_def_id = cx.tcx.hir().local_def_id(search_expr.hir_id);\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n+            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+                .consume_body(closure_body);\n+        });\n \n-    if visitor.suggestion_start.is_empty() {\n-        None\n-    } else {\n-        Some(ClosureSugg {\n-            applicability: visitor.applicability,\n-            suggestion: visitor.finish(),\n-        })\n+        if !visitor.suggestion_start.is_empty() {\n+            return Some(ClosureSugg {\n+                applicability: visitor.applicability,\n+                suggestion: visitor.finish(),\n+            });\n+        }\n     }\n+    None\n }\n \n struct DerefDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     closure_span: Span,\n+    closure_arg_is_double_ref: bool,\n     next_pos: BytePos,\n     suggestion_start: String,\n     applicability: Applicability,\n@@ -223,7 +217,12 @@ impl DerefDelegate<'_, 'tcx> {\n     pub fn finish(&mut self) -> String {\n         let end_span = Span::new(self.next_pos, self.closure_span.hi(), self.closure_span.ctxt(), None);\n         let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n-        format!(\"{}{}\", self.suggestion_start, end_snip)\n+        let sugg = format!(\"{}{}\", self.suggestion_start, end_snip);\n+        if self.closure_arg_is_double_ref {\n+            sugg.replacen('&', \"\", 1)\n+        } else {\n+            sugg\n+        }\n     }\n \n     fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n@@ -261,6 +260,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n             if cmt.place.projections.is_empty() {\n                 // handle item without any projection, that needs an explicit borrowing\n                 // i.e.: suggest `&x` instead of `x`\n+                self.closure_arg_is_double_ref = false;\n                 self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n             } else {\n                 // cases where a parent `Call` or `MethodCall` is using the item\n@@ -272,29 +272,43 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                 // - `self` arguments in the case of `x.is_something()` are also automatically (de)referenced, and\n                 //   no projection should be suggested\n                 if let Some(parent_expr) = get_parent_expr_for_hir(self.cx, cmt.hir_id) {\n-                    if let ExprKind::Call(_, call_args) | ExprKind::MethodCall(_, _, call_args, _) = parent_expr.kind {\n-                        let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n-                        let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n-\n-                        if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n-                            // suggest ampersand if call function is taking args by double reference\n-                            let takes_arg_by_double_ref = self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n-\n-                            // do not suggest ampersand if the ident is the method caller\n-                            let ident_sugg = if !call_args.is_empty()\n-                                && call_args[0].hir_id == cmt.hir_id\n-                                && !takes_arg_by_double_ref\n-                            {\n-                                format!(\"{}{}\", start_snip, ident_str)\n-                            } else {\n-                                format!(\"{}&{}\", start_snip, ident_str)\n-                            };\n-                            self.suggestion_start.push_str(&ident_sugg);\n+                    match &parent_expr.kind {\n+                        // given expression is the self argument and will be handled completely by the compiler\n+                        // i.e.: `|x| x.is_something()`\n+                        ExprKind::MethodCall(_, _, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                            self.suggestion_start.push_str(&format!(\"{}{}\", start_snip, ident_str));\n                             self.next_pos = span.hi();\n                             return;\n-                        }\n+                        },\n+                        // item is used in a call\n+                        // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [_, call_args @ ..], _) => {\n+                            let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n+                            let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n \n-                        self.applicability = Applicability::Unspecified;\n+                            if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n+                                // suggest ampersand if call function is taking args by double reference\n+                                let takes_arg_by_double_ref =\n+                                    self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n+\n+                                // no need to bind again if the function doesn't take arg by double ref\n+                                // and if the item is already a double ref\n+                                let ident_sugg = if !call_args.is_empty()\n+                                    && !takes_arg_by_double_ref\n+                                    && self.closure_arg_is_double_ref\n+                                {\n+                                    format!(\"{}{}\", start_snip, ident_str)\n+                                } else {\n+                                    format!(\"{}&{}\", start_snip, ident_str)\n+                                };\n+                                self.suggestion_start.push_str(&ident_sugg);\n+                                self.next_pos = span.hi();\n+                                return;\n+                            }\n+\n+                            self.applicability = Applicability::Unspecified;\n+                        },\n+                        _ => (),\n                     }\n                 }\n \n@@ -346,7 +360,9 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n \n                 // handle `ProjectionKind::Deref` by removing one explicit deref\n                 // if no special case was detected (i.e.: suggest `*x` instead of `**x`)\n-                if !projections_handled {\n+                if projections_handled {\n+                    self.closure_arg_is_double_ref = false;\n+                } else {\n                     let last_deref = cmt\n                         .place\n                         .projections"}, {"sha": "adc6b2739c44939e8e130bd266190d48b60851fd", "filename": "tests/ui/search_is_some_fixable_none.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.fixed?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -118,9 +118,12 @@ mod issue7392 {\n \n         let v = vec![3, 2, 1, 0];\n         let _ = !v.iter().any(|x| deref_enough(*x));\n+        let _ = !v.iter().any(|x: &u32| deref_enough(*x));\n \n         #[allow(clippy::redundant_closure)]\n         let _ = !v.iter().any(|x| arg_no_deref(&x));\n+        #[allow(clippy::redundant_closure)]\n+        let _ = !v.iter().any(|x: &u32| arg_no_deref(&x));\n     }\n \n     fn field_index_projection() {"}, {"sha": "f0be2be4788b2a33a5328766889047a63a948e84", "filename": "tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -122,9 +122,12 @@ mod issue7392 {\n \n         let v = vec![3, 2, 1, 0];\n         let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n+        let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_none();\n \n         #[allow(clippy::redundant_closure)]\n         let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_none();\n     }\n \n     fn field_index_projection() {"}, {"sha": "910d5ad37b89f909b636d52e0959ce5be32fda21", "filename": "tests/ui/search_is_some_fixable_none.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.stderr?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -188,13 +188,25 @@ LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| deref_enough(*x))`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:127:17\n+  --> $DIR/search_is_some_fixable_none.rs:125:17\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x: &u32| deref_enough(*x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:128:17\n    |\n LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| arg_no_deref(&x))`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:147:17\n+  --> $DIR/search_is_some_fixable_none.rs:130:17\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x: &u32| arg_no_deref(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:150:17\n    |\n LL |           let _ = vfoo\n    |  _________________^\n@@ -210,34 +222,34 @@ LL ~             .iter().any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0]\n    |\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:163:17\n+  --> $DIR/search_is_some_fixable_none.rs:166:17\n    |\n LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.inner[0].bar == 2)`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:168:17\n+  --> $DIR/search_is_some_fixable_none.rs:171:17\n    |\n LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|x| (**x)[0] == 9)`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:181:17\n+  --> $DIR/search_is_some_fixable_none.rs:184:17\n    |\n LL |         let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.by_ref(&v.bar))`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:185:17\n+  --> $DIR/search_is_some_fixable_none.rs:188:17\n    |\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n \n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_none.rs:186:17\n+  --> $DIR/search_is_some_fixable_none.rs:189:17\n    |\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 38 previous errors\n "}, {"sha": "2799ae0a98b814ffea09145b16a8c7a0c1cecede", "filename": "tests/ui/search_is_some_fixable_some.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.fixed?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -119,9 +119,12 @@ mod issue7392 {\n \n         let v = vec![3, 2, 1, 0];\n         let _ = v.iter().any(|x| deref_enough(*x));\n+        let _ = v.iter().any(|x: &u32| deref_enough(*x));\n \n         #[allow(clippy::redundant_closure)]\n         let _ = v.iter().any(|x| arg_no_deref(&x));\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().any(|x: &u32| arg_no_deref(&x));\n     }\n \n     fn field_index_projection() {"}, {"sha": "bf9d50d905703e2f1fc21719e2e31156f395f4f7", "filename": "tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -121,9 +121,12 @@ mod issue7392 {\n \n         let v = vec![3, 2, 1, 0];\n         let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n+        let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_some();\n \n         #[allow(clippy::redundant_closure)]\n         let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_some();\n     }\n \n     fn field_index_projection() {"}, {"sha": "71680bc8d2a2074070257ee09e4a38bb7dc18bed", "filename": "tests/ui/search_is_some_fixable_some.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1176b8e5e9e697978ad563924f1561b52b330c07/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.stderr?ref=1176b8e5e9e697978ad563924f1561b52b330c07", "patch": "@@ -179,48 +179,60 @@ LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| deref_enough(*x))`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:126:26\n+  --> $DIR/search_is_some_fixable_some.rs:124:26\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x: &u32| deref_enough(*x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:127:26\n    |\n LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| arg_no_deref(&x))`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:148:14\n+  --> $DIR/search_is_some_fixable_some.rs:129:26\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x: &u32| arg_no_deref(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:151:14\n    |\n LL |               .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n    |  ______________^\n LL | |             .is_some();\n    | |______________________^ help: use `any()` instead: `any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:162:29\n+  --> $DIR/search_is_some_fixable_some.rs:165:29\n    |\n LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_some();\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.inner[0].bar == 2)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:167:29\n+  --> $DIR/search_is_some_fixable_some.rs:170:29\n    |\n LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_some();\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| (**x)[0] == 9)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:180:29\n+  --> $DIR/search_is_some_fixable_some.rs:183:29\n    |\n LL |         let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_some();\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.by_ref(&v.bar))`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:184:55\n+  --> $DIR/search_is_some_fixable_some.rs:187:55\n    |\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_some();\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n \n error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable_some.rs:185:55\n+  --> $DIR/search_is_some_fixable_some.rs:188:55\n    |\n LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 38 previous errors\n "}]}