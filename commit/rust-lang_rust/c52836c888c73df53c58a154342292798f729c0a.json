{"sha": "c52836c888c73df53c58a154342292798f729c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MjgzNmM4ODhjNzNkZjUzYzU4YTE1NDM0MjI5Mjc5OGY3MjljMGE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-10-21T21:56:36Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-10-21T21:56:36Z"}, "message": "debuginfo: Use TypeIdHasher to create global type identifiers for debuginfo.", "tree": {"sha": "b29ba316f7b3c6daf2f0e3057de5ed83a662df87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29ba316f7b3c6daf2f0e3057de5ed83a662df87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c52836c888c73df53c58a154342292798f729c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c52836c888c73df53c58a154342292798f729c0a", "html_url": "https://github.com/rust-lang/rust/commit/c52836c888c73df53c58a154342292798f729c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c52836c888c73df53c58a154342292798f729c0a/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f3edb034ca681f3d81482253f0435fff1026a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f3edb034ca681f3d81482253f0435fff1026a6f", "html_url": "https://github.com/rust-lang/rust/commit/6f3edb034ca681f3d81482253f0435fff1026a6f"}], "stats": {"total": 238, "additions": 41, "deletions": 197}, "files": [{"sha": "11355761a9c70748d956d0afc3fb2486f963e706", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 41, "deletions": 197, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/c52836c888c73df53c58a154342292798f729c0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52836c888c73df53c58a154342292798f729c0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c52836c888c73df53c58a154342292798f729c0a", "patch": "@@ -16,7 +16,7 @@ use self::EnumDiscriminantInfo::*;\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                    get_namespace_and_span_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n-use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n+use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use context::SharedCrateContext;\n use session::Session;\n@@ -26,8 +26,11 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DI\n \n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::DefId;\n+use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n+use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n+use rustc_data_structures::blake2b;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -38,6 +41,7 @@ use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n+use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n@@ -46,6 +50,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax_pos::{self, Span};\n \n+\n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n const DW_LANG_RUST: c_uint = 0x1c;\n@@ -138,219 +143,58 @@ impl<'tcx> TypeMap<'tcx> {\n     // ID will be generated and stored for later lookup.\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n-\n-        // basic type             -> {:name of the type:}\n-        // tuple                  -> {tuple_(:param-uid:)*}\n-        // struct                 -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                   -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant           -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)          -> {& :pointee-uid:}\n-        // mut reference (&mut)   -> {&mut :pointee-uid:}\n-        // ptr (*)                -> {* :pointee-uid:}\n-        // mut ptr (*mut)         -> {*mut :pointee-uid:}\n-        // unique ptr (box)       -> {box :pointee-uid:}\n-        // @-ptr (@)              -> {@ :pointee-uid:}\n-        // sized vec ([T; x])     -> {[:size:] :element-uid:}\n-        // unsized vec ([T])      -> {[] :element-uid:}\n-        // trait (T)              -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure                -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n-        //                             :return-type-uid: : (:bounds:)*}\n-        // function               -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n-        //                             :return-type-uid:}\n-\n+        // Let's see if we already have something in the cache\n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n \n-        let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push('{');\n-\n-        match type_.sty {\n-            ty::TyNever    |\n-            ty::TyBool     |\n-            ty::TyChar     |\n-            ty::TyStr      |\n-            ty::TyInt(_)   |\n-            ty::TyUint(_)  |\n-            ty::TyFloat(_) => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyAdt(def, substs) => {\n-                unique_type_id.push_str(&(String::from(def.descr()) + \" \"));\n-                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            }\n-            ty::TyTuple(component_types) if component_types.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyTuple(component_types) => {\n-                unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types {\n-                    let component_type_id =\n-                        self.get_unique_type_id_of_type(cx, component_type);\n-                    let component_type_id =\n-                        self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[..]);\n-                }\n-            },\n-            ty::TyBox(inner_type) => {\n-                unique_type_id.push_str(\"box \");\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push('*');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n+        let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n+                                                   DebugInfoTypeIdHasher::new());\n+        type_id_hasher.visit_ty(type_);\n+        let hash = type_id_hasher.into_inner().into_hash();\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-                unique_type_id.push('&');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n+        let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyArray(inner_type, len) => {\n-                unique_type_id.push_str(&format!(\"[{}]\", len));\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TySlice(inner_type) => {\n-                unique_type_id.push_str(\"[]\");\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyTrait(ref trait_data) => {\n-                unique_type_id.push_str(\"trait \");\n-\n-                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n-                    &trait_data.principal);\n-\n-                from_def_id_and_substs(self,\n-                                       cx,\n-                                       principal.def_id,\n-                                       principal.substs,\n-                                       &mut unique_type_id);\n-            },\n-            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-                if unsafety == hir::Unsafety::Unsafe {\n-                    unique_type_id.push_str(\"unsafe \");\n-                }\n-\n-                unique_type_id.push_str(abi.name());\n+        for byte in hash.into_iter() {\n+            write!(&mut unique_type_id, \"{:x}\", byte).unwrap();\n+        }\n \n-                unique_type_id.push_str(\" fn(\");\n+        let key = self.unique_id_interner.intern(&unique_type_id);\n+        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-                let sig = cx.tcx().erase_late_bound_regions_and_normalize(sig);\n+        return UniqueTypeId(key);\n \n-                for &parameter_type in &sig.inputs {\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[..]);\n-                    unique_type_id.push(',');\n-                }\n+        // The hasher we are using to generate the UniqueTypeId. We want\n+        // something that provides more than the 64 bits of the DefaultHasher.\n+        const TYPE_ID_HASH_LENGTH: usize = 20;\n \n-                if sig.variadic {\n-                    unique_type_id.push_str(\"...\");\n-                }\n+        struct DebugInfoTypeIdHasher {\n+            state: blake2b::Blake2bCtx\n+        }\n \n-                unique_type_id.push_str(\")->\");\n-                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[..]);\n-            },\n-            ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyClosure(_, substs) => {\n-                unique_type_id.push_str(\"closure \");\n-                for upvar_type in substs.upvar_tys {\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_of_type(cx, upvar_type);\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_as_string(upvar_type_id);\n-                    unique_type_id.push_str(&upvar_type_id[..]);\n-                }\n-            },\n-            _ => {\n-                bug!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n-                     type_)\n+        impl ::std::hash::Hasher for DebugInfoTypeIdHasher {\n+            fn finish(&self) -> u64 {\n+                unimplemented!()\n             }\n-        };\n-\n-        unique_type_id.push('}');\n \n-        // Trim to size before storing permanently\n-        unique_type_id.shrink_to_fit();\n-\n-        let key = self.unique_id_interner.intern(&unique_type_id);\n-        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n-\n-        return UniqueTypeId(key);\n-\n-        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n-                                            cx: &CrateContext<'a, 'tcx>,\n-                                            def_id: DefId,\n-                                            substs: &Substs<'tcx>,\n-                                            output: &mut String) {\n-            // First, find out the 'real' def_id of the type. Items inlined from\n-            // other crates have to be mapped back to their source.\n-            let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                if cx.tcx().map.is_inlined_node_id(node_id) {\n-                    // The given def_id identifies the inlined copy of a\n-                    // type definition, let's take the source of the copy.\n-                    cx.defid_for_inlined_node(node_id).unwrap()\n-                } else {\n-                    def_id\n-                }\n-            } else {\n-                def_id\n-            };\n+            #[inline]\n+            fn write(&mut self, bytes: &[u8]) {\n+                blake2b::blake2b_update(&mut self.state, bytes);\n+            }\n+        }\n \n-            // Get the crate name/disambiguator as first part of the identifier.\n-            let crate_name = if def_id.is_local() {\n-                cx.tcx().crate_name.clone()\n-            } else {\n-                cx.sess().cstore.original_crate_name(def_id.krate)\n-            };\n-            let crate_disambiguator = cx.tcx().crate_disambiguator(def_id.krate);\n-\n-            output.push_str(&crate_name[..]);\n-            output.push_str(\"/\");\n-            output.push_str(&crate_disambiguator[..]);\n-            output.push_str(\"/\");\n-            // Add the def-index as the second part\n-            output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n-\n-            if substs.types().next().is_some() {\n-                output.push('<');\n-\n-                for type_parameter in substs.types() {\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[..]);\n-                    output.push(',');\n+        impl DebugInfoTypeIdHasher {\n+            fn new() -> DebugInfoTypeIdHasher {\n+                DebugInfoTypeIdHasher {\n+                    state: blake2b::blake2b_new(TYPE_ID_HASH_LENGTH, &[])\n                 }\n+            }\n \n-                output.push('>');\n+            fn into_hash(self) -> [u8; TYPE_ID_HASH_LENGTH] {\n+                let mut hash = [0u8; TYPE_ID_HASH_LENGTH];\n+                blake2b::blake2b_final(self.state, &mut hash);\n+                hash\n             }\n         }\n     }"}]}