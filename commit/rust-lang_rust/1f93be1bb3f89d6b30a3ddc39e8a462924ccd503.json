{"sha": "1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOTNiZTFiYjNmODlkNmIzMGEzZGRjMzllOGE0NjI5MjRjY2Q1MDM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-25T11:12:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T11:12:45Z"}, "message": "Rollup merge of #65074 - Rantanen:json-byte-pos, r=matklad\n\nFix the start/end byte positions in the compiler JSON output\n\nTrack the changes made during normalization in the `SourceFile` and use this information to correct the `start_byte` and `end_byte` fields in the JSON output.\n\nThis should ensure the start/end byte fields can be used to index the original file, even if Rust normalized the source code for parsing purposes. Both CRLF to LF and BOM removal are handled with this one.\n\nThe rough plan was discussed with @matklad in rust-lang-nursery/rustfix#176 - although I ended up going with `u32` offset tracking so I wouldn't need to deal with `u32 + i32` arithmetics when applying the offset to the span byte positions.\n\nFixes #65029", "tree": {"sha": "ddc93b333040abfda9dd252818e026760f8e0fa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddc93b333040abfda9dd252818e026760f8e0fa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdstitCRBK7hj4Ov3rIwAAdHIIAH6m1ON2WyqcfGjDr2VTcA3K\ndZK7c34fSpmH+/InRQKgI1eopDa+wP3CBnZ/lfLfph4VSPBLBvvBhSodyoJoyky0\nEfUWsW7B6Im7hJI130KrWsXEJPaHkbAOtZ6yJHnARE9/N6SMMTdHKJVW4z1j/gC2\nD63V+cEOczy19XZuumLI3Ogw8tnJWXfysSc7C6Y0d9FvkBkJKPJ7avspKhk1VCdw\n1RSTlsVH1kI0xCom6HNI6HDxyKO/8gPOPuaXsgOaV/qjDsTnV/pFIsyQHvCe2jAM\naJWbi4QGa7XdlhXa56KqFk1UFC8vb78rC2ggBYJtXdRcBH+x8KfJlywjWLkIJP8=\n=elng\n-----END PGP SIGNATURE-----\n", "payload": "tree ddc93b333040abfda9dd252818e026760f8e0fa3\nparent 959b6e324ce2786a4adade6cef222ffbd20f3791\nparent ff1860ad763baac652d3a43a93985e29ade805cb\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572001965 +0200\ncommitter GitHub <noreply@github.com> 1572001965 +0200\n\nRollup merge of #65074 - Rantanen:json-byte-pos, r=matklad\n\nFix the start/end byte positions in the compiler JSON output\n\nTrack the changes made during normalization in the `SourceFile` and use this information to correct the `start_byte` and `end_byte` fields in the JSON output.\n\nThis should ensure the start/end byte fields can be used to index the original file, even if Rust normalized the source code for parsing purposes. Both CRLF to LF and BOM removal are handled with this one.\n\nThe rough plan was discussed with @matklad in rust-lang-nursery/rustfix#176 - although I ended up going with `u32` offset tracking so I wouldn't need to deal with `u32 + i32` arithmetics when applying the offset to the span byte positions.\n\nFixes #65029\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "html_url": "https://github.com/rust-lang/rust/commit/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "959b6e324ce2786a4adade6cef222ffbd20f3791", "url": "https://api.github.com/repos/rust-lang/rust/commits/959b6e324ce2786a4adade6cef222ffbd20f3791", "html_url": "https://github.com/rust-lang/rust/commit/959b6e324ce2786a4adade6cef222ffbd20f3791"}, {"sha": "ff1860ad763baac652d3a43a93985e29ade805cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1860ad763baac652d3a43a93985e29ade805cb", "html_url": "https://github.com/rust-lang/rust/commit/ff1860ad763baac652d3a43a93985e29ade805cb"}], "stats": {"total": 565, "additions": 543, "deletions": 22}, "files": [{"sha": "2510d7efb59e7eac876a753925dc54a4c8f355ba", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -425,6 +425,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             ref lines,\n             ref multibyte_chars,\n             ref non_narrow_chars,\n+            ref normalized_pos,\n         } = *self;\n \n         (name_hash as u64).hash_stable(hcx, hasher);\n@@ -453,6 +454,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         for &char_pos in non_narrow_chars.iter() {\n             stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n         }\n+\n+        normalized_pos.len().hash_stable(hcx, hasher);\n+        for &char_pos in normalized_pos.iter() {\n+            stable_normalized_pos(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n+\n     }\n }\n \n@@ -482,6 +489,18 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n     (pos.0 - source_file_start.0, width as u32)\n }\n \n+fn stable_normalized_pos(np: ::syntax_pos::NormalizedPos,\n+                         source_file_start: ::syntax_pos::BytePos)\n+                         -> (u32, u32) {\n+    let ::syntax_pos::NormalizedPos {\n+        pos,\n+        diff\n+    } = np;\n+\n+    (pos.0 - source_file_start.0, diff)\n+}\n+\n+\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the"}, {"sha": "09ff7891a9debce40b602f16bf7db5a0bbdcf4e9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -1319,6 +1319,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       mut lines,\n                                       mut multibyte_chars,\n                                       mut non_narrow_chars,\n+                                      mut normalized_pos,\n                                       name_hash,\n                                       .. } = source_file_to_import;\n \n@@ -1338,6 +1339,9 @@ impl<'a, 'tcx> CrateMetadata {\n             for swc in &mut non_narrow_chars {\n                 *swc = *swc - start_pos;\n             }\n+            for np in &mut normalized_pos {\n+                np.pos = np.pos - start_pos;\n+            }\n \n             let local_version = local_source_map.new_imported_source_file(name,\n                                                                    name_was_remapped,\n@@ -1347,7 +1351,8 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars,\n-                                                                   non_narrow_chars);\n+                                                                   non_narrow_chars,\n+                                                                   normalized_pos);\n             debug!(\"CrateMetaData::imported_source_files alloc \\\n                     source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                     translated (start_pos {:?} end_pos {:?})\","}, {"sha": "0b157938375e10284db43cf53b1535a7b0230be8", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -25,6 +25,9 @@ use std::sync::{Arc, Mutex};\n \n use rustc_serialize::json::{as_json, as_pretty_json};\n \n+#[cfg(test)]\n+mod tests;\n+\n pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n@@ -336,8 +339,8 @@ impl DiagnosticSpan {\n \n         DiagnosticSpan {\n             file_name: start.file.name.to_string(),\n-            byte_start: span.lo().0 - start.file.start_pos.0,\n-            byte_end: span.hi().0 - start.file.start_pos.0,\n+            byte_start: start.file.original_relative_byte_pos(span.lo()).0,\n+            byte_end: start.file.original_relative_byte_pos(span.hi()).0,\n             line_start: start.line,\n             line_end: end.line,\n             column_start: start.col.0 + 1,"}, {"sha": "eb0d9ef3947c8f0d67165b88f66fda212216ec61", "filename": "src/libsyntax/json/tests.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson%2Ftests.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,186 @@\n+use super::*;\n+\n+use crate::json::JsonEmitter;\n+use crate::source_map::{FilePathMapping, SourceMap};\n+use crate::tests::Shared;\n+use crate::with_default_globals;\n+\n+use errors::emitter::{ColorConfig, HumanReadableErrorType};\n+use errors::Handler;\n+use rustc_serialize::json::decode;\n+use syntax_pos::{BytePos, Span};\n+\n+use std::str;\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct TestData {\n+    spans: Vec<SpanTestData>,\n+}\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct SpanTestData {\n+    pub byte_start: u32,\n+    pub byte_end: u32,\n+    pub line_start: u32,\n+    pub column_start: u32,\n+    pub line_end: u32,\n+    pub column_end: u32,\n+}\n+\n+/// Test the span yields correct positions in JSON.\n+fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n+    let expected_output = TestData { spans: vec![expected_output] };\n+\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n+\n+        let output = Arc::new(Mutex::new(Vec::new()));\n+        let je = JsonEmitter::new(\n+            Box::new(Shared { data: output.clone() }),\n+            None,\n+            sm,\n+            true,\n+            HumanReadableErrorType::Short(ColorConfig::Never),\n+            false,\n+        );\n+\n+        let span = Span::with_root_ctxt(BytePos(span.0), BytePos(span.1));\n+        let handler = Handler::with_emitter(true, None, Box::new(je));\n+        handler.span_err(span, \"foo\");\n+\n+        let bytes = output.lock().unwrap();\n+        let actual_output = str::from_utf8(&bytes).unwrap();\n+        let actual_output: TestData = decode(actual_output).unwrap();\n+\n+        assert_eq!(expected_output, actual_output)\n+    })\n+}\n+\n+#[test]\n+fn empty() {\n+    test_positions(\n+        \" \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 0,\n+            byte_end: 1,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn bom() {\n+    test_positions(\n+        \"\\u{feff} \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 4,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn lf_newlines() {\n+    test_positions(\n+        \"\\nmod foo;\\nmod bar;\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 12,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines() {\n+    test_positions(\n+        \"\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 6,\n+            byte_end: 14,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines_with_bom() {\n+    test_positions(\n+        \"\\u{feff}\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 9,\n+            byte_end: 17,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_before_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (2, 3),\n+        SpanTestData {\n+            byte_start: 2,\n+            byte_end: 3,\n+            line_start: 1,\n+            column_start: 3,\n+            line_end: 1,\n+            column_end: 4,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_on_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (3, 4),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 5,\n+            line_start: 1,\n+            column_start: 4,\n+            line_end: 2,\n+            column_end: 1,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_after_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (4, 5),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 6,\n+            line_start: 2,\n+            column_start: 1,\n+            line_end: 2,\n+            column_end: 2,\n+        },\n+    )\n+}"}, {"sha": "d7760e0cf9ee452964d1fdf607a2966a56cd05a4", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -283,6 +283,7 @@ impl SourceMap {\n         mut file_local_lines: Vec<BytePos>,\n         mut file_local_multibyte_chars: Vec<MultiByteChar>,\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n+        mut file_local_normalized_pos: Vec<NormalizedPos>,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n@@ -301,6 +302,10 @@ impl SourceMap {\n             *swc = *swc + start_pos;\n         }\n \n+        for nc in &mut file_local_normalized_pos {\n+            nc.pos = nc.pos + start_pos;\n+        }\n+\n         let source_file = Lrc::new(SourceFile {\n             name: filename,\n             name_was_remapped,\n@@ -314,6 +319,7 @@ impl SourceMap {\n             lines: file_local_lines,\n             multibyte_chars: file_local_multibyte_chars,\n             non_narrow_chars: file_local_non_narrow_chars,\n+            normalized_pos: file_local_normalized_pos,\n             name_hash,\n         });\n "}, {"sha": "e73c8b43bccbf4d9242db01d0af54466fdc04af1", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -111,8 +111,8 @@ struct SpanLabel {\n     label: &'static str,\n }\n \n-struct Shared<T: Write> {\n-    data: Arc<Mutex<T>>,\n+crate struct Shared<T: Write> {\n+    pub data: Arc<Mutex<T>>,\n }\n \n impl<T: Write> Write for Shared<T> {"}, {"sha": "9034f8c1afd1bbe0314341413abe34835bce69d3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -855,6 +855,15 @@ impl Sub<BytePos> for NonNarrowChar {\n     }\n }\n \n+/// Identifies an offset of a character that was normalized away from `SourceFile`.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+pub struct NormalizedPos {\n+    /// The absolute offset of the character in the `SourceMap`.\n+    pub pos: BytePos,\n+    /// The difference between original and normalized string at position.\n+    pub diff: u32,\n+}\n+\n /// The state of the lazy external source loading mechanism of a `SourceFile`.\n #[derive(PartialEq, Eq, Clone)]\n pub enum ExternalSource {\n@@ -918,6 +927,8 @@ pub struct SourceFile {\n     pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code.\n     pub non_narrow_chars: Vec<NonNarrowChar>,\n+    /// Locations of characters removed during normalization.\n+    pub normalized_pos: Vec<NormalizedPos>,\n     /// A hash of the filename, used for speeding up hashing in incremental compilation.\n     pub name_hash: u128,\n }\n@@ -984,6 +995,9 @@ impl Encodable for SourceFile {\n             })?;\n             s.emit_struct_field(\"name_hash\", 8, |s| {\n                 self.name_hash.encode(s)\n+            })?;\n+            s.emit_struct_field(\"normalized_pos\", 9, |s| {\n+                self.normalized_pos.encode(s)\n             })\n         })\n     }\n@@ -1034,6 +1048,8 @@ impl Decodable for SourceFile {\n                 d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n                 d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n+            let normalized_pos: Vec<NormalizedPos> =\n+                d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n@@ -1050,6 +1066,7 @@ impl Decodable for SourceFile {\n                 lines,\n                 multibyte_chars,\n                 non_narrow_chars,\n+                normalized_pos,\n                 name_hash,\n             })\n         })\n@@ -1068,8 +1085,7 @@ impl SourceFile {\n                unmapped_path: FileName,\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n-        remove_bom(&mut src);\n-        normalize_newlines(&mut src);\n+        let normalized_pos = normalize_src(&mut src, start_pos);\n \n         let src_hash = {\n             let mut hasher: StableHasher = StableHasher::new();\n@@ -1102,6 +1118,7 @@ impl SourceFile {\n             lines,\n             multibyte_chars,\n             non_narrow_chars,\n+            normalized_pos,\n             name_hash,\n         })\n     }\n@@ -1228,20 +1245,52 @@ impl SourceFile {\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n+\n+    /// Calculates the original byte position relative to the start of the file\n+    /// based on the given byte position.\n+    pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {\n+\n+        // Diff before any records is 0. Otherwise use the previously recorded\n+        // diff as that applies to the following characters until a new diff\n+        // is recorded.\n+        let diff = match self.normalized_pos.binary_search_by(\n+                            |np| np.pos.cmp(&pos)) {\n+            Ok(i) => self.normalized_pos[i].diff,\n+            Err(i) if i == 0 => 0,\n+            Err(i) => self.normalized_pos[i-1].diff,\n+        };\n+\n+        BytePos::from_u32(pos.0 - self.start_pos.0 + diff)\n+    }\n+}\n+\n+/// Normalizes the source code and records the normalizations.\n+fn normalize_src(src: &mut String, start_pos: BytePos) -> Vec<NormalizedPos> {\n+    let mut normalized_pos = vec![];\n+    remove_bom(src, &mut normalized_pos);\n+    normalize_newlines(src, &mut normalized_pos);\n+\n+    // Offset all the positions by start_pos to match the final file positions.\n+    for np in &mut normalized_pos {\n+        np.pos.0 += start_pos.0;\n+    }\n+\n+    normalized_pos\n }\n \n /// Removes UTF-8 BOM, if any.\n-fn remove_bom(src: &mut String) {\n+fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if src.starts_with(\"\\u{feff}\") {\n         src.drain(..3);\n+        normalized_pos.push(NormalizedPos { pos: BytePos(0), diff: 3 });\n     }\n }\n \n \n /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n ///\n /// Returns error if there's a lone `\\r` in the string\n-fn normalize_newlines(src: &mut String) {\n+fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if !src.as_bytes().contains(&b'\\r') {\n         return;\n     }\n@@ -1254,6 +1303,8 @@ fn normalize_newlines(src: &mut String) {\n     let mut buf = std::mem::replace(src, String::new()).into_bytes();\n     let mut gap_len = 0;\n     let mut tail = buf.as_mut_slice();\n+    let mut cursor = 0;\n+    let original_gap = normalized_pos.last().map_or(0, |l| l.diff);\n     loop {\n         let idx = match find_crlf(&tail[gap_len..]) {\n             None => tail.len(),\n@@ -1264,7 +1315,12 @@ fn normalize_newlines(src: &mut String) {\n         if tail.len() == gap_len {\n             break;\n         }\n+        cursor += idx - gap_len;\n         gap_len += 1;\n+        normalized_pos.push(NormalizedPos {\n+            pos: BytePos::from_usize(cursor + 1),\n+            diff: original_gap + gap_len as u32,\n+        });\n     }\n \n     // Account for removed `\\r`."}, {"sha": "87cc3505e389b40a90ac6b798385622889d3e595", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -19,20 +19,25 @@ fn test_lookup_line() {\n \n #[test]\n fn test_normalize_newlines() {\n-    fn check(before: &str, after: &str) {\n+    fn check(before: &str, after: &str, expected_positions: &[u32]) {\n         let mut actual = before.to_string();\n-        normalize_newlines(&mut actual);\n+        let mut actual_positions = vec![];\n+        normalize_newlines(&mut actual, &mut actual_positions);\n+        let actual_positions : Vec<_> = actual_positions\n+            .into_iter()\n+            .map(|nc| nc.pos.0).collect();\n         assert_eq!(actual.as_str(), after);\n+        assert_eq!(actual_positions, expected_positions);\n     }\n-    check(\"\", \"\");\n-    check(\"\\n\", \"\\n\");\n-    check(\"\\r\", \"\\r\");\n-    check(\"\\r\\r\", \"\\r\\r\");\n-    check(\"\\r\\n\", \"\\n\");\n-    check(\"hello world\", \"hello world\");\n-    check(\"hello\\nworld\", \"hello\\nworld\");\n-    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n-    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n-    check(\"\\r\\r\\n\", \"\\r\\n\");\n-    check(\"hello\\rworld\", \"hello\\rworld\");\n+    check(\"\", \"\", &[]);\n+    check(\"\\n\", \"\\n\", &[]);\n+    check(\"\\r\", \"\\r\", &[]);\n+    check(\"\\r\\r\", \"\\r\\r\", &[]);\n+    check(\"\\r\\n\", \"\\n\", &[1]);\n+    check(\"hello world\", \"hello world\", &[]);\n+    check(\"hello\\nworld\", \"hello\\nworld\", &[]);\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\", &[6]);\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\", &[1, 7, 13]);\n+    check(\"\\r\\r\\n\", \"\\r\\n\", &[2]);\n+    check(\"hello\\rworld\", \"hello\\rworld\", &[]);\n }"}, {"sha": "9ea3d3fb0e1f125038c940d40d0d2235ef8febea", "filename": "src/test/ui/.gitattributes", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2F.gitattributes?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -1,3 +1,6 @@\n lexer-crlf-line-endings-string-literal-doc-comment.rs -text\n+json-bom-plus-crlf.rs -text\n+json-bom-plus-crlf-multifile.rs -text\n+json-bom-plus-crlf-multifile-aux.rs -text\n trailing-carriage-return-in-string.rs -text\n *.bin -text"}, {"sha": "991ea1d85d2ca3d8ae73449e5516524d4e092d6d", "filename": "src/test/ui/json-bom-plus-crlf-multifile-aux.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// ignore-test Not a test. Used by other tests\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json-bom-plus-crlf.rs - given the actual fn is identical (just with\r\n+// a different, but equally sized name), the easiest way to do this is to\r\n+// ensure the two files are of equal size on disk.\r\n+// Padding............................\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+pub fn test() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "c71dd325f4427f107b3a6999a31c57d062b17bd5", "filename": "src/test/ui/json-bom-plus-crlf-multifile.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,12 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+#[path = \"json-bom-plus-crlf-multifile-aux.rs\"]\r\n+mod json_bom_plus_crlf_multifile_aux;\r\n+\r\n+fn main() {\r\n+    json_bom_plus_crlf_multifile_aux::test();\r\n+}\r"}, {"sha": "8472f16108909f0699a671fee0c2db7c37fabeee", "filename": "src/test/ui/json-bom-plus-crlf-multifile.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}, {"sha": "ae54a35d4805ce97bd638619cb64af180e42a98e", "filename": "src/test/ui/json-bom-plus-crlf.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json_bom_plus_crlf_multifile_aux.rs - given the actual fn is\r\n+// identical (just with a different, but equally sized name), the easiest way\r\n+// to do this is to ensure the two files are of equal size on disk.\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+fn main() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "17775f59fd16f8dc643fa89d0e36f5b1c1e1b57e", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}]}