{"sha": "26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YWY1ZGE2ZDRjYTdlZTNlN2NlYzAzMzNiMjQ2NWExYzY1ZTExNzE=", "commit": {"author": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2014-08-21T07:37:30Z"}, "committer": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2014-08-21T09:28:50Z"}, "message": "libstd: Limit Duration range to i64 milliseconds.\n\nThis enables `num_milliseconds` to return an `i64` again instead of\n`Option<i64>`, because it is guaranteed not to overflow.\n\nThe Duration range is now rougly 300e6 years (positive and negative),\nwhereas it was 300e9 years previously. To put these numbers in\nperspective, 300e9 years is about 21 times the age of the universe\n(according to Wolfram|Alpha). 300e6 years is about 1/15 of the age of\nthe earth (according to Wolfram|Alpha).", "tree": {"sha": "e3b5fc6d5899530720ae7dfffeeb40fd5ce89b03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b5fc6d5899530720ae7dfffeeb40fd5ce89b03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "html_url": "https://github.com/rust-lang/rust/commit/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/comments", "author": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39133efebf49823002977f0ad0ac12edf27b4d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/39133efebf49823002977f0ad0ac12edf27b4d06", "html_url": "https://github.com/rust-lang/rust/commit/39133efebf49823002977f0ad0ac12edf27b4d06"}], "stats": {"total": 106, "additions": 52, "deletions": 54}, "files": [{"sha": "8128c4466ce5a87145f1952e3f8d413872f175b6", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "patch": "@@ -105,23 +105,17 @@ impl TcpStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    /// If the timeout is larger than 2^63 milliseconds, the function also\n-    /// returns `Err` with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n-        let timeout_ms = timeout.num_milliseconds().map(|x| { x as u64 });\n-        if timeout_ms.is_none() {\n-            return Err(standard_error(TimedOut));\n-        }\n \n         let SocketAddr { ip, port } = addr;\n         let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, timeout_ms).map(TcpStream::new)\n+            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n         }).map_err(IoError::from_rtio_error)\n     }\n "}, {"sha": "33235bd6b03d62924947770d5e7e76b58a5f810e", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "patch": "@@ -66,21 +66,15 @@ impl UnixStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    /// If the timeout is larger than 2^63 milliseconds, the function also\n-    /// returns `Err` with the error kind set to `TimedOut`.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n                                       timeout: Duration) -> IoResult<UnixStream> {\n         if timeout <= Duration::milliseconds(0) {\n             return Err(standard_error(TimedOut));\n         }\n-        let timeout_ms = timeout.num_milliseconds().map(|x| { x as u64 });\n-        if timeout_ms.is_none() {\n-            return Err(standard_error(TimedOut));\n-        }\n \n         LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), timeout_ms);\n+            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n             s.map(|p| UnixStream { obj: p })\n         }).map_err(IoError::from_rtio_error)\n     }"}, {"sha": "39c6c74e45eef62c59028409b2f1875bd3d0d449", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "patch": "@@ -225,7 +225,7 @@ impl Callback for TimerCallback {\n }\n \n fn in_ms_u64(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds().unwrap_or(0);\n+    let ms = d.num_milliseconds();\n     if ms < 0 { return 0 };\n     return ms as u64;\n }"}, {"sha": "e8fefebc963d89c18522b125fa982f1e0bfc3a2e", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26af5da6d4ca7ee3e7cec0333b2465a1c65e1171/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=26af5da6d4ca7ee3e7cec0333b2465a1c65e1171", "patch": "@@ -51,10 +51,17 @@ pub struct Duration {\n     nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n-/// The minimum possible `Duration`.\n-pub static MIN: Duration = Duration { secs: i64::MIN, nanos: 0 };\n-/// The maximum possible `Duration`.\n-pub static MAX: Duration = Duration { secs: i64::MAX, nanos: NANOS_PER_SEC - 1 };\n+/// The minimum possible `Duration`: `i64::MIN` milliseconds.\n+pub static MIN: Duration = Duration {\n+    secs: i64::MIN / MILLIS_PER_SEC - 1,\n+    nanos: NANOS_PER_SEC + (i64::MIN % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n+};\n+\n+/// The maximum possible `Duration`: `i64::MAX` milliseconds.\n+pub static MAX: Duration = Duration {\n+    secs: i64::MAX / MILLIS_PER_SEC,\n+    nanos: (i64::MAX % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n+};\n \n impl Duration {\n     /// Makes a new `Duration` with given number of weeks.\n@@ -94,9 +101,15 @@ impl Duration {\n     }\n \n     /// Makes a new `Duration` with given number of seconds.\n+    /// Fails when the duration is more than `i64::MAX` milliseconds\n+    /// or less than `i64::MIN` milliseconds.\n     #[inline]\n     pub fn seconds(seconds: i64) -> Duration {\n-        Duration { secs: seconds, nanos: 0 }\n+        let d = Duration { secs: seconds, nanos: 0 };\n+        if d < MIN || d > MAX {\n+            fail!(\"Duration::seconds out of bounds\");\n+        }\n+        d\n     }\n \n     /// Makes a new `Duration` with given number of milliseconds.\n@@ -167,11 +180,12 @@ impl Duration {\n     }\n \n     /// Returns the total number of whole milliseconds in the duration,\n-    /// or `None` on overflow (exceeding 2^63 milliseconds in either direction).\n-    pub fn num_milliseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(&MILLIS_PER_SEC));\n+    pub fn num_milliseconds(&self) -> i64 {\n+        // A proper Duration will not overflow, because MIN and MAX are defined\n+        // such that the range is exactly i64 milliseconds.\n+        let secs_part = self.num_seconds() * MILLIS_PER_SEC;\n         let nanos_part = self.nanos_mod_sec() / NANOS_PER_MILLI;\n-        secs_part.checked_add(&(nanos_part as i64))\n+        secs_part + nanos_part as i64\n     }\n \n     /// Returns the total number of whole microseconds in the duration,\n@@ -211,13 +225,7 @@ impl num::Zero for Duration {\n impl Neg<Duration> for Duration {\n     #[inline]\n     fn neg(&self) -> Duration {\n-        if self.secs == i64::MIN && self.nanos == 0 {\n-            // The minimum value cannot be negated due to overflow. Use the\n-            // maximum value, which is one nanosecond less than the negated minimum.\n-            MAX\n-        } else if self.secs == i64::MIN {\n-            Duration { secs: i64::MAX, nanos: NANOS_PER_SEC - self.nanos }\n-        } else if self.nanos == 0 {\n+        if self.nanos == 0 {\n             Duration { secs: -self.secs, nanos: 0 }\n         } else {\n             Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n@@ -245,7 +253,10 @@ impl num::CheckedAdd for Duration {\n             nanos -= NANOS_PER_SEC;\n             secs = try_opt!(secs.checked_add(&1));\n         }\n-        Some(Duration { secs: secs, nanos: nanos }) \n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n     }\n }\n \n@@ -269,7 +280,10 @@ impl num::CheckedSub for Duration {\n             nanos += NANOS_PER_SEC;\n             secs = try_opt!(secs.checked_sub(&1));\n         }\n-        Some(Duration { secs: secs, nanos: nanos })\n+        let d = Duration { secs: secs, nanos: nanos };\n+        // Even if d is within the bounds of i64 seconds,\n+        // it might still overflow i64 milliseconds.\n+        if d < MIN || d > MAX { None } else { Some(d) }\n     }\n }\n \n@@ -407,26 +421,22 @@ mod tests {\n         assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n         assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n         assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n-        assert_eq!(Duration::seconds(i64::MAX).num_seconds(), i64::MAX);\n-        assert_eq!(Duration::seconds(i64::MIN).num_seconds(), i64::MIN);\n-        assert_eq!(MAX.num_seconds(), i64::MAX);\n-        assert_eq!(MIN.num_seconds(), i64::MIN);\n     }\n \n     #[test]\n     fn test_duration_num_milliseconds() {\n         let d: Duration = Zero::zero();\n-        assert_eq!(d.num_milliseconds(), Some(0));\n-        assert_eq!(Duration::milliseconds(1).num_milliseconds(), Some(1));\n-        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), Some(-1));\n-        assert_eq!(Duration::microseconds(999).num_milliseconds(), Some(0));\n-        assert_eq!(Duration::microseconds(1001).num_milliseconds(), Some(1));\n-        assert_eq!(Duration::microseconds(-999).num_milliseconds(), Some(0));\n-        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), Some(-1));\n-        assert_eq!(Duration::milliseconds(i64::MAX).num_milliseconds(), Some(i64::MAX));\n-        assert_eq!(Duration::milliseconds(i64::MIN).num_milliseconds(), Some(i64::MIN));\n-        assert_eq!(MAX.num_milliseconds(), None);\n-        assert_eq!(MIN.num_milliseconds(), None);\n+        assert_eq!(d.num_milliseconds(), 0);\n+        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n+        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n+        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n+        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n+        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n+        assert_eq!(Duration::milliseconds(i64::MAX).num_milliseconds(), i64::MAX);\n+        assert_eq!(Duration::milliseconds(i64::MIN).num_milliseconds(), i64::MIN);\n+        assert_eq!(MAX.num_milliseconds(), i64::MAX);\n+        assert_eq!(MIN.num_milliseconds(), i64::MIN);\n     }\n \n     #[test]\n@@ -477,13 +487,13 @@ mod tests {\n \n     #[test]\n     fn test_duration_checked_ops() {\n-        assert_eq!(Duration::seconds(i64::MAX).checked_add(&Duration::milliseconds(999)),\n-                   Some(Duration::seconds(i64::MAX - 1) + Duration::milliseconds(1999)));\n-        assert!(Duration::seconds(i64::MAX).checked_add(&Duration::milliseconds(1000)).is_none());\n+        assert_eq!(Duration::milliseconds(i64::MAX - 1).checked_add(&Duration::microseconds(999)),\n+                   Some(Duration::milliseconds(i64::MAX - 2) + Duration::microseconds(1999)));\n+        assert!(Duration::milliseconds(i64::MAX).checked_add(&Duration::microseconds(1000)).is_none());\n \n-        assert_eq!(Duration::seconds(i64::MIN).checked_sub(&Duration::seconds(0)),\n-                   Some(Duration::seconds(i64::MIN)));\n-        assert!(Duration::seconds(i64::MIN).checked_sub(&Duration::seconds(1)).is_none());\n+        assert_eq!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(0)),\n+                   Some(Duration::milliseconds(i64::MIN)));\n+        assert!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(1)).is_none());\n     }\n \n     #[test]"}]}