{"sha": "aec047edebb596c79852fc78c5cfcddbae595c08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzA0N2VkZWJiNTk2Yzc5ODUyZmM3OGM1Y2ZjZGRiYWU1OTVjMDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-16T16:22:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-16T16:22:21Z"}, "message": "Rollup merge of #61780 - SimonSapin:container-error, r=Amanieu\n\nFinalize the error type for `try_reserve`\n\nSee tracking issue comments from https://github.com/rust-lang/rust/issues/48043#issuecomment-500828346.\n\nIt is now:\n\n```rust\n/// The error type for `try_reserve` methods.\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\npub enum TryReserveError {\n    /// Error due to the computed capacity exceeding the collection's maximum\n    /// (usually `isize::MAX` bytes).\n    CapacityOverflow,\n\n    /// The memory allocator returned an error\n    AllocError {\n        /// The layout of allocation request that failed\n        layout: Layout,\n\n        #[doc(hidden)]\n        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n            Enable exposing the allocator\u2019s custom error value \\\n            if an associated type is added in the future: \\\n            https://github.com/rust-lang/wg-allocators/issues/23\")]\n        non_exhaustive: (),\n    },\n}\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\nimpl From<LayoutErr> for TryReserveError {\n    #[inline]\n    fn from(_: LayoutErr) -> Self {\n        TryReserveError::CapacityOverflow\n    }\n}\n```\n\nChanges:\n\n* A `Layout` is included. Firefox wants to log the size of failed allocations. If this were not part of the return value of e.g. `HashMap::try_reserve`, users would only be able to estimate based on `HashMap::capacity` and assumptions about the allocation strategy of `HashMap`.\n\n* There\u2019s a dummy field that can stay unstable when `try_reserve` and the rest of this enum are stabilized. This forces non-exhaustive matching ~(https://github.com/rust-lang/rust/issues/44109 is not implemented yet for variants)~ and allows adding another field in the future if we want to expose custom error values from the allocator. See https://github.com/rust-lang/wg-allocators/issues/23.\n\n  - If the `Alloc` trait is stabilized without an associated error type and with a zero-size `AllocErr` type, we can simply remove this dummy field.\n  - If an associated type is added, we can add a default type parameter to `ContainerError` and a generic field to the `AllocError` variant.\n\n* ~Moved from the `collections` module to the `alloc` module, and replaced `Collection` in the enum name with `Container`. The wold collection implies a multiplicity of items which is not relevant to this type. For example we may want to use this error type in a future `Box::try_new` method.~\n\n  - Renamed to `TryReserveError`, after the methods that involve this type: https://github.com/rust-lang/rust/pull/61780#issuecomment-501392487\n\n* Replaced `Err` with `Error` in the enum and variant names. There is more precedent for this in https://doc.rust-lang.org/std/error/trait.Error.html#implementors, `AllocErr` and `LayoutErr` are the odd ones.\n\n* ~Dropped `Alloc` in the enum name. `ContainerAllocError` with a mouthful, and being in the `alloc` module already provides the same indication.~", "tree": {"sha": "4b956b14e1b92d0ccacbca8b2a78fab3e429c45c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b956b14e1b92d0ccacbca8b2a78fab3e429c45c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec047edebb596c79852fc78c5cfcddbae595c08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVtg9CRBK7hj4Ov3rIwAAdHIIACv7Y3MLTSvmchBzPM3kc6YU\nAaYf2wSBypATxmksOqcfnqCel7dtO4F+1znr/VDjZMdmeU/NOHbRvQQ1SuRuBrx5\nO5iFu8vE3QuZtcDqVj9ed5j3/zx718+G9S3OGWQC6qaEDDdL0++cGiKNvMla8T2E\nz+RW5Vrk2cvDpat6UjdsZdez/v1wAmD/2/1zPW/XTH+SL/6MmpLeyXPLiMC4pNIN\nZ193yeC6TkgS9p9huta8luEgaF8JOtdHBU8pVbNuGfo8tI2xRCNI5zWwkALebbqf\nXOQ8j2T07g9jOg4CDQ3i6/TtgusuP6KRBrlYoMYDMm4g9sivYvz6FgkY94/tr0M=\n=Nm4x\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b956b14e1b92d0ccacbca8b2a78fab3e429c45c\nparent e632dafba2782ce8f51c2e414290d36cf983896f\nparent 59a340963fa5d8b5507d95cd015f7ca2855ba151\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565972541 +0200\ncommitter GitHub <noreply@github.com> 1565972541 +0200\n\nRollup merge of #61780 - SimonSapin:container-error, r=Amanieu\n\nFinalize the error type for `try_reserve`\n\nSee tracking issue comments from https://github.com/rust-lang/rust/issues/48043#issuecomment-500828346.\n\nIt is now:\n\n```rust\n/// The error type for `try_reserve` methods.\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\npub enum TryReserveError {\n    /// Error due to the computed capacity exceeding the collection's maximum\n    /// (usually `isize::MAX` bytes).\n    CapacityOverflow,\n\n    /// The memory allocator returned an error\n    AllocError {\n        /// The layout of allocation request that failed\n        layout: Layout,\n\n        #[doc(hidden)]\n        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n            Enable exposing the allocator\u2019s custom error value \\\n            if an associated type is added in the future: \\\n            https://github.com/rust-lang/wg-allocators/issues/23\")]\n        non_exhaustive: (),\n    },\n}\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\nimpl From<LayoutErr> for TryReserveError {\n    #[inline]\n    fn from(_: LayoutErr) -> Self {\n        TryReserveError::CapacityOverflow\n    }\n}\n```\n\nChanges:\n\n* A `Layout` is included. Firefox wants to log the size of failed allocations. If this were not part of the return value of e.g. `HashMap::try_reserve`, users would only be able to estimate based on `HashMap::capacity` and assumptions about the allocation strategy of `HashMap`.\n\n* There\u2019s a dummy field that can stay unstable when `try_reserve` and the rest of this enum are stabilized. This forces non-exhaustive matching ~(https://github.com/rust-lang/rust/issues/44109 is not implemented yet for variants)~ and allows adding another field in the future if we want to expose custom error values from the allocator. See https://github.com/rust-lang/wg-allocators/issues/23.\n\n  - If the `Alloc` trait is stabilized without an associated error type and with a zero-size `AllocErr` type, we can simply remove this dummy field.\n  - If an associated type is added, we can add a default type parameter to `ContainerError` and a generic field to the `AllocError` variant.\n\n* ~Moved from the `collections` module to the `alloc` module, and replaced `Collection` in the enum name with `Container`. The wold collection implies a multiplicity of items which is not relevant to this type. For example we may want to use this error type in a future `Box::try_new` method.~\n\n  - Renamed to `TryReserveError`, after the methods that involve this type: https://github.com/rust-lang/rust/pull/61780#issuecomment-501392487\n\n* Replaced `Err` with `Error` in the enum and variant names. There is more precedent for this in https://doc.rust-lang.org/std/error/trait.Error.html#implementors, `AllocErr` and `LayoutErr` are the odd ones.\n\n* ~Dropped `Alloc` in the enum name. `ContainerAllocError` with a mouthful, and being in the `alloc` module already provides the same indication.~\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec047edebb596c79852fc78c5cfcddbae595c08", "html_url": "https://github.com/rust-lang/rust/commit/aec047edebb596c79852fc78c5cfcddbae595c08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec047edebb596c79852fc78c5cfcddbae595c08/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e632dafba2782ce8f51c2e414290d36cf983896f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e632dafba2782ce8f51c2e414290d36cf983896f", "html_url": "https://github.com/rust-lang/rust/commit/e632dafba2782ce8f51c2e414290d36cf983896f"}, {"sha": "59a340963fa5d8b5507d95cd015f7ca2855ba151", "url": "https://api.github.com/repos/rust-lang/rust/commits/59a340963fa5d8b5507d95cd015f7ca2855ba151", "html_url": "https://github.com/rust-lang/rust/commit/59a340963fa5d8b5507d95cd015f7ca2855ba151"}], "stats": {"total": 192, "additions": 97, "deletions": 95}, "files": [{"sha": "070858cd185ece4b42c23ae2c122e9f5db006049", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -1138,19 +1138,12 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-alloc 1.0.0\",\n  \"rustc-std-workspace-core 1.0.0\",\n-]\n-\n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n  \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3534,7 +3527,7 @@ dependencies = [\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"hashbrown 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hashbrown 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -4450,7 +4443,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum globset 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef4feaabe24a0a658fd9cf4a9acf6ed284f045c77df0f49020ba3245cfb7b454\"\n \"checksum h2 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a539b63339fbbb00e081e84b6e11bd1d9634a82d91da2984a18ac74a8823f392\"\n \"checksum handlebars 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n-\"checksum hashbrown 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9529213c67695ca2d146e6f263b7b72df8fa973368beadf767e8ed80c03f2f36\"\n \"checksum hashbrown 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n \"checksum heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea04fa3ead4e05e51a7c806fc07271fdbde4e246a6c6d1efd52e72230b771b82\"\n \"checksum hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\""}, {"sha": "f1f22fe48c58ab0c4343a82dbd7ecfd26708c9c3", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -41,32 +41,35 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{Layout, LayoutErr};\n \n-/// Augments `AllocErr` with a CapacityOverflow variant.\n+/// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub enum CollectionAllocErr {\n+pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n-    /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr,\n-}\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<AllocErr> for CollectionAllocErr {\n-    #[inline]\n-    fn from(AllocErr: AllocErr) -> Self {\n-        CollectionAllocErr::AllocErr\n-    }\n+    /// The memory allocator returned an error\n+    AllocError {\n+        /// The layout of allocation request that failed\n+        layout: Layout,\n+\n+        #[doc(hidden)]\n+        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n+            Enable exposing the allocator\u2019s custom error value \\\n+            if an associated type is added in the future: \\\n+            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+        non_exhaustive: (),\n+    },\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<LayoutErr> for CollectionAllocErr {\n+impl From<LayoutErr> for TryReserveError {\n     #[inline]\n     fn from(_: LayoutErr) -> Self {\n-        CollectionAllocErr::CapacityOverflow\n+        TryReserveError::CapacityOverflow\n     }\n }\n "}, {"sha": "2fc87413367adddc5b3cd212c4db4046c2825005", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -18,7 +18,7 @@ use core::ptr::{self, NonNull};\n use core::slice;\n use core::hash::{Hash, Hasher};\n \n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n@@ -576,10 +576,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -595,7 +595,7 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.try_reserve(additional)\n     }\n \n@@ -614,10 +614,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -633,12 +633,12 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+            .ok_or(TryReserveError::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;"}, {"sha": "4a48945adc37a4bf313a00fe38cd06fce4296d0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -87,6 +87,7 @@\n #![feature(const_in_array_repeat_expressions)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n+#![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]"}, {"sha": "bc8a38f6b3aad530a9a0eb95d826f1696cd9d8e5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -7,8 +7,8 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n-use crate::collections::CollectionAllocErr::{self, *};\n+use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n+use crate::collections::TryReserveError::{self, *};\n use crate::boxed::Box;\n \n #[cfg(test)]\n@@ -385,7 +385,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-           -> Result<(), CollectionAllocErr> {\n+           -> Result<(), TryReserveError> {\n \n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n@@ -413,7 +413,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -422,7 +422,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<usize, CollectionAllocErr> {\n+        -> Result<usize, TryReserveError> {\n \n         // Nothing we can really do about these checks :(\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n@@ -435,7 +435,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n-        -> Result<(), CollectionAllocErr> {\n+        -> Result<(), TryReserveError> {\n         self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n@@ -494,7 +494,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n@@ -640,10 +640,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n         needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n-    ) -> Result<(), CollectionAllocErr> {\n+    ) -> Result<(), TryReserveError> {\n         unsafe {\n-            use crate::alloc::AllocErr;\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -672,12 +670,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            match (&res, fallibility) {\n+            let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                _ => {}\n-            }\n+                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n+                    layout: new_layout,\n+                    non_exhaustive: (),\n+                }),\n+                (Ok(ptr), _) => ptr,\n+            };\n \n-            self.ptr = res?.cast().into();\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -737,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {"}, {"sha": "b65f191836e9dcc9548bac74f9894520f5df463a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -56,7 +56,7 @@ use core::ptr;\n use core::str::{pattern::Pattern, lossy};\n \n use crate::borrow::{Cow, ToOwned};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use crate::vec::Vec;\n@@ -937,9 +937,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -953,7 +953,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve(additional)\n     }\n \n@@ -975,9 +975,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -991,7 +991,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.vec.try_reserve_exact(additional)\n     }\n "}, {"sha": "55edf56345b59a4cb270129610b0318a9f2163dd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -1,5 +1,5 @@\n use std::borrow::Cow;\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -566,11 +566,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -629,10 +629,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -651,7 +651,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "29a22aa0315b048199497108d04b2bb1eac04e46", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -1121,11 +1121,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1145,7 +1145,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1209,10 +1209,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1231,7 +1231,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1252,7 +1252,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d49b553fc0217a5161e9493220d25003b2221856", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Debug;\n use std::collections::{VecDeque, vec_deque::Drain};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1188,7 +1188,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1211,7 +1211,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1256,7 +1256,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1275,7 +1275,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1296,7 +1296,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d2798955c46a97105cec55fa5e5f3b4de2def63b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -70,7 +70,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n use crate::borrow::{ToOwned, Cow};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::raw_vec::RawVec;\n \n@@ -498,9 +498,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -516,7 +516,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve(self.len, additional)\n     }\n \n@@ -538,9 +538,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -556,7 +556,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.buf.try_reserve_exact(self.len, additional)\n     }\n "}, {"sha": "3288d0b4df2ee48683752d947483eb2f57eefec0", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -23,7 +23,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.16\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n-hashbrown = { version = \"0.4.0\", features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n version = \"0.3.34\""}, {"sha": "a0538986a22421b4fc0cc1cac02738b006f036ef", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -6,7 +6,7 @@ use hashbrown::hash_map as base;\n \n use crate::borrow::Borrow;\n use crate::cell::Cell;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt::{self, Debug};\n #[allow(deprecated)]\n use crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\n@@ -588,7 +588,7 @@ where\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.base\n             .try_reserve(additional)\n             .map_err(map_collection_alloc_err)\n@@ -2542,10 +2542,13 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> CollectionAllocErr {\n+fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n     match err {\n-        hashbrown::CollectionAllocErr::CapacityOverflow => CollectionAllocErr::CapacityOverflow,\n-        hashbrown::CollectionAllocErr::AllocErr => CollectionAllocErr::AllocErr,\n+        hashbrown::CollectionAllocErr::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::CollectionAllocErr::AllocErr { layout } => TryReserveError::AllocError {\n+            layout,\n+            non_exhaustive: (),\n+        },\n     }\n }\n \n@@ -2605,7 +2608,7 @@ mod test_map {\n     use super::RandomState;\n     use crate::cell::RefCell;\n     use rand::{thread_rng, Rng};\n-    use realstd::collections::CollectionAllocErr::*;\n+    use realstd::collections::TryReserveError::*;\n     use realstd::usize;\n \n     // https://github.com/rust-lang/rust/issues/62301\n@@ -3405,7 +3408,7 @@ mod test_map {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n \n-        if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+        if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n         } else {\n             panic!(\"usize::MAX / 8 should trigger an OOM!\")\n         }"}, {"sha": "26db651ef8911d8194532f0f71a4a870586f3373", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow::Borrow;\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{Hash, BuildHasher};\n use crate::iter::{Chain, FromIterator, FusedIterator};\n@@ -383,7 +383,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.map.try_reserve(additional)\n     }\n "}, {"sha": "f5957466be841009683e087023f5527bd8951e3a", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -427,7 +427,7 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub use alloc_crate::collections::CollectionAllocErr;\n+pub use alloc_crate::collections::TryReserveError;\n \n mod hash;\n "}, {"sha": "760d92f1d7b0ed589e7ccc597717c0c7ac6fde26", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec047edebb596c79852fc78c5cfcddbae595c08/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=aec047edebb596c79852fc78c5cfcddbae595c08", "patch": "@@ -251,6 +251,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]\n #![feature(doc_alias)]"}]}