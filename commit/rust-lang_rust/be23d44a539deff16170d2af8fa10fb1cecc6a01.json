{"sha": "be23d44a539deff16170d2af8fa10fb1cecc6a01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMjNkNDRhNTM5ZGVmZjE2MTcwZDJhZjhmYTEwZmIxY2VjYzZhMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-20T00:13:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-20T00:13:22Z"}, "message": "Auto merge of #27065 - marcusklaas:loop-label, r=nrc\n\nThis closes https://github.com/rust-lang/rust/issues/27042.\r\n\r\nI'd love to know if there's a way to make a regression test for this!", "tree": {"sha": "22a15b24c6d3d22b0877788336079f8c15d25ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22a15b24c6d3d22b0877788336079f8c15d25ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be23d44a539deff16170d2af8fa10fb1cecc6a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be23d44a539deff16170d2af8fa10fb1cecc6a01", "html_url": "https://github.com/rust-lang/rust/commit/be23d44a539deff16170d2af8fa10fb1cecc6a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be23d44a539deff16170d2af8fa10fb1cecc6a01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d304134ff65931e0529bf68ec14972f81d2fdb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d304134ff65931e0529bf68ec14972f81d2fdb1", "html_url": "https://github.com/rust-lang/rust/commit/5d304134ff65931e0529bf68ec14972f81d2fdb1"}, {"sha": "12963606d015c5f68c6e8bc51267cd2b9c8d0cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/12963606d015c5f68c6e8bc51267cd2b9c8d0cfe", "html_url": "https://github.com/rust-lang/rust/commit/12963606d015c5f68c6e8bc51267cd2b9c8d0cfe"}], "stats": {"total": 68, "additions": 49, "deletions": 19}, "files": [{"sha": "28802d323c692d2ddf491991e50197e71c46bc3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be23d44a539deff16170d2af8fa10fb1cecc6a01/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23d44a539deff16170d2af8fa10fb1cecc6a01/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=be23d44a539deff16170d2af8fa10fb1cecc6a01", "patch": "@@ -2099,28 +2099,32 @@ impl<'a> Parser<'a> {\n                     return self.parse_if_expr();\n                 }\n                 if try!(self.eat_keyword(keywords::For) ){\n-                    return self.parse_for_expr(None);\n+                    let lo = self.last_span.lo;\n+                    return self.parse_for_expr(None, lo);\n                 }\n                 if try!(self.eat_keyword(keywords::While) ){\n-                    return self.parse_while_expr(None);\n+                    let lo = self.last_span.lo;\n+                    return self.parse_while_expr(None, lo);\n                 }\n                 if self.token.is_lifetime() {\n                     let lifetime = self.get_lifetime();\n+                    let lo = self.span.lo;\n                     try!(self.bump());\n                     try!(self.expect(&token::Colon));\n                     if try!(self.eat_keyword(keywords::While) ){\n-                        return self.parse_while_expr(Some(lifetime))\n+                        return self.parse_while_expr(Some(lifetime), lo)\n                     }\n                     if try!(self.eat_keyword(keywords::For) ){\n-                        return self.parse_for_expr(Some(lifetime))\n+                        return self.parse_for_expr(Some(lifetime), lo)\n                     }\n                     if try!(self.eat_keyword(keywords::Loop) ){\n-                        return self.parse_loop_expr(Some(lifetime))\n+                        return self.parse_loop_expr(Some(lifetime), lo)\n                     }\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if try!(self.eat_keyword(keywords::Loop) ){\n-                    return self.parse_loop_expr(None);\n+                    let lo = self.last_span.lo;\n+                    return self.parse_loop_expr(None, lo);\n                 }\n                 if try!(self.eat_keyword(keywords::Continue) ){\n                     let lo = self.span.lo;\n@@ -2892,48 +2896,48 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> PResult<P<Expr>> {\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n+                          span_lo: BytePos) -> PResult<P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n-        let lo = self.last_span.lo;\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect_keyword(keywords::In));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let loop_block = try!(self.parse_block());\n         let hi = self.last_span.hi;\n \n-        Ok(self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident)))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> PResult<P<Expr>> {\n+    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n+                            span_lo: BytePos) -> PResult<P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n-            return self.parse_while_let_expr(opt_ident);\n+            return self.parse_while_let_expr(opt_ident, span_lo);\n         }\n-        let lo = self.last_span.lo;\n         let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident)));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>) -> PResult<P<Expr>> {\n-        let lo = self.last_span.lo;\n+    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n+                                span_lo: BytePos) -> PResult<P<Expr>> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect(&token::Eq));\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n     }\n \n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> PResult<P<Expr>> {\n-        let lo = self.last_span.lo;\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n+                           span_lo: BytePos) -> PResult<P<Expr>> {\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n-        Ok(self.mk_expr(lo, hi, ExprLoop(body, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident)))\n     }\n \n     fn parse_match_expr(&mut self) -> PResult<P<Expr>> {"}, {"sha": "f31389f1337ddb2dbd4447937bd65764e1d8ddf8", "filename": "src/test/compile-fail/issue-27042.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be23d44a539deff16170d2af8fa10fb1cecc6a01/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23d44a539deff16170d2af8fa10fb1cecc6a01/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27042.rs?ref=be23d44a539deff16170d2af8fa10fb1cecc6a01", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #27042. Test that a loop's label is included in its span.\n+\n+fn main() {\n+    let _: i32 =\n+        'a: //~ ERROR mismatched types\n+        loop { break };\n+    let _: i32 =\n+        'b: //~ ERROR mismatched types\n+        while true { break };\n+    let _: i32 =\n+        'c: //~ ERROR mismatched types\n+        for _ in None { break };\n+    let _: i32 =\n+        'd: //~ ERROR mismatched types\n+        while let Some(_) = None { break };\n+}"}]}