{"sha": "cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYTJhOGFlOWVlYWRkMDJiM2RhMzhkODE5Zjk1NzQxNDQ5ZGQ0ZTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-10T14:56:04Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-10T14:56:04Z"}, "message": "adjust lifetimes and bindings to the GlobalEvalContext -> EvalContext rename", "tree": {"sha": "f7d74838129d13f97a4b5355990b34499ab770fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d74838129d13f97a4b5355990b34499ab770fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXWtUEAAoJEFbW7qD8Z6xGrBUQAKgt2Rn0UlvDpZFcEJsBZDzt\n7gqnEGWrWWPispkECT2jl39iNGVOdn4BitmBKUWnQqltM7dy4a6rskp3EgNmq7mj\nClnzPgT51eoxFRkaKEVeyoON5ocN8QqVhmrliFcGf4ikVLrZ4PJ7GXxTMKfo7NaY\ns/wPn0KPxFqv7CciI3QNAYHF5qw2YWYsHwf6YqEEkj9+AUGZJ7Q0VsS2cBSKyX/d\nan2phGOuucf1jD8bLJcnDPY3pLG2I+XvPXHq7+Oq9DDTn1LL9ldTKHm1y48MKuyA\nEUl6obo7ZvtelZSiFQKW9VQFIESckc9kvI5Nn3xcfEfINXM+JKWtl7EdFaJnPUkU\nwQpnZGqLfhVuNZoAa6RC+j3DD38px/ENgS4BEVtMRj3PV/0CBTgGD6BGvrIkSGx1\nZgsz2NH+jgY3rOKnFIjEunDzwzpNQCuF55mLsE3ghmSXuQWREaOtV4E0Rx/+nd3a\n+djpZaQZFrAeFAWy9zYvdYCHkYxhVgumO/d8OTKhHAP8UZ0n+CyiLdQmHHEF9So3\nNnPKoSUkgAXCJcMiNRbKH1BHgRTabbD9rqXIAaQQPdhqDnUjwuj630wJSdBQZuEs\nqTRBrVLDukSD9msNNEqHjpBGdU1p1MqB70BYAmXrrqAyWBKD68lB9rfr8YerDJU5\nCWwbLfAdhLIwUhXWO0q+\n=hC/Z\n-----END PGP SIGNATURE-----", "payload": "tree f7d74838129d13f97a4b5355990b34499ab770fa\nparent 9c8f84caf774f5cb9e60a3c4bc14f6b514503c4d\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465570564 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465570564 +0200\n\nadjust lifetimes and bindings to the GlobalEvalContext -> EvalContext rename"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "html_url": "https://github.com/rust-lang/rust/commit/cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c8f84caf774f5cb9e60a3c4bc14f6b514503c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8f84caf774f5cb9e60a3c4bc14f6b514503c4d", "html_url": "https://github.com/rust-lang/rust/commit/9c8f84caf774f5cb9e60a3c4bc14f6b514503c4d"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "82702ae43788087ef42199340f720c8369a9b56c", "filename": "src/bin/miri.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "patch": "@@ -59,17 +59,17 @@ fn interpret_start_points<'a, 'tcx>(\n \n                 debug!(\"Interpreting: {}\", item.name);\n \n-                let mut gecx = EvalContext::new(tcx, mir_map);\n+                let mut ecx = EvalContext::new(tcx, mir_map);\n                 let substs = tcx.mk_substs(subst::Substs::empty());\n-                let return_ptr = gecx.alloc_ret_ptr(mir.return_ty, substs);\n+                let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs);\n \n-                gecx.push_stack_frame(tcx.map.local_def_id(id), mir.span, CachedMir::Ref(mir), substs, return_ptr);\n+                ecx.push_stack_frame(tcx.map.local_def_id(id), mir.span, CachedMir::Ref(mir), substs, return_ptr);\n \n                 loop {\n-                    match (step(&mut gecx), return_ptr) {\n+                    match (step(&mut ecx), return_ptr) {\n                         (Ok(true), _) => {},\n                         (Ok(false), Some(ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n-                            gecx.memory().dump(ptr.alloc_id);\n+                            ecx.memory().dump(ptr.alloc_id);\n                             break;\n                         },\n                         (Ok(false), None) => {\n@@ -78,7 +78,7 @@ fn interpret_start_points<'a, 'tcx>(\n                         },\n                         // FIXME: diverging functions can end up here in some future miri\n                         (Err(e), _) => {\n-                            report(tcx, &gecx, e);\n+                            report(tcx, &ecx, e);\n                             break;\n                         },\n                     }\n@@ -88,16 +88,16 @@ fn interpret_start_points<'a, 'tcx>(\n     }\n }\n \n-fn report(tcx: TyCtxt, gecx: &EvalContext, e: EvalError) {\n-    let frame = gecx.stack().last().expect(\"stackframe was empty\");\n+fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n+    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n     let block = frame.mir.basic_block_data(frame.next_block);\n     let span = if frame.stmt < block.statements.len() {\n         block.statements[frame.stmt].span\n     } else {\n         block.terminator().span\n     };\n     let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { def_id, substs, span, .. } in gecx.stack().iter().rev() {\n+    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n         // FIXME(solson): Find a way to do this without this Display impl hack.\n         use rustc::util::ppaux;\n         use std::fmt;"}, {"sha": "6831ab212fb356febf647150256bd00b06f9deb9", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "patch": "@@ -24,8 +24,8 @@ use std::collections::HashMap;\n \n mod stepper;\n \n-pub fn step<'fncx, 'a: 'fncx, 'tcx: 'a>(gecx: &'fncx mut EvalContext<'a, 'tcx>) -> EvalResult<bool> {\n-    stepper::Stepper::new(gecx).step()\n+pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<bool> {\n+    stepper::Stepper::new(ecx).step()\n }\n \n pub struct EvalContext<'a, 'tcx: 'a> {"}, {"sha": "3e4816834a82dca9598f5f602ecce55d9ab1dd3b", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea2a8ae9eeadd02b3da38d819f95741449dd4e0/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "patch": "@@ -12,57 +12,57 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n \n-pub(super) struct Stepper<'fncx, 'a: 'fncx, 'tcx: 'a>{\n-    gecx: &'fncx mut EvalContext<'a, 'tcx>,\n+pub(super) struct Stepper<'ecx, 'a: 'ecx, 'tcx: 'a>{\n+    ecx: &'ecx mut EvalContext<'a, 'tcx>,\n }\n \n-impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n-    pub(super) fn new(gecx: &'fncx mut EvalContext<'a, 'tcx>) -> Self {\n+impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n+    pub(super) fn new(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> Self {\n         Stepper {\n-            gecx: gecx,\n+            ecx: ecx,\n         }\n     }\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n         trace!(\"{:?}\", stmt);\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-        self.gecx.eval_assignment(lvalue, rvalue)?;\n-        self.gecx.frame_mut().stmt += 1;\n+        self.ecx.eval_assignment(lvalue, rvalue)?;\n+        self.ecx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n         // after a terminator we go to a new block\n-        self.gecx.frame_mut().stmt = 0;\n+        self.ecx.frame_mut().stmt = 0;\n         trace!(\"{:?}\", terminator.kind);\n-        self.gecx.eval_terminator(terminator)?;\n-        if !self.gecx.stack.is_empty() {\n-            trace!(\"// {:?}\", self.gecx.frame().next_block);\n+        self.ecx.eval_terminator(terminator)?;\n+        if !self.ecx.stack.is_empty() {\n+            trace!(\"// {:?}\", self.ecx.frame().next_block);\n         }\n         Ok(())\n     }\n \n     // returns true as long as there are more things to do\n     pub(super) fn step(&mut self) -> EvalResult<bool> {\n-        if self.gecx.stack.is_empty() {\n+        if self.ecx.stack.is_empty() {\n             return Ok(false);\n         }\n \n-        let block = self.gecx.frame().next_block;\n-        let stmt = self.gecx.frame().stmt;\n-        let mir = self.gecx.mir();\n+        let block = self.ecx.frame().next_block;\n+        let stmt = self.ecx.frame().stmt;\n+        let mir = self.ecx.mir();\n         let basic_block = mir.basic_block_data(block);\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n-            let current_stack = self.gecx.stack.len();\n+            let current_stack = self.ecx.stack.len();\n             ConstantExtractor {\n                 span: stmt.span,\n-                substs: self.gecx.substs(),\n-                def_id: self.gecx.frame().def_id,\n-                gecx: self.gecx,\n+                substs: self.ecx.substs(),\n+                def_id: self.ecx.frame().def_id,\n+                ecx: self.ecx,\n                 mir: &mir,\n             }.visit_statement(block, stmt);\n-            if current_stack == self.gecx.stack.len() {\n+            if current_stack == self.ecx.stack.len() {\n                 self.statement(stmt)?;\n             } else {\n                 // ConstantExtractor added some new frames for statics/constants/promoteds\n@@ -73,15 +73,15 @@ impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n         }\n \n         let terminator = basic_block.terminator();\n-        let current_stack = self.gecx.stack.len();\n+        let current_stack = self.ecx.stack.len();\n         ConstantExtractor {\n             span: terminator.span,\n-            substs: self.gecx.substs(),\n-            def_id: self.gecx.frame().def_id,\n-            gecx: self.gecx,\n+            substs: self.ecx.substs(),\n+            def_id: self.ecx.frame().def_id,\n+            ecx: self.ecx,\n             mir: &mir,\n         }.visit_terminator(block, terminator);\n-        if current_stack == self.gecx.stack.len() {\n+        if current_stack == self.ecx.stack.len() {\n             self.terminator(terminator)?;\n         } else {\n             // ConstantExtractor added some new frames for statics/constants/promoteds\n@@ -92,13 +92,13 @@ impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n     }\n }\n \n-// WARNING: make sure that any methods implemented on this type don't ever access gecx.stack\n+// WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n // this includes any method that might access the stack\n // basically don't call anything other than `load_mir`, `alloc_ret_ptr`, `push_stack_frame`\n // The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n-    gecx: &'a mut EvalContext<'b, 'tcx>,\n+    ecx: &'a mut EvalContext<'b, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     def_id: DefId,\n     substs: &'tcx subst::Substs<'tcx>,\n@@ -111,13 +111,13 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             substs: substs,\n             kind: ConstantKind::Global,\n         };\n-        if self.gecx.statics.contains_key(&cid) {\n+        if self.ecx.statics.contains_key(&cid) {\n             return;\n         }\n-        let mir = self.gecx.load_mir(def_id);\n-        let ptr = self.gecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n-        self.gecx.statics.insert(cid.clone(), ptr);\n-        self.gecx.push_stack_frame(def_id, span, mir, substs, Some(ptr));\n+        let mir = self.ecx.load_mir(def_id);\n+        let ptr = self.ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n+        self.ecx.statics.insert(cid.clone(), ptr);\n+        self.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr));\n     }\n }\n \n@@ -142,23 +142,23 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     substs: self.substs,\n                     kind: ConstantKind::Promoted(index),\n                 };\n-                if self.gecx.statics.contains_key(&cid) {\n+                if self.ecx.statics.contains_key(&cid) {\n                     return;\n                 }\n                 let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n-                let return_ptr = self.gecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n+                let return_ptr = self.ecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n                 let mir = CachedMir::Owned(Rc::new(mir));\n-                self.gecx.statics.insert(cid.clone(), return_ptr);\n-                self.gecx.push_stack_frame(self.def_id, constant.span, mir, self.substs, Some(return_ptr));\n+                self.ecx.statics.insert(cid.clone(), return_ptr);\n+                self.ecx.push_stack_frame(self.def_id, constant.span, mir, self.substs, Some(return_ptr));\n             }\n         }\n     }\n \n     fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext) {\n         self.super_lvalue(lvalue, context);\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n-            let substs = self.gecx.tcx.mk_substs(subst::Substs::empty());\n+            let substs = self.ecx.tcx.mk_substs(subst::Substs::empty());\n             let span = self.span;\n             self.global_item(def_id, substs, span);\n         }"}]}