{"sha": "96d335d578984b42c2e00c715c924bceca391a6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZDMzNWQ1Nzg5ODRiNDJjMmUwMGM3MTVjOTI0YmNlY2EzOTFhNmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T13:36:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T13:36:22Z"}, "message": "Merge #5061\n\n5061: Move TaskPool into GlobalState r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f49e366fefec372f037b9e523e0fa144bc08fb6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f49e366fefec372f037b9e523e0fa144bc08fb6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96d335d578984b42c2e00c715c924bceca391a6c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9KhWCRBK7hj4Ov3rIwAAdHIIAFgh4davNcEZg/PQ09RYo6T1\nsWe4v2D9TlYNWBtW9C6QR4WgKeJ1stbZukTFW+CMch+NGZjGVtQGO0MVAxBPipgT\nYivSjj9CuUZsowtpkAmFtuYqnX5vMNMWggqF9l1CjnmGBEQqYi+S8tIRhGWGEZvF\nYqw0b7vjk4gvh9w8Ge3Ac/G/ALdo6Sw1Lcdv3g4Qp0yVZVHrE8ndb9x9klRjR8o5\nNjWoe/MmJTWVW9b8C7sdVEm4ot2i2YAqT49Y2A7myAgh2JjRwUkB29ZpVCCGjqF8\nSDu/jr/KIkct3reNAfL8JnFPYYzXWG/L9rxx244kkSlAAmsIBY6ikW0d99D71+Q=\n=TZ9k\n-----END PGP SIGNATURE-----\n", "payload": "tree f49e366fefec372f037b9e523e0fa144bc08fb6e\nparent 9be0094b5cc24d82541d98a7bd00187c18388fd3\nparent dd20c2ec5bc0c5ac02149479c2b5f3746f3df505\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593092182 +0000\ncommitter GitHub <noreply@github.com> 1593092182 +0000\n\nMerge #5061\n\n5061: Move TaskPool into GlobalState r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96d335d578984b42c2e00c715c924bceca391a6c", "html_url": "https://github.com/rust-lang/rust/commit/96d335d578984b42c2e00c715c924bceca391a6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96d335d578984b42c2e00c715c924bceca391a6c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be0094b5cc24d82541d98a7bd00187c18388fd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be0094b5cc24d82541d98a7bd00187c18388fd3", "html_url": "https://github.com/rust-lang/rust/commit/9be0094b5cc24d82541d98a7bd00187c18388fd3"}, {"sha": "dd20c2ec5bc0c5ac02149479c2b5f3746f3df505", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd20c2ec5bc0c5ac02149479c2b5f3746f3df505", "html_url": "https://github.com/rust-lang/rust/commit/dd20c2ec5bc0c5ac02149479c2b5f3746f3df505"}], "stats": {"total": 182, "additions": 98, "deletions": 84}, "files": [{"sha": "de6b95686680ee76380ae3f057b2dbd111a2f56b", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=96d335d578984b42c2e00c715c924bceca391a6c", "patch": "@@ -20,8 +20,9 @@ use crate::{\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_endings::LineEndings,\n-    main_loop::ReqQueue,\n+    main_loop::{ReqQueue, Task},\n     request_metrics::{LatestRequests, RequestMetrics},\n+    thread_pool::TaskPool,\n     to_proto::url_from_abs_path,\n     Result,\n };\n@@ -66,6 +67,7 @@ impl Default for Status {\n /// incremental salsa database.\n pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n+    pub(crate) task_pool: (TaskPool<Task>, Receiver<Task>),\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) loader: Box<dyn vfs::loader::Handle>,\n     pub(crate) task_receiver: Receiver<vfs::loader::Message>,\n@@ -153,8 +155,15 @@ impl GlobalState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n+\n+        let task_pool = {\n+            let (sender, receiver) = unbounded();\n+            (TaskPool::new(sender), receiver)\n+        };\n+\n         let mut res = GlobalState {\n             config,\n+            task_pool,\n             analysis_host,\n             loader,\n             task_receiver,"}, {"sha": "ca788dd3cf963d5c206a29c23fbec857de197fcd", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=96d335d578984b42c2e00c715c924bceca391a6c", "patch": "@@ -30,6 +30,7 @@ mod diagnostics;\n mod line_endings;\n mod request_metrics;\n mod lsp_utils;\n+mod thread_pool;\n pub mod lsp_ext;\n pub mod config;\n "}, {"sha": "1a9c5ee2cef1d1d01cde6795586c882d9bad8eb8", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 52, "deletions": 83, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=96d335d578984b42c2e00c715c924bceca391a6c", "patch": "@@ -2,19 +2,17 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     env, fmt, panic,\n-    sync::Arc,\n     time::{Duration, Instant},\n };\n \n-use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n+use crossbeam_channel::{never, select, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Notification, Request, RequestId, Response};\n use lsp_types::{request::Request as _, NumberOrString};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n use serde::{de::DeserializeOwned, Serialize};\n-use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n@@ -118,20 +116,16 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         GlobalState::new(workspaces, config.lru_capacity, config, req_queue)\n     };\n \n-    let pool = ThreadPool::default();\n-    let (task_sender, task_receiver) = unbounded::<Task>();\n-\n     log::info!(\"server initialized, serving requests\");\n     {\n-        let task_sender = task_sender;\n         loop {\n             log::trace!(\"selecting\");\n             let event = select! {\n                 recv(&connection.receiver) -> msg => match msg {\n                     Ok(msg) => Event::Lsp(msg),\n                     Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n                 },\n-                recv(task_receiver) -> task => Event::Task(task.unwrap()),\n+                recv(&global_state.task_pool.1) -> task => Event::Task(task.unwrap()),\n                 recv(global_state.task_receiver) -> task => match task {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n@@ -147,29 +141,19 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 };\n             }\n             assert!(!global_state.vfs.read().0.has_changes());\n-            loop_turn(&pool, &task_sender, &connection, &mut global_state, event)?;\n+            loop_turn(&connection, &mut global_state, event)?;\n             assert!(!global_state.vfs.read().0.has_changes());\n         }\n     }\n     global_state.analysis_host.request_cancellation();\n-    log::info!(\"waiting for tasks to finish...\");\n-    task_receiver.into_iter().for_each(|task| on_task(task, &connection.sender, &mut global_state));\n-    log::info!(\"...tasks have finished\");\n-    log::info!(\"joining threadpool...\");\n-    pool.join();\n-    drop(pool);\n-    log::info!(\"...threadpool has finished\");\n-\n-    let vfs = Arc::try_unwrap(global_state.vfs).expect(\"all snapshots should be dead\");\n-    drop(vfs);\n-\n     Ok(())\n }\n \n #[derive(Debug)]\n-enum Task {\n+pub(crate) enum Task {\n     Respond(Response),\n-    Diagnostic(DiagnosticTask),\n+    Diagnostics(Vec<DiagnosticTask>),\n+    Unit,\n }\n \n enum Event {\n@@ -215,19 +199,13 @@ pub(crate) type ReqHandler = fn(&mut GlobalState, Response);\n pub(crate) type ReqQueue = lsp_server::ReqQueue<(&'static str, Instant), ReqHandler>;\n const DO_NOTHING: ReqHandler = |_, _| ();\n \n-fn loop_turn(\n-    pool: &ThreadPool,\n-    task_sender: &Sender<Task>,\n-    connection: &Connection,\n-    global_state: &mut GlobalState,\n-    event: Event,\n-) -> Result<()> {\n+fn loop_turn(connection: &Connection, global_state: &mut GlobalState, event: Event) -> Result<()> {\n     let loop_start = Instant::now();\n \n     // NOTE: don't count blocking select! call as a loop-turn time\n     let _p = profile(\"main_loop_inner/loop-turn\");\n     log::info!(\"loop turn = {:?}\", event);\n-    let queue_count = pool.queued_count();\n+    let queue_count = global_state.task_pool.0.len();\n     if queue_count > 0 {\n         log::info!(\"queued count = {}\", queue_count);\n     }\n@@ -269,12 +247,10 @@ fn loop_turn(\n                 )\n             }\n         },\n-        Event::Flycheck(task) => {\n-            on_check_task(task, global_state, task_sender, &connection.sender)?\n-        }\n+        Event::Flycheck(task) => on_check_task(task, global_state, &connection.sender)?,\n         Event::Lsp(msg) => match msg {\n             lsp_server::Message::Request(req) => {\n-                on_request(global_state, pool, task_sender, &connection.sender, loop_start, req)?\n+                on_request(global_state, &connection.sender, loop_start, req)?\n             }\n             lsp_server::Message::Notification(not) => {\n                 on_notification(&connection.sender, global_state, not)?;\n@@ -301,16 +277,14 @@ fn loop_turn(\n             .map(|path| global_state.vfs.read().0.file_id(&path).unwrap())\n             .collect::<Vec<_>>();\n \n-        update_file_notifications_on_threadpool(\n-            pool,\n-            global_state.snapshot(),\n-            task_sender.clone(),\n-            subscriptions.clone(),\n-        );\n-        pool.execute({\n+        update_file_notifications_on_threadpool(global_state, subscriptions.clone());\n+        global_state.task_pool.0.spawn({\n             let subs = subscriptions;\n             let snap = global_state.snapshot();\n-            move || snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n+            move || {\n+                snap.analysis.prime_caches(subs).unwrap_or_else(|_: Canceled| ());\n+                Task::Unit\n+            }\n         });\n     }\n \n@@ -345,26 +319,21 @@ fn on_task(task: Task, msg_sender: &Sender<lsp_server::Message>, global_state: &\n                 msg_sender.send(response.into()).unwrap();\n             }\n         }\n-        Task::Diagnostic(task) => on_diagnostic_task(task, msg_sender, global_state),\n+        Task::Diagnostics(tasks) => {\n+            tasks.into_iter().for_each(|task| on_diagnostic_task(task, msg_sender, global_state))\n+        }\n+        Task::Unit => (),\n     }\n }\n \n fn on_request(\n     global_state: &mut GlobalState,\n-    pool: &ThreadPool,\n-    task_sender: &Sender<Task>,\n     msg_sender: &Sender<lsp_server::Message>,\n     request_received: Instant,\n     req: Request,\n ) -> Result<()> {\n-    let mut pool_dispatcher = PoolDispatcher {\n-        req: Some(req),\n-        pool,\n-        global_state,\n-        task_sender,\n-        msg_sender,\n-        request_received,\n-    };\n+    let mut pool_dispatcher =\n+        PoolDispatcher { req: Some(req), global_state, msg_sender, request_received };\n     pool_dispatcher\n         .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n         .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n@@ -552,12 +521,11 @@ fn on_notification(\n fn on_check_task(\n     task: flycheck::Message,\n     global_state: &mut GlobalState,\n-    task_sender: &Sender<Task>,\n     msg_sender: &Sender<lsp_server::Message>,\n ) -> Result<()> {\n     match task {\n         flycheck::Message::ClearDiagnostics => {\n-            task_sender.send(Task::Diagnostic(DiagnosticTask::ClearCheck))?;\n+            on_diagnostic_task(DiagnosticTask::ClearCheck, msg_sender, global_state)\n         }\n \n         flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n@@ -576,11 +544,15 @@ fn on_check_task(\n                     }\n                 };\n \n-                task_sender.send(Task::Diagnostic(DiagnosticTask::AddCheck(\n-                    file_id,\n-                    diag.diagnostic,\n-                    diag.fixes.into_iter().map(|it| it.into()).collect(),\n-                )))?;\n+                on_diagnostic_task(\n+                    DiagnosticTask::AddCheck(\n+                        file_id,\n+                        diag.diagnostic,\n+                        diag.fixes.into_iter().map(|it| it.into()).collect(),\n+                    ),\n+                    msg_sender,\n+                    global_state,\n+                )\n             }\n         }\n \n@@ -674,10 +646,8 @@ fn report_progress(\n \n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n-    pool: &'a ThreadPool,\n     global_state: &'a mut GlobalState,\n     msg_sender: &'a Sender<lsp_server::Message>,\n-    task_sender: &'a Sender<Task>,\n     request_received: Instant,\n }\n \n@@ -725,13 +695,11 @@ impl<'a> PoolDispatcher<'a> {\n             }\n         };\n \n-        self.pool.execute({\n+        self.global_state.task_pool.0.spawn({\n             let world = self.global_state.snapshot();\n-            let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n-                let task = result_to_task::<R>(id, result);\n-                sender.send(task).unwrap();\n+                result_to_task::<R>(id, result)\n             }\n         });\n \n@@ -801,26 +769,27 @@ where\n }\n \n fn update_file_notifications_on_threadpool(\n-    pool: &ThreadPool,\n-    world: GlobalStateSnapshot,\n-    task_sender: Sender<Task>,\n+    global_state: &mut GlobalState,\n     subscriptions: Vec<FileId>,\n ) {\n     log::trace!(\"updating notifications for {:?}\", subscriptions);\n-    if world.config.publish_diagnostics {\n-        pool.execute(move || {\n-            for file_id in subscriptions {\n-                match handlers::publish_diagnostics(&world, file_id) {\n-                    Err(e) => {\n-                        if !is_canceled(&*e) {\n-                            log::error!(\"failed to compute diagnostics: {:?}\", e);\n-                        }\n-                    }\n-                    Ok(task) => {\n-                        task_sender.send(Task::Diagnostic(task)).unwrap();\n-                    }\n-                }\n-            }\n+    if global_state.config.publish_diagnostics {\n+        let snapshot = global_state.snapshot();\n+        global_state.task_pool.0.spawn(move || {\n+            let diagnostics = subscriptions\n+                .into_iter()\n+                .filter_map(|file_id| {\n+                    handlers::publish_diagnostics(&snapshot, file_id)\n+                        .map_err(|err| {\n+                            if !is_canceled(&*err) {\n+                                log::error!(\"failed to compute diagnostics: {:?}\", err);\n+                            }\n+                            ()\n+                        })\n+                        .ok()\n+                })\n+                .collect::<Vec<_>>();\n+            Task::Diagnostics(diagnostics)\n         })\n     }\n }"}, {"sha": "4fa5029253db09516c4270ae2a8c28da1bc929e3", "filename": "crates/rust-analyzer/src/thread_pool.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fthread_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d335d578984b42c2e00c715c924bceca391a6c/crates%2Frust-analyzer%2Fsrc%2Fthread_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fthread_pool.rs?ref=96d335d578984b42c2e00c715c924bceca391a6c", "patch": "@@ -0,0 +1,35 @@\n+//! A thin wrapper around `ThreadPool` to make sure that we join all things\n+//! properly.\n+use crossbeam_channel::Sender;\n+\n+pub(crate) struct TaskPool<T> {\n+    sender: Sender<T>,\n+    inner: threadpool::ThreadPool,\n+}\n+\n+impl<T> TaskPool<T> {\n+    pub(crate) fn new(sender: Sender<T>) -> TaskPool<T> {\n+        TaskPool { sender, inner: threadpool::ThreadPool::default() }\n+    }\n+\n+    pub(crate) fn spawn<F>(&mut self, task: F)\n+    where\n+        F: FnOnce() -> T + Send + 'static,\n+        T: Send + 'static,\n+    {\n+        self.inner.execute({\n+            let sender = self.sender.clone();\n+            move || sender.send(task()).unwrap()\n+        })\n+    }\n+\n+    pub(crate) fn len(&self) -> usize {\n+        self.inner.queued_count()\n+    }\n+}\n+\n+impl<T> Drop for TaskPool<T> {\n+    fn drop(&mut self) {\n+        self.inner.join()\n+    }\n+}"}]}