{"sha": "a417de94a94429e35afeb0a3eb867c2b1837a484", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTdkZTk0YTk0NDI5ZTM1YWZlYjBhM2ViODY3YzJiMTgzN2E0ODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-17T03:52:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T20:04:30Z"}, "message": "extra: Make room for more sync primitives", "tree": {"sha": "84af7c31d3dbd0ac99615bfd00c3ea6cf17e9856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84af7c31d3dbd0ac99615bfd00c3ea6cf17e9856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a417de94a94429e35afeb0a3eb867c2b1837a484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a417de94a94429e35afeb0a3eb867c2b1837a484", "html_url": "https://github.com/rust-lang/rust/commit/a417de94a94429e35afeb0a3eb867c2b1837a484", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a417de94a94429e35afeb0a3eb867c2b1837a484/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5f19795adda1bb2daca891e97bca8c7638916e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f19795adda1bb2daca891e97bca8c7638916e2", "html_url": "https://github.com/rust-lang/rust/commit/b5f19795adda1bb2daca891e97bca8c7638916e2"}], "stats": {"total": 48, "additions": 28, "deletions": 20}, "files": [{"sha": "21ebcf1272009435d66428a0f5472389911ff39f", "filename": "src/libextra/sync/mod.rs", "status": "renamed", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a417de94a94429e35afeb0a3eb867c2b1837a484/src%2Flibextra%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a417de94a94429e35afeb0a3eb867c2b1837a484/src%2Flibextra%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync%2Fmod.rs?ref=a417de94a94429e35afeb0a3eb867c2b1837a484", "patch": "@@ -17,9 +17,8 @@\n  * in std.\n  */\n \n-\n+use std::cast;\n use std::comm;\n-use std::unstable::sync::Exclusive;\n use std::sync::arc::UnsafeArc;\n use std::sync::atomics;\n use std::unstable::finally::Finally;\n@@ -32,6 +31,10 @@ use arc::MutexArc;\n  * Internals\n  ****************************************************************************/\n \n+pub mod mutex;\n+pub mod one;\n+mod mpsc_intrusive;\n+\n // Each waiting task receives on one of these.\n #[doc(hidden)]\n type WaitEnd = Port<()>;\n@@ -54,7 +57,7 @@ impl WaitQueue {\n             comm::Data(ch) => {\n                 // Send a wakeup signal. If the waiter was killed, its port will\n                 // have closed. Keep trying until we get a live task.\n-                if ch.try_send_deferred(()) {\n+                if ch.try_send(()) {\n                     true\n                 } else {\n                     self.signal()\n@@ -69,7 +72,7 @@ impl WaitQueue {\n         loop {\n             match self.head.try_recv() {\n                 comm::Data(ch) => {\n-                    if ch.try_send_deferred(()) {\n+                    if ch.try_send(()) {\n                         count += 1;\n                     }\n                 }\n@@ -81,36 +84,45 @@ impl WaitQueue {\n \n     fn wait_end(&self) -> WaitEnd {\n         let (wait_end, signal_end) = Chan::new();\n-        assert!(self.tail.try_send_deferred(signal_end));\n+        assert!(self.tail.try_send(signal_end));\n         wait_end\n     }\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n-#[doc(hidden)]\n struct SemInner<Q> {\n+    lock: mutex::Mutex,\n     count: int,\n     waiters:   WaitQueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n     blocked:   Q\n }\n \n-#[doc(hidden)]\n-struct Sem<Q>(Exclusive<SemInner<Q>>);\n+struct Sem<Q>(UnsafeArc<SemInner<Q>>);\n \n #[doc(hidden)]\n impl<Q:Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n-        Sem(Exclusive::new(SemInner {\n-            count: count, waiters: WaitQueue::new(), blocked: q }))\n+        Sem(UnsafeArc::new(SemInner {\n+            count: count,\n+            waiters: WaitQueue::new(),\n+            blocked: q,\n+            lock: mutex::Mutex::new(),\n+        }))\n+    }\n+\n+    unsafe fn with(&self, f: |&mut SemInner<Q>|) {\n+        let Sem(ref arc) = *self;\n+        let state = arc.get();\n+        let _g = (*state).lock.lock();\n+        f(cast::transmute(state));\n     }\n \n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n-            let Sem(ref lock) = *self;\n-            lock.with(|state| {\n+            self.with(|state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe, enqueue ourself, and tell\n@@ -129,8 +141,7 @@ impl<Q:Send> Sem<Q> {\n \n     pub fn release(&self) {\n         unsafe {\n-            let Sem(ref lock) = *self;\n-            lock.with(|state| {\n+            self.with(|state| {\n                 state.count += 1;\n                 if state.count <= 0 {\n                     state.waiters.signal();\n@@ -210,8 +221,7 @@ impl<'a> Condvar<'a> {\n         let mut out_of_bounds = None;\n         // Release lock, 'atomically' enqueuing ourselves in so doing.\n         unsafe {\n-            let Sem(ref queue) = *self.sem;\n-            queue.with(|state| {\n+            self.sem.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // Drop the lock.\n                     state.count += 1;\n@@ -253,8 +263,7 @@ impl<'a> Condvar<'a> {\n         unsafe {\n             let mut out_of_bounds = None;\n             let mut result = false;\n-            let Sem(ref lock) = *self.sem;\n-            lock.with(|state| {\n+            self.sem.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     result = state.blocked[condvar_id].signal();\n                 } else {\n@@ -276,8 +285,7 @@ impl<'a> Condvar<'a> {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n-            let Sem(ref lock) = *self.sem;\n-            lock.with(|state| {\n+            self.sem.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the", "previous_filename": "src/libextra/sync.rs"}]}