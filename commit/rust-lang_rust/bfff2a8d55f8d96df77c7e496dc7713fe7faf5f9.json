{"sha": "bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZmYyYThkNTVmOGQ5NmRmNzdjN2U0OTZkYzc3MTNmZTdmYWY1Zjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-15T19:25:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-15T21:26:11Z"}, "message": "make mut a keyword synonymous with mutable\n\nfirst step towards issue #1273", "tree": {"sha": "23c1e0515c6894f15bbd9c5b473f7f4e2653965d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23c1e0515c6894f15bbd9c5b473f7f4e2653965d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "html_url": "https://github.com/rust-lang/rust/commit/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dddd9908d537ce2858f37783779c3b88005ff0a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddd9908d537ce2858f37783779c3b88005ff0a8", "html_url": "https://github.com/rust-lang/rust/commit/dddd9908d537ce2858f37783779c3b88005ff0a8"}], "stats": {"total": 430, "additions": 224, "deletions": 206}, "files": [{"sha": "53ba8c65bdf77f02eca9a131a8e2ad3b4d6c611c", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -159,7 +159,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n     let mut_map =\n         time(time_passes, \"mutability checking\",\n-             bind middle::mut::check_crate(ty_cx, crate));\n+             bind middle::mutbl::check_crate(ty_cx, crate));\n     let (copy_map, ref_map) =\n         time(time_passes, \"alias checking\",\n              bind middle::alias::check_crate(ty_cx, crate));"}, {"sha": "47cd332875523905003900697b0d20d521254392", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -256,7 +256,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n     let test_desc_ty: ast::ty =\n         nospan(ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()));\n \n-    let vec_mt: ast::mt = {ty: @test_desc_ty, mut: ast::imm};\n+    let vec_mt: ast::mt = {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n     ret @nospan(ast::ty_vec(vec_mt));\n }\n@@ -270,7 +270,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     }\n \n     ret @{id: cx.sess.next_node_id(),\n-          node: ast::expr_vec(descs, ast::imm),\n+          node: ast::expr_vec(descs, ast::m_imm),\n           span: dummy_sp()};\n }\n \n@@ -288,7 +288,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let name_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"name\", expr: @name_expr});\n+        nospan({mutbl: ast::m_imm, ident: \"name\", expr: @name_expr});\n \n     let fn_path = @nospan({global: false, idents: path, types: []});\n \n@@ -300,7 +300,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n \n     let fn_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"fn\", expr: fn_wrapper_expr});\n+        nospan({mutbl: ast::m_imm, ident: \"fn\", expr: fn_wrapper_expr});\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -310,7 +310,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let ignore_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"ignore\", expr: @ignore_expr});\n+        nospan({mutbl: ast::m_imm, ident: \"ignore\", expr: @ignore_expr});\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n@@ -320,7 +320,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let fail_field: ast::field =\n-        nospan({mut: ast::imm, ident: \"should_fail\", expr: @fail_expr});\n+        nospan({mutbl: ast::m_imm, ident: \"should_fail\", expr: @fail_expr});\n \n     let desc_rec_: ast::expr_ =\n         ast::expr_rec([name_field, fn_field, ignore_field, fail_field],\n@@ -378,7 +378,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n fn mk_main(cx: test_ctxt) -> @ast::item {\n     let str_pt = @nospan({global: false, idents: [\"str\"], types: []});\n     let str_ty = @nospan(ast::ty_path(str_pt, cx.sess.next_node_id()));\n-    let args_mt: ast::mt = {ty: str_ty, mut: ast::imm};\n+    let args_mt: ast::mt = {ty: str_ty, mutbl: ast::m_imm};\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg ="}, {"sha": "71a95506a9da5a549a8b4d17831814f018ed31f1", "filename": "src/comp/metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -483,28 +483,28 @@ impl ast_output for ast_ctxt {\n                 self.tag(at_ty_bot) {||}\n               }\n \n-              ty_box({ty: ty, mut: m}) {\n+              ty_box({ty: ty, mutbl: m}) {\n                 self.tag(at_ty_box) {||\n                     self.ty(ty);\n                     self.mutbl(m);\n                 }\n               }\n \n-              ty_uniq({ty: ty, mut: m}) {\n+              ty_uniq({ty: ty, mutbl: m}) {\n                 self.tag(at_ty_uniq) {||\n                     self.ty(ty);\n                     self.mutbl(m);\n                 }\n               }\n \n-              ty_vec({ty: ty, mut: m}) {\n+              ty_vec({ty: ty, mutbl: m}) {\n                 self.tag(at_ty_vec) {||\n                     self.ty(ty);\n                     self.mutbl(m);\n                 }\n               }\n \n-              ty_ptr({ty: ty, mut: m}) {\n+              ty_ptr({ty: ty, mutbl: m}) {\n                 self.tag(at_ty_ptr) {||\n                     self.ty(ty);\n                     self.mutbl(m);"}, {"sha": "9bd7ee75512ebc2d7fd7f2155831cf22d0851a92", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -311,11 +311,11 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     let m;\n     alt peek(st) {\n-      'm' { next(st); m = ast::mut; }\n-      '?' { next(st); m = ast::maybe_mut; }\n-      _ { m = ast::imm; }\n+      'm' { next(st); m = ast::m_mutbl; }\n+      '?' { next(st); m = ast::m_const; }\n+      _ { m = ast::m_imm; }\n     }\n-    ret {ty: parse_ty(st, conv), mut: m};\n+    ret {ty: parse_ty(st, conv), mutbl: m};\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n@@ -356,7 +356,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     let inputs: [ty::arg] = [];\n     while peek(st) != ']' {\n         let mode = alt check peek(st) {\n-          '&' { ast::by_mut_ref }\n+          '&' { ast::by_mutbl_ref }\n           '-' { ast::by_move }\n           '+' { ast::by_copy }\n           '=' { ast::by_ref }"}, {"sha": "e1e0cd7d68b02569d171194c6212f296ec3cf467", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -85,10 +85,10 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     }\n }\n fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n-    alt mt.mut {\n-      imm { }\n-      mut { w.write_char('m'); }\n-      maybe_mut { w.write_char('?'); }\n+    alt mt.mutbl {\n+      m_imm { }\n+      m_mutbl { w.write_char('m'); }\n+      m_const { w.write_char('?'); }\n     }\n     enc_ty(w, cx, mt.ty);\n }\n@@ -215,7 +215,7 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n     for arg: ty::arg in ft.inputs {\n         alt ty::resolved_mode(cx.tcx, arg.mode) {\n-          by_mut_ref { w.write_char('&'); }\n+          by_mutbl_ref { w.write_char('&'); }\n           by_move { w.write_char('-'); }\n           by_copy { w.write_char('+'); }\n           by_ref { w.write_char('='); }"}, {"sha": "34caf927662c0e7a5ddb2647839f95b7a873bf34", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -22,7 +22,7 @@ type invalid = {reason: invalid_reason,\n                 node_id: node_id,\n                 sp: span, path: @ast::path};\n \n-enum unsafe_ty { contains(ty::t), mut_contains(ty::t), }\n+enum unsafe_ty { contains(ty::t), mutbl_contains(ty::t), }\n \n type binding = @{node_id: node_id,\n                  span: span,\n@@ -183,9 +183,9 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n             err(cx, loc.span, \"a reference binding can't be \\\n                                rooted in a temporary\");\n         }\n-        for proot in pattern_roots(cx.tcx, root.mut, loc.node.pat) {\n+        for proot in pattern_roots(cx.tcx, root.mutbl, loc.node.pat) {\n             let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n-                                 unsafe_set(proot.mut));\n+                                 unsafe_set(proot.mutbl));\n             // Don't implicitly copy explicit references\n             bnd.copied = not_allowed;\n             bs += [bnd];\n@@ -228,7 +228,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n         let arg = args[i];\n         let root = expr_root(cx, arg, false);\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n-          ast::by_mut_ref {\n+          ast::by_mutbl_ref {\n             alt path_def(cx, arg) {\n               some(def) {\n                 let dnum = ast_util::def_id_of_def(def).node;\n@@ -242,14 +242,14 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n         let root_var = path_def_id(cx, root.ex);\n         let arg_copied = alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n           ast::by_move | ast::by_copy { copied }\n-          ast::by_mut_ref { not_allowed }\n+          ast::by_mutbl_ref { not_allowed }\n           ast::by_ref | ast::by_val { not_copied }\n         };\n         bindings += [@{node_id: arg.id,\n                        span: arg.span,\n                        root_var: root_var,\n                        local_id: 0u,\n-                       unsafe_tys: unsafe_set(root.mut),\n+                       unsafe_tys: unsafe_set(root.mutbl),\n                        mutable copied: arg_copied}];\n         i += 1u;\n     }\n@@ -285,7 +285,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias =\n-                    (ast::by_mut_ref == ty::arg_mode(cx.tcx, arg_t));\n+                    (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n                 if i != j &&\n                        ty_can_unsafely_include(cx, unsafe_ty, arg_t.ty,\n                                                mut_alias) &&\n@@ -339,14 +339,14 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n             span: span};\n         let binding_info: [info] = [];\n         for pat in a.pats {\n-            for proot in pattern_roots(cx.tcx, root.mut, pat) {\n+            for proot in pattern_roots(cx.tcx, root.mutbl, pat) {\n                 let canon_id = pat_id_map.get(proot.name);\n                 alt vec::find(binding_info, {|x| x.id == canon_id}) {\n-                  some(s) { s.unsafe_tys += unsafe_set(proot.mut); }\n+                  some(s) { s.unsafe_tys += unsafe_set(proot.mutbl); }\n                   none {\n                       binding_info += [\n                           {id: canon_id,\n-                           mutable unsafe_tys: unsafe_set(proot.mut),\n+                           mutable unsafe_tys: unsafe_set(proot.mutbl),\n                            span: proot.span}];\n                   }\n                 }\n@@ -369,20 +369,20 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n-    let cur_mut = root.mut;\n+    let cur_mutbl = root.mutbl;\n     alt ty::get(seq_t).struct {\n       ty::ty_vec(mt) {\n-        if mt.mut != ast::imm {\n-            cur_mut = some(contains(seq_t));\n+        if mt.mutbl != ast::m_imm {\n+            cur_mutbl = some(contains(seq_t));\n         }\n       }\n       _ {}\n     }\n     let root_var = path_def_id(cx, root.ex);\n     let new_bs = sc.bs;\n-    for proot in pattern_roots(cx.tcx, cur_mut, local.node.pat) {\n+    for proot in pattern_roots(cx.tcx, cur_mutbl, local.node.pat) {\n         new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n-                              unsafe_set(proot.mut))];\n+                              unsafe_set(proot.mutbl))];\n     }\n     visit::visit_block(blk, {bs: new_bs with sc}, v);\n }\n@@ -493,36 +493,36 @@ fn path_def_id(cx: ctx, ex: @ast::expr) -> option<ast::node_id> {\n }\n \n fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n-                           mut: bool) -> bool {\n-    fn get_mut(cur: bool, mt: ty::mt) -> bool {\n-        ret cur || mt.mut != ast::imm;\n+                           mutbl: bool) -> bool {\n+    fn get_mutbl(cur: bool, mt: ty::mt) -> bool {\n+        ret cur || mt.mutbl != ast::m_imm;\n     }\n-    fn helper(tcx: ty::ctxt, needle: unsafe_ty, haystack: ty::t, mut: bool)\n+    fn helper(tcx: ty::ctxt, needle: unsafe_ty, haystack: ty::t, mutbl: bool)\n         -> bool {\n         if alt needle {\n           contains(ty) { ty == haystack }\n-          mut_contains(ty) { mut && ty == haystack }\n+          mutbl_contains(ty) { mutbl && ty == haystack }\n         } { ret true; }\n         alt ty::get(haystack).struct {\n           ty::ty_enum(_, ts) {\n             for t: ty::t in ts {\n-                if helper(tcx, needle, t, mut) { ret true; }\n+                if helper(tcx, needle, t, mutbl) { ret true; }\n             }\n             ret false;\n           }\n           ty::ty_box(mt) | ty::ty_ptr(mt) | ty::ty_uniq(mt) {\n-            ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+            ret helper(tcx, needle, mt.ty, get_mutbl(mutbl, mt));\n           }\n           ty::ty_rec(fields) {\n             for f: ty::field in fields {\n-                if helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt)) {\n+                if helper(tcx, needle, f.mt.ty, get_mutbl(mutbl, f.mt)) {\n                     ret true;\n                 }\n             }\n             ret false;\n           }\n           ty::ty_tup(ts) {\n-            for t in ts { if helper(tcx, needle, t, mut) { ret true; } }\n+            for t in ts { if helper(tcx, needle, t, mutbl) { ret true; } }\n             ret false;\n           }\n           ty::ty_fn({proto: ast::proto_bare, _}) { ret false; }\n@@ -532,11 +532,11 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n           // overwritten.\n-          ty::ty_param(_, _) { ret mut; }\n+          ty::ty_param(_, _) { ret mutbl; }\n           _ { ret false; }\n         }\n     }\n-    ret helper(cx.tcx, needle, haystack, mut);\n+    ret helper(cx.tcx, needle, haystack, mutbl);\n }\n \n fn def_is_local(d: ast::def) -> bool {\n@@ -589,66 +589,66 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n \n type pattern_root = {id: node_id,\n                      name: ident,\n-                     mut: option<unsafe_ty>,\n+                     mutbl: option<unsafe_ty>,\n                      span: span};\n \n-fn pattern_roots(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat)\n+fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n     -> [pattern_root] {\n-    fn walk(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat,\n+    fn walk(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt normalize_pat(tcx, pat).node {\n           ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) {}\n           ast::pat_ident(nm, sub) {\n-            set += [{id: pat.id, name: path_to_ident(nm), mut: mut,\n+            set += [{id: pat.id, name: path_to_ident(nm), mutbl: mutbl,\n                         span: pat.span}];\n-            alt sub { some(p) { walk(tcx, mut, p, set); } _ {} }\n+            alt sub { some(p) { walk(tcx, mutbl, p, set); } _ {} }\n           }\n           ast::pat_enum(_, ps) | ast::pat_tup(ps) {\n-            for p in ps { walk(tcx, mut, p, set); }\n+            for p in ps { walk(tcx, mutbl, p, set); }\n           }\n           ast::pat_rec(fs, _) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             for f in fs {\n-                let m = ty::get_field(ty, f.ident).mt.mut != ast::imm,\n-                    c = if m { some(contains(ty)) } else { mut };\n+                let m = ty::get_field(ty, f.ident).mt.mutbl != ast::m_imm,\n+                    c = if m { some(contains(ty)) } else { mutbl };\n                 walk(tcx, c, f.pat, set);\n             }\n           }\n           ast::pat_box(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::get(ty).struct {\n-              ty::ty_box(mt) { mt.mut != ast::imm }\n+              ty::ty_box(mt) { mt.mutbl != ast::m_imm }\n               _ { tcx.sess.span_bug(pat.span, \"box pat has non-box type\"); }\n             },\n-                c = if m  {some(contains(ty)) } else { mut };\n+                c = if m  {some(contains(ty)) } else { mutbl };\n             walk(tcx, c, p, set);\n           }\n           ast::pat_uniq(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::get(ty).struct {\n-              ty::ty_uniq(mt) { mt.mut != ast::imm }\n+              ty::ty_uniq(mt) { mt.mutbl != ast::m_imm }\n               _ { tcx.sess.span_bug(pat.span, \"uniq pat has non-uniq type\"); }\n             },\n-                c = if m { some(contains(ty)) } else { mut };\n+                c = if m { some(contains(ty)) } else { mutbl };\n             walk(tcx, c, p, set);\n           }\n         }\n     }\n     let set = [];\n-    walk(tcx, mut, pat, set);\n+    walk(tcx, mutbl, pat, set);\n     ret set;\n }\n \n-// Wraps the expr_root in mut.rs to also handle roots that exist through\n+// Wraps the expr_root in mutbl.rs to also handle roots that exist through\n // return-by-reference\n fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n-    -> {ex: @ast::expr, mut: option<unsafe_ty>} {\n-    let base_root = mut::expr_root(cx.tcx, ex, autoderef);\n+    -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n+    let base_root = mutbl::expr_root(cx.tcx, ex, autoderef);\n     let unsafe_ty = none;\n     for d in *base_root.ds {\n-        if d.mut { unsafe_ty = some(contains(d.outer_t)); break; }\n+        if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }\n     }\n-    ret {ex: base_root.ex, mut: unsafe_ty};\n+    ret {ex: base_root.ex, mutbl: unsafe_ty};\n }\n \n fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {"}, {"sha": "1349a43e7e0a192e8af5d20e439470788da7ddfe", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -587,21 +587,21 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           ty::ty_float(t) { ast::ty_float(t) }\n           ty::ty_uint(t) { ast::ty_uint(t) }\n           ty::ty_box(mt) { ast::ty_box({ty: t_to_ty(cx, mt.ty, span),\n-                                        mut: mt.mut}) }\n+                                        mutbl: mt.mutbl}) }\n           ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n-                                          mut: mt.mut}) }\n+                                          mutbl: mt.mutbl}) }\n           ty::ty_rec(fields) {\n             let fs = [];\n             for field in fields {\n                 fs += [{node: {ident: field.ident,\n                                mt: {ty: t_to_ty(cx, field.mt.ty, span),\n-                                    mut: field.mt.mut}},\n+                                    mutbl: field.mt.mutbl}},\n                         span: span}];\n             }\n             ast::ty_rec(fs)\n           }\n           ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n-                                        mut: mt.mut}) }\n+                                        mutbl: mt.mutbl}) }\n           _ {\n             cx.tcx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n           }"}, {"sha": "8c12807ae43f36c84e8830512160732c094a2316", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -167,7 +167,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n             alt ty::arg_mode(cx.tcx, arg_t) {\n               by_copy { maybe_copy(cx, args[i]); }\n-              by_ref | by_val | by_mut_ref | by_move { }\n+              by_ref | by_val | by_mutbl_ref | by_move { }\n             }\n             i += 1u;\n         }"}, {"sha": "69166d3ba7fb0444571e57c9b77400a9a9b8730a", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -156,7 +156,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n               }\n               _ {\n                 alt ty::arg_mode(cx.tcx, arg_ts[i]) {\n-                  by_mut_ref { clear_if_path(cx, arg, v, false); }\n+                  by_mutbl_ref { clear_if_path(cx, arg, v, false); }\n                   _ { v.visit_expr(arg, cx, v); }\n                 }\n               }\n@@ -299,7 +299,7 @@ fn clear_def_if_path(cx: ctx, d: def, to: bool)\n             clear_in_current(cx, def_id.node, to);\n             some(def_id.node)\n           }\n-          by_ref | by_val | by_mut_ref {\n+          by_ref | by_val | by_mutbl_ref {\n             none\n           }\n         }"}, {"sha": "7ba837f823123001350fe54b50172c7ab5af77cb", "filename": "src/comp/middle/mutbl.rs", "status": "renamed", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmutbl.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -5,7 +5,7 @@ import driver::session::session;\n \n enum deref_t { unbox(bool), field, index, }\n \n-type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n+type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n \n // Finds the root (the thing that is dereferenced) for the given expr, and a\n // vec of dereferences that were used on this root. Note that, in this vec,\n@@ -18,15 +18,19 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         while true {\n             alt ty::get(t).struct {\n               ty::ty_box(mt) {\n-                ds += [@{mut: mt.mut == mut, kind: unbox(false), outer_t: t}];\n+                ds += [@{mutbl: mt.mutbl == m_mutbl,\n+                         kind: unbox(false),\n+                         outer_t: t}];\n                 t = mt.ty;\n               }\n               ty::ty_uniq(mt) {\n-                ds += [@{mut: mt.mut == mut, kind: unbox(false), outer_t: t}];\n+                ds += [@{mutbl: mt.mutbl == m_mutbl,\n+                         kind: unbox(false),\n+                         outer_t: t}];\n                 t = mt.ty;\n               }\n               ty::ty_res(_, inner, tps) {\n-                ds += [@{mut: false, kind: unbox(false), outer_t: t}];\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n                 t = ty::substitute_type_params(tcx, tps, inner);\n               }\n               ty::ty_enum(did, tps) {\n@@ -35,7 +39,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                        vec::len(variants[0].args) != 1u {\n                     break;\n                 }\n-                ds += [@{mut: false, kind: unbox(false), outer_t: t}];\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n                 t = ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n               }\n               _ { break; }\n@@ -48,19 +52,19 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         alt copy ex.node {\n           expr_field(base, ident, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n-            let is_mut = false;\n+            let is_mutbl = false;\n             alt ty::get(auto_unbox.t).struct {\n               ty::ty_rec(fields) {\n                 for fld: ty::field in fields {\n                     if str::eq(ident, fld.ident) {\n-                        is_mut = fld.mt.mut == mut;\n+                        is_mutbl = fld.mt.mutbl == m_mutbl;\n                         break;\n                     }\n                 }\n               }\n               _ {}\n             }\n-            ds += [@{mut: is_mut, kind: field, outer_t: auto_unbox.t}];\n+            ds += [@{mutbl: is_mutbl, kind: field, outer_t: auto_unbox.t}];\n             ds += auto_unbox.ds;\n             ex = base;\n           }\n@@ -69,12 +73,12 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n             alt ty::get(auto_unbox.t).struct {\n               ty::ty_vec(mt) {\n                 ds +=\n-                    [@{mut: mt.mut == mut,\n+                    [@{mutbl: mt.mutbl == m_mutbl,\n                        kind: index,\n                        outer_t: auto_unbox.t}];\n               }\n               ty::ty_str {\n-                ds += [@{mut: false, kind: index, outer_t: auto_unbox.t}];\n+                ds += [@{mutbl: false, kind: index, outer_t: auto_unbox.t}];\n               }\n               _ { break; }\n             }\n@@ -84,17 +88,20 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n           expr_unary(op, base) {\n             if op == deref {\n                 let base_t = ty::expr_ty(tcx, base);\n-                let is_mut = false, ptr = false;\n+                let is_mutbl = false, ptr = false;\n                 alt ty::get(base_t).struct {\n-                  ty::ty_box(mt) { is_mut = mt.mut == mut; }\n-                  ty::ty_uniq(mt) { is_mut = mt.mut == mut; }\n+                  ty::ty_box(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n+                  ty::ty_uniq(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n                   ty::ty_res(_, _, _) { }\n                   ty::ty_enum(_, _) { }\n-                  ty::ty_ptr(mt) { is_mut = mt.mut == mut; ptr = true; }\n+                  ty::ty_ptr(mt) {\n+                    is_mutbl = mt.mutbl == m_mutbl;\n+                    ptr = true;\n+                  }\n                   _ { tcx.sess.span_bug(base.span, \"Ill-typed base \\\n                         expression in deref\"); }\n                 }\n-                ds += [@{mut: is_mut, kind: unbox(ptr && is_mut),\n+                ds += [@{mutbl: is_mutbl, kind: unbox(ptr && is_mutbl),\n                          outer_t: base_t}];\n                 ex = base;\n             } else { break; }\n@@ -109,27 +116,27 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n     ret {ex: ex, ds: @ds};\n }\n \n-// Actual mut-checking pass\n+// Actual mutbl-checking pass\n \n-type mut_map = std::map::hashmap<node_id, ()>;\n-type ctx = {tcx: ty::ctxt, mut_map: mut_map};\n+type mutbl_map = std::map::hashmap<node_id, ()>;\n+type ctx = {tcx: ty::ctxt, mutbl_map: mutbl_map};\n \n-fn check_crate(tcx: ty::ctxt, crate: @crate) -> mut_map {\n-    let cx = @{tcx: tcx, mut_map: std::map::new_int_hash()};\n+fn check_crate(tcx: ty::ctxt, crate: @crate) -> mutbl_map {\n+    let cx = @{tcx: tcx, mutbl_map: std::map::new_int_hash()};\n     let v = @{visit_expr: bind visit_expr(cx, _, _, _),\n               visit_decl: bind visit_decl(cx, _, _, _)\n               with *visit::default_visitor()};\n     visit::visit_crate(*crate, (), visit::mk_vt(v));\n-    ret cx.mut_map;\n+    ret cx.mutbl_map;\n }\n \n-enum msg { msg_assign, msg_move_out, msg_mut_ref, }\n+enum msg { msg_assign, msg_move_out, msg_mutbl_ref, }\n \n fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span, alt msg {\n       msg_assign { \"assigning to \" + name }\n       msg_move_out { \"moving out of \" + name }\n-      msg_mut_ref { \"passing \" + name + \" by mutable reference\" }\n+      msg_mutbl_ref { \"passing \" + name + \" by mutable reference\" }\n     });\n }\n \n@@ -178,20 +185,20 @@ fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n           some(name) { mk_err(cx, dest.span, msg, name); }\n           _ { }\n         }\n-        cx.mut_map.insert(ast_util::def_id_of_def(def).node, ());\n+        cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n       }\n       _ {\n         let root = expr_root(cx.tcx, dest, false);\n         if vec::len(*root.ds) == 0u {\n             if msg != msg_move_out {\n                 mk_err(cx, dest.span, msg, \"non-lvalue\");\n             }\n-        } else if !root.ds[0].mut {\n+        } else if !root.ds[0].mutbl {\n             let name =\n                 alt root.ds[0].kind {\n-                  mut::unbox(_) { \"immutable box\" }\n-                  mut::field { \"immutable field\" }\n-                  mut::index { \"immutable vec content\" }\n+                  mutbl::unbox(_) { \"immutable box\" }\n+                  mutbl::field { \"immutable field\" }\n+                  mutbl::index { \"immutable vec content\" }\n                 };\n             mk_err(cx, dest.span, msg, name);\n         }\n@@ -227,7 +234,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n-          by_mut_ref { check_lval(cx, args[i], msg_mut_ref); }\n+          by_mutbl_ref { check_lval(cx, args[i], msg_mutbl_ref); }\n           by_move { check_lval(cx, args[i], msg_move_out); }\n           by_ref | by_val | by_copy { }\n         }\n@@ -242,7 +249,7 @@ fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n         alt arg {\n           some(expr) {\n             let o_msg = alt ty::resolved_mode(cx.tcx, arg_ts[i].mode) {\n-              by_mut_ref { some(\"by mutable reference\") }\n+              by_mutbl_ref { some(\"by mutable reference\") }\n               by_move { some(\"by move\") }\n               _ { none }\n             };\n@@ -269,7 +276,7 @@ fn is_immutable_def(cx: @ctx, def: def) -> option<str> {\n       def_arg(_, m) {\n         alt ty::resolved_mode(cx.tcx, m) {\n           by_ref | by_val { some(\"argument\") }\n-          by_mut_ref | by_move | by_copy { none }\n+          by_mutbl_ref | by_move | by_copy { none }\n         }\n       }\n       def_self(_) { some(\"self argument\") }", "previous_filename": "src/comp/middle/mut.rs"}, {"sha": "3b8bde61cb80a0b3429a374284ae5c2b4dea3a7f", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -3987,7 +3987,7 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = bcx_ccx(cx);\n-    if is_simple && !ccx.mut_map.contains_key(local.node.pat.id) &&\n+    if is_simple && !ccx.mutbl_map.contains_key(local.node.pat.id) &&\n        !ccx.last_uses.contains_key(local.node.pat.id) &&\n        ty::type_is_immediate(t) {\n         alt local.node.init {\n@@ -4166,7 +4166,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v }\n                                               _ { epic_fail() } };\n         alt ty::resolved_mode(tcx, arg.mode) {\n-          ast::by_mut_ref { }\n+          ast::by_mutbl_ref { }\n           ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n           ast::by_val {\n             if !ty::type_is_immediate(arg.ty) {\n@@ -4598,7 +4598,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n             {mode: ast::expl(ast::by_val),\n-             ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n+             ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm})};\n         // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, [vecarg_ty], nt, []);\n@@ -5003,7 +5003,7 @@ fn write_abi_version(ccx: @crate_ctxt) {\n \n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, emap: resolve::exp_map, amap: ast_map::map,\n-               mut_map: mut::mut_map, copy_map: alias::copy_map,\n+               mutbl_map: mutbl::mutbl_map, copy_map: alias::copy_map,\n                last_uses: last_use::last_uses, impl_map: resolve::impl_map,\n                method_map: typeck::method_map, dict_map: typeck::dict_map)\n     -> (ModuleRef, link::link_meta) {\n@@ -5080,7 +5080,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           type_sha1s: ty::new_ty_hash(),\n           type_short_names: ty::new_ty_hash(),\n           tcx: tcx,\n-          mut_map: mut_map,\n+          mutbl_map: mutbl_map,\n           copy_map: copy_map,\n           last_uses: last_uses,\n           impl_map: impl_map,"}, {"sha": "b6ef093d534c9893a55d029ef2f4900e9399aec5", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -276,7 +276,7 @@ fn store_environment(\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n+    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n \n     // If necessary, copy tydescs describing type parameters into the\n@@ -905,7 +905,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                 bcx = take_ty(bcx, alloc, out_arg.ty);\n                 val = alloc;\n               }\n-              ast::by_ref | ast::by_mut_ref | ast::by_move { }\n+              ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n             }\n \n             // If the type is parameterized, then we need to cast the"}, {"sha": "6398928e0664da2f3b01ed0cf28f33bfafe7fc6b", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -104,7 +104,7 @@ type crate_ctxt =\n      type_sha1s: hashmap<ty::t, str>,\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n-     mut_map: mut::mut_map,\n+     mutbl_map: mutbl::mutbl_map,\n      copy_map: alias::copy_map,\n      last_uses: last_use::last_uses,\n      impl_map: resolve::impl_map,\n@@ -622,7 +622,7 @@ fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n // descr is embedded in the box (ty::type vs ty::send_type).  This is useful\n // for unique closure boxes, hence the name \"cbox_ty\" (closure box type).\n fn tuplify_cbox_ty(tcx: ty::ctxt, t: ty::t, tydesc_t: ty::t) -> ty::t {\n-    let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mut: ast::imm});\n+    let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n     ret ty::mk_tup(tcx, [ty::mk_uint(tcx), tydesc_t,\n                          ptr, ptr,\n                          t]);"}, {"sha": "2a4a2d423e207d8d65e9ed603f9ef7736b87ae78", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -782,7 +782,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n // nominal type that has pointers to itself in it.\n fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n     fn nilptr(tcx: ty::ctxt) -> ty::t {\n-        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mut: ast::imm})\n+        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n     }\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         alt ty::get(typ).struct {"}, {"sha": "cd0cd7e11c3c8db2bea079b94ef4fe0b13330da4", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -1089,7 +1089,7 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n     vec::map(callee_modes(fcx, callee)) {|m|\n         alt ty::resolved_mode(fcx.ccx.tcx, m) {\n           by_move { init_move }\n-          by_copy | by_ref | by_val | by_mut_ref { init_assign }\n+          by_copy | by_ref | by_val | by_mutbl_ref { init_assign }\n         }\n     }\n }"}, {"sha": "326c768cabe662b4eafbac179e5df15467495699", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -275,7 +275,7 @@ fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n     vec::iteri(modes) {|i,mode|\n         alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n           by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n-          by_ref | by_val | by_mut_ref | by_copy { }\n+          by_ref | by_val | by_mutbl_ref | by_copy { }\n         }\n     }\n }"}, {"sha": "06823f4aa30c7af20e0df7fcef44fa0b9575b375", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -147,7 +147,7 @@ type method = {ident: ast::ident,\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n-type mt = {ty: t, mut: ast::mutability};\n+type mt = {ty: t, mutbl: ast::mutability};\n \n \n // Contains information needed to resolve types and (in the future) look up\n@@ -423,15 +423,18 @@ fn mk_enum(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n \n fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n-fn mk_imm_box(cx: ctxt, ty: t) -> t { mk_box(cx, {ty: ty, mut: ast::imm}) }\n+fn mk_imm_box(cx: ctxt, ty: t) -> t { mk_box(cx, {ty: ty,\n+                                                  mutbl: ast::m_imm}) }\n \n fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n-fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty, mut: ast::imm}) }\n+fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty,\n+                                                    mutbl: ast::m_imm}) }\n \n fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty, mut: ast::mut}) }\n+fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty,\n+                                                  mutbl: ast::m_mutbl}) }\n \n fn mk_vec(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_vec(tm)) }\n \n@@ -541,16 +544,16 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box {}\n       ty_box(tm) {\n-        ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n+        ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n       }\n       ty_uniq(tm) {\n-        ty = mk_uniq(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n+        ty = mk_uniq(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n       }\n       ty_ptr(tm) {\n-        ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n+        ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n       }\n       ty_vec(tm) {\n-        ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n+        ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n       }\n       ty_enum(tid, subtys) {\n         ty = mk_enum(cx, tid, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n@@ -565,7 +568,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         let new_fields: [field] = [];\n         for fl: field in fields {\n             let new_ty = fold_ty(cx, fld, fl.mt.ty);\n-            let new_mt = {ty: new_ty, mut: fl.mt.mut};\n+            let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n             new_fields += [{ident: fl.ident, mt: new_mt}];\n         }\n         ty = mk_rec(cx, new_fields);\n@@ -922,12 +925,11 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n         alt sty {\n           ty_param(_, _) { true }\n           ty_vec(mt) {\n-            mt.mut != ast::imm\n+            mt.mutbl != ast::m_imm\n           }\n           ty_rec(fields) {\n             for field in fields {\n-                if field.mt.mut !=\n-                    ast::imm {\n+                if field.mt.mutbl != ast::m_imm {\n                     ret true;\n                 }\n             }\n@@ -1665,7 +1667,7 @@ mod unify {\n         // If you're unifying on something mutable then we have to\n         // be invariant on the inner type\n         let newvariance = alt expected {\n-          ast::mut {\n+          ast::m_mutbl {\n             variance_transform(variance, invariant)\n           }\n           _ {\n@@ -1675,11 +1677,11 @@ mod unify {\n \n         if expected == actual { ret some((expected, newvariance)); }\n         if variance == covariant {\n-            if expected == ast::maybe_mut {\n+            if expected == ast::m_const {\n                 ret some((actual, newvariance));\n             }\n         } else if variance == contravariant {\n-            if actual == ast::maybe_mut {\n+            if actual == ast::m_const {\n                 ret some((expected, newvariance));\n             }\n         }\n@@ -1960,15 +1962,15 @@ mod unify {\n             alt get(actual).struct {\n               ty_box(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n-                    expected_mt.mut, actual_mt.mut, variance) {\n+                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n                   none { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mutt};\n+                    let mt = {ty: result_sub, mutbl: mutt};\n                     ret ures_ok(mk_box(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -1981,15 +1983,15 @@ mod unify {\n             alt get(actual).struct {\n               ty_uniq(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n-                    expected_mt.mut, actual_mt.mut, variance) {\n+                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n                   none { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_mt) {\n-                    let mt = {ty: result_mt, mut: mutt};\n+                    let mt = {ty: result_mt, mutbl: mutt};\n                     ret ures_ok(mk_uniq(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2002,15 +2004,15 @@ mod unify {\n             alt get(actual).struct {\n               ty_vec(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n-                    expected_mt.mut, actual_mt.mut, variance) {\n+                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n                   none { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mutt};\n+                    let mt = {ty: result_sub, mutbl: mutt};\n                     ret ures_ok(mk_vec(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2023,15 +2025,15 @@ mod unify {\n             alt get(actual).struct {\n               ty_ptr(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n-                    expected_mt.mut, actual_mt.mut, variance) {\n+                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n                   none { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n                     cx, expected_mt.ty, actual_mt.ty, var);\n                 alt result {\n                   ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mutt};\n+                    let mt = {ty: result_sub, mutbl: mutt};\n                     ret ures_ok(mk_ptr(cx.tcx, mt));\n                   }\n                   _ { ret result; }\n@@ -2086,9 +2088,10 @@ mod unify {\n                 while i < expected_len {\n                     let expected_field = expected_fields[i];\n                     let actual_field = actual_fields[i];\n-                    let (mutt, var) = alt unify_mut(\n-                        expected_field.mt.mut, actual_field.mt.mut, variance)\n-                        {\n+                    let u_mut = unify_mut(expected_field.mt.mutbl,\n+                                          actual_field.mt.mutbl,\n+                                          variance);\n+                    let (mutt, var) = alt u_mut {\n                       none { ret ures_err(terr_record_mutability); }\n                       some(mv) { mv }\n                     };\n@@ -2103,7 +2106,7 @@ mod unify {\n                                    actual_field.mt.ty, var);\n                     alt result {\n                       ures_ok(rty) {\n-                        let mt = {ty: rty, mut: mutt};\n+                        let mt = {ty: rty, mutbl: mutt};\n                         result_fields += [{mt: mt with expected_field}];\n                       }\n                       _ { ret result; }"}, {"sha": "a54a376be2dd8d9238902cb333035a57039b3114", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -115,7 +115,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n                 fcx.ccx.tcx,\n                 {\n                     ty: ty::mk_mach_uint(fcx.ccx.tcx, ast::ty_u8),\n-                    mut: ast::imm\n+                    mutbl: ast::m_imm\n                 })\n         };\n       }\n@@ -259,7 +259,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n     fn ast_mt_to_mt(tcx: ty::ctxt, mode: mode, mt: ast::mt) -> ty::mt {\n-        ret {ty: ast_ty_to_ty(tcx, mode, mt.ty), mut: mt.mut};\n+        ret {ty: ast_ty_to_ty(tcx, mode, mt.ty), mutbl: mt.mutbl};\n     }\n     fn instantiate(tcx: ty::ctxt, sp: span, mode: mode,\n                    id: ast::def_id, args: [@ast::ty]) -> ty::t {\n@@ -2057,9 +2057,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         bot = check_expr(fcx, oper);\n         let oper_t = expr_ty(tcx, oper);\n         alt unop {\n-          ast::box(mut) { oper_t = ty::mk_box(tcx, {ty: oper_t, mut: mut}); }\n-          ast::uniq(mut) {\n-            oper_t = ty::mk_uniq(tcx, {ty: oper_t, mut: mut});\n+          ast::box(mutbl) {\n+            oper_t = ty::mk_box(tcx, {ty: oper_t, mutbl: mutbl});\n+          }\n+          ast::uniq(mutbl) {\n+            oper_t = ty::mk_uniq(tcx, {ty: oper_t, mutbl: mutbl});\n           }\n           ast::deref {\n             alt structure_of(fcx, expr.span, oper_t) {\n@@ -2358,10 +2360,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         write_ty(tcx, id, t_1);\n       }\n-      ast::expr_vec(args, mut) {\n+      ast::expr_vec(args, mutbl) {\n         let t: ty::t = next_ty_var(fcx);\n         for e: @ast::expr in args { bot |= check_expr_with(fcx, e, t); }\n-        let typ = ty::mk_vec(tcx, {ty: t, mut: mut});\n+        let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n         write_ty(tcx, id, typ);\n       }\n       ast::expr_tup(elts) {\n@@ -2381,7 +2383,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n-            let expr_mt = {ty: expr_t, mut: f.node.mut};\n+            let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n             fields_t +=\n@@ -2894,7 +2896,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::get(a.ty).struct {\n       ty::ty_vec(mt) {\n-        if mt.mut != ast::imm { ret false; }\n+        if mt.mutbl != ast::m_imm { ret false; }\n         alt ty::get(mt.ty).struct {\n           ty::ty_str { ret true; }\n           _ { ret false; }"}, {"sha": "bf4113cf395128516cc08a3cce11a998c9e086ed", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -34,7 +34,7 @@ mod middle {\n     mod check_alt;\n     mod check_const;\n     mod lint;\n-    mod mut;\n+    mod mutbl;\n     mod alias;\n     mod last_use;\n     mod block_use;"}, {"sha": "3a365e58bbda34d00bdb03b430321164a6335249", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -121,7 +121,7 @@ enum pat_ {\n     pat_range(@expr, @expr),\n }\n \n-enum mutability { mut, imm, maybe_mut, }\n+enum mutability { m_mutbl, m_imm, m_const, }\n \n enum proto {\n     proto_bare,    // native fn\n@@ -173,7 +173,7 @@ enum inferable<T> {\n }\n \n // \"resolved\" mode: the real modes.\n-enum rmode { by_ref, by_val, by_mut_ref, by_move, by_copy }\n+enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n // inferable mode.\n type mode = inferable<rmode>;\n@@ -205,7 +205,7 @@ enum decl_ { decl_local([@local]), decl_item(@item), }\n \n type arm = {pats: [@pat], guard: option<@expr>, body: blk};\n \n-type field_ = {mut: mutability, ident: ident, expr: @expr};\n+type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n@@ -316,7 +316,7 @@ enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-type mt = {ty: @ty, mut: mutability};\n+type mt = {ty: @ty, mutbl: mutability};\n \n type ty_field_ = {ident: ident, mt: mt};\n "}, {"sha": "cd508aae90b63c476797cb18b147160f64b497f2", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -66,8 +66,8 @@ pure fn lazy_binop(b: binop) -> bool {\n \n fn unop_to_str(op: unop) -> str {\n     alt op {\n-      box(mt) { if mt == mut { ret \"@mutable \"; } ret \"@\"; }\n-      uniq(mt) { if mt == mut { ret \"~mutable \"; } ret \"~\"; }\n+      box(mt) { if mt == m_mutbl { ret \"@mut \"; } ret \"@\"; }\n+      uniq(mt) { if mt == m_mutbl { ret \"~mut \"; } ret \"~\"; }\n       deref { ret \"*\"; }\n       not { ret \"!\"; }\n       neg { ret \"-\"; }"}, {"sha": "5d615c4305d4d85db276a3c5303bdfd9b187ef31", "filename": "src/comp/syntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbuild.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -61,7 +61,7 @@ fn mk_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident],\n // e = expr, t = type\n fn mk_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n    @ast::expr {\n-    let vecexpr = ast::expr_vec(exprs, ast::imm);\n+    let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     ret @{id: cx.next_id(), node: vecexpr, span: sp};\n }\n fn mk_rec_e(cx: ext_ctxt, sp: span,\n@@ -72,7 +72,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n         let ident = field.ident;\n         let val = field.ex;\n         let astfield =\n-            {node: {mut: ast::imm, ident: ident, expr: val}, span: sp};\n+            {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n         astfields += [astfield];\n     }\n     let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);"}, {"sha": "6d2a9e04d7272f332f5163543cacf87dff2c8acb", "filename": "src/comp/syntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -231,7 +231,7 @@ fn finish<T: qq_helper>\n                                 [mk_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n                                  mk_uint(cx,sp, loc.col)]),\n-                        mk_unary(cx,sp, ast::box(ast::imm),\n+                        mk_unary(cx,sp, ast::box(ast::m_imm),\n                                  mk_str(cx,sp, str2)),\n                         mk_access_(cx,sp,\n                                    mk_access_(cx,sp, session_call(), \"opts\"),"}, {"sha": "b8f9dd2c140176537d9b16b8ab9525bbc3a83ad0", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -682,7 +682,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n-          expr_vec(elts, mut) {\n+          expr_vec(elts, mutbl) {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n                               \"extension clause must consist of [\" +"}, {"sha": "d161d27c02025180e9b9e1135382e65692d3f140", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -337,7 +337,7 @@ fn wrap<T>(f: fn@(T, ast_fold) -> T)\n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n         ret {node:\n-                 {mut: field.node.mut,\n+                 {mutbl: field.node.mutbl,\n                   ident: fld.fold_ident(field.node.ident),\n                   expr: fld.fold_expr(field.node.expr)},\n              span: field.span};\n@@ -434,7 +434,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n     let fold_mac = bind fold_mac_(_, fld);\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n-        {ty: fld.fold_ty(mt.ty), mut: mt.mut}\n+        {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n     }\n     fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n         {node: {ident: fld.fold_ident(f.node.ident),"}, {"sha": "1e21dff0b34351b25330f307476e7006eaedf61e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -150,7 +150,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\", \"impl\",\n                  \"import\", \"let\", \"log\", \"mod\", \"mutable\", \"native\", \"pure\",\n                  \"resource\", \"ret\", \"trait\", \"type\", \"unchecked\", \"unsafe\",\n-                 \"while, crust\"] {\n+                 \"while\", \"crust\", \"mut\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -293,18 +293,18 @@ fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n }\n \n fn parse_mt(p: parser) -> ast::mt {\n-    let mut = parse_mutability(p);\n+    let mutbl = parse_mutability(p);\n     let t = parse_ty(p, false);\n-    ret {ty: t, mut: mut};\n+    ret {ty: t, mutbl: mutbl};\n }\n \n fn parse_ty_field(p: parser) -> ast::ty_field {\n     let lo = p.span.lo;\n-    let mut = parse_mutability(p);\n+    let mutbl = parse_mutability(p);\n     let id = parse_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n-    ret spanned(lo, ty.span.hi, {ident: id, mt: {ty: ty, mut: mut}});\n+    ret spanned(lo, ty.span.hi, {ident: id, mt: {ty: ty, mutbl: mutbl}});\n }\n \n // if i is the jth ident in args, return j\n@@ -486,7 +486,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n \n fn parse_arg_mode(p: parser) -> ast::mode {\n     if eat(p, token::BINOP(token::AND)) {\n-        ast::expl(ast::by_mut_ref)\n+        ast::expl(ast::by_mutbl_ref)\n     } else if eat(p, token::BINOP(token::MINUS)) {\n         ast::expl(ast::by_move)\n     } else if eat(p, token::ANDAND) {\n@@ -693,11 +693,13 @@ fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n \n fn parse_mutability(p: parser) -> ast::mutability {\n     if eat_word(p, \"mutable\") {\n-        ast::mut\n+        ast::m_mutbl\n+    } else if eat_word(p, \"mut\") {\n+        ast::m_mutbl\n     } else if eat_word(p, \"const\") {\n-        ast::maybe_mut\n+        ast::m_const\n     } else {\n-        ast::imm\n+        ast::m_imm\n     }\n }\n \n@@ -707,7 +709,7 @@ fn parse_field(p: parser, sep: token::token) -> ast::field {\n     let i = parse_ident(p);\n     expect(p, sep);\n     let e = parse_expr(p);\n-    ret spanned(lo, e.span.hi, {mut: m, ident: i, expr: e});\n+    ret spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n }\n \n fn mk_expr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> @ast::expr {\n@@ -786,7 +788,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret mk_pexpr(p, lo, hi, ast::expr_tup(es));\n     } else if p.token == token::LBRACE {\n         p.bump();\n-        if is_word(p, \"mutable\") ||\n+        if is_word(p, \"mut\") || is_word(p, \"mutable\") ||\n                is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n             let fields = [parse_field(p, token::COLON)];\n             let base = none;\n@@ -832,11 +834,11 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret pexpr(parse_block_expr(p, lo, ast::unsafe_blk));\n     } else if p.token == token::LBRACKET {\n         p.bump();\n-        let mut = parse_mutability(p);\n+        let mutbl = parse_mutability(p);\n         let es =\n             parse_seq_to_end(token::RBRACKET, seq_sep(token::COMMA),\n                              parse_expr, p);\n-        ex = ast::expr_vec(es, mut);\n+        ex = ast::expr_vec(es, mutbl);\n     } else if p.token == token::POUND_LT {\n         p.bump();\n         let ty = parse_ty(p, false);\n@@ -971,7 +973,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n             };\n         let hi = es.span.hi;\n         e = some(mk_expr(p, es.span.lo, hi,\n-                         ast::expr_vec(es.node, ast::imm)));\n+                         ast::expr_vec(es.node, ast::m_imm)));\n     }\n     let b = none;\n     if p.token == token::LBRACE {\n@@ -1578,6 +1580,9 @@ fn parse_local(p: parser, allow_init: bool) -> @ast::local {\n }\n \n fn parse_let(p: parser) -> @ast::decl {\n+    if eat_word(p, \"mut\") {\n+        /* TODO */\n+    }\n     let lo = p.span.lo;\n     let locals = [parse_local(p, true)];\n     while eat(p, token::COMMA) {\n@@ -1587,18 +1592,18 @@ fn parse_let(p: parser) -> @ast::decl {\n }\n \n fn parse_instance_var(p:parser) -> ast::class_member {\n-    let is_mut = ast::class_immutable;\n+    let is_mutbl = ast::class_immutable;\n     expect_word(p, \"let\");\n-    if eat_word(p, \"mutable\") {\n-            is_mut = ast::class_mutable;\n+    if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n+            is_mutbl = ast::class_mutable;\n     }\n     if !is_plain_ident(p) {\n         p.fatal(\"expecting ident\");\n     }\n     let name = parse_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n-    ret ast::instance_var(name, ty, is_mut, p.get_id());\n+    ret ast::instance_var(name, ty, is_mutbl, p.get_id());\n }\n \n fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {"}, {"sha": "343b4500a3d922164a472e424ff25aee40ebeb0e", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -318,10 +318,10 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       ast::ty_uniq(mt) { word(s.s, \"~\"); print_mt(s, mt); }\n       ast::ty_vec(mt) {\n         word(s.s, \"[\");\n-        alt mt.mut {\n-          ast::mut { word_space(s, \"mutable\"); }\n-          ast::maybe_mut { word_space(s, \"const\"); }\n-          ast::imm { }\n+        alt mt.mutbl {\n+          ast::m_mutbl { word_space(s, \"mut\"); }\n+          ast::m_const { word_space(s, \"const\"); }\n+          ast::m_imm { }\n         }\n         print_type(s, mt.ty);\n         word(s.s, \"]\");\n@@ -331,7 +331,7 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         word(s.s, \"{\");\n         fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n-            print_mutability(s, f.node.mt.mut);\n+            print_mutability(s, f.node.mt.mutbl);\n             word(s.s, f.node.ident);\n             word_space(s, \":\");\n             print_type(s, f.node.mt.ty);\n@@ -785,10 +785,10 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     let ann_node = node_expr(s, expr);\n     s.ann.pre(ann_node);\n     alt expr.node {\n-      ast::expr_vec(exprs, mut) {\n+      ast::expr_vec(exprs, mutbl) {\n         ibox(s, indent_unit);\n         word(s.s, \"[\");\n-        if mut == ast::mut {\n+        if mutbl == ast::m_mutbl {\n             word(s.s, \"mutable\");\n             if vec::len(exprs) > 0u { nbsp(s); }\n         }\n@@ -799,7 +799,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_rec(fields, wth) {\n         fn print_field(s: ps, field: ast::field) {\n             ibox(s, indent_unit);\n-            if field.node.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n+            if field.node.mutbl == ast::m_mutbl { word_nbsp(s, \"mutable\"); }\n             word(s.s, field.node.ident);\n             word_space(s, \":\");\n             print_expr(s, field.node.expr);\n@@ -1274,7 +1274,7 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n \n fn mode_to_str(m: ast::mode) -> str {\n     alt m {\n-      ast::expl(ast::by_mut_ref) { \"&\" }\n+      ast::expl(ast::by_mutbl_ref) { \"&\" }\n       ast::expl(ast::by_move) { \"-\" }\n       ast::expl(ast::by_ref) { \"&&\" }\n       ast::expl(ast::by_val) { \"++\" }\n@@ -1436,16 +1436,16 @@ fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: int) {\n     if add_them { pclose(s); }\n }\n \n-fn print_mutability(s: ps, mut: ast::mutability) {\n-    alt mut {\n-      ast::mut { word_nbsp(s, \"mutable\"); }\n-      ast::maybe_mut { word_nbsp(s, \"const\"); }\n-      ast::imm {/* nothing */ }\n+fn print_mutability(s: ps, mutbl: ast::mutability) {\n+    alt mutbl {\n+      ast::m_mutbl { word_nbsp(s, \"mutable\"); }\n+      ast::m_const { word_nbsp(s, \"const\"); }\n+      ast::m_imm {/* nothing */ }\n     }\n }\n \n fn print_mt(s: ps, mt: ast::mt) {\n-    print_mutability(s, mt.mut);\n+    print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n "}, {"sha": "2d253a1c3a928270e86068ba015a06d6c0c4b83e", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -53,12 +53,11 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n     fn mt_to_str(cx: ctxt, m: mt) -> str {\n-        let mstr;\n-        alt m.mut {\n-          ast::mut { mstr = \"mutable \"; }\n-          ast::imm { mstr = \"\"; }\n-          ast::maybe_mut { mstr = \"const \"; }\n-        }\n+        let mstr = alt m.mutbl {\n+          ast::m_mutbl { \"mut \" }\n+          ast::m_imm { \"\" }\n+          ast::m_const { \"const \" }\n+        };\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n     fn parameterized(cx: ctxt, base: str, tps: [ty::t]) -> str {"}, {"sha": "b0a47e4051b3dac3dd3f69ccd4841531e2614a7e", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=bfff2a8d55f8d96df77c7e496dc7713fe7faf5f9", "patch": "@@ -50,8 +50,10 @@ fn common_exprs() -> [ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::imm), @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(ast::uniq(ast::imm), @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+     dse(ast::expr_unary(ast::box(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n "}]}