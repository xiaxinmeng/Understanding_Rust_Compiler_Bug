{"sha": "68228be56062eb62f09088663e93ea66109156f8", "node_id": "C_kwDOAAsO6NoAKDY4MjI4YmU1NjA2MmViNjJmMDkwODg2NjNlOTNlYTY2MTA5MTU2Zjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-29T12:29:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-29T12:29:37Z"}, "message": "Rollup merge of #98625 - RalfJung:retag, r=oli-obk\n\nemit Retag for compound types with reference fields\n\nI want to add an option to Miri to do retagging inside reference fields. But that means we first have to even emit `Retag` for types that *contain* references (rather than being of reference types). :)\n\nStacked Borrows originally did that, but we stopped doing it when hitting bunch of issues in the standard library. However I have since realized that we actually do emit `noalias` for newtypes references, which means for soundness we should recurse into fields. Also it'd probably be bad news if newtypes lose out on optimizations (and they don't, for anything else). I want to add an option for that to Miri so that we can start experimenting with those semantics.\n\nr? ``@oli-obk``", "tree": {"sha": "17006f074d35aff9787abc12ac80094d53a436b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17006f074d35aff9787abc12ac80094d53a436b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68228be56062eb62f09088663e93ea66109156f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJivEWxCRBK7hj4Ov3rIwAAklUIAEkjSnpO0qqwFwZMjG1ijOva\nsMWp5RoyGEXwFvQdjWmr2z8FzZz5J2zGvK4yCAh8uy69cCIJ4pYRl6bsqjbRxBYA\nhPN2yNBjYc5hEM5k6fwijQ9ikJbm1Vugyw4daUHkDm2QONL8LuFAWyNJO/++d27q\nJCgxOCr1Ku3x3dE5Hq4YdJKYPEbGPpKmr3Zw6tAa55sOmQfxbh5HCuLPB5UUOLam\nqTgF1/7BCjZ48JeMWkVVCvSItYVvrIfN+GCmAgoOE5aT/9pppMgbtgNb+9rtQJnV\n5YtbOZ3Pwxp35H0+tETLpq7bjwt2bxqjcwR8NZFAW+EfgB/NkYKMQNciWNZe/DI=\n=jmQV\n-----END PGP SIGNATURE-----\n", "payload": "tree 17006f074d35aff9787abc12ac80094d53a436b2\nparent fcbb2e8009e440987060bb6c669d052326416c28\nparent 5fc1dd11a93b57d795e352e6c8718d5ffbb74dbb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656505777 +0530\ncommitter GitHub <noreply@github.com> 1656505777 +0530\n\nRollup merge of #98625 - RalfJung:retag, r=oli-obk\n\nemit Retag for compound types with reference fields\n\nI want to add an option to Miri to do retagging inside reference fields. But that means we first have to even emit `Retag` for types that *contain* references (rather than being of reference types). :)\n\nStacked Borrows originally did that, but we stopped doing it when hitting bunch of issues in the standard library. However I have since realized that we actually do emit `noalias` for newtypes references, which means for soundness we should recurse into fields. Also it'd probably be bad news if newtypes lose out on optimizations (and they don't, for anything else). I want to add an option for that to Miri so that we can start experimenting with those semantics.\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68228be56062eb62f09088663e93ea66109156f8", "html_url": "https://github.com/rust-lang/rust/commit/68228be56062eb62f09088663e93ea66109156f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68228be56062eb62f09088663e93ea66109156f8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcbb2e8009e440987060bb6c669d052326416c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbb2e8009e440987060bb6c669d052326416c28", "html_url": "https://github.com/rust-lang/rust/commit/fcbb2e8009e440987060bb6c669d052326416c28"}, {"sha": "5fc1dd11a93b57d795e352e6c8718d5ffbb74dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc1dd11a93b57d795e352e6c8718d5ffbb74dbb", "html_url": "https://github.com/rust-lang/rust/commit/5fc1dd11a93b57d795e352e6c8718d5ffbb74dbb"}], "stats": {"total": 25, "additions": 20, "deletions": 5}, "files": [{"sha": "0f87e638d2618e2ea92aa756008ed40f0a230c03", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68228be56062eb62f09088663e93ea66109156f8/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68228be56062eb62f09088663e93ea66109156f8/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=68228be56062eb62f09088663e93ea66109156f8", "patch": "@@ -33,8 +33,9 @@ fn is_stable(place: PlaceRef<'_>) -> bool {\n     })\n }\n \n-/// Determine whether this type may be a reference (or box), and thus needs retagging.\n-fn may_be_reference(ty: Ty<'_>) -> bool {\n+/// Determine whether this type may contain a reference (or box), and thus needs retagging.\n+/// We will only recurse `depth` times into Tuples/ADTs to bound the cost of this.\n+fn may_contain_reference<'tcx>(ty: Ty<'tcx>, depth: u32, tcx: TyCtxt<'tcx>) -> bool {\n     match ty.kind() {\n         // Primitive types that are not references\n         ty::Bool\n@@ -50,8 +51,20 @@ fn may_be_reference(ty: Ty<'_>) -> bool {\n         // References\n         ty::Ref(..) => true,\n         ty::Adt(..) if ty.is_box() => true,\n-        // Compound types are not references\n-        ty::Array(..) | ty::Slice(..) | ty::Tuple(..) | ty::Adt(..) => false,\n+        // Compound types: recurse\n+        ty::Array(ty, _) | ty::Slice(ty) => {\n+            // This does not branch so we keep the depth the same.\n+            may_contain_reference(*ty, depth, tcx)\n+        }\n+        ty::Tuple(tys) => {\n+            depth == 0 || tys.iter().any(|ty| may_contain_reference(ty, depth - 1, tcx))\n+        }\n+        ty::Adt(adt, subst) => {\n+            depth == 0\n+                || adt.variants().iter().any(|v| {\n+                    v.fields.iter().any(|f| may_contain_reference(f.ty(tcx, subst), depth - 1, tcx))\n+                })\n+        }\n         // Conservative fallback\n         _ => true,\n     }\n@@ -83,7 +96,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n             is_stable(place.as_ref())\n-                && may_be_reference(place.ty(&*local_decls, tcx).ty)\n+                && may_contain_reference(place.ty(&*local_decls, tcx).ty, /*depth*/ 3, tcx)\n                 && is_not_temp(&local_decls[place.local])\n         };\n         let place_base_raw = |place: &Place<'tcx>| {"}, {"sha": "c8c45da19137fb20ee213f7815402a6e3ad7a567", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68228be56062eb62f09088663e93ea66109156f8/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/68228be56062eb62f09088663e93ea66109156f8/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=68228be56062eb62f09088663e93ea66109156f8", "patch": "@@ -129,6 +129,7 @@ fn array_casts() -> () {\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _13 = (move _14, move _18);      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Retag(_13);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_14);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_20);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -171,6 +172,7 @@ fn array_casts() -> () {\n         Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _34 = Option::<Arguments>::None; // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        Retag(_34);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _28 = core::panicking::assert_failed::<usize, usize>(move _29, move _30, move _32, move _34); // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL"}]}