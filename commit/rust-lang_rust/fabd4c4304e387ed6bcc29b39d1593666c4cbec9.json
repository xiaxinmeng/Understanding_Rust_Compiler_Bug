{"sha": "fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYmQ0YzQzMDRlMzg3ZWQ2YmNjMjliMzlkMTU5MzY2NmM0Y2JlYzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T17:57:33Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T17:57:33Z"}, "message": "Merge #1556\n\n1556: sane indexing in text r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b18a0be7255bb070dd7e2ae3b5687bc5f35f0d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b18a0be7255bb070dd7e2ae3b5687bc5f35f0d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "html_url": "https://github.com/rust-lang/rust/commit/fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "d4ffbf2ae092b313b3c750adad398f3aa6fb209b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ffbf2ae092b313b3c750adad398f3aa6fb209b", "html_url": "https://github.com/rust-lang/rust/commit/d4ffbf2ae092b313b3c750adad398f3aa6fb209b"}, {"sha": "002529937075bd69d7f71483d798d6e4f43d1de9", "url": "https://api.github.com/repos/rust-lang/rust/commits/002529937075bd69d7f71483d798d6e4f43d1de9", "html_url": "https://github.com/rust-lang/rust/commit/002529937075bd69d7f71483d798d6e4f43d1de9"}], "stats": {"total": 140, "additions": 91, "deletions": 49}, "files": [{"sha": "5657ee4b8743305cb1c2d284df762fbd87d7e627", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "patch": "@@ -36,11 +36,10 @@ pub(crate) fn remove_dbg(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist>\n \n     let macro_content = {\n         let macro_args = macro_call.token_tree()?.syntax().clone();\n-        let range = macro_args.range();\n-        let start = range.start() + TextUnit::of_char('(');\n-        let end = range.end() - TextUnit::of_char(')');\n \n-        macro_args.text().slice(start..end).to_string()\n+        let text = macro_args.text();\n+        let without_parens = TextUnit::of_char('(')..text.len() - TextUnit::of_char(')');\n+        text.slice(without_parens).to_string()\n     };\n \n     ctx.add_action(AssistId(\"remove_dbg\"), \"remove dbg!()\", |edit| {"}, {"sha": "ec756f2c36f386cd2611405d032f09c7ed82e607", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "patch": "@@ -362,7 +362,16 @@ impl MacroCallId {\n     pub fn debug_dump(self, db: &impl AstDatabase) -> String {\n         let loc = self.loc(db);\n         let node = loc.ast_id.to_node(db);\n-        let syntax_str = node.syntax().text().chunks().collect::<Vec<_>>().join(\" \");\n+        let syntax_str = {\n+            let mut res = String::new();\n+            node.syntax().text().for_each_chunk(|chunk| {\n+                if !res.is_empty() {\n+                    res.push(' ')\n+                }\n+                res.push_str(chunk)\n+            });\n+            res\n+        };\n \n         // dump the file name\n         let file_id: HirFileId = self.loc(db).ast_id.file_id();"}, {"sha": "0b1a8b6e6f075a96f0f2bf0363ac5c383e8de78c", "filename": "crates/ra_ide_api/src/display/structure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs?ref=fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "patch": "@@ -83,20 +83,20 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn collapse_ws(node: &SyntaxNode, output: &mut String) {\n         let mut can_insert_ws = false;\n-        for chunk in node.text().chunks() {\n+        node.text().for_each_chunk(|chunk| {\n             for line in chunk.lines() {\n                 let line = line.trim();\n                 if line.is_empty() {\n                     if can_insert_ws {\n-                        output.push_str(\" \");\n+                        output.push(' ');\n                         can_insert_ws = false;\n                     }\n                 } else {\n                     output.push_str(line);\n                     can_insert_ws = true;\n                 }\n             }\n-        }\n+        })\n     }\n \n     visitor()"}, {"sha": "8fe9e5b4e14d80eb0b812e4507f70098819c7eb9", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "patch": "@@ -297,7 +297,6 @@ fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct SyntaxToken(pub(crate) rowan::cursor::SyntaxToken);\n \n-//FIXME: always output text\n impl fmt::Debug for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;"}, {"sha": "d8adf782b37d6ce0b1052f79377b658940985dd0", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabd4c4304e387ed6bcc29b39d1593666c4cbec9/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=fabd4c4304e387ed6bcc29b39d1593666c4cbec9", "patch": "@@ -16,26 +16,48 @@ impl<'a> SyntaxText<'a> {\n         SyntaxText { node, range: node.range() }\n     }\n \n-    pub fn chunks(&self) -> impl Iterator<Item = SmolStr> {\n-        let range = self.range;\n-        self.node.descendants_with_tokens().filter_map(move |el| match el {\n-            SyntaxElement::Token(t) => {\n-                let text = t.text();\n-                let range = range.intersection(&t.range())?;\n-                let res = if range == t.range() {\n-                    t.text().clone()\n-                } else {\n-                    let range = range - t.range().start();\n-                    text[range].into()\n-                };\n-                Some(res)\n-            }\n-            SyntaxElement::Node(_) => None,\n+    pub fn try_fold_chunks<T, F, E>(&self, init: T, mut f: F) -> Result<T, E>\n+    where\n+        F: FnMut(T, &str) -> Result<T, E>,\n+    {\n+        self.node.descendants_with_tokens().try_fold(init, move |acc, element| {\n+            let res = match element {\n+                SyntaxElement::Token(token) => {\n+                    let range = match self.range.intersection(&token.range()) {\n+                        None => return Ok(acc),\n+                        Some(it) => it,\n+                    };\n+                    let slice = if range == token.range() {\n+                        token.text()\n+                    } else {\n+                        let range = range - token.range().start();\n+                        &token.text()[range]\n+                    };\n+                    f(acc, slice)?\n+                }\n+                SyntaxElement::Node(_) => acc,\n+            };\n+            Ok(res)\n         })\n     }\n \n+    pub fn try_for_each_chunk<F: FnMut(&str) -> Result<(), E>, E>(\n+        &self,\n+        mut f: F,\n+    ) -> Result<(), E> {\n+        self.try_fold_chunks((), move |(), chunk| f(chunk))\n+    }\n+\n+    pub fn for_each_chunk<F: FnMut(&str)>(&self, mut f: F) {\n+        enum Void {}\n+        match self.try_for_each_chunk(|chunk| Ok::<(), Void>(f(chunk))) {\n+            Ok(()) => (),\n+            Err(void) => match void {},\n+        }\n+    }\n+\n     pub fn push_to(&self, buf: &mut String) {\n-        self.chunks().for_each(|it| buf.push_str(it.as_str()));\n+        self.for_each_chunk(|chunk| buf.push_str(chunk))\n     }\n \n     pub fn to_string(&self) -> String {\n@@ -49,19 +71,20 @@ impl<'a> SyntaxText<'a> {\n     }\n \n     pub fn contains(&self, c: char) -> bool {\n-        self.chunks().any(|it| it.contains(c))\n+        self.try_for_each_chunk(|chunk| if chunk.contains(c) { Err(()) } else { Ok(()) }).is_err()\n     }\n \n     pub fn find(&self, c: char) -> Option<TextUnit> {\n         let mut acc: TextUnit = 0.into();\n-        for chunk in self.chunks() {\n+        let res = self.try_for_each_chunk(|chunk| {\n             if let Some(pos) = chunk.find(c) {\n                 let pos: TextUnit = (pos as u32).into();\n-                return Some(acc + pos);\n+                return Err(acc + pos);\n             }\n-            acc += TextUnit::of_str(chunk.as_str());\n-        }\n-        None\n+            acc += TextUnit::of_str(chunk);\n+            Ok(())\n+        });\n+        found(res)\n     }\n \n     pub fn len(&self) -> TextUnit {\n@@ -72,18 +95,21 @@ impl<'a> SyntaxText<'a> {\n         self.range.is_empty()\n     }\n \n-    /// NB, the offsets here are absolute, and this probably doesn't make sense!\n     pub fn slice(&self, range: impl ops::RangeBounds<TextUnit>) -> SyntaxText<'a> {\n         let start = match range.start_bound() {\n-            Bound::Included(b) => *b,\n-            Bound::Excluded(b) => *b + TextUnit::from(1u32),\n-            Bound::Unbounded => self.range.start(),\n+            Bound::Included(&b) => b,\n+            Bound::Excluded(_) => panic!(\"utf-aware slicing can't work this way\"),\n+            Bound::Unbounded => 0.into(),\n         };\n         let end = match range.end_bound() {\n-            Bound::Included(b) => *b + TextUnit::from(1u32),\n-            Bound::Excluded(b) => *b,\n-            Bound::Unbounded => self.range.end(),\n+            Bound::Included(_) => panic!(\"utf-aware slicing can't work this way\"),\n+            Bound::Excluded(&b) => b,\n+            Bound::Unbounded => self.len(),\n         };\n+        assert!(start <= end);\n+        let len = end - start;\n+        let start = self.range.start() + start;\n+        let end = start + len;\n         assert!(\n             start <= end,\n             \"invalid slice, range: {:?}, slice: {:?}\",\n@@ -101,17 +127,25 @@ impl<'a> SyntaxText<'a> {\n     }\n \n     pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n-        let mut start: TextUnit = 0.into();\n         let offset = offset.into();\n-        for chunk in self.chunks() {\n-            let end = start + TextUnit::of_str(chunk.as_str());\n+        let mut start: TextUnit = 0.into();\n+        let res = self.try_for_each_chunk(|chunk| {\n+            let end = start + TextUnit::of_str(chunk);\n             if start <= offset && offset < end {\n                 let off: usize = u32::from(offset - start) as usize;\n-                return Some(chunk[off..].chars().next().unwrap());\n+                return Err(chunk[off..].chars().next().unwrap());\n             }\n             start = end;\n-        }\n-        None\n+            Ok(())\n+        });\n+        found(res)\n+    }\n+}\n+\n+fn found<T>(res: Result<(), T>) -> Option<T> {\n+    match res {\n+        Ok(()) => None,\n+        Err(it) => Some(it),\n     }\n }\n \n@@ -135,13 +169,14 @@ impl From<SyntaxText<'_>> for String {\n \n impl PartialEq<str> for SyntaxText<'_> {\n     fn eq(&self, mut rhs: &str) -> bool {\n-        for chunk in self.chunks() {\n-            if !rhs.starts_with(chunk.as_str()) {\n-                return false;\n+        self.try_for_each_chunk(|chunk| {\n+            if !rhs.starts_with(chunk) {\n+                return Err(());\n             }\n             rhs = &rhs[chunk.len()..];\n-        }\n-        rhs.is_empty()\n+            Ok(())\n+        })\n+        .is_ok()\n     }\n }\n "}]}