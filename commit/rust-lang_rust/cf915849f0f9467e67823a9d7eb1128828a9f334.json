{"sha": "cf915849f0f9467e67823a9d7eb1128828a9f334", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOTE1ODQ5ZjBmOTQ2N2U2NzgyM2E5ZDdlYjExMjg4MjhhOWYzMzQ=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-08-19T02:40:50Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-09-25T02:05:55Z"}, "message": "Lower `impl Trait` types in locals.", "tree": {"sha": "49a1480260cd77563151b9767a846ae257642c85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49a1480260cd77563151b9767a846ae257642c85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf915849f0f9467e67823a9d7eb1128828a9f334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf915849f0f9467e67823a9d7eb1128828a9f334", "html_url": "https://github.com/rust-lang/rust/commit/cf915849f0f9467e67823a9d7eb1128828a9f334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf915849f0f9467e67823a9d7eb1128828a9f334/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c875d93855c6d577962b0f74f17374f37b219c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c875d93855c6d577962b0f74f17374f37b219c9", "html_url": "https://github.com/rust-lang/rust/commit/5c875d93855c6d577962b0f74f17374f37b219c9"}], "stats": {"total": 438, "additions": 262, "deletions": 176}, "files": [{"sha": "c38b3510a0cc3032368a151b861dbca62aad84c2", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -1739,7 +1739,7 @@ specified exit code, use `std::process::exit`.\n \n E0562: r##\"\n Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function return types.\n+allowed as function and inherent impl return types or binding types.\n \n Erroneous code example:\n \n@@ -1754,7 +1754,8 @@ fn main() {\n }\n ```\n \n-Make sure `impl Trait` only appears in return-type position.\n+Make sure `impl Trait` only appears in return-type position or as the type of a\n+binding.\n \n ```\n fn count_to_n(n: usize) -> impl Iterator<Item=usize> {"}, {"sha": "bbad157091b973c6d1a85d8f0b547787784adf42", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -131,7 +131,6 @@ pub struct DefIndex(u32);\n /// thanks to `NodeCollector::new`.\n pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n-\n impl fmt::Debug for DefIndex {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,"}, {"sha": "275ca6e1694502ab58def0c198cb09647c675daf", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 187, "deletions": 114, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -139,6 +139,7 @@ pub struct LoweringContext<'a> {\n     type_def_lifetime_params: DefIdMap<usize>,\n \n     current_hir_id_owner: Vec<(DefIndex, u32)>,\n+    current_impl_trait_owner: Vec<DefId>,\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n }\n@@ -175,15 +176,17 @@ enum ImplTraitContext<'a> {\n     /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n-    /// Newly generated parameters should be inserted into the given `Vec`\n+    /// Newly generated parameters should be inserted into the given `Vec`.\n     Universal(&'a mut Vec<hir::GenericParam>),\n \n-    /// Treat `impl Trait` as shorthand for a new universal existential parameter.\n+    /// Treat `impl Trait` as shorthand for a new existential parameter.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n-    /// equivalent to a fresh existential parameter like `abstract type T; fn foo() -> T`.\n+    /// equivalent to a fresh existential parameter like `existential type T; fn foo() -> T`.\n     ///\n-    /// We store a DefId here so we can look up necessary information later\n-    Existential(DefId),\n+    /// We optionally store a `DefId` for the parent item here so we can look up necessary\n+    /// information later. It is `None` when no information about the context should be stored,\n+    /// e.g. for consts and statics.\n+    Existential(Option<DefId>),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed,\n@@ -230,6 +233,7 @@ pub fn lower_crate(\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: DefIdMap(),\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n+        current_impl_trait_owner: vec![],\n         item_local_id_counters: NodeMap(),\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n@@ -305,6 +309,35 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n+struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut OneVector<hir::ItemId> }\n+\n+impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n+    fn visit_ty(&mut self, ty: &'a Ty) {\n+        match ty.node {\n+            | TyKind::Typeof(_)\n+            | TyKind::BareFn(_)\n+            => return,\n+\n+            TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n+            _ => {},\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        path_segment: &'v PathSegment,\n+    ) {\n+        if let Some(ref p) = path_segment.args {\n+            if let GenericArgs::Parenthesized(_) = **p {\n+                return;\n+            }\n+        }\n+        visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -359,6 +392,17 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         impl<'lcx, 'interner> ItemLowerer<'lcx, 'interner> {\n+            fn with_impl_trait_owner<F, T>(&mut self, def_id: DefId, f: F) -> T\n+            where\n+                F: FnOnce(&mut Self) -> T,\n+            {\n+                self.lctx.current_impl_trait_owner.push(def_id);\n+                let ret = f(self);\n+                self.lctx.current_impl_trait_owner.pop();\n+\n+                ret\n+            }\n+\n             fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n             where\n                 F: FnOnce(&mut Self),\n@@ -396,7 +440,12 @@ impl<'a> LoweringContext<'a> {\n \n                     self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n                         let this = &mut ItemLowerer { lctx: this };\n-                        if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n+                        if let ItemKind::Fn(..) = item.node {\n+                            let fn_def_id = this.lctx.resolver.definitions().local_def_id(item.id);\n+                            this.with_impl_trait_owner(fn_def_id, |this| {\n+                                visit::walk_item(this, item)\n+                            });\n+                        } else if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n                             this.with_trait_impl_ref(opt_trait_ref, |this| {\n                                 visit::walk_item(this, item)\n                             });\n@@ -524,6 +573,17 @@ impl<'a> LoweringContext<'a> {\n         ret\n     }\n \n+    fn with_impl_trait_owner<F, T>(&mut self, def_id: DefId, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext) -> T,\n+    {\n+        self.current_impl_trait_owner.push(def_id);\n+        let ret = f(self);\n+        self.current_impl_trait_owner.pop();\n+\n+        ret\n+    }\n+\n     /// This method allocates a new HirId for the given NodeId and stores it in\n     /// the LoweringContext's NodeId => HirId map.\n     /// Take care not to call this method if the resulting HirId is then not\n@@ -955,13 +1015,13 @@ impl<'a> LoweringContext<'a> {\n \n         let catch_scopes = mem::replace(&mut self.catch_scopes, Vec::new());\n         let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n-        let result = f(self);\n+        let ret = f(self);\n         self.catch_scopes = catch_scopes;\n         self.loop_scopes = loop_scopes;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n-        result\n+        ret\n     }\n \n     fn def_key(&mut self, id: DefId) -> DefKey {\n@@ -1229,7 +1289,7 @@ impl<'a> LoweringContext<'a> {\n                             t.span,\n                             E0562,\n                             \"`impl Trait` not allowed outside of function \\\n-                             and inherent method return types\"\n+                             and inherent method return types or bindings\"\n                         );\n                         hir::TyKind::Err\n                     }\n@@ -1250,7 +1310,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_existential_impl_trait(\n         &mut self,\n         span: Span,\n-        fn_def_id: DefId,\n+        fn_def_id: Option<DefId>,\n         exist_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n@@ -1270,7 +1330,6 @@ impl<'a> LoweringContext<'a> {\n             .opt_def_index(exist_ty_node_id)\n             .unwrap();\n \n-\n         self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n \n         let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n@@ -1292,7 +1351,7 @@ impl<'a> LoweringContext<'a> {\n                     span,\n                 },\n                 bounds: hir_bounds,\n-                impl_trait_fn: Some(fn_def_id),\n+                impl_trait_fn: fn_def_id,\n             });\n             let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n             // Generate an `existential type Foo: Trait;` declaration\n@@ -1865,20 +1924,34 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n+    fn lower_local(&mut self, l: &Local) -> (P<hir::Local>, OneVector<hir::ItemId>) {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n-        P(hir::Local {\n+        let mut ids = OneVector::<hir::ItemId>::new();\n+        if self.sess.features_untracked().impl_trait_in_bindings {\n+            if let Some(ref ty) = l.ty {\n+                let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                visitor.visit_ty(ty);\n+            }\n+        }\n+        let impl_trait_owner_id = self.current_impl_trait_owner.last().map(|id| *id);\n+        (P(hir::Local {\n             id: node_id,\n             hir_id,\n             ty: l.ty\n                 .as_ref()\n-                .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed)),\n+                .map(|t| self.lower_ty(t,\n+                    if self.sess.features_untracked().impl_trait_in_bindings {\n+                        ImplTraitContext::Existential(impl_trait_owner_id)\n+                    } else {\n+                        ImplTraitContext::Disallowed\n+                    }\n+                )),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n             source: hir::LocalSource::Normal,\n-        })\n+        }), ids)\n     }\n \n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n@@ -1948,7 +2021,7 @@ impl<'a> LoweringContext<'a> {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n-                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(def_id)))\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(Some(def_id))))\n                     }\n                     _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },\n@@ -2131,10 +2204,10 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, fn_def_id, return_impl_trait_id, |this| {\n+            span, Some(fn_def_id), return_impl_trait_id, |this| {\n             let output_ty = match output {\n                 FunctionRetTy::Ty(ty) =>\n-                    this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n+                    this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id))),\n                 FunctionRetTy::Default(span) => {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n                     P(hir::Ty {\n@@ -2640,28 +2713,33 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                self.with_impl_trait_owner(fn_def_id, |this| {\n+                    this.with_new_scopes(|this| {\n+                        // Note: we don't need to change the return type from `T` to\n+                        // `impl Future<Output = T>` here because lower_body\n+                        // only cares about the input argument patterns in the function\n+                        // declaration (decl), not the return types.\n+                        let body_id = this.lower_async_body(decl, header.asyncness, body);\n+\n+                        let (generics, fn_decl) = this.add_in_band_defs(\n+                            generics,\n+                            fn_def_id,\n+                            AnonymousLifetimeMode::PassThrough,\n+                            |this, idty| this.lower_fn_decl(\n+                                decl,\n+                                Some((fn_def_id, idty)),\n+                                true,\n+                                header.asyncness.opt_return_id()\n+                            ),\n+                        );\n \n-                self.with_new_scopes(|this| {\n-                    // Note: we don't need to change the return type from `T` to\n-                    // `impl Future<Output = T>` here because lower_body\n-                    // only cares about the input argument patterns in the function\n-                    // declaration (decl), not the return types.\n-                    let body_id = this.lower_async_body(decl, header.asyncness, body);\n-\n-                    let (generics, fn_decl) = this.add_in_band_defs(\n-                        generics,\n-                        fn_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, idty| this.lower_fn_decl(\n-                            decl, Some((fn_def_id, idty)), true, header.asyncness.opt_return_id()),\n-                    );\n-\n-                    hir::ItemKind::Fn(\n-                        fn_decl,\n-                        this.lower_fn_header(header),\n-                        generics,\n-                        body_id,\n-                    )\n+                        hir::ItemKind::Fn(\n+                            fn_decl,\n+                            this.lower_fn_header(header),\n+                            generics,\n+                            body_id,\n+                        )\n+                    })\n                 })\n             }\n             ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n@@ -2980,31 +3058,33 @@ impl<'a> LoweringContext<'a> {\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    trait_item_def_id,\n-                    false,\n-                    None,\n-                );\n-                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n+                self.with_impl_trait_owner(trait_item_def_id, |this| {\n+                    let names = this.lower_fn_args_to_names(&sig.decl);\n+                    let (generics, sig) = this.lower_method_sig(\n+                        &i.generics,\n+                        sig,\n+                        trait_item_def_id,\n+                        false,\n+                        None,\n+                    );\n+                    (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n+                })\n             }\n             TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_body(Some(&sig.decl), |this| {\n-                    let body = this.lower_block(body, false);\n-                    this.expr_block(body, ThinVec::new())\n-                });\n-\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    trait_item_def_id,\n-                    false,\n-                    None,\n-                );\n-\n-                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n+                self.with_impl_trait_owner(trait_item_def_id, |this| {\n+                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    });\n+                    let (generics, sig) = this.lower_method_sig(\n+                        &i.generics,\n+                        sig,\n+                        trait_item_def_id,\n+                        false,\n+                        None,\n+                    );\n+                    (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n+                })\n             }\n             TraitItemKind::Type(ref bounds, ref default) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n@@ -3070,16 +3150,18 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness, body);\n-                let impl_trait_return_allow = !self.is_in_trait_impl;\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    impl_item_def_id,\n-                    impl_trait_return_allow,\n-                    sig.header.asyncness.opt_return_id(),\n-                );\n-                (generics, hir::ImplItemKind::Method(sig, body_id))\n+                self.with_impl_trait_owner(impl_item_def_id, |this| {\n+                    let body_id = this.lower_async_body(&sig.decl, sig.header.asyncness, body);\n+                    let impl_trait_return_allow = !this.is_in_trait_impl;\n+                    let (generics, sig) = this.lower_method_sig(\n+                        &i.generics,\n+                        sig,\n+                        impl_item_def_id,\n+                        impl_trait_return_allow,\n+                        sig.header.asyncness.opt_return_id(),\n+                    );\n+                    (generics, hir::ImplItemKind::Method(sig, body_id))\n+                })\n             }\n             ImplItemKind::Type(ref ty) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n@@ -3137,8 +3219,8 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    /// Lowers `impl Trait` items and appends them to the list\n-    fn lower_impl_trait_ids(\n+    /// Lowers `impl Trait` items for a function and appends them to the list\n+    fn lower_fn_impl_trait_ids(\n         &mut self,\n         decl: &FnDecl,\n         header: &FnHeader,\n@@ -3147,33 +3229,7 @@ impl<'a> LoweringContext<'a> {\n         if let Some(id) = header.asyncness.opt_return_id() {\n             ids.push(hir::ItemId { id });\n         }\n-        struct IdVisitor<'a> { ids: &'a mut OneVector<hir::ItemId> }\n-        impl<'a, 'b> Visitor<'a> for IdVisitor<'b> {\n-            fn visit_ty(&mut self, ty: &'a Ty) {\n-                match ty.node {\n-                    | TyKind::Typeof(_)\n-                    | TyKind::BareFn(_)\n-                    => return,\n-\n-                    TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n-                    _ => {},\n-                }\n-                visit::walk_ty(self, ty);\n-            }\n-            fn visit_path_segment(\n-                &mut self,\n-                path_span: Span,\n-                path_segment: &'v PathSegment,\n-            ) {\n-                if let Some(ref p) = path_segment.args {\n-                    if let GenericArgs::Parenthesized(_) = **p {\n-                        return;\n-                    }\n-                }\n-                visit::walk_path_segment(self, path_span, path_segment)\n-            }\n-        }\n-        let mut visitor = IdVisitor { ids };\n+        let mut visitor = ImplTraitTypeIdVisitor { ids };\n         match decl.output {\n             FunctionRetTy::Default(_) => {},\n             FunctionRetTy::Ty(ref ty) => visitor.visit_ty(ty),\n@@ -3190,14 +3246,14 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::MacroDef(..) => OneVector::new(),\n             ItemKind::Fn(ref decl, ref header, ..) => {\n                 let mut ids = smallvec![hir::ItemId { id: i.id }];\n-                self.lower_impl_trait_ids(decl, header, &mut ids);\n+                self.lower_fn_impl_trait_ids(decl, header, &mut ids);\n                 ids\n             },\n             ItemKind::Impl(.., None, _, ref items) => {\n                 let mut ids = smallvec![hir::ItemId { id: i.id }];\n                 for item in items {\n                     if let ImplItemKind::Method(ref sig, _) = item.node {\n-                        self.lower_impl_trait_ids(&sig.decl, &sig.header, &mut ids);\n+                        self.lower_fn_impl_trait_ids(&sig.decl, &sig.header, &mut ids);\n                     }\n                 }\n                 ids\n@@ -4312,15 +4368,32 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_stmt(&mut self, s: &Stmt) -> OneVector<hir::Stmt> {\n         smallvec![match s.node {\n-            StmtKind::Local(ref l) => Spanned {\n-                node: hir::StmtKind::Decl(\n-                    P(Spanned {\n-                        node: hir::DeclKind::Local(self.lower_local(l)),\n+            StmtKind::Local(ref l) => {\n+                let (l, item_ids) = self.lower_local(l);\n+                let mut ids: OneVector<hir::Stmt> = item_ids\n+                    .into_iter()\n+                    .map(|item_id| Spanned {\n+                        node: hir::StmtKind::Decl(\n+                            P(Spanned {\n+                                node: hir::DeclKind::Item(item_id),\n+                                span: s.span,\n+                            }),\n+                            self.next_id().node_id,\n+                        ),\n                         span: s.span,\n-                    }),\n-                    self.lower_node_id(s.id).node_id,\n-                ),\n-                span: s.span,\n+                    })\n+                    .collect();\n+                ids.push(Spanned {\n+                    node: hir::StmtKind::Decl(\n+                        P(Spanned {\n+                            node: hir::DeclKind::Local(l),\n+                            span: s.span,\n+                        }),\n+                        self.lower_node_id(s.id).node_id,\n+                    ),\n+                    span: s.span,\n+                });\n+                return ids;\n             },\n             StmtKind::Item(ref it) => {\n                 // Can only use the ID once.\n@@ -4334,8 +4407,8 @@ impl<'a> LoweringContext<'a> {\n                                 span: s.span,\n                             }),\n                             id.take()\n-                                .map(|id| self.lower_node_id(id).node_id)\n-                                .unwrap_or_else(|| self.next_id().node_id),\n+                              .map(|id| self.lower_node_id(id).node_id)\n+                              .unwrap_or_else(|| self.next_id().node_id),\n                         ),\n                         span: s.span,\n                     })"}, {"sha": "26cf8f5d2ae5c031c2670433375d450cb9f051a1", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -102,9 +102,9 @@ impl<'a> DefCollector<'a> {\n             visit::walk_fn_decl(this, decl);\n \n             let closure_def = this.create_def(closure_id,\n-                                  DefPathData::ClosureExpr,\n-                                  REGULAR_SPACE,\n-                                  span);\n+                                              DefPathData::ClosureExpr,\n+                                              REGULAR_SPACE,\n+                                              span);\n             this.with_parent(closure_def, |this| {\n                 visit::walk_block(this, body);\n             })"}, {"sha": "74ea393d64ad717f9b950db2355f179bb343bdc5", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -736,7 +736,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n                         debug!(\n                             \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside it's definition scope \\\n+                             encountered opaque outside its definition scope \\\n                              def_id={:?}\",\n                             def_id,\n                         );\n@@ -808,8 +808,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n-            // which will be the concrete type, instead of the Opaque.\n-            // This also instantiates nested `impl Trait`.\n+            // which will be the concrete type instead of the opaque type.\n+            // This also instantiates nested instances of `impl Trait`.\n             let predicate = self.instantiate_opaque_types_in_map(&predicate);\n \n             let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);"}, {"sha": "8e4819b68a95f6e1d3e07d531fff2364af15a222", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -79,8 +79,8 @@ impl BoundRegion {\n     }\n }\n \n-/// NB: If you change this, you'll probably want to change the corresponding\n-/// AST structure in libsyntax/ast.rs as well.\n+/// N.B., If you change this, you'll probably want to change the corresponding\n+/// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -158,7 +158,7 @@ pub enum TyKind<'tcx> {\n     Projection(ProjectionTy<'tcx>),\n \n     /// Opaque (`impl Trait`) type found in a return type.\n-    /// The DefId comes either from\n+    /// The `DefId` comes either from\n     /// * the `impl Trait` ast::Ty node,\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n@@ -168,7 +168,7 @@ pub enum TyKind<'tcx> {\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param(ParamTy),\n \n-    /// A type variable used during type-checking.\n+    /// A type variable used during type checking.\n     Infer(InferTy),\n \n     /// A placeholder for a type which could not be computed; this is"}, {"sha": "d3b215fa0704743574e28dca84a6b4ccee9d4608", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -14,7 +14,7 @@\n //! are supplied to us before normalization and may contain existential\n //! `impl Trait` instances. In contrast, the input/output types found in\n //! the MIR (specifically, in the special local variables for the\n-//! `RETURN_PLACE` the MIR arguments) are always fully normalize (and\n+//! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n use borrow_check::nll::renumber;"}, {"sha": "250db4d15e67540b9fa178a22a3f011eb511d707", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -98,7 +98,7 @@ mod relate_tys;\n ///   to outlive; should represent the fn body\n /// - `input_tys` -- fully liberated, but **not** normalized, expected types of the arguments;\n ///   the types of the input parameters found in the MIR itself will be equated with these\n-/// - `output_ty` -- fully liberaetd, but **not** normalized, expected return type;\n+/// - `output_ty` -- fully liberated, but **not** normalized, expected return type;\n ///   the type for the RETURN_PLACE will be equated with this\n /// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n ///   constraints for the regions in the types of variables"}, {"sha": "ac754f9af58fc348fb2d9085ae71179d94cd1600", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .pat_binding_modes_mut()\n                     .insert(pat.hir_id, bm);\n                 debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let typ = self.local_ty(pat.span, pat.id);\n+                let local_ty = self.local_ty(pat.span, pat.id).decl_ty;\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n                         // if the binding is like\n@@ -249,28 +249,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype(pat.span, region_ty, typ);\n+                        self.demand_eqtype(pat.span, region_ty, local_ty);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype(pat.span, expected, typ);\n+                        self.demand_eqtype(pat.span, expected, local_ty);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.id {\n-                    let vt = self.local_ty(pat.span, var_id);\n-                    self.demand_eqtype(pat.span, vt, typ);\n+                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n+                    self.demand_eqtype(pat.span, vt, local_ty);\n                 }\n \n                 if let Some(ref p) = *sub {\n                     self.check_pat_walk(&p, expected, def_bm, true);\n                 }\n \n-                typ\n+                local_ty\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n                 self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected, def_bm)"}, {"sha": "716dfce32fdcbf49ce71eaaecb42181a39341269", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -1039,8 +1039,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     }\n \n     /// Indicates that the value generated by `expression`, which is\n-    /// of type `expression_ty`, is one of the possibility that we\n-    /// could coerce from. This will record `expression` and later\n+    /// of type `expression_ty`, is one of the possibilities that we\n+    /// could coerce from. This will record `expression`, and later\n     /// calls to `coerce` may come back and add adjustments and things\n     /// if necessary.\n     pub fn coerce<'a>(&mut self,"}, {"sha": "d68899e216ce1cb29f2f2565cf2e9aa9497c4604", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -154,6 +154,13 @@ mod generator_interior;\n mod intrinsic;\n mod op;\n \n+/// The type of a local binding, including the revealed type for anon types.\n+#[derive(Copy, Clone)]\n+pub struct LocalTy<'tcx> {\n+    decl_ty: Ty<'tcx>,\n+    revealed_ty: Ty<'tcx>\n+}\n+\n /// A wrapper for InferCtxt's `in_progress_tables` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx: 'a> {\n@@ -180,7 +187,6 @@ impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n     }\n }\n \n-\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n@@ -195,7 +201,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     tables: MaybeInProgressTables<'a, 'tcx>,\n \n-    locals: RefCell<NodeMap<Ty<'tcx>>>,\n+    locals: RefCell<NodeMap<LocalTy<'tcx>>>,\n \n     fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n@@ -864,7 +870,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n             // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n+            GatherLocalsVisitor { fcx: &fcx, parent_id: id, }.visit_body(body);\n \n             fcx.check_expr_coercable_to_type(&body.value, expected_type);\n \n@@ -914,22 +920,26 @@ fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n }\n \n struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    parent_id: ast::NodeId,\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n-    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n                 let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-                self.fcx.locals.borrow_mut().insert(nid, var_ty);\n+                self.fcx.locals.borrow_mut().insert(nid, LocalTy {\n+                    decl_ty: var_ty,\n+                    revealed_ty: var_ty\n+                });\n                 var_ty\n             }\n             Some(typ) => {\n                 // take type that the user specified\n                 self.fcx.locals.borrow_mut().insert(nid, typ);\n-                typ\n+                typ.revealed_ty\n             }\n         }\n     }\n@@ -942,24 +952,28 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'gcx hir::Local) {\n-        let o_ty = match local.ty {\n+        let local_ty = match local.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n+                debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, 1);\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_response(&o_ty);\n-                debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n+                let revealed_ty = self.fcx.instantiate_opaque_types_from_value(\n+                    self.parent_id,\n+                    &o_ty);\n+\n+                let c_ty = self.fcx.inh.infcx.canonicalize_response(&revealed_ty);\n                 self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n \n-                Some(o_ty)\n+                Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             },\n             None => None,\n         };\n-        self.assign(local.span, local.id, o_ty);\n+        self.assign(local.span, local.id, local_ty);\n \n         debug!(\"Local variable {:?} is assigned type {}\",\n                local.pat,\n                self.fcx.ty_to_string(\n-                   self.fcx.locals.borrow().get(&local.id).unwrap().clone()));\n+                   self.fcx.locals.borrow().get(&local.id).unwrap().clone().decl_ty));\n         intravisit::walk_local(self, local);\n     }\n \n@@ -976,7 +990,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                    ident,\n                    self.fcx.ty_to_string(\n-                       self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n+                       self.fcx.locals.borrow().get(&p.id).unwrap().clone().decl_ty),\n                    var_ty);\n         }\n         intravisit::walk_pat(self, p);\n@@ -1027,7 +1041,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_return_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1045,7 +1059,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n+    GatherLocalsVisitor { fcx: &fcx, parent_id: fn_id, }.visit_body(body);\n \n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n@@ -2040,7 +2054,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         format!(\"{:?}\", self_ptr)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n         match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -2225,18 +2239,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Replace the opaque types from the return value of the\n-    /// function with type variables and records the `OpaqueTypeMap` for\n-    /// later use during writeback. See\n+    /// Replace the opaque types from the given value with type variables,\n+    /// and records the `OpaqueTypeMap` for later use during writeback. See\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n-    fn instantiate_opaque_types_from_return_value<T: TypeFoldable<'tcx>>(\n+    fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n         fn_id: ast::NodeId,\n         value: &T,\n     ) -> T {\n         let fn_def_id = self.tcx.hir.local_def_id(fn_id);\n         debug!(\n-            \"instantiate_opaque_types_from_return_value(fn_def_id={:?}, value={:?})\",\n+            \"instantiate_opaque_types_from_value(fn_def_id={:?}, value={:?})\",\n             fn_def_id,\n             value\n         );\n@@ -2889,7 +2902,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty,  AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -3048,7 +3061,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n-    fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n+    fn check_expr_with_hint(&self,\n+                            expr: &'gcx hir::Expr,\n                             expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n@@ -3197,7 +3211,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else(&self,\n@@ -3739,9 +3752,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(&self,\n-                                                   expr: &'gcx hir::Expr,\n-                                                   expected: Expectation<'tcx>,\n-                                                   needs: Needs) -> Ty<'tcx> {\n+                                             expr: &'gcx hir::Expr,\n+                                             expected: Expectation<'tcx>,\n+                                             needs: Needs) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n \n@@ -3827,8 +3840,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => Needs::None\n                 };\n                 let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                                    expected_inner,\n-                                                                                    needs);\n+                                                                             expected_inner,\n+                                                                             needs);\n \n                 if !oprnd_t.references_error() {\n                     oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n@@ -3858,8 +3871,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.write_method_call(expr.hir_id, method);\n                             } else {\n                                 type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n-                                                    \"type `{}` cannot be dereferenced\",\n-                                                    oprnd_t).emit();\n+                                                   \"type `{}` cannot be dereferenced\",\n+                                                   oprnd_t).emit();\n                                 oprnd_t = tcx.types.err;\n                             }\n                         }\n@@ -3923,6 +3936,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n+                debug!(\"path_foo: {:?} {:?}\", def, opt_ty);\n                 let ty = if def != Def::Err {\n                     self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0\n                 } else {\n@@ -4083,7 +4097,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                    expr.span, expected)\n+                                     expr.span, expected)\n             }\n             hir::ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n@@ -4471,7 +4485,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // See #44848.\n         let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n-        let local_ty = self.local_ty(init.span, local.id);\n+        let local_ty = self.local_ty(init.span, local.id).revealed_ty;\n         if let Some(m) = ref_bindings {\n             // Somewhat subtle: if we have a `ref` binding in the pattern,\n             // we want to avoid introducing coercions for the RHS. This is\n@@ -4490,7 +4504,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n-        let t = self.local_ty(local.span, local.id);\n+        let t = self.local_ty(local.span, local.id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n@@ -4827,7 +4841,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     /// A possible error is to forget to add a return type that is needed:\n     ///\n     /// ```\n@@ -5069,7 +5082,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let ty = self.local_ty(span, nid);\n+                let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n                 return (ty, def);"}, {"sha": "6595ce0facf696baf23005bbeabd7f5ef1613fdb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf915849f0f9467e67823a9d7eb1128828a9f334/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cf915849f0f9467e67823a9d7eb1128828a9f334", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// The Writerback context. This visitor walks the AST, checking the\n+// The Writeback context. This visitor walks the AST, checking the\n // fn-specific tables to find references to types or regions. It\n // resolves those regions to remove inference variables and writes the\n // final result back into the master tables in the tcx. Here and\n@@ -290,7 +290,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n-        let var_ty = self.fcx.local_ty(l.span, l.id);\n+        let var_ty = self.fcx.local_ty(l.span, l.id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }"}]}