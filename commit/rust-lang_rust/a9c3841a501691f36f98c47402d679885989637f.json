{"sha": "a9c3841a501691f36f98c47402d679885989637f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzM4NDFhNTAxNjkxZjM2Zjk4YzQ3NDAyZDY3OTg4NTk4OTYzN2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-01T01:58:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-01T11:13:06Z"}, "message": "Fix handling of `move` closures -- since they have one fewer deref, we weren't properly adjusting the closure kind in that case.", "tree": {"sha": "48791613ccf862feefb54a7a2c5e2a121904d949", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48791613ccf862feefb54a7a2c5e2a121904d949"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c3841a501691f36f98c47402d679885989637f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c3841a501691f36f98c47402d679885989637f", "html_url": "https://github.com/rust-lang/rust/commit/a9c3841a501691f36f98c47402d679885989637f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c3841a501691f36f98c47402d679885989637f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e778ea40701751ca15b19a8983949573ea9e3a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/e778ea40701751ca15b19a8983949573ea9e3a07", "html_url": "https://github.com/rust-lang/rust/commit/e778ea40701751ca15b19a8983949573ea9e3a07"}], "stats": {"total": 201, "additions": 167, "deletions": 34}, "files": [{"sha": "f7babadd41fd18ebcc56acbe396530d1e576172f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -263,16 +263,29 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         match guarantor.cat {\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(_, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n-                            setting upvar_id={:?} to by value\",\n-                           upvar_id);\n+                match cmt.note {\n+                    mc::NoteUpvarRef(upvar_id) => {\n+                        debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n+                                setting upvar_id={:?} to by value\",\n+                               upvar_id);\n \n-                    // to move out of an upvar, this must be a FnOnce closure\n-                    self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n+                        // to move out of an upvar, this must be a FnOnce closure\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n \n-                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                        upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                    }\n+                    mc::NoteClosureEnv(upvar_id) => {\n+                        // we get just a closureenv ref if this is a\n+                        // `move` closure, or if the upvar has already\n+                        // been inferred to by-value. In any case, we\n+                        // must still adjust the kind of the closure\n+                        // to be a FnOnce closure to permit moves out\n+                        // of the environment.\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n+                    }\n+                    mc::NoteNone => {\n+                    }\n                 }\n             }\n             _ => { }\n@@ -297,15 +310,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to mutable if necessary\n-                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    let ub = &mut upvar_capture_map[upvar_id];\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n-                } else {\n+                if !self.try_adjust_upvar_deref(&cmt.note, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n@@ -339,15 +344,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n-                    // if this is an implicit deref of an\n-                    // upvar, then we need to modify the\n-                    // borrow_kind of the upvar to make sure it\n-                    // is inferred to unique if necessary\n-                    let mut ub = self.fcx.inh.upvar_capture_map.borrow_mut();\n-                    let ub = &mut ub[upvar_id];\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n-                } else {\n+                if !self.try_adjust_upvar_deref(&cmt.note, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n@@ -363,6 +360,48 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n     }\n \n+    fn try_adjust_upvar_deref(&self,\n+                              note: &mc::Note,\n+                              borrow_kind: ty::BorrowKind)\n+                              -> bool\n+    {\n+        assert!(match borrow_kind {\n+            ty::MutBorrow => true,\n+            ty::UniqueImmBorrow => true,\n+\n+            // imm borrows never require adjusting any kinds, so we don't wind up here\n+            ty::ImmBorrow => false,\n+        });\n+\n+        match *note {\n+            mc::NoteUpvarRef(upvar_id) => {\n+                // if this is an implicit deref of an\n+                // upvar, then we need to modify the\n+                // borrow_kind of the upvar to make sure it\n+                // is inferred to mutable if necessary\n+                let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                let ub = &mut upvar_capture_map[upvar_id];\n+                self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n+\n+                // also need to be in an FnMut closure since this is not an ImmBorrow\n+                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n+\n+                true\n+            }\n+            mc::NoteClosureEnv(upvar_id) => {\n+                // this kind of deref occurs in a `move` closure, or\n+                // for a by-value upvar; in either case, to mutate an\n+                // upvar, we need to be an FnMut closure\n+                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n+\n+                true\n+            }\n+            mc::NoteNone => {\n+                false\n+            }\n+        }\n+    }\n+\n     /// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n     /// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n     /// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n@@ -374,13 +413,6 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n                upvar_id, upvar_capture, kind);\n \n-        match kind {\n-            ty::ImmBorrow => { }\n-            ty::UniqueImmBorrow | ty::MutBorrow => {\n-                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnMutClosureKind);\n-            }\n-        }\n-\n         match *upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 // Upvar is already by-value, the strongest criteria."}, {"sha": "de17d25b4c360fc8ef0a70bd8743d99671f0c4fd", "filename": "src/test/compile-fail/unboxed-closures-infer-fnmut-move-missing-mut.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-move-missing-mut.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+    let tick = move || counter += 1;\n+    tick(); //~ ERROR cannot borrow immutable local variable `tick` as mutable\n+}"}, {"sha": "f9709b8c596974c4a0e8d2e58c47d573c5e9cc65", "filename": "src/test/compile-fail/unboxed-closures-infer-fnonce-move-call-twice.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnonce-move-call-twice.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this closure\n+// that is just called (`FnMut`).\n+\n+use std::mem;\n+\n+fn main() {\n+    let mut counter: Vec<i32> = Vec::new();\n+    let tick = move || mem::drop(counter);\n+    tick();\n+    tick(); //~ ERROR use of moved value: `tick`\n+}"}, {"sha": "794527249bffaaf55d9da303bbd046c70de181e9", "filename": "src/test/run-pass/unboxed-closures-infer-fnmut-move.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnmut-move.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to infer a suitable kind for this `move`\n+// closure that is just called (`FnMut`).\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    let v = {\n+        let mut tick = move || { counter += 1; counter };\n+        tick();\n+        tick()\n+    };\n+\n+    assert_eq!(counter, 0);\n+    assert_eq!(v, 2);\n+}"}, {"sha": "9f8fc80819bfd39331be9016d3de78e9ad4264ab", "filename": "src/test/run-pass/unboxed-closures-infer-fnonce-move.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce-move.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsafe_destructor)]\n+\n+// Test that we are able to infer a suitable kind for this `move`\n+// closure that is just called (`FnOnce`).\n+\n+use std::mem;\n+\n+struct DropMe<'a>(&'a mut i32);\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for DropMe<'a> {\n+    fn drop(&mut self) {\n+        *self.0 += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut counter = 0;\n+\n+    {\n+        let drop_me = DropMe(&mut counter);\n+        let tick = move || mem::drop(drop_me);\n+        tick();\n+    }\n+\n+    assert_eq!(counter, 1);\n+}"}, {"sha": "f0f10139c5b86fa3d4570789098fd1c4d5c58b9e", "filename": "src/test/run-pass/unboxed-closures-infer-fnonce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3841a501691f36f98c47402d679885989637f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-fnonce.rs?ref=a9c3841a501691f36f98c47402d679885989637f", "patch": "@@ -11,7 +11,7 @@\n #![feature(unsafe_destructor)]\n \n // Test that we are able to infer a suitable kind for this closure\n-// that is just called (`FnMut`).\n+// that is just called (`FnOnce`).\n \n use std::mem;\n "}]}