{"sha": "4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NjFmMDNhMzZhN2EyZDBjZTJkNmUzYjUwYzkyYTdkNzVjY2I0MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-24T16:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-24T16:11:23Z"}, "message": "auto merge of #15949 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "cf2ce47db686efea410691f337bba732cf821e64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf2ce47db686efea410691f337bba732cf821e64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "html_url": "https://github.com/rust-lang/rust/commit/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6203f8ac7b2c31611ef7b84a940dba56058ac03d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6203f8ac7b2c31611ef7b84a940dba56058ac03d", "html_url": "https://github.com/rust-lang/rust/commit/6203f8ac7b2c31611ef7b84a940dba56058ac03d"}, {"sha": "1031ad8f709839a4d34045c6b116704e639f5cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1031ad8f709839a4d34045c6b116704e639f5cbe", "html_url": "https://github.com/rust-lang/rust/commit/1031ad8f709839a4d34045c6b116704e639f5cbe"}], "stats": {"total": 1303, "additions": 929, "deletions": 374}, "files": [{"sha": "b015cb0fbb8c679bab536198dab5e54d42fad9e9", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -3864,13 +3864,13 @@ Function parameters are immutable unless declared with `mut`. The\n and `fn f(mut x: Box<int>, y: Box<int>)` declare one mutable variable `x` and\n one immutable variable `y`).\n \n-Methods that take either `self` or `~self` can optionally place them in a\n+Methods that take either `self` or `Box<Self>` can optionally place them in a\n mutable slot by prefixing them with `mut` (similar to regular arguments):\n \n ~~~\n trait Changer {\n     fn change(mut self) -> Self;\n-    fn modify(mut ~self) -> Box<Self>;\n+    fn modify(mut self: Box<Self>) -> Box<Self>;\n }\n ~~~\n "}, {"sha": "b6485f711ee7a4f75ff647aa627fad6afa6d4391", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1971,7 +1971,7 @@ like any other function, except for the name `self`.\n \n The type of `self` is the type on which the method is implemented,\n or a pointer thereof. As an argument it is written either `self`,\n-`&self`, or `~self`.\n+`&self`, or `self: TYPE`.\n A caller must in turn have a compatible pointer type to call the method.\n \n ~~~\n@@ -1984,7 +1984,7 @@ A caller must in turn have a compatible pointer type to call the method.\n # }\n impl Shape {\n     fn draw_reference(&self) { /* ... */ }\n-    fn draw_owned(~self) { /* ... */ }\n+    fn draw_owned(self: Box<Shape>) { /* ... */ }\n     fn draw_value(self) { /* ... */ }\n }\n \n@@ -2009,7 +2009,7 @@ to a reference.\n # }\n # impl Shape {\n #    fn draw_reference(&self) { /* ... */ }\n-#    fn draw_owned(~self) { /* ... */ }\n+#    fn draw_owned(self: Box<Shape>) { /* ... */ }\n #    fn draw_value(self) { /* ... */ }\n # }\n # let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);"}, {"sha": "c56b265b43aca66b0e5f959853d1696c16372707", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -71,7 +71,7 @@ pub mod bench {\n         // measure\n         let mut i = 0;\n         b.iter(|| {\n-            map.find(keys.get(i));\n+            map.find(&keys[i]);\n             i = (i + 1) % n;\n         })\n     }"}, {"sha": "3bc2dbe5cbbb399ff02674b287f628dd031ee3fa", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 133, "deletions": 18, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * A simple map based on a vector for small integer keys. Space requirements\n- * are O(highest integer key).\n- */\n+//! A simple map based on a vector for small integer keys. Space requirements\n+//! are O(highest integer key).\n \n #![allow(missing_doc)]\n \n@@ -26,18 +24,50 @@ use {Collection, Mutable, Map, MutableMap, MutableSeq};\n use {vec, slice};\n use vec::Vec;\n \n-#[allow(missing_doc)]\n+/// A map optimized for small integer keys.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::SmallIntMap;\n+///\n+/// let mut months = SmallIntMap::new();\n+/// months.insert(1, \"Jan\");\n+/// months.insert(2, \"Feb\");\n+/// months.insert(3, \"Mar\");\n+///\n+/// if !months.contains_key(&12) {\n+///     println!(\"The end is near!\");\n+/// }\n+///\n+/// assert_eq!(months.find(&1), Some(&\"Jan\"));\n+///\n+/// match months.find_mut(&3) {\n+///     Some(value) => *value = \"Venus\",\n+///     None => (),\n+/// }\n+///\n+/// assert_eq!(months.find(&3), Some(&\"Venus\"));\n+///\n+/// // Print out all months\n+/// for (key, value) in months.iter() {\n+///     println!(\"month {} is {}\", key, value);\n+/// }\n+///\n+/// months.clear();\n+/// assert!(months.is_empty());\n+/// ```\n pub struct SmallIntMap<T> {\n     v: Vec<Option<T>>,\n }\n \n impl<V> Collection for SmallIntMap<V> {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the map.\n     fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n \n-    /// Return true if there are no elements in the map\n+    /// Return `true` if there are no elements in the map.\n     fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -49,7 +79,7 @@ impl<V> Mutable for SmallIntMap<V> {\n }\n \n impl<V> Map<uint, V> for SmallIntMap<V> {\n-    /// Return a reference to the value corresponding to the key\n+    /// Return a reference to the value corresponding to the key.\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n             match *self.v.get(*key) {\n@@ -63,7 +93,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n }\n \n impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n-    /// Return a mutable reference to the value corresponding to the key\n+    /// Return a mutable reference to the value corresponding to the key.\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n             match *self.v.get_mut(*key) {\n@@ -76,7 +106,7 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n+    /// key is replaced by the new value. Return `true` if the key did\n     /// not already exist in the map.\n     fn insert(&mut self, key: uint, value: V) -> bool {\n         let exists = self.contains_key(&key);\n@@ -88,14 +118,14 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n         !exists\n     }\n \n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n+    /// Remove a key-value pair from the map. Return `true` if the key\n+    /// was present in the map, otherwise `false`.\n     fn remove(&mut self, key: &uint) -> bool {\n         self.pop(key).is_some()\n     }\n \n     /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n+    /// present in the map, that value is returned. Otherwise `None` is returned.\n     fn swap(&mut self, key: uint, value: V) -> Option<V> {\n         match self.find_mut(&key) {\n             Some(loc) => { return Some(replace(loc, value)); }\n@@ -121,20 +151,67 @@ impl<V> Default for SmallIntMap<V> {\n }\n \n impl<V> SmallIntMap<V> {\n-    /// Create an empty SmallIntMap\n+    /// Create an empty SmallIntMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    /// let mut map: SmallIntMap<&str> = SmallIntMap::new();\n+    /// ```\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n \n-    /// Create an empty SmallIntMap with capacity `capacity`\n+    /// Create an empty SmallIntMap with space for at least `capacity` elements\n+    /// before resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    /// let mut map: SmallIntMap<&str> = SmallIntMap::with_capacity(10);\n+    /// ```\n     pub fn with_capacity(capacity: uint) -> SmallIntMap<V> {\n         SmallIntMap { v: Vec::with_capacity(capacity) }\n     }\n \n+    /// Retrieves a value for the given key.\n+    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.get(&1), &\"a\");\n+    /// ```\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n \n     /// An iterator visiting all key-value pairs in ascending order by the keys.\n-    /// Iterator element type is (uint, &'r V)\n+    /// Iterator element type is `(uint, &'r V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// // Print `1: a` then `2: b` then `3: c`\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n         Entries {\n             front: 0,\n@@ -145,7 +222,26 @@ impl<V> SmallIntMap<V> {\n \n     /// An iterator visiting all key-value pairs in ascending order by the keys,\n     /// with mutable references to the values\n-    /// Iterator element type is (uint, &'r mut V)\n+    /// Iterator element type is `(uint, &'r mut V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n+    ///\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value = \"x\";\n+    /// }\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     assert_eq!(value, &\"x\");\n+    /// }\n+    /// ```\n     pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> {\n         MutEntries {\n             front: 0,\n@@ -154,7 +250,23 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Empties the hash map, moving all values into the specified closure\n+    /// Empties the hash map, moving all values into the specified closure.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::SmallIntMap;\n+    ///\n+    /// let mut map = SmallIntMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(uint, &str)> = map.move_iter().collect();\n+    ///\n+    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// ```\n     pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n                 Enumerate<vec::MoveItems<Option<V>>>>\n@@ -249,6 +361,7 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n+/// Forward iterator over a map.\n pub struct Entries<'a, T> {\n     front: uint,\n     back: uint,\n@@ -258,6 +371,8 @@ pub struct Entries<'a, T> {\n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n \n+/// Forward iterator over the key-value pairs of a map, with the\n+/// values being mutable.\n pub struct MutEntries<'a, T> {\n     front: uint,\n     back: uint,"}, {"sha": "f013557f9a53254e18eafe531535c98d5d5c3239", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 13, "deletions": 79, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -555,10 +555,7 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe operations\n pub mod raw {\n-    use core::prelude::*;\n-    use core::mem;\n-    use core::raw::Slice;\n-\n+    use string;\n     use string::String;\n     use vec::Vec;\n \n@@ -567,57 +564,28 @@ pub mod raw {\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n \n-    /// Create a Rust string from a *u8 buffer of the given length\n+    /// Deprecated. Replaced by `string::raw::from_buf_len`\n+    #[deprecated = \"Use string::raw::from_buf_len\"]\n     pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        let mut result = String::new();\n-        result.push_bytes(mem::transmute(Slice {\n-            data: buf,\n-            len: len,\n-        }));\n-        result\n+        string::raw::from_buf_len(buf, len)\n     }\n \n-    /// Create a Rust string from a null-terminated C string\n+    /// Deprecated. Use `string::raw::from_buf`\n+    #[deprecated = \"Use string::raw::from_buf\"]\n     pub unsafe fn from_c_str(c_string: *const i8) -> String {\n-        let mut buf = String::new();\n-        let mut len = 0;\n-        while *c_string.offset(len) != 0 {\n-            len += 1;\n-        }\n-        buf.push_bytes(mem::transmute(Slice {\n-            data: c_string,\n-            len: len as uint,\n-        }));\n-        buf\n+        string::raw::from_buf(c_string as *const u8)\n     }\n \n-    /// Converts an owned vector of bytes to a new owned string. This assumes\n-    /// that the utf-8-ness of the vector has already been validated\n-    #[inline]\n+    /// Deprecated. Replaced by `string::raw::from_utf8`\n+    #[deprecated = \"Use string::raw::from_utf8\"]\n     pub unsafe fn from_utf8_owned(v: Vec<u8>) -> String {\n-        mem::transmute(v)\n+        string::raw::from_utf8(v)\n     }\n \n-    /// Converts a byte to a string.\n+    /// Deprecated. Use `string::raw::from_utf8`\n+    #[deprecated = \"Use string::raw::from_utf8\"]\n     pub unsafe fn from_byte(u: u8) -> String {\n-        from_utf8_owned(vec![u])\n-    }\n-\n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    #[test]\n-    fn test_from_buf_len() {\n-        use slice::ImmutableVector;\n-\n-        unsafe {\n-            let a = vec![65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = a.as_ptr();\n-            let c = from_buf_len(b, 3u);\n-            assert_eq!(c, String::from_str(\"AAA\"));\n-        }\n+        string::raw::from_utf8(vec![u])\n     }\n }\n \n@@ -785,30 +753,6 @@ impl<'a> StrAllocating for &'a str {\n     }\n }\n \n-/// Methods for owned strings\n-pub trait OwnedStr {\n-    /// Consumes the string, returning the underlying byte buffer.\n-    ///\n-    /// The buffer does not have a null terminator.\n-    fn into_bytes(self) -> Vec<u8>;\n-\n-    /// Pushes the given string onto this string, returning the concatenation of the two strings.\n-    fn append(self, rhs: &str) -> String;\n-}\n-\n-impl OwnedStr for String {\n-    #[inline]\n-    fn into_bytes(self) -> Vec<u8> {\n-        unsafe { mem::transmute(self) }\n-    }\n-\n-    #[inline]\n-    fn append(mut self, rhs: &str) -> String {\n-        self.push_str(rhs);\n-        self\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::iter::AdditiveIterator;\n@@ -1377,16 +1321,6 @@ mod tests {\n              [0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n     }\n \n-    #[test]\n-    fn test_raw_from_c_str() {\n-        unsafe {\n-            let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n-            let b = a.as_ptr();\n-            let c = raw::from_c_str(b);\n-            assert_eq!(c, String::from_str(\"AAAAAAA\"));\n-        }\n-    }\n-\n     #[test]\n     fn test_as_bytes() {\n         // no null"}, {"sha": "282193d08aa81a94b4092c045ad70b0c3538008f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -49,14 +49,6 @@ impl String {\n         }\n     }\n \n-    /// Creates a new string buffer from length, capacity, and a pointer.\n-    #[inline]\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String {\n-        String {\n-            vec: Vec::from_raw_parts(length, capacity, ptr),\n-        }\n-    }\n-\n     /// Creates a new string buffer from the given string.\n     #[inline]\n     pub fn from_str(string: &str) -> String {\n@@ -65,6 +57,13 @@ impl String {\n         }\n     }\n \n+    /// Deprecated. Replaced by `string::raw::from_parts`\n+    #[inline]\n+    #[deprecated = \"Replaced by string::raw::from_parts\"]\n+    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String {\n+        raw::from_parts(ptr, length, capacity)\n+    }\n+\n     #[allow(missing_doc)]\n     #[deprecated = \"obsoleted by the removal of ~str\"]\n     #[inline]\n@@ -570,6 +569,62 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n+pub mod raw {\n+    use core::mem;\n+    use core::ptr::RawPtr;\n+    use core::raw::Slice;\n+\n+    use super::String;\n+    use vec::Vec;\n+\n+    /// Creates a new `String` from length, capacity, and a pointer.\n+    ///\n+    /// This is unsafe because:\n+    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`\n+    /// * We assume that the `Vec` contains valid UTF-8\n+    #[inline]\n+    pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n+        String {\n+            vec: Vec::from_raw_parts(length, capacity, buf),\n+        }\n+    }\n+\n+    /// Create `String` from a *u8 buffer of the given length\n+    ///\n+    /// This function is unsafe because of two reasons:\n+    /// * A raw pointer is dereferenced and transmuted to `&[u8]`\n+    /// * The slice is not checked to see whether it contains valid UTF-8\n+    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n+        use slice::CloneableVector;\n+        let slice: &[u8] = mem::transmute(Slice {\n+            data: buf,\n+            len: len,\n+        });\n+        self::from_utf8(slice.to_vec())\n+    }\n+\n+    /// Create a `String` from a null-terminated *u8 buffer\n+    ///\n+    /// This function is unsafe because we dereference memory until we find the NUL character,\n+    /// which is not guaranteed to be present. Additionaly, the slice is not checked to see\n+    /// whether it contains valid UTF-8\n+    pub unsafe fn from_buf(buf: *const u8) -> String {\n+        let mut len = 0;\n+        while *buf.offset(len) != 0 {\n+            len += 1;\n+        }\n+        self::from_buf_len(buf, len as uint)\n+    }\n+\n+    /// Converts a vector of bytes to a new `String` without checking if\n+    /// it contains valid UTF-8. This is unsafe because it assumes that\n+    /// the utf-8-ness of the vector has already been validated.\n+    #[inline]\n+    pub unsafe fn from_utf8(bytes: Vec<u8>) -> String {\n+        String { vec: bytes }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::*;\n@@ -727,6 +782,24 @@ mod tests {\n                    String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n     }\n \n+    #[test]\n+    fn test_from_buf_len() {\n+        unsafe {\n+            let a = vec![65u8, 65, 65, 65, 65, 65, 65, 0];\n+            assert_eq!(super::raw::from_buf_len(a.as_ptr(), 3), String::from_str(\"AAA\"));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_buf() {\n+        unsafe {\n+            let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n+            let b = a.as_ptr();\n+            let c = super::raw::from_buf(b);\n+            assert_eq!(c, String::from_str(\"AAAAAAA\"));\n+        }\n+    }\n+\n     #[test]\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");"}, {"sha": "5c17dd912253848ecfdba81d512ca6f7eac1a38c", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 256, "deletions": 16, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n+//! Ordered containers with unsigned integer keys,\n+//! implemented as radix tries (`TrieSet` and `TrieMap` types).\n \n use core::prelude::*;\n \n@@ -35,7 +36,44 @@ enum Child<T> {\n     Nothing\n }\n \n-#[allow(missing_doc)]\n+/// A map implemented as a radix trie.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TrieMap;\n+///\n+/// let mut map = TrieMap::new();\n+/// map.insert(27, \"Olaf\");\n+/// map.insert(1, \"Edgar\");\n+/// map.insert(13, \"Ruth\");\n+/// map.insert(1, \"Martin\");\n+///\n+/// assert_eq!(map.len(), 3);\n+/// assert_eq!(map.find(&1), Some(&\"Martin\"));\n+///\n+/// if !map.contains_key(&90) {\n+///     println!(\"Nobody is keyed 90\");\n+/// }\n+///\n+/// // Update a key\n+/// match map.find_mut(&1) {\n+///     Some(value) => *value = \"Olga\",\n+///     None => (),\n+/// }\n+///\n+/// map.remove(&13);\n+/// assert_eq!(map.len(), 2);\n+///\n+/// // Print the key value pairs, ordered by key.\n+/// for (key, value) in map.iter() {\n+///     // Prints `1: Olga` then `27: Olaf`\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// map.clear();\n+/// assert!(map.is_empty());\n+/// ```\n pub struct TrieMap<T> {\n     root: TrieNode<T>,\n     length: uint\n@@ -51,7 +89,7 @@ impl<T: PartialEq> PartialEq for TrieMap<T> {\n impl<T: Eq> Eq for TrieMap<T> {}\n \n impl<T> Collection for TrieMap<T> {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the map.\n     #[inline]\n     fn len(&self) -> uint { self.length }\n }\n@@ -66,7 +104,7 @@ impl<T> Mutable for TrieMap<T> {\n }\n \n impl<T> Map<uint, T> for TrieMap<T> {\n-    /// Return a reference to the value corresponding to the key\n+    /// Return a reference to the value corresponding to the key.\n     #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n         let mut node: &'a TrieNode<T> = &self.root;\n@@ -89,7 +127,7 @@ impl<T> Map<uint, T> for TrieMap<T> {\n }\n \n impl<T> MutableMap<uint, T> for TrieMap<T> {\n-    /// Return a mutable reference to the value corresponding to the key\n+    /// Return a mutable reference to the value corresponding to the key.\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n@@ -122,19 +160,54 @@ impl<T> Default for TrieMap<T> {\n }\n \n impl<T> TrieMap<T> {\n-    /// Create an empty TrieMap\n+    /// Create an empty TrieMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = TrieMap::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n \n-    /// Visit all key-value pairs in reverse order\n+    /// Visit all key-value pairs in reverse order. Abort traversal when f returns false.\n+    /// Return true if f returns true for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(1, \"a\"), (2, \"b\"), (3, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, map.each_reverse(|&key, &value| { vec.push((key, value)); true }));\n+    /// assert_eq!(vec, vec![(3, \"c\"), (2, \"b\"), (1, \"a\")]);\n+    ///\n+    /// // Stop when we reach 2\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, map.each_reverse(|&key, &value| { vec.push(value); key != 2 }));\n+    /// assert_eq!(vec, vec![\"c\", \"b\"]);\n+    /// ```\n     #[inline]\n     pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n-    /// Get an iterator over the key-value pairs in the map\n+    /// Get an iterator over the key-value pairs in the map, ordered by keys.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(3, \"c\"), (1, \"a\"), (2, \"b\")].iter().map(|&x| x).collect();\n+    ///\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n         let mut iter = unsafe {Entries::new()};\n         iter.stack[0] = self.root.children.iter();\n@@ -147,6 +220,21 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<int> = [(1, 2), (2, 4), (3, 6)].iter().map(|&x| x).collect();\n+    ///\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value = -(key as int);\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&1), Some(&-1));\n+    /// assert_eq!(map.find(&2), Some(&-2));\n+    /// assert_eq!(map.find(&3), Some(&-3));\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> {\n         let mut iter = unsafe {MutEntries::new()};\n         iter.stack[0] = self.root.children.mut_iter();\n@@ -255,12 +343,34 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.lower_bound(4).next(), Some((4, &\"b\")));\n+    /// assert_eq!(map.lower_bound(5).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.lower_bound(10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.upper_bound(4).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(5).next(), Some((6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, key: uint) -> Entries<'a, T> {\n         self.bound(key, true)\n     }\n@@ -275,12 +385,50 @@ impl<T> TrieMap<T> {\n \n     /// Get an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.mut_lower_bound(4).next(), Some((4, &mut \"b\")));\n+    /// assert_eq!(map.mut_lower_bound(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_lower_bound(10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_lower_bound(4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, false)\n     }\n \n     /// Get an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieMap;\n+    /// let mut map: TrieMap<&str> = [(2, \"a\"), (4, \"b\"), (6, \"c\")].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(map.mut_upper_bound(4).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(5).next(), Some((6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_upper_bound(4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"b\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.mut_bound(key, true)\n     }\n@@ -310,14 +458,42 @@ impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n     }\n }\n \n-#[allow(missing_doc)]\n+/// A set implemented as a radix trie.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TrieSet;\n+///\n+/// let mut set = TrieSet::new();\n+/// set.insert(6);\n+/// set.insert(28);\n+/// set.insert(6);\n+///\n+/// assert_eq!(set.len(), 2);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"3 is not in the set\");\n+/// }\n+///\n+/// // Print contents in order\n+/// for x in set.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// set.remove(&6);\n+/// assert_eq!(set.len(), 1);\n+///\n+/// set.clear();\n+/// assert!(set.is_empty());\n+/// ```\n #[deriving(Hash, PartialEq, Eq)]\n pub struct TrieSet {\n     map: TrieMap<()>\n }\n \n impl Collection for TrieSet {\n-    /// Return the number of elements in the set\n+    /// Return the number of elements in the set.\n     #[inline]\n     fn len(&self) -> uint { self.map.len() }\n }\n@@ -368,32 +544,96 @@ impl Default for TrieSet {\n }\n \n impl TrieSet {\n-    /// Create an empty TrieSet\n+    /// Create an empty TrieSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    /// let mut set = TrieSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n \n-    /// Visit all values in reverse order\n+    /// Visit all values in reverse order. Abort traversal when `f` returns false.\n+    /// Return `true` if `f` returns `true` for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n+    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n+    ///\n+    /// // Stop when we reach 3\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n+    /// assert_eq!(vec, vec![5, 4, 3]);\n+    /// ```\n     #[inline]\n     pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.map.each_reverse(|k, _| f(k))\n     }\n \n-    /// Get an iterator over the values in the set\n+    /// Get an iterator over the values in the set, in sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    /// set.insert(3);\n+    /// set.insert(2);\n+    /// set.insert(1);\n+    /// set.insert(2);\n+    ///\n+    /// // Print 1, 2, 3\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> SetItems<'a> {\n         SetItems{iter: self.map.iter()}\n     }\n \n     /// Get an iterator pointing to the first value that is not less than `val`.\n     /// If all values in the set are less than `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n+    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n+    /// assert_eq!(set.lower_bound(10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n         SetItems{iter: self.map.lower_bound(val)}\n     }\n \n     /// Get an iterator pointing to the first value that key is greater than `val`.\n-    /// If all values in the set are not greater than `val` an empty iterator is returned.\n+    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n         SetItems{iter: self.map.upper_bound(val)}\n     }\n@@ -526,7 +766,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n-/// Forward iterator over a map\n+/// Forward iterator over a map.\n pub struct Entries<'a, T> {\n     stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n     length: uint,\n@@ -660,7 +900,7 @@ macro_rules! iterator_impl {\n iterator_impl! { Entries, iter = iter, mutability = }\n iterator_impl! { MutEntries, iter = mut_iter, mutability = mut }\n \n-/// Forward iterator over a set\n+/// Forward iterator over a set.\n pub struct SetItems<'a> {\n     iter: Entries<'a, ()>\n }"}, {"sha": "48a3db4258f2b021f2fce3d24fc66bad9ed0c6fc", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1217,6 +1217,14 @@ impl<T: CheckedAdd + CheckedSub + Zero + PartialOrd + Bounded> Saturating for T\n /// Performs addition that returns `None` instead of wrapping around on overflow.\n pub trait CheckedAdd: Add<Self, Self> {\n     /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::CheckedAdd;\n+    /// assert_eq!(5u16.checked_add(&65530), Some(65535));\n+    /// assert_eq!(6u16.checked_add(&65530), None);\n+    /// ```\n     fn checked_add(&self, v: &Self) -> Option<Self>;\n }\n \n@@ -1270,6 +1278,14 @@ checked_impl!(CheckedAdd, checked_add, i64, intrinsics::i64_add_with_overflow)\n /// Performs subtraction that returns `None` instead of wrapping around on underflow.\n pub trait CheckedSub: Sub<Self, Self> {\n     /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::CheckedSub;\n+    /// assert_eq!((-127i8).checked_sub(&1), Some(-128));\n+    /// assert_eq!((-128i8).checked_sub(&1), None);\n+    /// ```\n     fn checked_sub(&self, v: &Self) -> Option<Self>;\n }\n \n@@ -1298,6 +1314,14 @@ checked_impl!(CheckedSub, checked_sub, i64, intrinsics::i64_sub_with_overflow)\n pub trait CheckedMul: Mul<Self, Self> {\n     /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n     /// happens, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::CheckedMul;\n+    /// assert_eq!(5u8.checked_mul(&51), Some(255));\n+    /// assert_eq!(5u8.checked_mul(&52), None);\n+    /// ```\n     fn checked_mul(&self, v: &Self) -> Option<Self>;\n }\n \n@@ -1325,6 +1349,14 @@ checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n pub trait CheckedDiv: Div<Self, Self> {\n     /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n     /// `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::CheckedDiv;\n+    /// assert_eq!((-127i8).checked_div(&-1), Some(127));\n+    /// assert_eq!((-128i8).checked_div(&-1), None);\n+    /// ```\n     fn checked_div(&self, v: &Self) -> Option<Self>;\n }\n "}, {"sha": "839243970ac673ed40080d84c55212b76aa3b50d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -769,3 +769,37 @@ pub trait FnOnce<Args,Result> {\n     fn call_once(self, args: Args) -> Result;\n }\n \n+macro_rules! def_fn_mut(\n+    ($($args:ident)*) => (\n+        #[cfg(not(stage0))]\n+        impl<Result$(,$args)*>\n+        FnMut<($($args,)*),Result>\n+        for extern \"Rust\" fn($($args: $args,)*) -> Result {\n+            #[rust_call_abi_hack]\n+            #[allow(uppercase_variables)]\n+            fn call_mut(&mut self, args: ($($args,)*)) -> Result {\n+                let ($($args,)*) = args;\n+                (*self)($($args,)*)\n+            }\n+        }\n+    )\n+)\n+\n+def_fn_mut!()\n+def_fn_mut!(A0)\n+def_fn_mut!(A0 A1)\n+def_fn_mut!(A0 A1 A2)\n+def_fn_mut!(A0 A1 A2 A3)\n+def_fn_mut!(A0 A1 A2 A3 A4)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14)\n+def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15)\n+"}, {"sha": "9058ae56c45e403e79f83caf56cd571a7e2d3d68", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -11,8 +11,8 @@\n use core::ptr::*;\n use libc::c_char;\n use core::mem;\n-use std::str;\n use libc;\n+use std::c_str::CString;\n \n #[test]\n fn test() {\n@@ -186,9 +186,8 @@ fn test_ptr_array_each_with_len() {\n         let mut ctr = 0;\n         let mut iteration_count = 0;\n         array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n-                let actual = str::raw::from_c_str(e);\n-                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n-                assert_eq!(actual.as_slice(), expected.as_slice());\n+                let actual = CString::new(e, false);\n+                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n                 ctr += 1;\n                 iteration_count += 1;\n             });\n@@ -217,9 +216,8 @@ fn test_ptr_array_each() {\n         let mut ctr = 0u;\n         let mut iteration_count = 0u;\n         array_each(arr_ptr, |e| {\n-                let actual = str::raw::from_c_str(e);\n-                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n-                assert_eq!(actual.as_slice(), expected.as_slice());\n+                let actual = CString::new(e, false);\n+                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n                 ctr += 1;\n                 iteration_count += 1;\n             });\n@@ -232,7 +230,7 @@ fn test_ptr_array_each() {\n fn test_ptr_array_each_with_len_null_ptr() {\n     unsafe {\n         array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n-            str::raw::from_c_str(e);\n+            CString::new(e, false).as_str().unwrap();\n         });\n     }\n }\n@@ -241,7 +239,7 @@ fn test_ptr_array_each_with_len_null_ptr() {\n fn test_ptr_array_each_null_ptr() {\n     unsafe {\n         array_each(0 as *const *const libc::c_char, |e| {\n-            str::raw::from_c_str(e);\n+            CString::new(e, false).as_str().unwrap();\n         });\n     }\n }"}, {"sha": "38bb6e355a77151857f370433b2518308d202f06", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -180,7 +180,7 @@ impl Scheduler {\n \n     // Take a main task to run, and a scheduler to run it in. Create a\n     // scheduler task and bootstrap into it.\n-    pub fn bootstrap(mut ~self) {\n+    pub fn bootstrap(mut self: Box<Scheduler>) {\n \n         // Build an Idle callback.\n         let cb = box SchedRunner as Box<Callback + Send>;\n@@ -224,7 +224,8 @@ impl Scheduler {\n \n     // This does not return a scheduler, as the scheduler is placed\n     // inside the task.\n-    pub fn run(mut ~self, stask: Box<GreenTask>) -> Box<GreenTask> {\n+    pub fn run(mut self: Box<Scheduler>, stask: Box<GreenTask>)\n+               -> Box<GreenTask> {\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n@@ -271,7 +272,7 @@ impl Scheduler {\n     // If we try really hard to do some work, but no work is available to be\n     // done, then we fall back to epoll() to block this thread waiting for more\n     // work (instead of busy waiting).\n-    fn run_sched_once(mut ~self, stask: Box<GreenTask>) {\n+    fn run_sched_once(mut self: Box<Scheduler>, stask: Box<GreenTask>) {\n         // Make sure that we're not lying in that the `stask` argument is indeed\n         // the scheduler task for this scheduler.\n         assert!(self.sched_task.is_none());\n@@ -349,11 +350,10 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(mut ~self, stask: Box<GreenTask>,\n+    fn interpret_message_queue(mut self: Box<Scheduler>,\n+                               stask: Box<GreenTask>,\n                                effort: EffortLevel)\n-            -> (Box<Scheduler>, Box<GreenTask>, bool)\n-    {\n-\n+                               -> (Box<Scheduler>, Box<GreenTask>, bool) {\n         let msg = if effort == DontTryTooHard {\n             self.message_queue.casual_pop()\n         } else {\n@@ -432,7 +432,7 @@ impl Scheduler {\n         }\n     }\n \n-    fn do_work(mut ~self, stask: Box<GreenTask>)\n+    fn do_work(mut self: Box<Scheduler>, stask: Box<GreenTask>)\n                -> (Box<Scheduler>, Box<GreenTask>, bool) {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n@@ -517,7 +517,7 @@ impl Scheduler {\n     // * Task Routing Functions - Make sure tasks send up in the right\n     // place.\n \n-    fn process_task(mut ~self,\n+    fn process_task(mut self: Box<Scheduler>,\n                     cur: Box<GreenTask>,\n                     mut next: Box<GreenTask>,\n                     schedule_fn: SchedulingFn)\n@@ -610,7 +610,7 @@ impl Scheduler {\n     // cleanup function f, which takes the scheduler and the\n     // old task as inputs.\n \n-    pub fn change_task_context(mut ~self,\n+    pub fn change_task_context(mut self: Box<Scheduler>,\n                                mut current_task: Box<GreenTask>,\n                                mut next_task: Box<GreenTask>,\n                                f: |&mut Scheduler, Box<GreenTask>|)\n@@ -693,7 +693,7 @@ impl Scheduler {\n \n     // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self,\n+    pub fn resume_task_immediately(self: Box<Scheduler>,\n                                    cur: Box<GreenTask>,\n                                    next: Box<GreenTask>)\n                                    -> (Box<Scheduler>, Box<GreenTask>) {\n@@ -733,7 +733,7 @@ impl Scheduler {\n     /// This situation is currently prevented, or in other words it is\n     /// guaranteed that this function will not return before the given closure\n     /// has returned.\n-    pub fn deschedule_running_task_and_then(mut ~self,\n+    pub fn deschedule_running_task_and_then(mut self: Box<Scheduler>,\n                                             cur: Box<GreenTask>,\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n@@ -743,7 +743,7 @@ impl Scheduler {\n         self.switch_running_tasks_and_then(cur, stask, f)\n     }\n \n-    pub fn switch_running_tasks_and_then(~self,\n+    pub fn switch_running_tasks_and_then(self: Box<Scheduler>,\n                                          cur: Box<GreenTask>,\n                                          next: Box<GreenTask>,\n                                          f: |&mut Scheduler, BlockedTask|) {\n@@ -795,7 +795,9 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(mut ~self, cur: Box<GreenTask>) -> ! {\n+    pub fn terminate_current_task(mut self: Box<Scheduler>,\n+                                  cur: Box<GreenTask>)\n+                                  -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n@@ -807,7 +809,9 @@ impl Scheduler {\n         fail!(\"should never return!\");\n     }\n \n-    pub fn run_task(~self, cur: Box<GreenTask>, next: Box<GreenTask>) {\n+    pub fn run_task(self: Box<Scheduler>,\n+                    cur: Box<GreenTask>,\n+                    next: Box<GreenTask>) {\n         let (sched, task) =\n             self.process_task(cur, next, Scheduler::switch_task);\n         task.put_with_sched(sched);\n@@ -823,7 +827,7 @@ impl Scheduler {\n     /// to introduce some amount of randomness to the scheduler. Currently the\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n-    pub fn yield_now(mut ~self, cur: Box<GreenTask>) {\n+    pub fn yield_now(mut self: Box<Scheduler>, cur: Box<GreenTask>) {\n         // Async handles trigger the scheduler by calling yield_now on the local\n         // task, which eventually gets us to here. See comments in SchedRunner\n         // for more info on this.\n@@ -842,7 +846,7 @@ impl Scheduler {\n         }\n     }\n \n-    pub fn maybe_yield(mut ~self, cur: Box<GreenTask>) {\n+    pub fn maybe_yield(mut self: Box<Scheduler>, cur: Box<GreenTask>) {\n         // It's possible for sched tasks to possibly call this function, and it\n         // just means that they're likely sending on channels (which\n         // occasionally call this function). Sched tasks follow different paths"}, {"sha": "6254e8c55f0075e41128e1cd70d10cc4f6f63bdf", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -27,7 +27,9 @@ struct SimpleTask {\n impl Runtime for SimpleTask {\n     // Implement the simple tasks of descheduling and rescheduling, but only in\n     // a simple number of cases.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<SimpleTask>,\n+                  times: uint,\n+                  mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         assert!(times == 1);\n \n@@ -54,7 +56,7 @@ impl Runtime for SimpleTask {\n         }\n         Local::put(cur_task);\n     }\n-    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<SimpleTask>, mut to_wake: Box<Task>) {\n         let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self);\n         unsafe {\n@@ -69,9 +71,9 @@ impl Runtime for SimpleTask {\n     // purpose. A \"simple task\" is just that, a very simple task that can't\n     // really do a whole lot. The only purpose of the task is to get us off our\n     // feet and running.\n-    fn yield_now(~self, _cur_task: Box<Task>) { fail!() }\n-    fn maybe_yield(~self, _cur_task: Box<Task>) { fail!() }\n-    fn spawn_sibling(~self,\n+    fn yield_now(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n+    fn maybe_yield(self: Box<SimpleTask>, _cur_task: Box<Task>) { fail!() }\n+    fn spawn_sibling(self: Box<SimpleTask>,\n                      _cur_task: Box<Task>,\n                      _opts: TaskOpts,\n                      _f: proc():Send) {\n@@ -80,7 +82,7 @@ impl Runtime for SimpleTask {\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n     fn stack_bounds(&self) -> (uint, uint) { fail!() }\n     fn can_block(&self) -> bool { true }\n-    fn wrap(~self) -> Box<Any> { fail!() }\n+    fn wrap(self: Box<SimpleTask>) -> Box<Any> { fail!() }\n }\n \n pub fn task() -> Box<Task> {"}, {"sha": "3d3b413384050f37e6cd6057c5b43e53118db332", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -265,7 +265,7 @@ impl GreenTask {\n \n     // Runtime glue functions and helpers\n \n-    pub fn put_with_sched(mut ~self, sched: Box<Scheduler>) {\n+    pub fn put_with_sched(mut self: Box<GreenTask>, sched: Box<Scheduler>) {\n         assert!(self.sched.is_none());\n         self.sched = Some(sched);\n         self.put();\n@@ -276,18 +276,18 @@ impl GreenTask {\n         self.task = Some(task);\n     }\n \n-    pub fn swap(mut ~self) -> Box<Task> {\n+    pub fn swap(mut self: Box<GreenTask>) -> Box<Task> {\n         let mut task = self.task.take_unwrap();\n         task.put_runtime(self);\n         return task;\n     }\n \n-    pub fn put(~self) {\n+    pub fn put(self: Box<GreenTask>) {\n         assert!(self.sched.is_some());\n         Local::put(self.swap());\n     }\n \n-    fn terminate(mut ~self) -> ! {\n+    fn terminate(mut self: Box<GreenTask>) -> ! {\n         let sched = self.sched.take_unwrap();\n         sched.terminate_current_task(self)\n     }\n@@ -311,7 +311,7 @@ impl GreenTask {\n     // *not* a cheap operation to clone a handle. Until the day comes that we\n     // need to optimize this, a lock should do just fine (it's completely\n     // uncontended except for when the task is rescheduled).\n-    fn reawaken_remotely(mut ~self) {\n+    fn reawaken_remotely(mut self: Box<GreenTask>) {\n         unsafe {\n             let mtx = &mut self.nasty_deschedule_lock as *mut NativeMutex;\n             let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n@@ -322,19 +322,21 @@ impl GreenTask {\n }\n \n impl Runtime for GreenTask {\n-    fn yield_now(mut ~self, cur_task: Box<Task>) {\n+    fn yield_now(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.yield_now(self);\n     }\n \n-    fn maybe_yield(mut ~self, cur_task: Box<Task>) {\n+    fn maybe_yield(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n         let sched = self.sched.take_unwrap();\n         sched.maybe_yield(self);\n     }\n \n-    fn deschedule(mut ~self, times: uint, cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<GreenTask>,\n+                  times: uint,\n+                  cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         self.put_task(cur_task);\n         let mut sched = self.sched.take_unwrap();\n@@ -383,7 +385,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn reawaken(mut ~self, to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<GreenTask>, to_wake: Box<Task>) {\n         self.put_task(to_wake);\n         assert!(self.sched.is_none());\n \n@@ -434,7 +436,7 @@ impl Runtime for GreenTask {\n         }\n     }\n \n-    fn spawn_sibling(mut ~self,\n+    fn spawn_sibling(mut self: Box<GreenTask>,\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send) {\n@@ -471,7 +473,7 @@ impl Runtime for GreenTask {\n \n     fn can_block(&self) -> bool { false }\n \n-    fn wrap(~self) -> Box<Any> { self as Box<Any> }\n+    fn wrap(self: Box<GreenTask>) -> Box<Any> { self as Box<Any> }\n }\n \n #[cfg(test)]"}, {"sha": "7a07b6221277f7fc44937264b9cd6d1d9c6d71af", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -10,7 +10,6 @@\n \n use libc::{c_char, c_int};\n use libc;\n-use std::c_str::CString;\n use std::mem;\n use std::ptr::{null, mut_null};\n use std::rt::rtio;\n@@ -27,8 +26,10 @@ impl GetAddrInfoRequest {\n     {\n         assert!(host.is_some() || servname.is_some());\n \n-        let c_host = host.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n-        let c_serv = servname.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n+        let c_host = host.map(|x| x.to_c_str());\n+        let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n+        let c_serv = servname.map(|x| x.to_c_str());\n+        let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n \n         let hint = hint.map(|hint| {\n             libc::addrinfo {\n@@ -50,9 +51,7 @@ impl GetAddrInfoRequest {\n \n         // Make the call\n         let s = unsafe {\n-            let ch = if c_host.is_null() { null() } else { c_host.as_ptr() };\n-            let cs = if c_serv.is_null() { null() } else { c_serv.as_ptr() };\n-            getaddrinfo(ch, cs, hint_ptr, &mut res)\n+            getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n         };\n \n         // Error?\n@@ -104,6 +103,7 @@ fn get_error(_: c_int) -> IoError {\n \n #[cfg(not(windows))]\n fn get_error(s: c_int) -> IoError {\n+    use std::c_str::CString;\n \n     let err_str = unsafe {\n         CString::new(gai_strerror(s), false).as_str().unwrap().to_string()"}, {"sha": "c3eb5e91e90f07c5f6fd09a7f87e00c9a344abf6", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -484,7 +484,8 @@ impl TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n+    fn listen(self: Box<TcpListener>)\n+              -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n         self.native_listen(128).map(|a| {\n             box a as Box<rtio::RtioTcpAcceptor + Send>\n         })"}, {"sha": "075ca769d073e919a46f31415195cce75205e13d", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -229,7 +229,8 @@ impl UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<UnixListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         self.native_listen(128).map(|a| {\n             box a as Box<rtio::RtioUnixAcceptor + Send>\n         })"}, {"sha": "79ca23abed25c9968ef567a8a63cb2ade6699541", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -588,7 +588,8 @@ impl Drop for UnixListener {\n }\n \n impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<UnixListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         self.native_listen().map(|a| {\n             box a as Box<rtio::RtioUnixAcceptor + Send>\n         })"}, {"sha": "35367ff2efab3675bbb0f376dfd893c203ecacce", "filename": "src/libnative/task.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -131,21 +131,21 @@ struct Ops {\n }\n \n impl rt::Runtime for Ops {\n-    fn yield_now(~self, mut cur_task: Box<Task>) {\n+    fn yield_now(self: Box<Ops>, mut cur_task: Box<Task>) {\n         // put the task back in TLS and then invoke the OS thread yield\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n         Thread::yield_now();\n     }\n \n-    fn maybe_yield(~self, mut cur_task: Box<Task>) {\n+    fn maybe_yield(self: Box<Ops>, mut cur_task: Box<Task>) {\n         // just put the task back in TLS, on OS threads we never need to\n         // opportunistically yield b/c the OS will do that for us (preemption)\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n     }\n \n-    fn wrap(~self) -> Box<Any> {\n+    fn wrap(self: Box<Ops>) -> Box<Any> {\n         self as Box<Any>\n     }\n \n@@ -192,7 +192,9 @@ impl rt::Runtime for Ops {\n     // `awoken` field which indicates whether we were actually woken up via some\n     // invocation of `reawaken`. This flag is only ever accessed inside the\n     // lock, so there's no need to make it atomic.\n-    fn deschedule(mut ~self, times: uint, mut cur_task: Box<Task>,\n+    fn deschedule(mut self: Box<Ops>,\n+                  times: uint,\n+                  mut cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         let me = &mut *self as *mut Ops;\n         cur_task.put_runtime(self);\n@@ -250,7 +252,7 @@ impl rt::Runtime for Ops {\n \n     // See the comments on `deschedule` for why the task is forgotten here, and\n     // why it's valid to do so.\n-    fn reawaken(mut ~self, mut to_wake: Box<Task>) {\n+    fn reawaken(mut self: Box<Ops>, mut to_wake: Box<Task>) {\n         unsafe {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self);\n@@ -261,7 +263,7 @@ impl rt::Runtime for Ops {\n         }\n     }\n \n-    fn spawn_sibling(~self,\n+    fn spawn_sibling(self: Box<Ops>,\n                      mut cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send) {"}, {"sha": "1811c4f8612f01560e8678b2451e7f5c4a33d825", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -233,7 +233,7 @@ use std::io;\n use std::mem;\n use std::ptr;\n use std::slice;\n-use std::str;\n+use std::string;\n \n use std::collections::{HashMap, HashSet};\n use flate;\n@@ -772,7 +772,7 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = str::raw::from_buf_len(name_buf as *const u8,\n+            let name = string::raw::from_buf_len(name_buf as *const u8,\n                                               name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os).as_slice() == name.as_slice() {"}, {"sha": "e9d92e45f62d9005c08c7c192803c51d562c8ae6", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -21,9 +21,9 @@ use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n \n use std::c_str::ToCStr;\n use std::mem;\n+use std::string;\n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::str::raw::from_c_str;\n \n use libc::{c_uint, c_void, free};\n \n@@ -334,9 +334,9 @@ impl TypeNames {\n     pub fn type_to_string(&self, ty: Type) -> String {\n         unsafe {\n             let s = llvm::LLVMTypeToString(ty.to_ref());\n-            let ret = from_c_str(s);\n+            let ret = string::raw::from_buf(s as *const u8);\n             free(s as *mut c_void);\n-            ret.to_string()\n+            ret\n         }\n     }\n \n@@ -348,9 +348,9 @@ impl TypeNames {\n     pub fn val_to_string(&self, val: ValueRef) -> String {\n         unsafe {\n             let s = llvm::LLVMValueToString(val);\n-            let ret = from_c_str(s);\n+            let ret = string::raw::from_buf(s as *const u8);\n             free(s as *mut c_void);\n-            ret.to_string()\n+            ret\n         }\n     }\n }"}, {"sha": "d202e61abf332e1981014763a92bf524db184f7d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -53,6 +53,7 @@ use middle::const_eval;\n use middle::def;\n use middle::lang_items::FnMutTraitLangItem;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::rscope::{ExplicitRscope, ImpliedSingleRscope};\n@@ -299,6 +300,47 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n \n+/// Returns the type that this AST path refers to. If the path has no type\n+/// parameters and the corresponding type has type parameters, fresh type\n+/// and/or region variables are substituted.\n+///\n+/// This is used when checking the constructor in struct literals.\n+pub fn ast_path_to_ty_relaxed<AC:AstConv,\n+                              RS:RegionScope>(\n+                              this: &AC,\n+                              rscope: &RS,\n+                              did: ast::DefId,\n+                              path: &ast::Path)\n+                              -> TypeAndSubsts {\n+    let tcx = this.tcx();\n+    let ty::Polytype {\n+        generics: generics,\n+        ty: decl_ty\n+    } = this.get_item_ty(did);\n+\n+    let substs = if (generics.has_type_params(TypeSpace) ||\n+        generics.has_region_params(TypeSpace)) &&\n+            path.segments.iter().all(|s| {\n+                s.lifetimes.len() == 0 && s.types.len() == 0\n+            }) {\n+        let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n+                                       |_| this.ty_infer(path.span));\n+        let region_params =\n+            rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n+                  .unwrap();\n+        Substs::new(VecPerParamSpace::params_from_type(type_params),\n+                    VecPerParamSpace::params_from_type(region_params))\n+    } else {\n+        ast_path_substs(this, rscope, &generics, None, path)\n+    };\n+\n+    let ty = decl_ty.subst(tcx, &substs);\n+    TypeAndSubsts {\n+        substs: substs,\n+        ty: ty,\n+    }\n+}\n+\n pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n@@ -1051,7 +1093,6 @@ fn determine_explicit_self_category<AC:AstConv,\n                                          lifetime);\n             ty::ByReferenceExplicitSelfCategory(region, mutability)\n         }\n-        ast::SelfUniq(_) => ty::ByBoxExplicitSelfCategory,\n         ast::SelfExplicit(ast_type, _) => {\n             let explicit_type = ast_ty_to_ty(this, rscope, &*ast_type);\n "}, {"sha": "747ba26f5909fce3d319cd4e6bd881b51e3aea5f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1541,6 +1541,13 @@ fn try_overloaded_call(fcx: &FnCtxt,\n                        callee_type: ty::t,\n                        args: &[Gc<ast::Expr>])\n                        -> bool {\n+    // Bail out if the callee is a bare function or a closure. We check those\n+    // manually.\n+    match *structure_of(fcx, callee.span, callee_type) {\n+        ty::ty_bare_fn(_) | ty::ty_closure(_) => return false,\n+        _ => {}\n+    }\n+\n     // Try `FnOnce`, then `FnMut`, then `Fn`.\n     for &(maybe_function_trait, method_name) in [\n         (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n@@ -3409,10 +3416,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprStruct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n-        match def {\n+        let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, _)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, fields.as_slice());\n+                enum_id\n             }\n             Some(def) => {\n                 // Verify that this was actually a struct.\n@@ -3432,11 +3440,47 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                             pprust::path_to_string(path));\n                     }\n                 }\n+\n+                def.def_id()\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span,\n                                   \"structure constructor wasn't resolved\")\n             }\n+        };\n+\n+        // Turn the path into a type and verify that that type unifies with\n+        // the resulting structure type. This is needed to handle type\n+        // parameters correctly.\n+        let actual_structure_type = fcx.expr_ty(&*expr);\n+        if !ty::type_is_error(actual_structure_type) {\n+            let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n+                                                                  fcx.infcx(),\n+                                                                  struct_id,\n+                                                                  path);\n+            match fcx.mk_subty(false,\n+                               infer::Misc(path.span),\n+                               actual_structure_type,\n+                               type_and_substs.ty) {\n+                Ok(()) => {}\n+                Err(type_error) => {\n+                    let type_error_description =\n+                        ty::type_err_to_str(tcx, &type_error);\n+                    fcx.tcx()\n+                       .sess\n+                       .span_err(path.span,\n+                                 format!(\"structure constructor specifies a \\\n+                                         structure of type `{}`, but this \\\n+                                         structure has type `{}`: {}\",\n+                                         fcx.infcx()\n+                                            .ty_to_string(type_and_substs.ty),\n+                                         fcx.infcx()\n+                                            .ty_to_string(\n+                                                actual_structure_type),\n+                                         type_error_description).as_slice());\n+                    ty::note_and_explain_type_err(tcx, &type_error);\n+                }\n+            }\n         }\n       }\n       ast::ExprField(ref base, ref field, ref tys) => {"}, {"sha": "57cda6c48178a3d42ab98c2b0b079b16b5780323", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -779,7 +779,6 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n-            ast::SelfUniq(_) => SelfOwned,\n             ast::SelfRegion(lt, mt, _) => {\n                 SelfBorrowed(lt.clean(), mt.clean())\n             }"}, {"sha": "e7f9370339922d3ae5abf583e0f84eee999c7879", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -491,7 +491,7 @@ impl<'a> fmt::Show for Method<'a> {\n         match *selfty {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n-            clean::SelfOwned => args.push_str(\"~self\"),\n+            clean::SelfOwned => args.push_str(\"self: Box<Self>\"),\n             clean::SelfBorrowed(Some(ref lt), mtbl) => {\n                 args.push_str(format!(\"&amp;{} {}self\", *lt,\n                                       MutableSpace(mtbl)).as_slice());"}, {"sha": "97fa58d50777401da65ee74765eb8073c2384319", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -32,6 +32,7 @@ use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::slice;\n use std::str;\n+use std::string;\n use std::collections::HashMap;\n \n use html::toc::TocBuilder;\n@@ -222,7 +223,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             \"\".to_string()\n         } else {\n             unsafe {\n-                str::raw::from_buf_len((*text).data, (*text).size as uint)\n+                string::raw::from_buf_len((*text).data, (*text).size as uint)\n             }\n         };\n "}, {"sha": "39b2511fde4f3e49ea6756224d8a8fbcb1f5564a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -102,6 +102,7 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n         optopt(\"w\", \"output-format\", \"the output type to write\",\n                \"[html|json]\"),\n         optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n+        optopt(\"\", \"crate-name\", \"specify the name of this crate\", \"NAME\"),\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\"),\n@@ -131,7 +132,8 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n                  Markdown file or generated documentation\",\n                  \"FILES\"),\n         optopt(\"\", \"markdown-playground-url\",\n-               \"URL to send code snippets to\", \"URL\")\n+               \"URL to send code snippets to\", \"URL\"),\n+        optflag(\"\", \"markdown-no-toc\", \"don't include table of contents\")\n     )\n }\n \n@@ -220,7 +222,8 @@ pub fn main_args(args: &[String]) -> int {\n             return test::run(input, cfgs, libs, externs, test_args)\n         }\n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n-                                                 &matches, &external_html),\n+                                                 &matches, &external_html,\n+                                                 !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n     }\n \n@@ -321,7 +324,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (krate, analysis) = std::task::try(proc() {\n+    let (mut krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n         core::run_core(libs.move_iter().collect(),\n                        cfgs,\n@@ -331,6 +334,11 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     info!(\"finished with rustc\");\n     analysiskey.replace(Some(analysis));\n \n+    match matches.opt_str(\"crate-name\") {\n+        Some(name) => krate.name = name,\n+        None => {}\n+    }\n+\n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n     match krate.module.get_ref().doc_list() {"}, {"sha": "29da9462c7f57163fa6b9802d7add6bb2ca9e278", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -20,7 +20,7 @@ use externalfiles::ExternalHtml;\n \n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{MarkdownWithToc, find_testable_code, reset_headers};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code, reset_headers};\n use test::Collector;\n \n /// Separate any lines at the start of the file that begin with `%`.\n@@ -42,7 +42,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n-              external_html: &ExternalHtml) -> int {\n+              external_html: &ExternalHtml, include_toc: bool) -> int {\n     let input_p = Path::new(input);\n     output.push(input_p.filestem().unwrap());\n     output.set_extension(\"html\");\n@@ -80,6 +80,12 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n \n     reset_headers();\n \n+    let rendered = if include_toc {\n+        format!(\"{}\", MarkdownWithToc(text))\n+    } else {\n+        format!(\"{}\", Markdown(text))\n+    };\n+\n     let err = write!(\n         &mut out,\n         r#\"<!DOCTYPE html>\n@@ -113,7 +119,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n         css = css,\n         in_header = external_html.in_header,\n         before_content = external_html.before_content,\n-        text = MarkdownWithToc(text),\n+        text = rendered,\n         after_content = external_html.after_content,\n         playground = playground,\n         );"}, {"sha": "5dd61c03d17e75b053eabff31b5baecde5e91ca9", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 20, "deletions": 108, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -70,6 +70,7 @@ use core::prelude::*;\n use alloc::libc_heap::malloc_raw;\n use collections::string::String;\n use collections::hash;\n+use core::fmt;\n use core::kinds::marker;\n use core::mem;\n use core::ptr;\n@@ -92,23 +93,18 @@ impl Clone for CString {\n     /// reasons, this is always a deep clone, rather than the usual shallow\n     /// clone.\n     fn clone(&self) -> CString {\n-        if self.buf.is_null() {\n-            CString { buf: self.buf, owns_buffer_: self.owns_buffer_ }\n-        } else {\n-            let len = self.len() + 1;\n-            let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n-            unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n-            CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n-        }\n+        let len = self.len() + 1;\n+        let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n+        unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n+        CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n     }\n }\n \n impl PartialEq for CString {\n     fn eq(&self, other: &CString) -> bool {\n+        // Check if the two strings share the same buffer\n         if self.buf as uint == other.buf as uint {\n             true\n-        } else if self.buf.is_null() || other.buf.is_null() {\n-            false\n         } else {\n             unsafe {\n                 libc::strcmp(self.buf, other.buf) == 0\n@@ -135,7 +131,12 @@ impl<S: hash::Writer> hash::Hash<S> for CString {\n \n impl CString {\n     /// Create a C String from a pointer.\n+    ///\n+    ///# Failure\n+    ///\n+    /// Fails if `buf` is null\n     pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n+        assert!(!buf.is_null());\n         CString { buf: buf, owns_buffer_: owns_buffer }\n     }\n \n@@ -157,10 +158,6 @@ impl CString {\n     /// let p = foo.to_c_str().as_ptr();\n     /// ```\n     ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n-    ///\n     /// # Example\n     ///\n     /// ```rust\n@@ -174,8 +171,6 @@ impl CString {\n     /// }\n     /// ```\n     pub fn as_ptr(&self) -> *const libc::c_char {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n-\n         self.buf\n     }\n \n@@ -196,44 +191,30 @@ impl CString {\n     /// // wrong (the CString will be freed, invalidating `p`)\n     /// let p = foo.to_c_str().as_mut_ptr();\n     /// ```\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n-        if self.buf.is_null() { fail!(\"CString is null!\") }\n-\n         self.buf as *mut _\n     }\n \n     /// Calls a closure with a reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[deprecated=\"use `.as_ptr()`\"]\n     pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n     /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[deprecated=\"use `.as_mut_ptr()`\"]\n     pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf as *mut libc::c_char)\n     }\n \n     /// Returns true if the CString is a null.\n+    #[deprecated=\"a CString cannot be null\"]\n     pub fn is_null(&self) -> bool {\n         self.buf.is_null()\n     }\n \n     /// Returns true if the CString is not null.\n+    #[deprecated=\"a CString cannot be null\"]\n     pub fn is_not_null(&self) -> bool {\n         self.buf.is_not_null()\n     }\n@@ -245,51 +226,32 @@ impl CString {\n \n     /// Converts the CString into a `&[u8]` without copying.\n     /// Includes the terminating NUL byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             mem::transmute(Slice { data: self.buf, len: self.len() + 1 })\n         }\n     }\n \n     /// Converts the CString into a `&[u8]` without copying.\n     /// Does not include the terminating NUL byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             mem::transmute(Slice { data: self.buf, len: self.len() })\n         }\n     }\n \n     /// Converts the CString into a `&str` without copying.\n     /// Returns None if the CString is not UTF-8.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n         let buf = self.as_bytes_no_nul();\n         str::from_utf8(buf)\n     }\n \n     /// Return a CString iterator.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     pub fn iter<'a>(&'a self) -> CChars<'a> {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         CChars {\n             ptr: self.buf,\n             marker: marker::ContravariantLifetime,\n@@ -325,13 +287,8 @@ impl Drop for CString {\n \n impl Collection for CString {\n     /// Return the number of bytes in the CString (not including the NUL terminator).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     fn len(&self) -> uint {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         let mut cur = self.buf;\n         let mut len = 0;\n         unsafe {\n@@ -344,6 +301,12 @@ impl Collection for CString {\n     }\n }\n \n+impl fmt::Show for CString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        String::from_utf8_lossy(self.as_bytes_no_nul()).fmt(f)\n+    }\n+}\n+\n /// A generic trait for converting a value to a CString.\n pub trait ToCStr {\n     /// Copy the receiver into a CString.\n@@ -624,13 +587,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_is_null() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        assert!(c_str.is_null());\n-        assert!(!c_str.is_not_null());\n-    }\n-\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n@@ -641,16 +597,8 @@ mod tests {\n     fn test_as_ptr() {\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { libc::strlen(c_str.as_ptr()) };\n-        assert!(!c_str.is_null());\n-        assert!(c_str.is_not_null());\n         assert_eq!(len, 5);\n     }\n-    #[test]\n-    #[should_fail]\n-    fn test_as_ptr_empty_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_ptr();\n-    }\n \n     #[test]\n     fn test_iterator() {\n@@ -709,20 +657,6 @@ mod tests {\n         assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_as_bytes_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_bytes();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_as_bytes_no_nul_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_bytes_no_nul();\n-    }\n-\n     #[test]\n     fn test_as_str() {\n         let c_str = \"hello\".to_c_str();\n@@ -735,23 +669,8 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_as_str_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_str();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_len_fail() {\n+    fn test_new_fail() {\n         let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.len();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_iter_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.iter();\n     }\n \n     #[test]\n@@ -784,13 +703,6 @@ mod tests {\n         // force a copy, reading the memory\n         c_.as_bytes().to_vec();\n     }\n-\n-    #[test]\n-    fn test_clone_eq_null() {\n-        let x = unsafe { CString::new(ptr::null(), false) };\n-        let y = x.clone();\n-        assert!(x == y);\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "e2d7f91d1a6f9b4bc258886d430c0d2d967e9968", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -74,15 +74,17 @@ pub mod unwind;\n pub trait Runtime {\n     // Necessary scheduling functions, used for channels and blocking I/O\n     // (sometimes).\n-    fn yield_now(~self, cur_task: Box<Task>);\n-    fn maybe_yield(~self, cur_task: Box<Task>);\n-    fn deschedule(~self, times: uint, cur_task: Box<Task>,\n+    fn yield_now(self: Box<Self>, cur_task: Box<Task>);\n+    fn maybe_yield(self: Box<Self>, cur_task: Box<Task>);\n+    fn deschedule(self: Box<Self>,\n+                  times: uint,\n+                  cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>);\n-    fn reawaken(~self, to_wake: Box<Task>);\n+    fn reawaken(self: Box<Self>, to_wake: Box<Task>);\n \n     // Miscellaneous calls which are very different depending on what context\n     // you're in.\n-    fn spawn_sibling(~self,\n+    fn spawn_sibling(self: Box<Self>,\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send);\n@@ -92,7 +94,7 @@ pub trait Runtime {\n     fn can_block(&self) -> bool;\n \n     // FIXME: This is a serious code smell and this should not exist at all.\n-    fn wrap(~self) -> Box<Any>;\n+    fn wrap(self: Box<Self>) -> Box<Any>;\n }\n \n /// The default error code of the rust runtime if the main task fails instead"}, {"sha": "134453659dbf6740de949a95104e3d87c0a84d96", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -238,7 +238,7 @@ pub trait IoFactory {\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(~self) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n+    fn listen(self: Box<Self>) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n@@ -329,7 +329,7 @@ pub trait RtioPipe {\n }\n \n pub trait RtioUnixListener {\n-    fn listen(~self) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n+    fn listen(self: Box<Self>) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n }\n \n pub trait RtioUnixAcceptor {"}, {"sha": "d27a4f25b4e70ce60cd7a96091ea65431a19a606", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -203,7 +203,7 @@ impl Task {\n     /// }).destroy();\n     /// # }\n     /// ```\n-    pub fn run(~self, f: ||) -> Box<Task> {\n+    pub fn run(self: Box<Task>, f: ||) -> Box<Task> {\n         assert!(!self.is_destroyed(), \"cannot re-use a destroyed task\");\n \n         // First, make sure that no one else is in TLS. This does not allow\n@@ -239,7 +239,7 @@ impl Task {\n     ///\n     /// The returned task cannot be used for running any more code, but it may\n     /// be used to extract the runtime as necessary.\n-    pub fn destroy(~self) -> Box<Task> {\n+    pub fn destroy(self: Box<Task>) -> Box<Task> {\n         if self.is_destroyed() {\n             self\n         } else {\n@@ -252,7 +252,7 @@ impl Task {\n     /// This function consumes ownership of the task, deallocating it once it's\n     /// done being processed. It is assumed that TLD and the local heap have\n     /// already been destroyed and/or annihilated.\n-    fn cleanup(~self, result: Result) -> Box<Task> {\n+    fn cleanup(self: Box<Task>, result: Result) -> Box<Task> {\n         // The first thing to do when cleaning up is to deallocate our local\n         // resources, such as TLD and GC data.\n         //\n@@ -394,15 +394,18 @@ impl Task {\n \n     /// Spawns a sibling to this task. The newly spawned task is configured with\n     /// the `opts` structure and will run `f` as the body of its code.\n-    pub fn spawn_sibling(mut ~self, opts: TaskOpts, f: proc(): Send) {\n+    pub fn spawn_sibling(mut self: Box<Task>,\n+                         opts: TaskOpts,\n+                         f: proc(): Send) {\n         let ops = self.imp.take_unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }\n \n     /// Deschedules the current task, invoking `f` `amt` times. It is not\n     /// recommended to use this function directly, but rather communication\n     /// primitives in `std::comm` should be used.\n-    pub fn deschedule(mut ~self, amt: uint,\n+    pub fn deschedule(mut self: Box<Task>,\n+                      amt: uint,\n                       f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n         let ops = self.imp.take_unwrap();\n         ops.deschedule(amt, self, f)\n@@ -411,22 +414,22 @@ impl Task {\n     /// Wakes up a previously blocked task, optionally specifying whether the\n     /// current task can accept a change in scheduling. This function can only\n     /// be called on tasks that were previously blocked in `deschedule`.\n-    pub fn reawaken(mut ~self) {\n+    pub fn reawaken(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.reawaken(self);\n     }\n \n     /// Yields control of this task to another task. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n     /// opportunity to allow other tasks a chance to run.\n-    pub fn yield_now(mut ~self) {\n+    pub fn yield_now(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.yield_now(self);\n     }\n \n     /// Similar to `yield_now`, except that this function may immediately return\n     /// without yielding (depending on what the runtime decides to do).\n-    pub fn maybe_yield(mut ~self) {\n+    pub fn maybe_yield(mut self: Box<Task>) {\n         let ops = self.imp.take_unwrap();\n         ops.maybe_yield(self);\n     }"}, {"sha": "24b8c29785804920ccd43c49cfd854bf220f0afb", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -58,11 +58,11 @@ use libc::{c_int, c_void};\n use std::fmt;\n use std::mem;\n use std::ptr;\n+use std::string;\n use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n use std::rt::task::{BlockedTask, Task};\n-use std::str::raw::from_c_str;\n use std::task;\n \n pub use self::async::AsyncWatcher;\n@@ -154,7 +154,7 @@ pub trait UvHandle<T> {\n         mem::transmute(uvll::get_data_for_uv_handle(*h))\n     }\n \n-    fn install(~self) -> Box<Self> {\n+    fn install(self: Box<Self>) -> Box<Self> {\n         unsafe {\n             let myptr = mem::transmute::<&Box<Self>, &*mut u8>(&self);\n             uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n@@ -363,7 +363,7 @@ impl UvError {\n             let inner = match self { &UvError(a) => a };\n             let name_str = uvll::uv_err_name(inner);\n             assert!(name_str.is_not_null());\n-            from_c_str(name_str).to_string()\n+            string::raw::from_buf(name_str as *const u8)\n         }\n     }\n \n@@ -372,7 +372,7 @@ impl UvError {\n             let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::uv_strerror(inner);\n             assert!(desc_str.is_not_null());\n-            from_c_str(desc_str).to_string()\n+            string::raw::from_buf(desc_str as *const u8)\n         }\n     }\n "}, {"sha": "3cc10ae3823ac56a545d4e6fa4e014ebeccba299", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -389,7 +389,8 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(~self) -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n+    fn listen(self: Box<TcpListener>)\n+              -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box TcpAcceptor {\n             listener: self,"}, {"sha": "f0a57546ed43ee1f94b469038561ce6b31468fa0", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -248,7 +248,8 @@ impl PipeListener {\n }\n \n impl rtio::RtioUnixListener for PipeListener {\n-    fn listen(~self) -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+    fn listen(self: Box<PipeListener>)\n+              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n         // create the acceptor object from ourselves\n         let mut acceptor = box PipeAcceptor {\n             listener: self,"}, {"sha": "9a30e87647a83b9fb9f28d2dfdaf325789d5467f", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -11,8 +11,8 @@\n // ignore-lexer-test FIXME #15679\n \n //! Base64 binary-to-text encoding\n-use std::str;\n use std::fmt;\n+use std::string;\n \n /// Available encoding character sets\n pub enum CharacterSet {\n@@ -148,7 +148,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            string::raw::from_utf8(v)\n         }\n     }\n }"}, {"sha": "fa5b3ca4040d0bb29feedd24cf9279da7189f5df", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -11,8 +11,8 @@\n // ignore-lexer-test FIXME #15679\n \n //! Hex binary-to-text encoding\n-use std::str;\n use std::fmt;\n+use std::string;\n \n /// A trait for converting a value to hexadecimal encoding\n pub trait ToHex {\n@@ -47,7 +47,7 @@ impl<'a> ToHex for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v)\n+            string::raw::from_utf8(v)\n         }\n     }\n }"}, {"sha": "bcc0761d92a3a75a90861183df084847d9d47c8c", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -20,7 +20,7 @@ use iter::Iterator;\n use mem;\n use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n-use str::{OwnedStr, Str, StrAllocating, StrSlice};\n+use str::{Str, StrAllocating, StrSlice};\n use string::String;\n use to_string::IntoStr;\n use vec::Vec;"}, {"sha": "ebcb60253f59cedbab80ce92bfde482d452e6e23", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -47,7 +47,6 @@ use ptr;\n use result::{Err, Ok, Result};\n use slice::{Vector, ImmutableVector, MutableVector, ImmutableEqVector};\n use str::{Str, StrSlice, StrAllocating};\n-use str;\n use string::String;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use vec::Vec;\n@@ -56,8 +55,6 @@ use vec::Vec;\n use c_str::ToCStr;\n #[cfg(unix)]\n use libc::c_char;\n-#[cfg(windows)]\n-use str::OwnedStr;\n \n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n@@ -137,7 +134,7 @@ pub fn getcwd() -> Path {\n             fail!();\n         }\n     }\n-    Path::new(String::from_utf16(str::truncate_utf16_at_nul(buf))\n+    Path::new(String::from_utf16(::str::truncate_utf16_at_nul(buf))\n               .expect(\"GetCurrentDirectoryW returned invalid UTF-16\"))\n }\n \n@@ -415,7 +412,7 @@ pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     fn _setenv(n: &str, v: &[u8]) {\n         let n: Vec<u16> = n.utf16_units().collect();\n         let n = n.append_one(0);\n-        let v: Vec<u16> = str::from_utf8(v).unwrap().utf16_units().collect();\n+        let v: Vec<u16> = ::str::from_utf8(v).unwrap().utf16_units().collect();\n         let v = v.append_one(0);\n \n         unsafe {\n@@ -708,8 +705,6 @@ pub fn self_exe_name() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn load_self() -> Option<Vec<u8>> {\n-        use str::OwnedStr;\n-\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n             fill_utf16_buf_and_decode(|buf, sz| {\n@@ -1002,7 +997,7 @@ pub fn error_string(errnum: uint) -> String {\n                 fail!(\"strerror_r failure\");\n             }\n \n-            str::raw::from_c_str(p as *const c_char).into_string()\n+            ::string::raw::from_buf(p as *const u8)\n         }\n     }\n \n@@ -1049,7 +1044,7 @@ pub fn error_string(errnum: uint) -> String {\n                 return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n             }\n \n-            let msg = String::from_utf16(str::truncate_utf16_at_nul(buf));\n+            let msg = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n             match msg {\n                 Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n                 None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n@@ -1206,7 +1201,7 @@ fn real_args() -> Vec<String> {\n \n         // Push it onto the list.\n         let opt_s = slice::raw::buf_as_slice(ptr as *const _, len, |buf| {\n-            String::from_utf16(str::truncate_utf16_at_nul(buf))\n+            String::from_utf16(::str::truncate_utf16_at_nul(buf))\n         });\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });"}, {"sha": "96d5c0785f47774650696b43ad0b9f9ef2816983", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -76,7 +76,7 @@\n #[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n #[doc(no_inline)] pub use ptr::RawPtr;\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n-#[doc(no_inline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n+#[doc(no_inline)] pub use str::{Str, StrVector, StrSlice};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrSlice};\n #[doc(no_inline)] pub use to_string::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};"}, {"sha": "f05d17569f68d82760630b147b018d246b39626f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -955,8 +955,6 @@ pub enum ExplicitSelf_ {\n     SelfValue(Ident),\n     /// `&'lt self`, `&'lt mut self`\n     SelfRegion(Option<Lifetime>, Mutability, Ident),\n-    /// `~self`\n-    SelfUniq(Ident),\n     /// `self: TYPE`\n     SelfExplicit(P<Ty>, Ident),\n }"}, {"sha": "f48306bc6ee2fbfd6b5d96e14b2d9e94415d1f6e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -340,7 +340,7 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue(_) | SelfUniq(_) => *es,\n+            SelfStatic | SelfValue(_) => *es,\n             SelfRegion(ref lifetime, m, id) => {\n                 SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n             }"}, {"sha": "afcf84753a612847e4de00b0e3483e7a58d523d6", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -31,6 +31,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteOwnedExpr,\n     ObsoleteOwnedPattern,\n     ObsoleteOwnedVector,\n+    ObsoleteOwnedSelf,\n     ObsoleteManagedType,\n     ObsoleteManagedExpr,\n }\n@@ -70,6 +71,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`~[T]` is no longer a type\",\n                 \"use the `Vec` type instead\"\n             ),\n+            ObsoleteOwnedSelf => (\n+                \"`~self` is no longer supported\",\n+                \"write `self: Box<Self>` instead\"\n+            ),\n             ObsoleteManagedType => (\n                 \"`@` notation for managed pointers\",\n                 \"use `Gc<T>` in `std::gc` instead\""}, {"sha": "0116518d537a75dee4ddb72c2dc878c26683583a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -45,7 +45,7 @@ use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n-use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfUniq, SelfValue};\n+use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n@@ -3826,10 +3826,11 @@ impl<'a> Parser<'a> {\n                 // We need to make sure it isn't a type\n                 if self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                     self.bump();\n-                    SelfUniq(self.expect_self_ident())\n-                } else {\n-                    SelfStatic\n+                    drop(self.expect_self_ident());\n+                    let last_span = self.last_span;\n+                    self.obsolete(last_span, ObsoleteOwnedSelf)\n                 }\n+                SelfStatic\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n                 let self_ident = self.expect_self_ident();\n@@ -3877,7 +3878,10 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n                 self.bump();\n-                SelfUniq(self.expect_self_ident())\n+                drop(self.expect_self_ident());\n+                let last_span = self.last_span;\n+                self.obsolete(last_span, ObsoleteOwnedSelf);\n+                SelfStatic\n             }\n             _ => SelfStatic\n         };\n@@ -3921,7 +3925,6 @@ impl<'a> Parser<'a> {\n             }\n             SelfValue(id) => parse_remaining_arguments!(id),\n             SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n-            SelfUniq(id) => parse_remaining_arguments!(id),\n             SelfExplicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n@@ -4042,7 +4045,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n-                    already_parsed_attrs: Option<Vec<Attribute>>) -> Gc<Method> {\n+                        already_parsed_attrs: Option<Vec<Attribute>>)\n+                        -> Gc<Method> {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -4080,6 +4084,11 @@ impl<'a> Parser<'a> {\n                 let visa = self.parse_visibility();\n                 let abi = if self.eat_keyword(keywords::Extern) {\n                     self.parse_opt_abi().unwrap_or(abi::C)\n+                } else if attr::contains_name(attrs.as_slice(),\n+                                              \"rust_call_abi_hack\") {\n+                    // FIXME(stage0, pcwalton): Remove this awful hack after a\n+                    // snapshot, and change to `extern \"rust-call\" fn`.\n+                    abi::RustCall\n                 } else {\n                     abi::Rust\n                 };"}, {"sha": "ac8355651916e0a5c03b2b4d9da6c5cc6c994f83", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1892,9 +1892,6 @@ impl<'a> State<'a> {\n             ast::SelfValue(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfUniq(_) => {\n-                try!(word(&mut self.s, \"~self\"));\n-            }\n             ast::SelfRegion(ref lt, m, _) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lt));"}, {"sha": "371fae53b41d06bc20390d5633a1111f2707a652", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -216,7 +216,7 @@ pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    explicit_self: &ExplicitSelf,\n                                                    env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) | SelfUniq(_) => {},\n+        SelfStatic | SelfValue(_) => {},\n         SelfRegion(ref lifetime, _, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }"}, {"sha": "cd24b5c6633b27df2b84249a65a46a610b734494", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1 +1 @@\n-Subproject commit d66318a4aae089bae5c3c38ee42daaa1bd8fadb7\n+Subproject commit cd24b5c6633b27df2b84249a65a46a610b734494"}, {"sha": "a4437ea7c7b49f6aac87222962fe4a6c4ffa7020", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -658,13 +658,14 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n #if LLVM_VERSION_MINOR >= 5\n extern \"C\" void*\n LLVMRustOpenArchive(char *path) {\n-    std::unique_ptr<MemoryBuffer> buf;\n-    std::error_code err = MemoryBuffer::getFile(path, buf);\n-    if (err) {\n-        LLVMRustSetLastError(err.message().c_str());\n+    ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path);\n+    if (!buf_or) {\n+        LLVMRustSetLastError(buf_or.getError().message().c_str());\n         return NULL;\n     }\n-    Archive *ret = new Archive(buf.release(), err);\n+\n+    std::error_code err;\n+    Archive *ret = new Archive(std::move(buf_or.get()), err);\n     if (err) {\n         LLVMRustSetLastError(err.message().c_str());\n         return NULL;"}, {"sha": "bdc5bfdc10a3ab22d13bd14ee355d18ccb26a845", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2014-07-21\n+2014-07-22"}, {"sha": "2c8bbee783bd3e409253f0d3f5a7fec7165f42e2", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n+\n+type PointF = Point<f32>;\n+\n+struct Pair<T,U> {\n+    x: T,\n+    y: U,\n+}\n+\n+type PairF<U> = Pair<f32,U>;\n+\n+fn main() {\n+    let pt = PointF {\n+        //~^ ERROR expected f32 but found int\n+        x: 1i,\n+        y: 2i,\n+    };\n+\n+    let pt2 = Point::<f32> {\n+        //~^ ERROR expected f32 but found int\n+        x: 3i,\n+        y: 4i,\n+    };\n+\n+    let pair = PairF {\n+        //~^ ERROR expected f32 but found int\n+        x: 5i,\n+        y: 6i,\n+    };\n+\n+    let pair2 = PairF::<int> {\n+        //~^ ERROR expected f32 but found int\n+        x: 7i,\n+        y: 8i,\n+    };\n+\n+    let pt3 = PointF::<int> {\n+        //~^ ERROR wrong number of type arguments\n+        x: 9i,\n+        y: 10i,\n+    };\n+}\n+"}, {"sha": "37c551734defbb9dc546fce335861d8f9cb17d60", "filename": "src/test/run-pass/bare-fn-implements-fn-mut.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+use std::ops::FnMut;\n+\n+fn call_f<F:FnMut<(),()>>(mut f: F) {\n+    f();\n+}\n+\n+fn f() {\n+    println!(\"hello\");\n+}\n+\n+fn call_g<G:FnMut<(String,String),String>>(mut g: G, x: String, y: String)\n+          -> String {\n+    g(x, y)\n+}\n+\n+fn g(x: String, y: String) -> String {\n+    x.append(y.as_slice())\n+}\n+\n+fn main() {\n+    call_f(f);\n+    assert_eq!(call_g(g, \"foo\".to_string(), \"bar\".to_string()).as_slice(),\n+               \"foobar\");\n+}\n+"}, {"sha": "0fef3dd4aac24937dc794d4a57425307fac2579a", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=4461f03a36a7a2d0ce2d6e3b50c92a7d75ccb40d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n+use std::{str, string};\n \n static A: [u8, ..2] = ['h' as u8, 'i' as u8];\n static B: &'static [u8, ..2] = &A;\n@@ -18,12 +18,12 @@ pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;\n         assert_eq!(str::raw::from_utf8(A), \"hi\");\n-        assert_eq!(str::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n-        assert_eq!(str::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n+        assert_eq!(string::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n+        assert_eq!(string::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *const u8) == A[0]);\n \n         let bar = str::raw::from_utf8(A).to_c_str();\n-        assert_eq!(str::raw::from_c_str(bar.as_ptr()), \"hi\".to_string());\n+        assert_eq!(bar.as_str(), \"hi\".to_c_str().as_str());\n     }\n }"}]}