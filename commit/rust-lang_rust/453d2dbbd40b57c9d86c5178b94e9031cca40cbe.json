{"sha": "453d2dbbd40b57c9d86c5178b94e9031cca40cbe", "node_id": "C_kwDOAAsO6NoAKDQ1M2QyZGJiZDQwYjU3YzlkODZjNTE3OGI5NGU5MDMxY2NhNDBjYmU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T08:08:17Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T17:17:09Z"}, "message": "check all GATs at once", "tree": {"sha": "e37aef3eeab6ea36c60456c87efbbb2309e8242a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37aef3eeab6ea36c60456c87efbbb2309e8242a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/453d2dbbd40b57c9d86c5178b94e9031cca40cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/453d2dbbd40b57c9d86c5178b94e9031cca40cbe", "html_url": "https://github.com/rust-lang/rust/commit/453d2dbbd40b57c9d86c5178b94e9031cca40cbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/453d2dbbd40b57c9d86c5178b94e9031cca40cbe/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764839320c247b813528533c79d4b25a4f55f5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/764839320c247b813528533c79d4b25a4f55f5fd", "html_url": "https://github.com/rust-lang/rust/commit/764839320c247b813528533c79d4b25a4f55f5fd"}], "stats": {"total": 189, "additions": 90, "deletions": 99}, "files": [{"sha": "d05c96da3317448b2b7987d5c3b5785122c08244", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 90, "deletions": 99, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/453d2dbbd40b57c9d86c5178b94e9031cca40cbe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453d2dbbd40b57c9d86c5178b94e9031cca40cbe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=453d2dbbd40b57c9d86c5178b94e9031cca40cbe", "patch": "@@ -3,7 +3,7 @@ use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -258,145 +258,131 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .emit();\n         }\n     }\n-\n-    check_gat_where_clauses(tcx, trait_item, encl_trait_def_id);\n }\n \n /// Require that the user writes where clauses on GATs for the implicit\n /// outlives bounds involving trait parameters in trait functions and\n /// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n-///\n-/// This trait will be our running example. We are currently WF checking the `Item` item...\n-///\n-/// ```rust\n-/// trait LendingIterator {\n-///   type Item<'me>; // <-- WF checking this trait item\n-///\n-///   fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n-/// }\n /// ```\n-fn check_gat_where_clauses(tcx: TyCtxt<'_>, gat_hir: &hir::TraitItem<'_>, gat_def_id: DefId) {\n-    let gat_item = tcx.associated_item(gat_def_id);\n-    let gat_def_id = gat_hir.def_id;\n-    // If the current trait item isn't a type, it isn't a GAT\n-    if !matches!(gat_item.kind, ty::AssocKind::Type) {\n-        return;\n-    }\n-    let gat_generics: &ty::Generics = tcx.generics_of(gat_def_id);\n-    // If the current associated type doesn't have any (own) params, it's not a GAT\n-    // FIXME(jackh726): we can also warn in the more general case\n-    if gat_generics.params.len() == 0 {\n-        return;\n-    }\n-    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(gat_def_id);\n-    let mut clauses: Option<FxHashSet<ty::Predicate<'_>>> = None;\n-    // For every function in this trait...\n-    // In our example, this would be the `next` method\n-    for item in\n-        associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n-    {\n-        let item_hir_id = hir::HirId::make_owner(item.def_id.expect_local());\n-        let param_env = tcx.param_env(item.def_id.expect_local());\n+fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRef]) {\n+    let mut required_bounds_by_item = FxHashMap::default();\n+\n+    for gat_item in associated_items {\n+        let gat_def_id = gat_item.id.def_id;\n+        let gat_item = tcx.associated_item(gat_def_id);\n+        // If this item is not an assoc ty, or has no substs, then it's not a GAT\n+        if gat_item.kind != ty::AssocKind::Type {\n+            continue;\n+        }\n+        let gat_generics = tcx.generics_of(gat_def_id);\n+        if gat_generics.params.is_empty() {\n+            continue;\n+        }\n \n-        // Get the signature using placeholders. In our example, this would\n-        // convert the late-bound 'a into a free region.\n-        let sig = tcx.liberate_late_bound_regions(item.def_id, tcx.fn_sig(item.def_id));\n+        let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n+        for item in associated_items {\n+            if !matches!(&item.kind, hir::AssocItemKind::Fn { .. }) {\n+                // FIXME: next commit will add items...\n+                continue;\n+            }\n \n-        // The types we can assume to be well-formed. In our example, this\n-        // would be &'a mut Self, from the first argument.\n-        let mut wf_tys = FxHashSet::default();\n-        wf_tys.extend(sig.inputs());\n+            let item_def_id = item.id.def_id;\n+            // Skip our own GAT, since it would blow away the required bounds\n+            if item_def_id == gat_def_id {\n+                continue;\n+            }\n \n-        // The clauses we that we would require from this function\n-        let function_clauses = gather_gat_bounds(\n-            tcx,\n-            param_env,\n-            item_hir_id,\n-            sig.output(),\n-            &wf_tys,\n-            gat_def_id,\n-            gat_generics,\n-        );\n+            let item_hir_id = item.id.hir_id();\n+            let param_env = tcx.param_env(item_def_id);\n \n-        if let Some(function_clauses) = function_clauses {\n-            // Imagine we have:\n-            // ```\n-            // trait Foo {\n-            //   type Bar<'me>;\n-            //   fn gimme(&self) -> Self::Bar<'_>;\n-            //   fn gimme_default(&self) -> Self::Bar<'static>;\n-            // }\n-            // ```\n-            // We only want to require clauses on `Bar` that we can prove from *all* functions (in this\n-            // case, `'me` can be `static` from `gimme_default`)\n-            match clauses.as_mut() {\n-                Some(clauses) => {\n-                    clauses.drain_filter(|p| !function_clauses.contains(p));\n-                }\n-                None => {\n-                    clauses = Some(function_clauses);\n+            // Get the signature using placeholders. In our example, this would\n+            // convert the late-bound 'a into a free region.\n+            let sig = tcx.liberate_late_bound_regions(\n+                item_def_id.to_def_id(),\n+                tcx.fn_sig(item_def_id.to_def_id()),\n+            );\n+\n+            // The types we can assume to be well-formed. In our example, this\n+            // would be &'a mut Self, from the first argument.\n+            let mut wf_tys = FxHashSet::default();\n+            wf_tys.extend(sig.inputs());\n+\n+            // The clauses we that we would require from this function\n+            let item_required_bounds = gather_gat_bounds(\n+                tcx,\n+                param_env,\n+                item_hir_id,\n+                sig.output(),\n+                &wf_tys,\n+                gat_def_id,\n+                gat_generics,\n+            );\n+\n+            if let Some(item_required_bounds) = item_required_bounds {\n+                // Take the intersection of the new_required_bounds and the item_required_bounds\n+                // for this item. This is why we use an Option<_>, since we need to distinguish\n+                // the empty set of bounds from the uninitialized set of bounds.\n+                if let Some(new_required_bounds) = &mut new_required_bounds {\n+                    new_required_bounds.retain(|b| item_required_bounds.contains(b));\n+                } else {\n+                    new_required_bounds = Some(item_required_bounds);\n                 }\n             }\n         }\n+\n+        if let Some(required_bounds) = new_required_bounds {\n+            required_bounds_by_item.insert(gat_def_id, required_bounds);\n+        }\n     }\n \n-    // If there are any clauses that aren't provable, emit an error\n-    let clauses = clauses.unwrap_or_default();\n-    debug!(?clauses);\n-    if !clauses.is_empty() {\n+    for (gat_def_id, required_bounds) in required_bounds_by_item {\n+        let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id);\n+        debug!(?required_bounds);\n         let param_env = tcx.param_env(gat_def_id);\n+        let gat_hir = gat_item_hir.hir_id();\n \n-        let mut clauses: Vec<_> = clauses\n+        let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !region_known_to_outlive(\n-                        tcx,\n-                        gat_hir.hir_id(),\n-                        param_env,\n-                        &FxHashSet::default(),\n-                        a,\n-                        b,\n-                    )\n+                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n                 }\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(\n-                        tcx,\n-                        gat_hir.hir_id(),\n-                        param_env,\n-                        &FxHashSet::default(),\n-                        a,\n-                        b,\n-                    )\n+                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n                 }\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n-            .map(|clause| format!(\"{}\", clause))\n+            .map(|clause| clause.to_string())\n             .collect();\n \n         // We sort so that order is predictable\n-        clauses.sort();\n+        unsatisfied_bounds.sort();\n \n-        if !clauses.is_empty() {\n-            let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n+        if !unsatisfied_bounds.is_empty() {\n+            let plural = if unsatisfied_bounds.len() > 1 { \"s\" } else { \"\" };\n             let mut err = tcx.sess.struct_span_err(\n-                gat_hir.span,\n-                &format!(\"missing required bound{} on `{}`\", plural, gat_hir.ident),\n+                gat_item_hir.span,\n+                &format!(\"missing required bound{} on `{}`\", plural, gat_item_hir.ident),\n             );\n \n             let suggestion = format!(\n                 \"{} {}\",\n-                if !gat_hir.generics.where_clause.predicates.is_empty() { \",\" } else { \" where\" },\n-                clauses.join(\", \"),\n+                if !gat_item_hir.generics.where_clause.predicates.is_empty() {\n+                    \",\"\n+                } else {\n+                    \" where\"\n+                },\n+                unsatisfied_bounds.join(\", \"),\n             );\n             err.span_suggestion(\n-                gat_hir.generics.where_clause.tail_span_for_suggestion(),\n+                gat_item_hir.generics.where_clause.tail_span_for_suggestion(),\n                 &format!(\"add the required where clause{}\", plural),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n \n-            let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n+            let bound =\n+                if unsatisfied_bounds.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n             err.note(&format!(\n                 \"{} currently required to ensure that impls have maximum flexibility\",\n                 bound\n@@ -1025,6 +1011,11 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n \n         FxHashSet::default()\n     });\n+\n+    // Only check traits, don't check trait aliases\n+    if let hir::ItemKind::Trait(_, _, _, _, items) = item.kind {\n+        check_gat_where_clauses(tcx, items);\n+    }\n }\n \n /// Checks all associated type defaults of trait `trait_def_id`."}]}