{"sha": "e9c74bc42db1f811820bd829f99c023d3d007628", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5Yzc0YmM0MmRiMWY4MTE4MjBiZDgyOWY5OWMwMjNkM2QwMDc2Mjg=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-04-14T15:14:20Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-04-14T15:31:33Z"}, "message": "Use associated constants in core::num::dec2flt", "tree": {"sha": "6cf195de30aadb5e1b8e1df29dc7b040cd1db9a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf195de30aadb5e1b8e1df29dc7b040cd1db9a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c74bc42db1f811820bd829f99c023d3d007628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c74bc42db1f811820bd829f99c023d3d007628", "html_url": "https://github.com/rust-lang/rust/commit/e9c74bc42db1f811820bd829f99c023d3d007628", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c74bc42db1f811820bd829f99c023d3d007628/comments", "author": null, "committer": null, "parents": [{"sha": "4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "html_url": "https://github.com/rust-lang/rust/commit/4f32e0dfb287c2b3d0c48cb3b8090b3902960084"}], "stats": {"total": 251, "additions": 99, "deletions": 152}, "files": [{"sha": "80c2221ce641617c5be116dfe255f1bf1c0c8da6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e9c74bc42db1f811820bd829f99c023d3d007628", "patch": "@@ -70,6 +70,7 @@\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_type_defaults)]\n+#![feature(associated_consts)]\n #![feature(cfg_target_feature)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]"}, {"sha": "42bc46c0c683ecc15510e23b4e625ae473a0df38", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=e9c74bc42db1f811820bd829f99c023d3d007628", "patch": "@@ -106,17 +106,17 @@ mod fpu_precision {\n /// a bignum.\n pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n     let num_digits = integral.len() + fractional.len();\n-    // log_10(f64::max_sig) ~ 15.95. We compare the exact value to max_sig near the end,\n+    // log_10(f64::MAX_SIG) ~ 15.95. We compare the exact value to MAX_SIG near the end,\n     // this is just a quick, cheap rejection (and also frees the rest of the code from\n     // worrying about underflow).\n     if num_digits > 16 {\n         return None;\n     }\n-    if e.abs() >= T::ceil_log5_of_max_sig() as i64 {\n+    if e.abs() >= T::CEIL_LOG5_OF_MAX_SIG as i64 {\n         return None;\n     }\n     let f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\n-    if f > T::max_sig() {\n+    if f > T::MAX_SIG {\n         return None;\n     }\n \n@@ -154,14 +154,14 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n /// > the best possible approximation that uses p bits of significand.)\n pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n     let slop;\n-    if f <= &Big::from_u64(T::max_sig()) {\n+    if f <= &Big::from_u64(T::MAX_SIG) {\n         // The cases abs(e) < log5(2^N) are in fast_path()\n         slop = if e >= 0 { 0 } else { 3 };\n     } else {\n         slop = if e >= 0 { 1 } else { 4 };\n     }\n     let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n-    let exp_p_n = 1 << (P - T::sig_bits() as u32);\n+    let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n     let lowbits: i64 = (z.f % exp_p_n) as i64;\n     // Is the slop large enough to make a difference when\n     // rounding to n bits?\n@@ -210,14 +210,14 @@ fn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T {\n         if d2 < y {\n             let mut d2_double = d2;\n             d2_double.mul_pow2(1);\n-            if m == T::min_sig() && d_negative && d2_double > y {\n+            if m == T::MIN_SIG && d_negative && d2_double > y {\n                 z = prev_float(z);\n             } else {\n                 return z;\n             }\n         } else if d2 == y {\n             if m % 2 == 0 {\n-                if m == T::min_sig() && d_negative {\n+                if m == T::MIN_SIG && d_negative {\n                     z = prev_float(z);\n                 } else {\n                     return z;\n@@ -303,12 +303,12 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     quick_start::<T>(&mut u, &mut v, &mut k);\n     let mut rem = Big::from_small(0);\n     let mut x = Big::from_small(0);\n-    let min_sig = Big::from_u64(T::min_sig());\n-    let max_sig = Big::from_u64(T::max_sig());\n+    let min_sig = Big::from_u64(T::MIN_SIG);\n+    let max_sig = Big::from_u64(T::MAX_SIG);\n     loop {\n         u.div_rem(&v, &mut x, &mut rem);\n-        if k == T::min_exp_int() {\n-            // We have to stop at the minimum exponent, if we wait until `k < T::min_exp_int()`,\n+        if k == T::MIN_EXP_INT {\n+            // We have to stop at the minimum exponent, if we wait until `k < T::MIN_EXP_INT`,\n             // then we'd be off by a factor of two. Unfortunately this means we have to special-\n             // case normal numbers with the minimum exponent.\n             // FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure\n@@ -318,8 +318,8 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n             }\n             return underflow(x, v, rem);\n         }\n-        if k > T::max_exp_int() {\n-            return T::infinity2();\n+        if k > T::MAX_EXP_INT {\n+            return T::INFINITY;\n         }\n         if x < min_sig {\n             u.mul_pow2(1);\n@@ -345,18 +345,18 @@ fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The target ratio is one where u/v is in an in-range significand. Thus our termination\n     // condition is log2(u / v) being the significand bits, plus/minus one.\n     // FIXME Looking at the second bit could improve the estimate and avoid some more divisions.\n-    let target_ratio = T::sig_bits() as i16;\n+    let target_ratio = T::SIG_BITS as i16;\n     let log2_u = u.bit_length() as i16;\n     let log2_v = v.bit_length() as i16;\n     let mut u_shift: i16 = 0;\n     let mut v_shift: i16 = 0;\n     assert!(*k == 0);\n     loop {\n-        if *k == T::min_exp_int() {\n+        if *k == T::MIN_EXP_INT {\n             // Underflow or subnormal. Leave it to the main function.\n             break;\n         }\n-        if *k == T::max_exp_int() {\n+        if *k == T::MAX_EXP_INT {\n             // Overflow. Leave it to the main function.\n             break;\n         }\n@@ -376,7 +376,7 @@ fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n }\n \n fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n-    if x < Big::from_u64(T::min_sig()) {\n+    if x < Big::from_u64(T::MIN_SIG) {\n         let q = num::to_u64(&x);\n         let z = rawfp::encode_subnormal(q);\n         return round_by_remainder(v, rem, q, z);\n@@ -395,9 +395,9 @@ fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n     // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainder\n     // is zero, we have a half-to-even situation.\n     let bits = x.bit_length();\n-    let lsb = bits - T::sig_bits() as usize;\n+    let lsb = bits - T::SIG_BITS as usize;\n     let q = num::get_bits(&x, lsb, bits);\n-    let k = T::min_exp_int() + lsb as i16;\n+    let k = T::MIN_EXP_INT + lsb as i16;\n     let z = rawfp::encode_normal(Unpacked::new(q, k));\n     let q_even = q % 2 == 0;\n     match num::compare_with_half_ulp(&x, lsb) {"}, {"sha": "f353770a736e40eccd2a74ef9af92b0f103e6736", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=e9c74bc42db1f811820bd829f99c023d3d007628", "patch": "@@ -214,11 +214,11 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n         ParseResult::Valid(decimal) => convert(decimal)?,\n-        ParseResult::ShortcutToInf => T::infinity2(),\n-        ParseResult::ShortcutToZero => T::zero2(),\n+        ParseResult::ShortcutToInf => T::INFINITY,\n+        ParseResult::ShortcutToZero => T::ZERO,\n         ParseResult::Invalid => match s {\n-            \"inf\" => T::infinity2(),\n-            \"NaN\" => T::nan2(),\n+            \"inf\" => T::INFINITY,\n+            \"NaN\" => T::NAN,\n             _ => { return Err(pfe_invalid()); }\n         }\n     };\n@@ -254,7 +254,7 @@ fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, ParseFloatError> {\n     // FIXME These bounds are rather conservative. A more careful analysis of the failure modes\n     // of Bellerophon could allow using it in more cases for a massive speed up.\n     let exponent_in_range = table::MIN_E <= e && e <= table::MAX_E;\n-    let value_in_range = upper_bound <= T::max_normal_digits() as u64;\n+    let value_in_range = upper_bound <= T::MAX_NORMAL_DIGITS as u64;\n     if exponent_in_range && value_in_range {\n         Ok(algorithm::bellerophon(&f, e))\n     } else {\n@@ -315,17 +315,17 @@ fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 {\n fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n     // There were zeros but they were stripped by simplify()\n     if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n-        return Some(T::zero2());\n+        return Some(T::ZERO);\n     }\n     // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n     // much about overflow here because the input length is tiny (at least compared to 2^64) and\n     // the parser already handles exponents whose absolute value is greater than 10^18\n     // (which is still 10^19 short of 2^64).\n     let max_place = decimal.exp + decimal.integral.len() as i64;\n-    if max_place > T::inf_cutoff() {\n-        return Some(T::infinity2());\n-    } else if max_place < T::zero_cutoff() {\n-        return Some(T::zero2());\n+    if max_place > T::INF_CUTOFF {\n+        return Some(T::INFINITY);\n+    } else if max_place < T::ZERO_CUTOFF {\n+        return Some(T::ZERO);\n     }\n     None\n }"}, {"sha": "1485c79ead2519ce624c193909bc7559998ca43b", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 69, "deletions": 123, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c74bc42db1f811820bd829f99c023d3d007628/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=e9c74bc42db1f811820bd829f99c023d3d007628", "patch": "@@ -56,24 +56,12 @@ impl Unpacked {\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n /// Inherits from `Float` because there is some overlap, but all the reused methods are trivial.\n-/// The \"methods\" (pseudo-constants) with default implementation should not be overriden.\n pub trait RawFloat : Float + Copy + Debug + LowerExp\n                     + Mul<Output=Self> + Div<Output=Self> + Neg<Output=Self>\n {\n-    // suffix of \"2\" because Float::infinity is deprecated\n-    #[allow(deprecated)]\n-    fn infinity2() -> Self {\n-        Float::infinity()\n-    }\n-\n-    // suffix of \"2\" because Float::nan is deprecated\n-    #[allow(deprecated)]\n-    fn nan2() -> Self {\n-        Float::nan()\n-    }\n-\n-    // suffix of \"2\" because Float::zero is deprecated\n-    fn zero2() -> Self;\n+    const INFINITY: Self;\n+    const NAN: Self;\n+    const ZERO: Self;\n \n     // suffix of \"2\" because Float::integer_decode is deprecated\n     #[allow(deprecated)]\n@@ -94,94 +82,83 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10<sup>e</sup> from a pre-computed table. Panics for e >=\n-    /// ceil_log5_of_max_sig().\n+    /// Get the value 10<sup>e</sup> from a pre-computed table.\n+    /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n     fn short_fast_pow10(e: usize) -> Self;\n \n-    // FIXME Everything that follows should be associated constants, but taking the value of an\n-    // associated constant from a type parameter does not work (yet?)\n-    // A possible workaround is having a `FloatInfo` struct for all the constants, but so far\n-    // the methods aren't painful enough to rewrite.\n-\n     /// What the name says. It's easier to hard code than juggling intrinsics and\n     /// hoping LLVM constant folds it.\n-    fn ceil_log5_of_max_sig() -> i16;\n+    const CEIL_LOG5_OF_MAX_SIG: i16;\n \n     // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\n     /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n-    fn max_normal_digits() -> usize;\n+    const MAX_NORMAL_DIGITS: usize;\n \n     /// When the most significant decimal digit has a place value greater than this, the number\n     /// is certainly rounded to infinity.\n-    fn inf_cutoff() -> i64;\n+    const INF_CUTOFF: i64;\n \n     /// When the most significant decimal digit has a place value less than this, the number\n     /// is certainly rounded to zero.\n-    fn zero_cutoff() -> i64;\n+    const ZERO_CUTOFF: i64;\n \n     /// The number of bits in the exponent.\n-    fn exp_bits() -> u8;\n+    const EXP_BITS: u8;\n \n     /// The number of bits in the singificand, *including* the hidden bit.\n-    fn sig_bits() -> u8;\n+    const SIG_BITS: u8;\n \n     /// The number of bits in the singificand, *excluding* the hidden bit.\n-    fn explicit_sig_bits() -> u8 {\n-        Self::sig_bits() - 1\n-    }\n+    const EXPLICIT_SIG_BITS: u8;\n \n     /// The maximum legal exponent in fractional representation.\n-    fn max_exp() -> i16 {\n-        (1 << (Self::exp_bits() - 1)) - 1\n-    }\n+    const MAX_EXP: i16;\n \n     /// The minimum legal exponent in fractional representation, excluding subnormals.\n-    fn min_exp() -> i16 {\n-        -Self::max_exp() + 1\n-    }\n+    const MIN_EXP: i16;\n \n     /// `MAX_EXP` for integral representation, i.e., with the shift applied.\n-    fn max_exp_int() -> i16 {\n-        Self::max_exp() - (Self::sig_bits() as i16 - 1)\n-    }\n+    const MAX_EXP_INT: i16;\n \n     /// `MAX_EXP` encoded (i.e., with offset bias)\n-    fn max_encoded_exp() -> i16 {\n-        (1 << Self::exp_bits()) - 1\n-    }\n+    const MAX_ENCODED_EXP: i16;\n \n     /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n-    fn min_exp_int() -> i16 {\n-        Self::min_exp() - (Self::sig_bits() as i16 - 1)\n-    }\n+    const MIN_EXP_INT: i16;\n \n     /// The maximum normalized singificand in integral representation.\n-    fn max_sig() -> u64 {\n-        (1 << Self::sig_bits()) - 1\n-    }\n+    const MAX_SIG: u64;\n \n     /// The minimal normalized significand in integral representation.\n-    fn min_sig() -> u64 {\n-        1 << (Self::sig_bits() - 1)\n-    }\n+    const MIN_SIG: u64;\n }\n \n-impl RawFloat for f32 {\n-    fn zero2() -> Self {\n-        0.0\n-    }\n-\n-    fn sig_bits() -> u8 {\n-        24\n-    }\n-\n-    fn exp_bits() -> u8 {\n-        8\n+// Mostly a workaround for #34344.\n+macro_rules! other_constants {\n+    ($type: ident) => {\n+        const EXPLICIT_SIG_BITS: u8 = Self::SIG_BITS - 1;\n+        const MAX_EXP: i16 = (1 << (Self::EXP_BITS - 1)) - 1;\n+        const MIN_EXP: i16 = -Self::MAX_EXP + 1;\n+        const MAX_EXP_INT: i16 = Self::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n+        const MAX_ENCODED_EXP: i16 = (1 << Self::EXP_BITS) - 1;\n+        const MIN_EXP_INT: i16 = Self::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n+        const MAX_SIG: u64 = (1 << Self::SIG_BITS) - 1;\n+        const MIN_SIG: u64 = 1 << (Self::SIG_BITS - 1);\n+\n+        const INFINITY: Self = $crate::$type::INFINITY;\n+        const NAN: Self = $crate::$type::NAN;\n+        const ZERO: Self = 0.0;\n     }\n+}\n \n-    fn ceil_log5_of_max_sig() -> i16 {\n-        11\n-    }\n+impl RawFloat for f32 {\n+    const SIG_BITS: u8 = 24;\n+    const EXP_BITS: u8 = 8;\n+    const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\n+    const MAX_NORMAL_DIGITS: usize = 35;\n+    const INF_CUTOFF: i64 = 40;\n+    const ZERO_CUTOFF: i64 = -48;\n+    other_constants!(f32);\n \n     fn transmute(self) -> u64 {\n         let bits: u32 = unsafe { transmute(self) };\n@@ -207,37 +184,17 @@ impl RawFloat for f32 {\n     fn short_fast_pow10(e: usize) -> Self {\n         table::F32_SHORT_POWERS[e]\n     }\n-\n-    fn max_normal_digits() -> usize {\n-        35\n-    }\n-\n-    fn inf_cutoff() -> i64 {\n-        40\n-    }\n-\n-    fn zero_cutoff() -> i64 {\n-        -48\n-    }\n }\n \n \n impl RawFloat for f64 {\n-    fn zero2() -> Self {\n-        0.0\n-    }\n-\n-    fn sig_bits() -> u8 {\n-        53\n-    }\n-\n-    fn exp_bits() -> u8 {\n-        11\n-    }\n-\n-    fn ceil_log5_of_max_sig() -> i16 {\n-        23\n-    }\n+    const SIG_BITS: u8 = 53;\n+    const EXP_BITS: u8 = 11;\n+    const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\n+    const MAX_NORMAL_DIGITS: usize = 305;\n+    const INF_CUTOFF: i64 = 310;\n+    const ZERO_CUTOFF: i64 = -326;\n+    other_constants!(f64);\n \n     fn transmute(self) -> u64 {\n         let bits: u64 = unsafe { transmute(self) };\n@@ -262,38 +219,27 @@ impl RawFloat for f64 {\n     fn short_fast_pow10(e: usize) -> Self {\n         table::F64_SHORT_POWERS[e]\n     }\n-\n-    fn max_normal_digits() -> usize {\n-        305\n-    }\n-\n-    fn inf_cutoff() -> i64 {\n-        310\n-    }\n-\n-    fn zero_cutoff() -> i64 {\n-        -326\n-    }\n-\n }\n \n-/// Convert an Fp to the closest f64. Only handles number that fit into a normalized f64.\n+/// Convert an Fp to the closest machine float type.\n+/// Does not handle subnormal results.\n pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let x = x.normalize();\n     // x.f is 64 bit, so x.e has a mantissa shift of 63\n     let e = x.e + 63;\n-    if e > T::max_exp() {\n+    if e > T::MAX_EXP {\n         panic!(\"fp_to_float: exponent {} too large\", e)\n-    }  else if e > T::min_exp() {\n+    }  else if e > T::MIN_EXP {\n         encode_normal(round_normal::<T>(x))\n     } else {\n         panic!(\"fp_to_float: exponent {} too small\", e)\n     }\n }\n \n-/// Round the 64-bit significand to 53 bit with half-to-even. Does not handle exponent overflow.\n+/// Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n+/// Does not handle exponent overflow.\n pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n-    let excess = 64 - T::sig_bits() as i16;\n+    let excess = 64 - T::SIG_BITS as i16;\n     let half: u64 = 1 << (excess - 1);\n     let (q, rem) = (x.f >> excess, x.f & ((1 << excess) - 1));\n     assert_eq!(q << excess | rem, x.f);\n@@ -303,8 +249,8 @@ pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n         Unpacked::new(q, k)\n     } else if rem == half && (q % 2) == 0 {\n         Unpacked::new(q, k)\n-    } else if q == T::max_sig() {\n-        Unpacked::new(T::min_sig(), k + 1)\n+    } else if q == T::MAX_SIG {\n+        Unpacked::new(T::MIN_SIG, k + 1)\n     } else {\n         Unpacked::new(q + 1, k)\n     }\n@@ -313,22 +259,22 @@ pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n /// Inverse of `RawFloat::unpack()` for normalized numbers.\n /// Panics if the significand or exponent are not valid for normalized numbers.\n pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n-    debug_assert!(T::min_sig() <= x.sig && x.sig <= T::max_sig(),\n+    debug_assert!(T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n         \"encode_normal: significand not normalized\");\n     // Remove the hidden bit\n-    let sig_enc = x.sig & !(1 << T::explicit_sig_bits());\n+    let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n     // Adjust the exponent for exponent bias and mantissa shift\n-    let k_enc = x.k + T::max_exp() + T::explicit_sig_bits() as i16;\n-    debug_assert!(k_enc != 0 && k_enc < T::max_encoded_exp(),\n+    let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n+    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP,\n         \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n-    let bits = (k_enc as u64) << T::explicit_sig_bits() | sig_enc;\n+    let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n     T::from_bits(bits)\n }\n \n-/// Construct the subnormal. A mantissa of 0 is allowed and constructs zero.\n+/// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n-    assert!(significand < T::min_sig(), \"encode_subnormal: not actually subnormal\");\n+    assert!(significand < T::MIN_SIG, \"encode_subnormal: not actually subnormal\");\n     // Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n     T::from_bits(significand)\n }\n@@ -364,8 +310,8 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n         Zero => panic!(\"prev_float: argument is zero\"),\n         Normal => {\n             let Unpacked { sig, k } = x.unpack();\n-            if sig == T::min_sig() {\n-                encode_normal(Unpacked::new(T::max_sig(), k - 1))\n+            if sig == T::MIN_SIG {\n+                encode_normal(Unpacked::new(T::MAX_SIG, k - 1))\n             } else {\n                 encode_normal(Unpacked::new(sig - 1, k))\n             }\n@@ -380,7 +326,7 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n pub fn next_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {\n         Nan => panic!(\"next_float: argument is NaN\"),\n-        Infinite => T::infinity2(),\n+        Infinite => T::INFINITY,\n         // This seems too good to be true, but it works.\n         // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n         // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F."}]}