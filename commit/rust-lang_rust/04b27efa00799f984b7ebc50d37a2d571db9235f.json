{"sha": "04b27efa00799f984b7ebc50d37a2d571db9235f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YjI3ZWZhMDA3OTlmOTg0YjdlYmM1MGQzN2EyZDU3MWRiOTIzNWY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-12T23:59:14Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T23:44:44Z"}, "message": "Move to print functions on types instead of impl fmt::Display\n\nThis will eventually allow us to easily pass in more parameters to the\nfunctions without TLS or other such hacks", "tree": {"sha": "eb42c95dc90fa5c493905e8cce5b28742ab2ad09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb42c95dc90fa5c493905e8cce5b28742ab2ad09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b27efa00799f984b7ebc50d37a2d571db9235f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b27efa00799f984b7ebc50d37a2d571db9235f", "html_url": "https://github.com/rust-lang/rust/commit/04b27efa00799f984b7ebc50d37a2d571db9235f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b27efa00799f984b7ebc50d37a2d571db9235f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb48d6bdee6c655d71f26594d47d232adf3e4e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb48d6bdee6c655d71f26594d47d232adf3e4e93", "html_url": "https://github.com/rust-lang/rust/commit/eb48d6bdee6c655d71f26594d47d232adf3e4e93"}], "stats": {"total": 1076, "additions": 553, "deletions": 523}, "files": [{"sha": "10c4231b82eebb61247e2c075e6ac4cc9fd43c0f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -1849,7 +1849,7 @@ fn get_real_types(\n     cx: &DocContext<'_>,\n     recurse: i32,\n ) -> FxHashSet<Type> {\n-    let arg_s = arg.to_string();\n+    let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n         return res;\n@@ -3573,16 +3573,6 @@ pub enum GenericArg {\n     Const(Constant),\n }\n \n-impl fmt::Display for GenericArg {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            GenericArg::Lifetime(lt) => lt.fmt(f),\n-            GenericArg::Type(ty) => ty.fmt(f),\n-            GenericArg::Const(ct) => ct.fmt(f),\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n@@ -4274,7 +4264,7 @@ fn resolve_type(cx: &DocContext<'_>,\n             return Generic(kw::SelfUpper.to_string());\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path));\n+            return Generic(format!(\"{:#}\", path.print()));\n         }\n         Res::SelfTy(..)\n         | Res::Def(DefKind::TyParam, _)"}, {"sha": "9baa69d981b527fc60b909b8e439aa01e0ae541c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 468, "deletions": 413, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -99,10 +99,6 @@ impl Buffer {\n         self.into_inner()\n     }\n \n-    crate fn with_formatter<T: FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result>(&mut self, t: T) {\n-        self.from_display(display_fn(move |f| (t)(f)));\n-    }\n-\n     crate fn from_display<T: std::fmt::Display>(&mut self, t: T) {\n         if self.for_html {\n             write!(self, \"{}\", t);\n@@ -131,8 +127,6 @@ pub struct AsyncSpace(pub hir::IsAsync);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n-/// Wrapper struct for emitting type parameter bounds.\n-pub struct GenericBounds<'a>(pub &'a [clean::GenericBound]);\n pub struct AbiSpace(pub Abi);\n pub struct DefaultSpace(pub bool);\n \n@@ -161,102 +155,89 @@ pub struct WhereClause<'a>{\n     pub end_newline: bool,\n }\n \n-impl<'a> VisSpace<'a> {\n-    pub fn get(self) -> &'a Option<clean::Visibility> {\n-        let VisSpace(v) = self; v\n-    }\n-}\n-\n-impl UnsafetySpace {\n-    pub fn get(&self) -> hir::Unsafety {\n-        let UnsafetySpace(v) = *self; v\n-    }\n-}\n-\n-impl ConstnessSpace {\n-    pub fn get(&self) -> hir::Constness {\n-        let ConstnessSpace(v) = *self; v\n-    }\n-}\n-\n-fn comma_sep<T: fmt::Display>(items: &[T]) -> impl fmt::Display + '_ {\n+fn comma_sep<T: fmt::Display>(items: impl Iterator<Item=T>) -> impl fmt::Display {\n     display_fn(move |f| {\n-        for (i, item) in items.iter().enumerate() {\n+        for (i, item) in items.enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n-            fmt::Display::fmt(item, f)?;\n+            fmt::Display::fmt(&item, f)?;\n         }\n         Ok(())\n     })\n }\n \n-impl<'a> fmt::Display for GenericBounds<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+crate fn print_generic_bounds(bounds: &[clean::GenericBound]) -> impl fmt::Display + '_ {\n+    display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n-        let &GenericBounds(bounds) = self;\n \n-        for (i, bound) in bounds.iter().filter(|b| bounds_dup.insert(b.to_string())).enumerate() {\n+        for (i, bound) in bounds.iter().filter(|b| {\n+            bounds_dup.insert(b.print().to_string())\n+        }).enumerate() {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(bound, f)?;\n+            fmt::Display::fmt(&bound.print(), f)?;\n         }\n         Ok(())\n-    }\n+    })\n }\n \n-impl fmt::Display for clean::GenericParamDef {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n-            clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n-                f.write_str(&self.name)?;\n+impl clean::GenericParamDef {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.kind {\n+                clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n+                clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n+                    f.write_str(&self.name)?;\n \n-                if !bounds.is_empty() {\n-                    if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n-                    } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n+                    }\n+\n+                    if let Some(ref ty) = default {\n+                        if f.alternate() {\n+                            write!(f, \" = {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \"&nbsp;=&nbsp;{}\", ty.print())?;\n+                        }\n                     }\n+\n+                    Ok(())\n                 }\n+                clean::GenericParamDefKind::Const { ref ty, .. } => {\n+                    f.write_str(\"const \")?;\n+                    f.write_str(&self.name)?;\n \n-                if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty)?;\n+                        write!(f, \": {:#}\", ty.print())\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                        write!(f, \":&nbsp;{}\", ty.print())\n                     }\n                 }\n-\n-                Ok(())\n-            }\n-            clean::GenericParamDefKind::Const { ref ty, .. } => {\n-                f.write_str(\"const \")?;\n-                f.write_str(&self.name)?;\n-\n-                if f.alternate() {\n-                    write!(f, \": {:#}\", ty)\n-                } else {\n-                    write!(f, \":&nbsp;{}\", ty)\n-                }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Generics {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let real_params = self.params\n-            .iter()\n-            .filter(|p| !p.is_synthetic_type_param())\n-            .collect::<Vec<_>>();\n-        if real_params.is_empty() {\n-            return Ok(());\n-        }\n-        if f.alternate() {\n-            write!(f, \"<{:#}>\", comma_sep(&real_params))\n-        } else {\n-            write!(f, \"&lt;{}&gt;\", comma_sep(&real_params))\n-        }\n+impl clean::Generics {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let real_params = self.params\n+                .iter()\n+                .filter(|p| !p.is_synthetic_type_param())\n+                .collect::<Vec<_>>();\n+            if real_params.is_empty() {\n+                return Ok(());\n+            }\n+            if f.alternate() {\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print())))\n+            } else {\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print())))\n+            }\n+        })\n     }\n }\n \n@@ -287,24 +268,26 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#}: {:#}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{:#}: {:#}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     } else {\n-                        clause.push_str(&format!(\"{}: {}\", ty, GenericBounds(bounds)));\n+                        clause.push_str(&format!(\"{}: {}\",\n+                                ty.print(), print_generic_bounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime, ref bounds } => {\n                     clause.push_str(&format!(\"{}: {}\",\n-                                                lifetime,\n+                                                lifetime.print(),\n                                                 bounds.iter()\n-                                                    .map(|b| b.to_string())\n+                                                    .map(|b| b.print().to_string())\n                                                     .collect::<Vec<_>>()\n                                                     .join(\" + \")));\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n-                        clause.push_str(&format!(\"{:#} == {:#}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(), rhs.print()));\n                     } else {\n-                        clause.push_str(&format!(\"{} == {}\", lhs, rhs));\n+                        clause.push_str(&format!(\"{} == {}\", lhs.print(), rhs.print()));\n                     }\n                 }\n             }\n@@ -336,153 +319,164 @@ impl<'a> fmt::Display for WhereClause<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.get_ref())?;\n-        Ok(())\n+impl clean::Lifetime {\n+    crate fn print(&self) -> &str {\n+        self.get_ref()\n     }\n }\n \n-impl fmt::Display for clean::Constant {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.expr, f)\n+impl clean::Constant {\n+    crate fn print(&self) -> &str {\n+        &self.expr\n     }\n }\n \n-impl fmt::Display for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if !self.generic_params.is_empty() {\n+impl clean::PolyTrait {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if !self.generic_params.is_empty() {\n+                if f.alternate() {\n+                    write!(f, \"for<{:#}> \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                } else {\n+                    write!(f, \"for&lt;{}&gt; \",\n+                        comma_sep(self.generic_params.iter().map(|g| g.print())))?;\n+                }\n+            }\n             if f.alternate() {\n-                write!(f, \"for<{:#}> \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{:#}\", self.trait_.print())\n             } else {\n-                write!(f, \"for&lt;{}&gt; \", comma_sep(&self.generic_params))?;\n+                write!(f, \"{}\", self.trait_.print())\n             }\n-        }\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.trait_)\n-        } else {\n-            write!(f, \"{}\", self.trait_)\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericBound {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericBound::Outlives(ref lt) => {\n-                write!(f, \"{}\", *lt)\n-            }\n-            clean::GenericBound::TraitBound(ref ty, modifier) => {\n-                let modifier_str = match modifier {\n-                    hir::TraitBoundModifier::None => \"\",\n-                    hir::TraitBoundModifier::Maybe => \"?\",\n-                };\n-                if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, *ty)\n-                } else {\n-                    write!(f, \"{}{}\", modifier_str, *ty)\n+impl clean::GenericBound {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericBound::Outlives(lt) => {\n+                    write!(f, \"{}\", lt.print())\n+                }\n+                clean::GenericBound::TraitBound(ty, modifier) => {\n+                    let modifier_str = match modifier {\n+                        hir::TraitBoundModifier::None => \"\",\n+                        hir::TraitBoundModifier::Maybe => \"?\",\n+                    };\n+                    if f.alternate() {\n+                        write!(f, \"{}{:#}\", modifier_str, ty.print())\n+                    } else {\n+                        write!(f, \"{}{}\", modifier_str, ty.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::GenericArgs {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n-                if !args.is_empty() || !bindings.is_empty() {\n-                    if f.alternate() {\n-                        f.write_str(\"<\")?;\n-                    } else {\n-                        f.write_str(\"&lt;\")?;\n-                    }\n-                    let mut comma = false;\n-                    for arg in args {\n-                        if comma {\n-                            f.write_str(\", \")?;\n+impl clean::GenericArgs {\n+    fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n+                    if !args.is_empty() || !bindings.is_empty() {\n+                        if f.alternate() {\n+                            f.write_str(\"<\")?;\n+                        } else {\n+                            f.write_str(\"&lt;\")?;\n+                        }\n+                        let mut comma = false;\n+                        for arg in args {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", arg.print())?;\n+                            } else {\n+                                write!(f, \"{}\", arg.print())?;\n+                            }\n+                        }\n+                        for binding in bindings {\n+                            if comma {\n+                                f.write_str(\", \")?;\n+                            }\n+                            comma = true;\n+                            if f.alternate() {\n+                                write!(f, \"{:#}\", binding.print())?;\n+                            } else {\n+                                write!(f, \"{}\", binding.print())?;\n+                            }\n                         }\n-                        comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *arg)?;\n+                            f.write_str(\">\")?;\n                         } else {\n-                            write!(f, \"{}\", *arg)?;\n+                            f.write_str(\"&gt;\")?;\n                         }\n                     }\n-                    for binding in bindings {\n+                }\n+                clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n+                    f.write_str(\"(\")?;\n+                    let mut comma = false;\n+                    for ty in inputs {\n                         if comma {\n                             f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *binding)?;\n+                            write!(f, \"{:#}\", ty.print())?;\n                         } else {\n-                            write!(f, \"{}\", *binding)?;\n+                            write!(f, \"{}\", ty.print())?;\n                         }\n                     }\n-                    if f.alternate() {\n-                        f.write_str(\">\")?;\n-                    } else {\n-                        f.write_str(\"&gt;\")?;\n-                    }\n-                }\n-            }\n-            clean::GenericArgs::Parenthesized { ref inputs, ref output } => {\n-                f.write_str(\"(\")?;\n-                let mut comma = false;\n-                for ty in inputs {\n-                    if comma {\n-                        f.write_str(\", \")?;\n-                    }\n-                    comma = true;\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *ty)?;\n-                    } else {\n-                        write!(f, \"{}\", *ty)?;\n-                    }\n-                }\n-                f.write_str(\")\")?;\n-                if let Some(ref ty) = *output {\n-                    if f.alternate() {\n-                        write!(f, \" -> {:#}\", ty)?;\n-                    } else {\n-                        write!(f, \" -&gt; {}\", ty)?;\n+                    f.write_str(\")\")?;\n+                    if let Some(ref ty) = *output {\n+                        if f.alternate() {\n+                            write!(f, \" -> {:#}\", ty.print())?;\n+                        } else {\n+                            write!(f, \" -&gt; {}\", ty.print())?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        if f.alternate() {\n-            write!(f, \"{:#}\", self.args)\n-        } else {\n-            write!(f, \"{}\", self.args)\n-        }\n+impl clean::PathSegment {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", self.args.print())\n+            } else {\n+                write!(f, \"{}\", self.args.print())\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.global {\n-            f.write_str(\"::\")?\n-        }\n-\n-        for (i, seg) in self.segments.iter().enumerate() {\n-            if i > 0 {\n+impl clean::Path {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if self.global {\n                 f.write_str(\"::\")?\n             }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", seg)?;\n-            } else {\n-                write!(f, \"{}\", seg)?;\n+\n+            for (i, seg) in self.segments.iter().enumerate() {\n+                if i > 0 {\n+                    f.write_str(\"::\")?\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", seg.print())?;\n+                } else {\n+                    write!(f, \"{}\", seg.print())?;\n+                }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n@@ -516,7 +510,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n             url.push_str(\"/index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.css_class());\n+            url.push_str(shortty.as_str());\n             url.push_str(\".\");\n             url.push_str(fqp.last().unwrap());\n             url.push_str(\".html\");\n@@ -537,7 +531,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args)?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print())?;\n     } else {\n         let path = if use_absolute {\n             if let Some((_, _, fqp)) = href(did) {\n@@ -550,7 +544,7 @@ fn resolved_path(w: &mut fmt::Formatter<'_>, did: DefId, path: &clean::Path,\n         } else {\n             anchor(did, &last.name).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args)?;\n+        write!(w, \"{}{}\", path, last.args.print())?;\n     }\n     Ok(())\n }\n@@ -606,7 +600,7 @@ fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display\n             Some(ref params) => {\n                 for param in params {\n                     write!(f, \" + \")?;\n-                    fmt::Display::fmt(param, f)?;\n+                    fmt::Display::fmt(&param.print(), f)?;\n                 }\n                 Ok(())\n             }\n@@ -646,12 +640,12 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 write!(f, \"{}{:#}fn{:#}{:#}\",\n                        UnsafetySpace(decl.unsafety),\n                        AbiSpace(decl.abi),\n-                       comma_sep(&decl.generic_params),\n-                       decl.decl)\n+                       decl.print_generic_params(),\n+                       decl.decl.print())\n             } else {\n                 write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", comma_sep(&decl.generic_params), decl.decl)\n+                write!(f, \"{}{}\", decl.print_generic_params(), decl.decl.print())\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -660,24 +654,27 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(one, f)?;\n+                    fmt::Display::fmt(&one.print(), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n                 many => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                    fmt::Display::fmt(&comma_sep(many), f)?;\n+                    for (i, item) in many.iter().enumerate() {\n+                        if i != 0 { write!(f, \", \")?; }\n+                        fmt::Display::fmt(&item.print(), f)?;\n+                    }\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n             primitive_link(f, PrimitiveType::Slice, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n         clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n-            fmt::Display::fmt(t, f)?;\n+            fmt::Display::fmt(&t.print(), f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n         }\n         clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n@@ -691,22 +688,22 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {:#}\", m, t))\n+                                       &format!(\"*{} {:#}\", m, t.print()))\n                     } else {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{} {}\", m, t))\n+                                       &format!(\"*{} {}\", m, t.print()))\n                     }\n                 }\n                 _ => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n-                    fmt::Display::fmt(t, f)\n+                    fmt::Display::fmt(&t.print(), f)\n                 }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-            let lt = match *l {\n-                Some(ref l) => format!(\"{} \", *l),\n-                _ => String::new(),\n+            let lt = match l {\n+                Some(l) => format!(\"{} \", l.print()),\n+                _ => String::new()\n             };\n             let m = MutableSpace(mutability);\n             let amp = if f.alternate() {\n@@ -720,19 +717,19 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         clean::Generic(_) => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print()))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, **bt))\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print()))\n                             }\n                         }\n                         _ => {\n                             primitive_link(f, PrimitiveType::Slice,\n                                            &format!(\"{}{}{}[\", amp, lt, m))?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", **bt)?;\n+                                write!(f, \"{:#}\", bt.print())?;\n                             } else {\n-                                write!(f, \"{}\", **bt)?;\n+                                write!(f, \"{}\", bt.print())?;\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n@@ -756,9 +753,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", GenericBounds(bounds))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds))\n             } else {\n-                write!(f, \"impl {}\", GenericBounds(bounds))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -770,15 +767,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(f, \"<{:#} as {:#}>::\", self_type, trait_)?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type)?\n+                    write!(f, \"{:#}::\", self_type.print())?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(f, \"&lt;{} as {}&gt;::\", self_type, trait_)?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(), trait_.print())?\n                 } else {\n-                    write!(f, \"{}::\", self_type)?\n+                    write!(f, \"{}::\", self_type.print())?\n                 }\n             };\n             match *trait_ {\n@@ -818,218 +815,258 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_type(self, f, false)\n+impl clean::Type {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            fmt_type(self, f, false)\n+        })\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl,\n-            f: &mut fmt::Formatter<'_>,\n-            link_trait: bool,\n-            use_absolute: bool) -> fmt::Result {\n-    if f.alternate() {\n-        write!(f, \"impl{:#} \", i.generics)?;\n-    } else {\n-        write!(f, \"impl{} \", i.generics)?;\n+impl clean::Impl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        self.print_inner(true, false)\n     }\n \n-    if let Some(ref ty) = i.trait_ {\n-        if i.polarity == Some(clean::ImplPolarity::Negative) {\n-            write!(f, \"!\")?;\n-        }\n+    fn print_inner(\n+        &self,\n+        link_trait: bool,\n+        use_absolute: bool,\n+    ) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f, \"impl{:#} \", self.generics.print())?;\n+            } else {\n+                write!(f, \"impl{} \", self.generics.print())?;\n+            }\n \n-        if link_trait {\n-            fmt::Display::fmt(ty, f)?;\n-        } else {\n-            match *ty {\n-                clean::ResolvedPath { param_names: None, ref path, is_generic: false, .. } => {\n-                    let last = path.segments.last().unwrap();\n-                    fmt::Display::fmt(&last.name, f)?;\n-                    fmt::Display::fmt(&last.args, f)?;\n+            if let Some(ref ty) = self.trait_ {\n+                if self.polarity == Some(clean::ImplPolarity::Negative) {\n+                    write!(f, \"!\")?;\n                 }\n-                _ => unreachable!(),\n-            }\n-        }\n-        write!(f, \" for \")?;\n-    }\n \n-    if let Some(ref ty) = i.blanket_impl {\n-        fmt_type(ty, f, use_absolute)?;\n-    } else {\n-        fmt_type(&i.for_, f, use_absolute)?;\n-    }\n+                if link_trait {\n+                    fmt::Display::fmt(&ty.print(), f)?;\n+                } else {\n+                    match ty {\n+                        clean::ResolvedPath { param_names: None, path, is_generic: false, .. } => {\n+                            let last = path.segments.last().unwrap();\n+                            fmt::Display::fmt(&last.name, f)?;\n+                            fmt::Display::fmt(&last.args.print(), f)?;\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+                write!(f, \" for \")?;\n+            }\n \n-    fmt::Display::fmt(&WhereClause { gens: &i.generics, indent: 0, end_newline: true }, f)?;\n-    Ok(())\n-}\n+            if let Some(ref ty) = self.blanket_impl {\n+                fmt_type(ty, f, use_absolute)?;\n+            } else {\n+                fmt_type(&self.for_, f, use_absolute)?;\n+            }\n \n-impl fmt::Display for clean::Impl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt_impl(self, f, true, false)\n+            fmt::Display::fmt(&WhereClause {\n+                gens: &self.generics,\n+                indent: 0,\n+                end_newline: true,\n+            }, f)?;\n+            Ok(())\n+        })\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n                                f: &mut Buffer,\n                                use_absolute: bool) {\n-    f.with_formatter(|f| fmt_impl(i, f, false, use_absolute))\n+    f.from_display(i.print_inner(false, use_absolute))\n }\n \n-impl fmt::Display for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, input) in self.values.iter().enumerate() {\n-            if !input.name.is_empty() {\n-                write!(f, \"{}: \", input.name)?;\n-            }\n-            if f.alternate() {\n-                write!(f, \"{:#}\", input.type_)?;\n-            } else {\n-                write!(f, \"{}\", input.type_)?;\n+impl clean::Arguments {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            for (i, input) in self.values.iter().enumerate() {\n+                if !input.name.is_empty() {\n+                    write!(f, \"{}: \", input.name)?;\n+                }\n+                if f.alternate() {\n+                    write!(f, \"{:#}\", input.type_.print())?;\n+                } else {\n+                    write!(f, \"{}\", input.type_.print())?;\n+                }\n+                if i + 1 < self.values.len() { write!(f, \", \")?; }\n             }\n-            if i + 1 < self.values.len() { write!(f, \", \")?; }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n-            clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n-            clean::DefaultReturn => Ok(()),\n-        }\n+impl clean::FunctionRetTy {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n+                clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print()),\n+                clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print()),\n+                clean::DefaultReturn => Ok(()),\n+            }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if f.alternate() {\n-            write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n-        } else {\n-            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n-        }\n+impl clean::BareFunctionDecl {\n+    fn print_generic_params(&self) -> impl fmt::Display + '_ {\n+        comma_sep(self.generic_params.iter().map(|g| g.print()))\n     }\n }\n \n-impl<'a> fmt::Display for Function<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let &Function { decl, header_len, indent, asyncness } = self;\n-        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n-        let mut args = String::new();\n-        let mut args_plain = String::new();\n-        for (i, input) in decl.inputs.values.iter().enumerate() {\n-            if i == 0 {\n-                args.push_str(\"<br>\");\n+impl clean::FnDecl {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            if f.alternate() {\n+                write!(f,\n+                    \"({args:#}){arrow:#}\", args = self.inputs.print(), arrow = self.output.print())\n+            } else {\n+                write!(f,\n+                    \"({args}){arrow}\", args = self.inputs.print(), arrow = self.output.print())\n             }\n+        })\n+    }\n+}\n+\n+\n+impl Function<'_> {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            let &Function { decl, header_len, indent, asyncness } = self;\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n+            let mut args = String::new();\n+            let mut args_plain = String::new();\n+            for (i, input) in decl.inputs.values.iter().enumerate() {\n+                if i == 0 {\n+                    args.push_str(\"<br>\");\n+                }\n \n-            if let Some(selfty) = input.to_self() {\n-                match selfty {\n-                    clean::SelfValue => {\n-                        args.push_str(\"self\");\n-                        args_plain.push_str(\"self\");\n+                if let Some(selfty) = input.to_self() {\n+                    match selfty {\n+                        clean::SelfValue => {\n+                            args.push_str(\"self\");\n+                            args_plain.push_str(\"self\");\n+                        }\n+                        clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                            args.push_str(\n+                                &format!(\"{}{} {}self\", amp, lt.print(), MutableSpace(mtbl)));\n+                            args_plain.push_str(\n+                                &format!(\"&{} {}self\", lt.print(), MutableSpace(mtbl)));\n+                        }\n+                        clean::SelfBorrowed(None, mtbl) => {\n+                            args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n+                            args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n+                        }\n+                        clean::SelfExplicit(ref typ) => {\n+                            if f.alternate() {\n+                                args.push_str(&format!(\"self: {:#}\", typ.print()));\n+                            } else {\n+                                args.push_str(&format!(\"self: {}\", typ.print()));\n+                            }\n+                            args_plain.push_str(&format!(\"self: {:#}\", typ.print()));\n+                        }\n                     }\n-                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        args.push_str(&format!(\"{}{} {}self\", amp, *lt, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{} {}self\", *lt, MutableSpace(mtbl)));\n+                } else {\n+                    if i > 0 {\n+                        args.push_str(\" <br>\");\n+                        args_plain.push_str(\" \");\n                     }\n-                    clean::SelfBorrowed(None, mtbl) => {\n-                        args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n-                        args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n+                    if !input.name.is_empty() {\n+                        args.push_str(&format!(\"{}: \", input.name));\n+                        args_plain.push_str(&format!(\"{}: \", input.name));\n                     }\n-                    clean::SelfExplicit(ref typ) => {\n-                        if f.alternate() {\n-                            args.push_str(&format!(\"self: {:#}\", *typ));\n-                        } else {\n-                            args.push_str(&format!(\"self: {}\", *typ));\n-                        }\n-                        args_plain.push_str(&format!(\"self: {:#}\", *typ));\n+\n+                    if f.alternate() {\n+                        args.push_str(&format!(\"{:#}\", input.type_.print()));\n+                    } else {\n+                        args.push_str(&input.type_.print().to_string());\n                     }\n+                    args_plain.push_str(&format!(\"{:#}\", input.type_.print()));\n                 }\n-            } else {\n-                if i > 0 {\n-                    args.push_str(\" <br>\");\n-                    args_plain.push_str(\" \");\n-                }\n-                if !input.name.is_empty() {\n-                    args.push_str(&format!(\"{}: \", input.name));\n-                    args_plain.push_str(&format!(\"{}: \", input.name));\n+                if i + 1 < decl.inputs.values.len() {\n+                    args.push(',');\n+                    args_plain.push(',');\n                 }\n-\n-                if f.alternate() {\n-                    args.push_str(&format!(\"{:#}\", input.type_));\n-                } else {\n-                    args.push_str(&input.type_.to_string());\n-                }\n-                args_plain.push_str(&format!(\"{:#}\", input.type_));\n             }\n-            if i + 1 < decl.inputs.values.len() {\n-                args.push(',');\n-                args_plain.push(',');\n-            }\n-        }\n \n-        let args_plain = format!(\"({})\", args_plain);\n+            let args_plain = format!(\"({})\", args_plain);\n \n-        let output = if let hir::IsAsync::Async = asyncness {\n-            Cow::Owned(decl.sugared_async_return_type())\n-        } else {\n-            Cow::Borrowed(&decl.output)\n-        };\n+            let output = if let hir::IsAsync::Async = asyncness {\n+                Cow::Owned(decl.sugared_async_return_type())\n+            } else {\n+                Cow::Borrowed(&decl.output)\n+            };\n \n-        let arrow_plain = format!(\"{:#}\", &output);\n-        let arrow = if f.alternate() {\n-            format!(\"{:#}\", &output)\n-        } else {\n-            output.to_string()\n-        };\n+            let arrow_plain = format!(\"{:#}\", &output.print());\n+            let arrow = if f.alternate() {\n+                format!(\"{:#}\", &output.print())\n+            } else {\n+                output.print().to_string()\n+            };\n \n-        let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n-        let output = if declaration_len > 80 {\n-            let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n-            let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n-            format!(\"({args}{close}){arrow}\",\n-                    args = args.replace(\"<br>\", &full_pad),\n-                    close = close_pad,\n-                    arrow = arrow)\n-        } else {\n-            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n-        };\n+            let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n+            let output = if declaration_len > 80 {\n+                let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n+                let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n+                format!(\"({args}{close}){arrow}\",\n+                        args = args.replace(\"<br>\", &full_pad),\n+                        close = close_pad,\n+                        arrow = arrow)\n+            } else {\n+                format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n+            };\n \n-        if f.alternate() {\n-            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n-        } else {\n-            write!(f, \"{}\", output)\n-        }\n+            if f.alternate() {\n+                write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+            } else {\n+                write!(f, \"{}\", output)\n+            }\n+        })\n     }\n }\n \n impl<'a> fmt::Display for VisSpace<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self.get() {\n-            Some(clean::Public) => f.write_str(\"pub \"),\n-            Some(clean::Inherited) | None => Ok(()),\n-            Some(clean::Visibility::Crate) => write!(f, \"pub(crate) \"),\n-            Some(clean::Visibility::Restricted(did, ref path)) => {\n-                f.write_str(\"pub(\")?;\n-                if path.segments.len() != 1\n-                    || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n-                {\n-                    f.write_str(\"in \")?;\n+        if let Some(v) = self.0 {\n+            fmt::Display::fmt(&v.print_with_space(), f)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl clean::Visibility {\n+    fn print_with_space(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Public => f.write_str(\"pub \"),\n+                clean::Inherited => Ok(()),\n+                clean::Visibility::Crate => write!(f, \"pub(crate) \"),\n+                clean::Visibility::Restricted(did, ref path) => {\n+                    f.write_str(\"pub(\")?;\n+                    if path.segments.len() != 1\n+                        || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n+                    {\n+                        f.write_str(\"in \")?;\n+                    }\n+                    resolved_path(f, did, path, true, false)?;\n+                    f.write_str(\") \")\n                 }\n-                resolved_path(f, did, path, true, false)?;\n-                f.write_str(\") \")\n             }\n-        }\n+        })\n     }\n }\n \n impl fmt::Display for UnsafetySpace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n+        match self.0 {\n             hir::Unsafety::Unsafe => write!(f, \"unsafe \"),\n             hir::Unsafety::Normal => Ok(())\n         }\n@@ -1038,7 +1075,7 @@ impl fmt::Display for UnsafetySpace {\n \n impl fmt::Display for ConstnessSpace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n+        match self.0 {\n             hir::Constness::Const => write!(f, \"const \"),\n             hir::Constness::NotConst => Ok(())\n         }\n@@ -1054,66 +1091,72 @@ impl fmt::Display for AsyncSpace {\n     }\n }\n \n-impl fmt::Display for clean::Import {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            clean::Import::Simple(ref name, ref src) => {\n-                if *name == src.path.last_name() {\n-                    write!(f, \"use {};\", *src)\n-                } else {\n-                    write!(f, \"use {} as {};\", *src, *name)\n+impl clean::Import {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match *self {\n+                clean::Import::Simple(ref name, ref src) => {\n+                    if *name == src.path.last_name() {\n+                        write!(f, \"use {};\", src.print())\n+                    } else {\n+                        write!(f, \"use {} as {};\", src.print(), *name)\n+                    }\n                 }\n-            }\n-            clean::Import::Glob(ref src) => {\n-                if src.path.segments.is_empty() {\n-                    write!(f, \"use *;\")\n-                } else {\n-                    write!(f, \"use {}::*;\", *src)\n+                clean::Import::Glob(ref src) => {\n+                    if src.path.segments.is_empty() {\n+                        write!(f, \"use *;\")\n+                    } else {\n+                        write!(f, \"use {}::*;\", src.print())\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false),\n-            _ => {\n-                for (i, seg) in self.path.segments.iter().enumerate() {\n-                    if i > 0 {\n-                        write!(f, \"::\")?\n+impl clean::ImportSource {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self.did {\n+                Some(did) => resolved_path(f, did, &self.path, true, false),\n+                _ => {\n+                    for (i, seg) in self.path.segments.iter().enumerate() {\n+                        if i > 0 {\n+                            write!(f, \"::\")?\n+                        }\n+                        write!(f, \"{}\", seg.name)?;\n                     }\n-                    write!(f, \"{}\", seg.name)?;\n+                    Ok(())\n                 }\n-                Ok(())\n             }\n-        }\n+        })\n     }\n }\n \n-impl fmt::Display for clean::TypeBinding {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)?;\n-        match self.kind {\n-            clean::TypeBindingKind::Equality { ref ty } => {\n-                if f.alternate() {\n-                    write!(f, \" = {:#}\", ty)?;\n-                } else {\n-                    write!(f, \" = {}\", ty)?;\n-                }\n-            }\n-            clean::TypeBindingKind::Constraint { ref bounds } => {\n-                if !bounds.is_empty() {\n+impl clean::TypeBinding {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            f.write_str(&self.name)?;\n+            match self.kind {\n+                clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {:#}\", ty.print())?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", GenericBounds(bounds))?;\n+                        write!(f, \" = {}\", ty.print())?;\n+                    }\n+                }\n+                clean::TypeBindingKind::Constraint { ref bounds } => {\n+                    if !bounds.is_empty() {\n+                        if f.alternate() {\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        } else {\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        }\n                     }\n                 }\n             }\n-        }\n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n@@ -1146,6 +1189,18 @@ impl fmt::Display for DefaultSpace {\n     }\n }\n \n+impl clean::GenericArg {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        display_fn(move |f| {\n+            match self {\n+                clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n+                clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(), f),\n+                clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(), f),\n+            }\n+        })\n+    }\n+}\n+\n crate fn display_fn(\n     f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n ) -> impl fmt::Display {"}, {"sha": "5fb9afd6c49a04abd4f5c2cf7c727267c138bca9", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -46,14 +46,6 @@ pub enum ItemType {\n }\n \n \n-#[derive(Copy, Eq, PartialEq, Clone)]\n-pub enum NameSpace {\n-    Type,\n-    Value,\n-    Macro,\n-    Keyword,\n-}\n-\n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n         let inner = match item.inner {\n@@ -120,7 +112,7 @@ impl From<clean::TypeKind> for ItemType {\n }\n \n impl ItemType {\n-    pub fn css_class(&self) -> &'static str {\n+    pub fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n             ItemType::ExternCrate     => \"externcrate\",\n@@ -151,7 +143,7 @@ impl ItemType {\n         }\n     }\n \n-    pub fn name_space(&self) -> NameSpace {\n+    pub fn name_space(&self) -> &'static str {\n         match *self {\n             ItemType::Struct |\n             ItemType::Union |\n@@ -163,7 +155,7 @@ impl ItemType {\n             ItemType::AssocType |\n             ItemType::OpaqueTy |\n             ItemType::TraitAlias |\n-            ItemType::ForeignType => NameSpace::Type,\n+            ItemType::ForeignType => NAMESPACE_TYPE,\n \n             ItemType::ExternCrate |\n             ItemType::Import |\n@@ -175,41 +167,24 @@ impl ItemType {\n             ItemType::StructField |\n             ItemType::Variant |\n             ItemType::Constant |\n-            ItemType::AssocConst => NameSpace::Value,\n+            ItemType::AssocConst => NAMESPACE_VALUE,\n \n             ItemType::Macro |\n             ItemType::ProcAttribute |\n-            ItemType::ProcDerive => NameSpace::Macro,\n+            ItemType::ProcDerive => NAMESPACE_MACRO,\n \n-            ItemType::Keyword => NameSpace::Keyword,\n+            ItemType::Keyword => NAMESPACE_KEYWORD,\n         }\n     }\n }\n \n impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.css_class().fmt(f)\n+        write!(f, \"{}\", self.as_str())\n     }\n }\n \n pub const NAMESPACE_TYPE: &'static str = \"t\";\n pub const NAMESPACE_VALUE: &'static str = \"v\";\n pub const NAMESPACE_MACRO: &'static str = \"m\";\n pub const NAMESPACE_KEYWORD: &'static str = \"k\";\n-\n-impl NameSpace {\n-    pub fn to_static_str(&self) -> &'static str {\n-        match *self {\n-            NameSpace::Type => NAMESPACE_TYPE,\n-            NameSpace::Value => NAMESPACE_VALUE,\n-            NameSpace::Macro => NAMESPACE_MACRO,\n-            NameSpace::Keyword => NAMESPACE_KEYWORD,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for NameSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.to_static_str().fmt(f)\n-    }\n-}"}, {"sha": "7aaf04f34d32fa6bd75d62582946b5daf72bccb6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 68, "deletions": 59, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -66,7 +66,7 @@ use crate::doctree;\n use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n use crate::html::format::{Buffer, AsyncSpace, ConstnessSpace};\n-use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace, DefaultSpace};\n+use crate::html::format::{print_generic_bounds, WhereClause, href, AbiSpace, DefaultSpace};\n use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::item_type::ItemType;\n@@ -1203,7 +1203,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n             if !imp.impl_item.def_id.is_local() { continue }\n             have_impls = true;\n             write!(implementors, \"{{text:{},synthetic:{},types:{}}},\",\n-                   as_json(&imp.inner_impl().to_string()),\n+                   as_json(&imp.inner_impl().print().to_string()),\n                    imp.inner_impl().synthetic,\n                    as_json(&collect_paths_for_type(imp.inner_impl().for_.clone()))).unwrap();\n         }\n@@ -1222,7 +1222,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\",\n-                            remote_item_type.css_class(),\n+                            remote_item_type,\n                             remote_path[remote_path.len() - 1]));\n \n         let (mut all_implementors, _, _) = try_err!(collect(&mydst, &krate.name, \"implementors\",\n@@ -1665,9 +1665,11 @@ impl ItemEntry {\n     }\n }\n \n-impl fmt::Display for ItemEntry {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+impl ItemEntry {\n+    crate fn print(&self) -> impl fmt::Display + '_ {\n+        crate::html::format::display_fn(move |f| {\n+            write!(f, \"<a href='{}'>{}</a>\", self.url, Escape(&self.name))\n+        })\n     }\n }\n \n@@ -1759,7 +1761,7 @@ fn print_entries(f: &mut Buffer, e: &FxHashSet<ItemEntry>, title: &str, class: &\n                title,\n                Escape(title),\n                class,\n-               e.iter().map(|s| format!(\"<li>{}</li>\", s)).collect::<String>());\n+               e.iter().map(|s| format!(\"<li>{}</li>\", s.print())).collect::<String>());\n     }\n }\n \n@@ -1939,7 +1941,7 @@ impl Context {\n             title.push_str(it.name.as_ref().unwrap());\n         }\n         title.push_str(\" - Rust\");\n-        let tyname = it.type_().css_class();\n+        let tyname = it.type_();\n         let desc = if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\",\n                     self.shared.layout.krate)\n@@ -1949,7 +1951,7 @@ impl Context {\n         };\n         let keywords = make_item_keywords(it);\n         let page = layout::Page {\n-            css_class: tyname,\n+            css_class: tyname.as_str(),\n             root_path: &self.root_path(),\n             static_root_path: self.shared.static_root_path.as_deref(),\n             title: &title,\n@@ -2090,7 +2092,7 @@ impl Context {\n         for item in &m.items {\n             if item.is_stripped() { continue }\n \n-            let short = item.type_().css_class();\n+            let short = item.type_();\n             let myname = match item.name {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n@@ -2285,7 +2287,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n fn item_path(ty: ItemType, name: &str) -> String {\n     match ty {\n         ItemType::Module => format!(\"{}index.html\", SlashChecker(name)),\n-        _ => format!(\"{}.{}.html\", ty.css_class(), name),\n+        _ => format!(\"{}.{}.html\", ty, name),\n     }\n }\n \n@@ -2586,7 +2588,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(&myitem.visibility), *import);\n+                       VisSpace(&myitem.visibility), import.print());\n             }\n \n             _ => {\n@@ -2794,7 +2796,7 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n                {name}: {typ}</pre>\",\n            vis = VisSpace(&it.visibility),\n            name = it.name.as_ref().unwrap(),\n-           typ = c.type_);\n+           typ = c.type_.print());\n     document(w, cx, it)\n }\n \n@@ -2806,7 +2808,7 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n            vis = VisSpace(&it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n-           typ = s.type_);\n+           typ = s.type_.print());\n     document(w, cx, it)\n }\n \n@@ -2819,7 +2821,7 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n         AsyncSpace(f.header.asyncness),\n         AbiSpace(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics\n+        f.generics.print()\n     ).len();\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it));\n     render_attributes(w, it, false);\n@@ -2832,14 +2834,14 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n            asyncness = AsyncSpace(f.header.asyncness),\n            abi = AbiSpace(f.header.abi),\n            name = it.name.as_ref().unwrap(),\n-           generics = f.generics,\n+           generics = f.generics.print(),\n            where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n            decl = Function {\n               decl: &f.decl,\n               header_len,\n               indent: 0,\n               asyncness: f.header.asyncness,\n-           });\n+           }.print());\n     document(w, cx, it)\n }\n \n@@ -2880,15 +2882,15 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&(*p).to_string());\n+            bounds.push_str(&p.print().to_string());\n         }\n     }\n     bounds\n }\n \n fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl());\n-    let rhs = format!(\"{}\", rhs.inner_impl());\n+    let lhs = format!(\"{}\", lhs.inner_impl().print());\n+    let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n     name_key(&lhs).cmp(&name_key(&rhs))\n@@ -2915,7 +2917,7 @@ fn item_trait(\n                UnsafetySpace(t.unsafety),\n                if t.is_auto { \"auto \" } else { \"\" },\n                it.name.as_ref().unwrap(),\n-               t.generics,\n+               t.generics.print(),\n                bounds);\n \n         if !t.generics.where_predicates.is_empty() {\n@@ -3142,7 +3144,7 @@ fn item_trait(\n                let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n-           ty = it.type_().css_class(),\n+           ty = it.type_(),\n            name = *it.name.as_ref().unwrap());\n }\n \n@@ -3176,7 +3178,7 @@ fn assoc_const(w: &mut Buffer,\n            VisSpace(&it.visibility),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n-           ty);\n+           ty.print());\n }\n \n fn assoc_type(w: &mut Buffer, it: &clean::Item,\n@@ -3189,10 +3191,10 @@ fn assoc_type(w: &mut Buffer, it: &clean::Item,\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap());\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", GenericBounds(bounds))\n+        write!(w, \": {}\", print_generic_bounds(bounds))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)\n+        write!(w, \" = {}\", default.print())\n     }\n }\n \n@@ -3245,7 +3247,7 @@ fn render_assoc_item(w: &mut Buffer,\n             DefaultSpace(meth.is_default()),\n             AbiSpace(header.abi),\n             name,\n-            *g\n+            g.print()\n         ).len();\n         let (indent, end_newline) = if parent == ItemType::Trait {\n             header_len += 4;\n@@ -3265,13 +3267,13 @@ fn render_assoc_item(w: &mut Buffer,\n                AbiSpace(header.abi),\n                href = href,\n                name = name,\n-               generics = *g,\n+               generics = g.print(),\n                decl = Function {\n                    decl: d,\n                    header_len,\n                    indent,\n                    asyncness: header.asyncness,\n-               },\n+               }.print(),\n                where_clause = WhereClause {\n                    gens: g,\n                    indent,\n@@ -3340,7 +3342,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n                        id = id,\n                        ns_id = ns_id,\n                        name = field.name.as_ref().unwrap(),\n-                       ty = ty);\n+                       ty = ty.print());\n                 document(w, cx, field);\n             }\n         }\n@@ -3381,7 +3383,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n                    id = id,\n                    name = name,\n                    shortty = ItemType::StructField,\n-                   ty = ty);\n+                   ty = ty.print());\n             if let Some(stability_class) = field.stability_class() {\n                 write!(w, \"<span class='stab {stab}'></span>\",\n                     stab = stability_class);\n@@ -3399,7 +3401,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n         write!(w, \"{}enum {}{}{}\",\n                VisSpace(&it.visibility),\n                it.name.as_ref().unwrap(),\n-               e.generics,\n+               e.generics.print(),\n                WhereClause { gens: &e.generics, indent: 0, end_newline: true });\n         if e.variants.is_empty() && !e.variants_stripped {\n             write!(w, \" {{}}\");\n@@ -3418,7 +3420,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                     if i > 0 {\n                                         write!(w, \",&nbsp;\")\n                                     }\n-                                    write!(w, \"{}\", *ty);\n+                                    write!(w, \"{}\", ty.print());\n                                 }\n                                 write!(w, \")\");\n                             }\n@@ -3472,7 +3474,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                         if i > 0 {\n                             write!(w, \",&nbsp;\");\n                         }\n-                        write!(w, \"{}\", *ty);\n+                        write!(w, \"{}\", ty.print());\n                     }\n                     write!(w, \")\");\n                 }\n@@ -3510,7 +3512,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n                                id = id,\n                                ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n-                               t = *ty);\n+                               t = ty.print());\n                         document(w, cx, field);\n                     }\n                 }\n@@ -3590,7 +3592,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g)\n+        write!(w, \"{}\", g.print())\n     }\n     match ty {\n         doctree::Plain => {\n@@ -3605,7 +3607,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                            tab,\n                            VisSpace(&field.visibility),\n                            field.name.as_ref().unwrap(),\n-                           *ty);\n+                           ty.print());\n                     has_visible_fields = true;\n                 }\n             }\n@@ -3633,7 +3635,7 @@ fn render_struct(w: &mut Buffer, it: &clean::Item,\n                         write!(w, \"_\")\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)\n+                        write!(w, \"{}{}\", VisSpace(&field.visibility), ty.print())\n                     }\n                     _ => unreachable!()\n                 }\n@@ -3664,7 +3666,7 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g);\n+        write!(w, \"{}\", g.print());\n         write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true });\n     }\n \n@@ -3674,7 +3676,7 @@ fn render_union(w: &mut Buffer, it: &clean::Item,\n             write!(w, \"    {}{}: {},\\n{}\",\n                    VisSpace(&field.visibility),\n                    field.name.as_ref().unwrap(),\n-                   *ty,\n+                   ty.print(),\n                    tab);\n         }\n     }\n@@ -3740,7 +3742,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       Methods from {}&lt;Target = {}&gt;\\\n                       <a href='#deref-methods' class='anchor'></a>\\\n                     </h2>\\\n-                \", trait_, type_);\n+                \", trait_.print(), type_.print());\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n@@ -3885,12 +3887,13 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                         out.push_str(\n                             &format!(\"<h3 class=\\\"important\\\">Important traits for {}</h3>\\\n                                       <code class=\\\"content\\\">\",\n-                                     impl_.for_));\n-                        trait_.push_str(&impl_.for_.to_string());\n+                                     impl_.for_.print()));\n+                        trait_.push_str(&impl_.for_.print().to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n-                    out.push_str(&format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_));\n+                    out.push_str(\n+                        &format!(\"<span class=\\\"where fmt-newline\\\">{}</span>\", impl_.print()));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = it.inner {\n@@ -3927,7 +3930,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             Some(ref t) => if is_on_foreign_type {\n                 get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t)\n             } else {\n-                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t)))\n+                format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print())))\n             },\n             None => \"impl\".to_string(),\n         });\n@@ -3948,7 +3951,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n             write!(w, \"</code>\");\n         } else {\n             write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n-                id, i.inner_impl()\n+                id, i.inner_impl().print()\n             );\n         }\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n@@ -3993,8 +3996,10 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\",\n+                            name, item_type.name_space()));\n+                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\",\n+                        id, item_type, extra_class);\n                     write!(w, \"{}\", spotlight_decl(decl));\n                     write!(w, \"<code id='{}'>\", ns_id);\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n@@ -4125,7 +4130,7 @@ fn item_opaque_ty(\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = impl {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds = bounds(&t.bounds, false));\n \n@@ -4144,7 +4149,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item,\n     render_attributes(w, it, false);\n     write!(w, \"trait {}{}{} = {};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n            bounds(&t.bounds, true));\n \n@@ -4162,9 +4167,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n-           t.generics,\n+           t.generics.print(),\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           type_ = t.type_);\n+           type_ = t.type_.print());\n \n     document(w, cx, it);\n \n@@ -4269,7 +4274,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n                 relpath: '{path}'\\\n             }};</script>\",\n             name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-            ty = it.type_().css_class(),\n+            ty = it.type_(),\n             path = relpath);\n     if parentlen == 0 {\n         // There is no sidebar-items.js beyond the crate root path\n@@ -4370,9 +4375,10 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     if let Some(impls) = inner_impl {\n                         out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n                         out.push_str(&format!(\"Methods from {}&lt;Target={}&gt;\",\n-                                              Escape(&format!(\"{:#}\",\n-                                                     impl_.inner_impl().trait_.as_ref().unwrap())),\n-                                              Escape(&format!(\"{:#}\", target))));\n+                            Escape(&format!(\n+                                \"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print()\n+                            )),\n+                            Escape(&format!(\"{:#}\", target.print()))));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls.iter()\n                                            .filter(|i| i.inner_impl().trait_.is_none())\n@@ -4397,9 +4403,9 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     .filter_map(|i| {\n                         let is_negative_impl = is_negative_impl(i.inner_impl());\n                         if let Some(ref i) = i.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i);\n+                            let i_display = format!(\"{:#}\", i.print());\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(&format!(\"{:#}\", i));\n+                            let encoded = small_url_encode(&format!(\"{:#}\", i.print()));\n                             let generated = format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                                     encoded,\n                                                     if is_negative_impl { \"!\" } else { \"\" },\n@@ -4471,14 +4477,17 @@ fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n }\n \n fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) -> String {\n-    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_, for_))\n+    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(), for_.print()))\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n     match item.inner {\n         clean::ItemEnum::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n-                Some((format!(\"{:#}\", i.for_), get_id_for_impl_on_foreign_type(&i.for_, trait_)))\n+                Some((\n+                    format!(\"{:#}\", i.for_.print()),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_),\n+                ))\n             } else {\n                 None\n             }"}, {"sha": "dc1ca8d7668ae156aec2316eb1958d6e18552cf4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -142,7 +142,8 @@ impl fold::DocFolder for CoverageCalculator {\n             }\n             clean::ImplItem(ref impl_) => {\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\"impl {:#} for {:#} in {}\", tr, impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} for {:#} in {}\",\n+                        tr.print(), impl_.for_.print(), i.source.filename);\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -151,11 +152,11 @@ impl fold::DocFolder for CoverageCalculator {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_, i.source.filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(), i.source.filename);\n                 }\n             }\n             _ => {\n-                debug!(\"counting {} {:?} in {}\", i.type_(), i.name, i.source.filename);\n+                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n                 self.items.entry(i.source.filename.clone())\n                           .or_default()\n                           .count_item(has_docs);"}, {"sha": "b67f39d328015962fa245dd73bac70f554701284", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         });\n \n         if parent_node.is_some() {\n-            debug!(\"got parent node for {} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+            debug!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         let current_item = match item.inner {"}, {"sha": "d0f2cdad8f3e432560ae6d4e226cba753d1f341a", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -153,7 +153,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n                 // items to the `retained` set.\n-                debug!(\"Stripper: recursing into stripped {} {:?}\", i.type_(), i.name);\n+                debug!(\"Stripper: recursing into stripped {:?} {:?}\", i.type_(), i.name);\n                 let old = mem::replace(&mut self.update_retained, false);\n                 let ret = self.fold_item_recur(i);\n                 self.update_retained = old;\n@@ -178,7 +178,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n-                        debug!(\"Stripper: stripping {} {:?}\", i.type_(), i.name);\n+                        debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n                 }"}, {"sha": "0159e03f6f2997c41a287a97fcae11a07a62a7a4", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b27efa00799f984b7ebc50d37a2d571db9235f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=04b27efa00799f984b7ebc50d37a2d571db9235f", "patch": "@@ -39,7 +39,7 @@ struct Stripper<'a> {\n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n-            debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n+            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {"}]}