{"sha": "a37091d2d0175b0999d6383d48f538cdbf0267a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzA5MWQyZDAxNzViMDk5OWQ2MzgzZDQ4ZjUzOGNkYmYwMjY3YTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-25T18:24:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-25T18:24:04Z"}, "message": "Merge #7431\n\n7431: Handle `super` paths inside blocks correctly r=jonas-schievink a=jonas-schievink\n\nWe now intern `BlockLoc` and use `BlockId` to refer to block expressions. This is needed to keep `ModuleId` simple, since it would otherwise have to store an arbitrarily long chain of blocks and couldn't be `Copy`.\r\n\r\nThe `DefMap` hierarchy is now created as the caller descends into an item body. This is necessary to link the correct module as the block's parent, which is important for correct name resolution.\r\n\r\nAs a result, we can now resolve `super` paths inside block expressions by climbing the `DefMap` chain.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "06981374f0c397b45e31b74c97ed337853fe59d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06981374f0c397b45e31b74c97ed337853fe59d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a37091d2d0175b0999d6383d48f538cdbf0267a0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgDwzECRBK7hj4Ov3rIwAAdHIIACOIKQutahAP5TSJ/gPlC7jw\nCgTpEqLSS/JaFVUzns0LAZiXS1nvcvGUWNfN8/xkoI3Uh26+dwNJrJe3OeXsCPl6\nQHuEXGf6C7v/ftmj3EnBJvOlZG6IEhSAqFkXjvlYGnlDME+2nsLuU9D0sFNCwP78\n4ogno53G2lhU4SbhrPRARJcylhw7qeCJHGpz5Auo1m3Vt23livb7QJM9u1y91BMR\nTkpIt2cBrT/pMHmB4qTDIqYWhq43OP/rRD18GAWsgGHrMqaXlwDZEW3q7YJTPMN0\nWSwaetSmfUCff77aUcDjkxK4pCnY5sVtsFYsYnAcsHSrDky3Roo5TzIAy2jI1E0=\n=cCHF\n-----END PGP SIGNATURE-----\n", "payload": "tree 06981374f0c397b45e31b74c97ed337853fe59d2\nparent 2c735ed734be9b9041921478e0049fffd7160f78\nparent 08253d5473348e2f3061e0c8d84c62de537a5821\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611599044 +0000\ncommitter GitHub <noreply@github.com> 1611599044 +0000\n\nMerge #7431\n\n7431: Handle `super` paths inside blocks correctly r=jonas-schievink a=jonas-schievink\n\nWe now intern `BlockLoc` and use `BlockId` to refer to block expressions. This is needed to keep `ModuleId` simple, since it would otherwise have to store an arbitrarily long chain of blocks and couldn't be `Copy`.\r\n\r\nThe `DefMap` hierarchy is now created as the caller descends into an item body. This is necessary to link the correct module as the block's parent, which is important for correct name resolution.\r\n\r\nAs a result, we can now resolve `super` paths inside block expressions by climbing the `DefMap` chain.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a37091d2d0175b0999d6383d48f538cdbf0267a0", "html_url": "https://github.com/rust-lang/rust/commit/a37091d2d0175b0999d6383d48f538cdbf0267a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a37091d2d0175b0999d6383d48f538cdbf0267a0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c735ed734be9b9041921478e0049fffd7160f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c735ed734be9b9041921478e0049fffd7160f78", "html_url": "https://github.com/rust-lang/rust/commit/2c735ed734be9b9041921478e0049fffd7160f78"}, {"sha": "08253d5473348e2f3061e0c8d84c62de537a5821", "url": "https://api.github.com/repos/rust-lang/rust/commits/08253d5473348e2f3061e0c8d84c62de537a5821", "html_url": "https://github.com/rust-lang/rust/commit/08253d5473348e2f3061e0c8d84c62de537a5821"}], "stats": {"total": 232, "additions": 158, "deletions": 74}, "files": [{"sha": "aef7e1f6cd0366e2698738d1ef159d37a23b8189", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -2,9 +2,9 @@\n use std::sync::Arc;\n \n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n-use hir_expand::{db::AstDatabase, AstId, HirFileId};\n+use hir_expand::{db::AstDatabase, HirFileId};\n use la_arena::ArenaMap;\n-use syntax::{ast, SmolStr};\n+use syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -16,9 +16,10 @@ use crate::{\n     item_tree::ItemTree,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::DefMap,\n-    AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n-    GenericDefId, ImplId, ImplLoc, LocalEnumVariantId, LocalFieldId, StaticId, StaticLoc, StructId,\n-    StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n+    AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId,\n+    FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId, LocalFieldId, StaticId,\n+    StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc, UnionId,\n+    UnionLoc, VariantId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -41,6 +42,8 @@ pub trait InternDatabase: SourceDatabase {\n     fn intern_type_alias(&self, loc: TypeAliasLoc) -> TypeAliasId;\n     #[salsa::interned]\n     fn intern_impl(&self, loc: ImplLoc) -> ImplId;\n+    #[salsa::interned]\n+    fn intern_block(&self, loc: BlockLoc) -> BlockId;\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n@@ -56,7 +59,7 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     fn crate_def_map_query(&self, krate: CrateId) -> Arc<DefMap>;\n \n     #[salsa::invoke(DefMap::block_def_map_query)]\n-    fn block_def_map(&self, krate: CrateId, block: AstId<ast::BlockExpr>) -> Arc<DefMap>;\n+    fn block_def_map(&self, block: BlockId) -> Arc<DefMap>;\n \n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;"}, {"sha": "42b50b5b75fae05fc9e76f2704ebf9b5fe5fd8a2", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -74,12 +74,16 @@ use stdx::impl_from;\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     krate: CrateId,\n+    block: Option<BlockId>,\n     pub local_id: LocalModuleId,\n }\n \n impl ModuleId {\n     pub fn def_map(&self, db: &dyn db::DefDatabase) -> Arc<DefMap> {\n-        db.crate_def_map(self.krate)\n+        match self.block {\n+            Some(block) => db.block_def_map(block),\n+            None => db.crate_def_map(self.krate),\n+        }\n     }\n \n     pub fn krate(&self) -> CrateId {\n@@ -230,6 +234,15 @@ pub struct ImplId(salsa::InternId);\n type ImplLoc = ItemLoc<Impl>;\n impl_intern!(ImplId, ImplLoc, intern_impl, lookup_intern_impl);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct BlockId(salsa::InternId);\n+#[derive(Debug, Hash, PartialEq, Eq, Clone)]\n+pub struct BlockLoc {\n+    ast_id: AstId<ast::BlockExpr>,\n+    module: ModuleId,\n+}\n+impl_intern!(BlockId, BlockLoc, intern_block, lookup_intern_block);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeParamId {\n     pub parent: GenericDefId,"}, {"sha": "199771e9a83b568870ddb705503b54103c2f8886", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -62,22 +62,22 @@ use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use stdx::format_to;\n-use syntax::{ast, AstNode};\n+use syntax::ast;\n \n use crate::{\n     db::DefDatabase,\n     item_scope::{BuiltinShadowMode, ItemScope},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n-    AstId, LocalModuleId, ModuleDefId, ModuleId,\n+    AstId, BlockId, BlockLoc, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n pub struct DefMap {\n     _c: Count<Self>,\n-    parent: Option<Arc<DefMap>>,\n+    block: Option<BlockInfo>,\n     root: LocalModuleId,\n     modules: Arena<ModuleData>,\n     krate: CrateId,\n@@ -91,6 +91,13 @@ pub struct DefMap {\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+struct BlockInfo {\n+    block: BlockId,\n+    parent: Arc<DefMap>,\n+    parent_module: LocalModuleId,\n+}\n+\n impl std::ops::Index<LocalModuleId> for DefMap {\n     type Output = ModuleData;\n     fn index(&self, id: LocalModuleId) -> &ModuleData {\n@@ -190,26 +197,26 @@ impl DefMap {\n         Arc::new(def_map)\n     }\n \n-    pub(crate) fn block_def_map_query(\n-        db: &dyn DefDatabase,\n-        krate: CrateId,\n-        block: AstId<ast::BlockExpr>,\n-    ) -> Arc<DefMap> {\n-        let item_tree = db.item_tree(block.file_id);\n-        let block_items = item_tree.inner_items_of_block(block.value);\n+    pub(crate) fn block_def_map_query(db: &dyn DefDatabase, block_id: BlockId) -> Arc<DefMap> {\n+        let block: BlockLoc = db.lookup_intern_block(block_id);\n+        let item_tree = db.item_tree(block.ast_id.file_id);\n+        let block_items = item_tree.inner_items_of_block(block.ast_id.value);\n \n-        let parent = parent_def_map(db, krate, block);\n+        let parent = block.module.def_map(db);\n \n         if block_items.is_empty() {\n             // If there are no inner items, nothing new is brought into scope, so we can just return\n             // the parent DefMap. This keeps DefMap parent chains short.\n             return parent;\n         }\n \n-        let mut def_map = DefMap::empty(krate, parent.edition);\n-        def_map.parent = Some(parent);\n+        let block_info =\n+            BlockInfo { block: block_id, parent, parent_module: block.module.local_id };\n+\n+        let mut def_map = DefMap::empty(block.module.krate, block_info.parent.edition);\n+        def_map.block = Some(block_info);\n \n-        let def_map = collector::collect_defs(db, def_map, Some(block.value));\n+        let def_map = collector::collect_defs(db, def_map, Some(block.ast_id.value));\n         Arc::new(def_map)\n     }\n \n@@ -218,7 +225,7 @@ impl DefMap {\n         let root = modules.alloc(ModuleData::default());\n         DefMap {\n             _c: Count::new(),\n-            parent: None,\n+            block: None,\n             krate,\n             edition,\n             extern_prelude: FxHashMap::default(),\n@@ -266,7 +273,8 @@ impl DefMap {\n     }\n \n     pub fn module_id(&self, local_id: LocalModuleId) -> ModuleId {\n-        ModuleId { krate: self.krate, local_id }\n+        let block = self.block.as_ref().map(|b| b.block);\n+        ModuleId { krate: self.krate, local_id, block }\n     }\n \n     pub(crate) fn resolve_path(\n@@ -286,9 +294,9 @@ impl DefMap {\n     pub fn dump(&self) -> String {\n         let mut buf = String::new();\n         let mut current_map = self;\n-        while let Some(parent) = &current_map.parent {\n+        while let Some(block) = &current_map.block {\n             go(&mut buf, current_map, \"block scope\", current_map.root);\n-            current_map = &**parent;\n+            current_map = &*block.parent;\n         }\n         go(&mut buf, current_map, \"crate\", current_map.root);\n         return buf;\n@@ -342,35 +350,6 @@ impl ModuleData {\n     }\n }\n \n-fn parent_def_map(\n-    db: &dyn DefDatabase,\n-    krate: CrateId,\n-    block: AstId<ast::BlockExpr>,\n-) -> Arc<DefMap> {\n-    // FIXME: store this info in the item tree instead of reparsing here\n-    let ast_id_map = db.ast_id_map(block.file_id);\n-    let block_ptr = ast_id_map.get(block.value);\n-    let root = match db.parse_or_expand(block.file_id) {\n-        Some(it) => it,\n-        None => {\n-            return Arc::new(DefMap::empty(krate, Edition::Edition2018));\n-        }\n-    };\n-    let ast = block_ptr.to_node(&root);\n-\n-    for ancestor in ast.syntax().ancestors().skip(1) {\n-        if let Some(block_expr) = ast::BlockExpr::cast(ancestor) {\n-            let ancestor_id = ast_id_map.ast_id(&block_expr);\n-            let ast_id = InFile::new(block.file_id, ancestor_id);\n-            let parent_map = db.block_def_map(krate, ast_id);\n-            return parent_map;\n-        }\n-    }\n-\n-    // No enclosing block scope, so the parent is the crate-level DefMap.\n-    db.crate_def_map(krate)\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ModuleSource {\n     SourceFile(ast::SourceFile),"}, {"sha": "419e465ed8fb27cb83b960db0739e205ed581c29", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -10,8 +10,6 @@\n //!\n //! `ReachedFixedPoint` signals about this.\n \n-use std::iter::successors;\n-\n use base_db::Edition;\n use hir_expand::name;\n use hir_expand::name::Name;\n@@ -131,8 +129,8 @@ impl DefMap {\n             result.krate = result.krate.or(new.krate);\n             result.segment_index = result.segment_index.min(new.segment_index);\n \n-            match &current_map.parent {\n-                Some(map) => current_map = map,\n+            match &current_map.block {\n+                Some(block) => current_map = &block.parent,\n                 None => return result,\n             }\n         }\n@@ -193,14 +191,35 @@ impl DefMap {\n                 self.resolve_name_in_module(db, original_module, &segment, prefer_module)\n             }\n             PathKind::Super(lvl) => {\n-                let m = successors(Some(original_module), |m| self.modules[*m].parent)\n-                    .nth(lvl as usize);\n-                if let Some(local_id) = m {\n-                    PerNs::types(self.module_id(local_id).into(), Visibility::Public)\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                let mut module = original_module;\n+                for i in 0..lvl {\n+                    match self.modules[module].parent {\n+                        Some(it) => module = it,\n+                        None => match &self.block {\n+                            Some(block) => {\n+                                // Look up remaining path in parent `DefMap`\n+                                let new_path = ModPath {\n+                                    kind: PathKind::Super(lvl - i),\n+                                    segments: path.segments.clone(),\n+                                };\n+                                log::debug!(\"`super` path: {} -> {} in parent map\", path, new_path);\n+                                return block.parent.resolve_path_fp_with_macro(\n+                                    db,\n+                                    mode,\n+                                    block.parent_module,\n+                                    &new_path,\n+                                    shadow,\n+                                );\n+                            }\n+                            None => {\n+                                log::debug!(\"super path in root module\");\n+                                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                            }\n+                        },\n+                    }\n                 }\n+\n+                PerNs::types(self.module_id(module).into(), Visibility::Public)\n             }\n             PathKind::Abs => {\n                 // 2018-style absolute path -- only extern prelude"}, {"sha": "b36d0b59bd73ac62a91a45e7d2bfeef36b0f54b3", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -8,12 +8,12 @@ mod block;\n \n use std::sync::Arc;\n \n-use base_db::{fixture::WithFixture, SourceDatabase};\n+use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n use expect_test::{expect, Expect};\n-use hir_expand::db::AstDatabase;\n+use syntax::AstNode;\n use test_utils::mark;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB, Lookup};\n \n fn compute_crate_def_map(ra_fixture: &str) -> Arc<DefMap> {\n     let db = TestDB::with_files(ra_fixture);\n@@ -23,14 +23,58 @@ fn compute_crate_def_map(ra_fixture: &str) -> Arc<DefMap> {\n \n fn compute_block_def_map(ra_fixture: &str) -> Arc<DefMap> {\n     let (db, position) = TestDB::with_position(ra_fixture);\n+\n+    // FIXME: perhaps we should make this use body lowering tests instead?\n+\n     let module = db.module_for_file(position.file_id);\n-    let ast_map = db.ast_id_map(position.file_id.into());\n-    let ast = db.parse(position.file_id);\n-    let block: ast::BlockExpr =\n-        syntax::algo::find_node_at_offset(&ast.syntax_node(), position.offset).unwrap();\n-    let block_id = ast_map.ast_id(&block);\n+    let mut def_map = db.crate_def_map(module.krate);\n+    while let Some(new_def_map) = descend_def_map_at_position(&db, position, def_map.clone()) {\n+        def_map = new_def_map;\n+    }\n+\n+    // FIXME: select the right module, not the root\n+\n+    def_map\n+}\n+\n+fn descend_def_map_at_position(\n+    db: &dyn DefDatabase,\n+    position: FilePosition,\n+    def_map: Arc<DefMap>,\n+) -> Option<Arc<DefMap>> {\n+    for (local_id, module_data) in def_map.modules() {\n+        let mod_def = module_data.origin.definition_source(db);\n+        let ast_map = db.ast_id_map(mod_def.file_id);\n+        let item_tree = db.item_tree(mod_def.file_id);\n+        let root = db.parse_or_expand(mod_def.file_id).unwrap();\n+        for item in module_data.scope.declarations() {\n+            match item {\n+                ModuleDefId::FunctionId(it) => {\n+                    // Technically blocks can be inside any type (due to arrays and const generics),\n+                    // and also in const/static initializers. For tests we only really care about\n+                    // functions though.\n+\n+                    let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n+\n+                    if ast.syntax().text_range().contains(position.offset) {\n+                        // Cursor inside function, descend into its body's DefMap.\n+                        // Note that we don't handle block *expressions* inside function bodies.\n+                        let ast_map = db.ast_id_map(position.file_id.into());\n+                        let ast_id = ast_map.ast_id(&ast.body().unwrap());\n+                        let block = BlockLoc {\n+                            ast_id: InFile::new(position.file_id.into(), ast_id),\n+                            module: def_map.module_id(local_id),\n+                        };\n+                        let block_id = db.intern_block(block);\n+                        return Some(db.block_def_map(block_id));\n+                    }\n+                }\n+                _ => continue,\n+            }\n+        }\n+    }\n \n-    db.block_def_map(module.krate, InFile::new(position.file_id.into(), block_id))\n+    None\n }\n \n fn check(ra_fixture: &str, expect: Expect) {"}, {"sha": "470ca593e199f5e9369394d2ea0e382ea0b5ed54", "filename": "crates/hir_def/src/nameres/tests/block.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37091d2d0175b0999d6383d48f538cdbf0267a0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fblock.rs?ref=a37091d2d0175b0999d6383d48f538cdbf0267a0", "patch": "@@ -95,3 +95,29 @@ fn outer() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn super_imports() {\n+    check_at(\n+        r#\"\n+mod module {\n+    fn f() {\n+        use super::Struct;\n+        $0\n+    }\n+}\n+\n+struct Struct {}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            Struct: t\n+            crate\n+            Struct: t\n+            module: t\n+\n+            crate::module\n+            f: v\n+        \"#]],\n+    );\n+}"}]}