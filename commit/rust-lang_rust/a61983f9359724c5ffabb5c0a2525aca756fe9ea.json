{"sha": "a61983f9359724c5ffabb5c0a2525aca756fe9ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTk4M2Y5MzU5NzI0YzVmZmFiYjVjMGEyNTI1YWNhNzU2ZmU5ZWE=", "commit": {"author": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-02-05T10:22:32Z"}, "committer": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-02-05T10:26:19Z"}, "message": "Remove MutexGuard::map, as it is not safe in combination with Condvar.\n\nIt could return in the future if it returned a different guard type, which\ncould not be used with Condvar, otherwise it is unsafe as another thread\ncan invalidate an \"inner\" reference during a Condvar::wait.\n\ncc #27746", "tree": {"sha": "c6dec5d3f1cf4aea78fe2aea5b1e28796c63adf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6dec5d3f1cf4aea78fe2aea5b1e28796c63adf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a61983f9359724c5ffabb5c0a2525aca756fe9ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a61983f9359724c5ffabb5c0a2525aca756fe9ea", "html_url": "https://github.com/rust-lang/rust/commit/a61983f9359724c5ffabb5c0a2525aca756fe9ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a61983f9359724c5ffabb5c0a2525aca756fe9ea/comments", "author": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ad6dc2556c19f49280b561fc1f5246ff9f9d6ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad6dc2556c19f49280b561fc1f5246ff9f9d6ed", "html_url": "https://github.com/rust-lang/rust/commit/2ad6dc2556c19f49280b561fc1f5246ff9f9d6ed"}], "stats": {"total": 61, "additions": 1, "deletions": 60}, "files": [{"sha": "5ea0a3d7142f4aa8a81e5bdf86f109c5df779767", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a61983f9359724c5ffabb5c0a2525aca756fe9ea/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a61983f9359724c5ffabb5c0a2525aca756fe9ea/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=a61983f9359724c5ffabb5c0a2525aca756fe9ea", "patch": "@@ -387,50 +387,6 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n             }\n         })\n     }\n-\n-    /// Transform this guard to hold a sub-borrow of the original data.\n-    ///\n-    /// Applies the supplied closure to the data, returning a new lock\n-    /// guard referencing the borrow returned by the closure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// # #![feature(guard_map)]\n-    /// # use std::sync::{Mutex, MutexGuard};\n-    /// let x = Mutex::new(vec![1, 2]);\n-    ///\n-    /// {\n-    ///     let mut y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n-    ///     *y = 3;\n-    /// }\n-    ///\n-    /// assert_eq!(&*x.lock().unwrap(), &[3, 2]);\n-    /// ```\n-    #[unstable(feature = \"guard_map\",\n-               reason = \"recently added, needs RFC for stabilization\",\n-               issue = \"27746\")]\n-    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n-        where F: FnOnce(&'mutex mut T) -> &'mutex mut U\n-    {\n-        // Compute the new data while still owning the original lock\n-        // in order to correctly poison if the callback panics.\n-        let data = unsafe { ptr::read(&this.__data) };\n-        let new_data = cb(data);\n-\n-        // We don't want to unlock the lock by running the destructor of the\n-        // original lock, so just read the fields we need and forget it.\n-        let (poison, lock) = unsafe {\n-            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n-        };\n-        mem::forget(this);\n-\n-        MutexGuard {\n-            __lock: lock,\n-            __data: new_data,\n-            __poison: poison\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -469,7 +425,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar, MutexGuard};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -713,19 +669,4 @@ mod tests {\n         let comp: &[i32] = &[4, 2, 5];\n         assert_eq!(&*mutex.lock().unwrap(), comp);\n     }\n-\n-    #[test]\n-    fn test_mutex_guard_map_panic() {\n-        let mutex = Arc::new(Mutex::new(vec![1, 2]));\n-        let mutex2 = mutex.clone();\n-\n-        thread::spawn(move || {\n-            let _ = MutexGuard::map::<usize, _>(mutex2.lock().unwrap(), |_| panic!());\n-        }).join().unwrap_err();\n-\n-        match mutex.lock() {\n-            Ok(r) => panic!(\"Lock on poisioned Mutex is Ok: {:?}\", &*r),\n-            Err(_) => {}\n-        };\n-    }\n }"}]}