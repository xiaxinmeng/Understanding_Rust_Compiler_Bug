{"sha": "00d1465d13980fc3acf650f182ee0723fbda0e06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZDE0NjVkMTM5ODBmYzNhY2Y2NTBmMTgyZWUwNzIzZmJkYTBlMDY=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-07-19T21:05:18Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-07-19T21:05:18Z"}, "message": "Added a message passing system based on lock free queues for inter-thread communication. Channels now buffer on the sending side, and no longer require blocking when sending. Lots of other refactoring and bug fixes.", "tree": {"sha": "a73cf5f0f20c0bee6722b33d975eb930919fefdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a73cf5f0f20c0bee6722b33d975eb930919fefdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00d1465d13980fc3acf650f182ee0723fbda0e06", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00d1465d13980fc3acf650f182ee0723fbda0e06", "html_url": "https://github.com/rust-lang/rust/commit/00d1465d13980fc3acf650f182ee0723fbda0e06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00d1465d13980fc3acf650f182ee0723fbda0e06/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f0656d9084970fcc02ba9c27277265b8b3b7217", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0656d9084970fcc02ba9c27277265b8b3b7217", "html_url": "https://github.com/rust-lang/rust/commit/1f0656d9084970fcc02ba9c27277265b8b3b7217"}], "stats": {"total": 2328, "additions": 1494, "deletions": 834}, "files": [{"sha": "4449418e0f129f642d599bfc04ad772b58fa082e", "filename": "src/Makefile", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -244,7 +244,10 @@ BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n \n-RUNTIME_CS := rt/rust.cpp \\\n+RUNTIME_CS := rt/sync/spin_lock.cpp \\\n+\t\t\t  rt/sync/lock_free_queue.cpp \\\n+\t\t\t  rt/sync/condition_variable.cpp \\\n+              rt/rust.cpp \\\n               rt/rust_builtin.cpp \\\n               rt/rust_crate.cpp \\\n               rt/rust_crate_cache.cpp \\\n@@ -256,12 +259,19 @@ RUNTIME_CS := rt/rust.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_timer.cpp \\\n+              rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp\n \n-RUNTIME_HDR := rt/rust.h \\\n+RUNTIME_HDR := rt/globals.h \\\n+\t\t\t   rt/rust.h \\\n                rt/rust_dwarf.h \\\n                rt/rust_internal.h \\\n-               rt/rust_util.h\n+               rt/rust_util.h \\\n+               rt/rust_chan.h \\\n+               rt/rust_dom.h \\\n+               rt/rust_task.h \\\n+               rt/rust_proxy.h \\\n+               rt/circular_buffer.h\n \n RUNTIME_INCS := -Irt/isaac -Irt/uthash\n RUNTIME_OBJS := $(RUNTIME_CS:.cpp=$(CFG_OBJ_SUFFIX))\n@@ -363,6 +373,8 @@ TEST_XFAILS_X86 :=  $(MUT_BOX_XFAILS) \\\n                     test/run-pass/task-comm.rs \\\n                     test/run-pass/vec-alloc-append.rs \\\n                     test/run-pass/vec-slice.rs \\\n+\t\t\t\t\ttest/run-pass/task-comm-3.rs \\\n+\t\t\t\t\ttest/run-pass/task-comm-4.rs \\\n                     test/compile-fail/bad-recv.rs \\\n                     test/compile-fail/bad-send.rs \\\n                     test/compile-fail/infinite-tag-type-recursion.rs \\\n@@ -452,6 +464,11 @@ TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       tail-cps.rs \\\n                       tail-direct.rs \\\n                       task-comm.rs \\\n+                      task-comm-0.rs \\\n+                      task-comm-1.rs \\\n+                      task-comm-2.rs \\\n+                      task-comm-3.rs \\\n+                      task-comm-4.rs \\\n                       threads.rs \\\n                       tup.rs \\\n                       type-sizes.rs \\"}, {"sha": "e4bb3c9cdea134e5aff5c7a29da7ce9e237da251", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -13,7 +13,7 @@\n let rc_base_field_refcnt = 0;;\n \n let task_field_refcnt = rc_base_field_refcnt;;\n-let task_field_stk = task_field_refcnt + 1;;\n+let task_field_stk = task_field_refcnt + 2;;\n let task_field_runtime_sp = task_field_stk + 1;;\n let task_field_rust_sp = task_field_runtime_sp + 1;;\n let task_field_gc_alloc_chain = task_field_rust_sp + 1;;"}, {"sha": "0e1979c13718674ad49f8ea484e07bdac2bc6eb9", "filename": "src/rt/circular_buffer.cpp", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,118 @@\n+/*\n+ * A simple resizable circular buffer.\n+ */\n+\n+#include \"rust_internal.h\"\n+\n+circular_buffer::circular_buffer(rust_dom *dom, size_t unit_sz) :\n+    dom(dom),\n+    _buffer_sz(INITIAL_CIRCULAR_BUFFFER_SIZE_IN_UNITS * unit_sz),\n+    unit_sz(unit_sz),\n+    _next(0),\n+    _unread(0),\n+    _buffer((uint8_t *)dom->calloc(_buffer_sz)) {\n+\n+    A(dom, unit_sz, \"Unit size must be larger than zero.\");\n+\n+    dom->log(rust_log::MEM | rust_log::COMM,\n+             \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n+             \"-> circular_buffer=0x%\" PRIxPTR,\n+             _buffer_sz, _unread, this);\n+\n+    A(dom, _buffer, \"Failed to allocate buffer.\");\n+}\n+\n+circular_buffer::~circular_buffer() {\n+    dom->log(rust_log::MEM | rust_log::COMM,\n+             \"~circular_buffer 0x%\" PRIxPTR,\n+             this);\n+    I(dom, _buffer);\n+    // I(dom, unread == 0);\n+    dom->free(_buffer);\n+}\n+\n+/**\n+ * Copies the unread data from this buffer to the \"dst\" address.\n+ */\n+void\n+circular_buffer::transfer(void *dst) {\n+    I(dom, dst);\n+    uint8_t *ptr = (uint8_t *) dst;\n+    for (size_t i = 0; i < _unread; i += unit_sz) {\n+        memcpy(&ptr[i], &_buffer[_next + i % _buffer_sz], unit_sz);\n+    }\n+}\n+\n+/**\n+ * Copies the data at the \"src\" address into this buffer. The buffer is\n+ * grown if it isn't large enough.\n+ */\n+void\n+circular_buffer::enqueue(void *src) {\n+    I(dom, src);\n+    I(dom, _unread <= _buffer_sz);\n+\n+    // Grow if necessary.\n+    if (_unread == _buffer_sz) {\n+        I(dom, _buffer_sz <= MAX_CIRCULAR_BUFFFER_SIZE);\n+        void *tmp = dom->malloc(_buffer_sz << 1);\n+        transfer(tmp);\n+        _buffer_sz <<= 1;\n+        dom->free(_buffer);\n+        _buffer = (uint8_t *)tmp;\n+    }\n+\n+    dom->log(rust_log::MEM | rust_log::COMM,\n+             \"circular_buffer enqueue \"\n+             \"unread: %d, buffer_sz: %d, unit_sz: %d\",\n+             _unread, _buffer_sz, unit_sz);\n+\n+    I(dom, _unread < _buffer_sz);\n+    I(dom, _unread + unit_sz <= _buffer_sz);\n+\n+    // Copy data\n+    size_t i = (_next + _unread) % _buffer_sz;\n+    memcpy(&_buffer[i], src, unit_sz);\n+    _unread += unit_sz;\n+\n+    dom->log(rust_log::MEM | rust_log::COMM,\n+             \"circular_buffer pushed data at index: %d\", i);\n+}\n+\n+/**\n+ * Copies data from this buffer to the \"dst\" address. The buffer is\n+ * shrunk if possible.\n+ */\n+void\n+circular_buffer::dequeue(void *dst) {\n+    I(dom, dst);\n+    I(dom, unit_sz > 0);\n+    I(dom, _unread >= unit_sz);\n+    I(dom, _unread <= _buffer_sz);\n+    I(dom, _buffer);\n+    size_t i = _next;\n+    memcpy(dst, &_buffer[i], unit_sz);\n+    dom->log(rust_log::MEM | rust_log::COMM,\n+             \"shifted data from index %d\", i);\n+    _unread -= unit_sz;\n+    _next += unit_sz;\n+    I(dom, _next <= _buffer_sz);\n+    if (_next == _buffer_sz) {\n+        _next = 0;\n+    }\n+\n+    // Shrink if possible.\n+    if (_buffer_sz >= INITIAL_CIRCULAR_BUFFFER_SIZE_IN_UNITS * unit_sz &&\n+        _unread <= _buffer_sz / 4) {\n+        void *tmp = dom->malloc(_buffer_sz / 2);\n+        transfer(tmp);\n+        _buffer_sz >>= 1;\n+        dom->free(_buffer);\n+        _buffer = (uint8_t *)tmp;\n+    }\n+}\n+\n+bool\n+circular_buffer::is_empty() {\n+    return _unread == 0;\n+}"}, {"sha": "c0c0da5eb1a7edfb410a2b5b704e0dcfa84b7301", "filename": "src/rt/circular_buffer.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fcircular_buffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fcircular_buffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,30 @@\n+/*\n+ *\n+ */\n+\n+#ifndef CIRCULAR_BUFFER_H\n+#define CIRCULAR_BUFFER_H\n+\n+class\n+circular_buffer : public dom_owned<circular_buffer> {\n+    static const size_t INITIAL_CIRCULAR_BUFFFER_SIZE_IN_UNITS = 8;\n+    static const size_t MAX_CIRCULAR_BUFFFER_SIZE = 1 << 24;\n+\n+public:\n+    rust_dom *dom;\n+    circular_buffer(rust_dom *dom, size_t unit_sz);\n+    ~circular_buffer();\n+    void transfer(void *dst);\n+    void enqueue(void *src);\n+    void dequeue(void *dst);\n+    bool is_empty();\n+\n+private:\n+    size_t _buffer_sz;\n+    size_t unit_sz;\n+    size_t _next;\n+    size_t _unread;\n+    uint8_t *_buffer;\n+};\n+\n+#endif /* CIRCULAR_BUFFER_H */"}, {"sha": "f8025a406b447ca4d688f4791c373b016d0c556e", "filename": "src/rt/globals.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fglobals.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fglobals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fglobals.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,33 @@\n+#ifndef GLOBALS_H\n+#define GLOBALS_H\n+\n+#define __STDC_LIMIT_MACROS 1\n+#define __STDC_CONSTANT_MACROS 1\n+#define __STDC_FORMAT_MACROS 1\n+\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <inttypes.h>\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#if defined(__WIN32__)\n+extern \"C\" {\n+#include <windows.h>\n+#include <tchar.h>\n+#include <wincrypt.h>\n+}\n+#elif defined(__GNUC__)\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <dlfcn.h>\n+#include <pthread.h>\n+#include <errno.h>\n+#else\n+#error \"Platform not supported.\"\n+#endif\n+\n+#endif /* GLOBALS_H */"}, {"sha": "00e709c9748f406004807aae7186f34a5cd03325", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,7 +1,6 @@\n #include \"rust_internal.h\"\n #include \"util/array_list.h\"\n \n-\n // #define TRACK_ALLOCATIONS\n // For debugging, keeps track of live allocations, so you can find out\n // exactly what leaked.\n@@ -100,52 +99,6 @@ rust_srv::clone()\n     return new rust_srv();\n }\n \n-\n-int\n-rust_main_loop(rust_dom *dom)\n-{\n-    // Make sure someone is watching, to pull us out of infinite loops.\n-    rust_timer timer(*dom);\n-\n-    int rval;\n-    rust_task *task;\n-\n-    dom->log(rust_log::DOM,\n-            \"running main-loop on domain 0x%\" PRIxPTR, dom);\n-    dom->logptr(\"exit-task glue\",\n-            dom->root_crate->get_exit_task_glue());\n-\n-    while ((task = dom->sched()) != NULL) {\n-        I(dom, task->running());\n-\n-        dom->log(rust_log::TASK,\n-                \"activating task 0x%\" PRIxPTR \", sp=0x%\" PRIxPTR,\n-                (uintptr_t)task, task->rust_sp);\n-\n-        dom->interrupt_flag = 0;\n-\n-        dom->activate(task);\n-\n-        dom->log(rust_log::TASK,\n-                 \"returned from task 0x%\" PRIxPTR\n-                 \" in state '%s', sp=0x%\" PRIxPTR,\n-                 (uintptr_t)task,\n-                 dom->state_vec_name(task->state),\n-                 task->rust_sp);\n-\n-        I(dom, task->rust_sp >= (uintptr_t) &task->stk->data[0]);\n-        I(dom, task->rust_sp < task->stk->limit);\n-\n-        dom->reap_dead_tasks();\n-    }\n-\n-    dom->log(rust_log::DOM, \"finished main-loop (dom.rval = %d)\", dom->rval);\n-    rval = dom->rval;\n-\n-    return rval;\n-}\n-\n-\n struct\n command_line_args\n {\n@@ -243,7 +196,7 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc, char **argv)\n                              (uintptr_t)&main_args,\n                              sizeof(main_args));\n \n-        ret = rust_main_loop(&dom);\n+        ret = dom.start_main_loop();\n     }\n \n #if !defined(__WIN32__)"}, {"sha": "0b492de84a1f22fc9c3ec7eec0502e402ca44ad2", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -19,7 +19,7 @@ str_alloc(rust_task *task, size_t n_bytes)\n extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::TASK, \"last_os_error()\");\n+    task->log(rust_log::TASK, \"last_os_error()\");\n \n #if defined(__WIN32__)\n     LPTSTR buf;\n@@ -95,7 +95,7 @@ extern \"C\" CDECL rust_vec*\n vec_alloc(rust_task *task, type_desc *t, size_t n_elts)\n {\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::MEM,\n+    task->log(rust_log::MEM,\n             \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n              n_elts, t->size);\n     size_t fill = n_elts * t->size;"}, {"sha": "6aa9121aa14fcc001b5748cadcb097d43bde99ec", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,34 +1,62 @@\n-\n #include \"rust_internal.h\"\n #include \"rust_chan.h\"\n \n rust_chan::rust_chan(rust_task *task, rust_port *port) :\n-    task(task),\n-    port(port),\n-    buffer(task->dom, port->unit_sz),\n-    token(this)\n-{\n-    if (port)\n+    task(task), port(port), buffer(task->dom, port->unit_sz), token(this) {\n+\n+    if (port) {\n         port->chans.push(this);\n+        ref();\n+    }\n+\n+    task->log(rust_log::MEM | rust_log::COMM,\n+              \"new rust_chan(task=0x%\" PRIxPTR\n+              \", port=0x%\" PRIxPTR \") -> chan=0x%\"\n+              PRIxPTR, (uintptr_t) task, (uintptr_t) port, (uintptr_t) this);\n }\n \n-rust_chan::~rust_chan()\n-{\n+rust_chan::~rust_chan() {\n     if (port) {\n         if (token.pending())\n             token.withdraw();\n-        port->chans.swapdel(this);\n+        port->chans.swap_delete(this);\n     }\n }\n \n-void\n-rust_chan::disassociate()\n-{\n+void rust_chan::disassociate() {\n     I(task->dom, port);\n \n     if (token.pending())\n         token.withdraw();\n \n     // Delete reference to the port/\n     port = NULL;\n+\n+    deref();\n+}\n+\n+/**\n+ * Attempt to transmit channel data to the associated port.\n+ */\n+int rust_chan::transmit() {\n+    rust_dom *dom = task->dom;\n+\n+    // TODO: Figure out how and why the port would become null.\n+    if (port == NULL) {\n+        dom->log(rust_log::COMM, \"invalid port, transmission incomplete\");\n+        return ERROR;\n+    }\n+\n+    if (buffer.is_empty()) {\n+        dom->log(rust_log::COMM, \"buffer is empty, transmission incomplete\");\n+        return ERROR;\n+    }\n+\n+    if(port->task->blocked_on(port)) {\n+        buffer.dequeue(port->task->rendezvous_ptr);\n+        port->task->wakeup(port);\n+    }\n+\n+    return 0;\n+\n }"}, {"sha": "3e32d83837b006b335182821f3efa06814b0678d", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -9,14 +9,16 @@ class rust_chan : public rc_base<rust_chan>, public task_owned<rust_chan> {\n \n     rust_task *task;\n     rust_port *port;\n-    circ_buf buffer;\n+    circular_buffer buffer;\n     size_t idx;           // Index into port->chans.\n \n     // Token belonging to this chan, it will be placed into a port's\n     // writers vector if we have something to send to the port.\n     rust_token token;\n \n     void disassociate();\n+\n+    int transmit();\n };\n \n #endif /* RUST_CHAN_H */"}, {"sha": "37929b8b05ab103f83da1c638cf40957e7e02ceb", "filename": "src/rt/rust_comm.cpp", "status": "modified", "additions": 7, "deletions": 112, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_comm.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_comm.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_comm.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -10,109 +10,6 @@ rust_alarm::rust_alarm(rust_task *receiver) :\n {\n }\n \n-\n-// Circular buffers.\n-\n-circ_buf::circ_buf(rust_dom *dom, size_t unit_sz) :\n-    dom(dom),\n-    alloc(INIT_CIRC_BUF_UNITS * unit_sz),\n-    unit_sz(unit_sz),\n-    next(0),\n-    unread(0),\n-    data((uint8_t *)dom->calloc(alloc))\n-{\n-    I(dom, unit_sz);\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"new circ_buf(alloc=%d, unread=%d) -> circ_buf=0x%\" PRIxPTR,\n-             alloc, unread, this);\n-    I(dom, data);\n-}\n-\n-circ_buf::~circ_buf()\n-{\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"~circ_buf 0x%\" PRIxPTR,\n-             this);\n-    I(dom, data);\n-    // I(dom, unread == 0);\n-    dom->free(data);\n-}\n-\n-void\n-circ_buf::transfer(void *dst)\n-{\n-    size_t i;\n-    uint8_t *d = (uint8_t *)dst;\n-    I(dom, dst);\n-    for (i = 0; i < unread; i += unit_sz)\n-        memcpy(&d[i], &data[next + i % alloc], unit_sz);\n-}\n-\n-void\n-circ_buf::push(void *src)\n-{\n-    size_t i;\n-    void *tmp;\n-\n-    I(dom, src);\n-    I(dom, unread <= alloc);\n-\n-    /* Grow if necessary. */\n-    if (unread == alloc) {\n-        I(dom, alloc <= MAX_CIRC_BUF_SIZE);\n-        tmp = dom->malloc(alloc << 1);\n-        transfer(tmp);\n-        alloc <<= 1;\n-        dom->free(data);\n-        data = (uint8_t *)tmp;\n-    }\n-\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"circ buf push, unread=%d, alloc=%d, unit_sz=%d\",\n-             unread, alloc, unit_sz);\n-\n-    I(dom, unread < alloc);\n-    I(dom, unread + unit_sz <= alloc);\n-\n-    i = (next + unread) % alloc;\n-    memcpy(&data[i], src, unit_sz);\n-\n-    dom->log(rust_log::MEM|rust_log::COMM, \"pushed data at index %d\", i);\n-    unread += unit_sz;\n-}\n-\n-void\n-circ_buf::shift(void *dst)\n-{\n-    size_t i;\n-    void *tmp;\n-\n-    I(dom, dst);\n-    I(dom, unit_sz > 0);\n-    I(dom, unread >= unit_sz);\n-    I(dom, unread <= alloc);\n-    I(dom, data);\n-    i = next;\n-    memcpy(dst, &data[i], unit_sz);\n-    dom->log(rust_log::MEM|rust_log::COMM, \"shifted data from index %d\", i);\n-    unread -= unit_sz;\n-    next += unit_sz;\n-    I(dom, next <= alloc);\n-    if (next == alloc)\n-        next = 0;\n-\n-    /* Shrink if necessary. */\n-    if (alloc >= INIT_CIRC_BUF_UNITS * unit_sz &&\n-        unread <= alloc / 4) {\n-        tmp = dom->malloc(alloc / 2);\n-        transfer(tmp);\n-        alloc >>= 1;\n-        dom->free(data);\n-        data = (uint8_t *)tmp;\n-    }\n-}\n-\n-\n // Ports.\n \n rust_port::rust_port(rust_task *task, size_t unit_sz) :\n@@ -121,18 +18,16 @@ rust_port::rust_port(rust_task *task, size_t unit_sz) :\n     writers(task->dom),\n     chans(task->dom)\n {\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n-             PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n+    task->log(rust_log::MEM|rust_log::COMM,\n+              \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n+              PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n }\n \n rust_port::~rust_port()\n {\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::COMM|rust_log::MEM,\n-             \"~rust_port 0x%\" PRIxPTR,\n-             (uintptr_t)this);\n+    task->log(rust_log::COMM|rust_log::MEM,\n+              \"~rust_port 0x%\" PRIxPTR,\n+              (uintptr_t)this);\n     while (chans.length() > 0)\n         chans.pop()->disassociate();\n }\n@@ -182,7 +77,7 @@ rust_token::withdraw()\n \n     if (task->blocked())\n         task->wakeup(this); // must be blocked on us (or dead)\n-    port->writers.swapdel(this);\n+    port->writers.swap_delete(this);\n     submitted = false;\n }\n "}, {"sha": "650e3bb1ef3a75faf65f3b9389f70a454ea876f5", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -251,7 +251,7 @@ rust_crate_cache::flush() {\n         if (s) {\n             dom->log(rust_log::CACHE,\n                      \"rust_crate_cache::flush() deref rust_sym %\"\n-                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->refcnt);\n+                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n         }\n         rust_syms[i] = NULL;\n@@ -262,7 +262,7 @@ rust_crate_cache::flush() {\n         if (s) {\n             dom->log(rust_log::CACHE,\n                      \"rust_crate_cache::flush() deref c_sym %\"\n-                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->refcnt);\n+                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, s->ref_count);\n             s->deref();\n         }\n         c_syms[i] = NULL;\n@@ -272,7 +272,7 @@ rust_crate_cache::flush() {\n         lib *l = libs[i];\n         if (l) {\n             dom->log(rust_log::CACHE, \"rust_crate_cache::flush() deref lib %\"\n-                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, l->refcnt);\n+                     PRIdPTR \" (rc=%\" PRIdPTR \")\", i, l->ref_count);\n             l->deref();\n         }\n         libs[i] = NULL;"}, {"sha": "39124491a283fed440b3ef6edacb2031a4a5ee2c", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 162, "deletions": 13, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -4,6 +4,24 @@\n \n template class ptr_vec<rust_task>;\n \n+rust_message::rust_message(rust_dom *dom) : dom(dom) {\n+\n+}\n+\n+void rust_message::process() {\n+\n+}\n+\n+kill_task_message::kill_task_message(rust_dom *dom, rust_task *task) :\n+        rust_message(dom), _task(task) {\n+\n+}\n+\n+void kill_task_message::process() {\n+    _task->ref_count--;\n+    _task->kill();\n+}\n+\n rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate) :\n     interrupt_flag(0),\n     root_crate(root_crate),\n@@ -80,14 +98,26 @@ rust_dom::activate(rust_task *task) {\n     curr_task = NULL;\n }\n \n+void\n+rust_dom::log(rust_task *task, uint32_t type_bits, char const *fmt, ...) {\n+    char buf[256];\n+    if (_log.is_tracing(type_bits)) {\n+        va_list args;\n+        va_start(args, fmt);\n+        vsnprintf(buf, sizeof(buf), fmt, args);\n+        _log.trace_ln(task, type_bits, buf);\n+        va_end(args);\n+    }\n+}\n+\n void\n rust_dom::log(uint32_t type_bits, char const *fmt, ...) {\n     char buf[256];\n     if (_log.is_tracing(type_bits)) {\n         va_list args;\n         va_start(args, fmt);\n         vsnprintf(buf, sizeof(buf), fmt, args);\n-        _log.trace_ln(type_bits, buf);\n+        _log.trace_ln(NULL, type_bits, buf);\n         va_end(args);\n     }\n }\n@@ -189,7 +219,7 @@ rust_dom::remove_task_from_state_vec(ptr_vec<rust_task> *v, rust_task *task)\n         \"removing task 0x%\" PRIxPTR \" in state '%s' from vec 0x%\" PRIxPTR,\n         (uintptr_t)task, state_vec_name(v), (uintptr_t)v);\n     I(this, (*v)[task->idx] == task);\n-    v->swapdel(task);\n+    v->swap_delete(task);\n }\n \n const char *\n@@ -203,25 +233,67 @@ rust_dom::state_vec_name(ptr_vec<rust_task> *v)\n     return \"dead\";\n }\n \n+/**\n+ * Delete any dead tasks.\n+ */\n void\n-rust_dom::reap_dead_tasks()\n-{\n+rust_dom::reap_dead_tasks() {\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n-        rust_task *t = dead_tasks[i];\n-        if (t == root_task || t->refcnt == 0) {\n-            I(this, !t->waiting_tasks.length());\n-            dead_tasks.swapdel(t);\n+        rust_task *task = dead_tasks[i];\n+//        log(rust_log::TASK, \"dead task 0x%\" PRIxPTR \" with ref_count: %d\",\n+//            task, task->ref_count);\n+        if (task->ref_count == 0) {\n+            I(this, !task->waiting_tasks.length());\n+            dead_tasks.swap_delete(task);\n             log(rust_log::TASK,\n-                \"deleting unreferenced dead task 0x%\" PRIxPTR, t);\n-            delete t;\n+                \"deleting unreferenced dead task 0x%\" PRIxPTR, task);\n+            delete task;\n             continue;\n         }\n         ++i;\n     }\n }\n \n+\n+/**\n+ * Enqueues a message in this domain's incoming message queue. It's the\n+ * responsibility of the receiver to free the message once it's processed.\n+ */\n+void rust_dom::send_message(rust_message *message) {\n+    log(rust_log::COMM, \"enqueueing message 0x%\" PRIxPTR\n+                        \" in queue 0x%\" PRIxPTR,\n+                        message,\n+                        &_incoming_message_queue);\n+    _incoming_message_queue.enqueue(message);\n+    _incoming_message_pending.signal();\n+}\n+\n+/**\n+ * Drains and processes incoming pending messages.\n+ */\n+void rust_dom::drain_incoming_message_queue() {\n+    rust_message *message;\n+    while ((message = (rust_message *) _incoming_message_queue.dequeue())) {\n+        log(rust_log::COMM, \"read 0x%\" PRIxPTR\n+                            \" from queue 0x%\" PRIxPTR,\n+                            message,\n+                            &_incoming_message_queue);\n+        log(rust_log::COMM, \"processing incoming message 0x%\" PRIxPTR,\n+                            message);\n+        message->process();\n+        delete message;\n+    }\n+}\n+\n+/**\n+ * Schedules a running task for execution. Only running tasks can be\n+ * activated.  Blocked tasks have to be unblocked before they can be\n+ * activated.\n+ *\n+ * Returns NULL if no tasks can be scheduled.\n+ */\n rust_task *\n-rust_dom::sched()\n+rust_dom::schedule_task()\n {\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n@@ -231,11 +303,88 @@ rust_dom::sched()\n         i %= running_tasks.length();\n         return (rust_task *)running_tasks[i];\n     }\n-    log(rust_log::DOM|rust_log::TASK,\n-        \"no schedulable tasks\");\n+    // log(rust_log::DOM|rust_log::TASK, \"no schedulable tasks\");\n     return NULL;\n }\n \n+/**\n+ * Starts the main scheduler loop which performs task scheduling for this\n+ * domain.\n+ *\n+ * Returns once no more tasks can be scheduled.\n+ */\n+int\n+rust_dom::start_main_loop()\n+{\n+    // Make sure someone is watching, to pull us out of infinite loops.\n+    rust_timer timer(this);\n+\n+    log(rust_log::DOM, \"running main-loop on domain 0x%\" PRIxPTR, this);\n+    logptr(\"exit-task glue\", root_crate->get_exit_task_glue());\n+\n+    while (n_live_tasks() > 0) {\n+        rust_task *scheduled_task = schedule_task();\n+\n+        // If we cannot schedule a task because all other live tasks\n+        // are blocked, wait on a condition variable which is signaled\n+        // if progress is made in other domains.\n+\n+        if (scheduled_task == NULL) {\n+            log(rust_log::TASK,\n+                \"all tasks are blocked, waiting for progress ...\");\n+            _progress.wait();\n+            continue;\n+        }\n+\n+        I(this, scheduled_task->running());\n+\n+        log(rust_log::TASK,\n+                 \"activating task 0x%\" PRIxPTR \", sp=x%\" PRIxPTR,\n+                 (uintptr_t)scheduled_task, scheduled_task->rust_sp);\n+\n+        interrupt_flag = 0;\n+\n+        activate(scheduled_task);\n+\n+        log(rust_log::TASK,\n+                 \"returned from task 0x%\" PRIxPTR\n+                 \" in state '%s', sp=0x%\" PRIxPTR,\n+                 (uintptr_t)scheduled_task,\n+                 state_vec_name(scheduled_task->state),\n+                 scheduled_task->rust_sp);\n+\n+        I(this, scheduled_task->rust_sp >=\n+          (uintptr_t) &scheduled_task->stk->data[0]);\n+        I(this, scheduled_task->rust_sp < scheduled_task->stk->limit);\n+\n+        drain_incoming_message_queue();\n+\n+        reap_dead_tasks();\n+    }\n+\n+    log(rust_log::DOM, \"terminated scheduler loop, reaping dead tasks ...\");\n+\n+    while (dead_tasks.length() > 0) {\n+        log(rust_log::DOM,\n+            \"waiting for %d dead tasks to become dereferenced ...\",\n+            dead_tasks.length());\n+\n+        log(rust_log::DOM,\n+            \"waiting for %\" PRIxPTR, dead_tasks[0]);\n+\n+        if (_incoming_message_queue.is_empty()) {\n+            _incoming_message_pending.wait();\n+        } else {\n+            drain_incoming_message_queue();\n+        }\n+        reap_dead_tasks();\n+    }\n+\n+    log(rust_log::DOM, \"finished main-loop (dom.rval = %d)\", rval);\n+    return rval;\n+}\n+\n+\n rust_crate_cache *\n rust_dom::get_cache(rust_crate const *crate) {\n     log(rust_log::CACHE,"}, {"sha": "38d04dbfb5371d6bad1559050410c4e1b5b195e3", "filename": "src/rt/rust_dom.h", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,92 @@\n+/*\n+ * rust_dom.h\n+ */\n+\n+#ifndef RUST_DOM_H\n+#define RUST_DOM_H\n+\n+#include \"sync/lock_free_queue.h\"\n+\n+class rust_message : public lock_free_queue_node,\n+                     public dom_owned<rust_message> {\n+public:\n+    rust_dom *dom;\n+    rust_message(rust_dom *dom);\n+    virtual void process();\n+};\n+\n+class kill_task_message : public rust_message {\n+    rust_task *_task;\n+public:\n+    kill_task_message(rust_dom *dom, rust_task *task);\n+    void process();\n+};\n+\n+struct rust_dom\n+{\n+    // Fields known to the compiler:\n+    uintptr_t interrupt_flag;\n+\n+    // Fields known only by the runtime:\n+\n+    // NB: the root crate must remain in memory until the root of the\n+    // tree of domains exits. All domains within this tree have a\n+    // copy of this root_crate value and use it for finding utility\n+    // glue.\n+    rust_crate const *root_crate;\n+    rust_log _log;\n+    rust_srv *srv;\n+    ptr_vec<rust_task> running_tasks;\n+    ptr_vec<rust_task> blocked_tasks;\n+    ptr_vec<rust_task> dead_tasks;\n+    ptr_vec<rust_crate_cache> caches;\n+    randctx rctx;\n+    rust_task *root_task;\n+    rust_task *curr_task;\n+    int rval;\n+\n+    condition_variable _progress;\n+\n+    // Incoming messages from other domains.\n+    condition_variable _incoming_message_pending;\n+    lock_free_queue _incoming_message_queue;\n+\n+#ifndef __WIN32__\n+    pthread_attr_t attr;\n+#endif\n+\n+    rust_dom(rust_srv *srv, rust_crate const *root_crate);\n+    ~rust_dom();\n+\n+    void activate(rust_task *task);\n+    void log(rust_task *task, uint32_t logbit, char const *fmt, ...);\n+    void log(uint32_t logbit, char const *fmt, ...);\n+    rust_log & get_log();\n+    void logptr(char const *msg, uintptr_t ptrval);\n+    template<typename T>\n+    void logptr(char const *msg, T* ptrval);\n+    void fail();\n+    void *malloc(size_t sz);\n+    void *calloc(size_t sz);\n+    void *realloc(void *data, size_t sz);\n+    void free(void *p);\n+\n+    void send_message(rust_message *message);\n+    void drain_incoming_message_queue();\n+\n+#ifdef __WIN32__\n+    void win32_require(LPCTSTR fn, BOOL ok);\n+#endif\n+\n+    rust_crate_cache *get_cache(rust_crate const *crate);\n+    size_t n_live_tasks();\n+    void add_task_to_state_vec(ptr_vec<rust_task> *v, rust_task *task);\n+    void remove_task_from_state_vec(ptr_vec<rust_task> *v, rust_task *task);\n+    const char *state_vec_name(ptr_vec<rust_task> *v);\n+\n+    void reap_dead_tasks();\n+    rust_task *schedule_task();\n+    int start_main_loop();\n+};\n+\n+#endif /* RUST_DOM_H */"}, {"sha": "d962e894153bdf3a21eb1d35475951f155982a3b", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 50, "deletions": 173, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -5,6 +5,8 @@\n #define __STDC_CONSTANT_MACROS 1\n #define __STDC_FORMAT_MACROS 1\n \n+#define ERROR 0\n+\n #include <stdlib.h>\n #include <stdint.h>\n #include <inttypes.h>\n@@ -36,21 +38,26 @@ extern \"C\" {\n #error \"Platform not supported.\"\n #endif\n \n+#include \"sync/condition_variable.h\"\n+\n #ifndef __i386__\n #error \"Target CPU not supported.\"\n #endif\n \n-#define I(dom, e) ((e) ? (void)0 :                              \\\n+#define I(dom, e) ((e) ? (void)0 :                           \\\n                    (dom)->srv->fatal(#e, __FILE__, __LINE__))\n \n+#define A(dom, e, s) ((e) ? (void)0 :                                    \\\n+                      (dom)->srv->fatal(#e \" : \" #s, __FILE__, __LINE__))\n+\n struct rust_task;\n struct rust_port;\n class rust_chan;\n struct rust_token;\n struct rust_dom;\n class rust_crate;\n class rust_crate_cache;\n-class lockfree_queue;\n+// class lockfree_queue;\n \n struct stk_seg;\n struct type_desc;\n@@ -66,14 +73,14 @@ template <typename T>\n struct\n rc_base\n {\n-    size_t refcnt;\n+    size_t ref_count;\n \n     void ref() {\n-        ++refcnt;\n+        ++ref_count;\n     }\n \n     void deref() {\n-        if (--refcnt == 0) {\n+        if (--ref_count == 0) {\n             delete (T*)this;\n         }\n     }\n@@ -122,71 +129,29 @@ ptr_vec : public dom_owned<ptr_vec<T> >\n         return fill;\n     }\n \n+    bool is_empty() {\n+        return fill == 0;\n+    }\n+\n     T *& operator[](size_t offset);\n     void push(T *p);\n     T *pop();\n     void trim(size_t fill);\n-    void swapdel(T* p);\n+    void swap_delete(T* p);\n };\n \n-struct\n-rust_dom\n-{\n-    // Fields known to the compiler:\n-    uintptr_t interrupt_flag;\n-\n-    // Fields known only by the runtime:\n-\n-    // NB: the root crate must remain in memory until the root of the\n-    // tree of domains exits. All domains within this tree have a\n-    // copy of this root_crate value and use it for finding utility\n-    // glue.\n-    rust_crate const *root_crate;\n-    rust_log _log;\n-    rust_srv *srv;\n-    // uint32_t logbits;\n-    ptr_vec<rust_task> running_tasks;\n-    ptr_vec<rust_task> blocked_tasks;\n-    ptr_vec<rust_task> dead_tasks;\n-    ptr_vec<rust_crate_cache> caches;\n-    randctx rctx;\n-    rust_task *root_task;\n-    rust_task *curr_task;\n-    int rval;\n-    lockfree_queue *incoming; // incoming messages from other threads\n-\n-#ifndef __WIN32__\n-    pthread_attr_t attr;\n-#endif\n-\n-    rust_dom(rust_srv *srv, rust_crate const *root_crate);\n-    ~rust_dom();\n-\n-    void activate(rust_task *task);\n-    void log(uint32_t logbit, char const *fmt, ...);\n-    rust_log & get_log();\n-    void logptr(char const *msg, uintptr_t ptrval);\n-    template<typename T>\n-    void logptr(char const *msg, T* ptrval);\n-    void fail();\n-    void *malloc(size_t sz);\n-    void *calloc(size_t sz);\n-    void *realloc(void *data, size_t sz);\n-    void free(void *p);\n-\n-#ifdef __WIN32__\n-    void win32_require(LPCTSTR fn, BOOL ok);\n-#endif\n+#include \"rust_dom.h\"\n \n-    rust_crate_cache *get_cache(rust_crate const *crate);\n-    size_t n_live_tasks();\n-    void add_task_to_state_vec(ptr_vec<rust_task> *v, rust_task *task);\n-    void remove_task_from_state_vec(ptr_vec<rust_task> *v, rust_task *task);\n-    const char *state_vec_name(ptr_vec<rust_task> *v);\n+template <typename T> inline T\n+check_null(rust_dom *dom, T value, char const *expr,\n+           char const *file, size_t line) {\n+    if (value == NULL) {\n+        dom->srv->fatal(expr, file, line);\n+    }\n+    return value;\n+}\n \n-    void reap_dead_tasks();\n-    rust_task *sched();\n-};\n+#define CHECK_NULL(dom, e) (check_null(dom, e, #e, __FILE__, __LINE__))\n \n inline void *operator new(size_t sz, void *mem) {\n     return mem;\n@@ -217,7 +182,7 @@ rust_timer\n     // For now it's just the most basic \"thread that can interrupt\n     // its associated domain-thread\" device, so that we have\n     // *some* form of task-preemption.\n-    rust_dom &dom;\n+    rust_dom *dom;\n     uintptr_t exit_flag;\n \n #if defined(__WIN32__)\n@@ -227,7 +192,7 @@ rust_timer\n     pthread_t thread;\n #endif\n \n-    rust_timer(rust_dom &dom);\n+    rust_timer(rust_dom *dom);\n     ~rust_timer();\n };\n \n@@ -608,94 +573,8 @@ struct gc_alloc {\n     }\n };\n \n-struct\n-rust_task : public rc_base<rust_task>,\n-            public dom_owned<rust_task>,\n-            public rust_cond\n-{\n-    // Fields known to the compiler.\n-    stk_seg *stk;\n-    uintptr_t runtime_sp;      // Runtime sp while task running.\n-    uintptr_t rust_sp;         // Saved sp when not running.\n-    gc_alloc *gc_alloc_chain;  // Linked list of GC allocations.\n-    rust_dom *dom;\n-    rust_crate_cache *cache;\n-\n-    // Fields known only to the runtime.\n-    ptr_vec<rust_task> *state;\n-    rust_cond *cond;\n-    uintptr_t* dptr;           // Rendezvous pointer for send/recv.\n-    rust_task *supervisor;     // Parent-link for failure propagation.\n-    size_t idx;\n-    size_t gc_alloc_thresh;\n-    size_t gc_alloc_accum;\n-\n-    // Wait queue for tasks waiting for this task.\n-    rust_wait_queue waiting_tasks;\n-    rust_alarm alarm;\n-\n-    rust_task(rust_dom *dom,\n-              rust_task *spawner);\n-    ~rust_task();\n-\n-    void start(uintptr_t exit_task_glue,\n-               uintptr_t spawnee_fn,\n-               uintptr_t args,\n-               size_t callsz);\n-    void grow(size_t n_frame_bytes);\n-    bool running();\n-    bool blocked();\n-    bool blocked_on(rust_cond *cond);\n-    bool dead();\n-\n-    void link_gc(gc_alloc *gcm);\n-    void unlink_gc(gc_alloc *gcm);\n-    void *malloc(size_t sz, type_desc *td=0);\n-    void *realloc(void *data, size_t sz, bool gc_mem=false);\n-    void free(void *p, bool gc_mem=false);\n-\n-    const char *state_str();\n-    void transition(ptr_vec<rust_task> *svec, ptr_vec<rust_task> *dvec);\n-\n-    void block(rust_cond *on);\n-    void wakeup(rust_cond *from);\n-    void die();\n-    void unblock();\n-\n-    void check_active() { I(dom, dom->curr_task == this); }\n-    void check_suspended() { I(dom, dom->curr_task != this); }\n-\n-    // Swap in some glue code to run when we have returned to the\n-    // task's context (assuming we're the active task).\n-    void run_after_return(size_t nargs, uintptr_t glue);\n-\n-    // Swap in some glue code to run when we're next activated\n-    // (assuming we're the suspended task).\n-    void run_on_resume(uintptr_t glue);\n-\n-    // Save callee-saved registers and return to the main loop.\n-    void yield(size_t nargs);\n-\n-    // Fail this task (assuming caller-on-stack is different task).\n-    void kill();\n-\n-    // Fail self, assuming caller-on-stack is this task.\n-    void fail(size_t nargs);\n-\n-    // Run the gc glue on the task stack.\n-    void gc(size_t nargs);\n-\n-    // Disconnect from our supervisor.\n-    void unsupervise();\n-\n-    // Notify tasks waiting for us that we are about to die.\n-    void notify_waiting_tasks();\n-\n-    uintptr_t get_fp();\n-    uintptr_t get_previous_fp(uintptr_t fp);\n-    frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n-    rust_crate_cache * get_crate_cache(rust_crate const *curr_crate);\n-};\n+#include \"rust_proxy.h\"\n+#include \"rust_task.h\"\n \n struct rust_port : public rc_base<rust_port>,\n                    public task_owned<rust_port>,\n@@ -722,31 +601,29 @@ struct rust_token : public rust_cond {\n     void withdraw();\n };\n \n+#include \"circular_buffer.h\"\n \n-struct circ_buf : public dom_owned<circ_buf> {\n-    static const size_t INIT_CIRC_BUF_UNITS = 8;\n-    static const size_t MAX_CIRC_BUF_SIZE = 1 << 24;\n-\n-    rust_dom *dom;\n-    size_t alloc;\n-    size_t unit_sz;\n-    size_t next;\n-    size_t unread;\n-    uint8_t *data;\n-\n-    circ_buf(rust_dom *dom, size_t unit_sz);\n-    ~circ_buf();\n-\n-    void transfer(void *dst);\n-    void push(void *src);\n-    void shift(void *dst);\n-};\n+//struct circ_buf : public dom_owned<circ_buf> {\n+//    static const size_t INIT_CIRC_BUF_UNITS = 8;\n+//    static const size_t MAX_CIRC_BUF_SIZE = 1 << 24;\n+//\n+//    rust_dom *dom;\n+//    size_t alloc;\n+//    size_t unit_sz;\n+//    size_t next;\n+//    size_t unread;\n+//    uint8_t *data;\n+//\n+//    circ_buf(rust_dom *dom, size_t unit_sz);\n+//    ~circ_buf();\n+//\n+//    void transfer(void *dst);\n+//    void push(void *src);\n+//    void shift(void *dst);\n+//};\n \n #include \"rust_chan.h\"\n \n-int\n-rust_main_loop(rust_dom *dom);\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "b67876ebe6a0a7bcb401dd977c7a05007a62a480", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 128, "deletions": 49, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -4,9 +4,13 @@\n  */\n \n #include \"rust_internal.h\"\n+#include \"sync/spin_lock.h\"\n+#include \"util/array_list.h\"\n+#include <stdarg.h>\n \n-static uint32_t read_type_bit_mask() {\n-    uint32_t bits = rust_log::ULOG | rust_log::ERR;\n+static uint32_t\n+read_type_bit_mask() {\n+    uint32_t bits = rust_log::ULOG | rust_log::ERR | rust_log::ALL;\n     char *env_str = getenv(\"RUST_LOG\");\n     if (env_str) {\n         bits = 0;\n@@ -27,92 +31,167 @@ static uint32_t read_type_bit_mask() {\n     return bits;\n }\n \n-rust_log::ansi_color rust_log::get_type_color(log_type type) {\n-    switch (type) {\n-    case ERR:\n-        return rust_log::RED;\n-    case UPCALL:\n-        return rust_log::GREEN;\n-    case COMM:\n-        return rust_log::MAGENTA;\n-    case DOM:\n-    case TASK:\n-        return rust_log::LIGHTTEAL;\n-    case MEM:\n-        return rust_log::YELLOW;\n-    default:\n-        return rust_log::WHITE;\n-    }\n+rust_log::ansi_color\n+get_type_color(rust_log::log_type type) {\n+    rust_log::ansi_color color = rust_log::WHITE;\n+    if (type & rust_log::ERR)\n+        color = rust_log::RED;\n+    if (type & rust_log::MEM)\n+        color = rust_log::YELLOW;\n+    if (type & rust_log::UPCALL)\n+        color = rust_log::GREEN;\n+    if (type & rust_log::COMM)\n+        color = rust_log::MAGENTA;\n+    if (type & rust_log::DOM)\n+        color = rust_log::LIGHTTEAL;\n+    if (type & rust_log::TASK)\n+        color = rust_log::LIGHTTEAL;\n+    return color;\n }\n \n-static const char * _foreground_colors[] = { \"[30m\", \"[1;30m\", \"[37m\",\n-                                             \"[31m\", \"[1;31m\", \"[32m\",\n-                                             \"[1;32m\", \"[33m\", \"[33m\",\n-                                             \"[34m\", \"[1;34m\", \"[35m\",\n-                                             \"[1;35m\", \"[36m\", \"[1;36m\" };\n+static const char * _foreground_colors[] = { \"[37m\",\n+                                             \"[31m\", \"[1;31m\",\n+                                             \"[32m\", \"[1;32m\",\n+                                             \"[33m\", \"[1;33m\",\n+                                             \"[31m\", \"[1;31m\",\n+                                             \"[35m\", \"[1;35m\",\n+                                             \"[36m\", \"[1;36m\" };\n+\n+/**\n+ * Synchronizes access to the underlying logging mechanism.\n+ */\n+static spin_lock _log_lock;\n+\n rust_log::rust_log(rust_srv *srv, rust_dom *dom) :\n-    _srv(srv), _dom(dom), _type_bit_mask(read_type_bit_mask()),\n-            _use_colors(getenv(\"RUST_COLOR_LOG\")), _indent(0) {\n+    _srv(srv),\n+    _dom(dom),\n+    _type_bit_mask(read_type_bit_mask()),\n+    _use_colors(getenv(\"RUST_COLOR_LOG\")),\n+    _indent(0) {\n }\n \n rust_log::~rust_log() {\n \n }\n \n-void rust_log::trace_ln(char *message) {\n-    char buffer[512];\n-    if (_use_colors) {\n-        snprintf(buffer, sizeof(buffer), \"\\x1b%s0x%08\" PRIxPTR \"\\x1b[0m: \",\n-                 _foreground_colors[1 + ((uintptr_t) _dom % 2687 % (LIGHTTEAL\n-                         - 1))], (uintptr_t) _dom);\n-    } else {\n-        snprintf(buffer, sizeof(buffer), \"0x%08\" PRIxPTR \": \",\n-                 (uintptr_t) _dom);\n+const uint16_t\n+hash(uintptr_t ptr) {\n+    // Robert Jenkins' 32 bit integer hash function\n+    ptr = (ptr + 0x7ed55d16) + (ptr << 12);\n+    ptr = (ptr ^ 0xc761c23c) ^ (ptr >> 19);\n+    ptr = (ptr + 0x165667b1) + (ptr << 5);\n+    ptr = (ptr + 0xd3a2646c) ^ (ptr << 9);\n+    ptr = (ptr + 0xfd7046c5) + (ptr << 3);\n+    ptr = (ptr ^ 0xb55a4f09) ^ (ptr >> 16);\n+    return (uint16_t) ptr;\n+}\n+\n+const char *\n+get_color(uintptr_t ptr) {\n+    return _foreground_colors[hash(ptr) % rust_log::LIGHTTEAL];\n+}\n+\n+char *\n+copy_string(char *dst, const char *src, size_t length) {\n+    return strncpy(dst, src, length) + length;\n+}\n+\n+char *\n+append_string(char *buffer, const char *format, ...) {\n+    if (buffer != NULL && format) {\n+        va_list args;\n+        va_start(args, format);\n+        vsprintf(buffer + strlen(buffer), format, args);\n+        va_end(args);\n     }\n+    return buffer;\n+}\n \n+char *\n+append_string(char *buffer, rust_log::ansi_color color,\n+              const char *format, ...) {\n+    if (buffer != NULL && format) {\n+        append_string(buffer, \"\\x1b%s\", _foreground_colors[color]);\n+        va_list args;\n+        va_start(args, format);\n+        vsprintf(buffer + strlen(buffer), format, args);\n+        va_end(args);\n+        append_string(buffer, \"\\x1b[0m\");\n+    }\n+    return buffer;\n+}\n+\n+void\n+rust_log::trace_ln(char *prefix, char *message) {\n+    char buffer[1024] = \"\";\n+    _log_lock.lock();\n+    append_string(buffer, \"%-34s\", prefix);\n     for (uint32_t i = 0; i < _indent; i++) {\n-        strncat(buffer, \"\\t\", sizeof(buffer) - strlen(buffer) - 1);\n+        append_string(buffer, \"    \");\n     }\n-    strncat(buffer, message, sizeof(buffer) - strlen(buffer) - 1);\n+    append_string(buffer, \"%s\", message);\n     _srv->log(buffer);\n+    _log_lock.unlock();\n+}\n+\n+void\n+rust_log::trace_ln(rust_task *task, char *message) {\n+#if defined(__WIN32__)\n+    uint32_t thread_id = 0;\n+#else\n+    uint32_t thread_id = (uint32_t) pthread_self();\n+#endif\n+    char prefix[1024] = \"\";\n+    append_string(prefix, \"0x%08\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n+                  thread_id, (uintptr_t) _dom);\n+    if (task) {\n+        append_string(prefix, \"0x%08\" PRIxPTR \":\", (uintptr_t) task);\n+    }\n+    trace_ln(prefix, message);\n }\n \n /**\n  * Traces a log message if the specified logging type is not filtered.\n  */\n-void rust_log::trace_ln(uint32_t type_bits, char *message) {\n-    trace_ln(get_type_color((rust_log::log_type) type_bits), type_bits,\n-             message);\n+void\n+rust_log::trace_ln(rust_task *task, uint32_t type_bits, char *message) {\n+    trace_ln(task, get_type_color((rust_log::log_type) type_bits),\n+             type_bits, message);\n }\n \n /**\n  * Traces a log message using the specified ANSI color code.\n  */\n-void rust_log::trace_ln(ansi_color color, uint32_t type_bits, char *message) {\n+void\n+rust_log::trace_ln(rust_task *task, ansi_color color,\n+                   uint32_t type_bits, char *message) {\n     if (is_tracing(type_bits)) {\n         if (_use_colors) {\n-            char buffer[512];\n-            snprintf(buffer, sizeof(buffer), \"\\x1b%s%s\\x1b[0m\",\n-                     _foreground_colors[color], message);\n-            trace_ln(buffer);\n+            char buffer[512] = \"\";\n+            append_string(buffer, color, \"%s\", message);\n+            trace_ln(task, buffer);\n         } else {\n-            trace_ln(message);\n+            trace_ln(task, message);\n         }\n     }\n }\n \n-bool rust_log::is_tracing(uint32_t type_bits) {\n+bool\n+rust_log::is_tracing(uint32_t type_bits) {\n     return type_bits & _type_bit_mask;\n }\n \n-void rust_log::indent() {\n+void\n+rust_log::indent() {\n     _indent++;\n }\n \n-void rust_log::outdent() {\n+void\n+rust_log::outdent() {\n     _indent--;\n }\n \n-void rust_log::reset_indent(uint32_t indent) {\n+void\n+rust_log::reset_indent(uint32_t indent) {\n     _indent = indent;\n }"}, {"sha": "06712066b1b37407b73f28a006fc928024e3894b", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,22 +1,18 @@\n-#ifndef RUST_LOG_H_\n-#define RUST_LOG_H_\n+#ifndef RUST_LOG_H\n+#define RUST_LOG_H\n \n class rust_dom;\n+class rust_task;\n+\n+\n \n class rust_log {\n-    rust_srv *_srv;\n-    rust_dom *_dom;\n-    uint32_t _type_bit_mask;\n-    bool _use_colors;\n-    uint32_t _indent;\n-    void trace_ln(char *message);\n+\n public:\n     rust_log(rust_srv *srv, rust_dom *dom);\n     virtual ~rust_log();\n \n     enum ansi_color {\n-        BLACK,\n-        GRAY,\n         WHITE,\n         RED,\n         LIGHTRED,\n@@ -51,10 +47,19 @@ class rust_log {\n     void indent();\n     void outdent();\n     void reset_indent(uint32_t indent);\n-    void trace_ln(uint32_t type_bits, char *message);\n-    void trace_ln(ansi_color color, uint32_t type_bits, char *message);\n+    void trace_ln(char *prefix, char *message);\n+    void trace_ln(rust_task *task, uint32_t type_bits, char *message);\n+    void trace_ln(rust_task *task, ansi_color color, uint32_t type_bits, char *message);\n     bool is_tracing(uint32_t type_bits);\n-    static ansi_color get_type_color(log_type type);\n+\n+private:\n+    rust_srv *_srv;\n+    rust_dom *_dom;\n+    uint32_t _type_bit_mask;\n+    bool _use_labels;\n+    bool _use_colors;\n+    uint32_t _indent;\n+    void trace_ln(rust_task *task, char *message);\n };\n \n-#endif /* RUST_LOG_H_ */\n+#endif /* RUST_LOG_H */"}, {"sha": "8059dd89d42039e82c9e79026dbe029bdb64c893", "filename": "src/rt/rust_proxy.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_proxy.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_proxy.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_proxy.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,31 @@\n+/**\n+ * A proxy object is a wrapper around other Rust objects. One use of the proxy\n+ * object is to mitigate access between tasks in different thread domains.\n+ */\n+\n+#ifndef RUST_PROXY_H\n+#define RUST_PROXY_H\n+\n+template <typename T> struct\n+rust_proxy_delegate : public rc_base<T> {\n+protected:\n+    T *_delegate;\n+public:\n+    rust_proxy_delegate(T * delegate) : _delegate(delegate) {\n+    }\n+    T *delegate() { return _delegate; }\n+};\n+\n+template <typename T> struct\n+rust_proxy : public rust_proxy_delegate<T>,\n+             public dom_owned<rust_proxy<T> > {\n+public:\n+    rust_dom *dom;\n+    rust_proxy(rust_dom *dom, T *delegate) :\n+        rust_proxy_delegate<T> (delegate),\n+        dom(dom) {\n+        delegate->ref();\n+    }\n+};\n+\n+#endif /* RUST_PROXY_H */"}, {"sha": "357edbf187d3f2f118610208ece45b8485d52054", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -53,6 +53,7 @@ align_down(uintptr_t sp)\n \n \n rust_task::rust_task(rust_dom *dom, rust_task *spawner) :\n+    rust_proxy_delegate<rust_task>(this),\n     stk(new_stk(dom, 0)),\n     runtime_sp(0),\n     rust_sp(stk->limit),\n@@ -61,20 +62,24 @@ rust_task::rust_task(rust_dom *dom, rust_task *spawner) :\n     cache(NULL),\n     state(&dom->running_tasks),\n     cond(NULL),\n-    dptr(0),\n     supervisor(spawner),\n     idx(0),\n     waiting_tasks(dom),\n+    rendezvous_ptr(0),\n     alarm(this)\n {\n     dom->logptr(\"new task\", (uintptr_t)this);\n+\n+    if (spawner == NULL) {\n+        ref_count = 0;\n+    }\n }\n \n rust_task::~rust_task()\n {\n     dom->log(rust_log::MEM|rust_log::TASK,\n              \"~rust_task 0x%\" PRIxPTR \", refcnt=%d\",\n-             (uintptr_t)this, refcnt);\n+             (uintptr_t)this, ref_count);\n \n     /*\n       for (uintptr_t fp = get_fp(); fp; fp = get_previous_fp(fp)) {\n@@ -98,8 +103,8 @@ rust_task::~rust_task()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(dom, refcnt == 0 ||\n-      (refcnt == 1 && this == dom->root_task));\n+    I(dom, ref_count == 0 ||\n+      (ref_count == 1 && this == dom->root_task));\n \n     del_stk(dom, stk);\n     if (cache)\n@@ -275,9 +280,9 @@ rust_task::run_after_return(size_t nargs, uintptr_t glue)\n \n     uintptr_t *retpc = ((uintptr_t *) sp) - 1;\n     dom->log(rust_log::TASK|rust_log::MEM,\n-             \"run_after_return: overwriting retpc=0x%\" PRIxPTR\n-             \" @ runtime_sp=0x%\" PRIxPTR\n-             \" with glue=0x%\" PRIxPTR,\n+             \"run_after_return: overwriting retpc=x%\" PRIxPTR\n+             \" @ runtime_sp=x%\" PRIxPTR\n+             \" with glue=x%\" PRIxPTR,\n              *retpc, sp, glue);\n \n     // Move the current return address (which points into rust code)\n@@ -296,18 +301,18 @@ rust_task::run_on_resume(uintptr_t glue)\n     uintptr_t* rsp = (uintptr_t*) rust_sp;\n     rsp += n_callee_saves;\n     dom->log(rust_log::TASK|rust_log::MEM,\n-             \"run_on_resume: overwriting retpc=0x%\" PRIxPTR\n-             \" @ rust_sp=0x%\" PRIxPTR\n-             \" with glue=0x%\" PRIxPTR,\n+             \"run_on_resume: overwriting retpc=x%\" PRIxPTR\n+             \" @ rust_sp=x%\" PRIxPTR\n+             \" with glue=x%\" PRIxPTR,\n              *rsp, rsp, glue);\n     *rsp = glue;\n }\n \n void\n rust_task::yield(size_t nargs)\n {\n-    dom->log(rust_log::TASK,\n-             \"task 0x%\" PRIxPTR \" yielding\", this);\n+    log(rust_log::TASK,\n+        \"task 0x%\" PRIxPTR \" yielding\", this);\n     run_after_return(nargs, dom->root_crate->get_yield_glue());\n }\n \n@@ -322,11 +327,13 @@ rust_task::kill() {\n     // Note the distinction here: kill() is when you're in an upcall\n     // from task A and want to force-fail task B, you do B->kill().\n     // If you want to fail yourself you do self->fail(upcall_nargs).\n-    dom->log(rust_log::TASK, \"killing task 0x%\" PRIxPTR, this);\n+    log(rust_log::TASK, \"killing task 0x%\" PRIxPTR, this);\n     // Unblock the task so it can unwind.\n     unblock();\n+\n     if (this == dom->root_task)\n         dom->fail();\n+\n     run_on_resume(dom->root_crate->get_unwind_glue());\n }\n \n@@ -369,9 +376,12 @@ void\n rust_task::notify_waiting_tasks()\n {\n     while (waiting_tasks.length() > 0) {\n-        rust_task *t = waiting_tasks.pop()->receiver;\n-        if (!t->dead())\n-            t->wakeup(this);\n+        log(rust_log::ALL, \"notify_waiting_tasks: %d\",\n+            waiting_tasks.length());\n+        rust_task *waiting_task = waiting_tasks.pop()->receiver;\n+        if (!waiting_task->dead()) {\n+            waiting_task->wakeup(this);\n+        }\n     }\n }\n \n@@ -532,6 +542,9 @@ void\n rust_task::wakeup(rust_cond *from)\n {\n     transition(&dom->blocked_tasks, &dom->running_tasks);\n+    // TODO: Signaling every time the task is awaken is kind of silly,\n+    // do this a nicer way.\n+    dom->_progress.signal();\n     I(dom, cond == from);\n }\n \n@@ -565,6 +578,18 @@ rust_task::get_crate_cache(rust_crate const *curr_crate)\n     return cache;\n }\n \n+void\n+rust_task::log(uint32_t type_bits, char const *fmt, ...) {\n+    char buf[256];\n+    if (dom->get_log().is_tracing(type_bits)) {\n+        va_list args;\n+        va_start(args, fmt);\n+        vsnprintf(buf, sizeof(buf), fmt, args);\n+        dom->get_log().trace_ln(this, type_bits, buf);\n+        va_end(args);\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "879cb61ae3c4d6e136c07b9682802da797b63c96", "filename": "src/rt/rust_task.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,107 @@\n+/*\n+ *\n+ */\n+\n+#ifndef RUST_TASK_H\n+#define RUST_TASK_H\n+struct\n+rust_task : public rust_proxy_delegate<rust_task>,\n+            public dom_owned<rust_task>,\n+            public rust_cond\n+{\n+    // Fields known to the compiler.\n+    stk_seg *stk;\n+    uintptr_t runtime_sp;      // Runtime sp while task running.\n+    uintptr_t rust_sp;         // Saved sp when not running.\n+    gc_alloc *gc_alloc_chain;  // Linked list of GC allocations.\n+    rust_dom *dom;\n+    rust_crate_cache *cache;\n+\n+    // Fields known only to the runtime.\n+    ptr_vec<rust_task> *state;\n+    rust_cond *cond;\n+    rust_task *supervisor;     // Parent-link for failure propagation.\n+    size_t idx;\n+    size_t gc_alloc_thresh;\n+    size_t gc_alloc_accum;\n+\n+    // Wait queue for tasks waiting for this task.\n+    rust_wait_queue waiting_tasks;\n+\n+    // Rendezvous pointer for receiving data when blocked on a port. If we're\n+    // trying to read data and no data is available on any incoming channel,\n+    // we block on the port, and yield control to the scheduler. Since, we\n+    // were not able to read anJything, we remember the location where the\n+    // result should go in the rendezvous_ptr, and let the sender write to\n+    // that location before waking us up.\n+    uintptr_t* rendezvous_ptr;\n+\n+    rust_alarm alarm;\n+\n+    rust_task(rust_dom *dom,\n+              rust_task *spawner);\n+    ~rust_task();\n+\n+    void start(uintptr_t exit_task_glue,\n+               uintptr_t spawnee_fn,\n+               uintptr_t args,\n+               size_t callsz);\n+    void grow(size_t n_frame_bytes);\n+    bool running();\n+    bool blocked();\n+    bool blocked_on(rust_cond *cond);\n+    bool dead();\n+\n+    void link_gc(gc_alloc *gcm);\n+    void unlink_gc(gc_alloc *gcm);\n+    void *malloc(size_t sz, type_desc *td=0);\n+    void *realloc(void *data, size_t sz, bool gc_mem=false);\n+    void free(void *p, bool gc_mem=false);\n+\n+    const char *state_str();\n+    void transition(ptr_vec<rust_task> *svec, ptr_vec<rust_task> *dvec);\n+\n+    void block(rust_cond *on);\n+    void wakeup(rust_cond *from);\n+    void die();\n+    void unblock();\n+\n+    void check_active() { I(dom, dom->curr_task == this); }\n+    void check_suspended() { I(dom, dom->curr_task != this); }\n+\n+    void log(uint32_t type_bits, char const *fmt, ...);\n+\n+    // Swap in some glue code to run when we have returned to the\n+    // task's context (assuming we're the active task).\n+    void run_after_return(size_t nargs, uintptr_t glue);\n+\n+    // Swap in some glue code to run when we're next activated\n+    // (assuming we're the suspended task).\n+    void run_on_resume(uintptr_t glue);\n+\n+    // Save callee-saved registers and return to the main loop.\n+    void yield(size_t nargs);\n+\n+    // Fail this task (assuming caller-on-stack is different task).\n+    void kill();\n+\n+    // Fail self, assuming caller-on-stack is this task.\n+    void fail(size_t nargs);\n+\n+    // Run the gc glue on the task stack.\n+    void gc(size_t nargs);\n+\n+    // Disconnect from our supervisor.\n+    void unsupervise();\n+\n+    // Notify tasks waiting for us that we are about to die.\n+    void notify_waiting_tasks();\n+\n+    uintptr_t get_fp();\n+    uintptr_t get_previous_fp(uintptr_t fp);\n+    frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n+    rust_crate_cache * get_crate_cache(rust_crate const *curr_crate);\n+};\n+\n+\n+#endif /* RUST_TASK_H */"}, {"sha": "269942f5f800d971ed9d1374c8d4a4edfecc095b", "filename": "src/rt/rust_timer.cpp", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,4 +1,3 @@\n-\n #include \"rust_internal.h\"\n #include \"valgrind.h\"\n \n@@ -27,12 +26,11 @@ static void *\n #else\n #error \"Platform not supported\"\n #endif\n-timer_loop(void *ptr)\n-{\n+timer_loop(void *ptr) {\n     // We were handed the rust_timer that owns us.\n     rust_timer *timer = (rust_timer *)ptr;\n-    rust_dom &dom = timer->dom;\n-    dom.log(rust_log::TIMER, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n+    rust_dom *dom = timer->dom;\n+    dom->log(rust_log::TIMER, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n     size_t ms = TIME_SLICE_IN_MS;\n     if (!RUNNING_ON_VALGRIND)\n         ms = 1;\n@@ -43,12 +41,10 @@ timer_loop(void *ptr)\n #else\n         usleep(ms * 1000);\n #endif\n-        dom.log(rust_log::TIMER,\n-                \"timer 0x%\" PRIxPTR\n-                \" interrupting domain 0x%\" PRIxPTR,\n-                (uintptr_t)timer,\n-                (uintptr_t)&dom);\n-        dom.interrupt_flag = 1;\n+        dom->log(rust_log::TIMER, \"timer 0x%\" PRIxPTR\n+        \" interrupting domain 0x%\" PRIxPTR, (uintptr_t) timer,\n+                 (uintptr_t) dom);\n+        dom->interrupt_flag = 1;\n     }\n #if defined(__WIN32__)\n     ExitThread(0);\n@@ -58,10 +54,9 @@ timer_loop(void *ptr)\n     return 0;\n }\n \n-\n-rust_timer::rust_timer(rust_dom &dom) : dom(dom), exit_flag(0)\n-{\n-    dom.log(rust_log::TIMER, \"creating timer for domain 0x%\" PRIxPTR, &dom);\n+rust_timer::rust_timer(rust_dom *dom) :\n+    dom(dom), exit_flag(0) {\n+    dom->log(rust_log::TIMER, \"creating timer for domain 0x%\" PRIxPTR, dom);\n #if defined(__WIN32__)\n     thread = CreateThread(NULL, 0, timer_loop, this, 0, NULL);\n     dom.win32_require(\"CreateThread\", thread != NULL);\n@@ -76,13 +71,11 @@ rust_timer::rust_timer(rust_dom &dom) : dom(dom), exit_flag(0)\n #endif\n }\n \n-rust_timer::~rust_timer()\n-{\n+rust_timer::~rust_timer() {\n     exit_flag = 1;\n #if defined(__WIN32__)\n-    dom.win32_require(\"WaitForSingleObject\",\n-                      WaitForSingleObject(thread, INFINITE)\n-                      == WAIT_OBJECT_0);\n+    dom->win32_require(\"WaitForSingleObject\",\n+            WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0);\n #else\n     pthread_join(thread, NULL);\n #endif"}, {"sha": "1aaf89fba978469afa64e5fbf52e4e7c8213c091", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 270, "deletions": 330, "changes": 600, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,127 +1,120 @@\n-\n #include \"rust_internal.h\"\n \n-\n // Upcalls.\n \n #ifdef __GNUC__\n #define LOG_UPCALL_ENTRY(task)                              \\\n     (task)->dom->get_log().reset_indent(0);                 \\\n-    (task)->dom->log(rust_log::UPCALL,                      \\\n-                     \"upcall task: 0x%\" PRIxPTR             \\\n-                     \" retpc: 0x%\" PRIxPTR,                 \\\n-                     (task), __builtin_return_address(0));  \\\n+    (task)->log(rust_log::UPCALL,                           \\\n+                \"> UPCALL %s - task: 0x%\" PRIxPTR           \\\n+                \" retpc: x%\" PRIxPTR,                      \\\n+                __FUNCTION__,                               \\\n+                (task), __builtin_return_address(0));       \\\n     (task)->dom->get_log().indent();\n #else\n #define LOG_UPCALL_ENTRY(task)                              \\\n     (task)->dom->get_log().reset_indent(0);                 \\\n-    (task)->dom->log(rust_log::UPCALL,                      \\\n-                     \"upcall task: 0x%\" PRIxPTR (task));    \\\n+    (task)->log(rust_log::UPCALL,                           \\\n+                \"> UPCALL task: x%\" PRIxPTR (task));       \\\n     (task)->dom->get_log().indent();\n #endif\n \n extern \"C\" CDECL char const *str_buf(rust_task *task, rust_str *s);\n \n-extern \"C\" void\n-upcall_grow_task(rust_task *task, size_t n_frame_bytes)\n-{\n+inline bool\n+requires_message_passing(rust_task *sender, rust_task *receiver) {\n+    return sender->dom != receiver->dom;\n+}\n+\n+extern \"C\" void upcall_grow_task(rust_task *task, size_t n_frame_bytes) {\n     LOG_UPCALL_ENTRY(task);\n     task->grow(n_frame_bytes);\n }\n \n-extern \"C\" CDECL void\n-upcall_log_int(rust_task *task, int32_t i)\n-{\n+extern \"C\" CDECL void upcall_log_int(rust_task *task, int32_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::ULOG,\n-                   \"upcall log_int(0x%\" PRIx32 \" = %\" PRId32 \" = '%c')\",\n-                   i, i, (char)i);\n+    task->log(rust_log::UPCALL | rust_log::ULOG,\n+              \"upcall log_int(0x%\" PRIx32 \" = %\" PRId32 \" = '%c')\", i, i,\n+              (char) i);\n }\n \n-extern \"C\" CDECL void\n-upcall_log_str(rust_task *task, rust_str *str)\n-{\n+extern \"C\" CDECL void upcall_log_str(rust_task *task, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n     const char *c = str_buf(task, str);\n-    task->dom->log(rust_log::UPCALL|rust_log::ULOG,\n-                   \"upcall log_str(\\\"%s\\\")\",\n-                   c);\n+    task->log(rust_log::UPCALL | rust_log::ULOG, \"upcall log_str(\\\"%s\\\")\", c);\n }\n \n-extern \"C\" CDECL void\n-upcall_trace_word(rust_task *task, uintptr_t i)\n-{\n+extern \"C\" CDECL void upcall_trace_word(rust_task *task, uintptr_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::TRACE,\n-                   \"trace: 0x%\" PRIxPTR \"\",\n-                   i, i, (char)i);\n+    task->log(rust_log::UPCALL | rust_log::TRACE, \"trace: 0x%\" PRIxPTR \"\", i,\n+              i, (char) i);\n }\n \n-extern \"C\" CDECL void\n-upcall_trace_str(rust_task *task, char const *c)\n-{\n+extern \"C\" CDECL void upcall_trace_str(rust_task *task, char const *c) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::TRACE,\n-                   \"trace: %s\",\n-                   c);\n+    task->log(rust_log::UPCALL | rust_log::TRACE, \"trace: %s\", c);\n }\n \n extern \"C\" CDECL rust_port*\n-upcall_new_port(rust_task *task, size_t unit_sz)\n-{\n+upcall_new_port(rust_task *task, size_t unit_sz) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::COMM,\n-             \"upcall_new_port(task=0x%\" PRIxPTR \", unit_sz=%d)\",\n-             (uintptr_t)task, unit_sz);\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+              \"upcall_new_port(task=0x%\" PRIxPTR \", unit_sz=%d)\",\n+              (uintptr_t) task, unit_sz);\n     return new (dom) rust_port(task, unit_sz);\n }\n \n-extern \"C\" CDECL void\n-upcall_del_port(rust_task *task, rust_port *port)\n-{\n+extern \"C\" CDECL void upcall_del_port(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::COMM,\n-                   \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t)port);\n-    I(task->dom, !port->refcnt);\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+              \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n+    I(task->dom, !port->ref_count);\n     delete port;\n }\n \n+/**\n+ * Creates a new channel, pointed to a specified port.\n+ */\n extern \"C\" CDECL rust_chan*\n-upcall_new_chan(rust_task *task, rust_port *port)\n-{\n+upcall_new_chan(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::COMM,\n-             \"upcall_new_chan(task=0x%\" PRIxPTR \", port=0x%\" PRIxPTR \")\",\n-             (uintptr_t)task, port);\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+              \"upcall_new_chan(task=0x%\" PRIxPTR \", port=0x%\" PRIxPTR \")\",\n+              (uintptr_t) task, port);\n     I(dom, port);\n     return new (dom) rust_chan(task, port);\n }\n \n-extern \"C\" CDECL void\n-upcall_del_chan(rust_task *task, rust_chan *chan)\n-{\n+/**\n+ * Called whenever the channel's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::COMM,\n-             \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t)chan);\n-    I(dom, !chan->refcnt);\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+              \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n+    I(dom, !chan->ref_count);\n     delete chan;\n }\n \n+/**\n+ * Clones a channel and stores it in the spawnee's domain. Each spawned task\n+ * has it's own copy of the channel.\n+ */\n extern \"C\" CDECL rust_chan *\n-upcall_clone_chan(rust_task *task, rust_task *owner, rust_chan *chan)\n-{\n+upcall_clone_chan(rust_task *task,\n+                  rust_proxy_delegate<rust_task> *spawnee_proxy,\n+                  rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::COMM,\n-             \"upcall clone_chan(owner 0x%\" PRIxPTR \", chan 0x%\" PRIxPTR \")\",\n-             (uintptr_t)owner, (uintptr_t)chan);\n-    return new (owner->dom) rust_chan(owner, chan->port);\n+    rust_task *spawnee = spawnee_proxy->delegate();\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n+              \"spawnee: 0x%\" PRIxPTR \", chan: 0x%\" PRIxPTR,\n+              (uintptr_t) spawnee, (uintptr_t) chan);\n+    return new (spawnee->dom) rust_chan(spawnee, chan->port);\n }\n \n-\n /*\n  * Buffering protocol:\n  *\n@@ -143,181 +136,156 @@ upcall_clone_chan(rust_task *task, rust_task *owner, rust_chan *chan)\n  *         - Set blocked writer to running\n  *\n  */\n+//\n+//static int\n+//attempt_transmission(rust_dom *dom, rust_chan *src, rust_task *dst) {\n+//    I(dom, src);\n+//    I(dom, dst);\n+//\n+//    rust_port *port = src->port;\n+//    if (!port) {\n+//        dom->log(rust_log::COMM, \"src died, transmission incomplete\");\n+//        return 0;\n+//    }\n+//\n+//    circular_buffer *buf = &src->buffer;\n+//    if (buf->is_empty()) {\n+//        dom->log(rust_log::COMM, \"buffer empty, transmission incomplete\");\n+//        return 0;\n+//    }\n+//\n+//    if (!dst->blocked_on(port)) {\n+//        dom->log(rust_log::COMM,\n+//                 \"dst in non-reading state, transmission incomplete\");\n+//        return 0;\n+//    }\n+//\n+//    uintptr_t *dptr = dst->dptr;\n+//    dom->log(rust_log::COMM, \"receiving %d bytes into dst_task=0x%\" PRIxPTR\n+//    \", dptr=0x%\" PRIxPTR, port->unit_sz, dst, dptr);\n+//    buf->dequeue(dptr);\n+//\n+//    // Wake up the sender if its waiting for the send operation.\n+//    rust_task *sender = src->task;\n+//    rust_token *token = &src->token;\n+//    if (sender->blocked_on(token))\n+//        sender->wakeup(token);\n+//\n+//    // Wake up the receiver, there is new data.\n+//    dst->wakeup(port);\n+//\n+//    dom->log(rust_log::COMM, \"transmission complete\");\n+//    return 1;\n+//}\n \n-static int\n-attempt_transmission(rust_dom *dom,\n-                     rust_chan *src,\n-                     rust_task *dst)\n-{\n-    I(dom, src);\n-    I(dom, dst);\n-\n-    rust_port *port = src->port;\n-    if (!port) {\n-        dom->log(rust_log::COMM,\n-                 \"src died, transmission incomplete\");\n-        return 0;\n-    }\n-\n-    circ_buf *buf = &src->buffer;\n-    if (buf->unread == 0) {\n-        dom->log(rust_log::COMM,\n-                 \"buffer empty, transmission incomplete\");\n-        return 0;\n-    }\n-\n-    if (!dst->blocked_on(port)) {\n-        dom->log(rust_log::COMM,\n-                 \"dst in non-reading state, transmission incomplete\");\n-        return 0;\n-    }\n-\n-    uintptr_t *dptr = dst->dptr;\n-    dom->log(rust_log::COMM,\n-             \"receiving %d bytes into dst_task=0x%\" PRIxPTR\n-             \", dptr=0x%\" PRIxPTR,\n-             port->unit_sz, dst, dptr);\n-    buf->shift(dptr);\n-\n-    // Wake up the sender if its waiting for the send operation.\n-    rust_task *sender = src->task;\n-    rust_token *token = &src->token;\n-    if (sender->blocked_on(token))\n-        sender->wakeup(token);\n-\n-    // Wake up the receiver, there is new data.\n-    dst->wakeup(port);\n-\n-    dom->log(rust_log::COMM, \"transmission complete\");\n-    return 1;\n-}\n-\n-extern \"C\" CDECL void\n-upcall_yield(rust_task *task)\n-{\n+extern \"C\" CDECL void upcall_yield(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::COMM, \"upcall yield()\");\n+    task->log(rust_log::UPCALL | rust_log::COMM, \"upcall yield()\");\n     task->yield(1);\n }\n \n-extern \"C\" CDECL void\n-upcall_join(rust_task *task, rust_task *other)\n-{\n+extern \"C\" CDECL void upcall_join(rust_task *task,\n+                                  rust_proxy_delegate<rust_task> *proxy) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::COMM,\n-             \"upcall join(other=0x%\" PRIxPTR \")\",\n-             (uintptr_t)other);\n+    task->log(rust_log::UPCALL | rust_log::COMM,\n+                  \"join proxy 0x%\" PRIxPTR \" -> task = 0x%\" PRIxPTR,\n+                  proxy, proxy->delegate());\n \n-    // If the other task is already dying, we dont have to wait for it.\n+    rust_task *other = proxy->delegate();\n+\n+    // If the other task is already dying, we don't have to wait for it.\n     if (!other->dead()) {\n         other->waiting_tasks.push(&task->alarm);\n         task->block(other);\n         task->yield(2);\n     }\n }\n \n+/**\n+ * Sends an chunk of data along the specified channel.\n+ *\n+ * sptr: pointer to a chunk of data to send\n+ */\n extern \"C\" CDECL void\n-upcall_send(rust_task *task, rust_chan *chan, void *sptr)\n-{\n+upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::COMM,\n-             \"upcall send(chan=0x%\" PRIxPTR \", sptr=0x%\" PRIxPTR \")\",\n-             (uintptr_t)chan,\n-             (uintptr_t)sptr);\n+    task->log(rust_log::UPCALL | rust_log::COMM,\n+              \"chan: 0x%\" PRIxPTR \", sptr: 0x%\" PRIxPTR \", size: %d\",\n+              (uintptr_t) chan, (uintptr_t) sptr, chan->port->unit_sz);\n \n-    I(dom, chan);\n-    I(dom, sptr);\n-\n-    rust_port *port = chan->port;\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"send to port\", (uintptr_t)port);\n-    I(dom, port);\n-\n-    rust_token *token = &chan->token;\n-    dom->log(rust_log::MEM|rust_log::COMM,\n-             \"sending via token 0x%\" PRIxPTR,\n-             (uintptr_t)token);\n-\n-    if (port->task) {\n-        chan->buffer.push(sptr);\n-        task->block(token);\n-        attempt_transmission(dom, chan, port->task);\n-        if (chan->buffer.unread && !token->pending())\n-            token->submit();\n-    } else {\n-        dom->log(rust_log::COMM|rust_log::ERR,\n-                 \"port has no task (possibly throw?)\");\n-    }\n-\n-    if (!task->running())\n-        task->yield(3);\n+    chan->buffer.enqueue(sptr);\n+    chan->transmit();\n+    task->log(rust_log::COMM, \"=== WROTE DATA ===>\");\n }\n \n extern \"C\" CDECL void\n-upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port)\n-{\n+upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::COMM,\n-             \"upcall recv(dptr=0x%\" PRIxPTR \", port=0x%\" PRIxPTR \")\",\n-             (uintptr_t)dptr,\n-             (uintptr_t)port);\n+    task->log(rust_log::UPCALL | rust_log::COMM,\n+              \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n+              \", size: 0x%\" PRIxPTR \", chan_no: %d\",\n+              (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n+              port->chans.length());\n+\n+    for (uint32_t i = 0; i < port->chans.length(); i++) {\n+        rust_chan *chan = port->chans[i];\n+        if (chan->buffer.is_empty() == false) {\n+            chan->buffer.dequeue(dptr);\n+            task->log(rust_log::COMM, \"<=== READ DATA ===\");\n+            return;\n+        }\n+    }\n \n-    I(dom, port);\n-    I(dom, port->task);\n-    I(dom, task);\n-    I(dom, port->task == task);\n+    // No data was buffered on any incoming channel, so block this task\n+    // on the port. Remember the rendezvous location so that any sender\n+    // task can write to it before waking up this task.\n \n+    task->rendezvous_ptr = dptr;\n     task->block(port);\n-\n-    if (port->writers.length() > 0) {\n-        I(dom, task->dom);\n-        size_t i = rand(&dom->rctx);\n-        i %= port->writers.length();\n-        rust_token *token = port->writers[i];\n-        rust_chan *chan = token->chan;\n-        if (attempt_transmission(dom, chan, task))\n-            token->withdraw();\n-    } else {\n-        dom->log(rust_log::COMM,\n-                 \"no writers sending to port\", (uintptr_t)port);\n-    }\n-\n-    if (!task->running()) {\n-        task->dptr = dptr;\n-        task->yield(3);\n-    }\n+    task->yield(3);\n }\n \n-extern \"C\" CDECL void\n-upcall_fail(rust_task *task, char const *expr, char const *file, size_t line)\n-{\n+extern \"C\" CDECL void upcall_fail(rust_task *task, char const *expr,\n+    char const *file, size_t line) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::ERR,\n-                   \"upcall fail '%s', %s:%\" PRIdPTR,\n-                   expr, file, line);\n+    task->log(rust_log::UPCALL | rust_log::ERR,\n+              \"upcall fail '%s', %s:%\" PRIdPTR, expr, file, line);\n     task->fail(4);\n }\n \n+/**\n+ * Called whenever a task's ref count drops to zero.\n+ */\n extern \"C\" CDECL void\n-upcall_kill(rust_task *task, rust_task *target)\n-{\n+upcall_kill(rust_task *task, rust_proxy_delegate<rust_task> *target_proxy) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(rust_log::UPCALL|rust_log::TASK,\n-                   \"upcall kill target=0x%\" PRIxPTR, target);\n-    target->kill();\n+    rust_task *target_task = target_proxy->delegate();\n+    if (target_proxy != target_task) {\n+        task->dom->free(target_proxy);\n+    }\n+    task->log(rust_log::UPCALL | rust_log::TASK,\n+              \"kill task 0x%\" PRIxPTR \", ref count %d\",\n+              target_task,\n+              target_task->ref_count);\n+\n+    if (requires_message_passing(task, target_task)) {\n+        rust_dom *target_domain = target_task->dom;\n+        target_domain->send_message(\n+                new (target_domain)\n+                kill_task_message(target_domain, target_task));\n+    } else {\n+        target_task->kill();\n+    }\n }\n \n+/**\n+ * Called by the exit glue when the task terminates.\n+ */\n extern \"C\" CDECL void\n-upcall_exit(rust_task *task)\n-{\n+upcall_exit(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n-\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::TASK, \"upcall exit\");\n+    task->log(rust_log::UPCALL | rust_log::TASK,\n+              \"task ref_count: %d\", task->ref_count);\n     task->die();\n     task->notify_waiting_tasks();\n     task->yield(1);\n@@ -341,11 +309,13 @@ upcall_malloc(rust_task *task, size_t nbytes, type_desc *td)\n     return (uintptr_t) p;\n }\n \n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n extern \"C\" CDECL void\n upcall_free(rust_task *task, void* ptr, uintptr_t is_gc)\n {\n     LOG_UPCALL_ENTRY(task);\n-\n     rust_dom *dom = task->dom;\n     dom->log(rust_log::UPCALL|rust_log::MEM,\n              \"upcall free(0x%\" PRIxPTR \")\",\n@@ -371,22 +341,19 @@ upcall_mark(rust_task *task, void* ptr)\n }\n \n extern \"C\" CDECL rust_str *\n-upcall_new_str(rust_task *task, char const *s, size_t fill)\n-{\n+upcall_new_str(rust_task *task, char const *s, size_t fill) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall new_str('%s', %\" PRIdPTR \")\", s, fill);\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n     void *mem = dom->malloc(alloc);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n     }\n-    rust_str *st = new (mem) rust_str(dom, alloc, fill, (uint8_t const *)s);\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n-             s, fill, st);\n+    rust_str *st = new (mem) rust_str(dom, alloc, fill, (uint8_t const *) s);\n+    task->log(rust_log::UPCALL | rust_log::MEM,\n+              \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n+              s, fill, st);\n     return st;\n }\n \n@@ -405,34 +372,32 @@ upcall_new_vec(rust_task *task, size_t fill, type_desc *td)\n         return NULL;\n     }\n     rust_vec *v = new (mem) rust_vec(dom, alloc, 0, NULL);\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR,\n-             fill, v);\n+    task->log(rust_log::UPCALL | rust_log::MEM,\n+              \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR, fill, v);\n     return v;\n }\n \n-\n extern \"C\" CDECL rust_str *\n upcall_vec_grow(rust_task *task, rust_vec *v, size_t n_bytes, uintptr_t is_gc)\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM,\n+    task->log(rust_log::UPCALL|rust_log::MEM,\n              \"upcall vec_grow(%\" PRIxPTR \", %\" PRIdPTR\n              \"), alloc=%\" PRIdPTR \", fill=%\" PRIdPTR,\n              v, n_bytes, v->alloc, v->fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + v->fill + n_bytes);\n-    if (v->refcnt == 1) {\n+    if (v->ref_count == 1) {\n \n         // Fastest path: already large enough.\n         if (v->alloc >= alloc) {\n-            dom->log(rust_log::UPCALL|rust_log::MEM, \"no-growth path\");\n+            task->log(rust_log::UPCALL | rust_log::MEM, \"no-growth path\");\n             return v;\n         }\n \n         // Second-fastest path: can at least realloc.\n-        dom->log(rust_log::UPCALL|rust_log::MEM, \"realloc path\");\n-        v = (rust_vec*)dom->realloc(v, alloc);\n+        task->log(rust_log::UPCALL | rust_log::MEM, \"realloc path\");\n+        v = (rust_vec*) dom->realloc(v, alloc);\n         if (!v) {\n             task->fail(4);\n             return NULL;\n@@ -441,7 +406,7 @@ upcall_vec_grow(rust_task *task, rust_vec *v, size_t n_bytes, uintptr_t is_gc)\n \n     } else {\n         // Slowest path: make a new vec.\n-        dom->log(rust_log::UPCALL|rust_log::MEM, \"new vec path\");\n+        task->log(rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n         void *mem = dom->malloc(alloc);\n         if (!mem) {\n             task->fail(4);\n@@ -454,121 +419,100 @@ upcall_vec_grow(rust_task *task, rust_vec *v, size_t n_bytes, uintptr_t is_gc)\n     return v;\n }\n \n-\n static rust_crate_cache::c_sym *\n-fetch_c_sym(rust_task *task,\n-            rust_crate const *curr_crate,\n-            size_t lib_num,\n-            size_t c_sym_num,\n-            char const *library,\n-            char const *symbol)\n-{\n+fetch_c_sym(rust_task *task, rust_crate const *curr_crate, size_t lib_num,\n+    size_t c_sym_num, char const *library, char const *symbol) {\n     rust_crate_cache *cache = task->get_crate_cache(curr_crate);\n     rust_crate_cache::lib *l = cache->get_lib(lib_num, library);\n     return cache->get_c_sym(c_sym_num, l, symbol);\n }\n \n-extern \"C\" CDECL uintptr_t\n-upcall_require_rust_sym(rust_task *task,\n-                        rust_crate const *curr_crate,\n-                        size_t lib_num,      // # of lib\n-                        size_t c_sym_num,    // # of C sym \"rust_crate\" in lib\n-                        size_t rust_sym_num, // # of rust sym\n-                        char const *library,\n-                        char const **path)\n-{\n+extern \"C\" CDECL uintptr_t upcall_require_rust_sym(rust_task *task,\n+    rust_crate const *curr_crate, size_t lib_num, // # of lib\n+    size_t c_sym_num, // # of C sym \"rust_crate\" in lib\n+    size_t rust_sym_num, // # of rust sym\n+    char const *library, char const **path) {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n \n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"upcall require rust sym: lib #%\" PRIdPTR\n-             \" = %s, c_sym #%\" PRIdPTR\n-             \", rust_sym #%\" PRIdPTR\n-             \", curr_crate = 0x%\" PRIxPTR,\n-             lib_num, library, c_sym_num, rust_sym_num,\n-             curr_crate);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"upcall require rust sym: lib #%\" PRIdPTR\n+              \" = %s, c_sym #%\" PRIdPTR\n+              \", rust_sym #%\" PRIdPTR\n+              \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n+              rust_sym_num, curr_crate);\n     for (char const **c = crate_rel(curr_crate, path); *c; ++c) {\n-        dom->log(rust_log::UPCALL, \" + %s\", crate_rel(curr_crate, *c));\n+        task->log(rust_log::UPCALL, \" + %s\", crate_rel(curr_crate, *c));\n     }\n \n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"require C symbol 'rust_crate' from lib #%\" PRIdPTR,lib_num);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"require C symbol 'rust_crate' from lib #%\" PRIdPTR, lib_num);\n     rust_crate_cache::c_sym *c =\n-        fetch_c_sym(task, curr_crate, lib_num, c_sym_num,\n-                    library, \"rust_crate\");\n+            fetch_c_sym(task, curr_crate, lib_num, c_sym_num, library,\n+                        \"rust_crate\");\n \n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"require rust symbol inside crate\");\n-    rust_crate_cache::rust_sym *s =\n-        task->cache->get_rust_sym(rust_sym_num, dom, curr_crate, c, path);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"require rust symbol inside crate\");\n+    rust_crate_cache::rust_sym *s = task->cache->get_rust_sym(rust_sym_num,\n+                                                              dom,\n+                                                              curr_crate, c,\n+                                                              path);\n \n     uintptr_t addr = s->get_val();\n     if (addr) {\n-        dom->log(rust_log::UPCALL|rust_log::CACHE,\n-                 \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n+        task->log(rust_log::UPCALL | rust_log::CACHE,\n+                  \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        dom->log(rust_log::UPCALL|rust_log::CACHE,\n-                 \"failed to resolve symbol\");\n+        task->log(rust_log::UPCALL | rust_log::CACHE,\n+                  \"failed to resolve symbol\");\n         task->fail(7);\n     }\n     return addr;\n }\n \n-extern \"C\" CDECL uintptr_t\n-upcall_require_c_sym(rust_task *task,\n-                     rust_crate const *curr_crate,\n-                     size_t lib_num,      // # of lib\n-                     size_t c_sym_num,    // # of C sym\n-                     char const *library,\n-                     char const *symbol)\n-{\n+extern \"C\" CDECL uintptr_t upcall_require_c_sym(rust_task *task,\n+    rust_crate const *curr_crate, size_t lib_num, // # of lib\n+    size_t c_sym_num, // # of C sym\n+    char const *library, char const *symbol) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n \n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"upcall require c sym: lib #%\" PRIdPTR\n-             \" = %s, c_sym #%\" PRIdPTR\n-             \" = %s\"\n-             \", curr_crate = 0x%\" PRIxPTR,\n-             lib_num, library, c_sym_num, symbol, curr_crate);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"upcall require c sym: lib #%\" PRIdPTR\n+              \" = %s, c_sym #%\" PRIdPTR\n+              \" = %s\"\n+              \", curr_crate = 0x%\" PRIxPTR, lib_num, library, c_sym_num,\n+              symbol, curr_crate);\n \n-    rust_crate_cache::c_sym *c =\n-        fetch_c_sym(task, curr_crate, lib_num, c_sym_num, library, symbol);\n+    rust_crate_cache::c_sym *c = fetch_c_sym(task, curr_crate, lib_num,\n+                                             c_sym_num, library, symbol);\n \n     uintptr_t addr = c->get_val();\n     if (addr) {\n-        dom->log(rust_log::UPCALL|rust_log::CACHE,\n-                 \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n+        task->log(rust_log::UPCALL | rust_log::CACHE,\n+                  \"found-or-cached addr: 0x%\" PRIxPTR, addr);\n     } else {\n-        dom->log(rust_log::UPCALL|rust_log::CACHE,\n-                 \"failed to resolve symbol\");\n+        task->log(rust_log::UPCALL | rust_log::CACHE,\n+                  \"failed to resolve symbol\");\n         task->fail(6);\n     }\n     return addr;\n }\n \n extern \"C\" CDECL type_desc *\n-upcall_get_type_desc(rust_task *task,\n-                     rust_crate const *curr_crate,\n-                     size_t size,\n-                     size_t align,\n-                     size_t n_descs,\n-                     type_desc const **descs)\n-{\n+upcall_get_type_desc(rust_task *task, rust_crate const *curr_crate,\n+    size_t size, size_t align, size_t n_descs, type_desc const **descs) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"upcall get_type_desc with size=%\" PRIdPTR\n-             \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\",\n-             size, align, n_descs);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"upcall get_type_desc with size=%\" PRIdPTR\n+              \", align=%\" PRIdPTR \", %\" PRIdPTR \" descs\", size, align,\n+              n_descs);\n     rust_crate_cache *cache = task->get_crate_cache(curr_crate);\n     type_desc *td = cache->get_type_desc(size, align, n_descs, descs);\n-    dom->log(rust_log::UPCALL|rust_log::CACHE,\n-             \"returning tydesc 0x%\" PRIxPTR, td);\n+    task->log(rust_log::UPCALL | rust_log::CACHE,\n+              \"returning tydesc 0x%\" PRIxPTR, td);\n     return td;\n }\n \n-\n #if defined(__WIN32__)\n static DWORD WINAPI rust_thread_start(void *ptr)\n #elif defined(__GNUC__)\n@@ -578,10 +522,10 @@ static void *rust_thread_start(void *ptr)\n #endif\n {\n     // We were handed the domain we are supposed to run.\n-    rust_dom *dom = (rust_dom *)ptr;\n+    rust_dom *dom = (rust_dom *) ptr;\n \n     // Start a new rust main loop for this thread.\n-    rust_main_loop(dom);\n+    dom->start_main_loop();\n \n     rust_srv *srv = dom->srv;\n     delete dom;\n@@ -591,81 +535,77 @@ static void *rust_thread_start(void *ptr)\n }\n \n extern \"C\" CDECL rust_task *\n-upcall_new_task(rust_task *spawner)\n-{\n+upcall_new_task(rust_task *spawner) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n     rust_task *task = new (dom) rust_task(dom, spawner);\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::TASK,\n+    dom->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n              \"upcall new_task(spawner 0x%\" PRIxPTR \") = 0x%\" PRIxPTR,\n              spawner, task);\n     return task;\n }\n \n extern \"C\" CDECL rust_task *\n-upcall_start_task(rust_task *spawner,\n-                  rust_task *task,\n-                  uintptr_t exit_task_glue,\n-                  uintptr_t spawnee_fn,\n-                  size_t callsz)\n-{\n+upcall_start_task(rust_task *spawner, rust_task *task,\n+    uintptr_t exit_task_glue, uintptr_t spawnee_fn, size_t callsz) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::TASK,\n+    dom->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n              \"upcall start_task(task 0x%\" PRIxPTR\n              \" exit_task_glue 0x%\" PRIxPTR\n              \", spawnee 0x%\" PRIxPTR\n-             \", callsz %\" PRIdPTR \")\",\n-             task, exit_task_glue, spawnee_fn, callsz);\n+             \", callsz %\" PRIdPTR \")\", task, exit_task_glue, spawnee_fn,\n+             callsz);\n     task->start(exit_task_glue, spawnee_fn, spawner->rust_sp, callsz);\n     return task;\n }\n \n-extern \"C\" CDECL rust_task *\n-upcall_new_thread(rust_task *task)\n-{\n+extern \"C\" CDECL rust_proxy_delegate<rust_task> *\n+upcall_new_thread(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n \n     rust_dom *old_dom = task->dom;\n     rust_dom *new_dom = new rust_dom(old_dom->srv->clone(),\n                                      old_dom->root_crate);\n-    new_dom->log(rust_log::UPCALL|rust_log::MEM,\n-                 \"upcall new_thread() = 0x%\" PRIxPTR,\n-                 new_dom->root_task);\n-    return new_dom->root_task;\n+\n+    task->log(rust_log::UPCALL | rust_log::MEM,\n+              \"upcall new_thread() = dom 0x%\" PRIxPTR \" task 0x%\" PRIxPTR,\n+              new_dom, new_dom->root_task);\n+    rust_proxy<rust_task> *proxy =\n+            new (old_dom) rust_proxy<rust_task>(old_dom, new_dom->root_task);\n+    task->log(rust_log::UPCALL | rust_log::MEM,\n+              \"new proxy = 0x%\" PRIxPTR \" -> task = 0x%\" PRIxPTR,\n+              proxy, proxy->delegate());\n+    return proxy;\n }\n \n-extern \"C\" CDECL rust_task *\n+extern \"C\" CDECL rust_proxy_delegate<rust_task> *\n upcall_start_thread(rust_task *spawner,\n-                    rust_task *root_task,\n-                    uintptr_t exit_task_glue,\n-                    uintptr_t spawnee_fn,\n-                    size_t callsz)\n-{\n+                    rust_proxy_delegate<rust_task> *root_task_proxy,\n+    uintptr_t exit_task_glue, uintptr_t spawnee_fn, size_t callsz) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n-    dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::TASK,\n+    rust_task *root_task = root_task_proxy->delegate();\n+    dom->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n              \"upcall start_thread(exit_task_glue 0x%\" PRIxPTR\n              \", spawnee 0x%\" PRIxPTR\n-             \", callsz %\" PRIdPTR \")\",\n-             exit_task_glue, spawnee_fn, callsz);\n+             \", callsz %\" PRIdPTR \")\", exit_task_glue, spawnee_fn, callsz);\n     root_task->start(exit_task_glue, spawnee_fn, spawner->rust_sp, callsz);\n \n #if defined(__WIN32__)\n     HANDLE thread;\n     thread = CreateThread(NULL, 0, rust_thread_start, root_task->dom,\n-                          0, NULL);\n+            0, NULL);\n     dom->win32_require(\"CreateThread\", thread != NULL);\n #else\n     pthread_t thread;\n     pthread_create(&thread, &dom->attr, rust_thread_start,\n-                   (void *)root_task->dom);\n+                   (void *) root_task->dom);\n #endif\n-\n-    return 0;\n+    return root_task_proxy;\n }\n \n //"}, {"sha": "62ac7de2d251ab4808f56b9e38136835aca74a90", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -5,7 +5,7 @@\n \n template <typename T>\n rc_base<T>::rc_base() :\n-    refcnt(1)\n+    ref_count(1)\n {\n }\n \n@@ -85,7 +85,7 @@ ptr_vec<T>::trim(size_t sz)\n \n template <typename T>\n void\n-ptr_vec<T>::swapdel(T *item)\n+ptr_vec<T>::swap_delete(T *item)\n {\n     /* Swap the endpoint into i and decr fill. */\n     I(dom, data);"}, {"sha": "d403257243dde74f991006915065f34b73f256cb", "filename": "src/rt/sync/condition_variable.cpp", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fcondition_variable.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fcondition_variable.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fcondition_variable.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,66 @@\n+#include \"../globals.h\"\n+\n+/*\n+ * Conditional variable. Implemented using pthreads condition variables, and\n+ * using events on windows.\n+ */\n+\n+#include \"condition_variable.h\"\n+\n+// #define TRACE\n+\n+condition_variable::condition_variable() {\n+#if defined(__WIN32__)\n+    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n+#else\n+    pthread_cond_init(&_cond, NULL);\n+    pthread_mutex_init(&_mutex, NULL);\n+#endif\n+}\n+\n+condition_variable::~condition_variable() {\n+#if defined(__WIN32__)\n+    CloseHandle(_event);\n+#else\n+    pthread_cond_destroy(&_cond);\n+    pthread_mutex_destroy(&_mutex);\n+#endif\n+}\n+\n+/**\n+ * Wait indefinitely until condition is signaled.\n+ */\n+void condition_variable::wait() {\n+#ifdef TRACE\n+    printf(\"waiting on condition_variable: 0x%\" PRIxPTR \"\\n\",\n+           (uintptr_t)this);\n+#endif\n+#if defined(__WIN32__)\n+    WaitForSingleObject(_event, INFINITE);\n+#else\n+    pthread_mutex_lock(&_mutex);\n+    pthread_cond_wait(&_cond, &_mutex);\n+    pthread_mutex_unlock(&_mutex);\n+#endif\n+#ifdef TRACE\n+    printf(\"resumed on condition_variable: 0x%\" PRIxPTR \"\\n\",\n+           (uintptr_t)this);\n+#endif\n+}\n+\n+/**\n+ * Signal condition, and resume the waiting thread.\n+ */\n+void condition_variable::signal() {\n+#if defined(__WIN32__)\n+    SetEvent(_event);\n+#else\n+    pthread_mutex_lock(&_mutex);\n+    pthread_cond_signal(&_cond);\n+    pthread_mutex_unlock(&_mutex);\n+#endif\n+#ifdef TRACE\n+    printf(\"signal  condition_variable: 0x%\" PRIxPTR \"\\n\",\n+           (uintptr_t)this);\n+#endif\n+}"}, {"sha": "f847ef990bdd8dd5bc04f8ee43742696bb65dd14", "filename": "src/rt/sync/condition_variable.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fcondition_variable.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fcondition_variable.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fcondition_variable.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,19 @@\n+#ifndef CONDITION_VARIABLE_H\n+#define CONDITION_VARIABLE_H\n+\n+class condition_variable {\n+#if defined(__WIN32__)\n+    HANDLE _event;\n+#else\n+    pthread_cond_t _cond;\n+    pthread_mutex_t _mutex;\n+#endif\n+public:\n+    condition_variable();\n+    virtual ~condition_variable();\n+\n+    void wait();\n+    void signal();\n+};\n+\n+#endif /* CONDITION_VARIABLE_H */"}, {"sha": "69241eced55c86bd0dfe359c50dc3b47b2f4a82c", "filename": "src/rt/sync/lock_free_queue.cpp", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Flock_free_queue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Flock_free_queue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -5,33 +5,46 @@\n  * dequeue() is not allowed to interrupt itself.\n  */\n \n+#include \"../globals.h\"\n #include \"lock_free_queue.h\"\n \n-lock_free_queue::lock_free_queue() :\n-    tail(this) {\n+lock_free_queue_node::lock_free_queue_node() : next(NULL) {\n+\n+}\n+\n+lock_free_queue::lock_free_queue() : _tail(this) {\n+\n }\n \n-void lock_free_queue::enqueue(lock_free_queue_node *item) {\n-    item->next = (lock_free_queue_node *) 0;\n-    lock_free_queue_node *last = tail;\n-    tail = item;\n-    while (last->next)\n+void\n+lock_free_queue::enqueue(lock_free_queue_node *item) {\n+    item->next = (lock_free_queue_node *) NULL;\n+    lock_free_queue_node *last = _tail;\n+    _tail = item;\n+    while (last->next) {\n         last = last->next;\n+    }\n     last->next = item;\n }\n \n-lock_free_queue_node *lockfree_queue::dequeue() {\n+lock_free_queue_node *\n+lock_free_queue::dequeue() {\n     lock_free_queue_node *item = next;\n     if (item && !(next = item->next)) {\n-        tail = (lock_free_queue_node *) this;\n+        _tail = (lock_free_queue_node *) this;\n         if (item->next) {\n             lock_free_queue_node *lost = item->next;\n             lock_free_queue_node *help;\n             do {\n                 help = lost->next;\n                 enqueue(lost);\n-            } while ((lost = help) != (lock_free_queue_node *) 0);\n+            } while ((lost = help) != (lock_free_queue_node *) NULL);\n         }\n     }\n     return item;\n }\n+\n+bool\n+lock_free_queue::is_empty() {\n+    return next == NULL;\n+}"}, {"sha": "1f09ec5225c3c3b26ea83ac21a9d64690c3b506c", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -2,14 +2,18 @@\n #define LOCK_FREE_QUEUE_H\n \n class lock_free_queue_node {\n+public:\n     lock_free_queue_node *next;\n+    lock_free_queue_node();\n };\n \n-class lock_free_queue {\n+class lock_free_queue : lock_free_queue_node {\n+    lock_free_queue_node *_tail;\n public:\n     lock_free_queue();\n     void enqueue(lock_free_queue_node *item);\n     lock_free_queue_node *dequeue();\n+    bool is_empty();\n };\n \n #endif /* LOCK_FREE_QUEUE_H */"}, {"sha": "4a113d1aef97a76a11f9f02fde0073a6b348b51a", "filename": "src/rt/sync/spin_lock.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fspin_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fspin_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.cpp?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,9 +1,10 @@\n+#include \"../globals.h\"\n+#include \"spin_lock.h\"\n+\n /*\n  * Your average spin lock.\n  */\n \n-#include \"globals.h\"\n-\n // #define TRACE\n \n spin_lock::spin_lock() {"}, {"sha": "f15416a2d4e015de2c719dcc36da09512d5c30ec", "filename": "src/rt/sync/spin_lock.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fspin_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Fsync%2Fspin_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,5 +1,5 @@\n-#ifndef UNFAIR_TICKET_LOCK_H\n-#define UNFAIR_TICKET_LOCK_H\n+#ifndef SPIN_LOCK_H\n+#define SPIN_LOCK_H\n \n class spin_lock {\n     unsigned ticket;\n@@ -11,4 +11,4 @@ class spin_lock {\n     void unlock();\n };\n \n-#endif /* UNFAIR_TICKET_LOCK_H */\n+#endif /* SPIN_LOCK_H */"}, {"sha": "04fd833f8b62e5aab0f813d7df744ab2df76dda9", "filename": "src/rt/util/array_list.h", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Futil%2Farray_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Frt%2Futil%2Farray_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Farray_list.h?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -13,38 +13,44 @@ template<typename T> class array_list {\n     array_list();\n     ~array_list();\n     size_t size();\n-    void append(T value);\n+    int32_t append(T value);\n     T replace(T old_value, T new_value);\n-    size_t index_of(T value);\n+    int32_t index_of(T value);\n     T & operator[](size_t index);\n };\n \n-template<typename T> array_list<T>::array_list() {\n+template<typename T>\n+array_list<T>::array_list() {\n     _capacity = INITIAL_CAPACITY;\n     _data = (T *) malloc(sizeof(T) * _capacity);\n }\n \n-template<typename T> array_list<T>::~array_list() {\n+template<typename T>\n+array_list<T>::~array_list() {\n     delete _data;\n }\n \n-template<typename T> size_t array_list<T>::size() {\n+template<typename T> size_t\n+array_list<T>::size() {\n     return _size;\n }\n \n-template<typename T> void array_list<T>::append(T value) {\n+template<typename T> int32_t\n+array_list<T>::append(T value) {\n     if (_size == _capacity) {\n         _capacity = _capacity * 2;\n         _data = (T *) realloc(_data, _capacity * sizeof(T));\n     }\n-    _data[_size++] = value;\n+    _data[_size ++] = value;\n+    return _size - 1;\n }\n \n /**\n  * Replaces the old_value in the list with the new_value.\n  * Returns the old_value if the replacement succeeded, or NULL otherwise.\n  */\n-template<typename T> T array_list<T>::replace(T old_value, T new_value) {\n+template<typename T> T\n+array_list<T>::replace(T old_value, T new_value) {\n     int index = index_of(old_value);\n     if (index < 0) {\n         return NULL;\n@@ -53,7 +59,8 @@ template<typename T> T array_list<T>::replace(T old_value, T new_value) {\n     return old_value;\n }\n \n-template<typename T> size_t array_list<T>::index_of(T value) {\n+template<typename T> int32_t\n+array_list<T>::index_of(T value) {\n     for (size_t i = 0; i < _size; i++) {\n         if (_data[i] == value) {\n             return i;\n@@ -62,7 +69,8 @@ template<typename T> size_t array_list<T>::index_of(T value) {\n     return -1;\n }\n \n-template<typename T> T & array_list<T>::operator[](size_t index) {\n+template<typename T> T &\n+array_list<T>::operator[](size_t index) {\n     return _data[index];\n }\n "}, {"sha": "5992ba5cf6fb4f0f1fe57bc90c4e2d63e67b9afb", "filename": "src/test/run-pass/task-comm-0.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,19 @@\n+io fn main() -> () {\n+    test05();\n+}\n+\n+io fn test05_start(chan[int] ch) {\n+    ch <| 10;\n+    ch <| 20;\n+    ch <| 30;\n+}\n+\n+io fn test05() {\n+    let port[int] po = port();\n+    let chan[int] ch = chan(po);\n+    spawn test05_start(chan(po));\n+    let int value <- po;\n+    value <- po;\n+    value <- po;\n+    log value;\n+}"}, {"sha": "48983b71e1af20a1b686c6ce3e54c352eabf0300", "filename": "src/test/run-pass/task-comm-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,13 @@\n+fn main() -> () {\n+   test00(); \n+}\n+\n+fn start() {\n+    log \"Started / Finished Task.\";\n+}\n+\n+fn test00() {\n+    let task t = spawn thread start();\n+    join t;\n+    log \"Completing.\";\n+}\n\\ No newline at end of file"}, {"sha": "9151c7b12c3ab5c023cba9cbf8b017d3b00041d8", "filename": "src/test/run-pass/task-comm-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,34 @@\n+fn main() -> () {\n+   log \"===== THREADS =====\";\n+   test00(true);\n+   log \"====== TASKS ======\";\n+   test00(false);\n+}\n+\n+fn start(int task_number) {\n+    log \"Started task.\";\n+    let int i = 0;\n+    while (i < 10000) {\n+        i = i + 1;\n+    }\n+    log \"Finished task.\";\n+}\n+    \n+fn test00(bool create_threads) {\n+    let int number_of_tasks = 32;\n+    \n+    let int i = 0;\n+    let vec[task] tasks = vec();\n+    while (i < number_of_tasks) {\n+        i = i + 1;\n+        if (create_threads) {\n+            tasks += vec(spawn thread start(i));\n+        } else {\n+            tasks += vec(spawn start(i));\n+        }\n+    }\n+    \n+    for (task t in tasks) {\n+        join t;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6dd620cc762179054f466b5d5d53f2945fa7603d", "filename": "src/test/run-pass/task-comm-3.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,59 @@\n+io fn main() -> () {\n+   log \"===== THREADS =====\";\n+   test00(false);\n+}\n+\n+io fn test00_start(chan[int] ch, int message, int count) {\n+    log \"Starting test00_start\";\n+    let int i = 0;\n+    while (i < count) {\n+        log \"Sending Message\";\n+        ch <| message;\n+        i = i + 1;\n+    }\n+    log \"Ending test00_start\";\n+}\n+\n+io fn test00(bool is_multithreaded) {\n+    let int number_of_tasks = 1;\n+    let int number_of_messages = 0;\n+    log \"Creating tasks\";\n+    \n+    let port[int] po = port();\n+    let chan[int] ch = chan(po);\n+    \n+    let int i = 0;\n+    \n+    // Create and spawn tasks...\n+    let vec[task] tasks = vec();\n+    while (i < number_of_tasks) {\n+        i = i + 1;\n+        if (is_multithreaded) {\n+            tasks += vec(\n+                spawn thread test00_start(ch, i, number_of_messages));\n+        } else {\n+            tasks += vec(spawn test00_start(ch, i, number_of_messages));\n+        }\n+    }\n+    \n+    // Read from spawned tasks...\n+    let int sum = 0;\n+    for (task t in tasks) {\n+        i = 0;\n+        while (i < number_of_messages) {\n+            let int value <- po;\n+            sum += value;\n+            i = i + 1;\n+        }\n+    }\n+\n+    // Join spawned tasks...\n+    for (task t in tasks) {\n+        join t;\n+    }\n+    \n+    log \"Completed: Final number is: \";\n+    check (sum + 1 == number_of_messages * \n+           (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n+    log sum;\n+}\n\\ No newline at end of file"}, {"sha": "42ba699236425288e730a6d5477759f2734b0e3e", "filename": "src/test/run-pass/task-comm-4.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -0,0 +1,10 @@\n+io fn main() -> () {\n+   test00();\n+}\n+\n+io fn test00() {\n+    let port[int] p = port();\n+    let chan[int] c = chan(p);\n+    c <| 42;\n+    let int r <- p;\n+}\n\\ No newline at end of file"}, {"sha": "ef71c6e1bcf55bc48e2ee6cc2da895a51cea2719", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d1465d13980fc3acf650f182ee0723fbda0e06/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=00d1465d13980fc3acf650f182ee0723fbda0e06", "patch": "@@ -1,25 +1,27 @@\n \n-\n-io fn main() -> () {\n-    test00(true);\n+fn main() -> () {\n+    // test00(true);\n     // test01();\n     // test02();\n     // test03();\n     // test04();\n+    // test05();\n+    test06();\n }\n \n io fn test00_start(chan[int] ch, int message, int count) {\n     log \"Starting test00_start\";\n     let int i = 0;\n     while (i < count) {\n+        log \"Sending Message\";\n         ch <| message;\n         i = i + 1;\n     }\n     log \"Ending test00_start\";\n }\n \n io fn test00(bool is_multithreaded) {\n-    let int number_of_tasks = 4;\n+    let int number_of_tasks = 1;\n     let int number_of_messages = 64;\n     log \"Creating tasks\";\n     \n@@ -109,12 +111,50 @@ fn test04() {\n     log \"Finishing up.\";\n }\n \n+io fn test05_start(chan[int] ch) {\n+    ch <| 10;\n+    ch <| 20;\n+    ch <| 30;\n+    ch <| 30;\n+    ch <| 30;    \n+}\n \n+io fn test05() {\n+    let port[int] po = port();\n+    let chan[int] ch = chan(po);\n+    spawn thread test05_start(ch);\n+    let int value <- po;\n+    value <- po;\n+    value <- po;\n+    log value;\n+}\n \n-\n-\n-\n-\n+fn test06_start(int task_number) {\n+    log \"Started task.\";\n+    let int i = 0;\n+    while (i < 100000000) {\n+        i = i + 1;    \n+    }\n+    log \"Finished task.\";\n+}\n+    \n+fn test06() {\n+    let int number_of_tasks = 32;\n+    log \"Creating tasks\";\n+    \n+    let int i = 0;\n+    \n+    let vec[task] tasks = vec();\n+    while (i < number_of_tasks) {\n+        i = i + 1;\n+        tasks += vec(spawn thread test06_start(i));\n+        // tasks += vec(spawn test06_start(i));\n+    }\n+    \n+    for (task t in tasks) {\n+        join t;\n+    }\n+}\n \n \n "}]}