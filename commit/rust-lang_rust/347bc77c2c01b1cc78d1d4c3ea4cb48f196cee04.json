{"sha": "347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0N2JjNzdjMmMwMWIxY2M3OGQxZDRjM2VhNGNiNDhmMTk2Y2VlMDQ=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-02-09T16:52:51Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-02-09T16:52:51Z"}, "message": "Use global recursion limit when evaluating inhabitedness", "tree": {"sha": "547380319ed759380763eb0664652499008c76ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/547380319ed759380763eb0664652499008c76ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "html_url": "https://github.com/rust-lang/rust/commit/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e", "html_url": "https://github.com/rust-lang/rust/commit/2bb9c5875d0ab956f7d87c60de34bc3f2a427c1e"}], "stats": {"total": 102, "additions": 55, "deletions": 47}, "files": [{"sha": "24ca476e5ff7994a36311f123cec3cace45b164a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::FxHashSet;\n+use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, TyS};\n use ty::{DefId, Substs};\n@@ -62,53 +62,43 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n-const ARBITRARY_RECURSION_LIMIT: u32 = 24;\n-\n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                recursion_depth: u32,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n-        if !visited.insert((self.did, substs)) {\n-            return DefIdForest::empty();\n-        }\n-\n-        let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(visited, recursion_depth, tcx, substs, self.adt_kind())\n-        }));\n-        visited.remove(&(self.did, substs));\n-        ret\n+        DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+        }))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                recursion_depth: u32,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n                 DefIdForest::intersection(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, recursion_depth, tcx, substs, false)\n+                    f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Struct => {\n                 DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, recursion_depth, tcx, substs, false)\n+                    f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Enum => {\n                 DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-                    f.uninhabited_from(visited, recursion_depth, tcx, substs, true)\n+                    f.uninhabited_from(visited, tcx, substs, true)\n                 }))\n             },\n         }\n@@ -119,14 +109,13 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                recursion_depth: u32,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n                 is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || {\n-            self.ty(tcx, substs).uninhabited_from(visited, recursion_depth, tcx)\n+            self.ty(tcx, substs).uninhabited_from(visited, tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // Visibility::Invisible so we need to override self.vis if we're\n@@ -151,15 +140,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                mut recursion_depth: u32,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n-        recursion_depth += 1;\n-        if recursion_depth >= ARBITRARY_RECURSION_LIMIT {\n-            return DefIdForest::empty();\n-        }\n-\n         match tcx.lift_to_global(&self) {\n             Some(global_ty) => {\n                 {\n@@ -168,44 +151,68 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                         return forest.clone();\n                     }\n                 }\n-                let forest = global_ty.uninhabited_from_inner(visited, recursion_depth, tcx);\n+                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n                 let mut cache = tcx.inhabitedness_cache.borrow_mut();\n                 cache.insert(global_ty, forest.clone());\n                 forest\n             },\n             None => {\n-                let forest = self.uninhabited_from_inner(visited, recursion_depth, tcx);\n+                let forest = self.uninhabited_from_inner(visited, tcx);\n                 forest\n             },\n         }\n     }\n \n     fn uninhabited_from_inner(\n                 &self,\n-                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                recursion_depth: u32,\n+                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {\n-                def.uninhabited_from(visited, recursion_depth, tcx, substs)\n+                {\n+                    let mut substs_set = visited.entry(def.did).or_insert(FxHashSet::default());\n+                    if !substs_set.insert(substs) {\n+                        // We are already calculating the inhabitedness of this type.\n+                        // The type must contain a reference to itself. Break the\n+                        // infinite loop.\n+                        return DefIdForest::empty();\n+                    }\n+                    if substs_set.len() >= tcx.sess.recursion_limit.get() / 4 {\n+                        // We have gone very deep, reinstantiating this ADT inside\n+                        // itself with different type arguments. We are probably\n+                        // hitting an infinite loop. For example, it's possible to write:\n+                        //                a type Foo<T>\n+                        //      which contains a Foo<(T, T)>\n+                        //      which contains a Foo<((T, T), (T, T))>\n+                        //      which contains a Foo<(((T, T), (T, T)), ((T, T), (T, T)))>\n+                        //      etc.\n+                        let error = format!(\"reached recursion limit while checking\n+                                             inhabitedness of `{}`\", self);\n+                        tcx.sess.fatal(&error);\n+                    }\n+                }\n+                let ret = def.uninhabited_from(visited, tcx, substs);\n+                let mut substs_set = visited.get_mut(&def.did).unwrap();\n+                substs_set.remove(substs);\n+                ret\n             },\n \n             TyNever => DefIdForest::full(tcx),\n             TyTuple(ref tys, _) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n-                    ty.uninhabited_from(visited, recursion_depth, tcx)\n+                    ty.uninhabited_from(visited, tcx)\n                 }))\n             },\n             TyArray(ty, len) => {\n                 if len == 0 {\n                     DefIdForest::empty()\n                 } else {\n-                    ty.uninhabited_from(visited, recursion_depth, tcx)\n+                    ty.uninhabited_from(visited, tcx)\n                 }\n             }\n             TyRef(_, ref tm) => {\n-                tm.ty.uninhabited_from(visited, recursion_depth, tcx)\n+                tm.ty.uninhabited_from(visited, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "862bc15c0526001775f1088c92cb540be4ed225a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "patch": "@@ -24,7 +24,7 @@ use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n-use util::nodemap::FxHashSet;\n+use util::nodemap::FxHashMap;\n \n use serialize;\n \n@@ -1018,8 +1018,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// This code should only compile in modules where the uninhabitedness of Foo is\n     /// visible.\n     pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashSet::default();\n-        let forest = self.uninhabited_from(&mut visited, 0, tcx);\n+        let mut visited = FxHashMap::default();\n+        let forest = self.uninhabited_from(&mut visited, tcx);\n \n         // To check whether this type is uninhabited at all (not just from the\n         // given node) you could check whether the forest is empty."}, {"sha": "78c4027aa4319297a1ab45100580d6e863b70c57", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "patch": "@@ -17,7 +17,7 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n@@ -404,8 +404,8 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n-                let mut visited = FxHashSet::default();\n-                let forest = v.uninhabited_from(&mut visited, 0,\n+                let mut visited = FxHashMap::default();\n+                let forest = v.uninhabited_from(&mut visited,\n                                                 cx.tcx, substs,\n                                                 AdtKind::Enum);\n                 if forest.contains(cx.tcx, cx.module)"}, {"sha": "efddee2c933f40baf3bb7d80c1d19f4293232ebc", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "patch": "@@ -26,7 +26,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n \n use std::mem;\n \n@@ -102,8 +102,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let mut visited = FxHashSet::default();\n-                            let node_set = v.uninhabited_from(&mut visited, 0,\n+                            let mut visited = FxHashMap::default();\n+                            let node_set = v.uninhabited_from(&mut visited,\n                                                               self.hir.tcx(),\n                                                               substs,\n                                                               adt_def.adt_kind());"}, {"sha": "91b85d7510a24bfc74405d5aa74df1bc2ede6398", "filename": "src/test/compile-fail/inhabitedness-infinite-loop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finhabitedness-infinite-loop.rs?ref=347bc77c2c01b1cc78d1d4c3ea4cb48f196cee04", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern:reached recursion limit\n+\n #![feature(never_type)]\n \n struct Foo<'a, T: 'a> {\n@@ -17,7 +19,6 @@ struct Foo<'a, T: 'a> {\n \n fn wub(f: Foo<!>) {\n     match f {}\n-    //~^ ERROR non-exhaustive\n }\n \n fn main() {}"}]}