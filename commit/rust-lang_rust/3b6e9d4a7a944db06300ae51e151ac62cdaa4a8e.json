{"sha": "3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNmU5ZDRhN2E5NDRkYjA2MzAwYWU1MWUxNTFhYzYyY2RhYTRhOGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-03-04T18:02:49Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-08T20:24:27Z"}, "message": "librustc: Automatically change uses of `~[T]` to `Vec<T>` in rustc.", "tree": {"sha": "30df4fb5365381ae1f967434bc22d121ff6489d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30df4fb5365381ae1f967434bc22d121ff6489d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "html_url": "https://github.com/rust-lang/rust/commit/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f690cc2c63d436434412cef56154627d94b6284e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f690cc2c63d436434412cef56154627d94b6284e", "html_url": "https://github.com/rust-lang/rust/commit/f690cc2c63d436434412cef56154627d94b6284e"}], "stats": {"total": 1628, "additions": 811, "deletions": 817}, "files": [{"sha": "ef8c2ddf38456943c7528466bc969ca96dd7b416", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -16,6 +16,7 @@ use metadata::filesearch;\n use lib::llvm::{ArchiveRef, llvm};\n \n use std::cast;\n+use std::vec_ng::Vec;\n use std::io::fs;\n use std::io;\n use std::libc;\n@@ -41,7 +42,7 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         paths: &[&Path]) -> ProcessOutput {\n     let ar = get_ar_prog(sess);\n \n-    let mut args = ~[args.to_owned()];\n+    let mut args = vec!(args.to_owned());\n     let mut paths = paths.iter().map(|p| p.as_str().unwrap().to_owned());\n     args.extend(&mut paths);\n     debug!(\"{} {}\", ar, args.connect(\" \"));\n@@ -89,7 +90,7 @@ impl Archive {\n     }\n \n     /// Read a file in the archive\n-    pub fn read(&self, file: &str) -> ~[u8] {\n+    pub fn read(&self, file: &str) -> Vec<u8> {\n         // Apparently if \"ar p\" is used on windows, it generates a corrupt file\n         // which has bad headers and LLVM will immediately choke on it\n         if cfg!(windows) && cfg!(windows) { // FIXME(#10734) double-and\n@@ -119,7 +120,7 @@ impl Archive {\n                     lto: bool) -> io::IoResult<()> {\n         let object = format!(\"{}.o\", name);\n         let bytecode = format!(\"{}.bc\", name);\n-        let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n+        let mut ignore = vec!(METADATA_FILENAME, bytecode.as_slice());\n         if lto {\n             ignore.push(object.as_slice());\n         }\n@@ -143,7 +144,7 @@ impl Archive {\n     }\n \n     /// Lists all files in an archive\n-    pub fn files(&self) -> ~[~str] {\n+    pub fn files(&self) -> Vec<~str> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n@@ -168,7 +169,7 @@ impl Archive {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        let mut inputs = ~[];\n+        let mut inputs = Vec::new();\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n             if skip.iter().any(|s| *s == filename) { continue }\n@@ -182,7 +183,7 @@ impl Archive {\n         if inputs.len() == 0 { return Ok(()) }\n \n         // Finally, add all the renamed files to this archive\n-        let mut args = ~[&self.dst];\n+        let mut args = vec!(&self.dst);\n         args.extend(&mut inputs.iter());\n         run_ar(self.sess, \"r\", None, args.as_slice());\n         Ok(())"}, {"sha": "f86c87af726746e6da28a093755b7bbf5e6c47a8", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -15,9 +15,9 @@ use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {\n     let cc_args = if target_triple.contains(\"thumb\") {\n-        ~[~\"-mthumb\"]\n+        vec!(~\"-mthumb\")\n     } else {\n-        ~[~\"-marm\"]\n+        vec!(~\"-marm\")\n     };\n     return target_strs::t {\n         module_asm: ~\"\","}, {"sha": "5f65b6c156fc64d78a6808a3b5bdcdd990cecb40", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -363,8 +363,8 @@ pub mod write {\n         let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n                             sess.opts.optimize == session::Aggressive;\n \n-        let mut llvm_c_strs = ~[];\n-        let mut llvm_args = ~[];\n+        let mut llvm_c_strs = Vec::new();\n+        let mut llvm_args = Vec::new();\n         {\n             let add = |arg: &str| {\n                 let s = arg.to_c_str();\n@@ -781,8 +781,8 @@ fn remove(sess: Session, path: &Path) {\n pub fn link_binary(sess: Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n-                   id: &CrateId) -> ~[Path] {\n-    let mut out_filenames = ~[];\n+                   id: &CrateId) -> Vec<Path> {\n+    let mut out_filenames = Vec::new();\n     let crate_types = sess.crate_types.borrow();\n     for &crate_type in crate_types.get().iter() {\n         let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n@@ -1071,15 +1071,15 @@ fn link_args(sess: Session,\n              dylib: bool,\n              tmpdir: &Path,\n              obj_filename: &Path,\n-             out_filename: &Path) -> ~[~str] {\n+             out_filename: &Path) -> Vec<~str> {\n \n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let lib_path = sess.filesearch.get_target_lib_path();\n     let stage: ~str = ~\"-L\" + lib_path.as_str().unwrap();\n \n-    let mut args = ~[stage];\n+    let mut args = vec!(stage);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     args.push_all([\n@@ -1230,7 +1230,7 @@ fn link_args(sess: Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n+fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n     let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n     for path in addl_lib_search_paths.get().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1263,7 +1263,7 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n+fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n                             dylib: bool, tmpdir: &Path) {\n \n     // As a limitation of the current implementation, we require that everything\n@@ -1347,7 +1347,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     // returning `None` if not all libraries could be found with that\n     // preference.\n     fn get_deps(cstore: &cstore::CStore,  preference: cstore::LinkagePreference)\n-            -> Option<~[(ast::CrateNum, Path)]>\n+            -> Option<Vec<(ast::CrateNum, Path)> >\n     {\n         let crates = cstore.get_used_crates(preference);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n@@ -1358,8 +1358,8 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crates(args: &mut ~[~str], sess: Session, tmpdir: &Path,\n-                         crates: ~[(ast::CrateNum, Path)]) {\n+    fn add_static_crates(args: &mut Vec<~str> , sess: Session, tmpdir: &Path,\n+                         crates: Vec<(ast::CrateNum, Path)> ) {\n         for (cnum, cratepath) in crates.move_iter() {\n             // When performing LTO on an executable output, all of the\n             // bytecode from the upstream libraries has already been\n@@ -1405,8 +1405,8 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crates(args: &mut ~[~str], sess: Session,\n-                          crates: ~[(ast::CrateNum, Path)]) {\n+    fn add_dynamic_crates(args: &mut Vec<~str> , sess: Session,\n+                          crates: Vec<(ast::CrateNum, Path)> ) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n@@ -1440,7 +1440,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut ~[~str], sess: Session) {\n+fn add_upstream_native_libraries(args: &mut Vec<~str> , sess: Session) {\n     let cstore = sess.cstore;\n     cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);"}, {"sha": "c1f3abe23c6b29fd41febdca72a66571a30588b5", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -63,6 +63,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[],\n+        cc_args: Vec::new(),\n     };\n }"}, {"sha": "df0160faaf89e119299bc893efb8eae8c38d75a4", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -21,15 +21,15 @@ fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n+pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n     if os == abi::OsWin32 {\n-        return ~[];\n+        return Vec::new();\n     }\n \n-    let mut flags = ~[];\n+    let mut flags = Vec::new();\n \n     if sess.targ_cfg.os == abi::OsFreebsd {\n         flags.push_all([~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n@@ -60,8 +60,8 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     p\n }\n \n-pub fn rpaths_to_flags(rpaths: &[~str]) -> ~[~str] {\n-    let mut ret = ~[];\n+pub fn rpaths_to_flags(rpaths: &[~str]) -> Vec<~str> {\n+    let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n         ret.push(\"-Wl,-rpath,\" + *rpath);\n     }\n@@ -72,7 +72,7 @@ fn get_rpaths(os: abi::Os,\n               sysroot: &Path,\n               output: &Path,\n               libs: &[Path],\n-              target_triple: &str) -> ~[~str] {\n+              target_triple: &str) -> Vec<~str> {\n     debug!(\"sysroot: {}\", sysroot.display());\n     debug!(\"output: {}\", output.display());\n     debug!(\"libs:\");\n@@ -91,7 +91,7 @@ fn get_rpaths(os: abi::Os,\n     let abs_rpaths = get_absolute_rpaths(libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n+    let fallback_rpaths = vec!(get_install_prefix_rpath(target_triple));\n \n     fn log_rpaths(desc: &str, rpaths: &[~str]) {\n         debug!(\"{} rpaths:\", desc);\n@@ -115,7 +115,7 @@ fn get_rpaths(os: abi::Os,\n \n fn get_rpaths_relative_to_output(os: abi::Os,\n                                  output: &Path,\n-                                 libs: &[Path]) -> ~[~str] {\n+                                 libs: &[Path]) -> Vec<~str> {\n     libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n@@ -145,7 +145,7 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n     prefix+\"/\"+relative.as_str().expect(\"non-utf8 component in path\")\n }\n \n-fn get_absolute_rpaths(libs: &[Path]) -> ~[~str] {\n+fn get_absolute_rpaths(libs: &[Path]) -> Vec<~str> {\n     libs.iter().map(|a| get_absolute_rpath(a)).collect()\n }\n \n@@ -167,9 +167,9 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> ~str {\n     path.as_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n-pub fn minimize_rpaths(rpaths: &[~str]) -> ~[~str] {\n+pub fn minimize_rpaths(rpaths: &[~str]) -> Vec<~str> {\n     let mut set = HashSet::new();\n-    let mut minimized = ~[];\n+    let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n         if set.insert(rpath.as_slice()) {\n             minimized.push(rpath.clone());\n@@ -190,7 +190,7 @@ mod test {\n     #[test]\n     fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags([~\"path1\", ~\"path2\"]);\n-        assert_eq!(flags, ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n+        assert_eq!(flags, vec!(~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"));\n     }\n \n     #[test]"}, {"sha": "1528fff511310f0c9c7c539fd489a08db66564b3", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -15,5 +15,5 @@ pub struct t {\n     meta_sect_name: ~str,\n     data_layout: ~str,\n     target_triple: ~str,\n-    cc_args: ~[~str],\n+    cc_args: Vec<~str> ,\n }"}, {"sha": "9b22c82e91776a9f01061a694e736e9f755e1f7e", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -46,6 +46,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[~\"-m32\"],\n+        cc_args: vec!(~\"-m32\"),\n     };\n }"}, {"sha": "524ae5e55248485c8b03b8bb16fbc364d4d2acbf", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -54,6 +54,6 @@ pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::\n \n         target_triple: target_triple,\n \n-        cc_args: ~[~\"-m64\"],\n+        cc_args: vec!(~\"-m64\"),\n     };\n }"}, {"sha": "af3970fcf7a4b7cb3d6f920def896974d2f24a34", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -145,7 +145,7 @@ pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str])\n+fn parse_cfgspecs(cfgspecs: Vec<~str> )\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess();\n@@ -399,8 +399,8 @@ pub struct CrateTranslation {\n     module: ModuleRef,\n     metadata_module: ModuleRef,\n     link: LinkMeta,\n-    metadata: ~[u8],\n-    reachable: ~[~str],\n+    metadata: Vec<u8> ,\n+    reachable: Vec<~str> ,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -489,7 +489,7 @@ fn write_out_deps(sess: Session,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n     let id = link::find_crate_id(krate.attrs.as_slice(), outputs);\n \n-    let mut out_filenames = ~[];\n+    let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.iter() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n@@ -524,7 +524,7 @@ fn write_out_deps(sess: Session,\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: ~[~str] = {\n+    let files: Vec<~str> = {\n         let files = sess.codemap.files.borrow();\n         files.get()\n              .iter()\n@@ -786,14 +786,14 @@ pub fn build_session_options(matches: &getopts::Matches)\n \n     let lint_levels = [lint::allow, lint::warn,\n                        lint::deny, lint::forbid];\n-    let mut lint_opts = ~[];\n+    let mut lint_opts = Vec::new();\n     let lint_dict = lint::get_lint_dict();\n     for level in lint_levels.iter() {\n         let level_name = lint::level_to_str(*level);\n \n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = vec::append(matches.opt_strs(level_short),\n+        let flags = vec_ng::append(matches.opt_strs(level_short),\n                                 matches.opt_strs(level_name));\n         for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n@@ -829,7 +829,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n     }\n \n     let mut output_types = if parse_only || no_trans {\n-        ~[]\n+        Vec::new()\n     } else {\n         matches.opt_strs(\"emit\").flat_map(|s| {\n             s.split(',').map(|part| {\n@@ -1005,7 +1005,7 @@ pub fn build_session_(sopts: @session::Options,\n         working_dir: os::getcwd(),\n         lints: RefCell::new(HashMap::new()),\n         node_id: Cell::new(1),\n-        crate_types: @RefCell::new(~[]),\n+        crate_types: @RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new()\n     }\n }\n@@ -1026,8 +1026,8 @@ pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n }\n \n // rustc command line options\n-pub fn optgroups() -> ~[getopts::OptGroup] {\n- ~[\n+pub fn optgroups() -> Vec<getopts::OptGroup> {\n+ vec!(\n   optflag(\"h\", \"help\", \"Display this message\"),\n   optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n   optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n@@ -1071,8 +1071,7 @@ pub fn optgroups() -> ~[getopts::OptGroup] {\n   optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n   optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n   optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-  optflag( \"v\", \"version\", \"Print version info and exit\"),\n- ]\n+  optflag( \"v\", \"version\", \"Print version info and exit\"))\n }\n \n pub struct OutputFilenames {"}, {"sha": "62d85af399d80461013ddede551ca270efbf8e68", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -74,8 +74,8 @@ debugging_opts!(\n     0\n )\n \n-pub fn debugging_opts_map() -> ~[(&'static str, &'static str, u64)] {\n-    ~[(\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n+pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n+    vec!((\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n      (\"time-passes\", \"measure time of each rustc pass\", TIME_PASSES),\n      (\"count-llvm-insns\", \"count where LLVM \\\n                            instrs originate\", COUNT_LLVM_INSNS),\n@@ -102,8 +102,7 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, u64)] {\n       PRINT_LLVM_PASSES),\n      (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n      (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n-     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n-    ]\n+     (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND))\n }\n \n #[deriving(Clone, Eq)]\n@@ -125,13 +124,13 @@ pub enum DebugInfoLevel {\n pub struct Options {\n     // The crate config requested for the session, which may be combined\n     // with additional crate configurations during the compile process\n-    crate_types: ~[CrateType],\n+    crate_types: Vec<CrateType> ,\n \n     gc: bool,\n     optimize: OptLevel,\n     debuginfo: DebugInfoLevel,\n-    lint_opts: ~[(lint::Lint, lint::level)],\n-    output_types: ~[back::link::OutputType],\n+    lint_opts: Vec<(lint::Lint, lint::level)> ,\n+    output_types: Vec<back::link::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n@@ -192,9 +191,9 @@ pub struct Session_ {\n     local_crate_source_file: Option<Path>,\n     working_dir: Path,\n     lints: RefCell<HashMap<ast::NodeId,\n-                           ~[(lint::Lint, codemap::Span, ~str)]>>,\n+                           Vec<(lint::Lint, codemap::Span, ~str)> >>,\n     node_id: Cell<ast::NodeId>,\n-    crate_types: @RefCell<~[CrateType]>,\n+    crate_types: @RefCell<Vec<CrateType> >,\n     features: front::feature_gate::Features\n }\n \n@@ -259,7 +258,7 @@ impl Session_ {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n-        lints.get().insert(id, ~[(lint, sp, msg)]);\n+        lints.get().insert(id, vec!((lint, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)\n@@ -318,12 +317,22 @@ impl Session_ {\n /// Some reasonable defaults\n pub fn basic_options() -> @Options {\n     @Options {\n-        crate_types: ~[],\n+        crate_types: Vec::new(),\n         gc: false,\n         optimize: No,\n+<<<<<<< HEAD\n         debuginfo: NoDebugInfo,\n         lint_opts: ~[],\n         output_types: ~[],\n+||||||| merged common ancestors\n+        debuginfo: false,\n+        lint_opts: ~[],\n+        output_types: ~[],\n+=======\n+        debuginfo: false,\n+        lint_opts: Vec::new(),\n+        output_types: Vec::new(),\n+>>>>>>> librustc: Automatically change uses of `~[T]` to `Vec<T>` in rustc.\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n@@ -394,7 +403,7 @@ macro_rules! cgoptions(\n             }\n         }\n \n-        fn parse_list(slot: &mut ~[~str], v: Option<&str>) -> bool {\n+        fn parse_list(slot: &mut Vec<~str> , v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => {\n                     for s in s.words() {\n@@ -414,15 +423,15 @@ cgoptions!(\n         \"tool to assemble archives with\"),\n     linker: Option<~str> = (None, parse_opt_string,\n         \"system linker to link outputs with\"),\n-    link_args: ~[~str] = (~[], parse_list,\n+    link_args: Vec<~str> = (Vec::new(), parse_list,\n         \"extra arguments to pass to the linker (space separated)\"),\n     target_cpu: ~str = (~\"generic\", parse_string,\n         \"select target processor (llc -mcpu=help for details)\"),\n     target_feature: ~str = (~\"\", parse_string,\n         \"target specific attributes (llc -mattr=help for details)\"),\n-    passes: ~[~str] = (~[], parse_list,\n+    passes: Vec<~str> = (Vec::new(), parse_list,\n         \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: ~[~str] = (~[], parse_list,\n+    llvm_args: Vec<~str> = (Vec::new(), parse_list,\n         \"a list of arguments to pass to llvm (space separated)\"),\n     save_temps: bool = (false, parse_bool,\n         \"save all temporary output files during compilation\"),\n@@ -476,11 +485,11 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn collect_crate_types(session: &Session,\n-                           attrs: &[ast::Attribute]) -> ~[CrateType] {\n+                           attrs: &[ast::Attribute]) -> Vec<CrateType> {\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return ~[CrateTypeExecutable];\n+        return Vec<CrateTypeExecutable> ;\n     }\n     let mut base = session.opts.crate_types.clone();\n     let mut iter = attrs.iter().filter_map(|a| {"}, {"sha": "cf2c0d0775c560ef1c7f2c1fc1f8a28030d8739d", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -58,7 +58,7 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n }\n \n fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: ~[&@ast::Item] = m.items.iter()\n+    let filtered_items: Vec<&@ast::Item> = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n             .collect();\n     let flattened_items = filtered_items.move_iter()\n@@ -170,7 +170,7 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n }\n \n fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: ~[&@ast::Stmt] =\n+    let resulting_stmts: Vec<&@ast::Stmt> =\n         b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n     let resulting_stmts = resulting_stmts.move_iter()\n         .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())"}, {"sha": "81aa48a6435bfa43ddb228ff0afaa5978eae8603", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -85,7 +85,7 @@ impl Features {\n }\n \n struct Context {\n-    features: ~[&'static str],\n+    features: Vec<&'static str> ,\n     sess: Session,\n }\n \n@@ -280,7 +280,7 @@ impl Visitor<()> for Context {\n \n pub fn check_crate(sess: Session, krate: &ast::Crate) {\n     let mut cx = Context {\n-        features: ~[],\n+        features: Vec::new(),\n         sess: sess,\n     };\n "}, {"sha": "82fae11f873a4b1da401f9617263ea56f397e041", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -40,17 +40,17 @@ use syntax::util::small_vector::SmallVector;\n \n struct Test {\n     span: Span,\n-    path: ~[ast::Ident],\n+    path: Vec<ast::Ident> ,\n     bench: bool,\n     ignore: bool,\n     should_fail: bool\n }\n \n struct TestCtxt<'a> {\n     sess: session::Session,\n-    path: RefCell<~[ast::Ident]>,\n+    path: RefCell<Vec<ast::Ident> >,\n     ext_cx: ExtCtxt<'a>,\n-    testfns: RefCell<~[Test]>,\n+    testfns: RefCell<Vec<Test> >,\n     is_test_crate: bool,\n     config: ast::CrateConfig,\n }\n@@ -171,8 +171,8 @@ fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n                                  loader: loader,\n                                  deriving_hash_type_parameter: false,\n                              }),\n-        path: RefCell::new(~[]),\n-        testfns: RefCell::new(~[]),\n+        path: RefCell::new(Vec::new()),\n+        testfns: RefCell::new(Vec::new()),\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -303,7 +303,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let vi = if cx.is_test_crate {\n         ast::ViewItemUse(\n             vec!(@nospan(ast::ViewPathSimple(id_test,\n-                                             path_node(~[id_test]),\n+                                             path_node(vec!(id_test)),\n                                              ast::DUMMY_NODE_ID))))\n     } else {\n         ast::ViewItemExternCrate(id_test,\n@@ -363,7 +363,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n-fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n+fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n@@ -375,7 +375,7 @@ fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n-fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n+fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: true,"}, {"sha": "6ff0733e98b096f2c45fdf1cbe0f3975d866a507", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -164,7 +164,7 @@ Available lint options:\n     let lint_dict = lint::get_lint_dict();\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n-                                 .collect::<~[(lint::LintSpec, &'static str)]>();\n+                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n     lint_dict.sort();\n \n     let mut max_key = 0;\n@@ -236,7 +236,7 @@ pub fn run_compiler(args: &[~str]) {\n         return;\n     }\n \n-    let lint_flags = vec::append(matches.opt_strs(\"W\"),\n+    let lint_flags = vec_ng::append(matches.opt_strs(\"W\"),\n                                  matches.opt_strs(\"warn\"));\n     if lint_flags.iter().any(|x| x == &~\"help\") {\n         describe_warnings();\n@@ -337,7 +337,7 @@ pub fn run_compiler(args: &[~str]) {\n }\n \n fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n-                     ~[ast::Attribute] {\n+                     Vec<ast::Attribute> {\n     let result = match *input {\n         d::FileInput(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile,"}, {"sha": "36f5929ba261d59f13d0fc6d41ec9304bfe58041", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -46,7 +46,7 @@ pub fn read_crates(sess: Session,\n     let mut e = Env {\n         sess: sess,\n         os: os,\n-        crate_cache: @RefCell::new(~[]),\n+        crate_cache: @RefCell::new(Vec::new()),\n         next_crate_num: 1,\n         intr: intr\n     };\n@@ -121,7 +121,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n struct Env {\n     sess: Session,\n     os: loader::Os,\n-    crate_cache: @RefCell<~[cache_entry]>,\n+    crate_cache: @RefCell<vec!(cache_entry)>,\n     next_crate_num: ast::CrateNum,\n     intr: @IdentInterner\n }\n@@ -401,7 +401,7 @@ impl Loader {\n             env: Env {\n                 sess: sess,\n                 os: os,\n-                crate_cache: @RefCell::new(~[]),\n+                crate_cache: @RefCell::new(Vec::new()),\n                 next_crate_num: 1,\n                 intr: token::get_ident_interner(),\n             }"}, {"sha": "fa00b3c69b2cb8c91f948485a6d9758bc27f94a2", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -86,14 +86,14 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ~[ast_map::PathElem] {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::PathMod(token::intern(cdata.name))], path)\n+    vec_ng::append(vec!(ast_map::PathMod(token::intern(cdata.name))), path)\n }\n \n pub enum found_ast {\n@@ -114,7 +114,7 @@ pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n }\n \n pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n-                      -> ~[@ty::VariantInfo] {\n+                      -> Vec<@ty::VariantInfo> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n@@ -141,7 +141,7 @@ pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n }\n \n pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n-                                def: ast::DefId) -> ~[ast::DefId] {\n+                                def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n@@ -154,13 +154,13 @@ pub fn get_item_variances(cstore: @cstore::CStore,\n \n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n-                               -> ~[@ty::Method] {\n+                               -> Vec<@ty::Method> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> ~[@ty::TraitRef] {\n+pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n@@ -174,21 +174,21 @@ pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n \n pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n                                   def: ast::DefId)\n-                               -> Option<~[StaticMethodInfo]> {\n+                               -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: @cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: |~[@ast::MetaItem]|) {\n+                      f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: @cstore::CStore,\n                          def: ast::DefId)\n-                      -> ~[ty::field_ty] {\n+                      -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n@@ -222,8 +222,8 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                  class_id, def) );\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n-                                region_param_defs: Rc::new(~[])},\n+        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n+                                region_param_defs: Rc::new(Vec::new())},\n         ty: ty\n     }\n }\n@@ -262,7 +262,7 @@ pub fn get_item_visibility(cstore: @cstore::CStore,\n \n pub fn get_native_libraries(cstore: @cstore::CStore,\n                             crate_num: ast::CrateNum)\n-                                -> ~[(cstore::NativeLibaryKind, ~str)] {\n+                                -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n@@ -308,7 +308,7 @@ pub fn get_macro_registrar_fn(cstore: @cstore::CStore,\n \n pub fn get_exported_macros(cstore: @cstore::CStore,\n                            crate_num: ast::CrateNum)\n-                           -> ~[~str] {\n+                           -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_exported_macros(cdata)\n }"}, {"sha": "f0c67c4140aba9f592234f61853d2e5743758d19", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -67,9 +67,9 @@ pub struct CrateSource {\n pub struct CStore {\n     priv metas: RefCell<HashMap<ast::CrateNum, @crate_metadata>>,\n     priv extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n-    priv used_crate_sources: RefCell<~[CrateSource]>,\n-    priv used_libraries: RefCell<~[(~str, NativeLibaryKind)]>,\n-    priv used_link_args: RefCell<~[~str]>,\n+    priv used_crate_sources: RefCell<Vec<CrateSource> >,\n+    priv used_libraries: RefCell<Vec<(~str, NativeLibaryKind)> >,\n+    priv used_link_args: RefCell<Vec<~str> >,\n     intr: @IdentInterner\n }\n \n@@ -81,9 +81,9 @@ impl CStore {\n         CStore {\n             metas: RefCell::new(HashMap::new()),\n             extern_mod_crate_map: RefCell::new(HashMap::new()),\n-            used_crate_sources: RefCell::new(~[]),\n-            used_libraries: RefCell::new(~[]),\n-            used_link_args: RefCell::new(~[]),\n+            used_crate_sources: RefCell::new(Vec::new()),\n+            used_libraries: RefCell::new(Vec::new()),\n+            used_link_args: RefCell::new(Vec::new()),\n             intr: intr\n         }\n     }\n@@ -143,7 +143,7 @@ impl CStore {\n     }\n \n     pub fn get_used_crates(&self, prefer: LinkagePreference)\n-                           -> ~[(ast::CrateNum, Option<Path>)] {\n+                           -> Vec<(ast::CrateNum, Option<Path>)> {\n         let used_crate_sources = self.used_crate_sources.borrow();\n         used_crate_sources.get()\n             .iter()\n@@ -161,7 +161,7 @@ impl CStore {\n     }\n \n     pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<~[(~str, NativeLibaryKind)]> {\n+                              -> &'a RefCell<Vec<(~str, NativeLibaryKind)> > {\n         &self.used_libraries\n     }\n \n@@ -172,7 +172,7 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<~[~str]> {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<~str> > {\n         &self.used_link_args\n     }\n "}, {"sha": "0c0dcf340d8bc5156cf8f14b2e97bdc070da2ea0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -250,8 +250,8 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tcx: ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n-                      -> Rc<~[ty::TypeParameterDef]> {\n-    let mut bounds = ~[];\n+                      -> Rc<Vec<ty::TypeParameterDef> > {\n+    let mut bounds = Vec::new();\n     reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n             p.data, p.start, cdata.cnum, tcx,\n@@ -263,8 +263,8 @@ fn item_ty_param_defs(item: ebml::Doc,\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n-                          -> Rc<~[ty::RegionParameterDef]> {\n-    let mut v = ~[];\n+                          -> Rc<Vec<ty::RegionParameterDef> > {\n+    let mut v = Vec::new();\n     reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n@@ -287,8 +287,8 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n     n\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n-    let mut ids: ~[ast::DefId] = ~[];\n+fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n+    let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n     reader::tagged_docs(item, v, |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n@@ -298,7 +298,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::Doc) -> ~[ast_map::PathElem] {\n+fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n@@ -667,15 +667,15 @@ pub fn each_top_level_item_of_crate(intr: @IdentInterner,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ~[ast_map::PathElem] {\n+pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n                                      tcx: ty::ctxt,\n-                                     path: ~[ast_map::PathElem],\n+                                     path: Vec<ast_map::PathElem> ,\n                                      par_doc: ebml::Doc|\n-                                     -> Result<ast::InlinedItem, ~[ast_map::PathElem]>;\n+                                     -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n                           decode_inlined_item: DecodeInlinedItem)\n@@ -702,11 +702,11 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                     tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n+                     tcx: ty::ctxt) -> Vec<@ty::VariantInfo> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: ~[@ty::VariantInfo] = ~[];\n+    let mut infos: Vec<@ty::VariantInfo> = Vec::new();\n     let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n     for did in variant_ids.iter() {\n@@ -716,7 +716,7 @@ pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n           ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n-          _ => ~[], // Nullary enum variant.\n+          _ => Vec::new(), // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n@@ -761,8 +761,8 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n }\n \n fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n-                     tcx: ty::ctxt) -> ~[@ty::Method] {\n-    let mut rslt = ~[];\n+                     tcx: ty::ctxt) -> Vec<@ty::Method> {\n+    let mut rslt = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n         rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n@@ -838,10 +838,10 @@ pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n }\n \n pub fn get_trait_method_def_ids(cdata: Cmd,\n-                                id: ast::NodeId) -> ~[ast::DefId] {\n+                                id: ast::NodeId) -> Vec<ast::DefId> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(item, tag_item_trait_method, |mth| {\n         result.push(item_def_id(mth, cdata));\n         true\n@@ -859,10 +859,10 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n \n pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n-        ~[@ty::Method] {\n+        Vec<@ty::Method> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n \n     reader::tagged_docs(item, tag_item_trait_method, |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n@@ -879,8 +879,8 @@ pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n-                    -> ~[@ty::TraitRef] {\n-    let mut results = ~[];\n+                    -> Vec<@ty::TraitRef> {\n+    let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Only reads the ones that *aren't* builtin-bounds. See also\n@@ -914,7 +914,7 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n pub fn get_static_methods_if_impl(intr: @IdentInterner,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n-                               -> Option<~[StaticMethodInfo]> {\n+                               -> Option<Vec<StaticMethodInfo> > {\n     let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n@@ -927,13 +927,13 @@ pub fn get_static_methods_if_impl(intr: @IdentInterner,\n \n     if !ret { return None }\n \n-    let mut impl_method_ids = ~[];\n+    let mut impl_method_ids = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |impl_method_doc| {\n         impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n         true\n     });\n \n-    let mut static_impl_methods = ~[];\n+    let mut static_impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids.iter() {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n@@ -975,7 +975,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n-                      f: |~[@ast::MetaItem]|) {\n+                      f: |Vec<@ast::MetaItem> |) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1000,10 +1000,10 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n }\n \n pub fn get_struct_fields(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId)\n-    -> ~[ty::field_ty] {\n+    -> Vec<ty::field_ty> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(item, tag_item_field, |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n@@ -1035,8 +1035,8 @@ pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n     item_visibility(lookup_item(id, cdata.data()))\n }\n \n-fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n-    let mut items: ~[@ast::MetaItem] = ~[];\n+fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n+    let mut items: Vec<@ast::MetaItem> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1063,8 +1063,8 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n-    let mut attrs: ~[ast::Attribute] = ~[];\n+fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n+    let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n         reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n@@ -1102,7 +1102,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n     write!(out, \"\\n\\n\")\n }\n \n-pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n+pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n     return get_attributes(reader::Doc(data));\n }\n \n@@ -1113,8 +1113,8 @@ pub struct CrateDep {\n     hash: Svh,\n }\n \n-pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n-    let mut deps: ~[CrateDep] = ~[];\n+pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n+    let mut deps: Vec<CrateDep> = Vec::new();\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n@@ -1255,10 +1255,10 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n }\n \n \n-pub fn get_native_libraries(cdata: Cmd) -> ~[(cstore::NativeLibaryKind, ~str)] {\n+pub fn get_native_libraries(cdata: Cmd) -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let libraries = reader::get_doc(reader::Doc(cdata.data()),\n                                     tag_native_libraries);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n@@ -1276,10 +1276,10 @@ pub fn get_macro_registrar_fn(cdata: Cmd) -> Option<ast::DefId> {\n         .map(|doc| item_def_id(doc, cdata))\n }\n \n-pub fn get_exported_macros(cdata: Cmd) -> ~[~str] {\n+pub fn get_exported_macros(cdata: Cmd) -> Vec<~str> {\n     let macros = reader::get_doc(reader::Doc(cdata.data()),\n                                  tag_exported_macros);\n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n         result.push(macro_doc.as_str());\n         true"}, {"sha": "c81ee348016209b5fec818a68249ac4303dca86a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -324,7 +324,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            index: @RefCell<~[entry<i64>]>,\n+                            index: @RefCell<Vec<entry<i64>> >,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -687,11 +687,11 @@ fn encode_provided_source(ebml_w: &mut writer::Encoder,\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           fields: &[StructField],\n-                          global_index: @RefCell<~[entry<i64>]>)\n-                          -> ~[entry<i64>] {\n+                          global_index: @RefCell<Vec<entry<i64>> >)\n+                          -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n-    let mut index = ~[];\n+    let mut index = Vec::new();\n     let tcx = ecx.tcx;\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n@@ -726,7 +726,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @RefCell<~[entry<i64>]>,\n+                               index: @RefCell<Vec<entry<i64>> >,\n                                struct_id: NodeId) {\n     {\n         let mut index = index.borrow_mut();\n@@ -888,13 +888,13 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: &Item,\n-                        index: @RefCell<~[entry<i64>]>,\n+                        index: @RefCell<Vec<entry<i64>> >,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: &Item, ebml_w: &writer::Encoder,\n-                     index: @RefCell<~[entry<i64>]>) {\n+                     index: @RefCell<Vec<entry<i64>> >) {\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: item.id as i64,\n@@ -1239,7 +1239,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n                                 nitem: &ForeignItem,\n-                                index: @RefCell<~[entry<i64>]>,\n+                                index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n                                 abi: AbiSet) {\n     {\n@@ -1284,7 +1284,7 @@ fn my_visit_expr(_e: &Expr) { }\n fn my_visit_item(i: &Item,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n-                 index: @RefCell<~[entry<i64>]>) {\n+                 index: @RefCell<Vec<entry<i64>> >) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1296,7 +1296,7 @@ fn my_visit_item(i: &Item,\n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n-                         index: @RefCell<~[entry<i64>]>) {\n+                         index: @RefCell<Vec<entry<i64>> >) {\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n@@ -1317,7 +1317,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n-    index: @RefCell<~[entry<i64>]>,\n+    index: @RefCell<Vec<entry<i64>> >,\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n@@ -1344,8 +1344,8 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut writer::Encoder,\n                          krate: &Crate)\n-                         -> ~[entry<i64>] {\n-    let index = @RefCell::new(~[]);\n+                         -> Vec<entry<i64>> {\n+    let index = @RefCell::new(Vec::new());\n     ebml_w.start_tag(tag_items_data);\n     {\n         let mut index = index.borrow_mut();\n@@ -1382,19 +1382,19 @@ fn encode_info_for_items(ecx: &EncodeContext,\n // Path and definition ID indexing\n \n fn create_index<T:Clone + Hash + 'static>(\n-                index: ~[entry<T>])\n-                -> ~[@~[entry<T>]] {\n-    let mut buckets: ~[@RefCell<~[entry<T>]>] = ~[];\n+                index: Vec<entry<T>> )\n+                -> Vec<@Vec<entry<T>> > {\n+    let mut buckets: Vec<@RefCell<Vec<entry<T>> >> = Vec::new();\n     for _ in range(0u, 256u) {\n-        buckets.push(@RefCell::new(~[]));\n+        buckets.push(@RefCell::new(Vec::new()));\n     }\n     for elt in index.iter() {\n         let h = hash::hash(&elt.val) as uint;\n         let mut bucket = buckets[h % 256].borrow_mut();\n         bucket.get().push((*elt).clone());\n     }\n \n-    let mut buckets_frozen = ~[];\n+    let mut buckets_frozen = Vec::new();\n     for bucket in buckets.iter() {\n         buckets_frozen.push(@/*bad*/(**bucket).get());\n     }\n@@ -1403,10 +1403,10 @@ fn create_index<T:Clone + Hash + 'static>(\n \n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n-                buckets: ~[@~[entry<T>]],\n+                buckets: Vec<@Vec<entry<T>> > ,\n                 write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n-    let mut bucket_locs = ~[];\n+    let mut bucket_locs = Vec::new();\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell().unwrap());\n@@ -1491,7 +1491,7 @@ fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n // metadata that Rust cares about for linking crates. If the user didn't\n // provide it we will throw it in anyway with a default value.\n fn synthesize_crate_attrs(ecx: &EncodeContext,\n-                          krate: &Crate) -> ~[Attribute] {\n+                          krate: &Crate) -> Vec<Attribute> {\n \n     fn synthesize_crateid_attr(ecx: &EncodeContext) -> Attribute {\n         assert!(!ecx.link_meta.crateid.name.is_empty());\n@@ -1502,7 +1502,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n                 token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))\n     }\n \n-    let mut attrs = ~[];\n+    let mut attrs = Vec::new();\n     for attr in krate.attrs.iter() {\n         if !attr.name().equiv(&(\"crate_id\")) {\n             attrs.push(*attr);\n@@ -1514,9 +1514,9 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n }\n \n fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n-    fn get_ordered_deps(cstore: &cstore::CStore) -> ~[decoder::CrateDep] {\n+    fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps = ~[];\n+        let mut deps = Vec::new();\n         cstore.iter_crate_data(|key, val| {\n             let dep = decoder::CrateDep {\n                 cnum: key,\n@@ -1767,7 +1767,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = MemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n     wr.unwrap()"}, {"sha": "c22caafab3034586116553a2d742cdec990443d3", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -205,14 +205,14 @@ pub fn get_rust_path() -> Option<~str> {\n /// $HOME/.rust\n /// DIR/.rust for any DIR that's the current working directory\n /// or an ancestor of it\n-pub fn rust_path() -> ~[Path] {\n-    let mut env_rust_path: ~[Path] = match get_rust_path() {\n+pub fn rust_path() -> Vec<Path> {\n+    let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n-            let env_path_components: ~[&str] =\n+            let env_path_components: Vec<&str> =\n                 env_path.split_str(PATH_ENTRY_SEPARATOR).collect();\n             env_path_components.map(|&s| Path::new(s))\n         }\n-        None => ~[]\n+        None => Vec::new()\n     };\n     let mut cwd = os::getcwd();\n     // now add in default entries"}, {"sha": "e9b6d241b171047651866fee6561693e8b7a294d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -183,7 +183,7 @@ impl<'a> Context<'a> {\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n         // serach is being performed for.\n-        let mut libraries = ~[];\n+        let mut libraries = Vec::new();\n         for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n             let mut metadata = None;\n             let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);"}, {"sha": "0f7fcdc4791ea3a85f451b255c9cd0752caa6344", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -177,7 +177,7 @@ fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n     assert_eq!(next(st), '[');\n-    let mut params: ~[ty::t] = ~[];\n+    let mut params: Vec<ty::t> = Vec::new();\n     while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n     st.pos = st.pos + 1u;\n \n@@ -362,7 +362,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n-        let mut params = ~[];\n+        let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n@@ -520,7 +520,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n     let id = parse_uint(st) as ast::NodeId;\n     assert_eq!(next(st), '|');\n-    let mut inputs = ~[];\n+    let mut inputs = Vec::new();\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n@@ -583,7 +583,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     let mut param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: ~[]\n+        trait_bounds: Vec::new()\n     };\n     loop {\n         match next(st) {"}, {"sha": "1477a1fb95131775b2b891c3b267350655d49f6c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -286,7 +286,7 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             enc_trait_store(w, cx, store);\n             enc_mutability(w, mt);\n             let bounds = ty::ParamBounds {builtin_bounds: bounds,\n-                                          trait_bounds: ~[]};\n+                                          trait_bounds: Vec::new()};\n             enc_bounds(w, cx, &bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -383,7 +383,7 @@ fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_onceness(w, ft.onceness);\n     enc_region(w, cx, ft.region);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n-                                  trait_bounds: ~[]};\n+                                  trait_bounds: Vec::new()};\n     enc_bounds(w, cx, &bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n }"}, {"sha": "b3d26b2bb7947b5d40abb27c618be57cc7d57539", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -116,9 +116,9 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           path: ~[ast_map::PathElem],\n+                           path: Vec<ast_map::PathElem> ,\n                            par_doc: ebml::Doc)\n-                           -> Result<ast::InlinedItem, ~[ast_map::PathElem]> {\n+                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem> > {\n     let dcx = @DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n@@ -395,7 +395,7 @@ impl ast_map::FoldOps for AstRenumberer {\n \n fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n                         map: &ast_map::Map,\n-                        path: ~[ast_map::PathElem],\n+                        path: Vec<ast_map::PathElem> ,\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n     ast_map::map_decoded_item(map,\n                               path.move_iter().collect(),\n@@ -1100,7 +1100,7 @@ impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n \n trait ebml_decoder_decoder_helpers {\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> ;\n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n                            -> ty::TypeParameterDef;\n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n@@ -1119,7 +1119,7 @@ trait ebml_decoder_decoder_helpers {\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n                       tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> ~[ty::t];\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t> ;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n@@ -1137,7 +1137,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> ~[ty::t] {\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n     }\n \n@@ -1169,7 +1169,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n+    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty(xcx) )\n     }\n \n@@ -1510,14 +1510,14 @@ fn test_simplification() {\n     let item = quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n-            return alist {eq_fn: eq_int, data: ~[]};\n+            return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n     let item_in = e::IIItemRef(item);\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::IIItem(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n-            return alist {eq_fn: eq_int, data: ~[]};\n+            return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());\n     match (item_out, item_exp) {"}, {"sha": "a44d4f55cd086a36ee09a375473d21aa9008827c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -143,11 +143,11 @@ impl<'a> CheckLoanCtxt<'a> {\n         })\n     }\n \n-    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n+    pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> Vec<uint> {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n-        let mut result = ~[];\n+        let mut result = Vec::new();\n         self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n             result.push(loan_index);\n             true"}, {"sha": "0583268b9e5e0fe7aa44623649cedd12a1d76bae", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -70,10 +70,9 @@ struct GatherLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n     id_range: IdRange,\n     move_data: move_data::MoveData,\n-    all_loans: @RefCell<~[Loan]>,\n+    all_loans: @RefCell<Vec<Loan> >,\n     item_ub: ast::NodeId,\n-    repeating_ids: ~[ast::NodeId]\n-}\n+    repeating_ids: Vec<ast::NodeId> }\n \n impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n@@ -103,13 +102,13 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n }\n \n pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n-                    -> (IdRange, @RefCell<~[Loan]>, move_data::MoveData) {\n+                    -> (IdRange, @RefCell<Vec<Loan> >, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         id_range: IdRange::max(),\n-        all_loans: @RefCell::new(~[]),\n+        all_loans: @RefCell::new(Vec::new()),\n         item_ub: body.id,\n-        repeating_ids: ~[body.id],\n+        repeating_ids: vec!(body.id),\n         move_data: MoveData::new()\n     };\n     glcx.gather_fn_arg_patterns(decl, body);"}, {"sha": "a21de25a76afd3d51db8443c1c4817eab87d66e2", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -21,7 +21,7 @@ use util::ppaux::Repr;\n \n pub enum RestrictionResult {\n     Safe,\n-    SafeIf(@LoanPath, ~[Restriction])\n+    SafeIf(@LoanPath, Vec<Restriction> )\n }\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n@@ -75,8 +75,8 @@ impl<'a> RestrictionsContext<'a> {\n             mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n                 let lp = @LpVar(local_id);\n-                SafeIf(lp, ~[Restriction {loan_path: lp,\n-                                          set: restrictions}])\n+                SafeIf(lp, vec!(Restriction {loan_path: lp,\n+                                          set: restrictions}))\n             }\n \n             mc::cat_downcast(cmt_base) => {"}, {"sha": "77c3af898945fc5eb91fe4e482719af8f11512f5", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -209,7 +209,7 @@ pub struct Loan {\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n     kind: ty::BorrowKind,\n-    restrictions: ~[Restriction],\n+    restrictions: Vec<Restriction> ,\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,"}, {"sha": "2cc312cccdc6fc754fde80135351839c640a9e21", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -32,23 +32,23 @@ use util::ppaux::Repr;\n \n pub struct MoveData {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n-    paths: RefCell<~[MovePath]>,\n+    paths: RefCell<Vec<MovePath> >,\n \n     /// Cache of loan path to move path index, for easy lookup.\n     path_map: RefCell<HashMap<@LoanPath, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n-    moves: RefCell<~[Move]>,\n+    moves: RefCell<Vec<Move> >,\n \n     /// Assignments to a variable, like `x = foo`. These are assigned\n     /// bits for dataflow, since we must track them to ensure that\n     /// immutable variables are assigned at most once along each path.\n-    var_assignments: RefCell<~[Assignment]>,\n+    var_assignments: RefCell<Vec<Assignment> >,\n \n     /// Assignments to a path, like `x.f = foo`. These are not\n     /// assigned dataflow bits, but we track them because they still\n     /// kill move bits.\n-    path_assignments: RefCell<~[Assignment]>,\n+    path_assignments: RefCell<Vec<Assignment> >,\n     assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n@@ -173,11 +173,11 @@ pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n impl MoveData {\n     pub fn new() -> MoveData {\n         MoveData {\n-            paths: RefCell::new(~[]),\n+            paths: RefCell::new(Vec::new()),\n             path_map: RefCell::new(HashMap::new()),\n-            moves: RefCell::new(~[]),\n-            path_assignments: RefCell::new(~[]),\n-            var_assignments: RefCell::new(~[]),\n+            moves: RefCell::new(Vec::new()),\n+            path_assignments: RefCell::new(Vec::new()),\n+            var_assignments: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(HashSet::new()),\n         }\n     }"}, {"sha": "5e22f35a47fab85e9a254d897c4528cf771cdbd9", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -22,7 +22,7 @@ struct CFGBuilder {\n     method_map: typeck::MethodMap,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n-    loop_scopes: ~[LoopScope],\n+    loop_scopes: Vec<LoopScope> ,\n }\n \n struct LoopScope {\n@@ -39,7 +39,7 @@ pub fn construct(tcx: ty::ctxt,\n         graph: graph::Graph::new(),\n         tcx: tcx,\n         method_map: method_map,\n-        loop_scopes: ~[]\n+        loop_scopes: Vec::new()\n     };\n     let entry = cfg_builder.add_node(0, []);\n     let exit = cfg_builder.block(blk, entry);\n@@ -375,7 +375,7 @@ impl CFGBuilder {\n \n             ast::ExprStruct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: ~[@ast::Expr] =\n+                let field_exprs: Vec<@ast::Expr> =\n                     fields.iter().map(|f| f.expr).collect();\n                 self.straightline(expr, base_exit, field_exprs)\n             }"}, {"sha": "218a4b0a71b78935a567ee512328a652c4d68afe", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -207,8 +207,7 @@ struct CheckItemRecursionVisitor<'a> {\n     sess: Session,\n     ast_map: &'a ast_map::Map,\n     def_map: resolve::DefMap,\n-    idstack: ~[NodeId]\n-}\n+    idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n@@ -222,7 +221,7 @@ pub fn check_item_recursion<'a>(sess: Session,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        idstack: ~[]\n+        idstack: Vec::new()\n     };\n     visitor.visit_item(it, ());\n }"}, {"sha": "5bc4cd878e1d3c45d4e999cc2df5caf6be70c595", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -105,7 +105,7 @@ fn check_expr(v: &mut CheckMatchVisitor,\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n \n-       let pats: ~[@Pat] = arms.iter()\n+       let pats: Vec<@Pat> = arms.iter()\n                                .filter_map(unguarded_pat)\n                                .flat_map(|pats| pats.move_iter())\n                                .collect();\n@@ -121,7 +121,7 @@ fn check_expr(v: &mut CheckMatchVisitor,\n \n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = ~[];\n+    let mut seen = Vec::new();\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n \n@@ -151,7 +151,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 true\n             });\n \n-            let v = ~[*pat];\n+            let v = vec!(*pat);\n             match is_useful(cx, &seen, v) {\n               not_useful => {\n                 cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n@@ -170,9 +170,9 @@ fn raw_pat(p: @Pat) -> @Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n     assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n+    let ext = match is_useful(cx, &pats.map(|p| vec!(*p)), [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -218,7 +218,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n     cx.tcx.sess.span_err(sp, msg);\n }\n \n-type matrix = ~[~[@Pat]];\n+type matrix = Vec<Vec<@Pat> > ;\n \n #[deriving(Clone)]\n enum useful {\n@@ -413,7 +413,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n-        let mut found = ~[];\n+        let mut found = Vec::new();\n         for r in m.iter() {\n             let r = pat_ctor_id(cx, r[0]);\n             for id in r.iter() {\n@@ -481,7 +481,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n                 }\n                 _ => None\n             }\n-        }).collect::<~[(uint, bool)]>();\n+        }).collect::<Vec<(uint, bool)> >();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n@@ -559,17 +559,17 @@ fn specialize(cx: &MatchCheckCtxt,\n                   ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n-               -> Option<~[@Pat]> {\n+               -> Option<Vec<@Pat> > {\n     // Sad, but I can't get rid of this easily\n     let r0 = (*raw_pat(r[0])).clone();\n     match r0 {\n         Pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n             PatWild => {\n-                Some(vec::append(vec::from_elem(arity, wild()), r.tail()))\n+                Some(vec_ng::append(vec::from_elem(arity, wild()), r.tail()))\n             }\n             PatWildMulti => {\n-                Some(vec::append(vec::from_elem(arity, wild_multi()), r.tail()))\n+                Some(vec_ng::append(vec::from_elem(arity, wild_multi()), r.tail()))\n             }\n             PatIdent(_, _, _) => {\n                 let opt_def = {\n@@ -624,7 +624,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     _ => {\n                         Some(\n-                            vec::append(\n+                            vec_ng::append(\n                                 vec::from_elem(arity, wild()),\n                                 r.tail()\n                             )\n@@ -678,7 +678,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                             Some(args) => args.iter().map(|x| *x).collect(),\n                             None => vec::from_elem(arity, wild())\n                         };\n-                        Some(vec::append(args, r.tail()))\n+                        Some(vec_ng::append(args, r.tail()))\n                     }\n                     DefVariant(_, _, _) => None,\n \n@@ -691,7 +691,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                             }\n                             None => new_args = vec::from_elem(arity, wild())\n                         }\n-                        Some(vec::append(new_args, r.tail()))\n+                        Some(vec_ng::append(new_args, r.tail()))\n                     }\n                     _ => None\n                 }\n@@ -712,7 +712,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                     _ => wild()\n                                 }\n                             });\n-                            Some(vec::append(args, r.tail()))\n+                            Some(vec_ng::append(args, r.tail()))\n                         } else {\n                             None\n                         }\n@@ -743,15 +743,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 _ => wild()\n                             }\n                         }).collect();\n-                        Some(vec::append(args, r.tail()))\n+                        Some(vec_ng::append(args, r.tail()))\n                     }\n                 }\n             }\n             PatTup(args) => {\n-                Some(vec::append(args.iter().map(|x| *x).collect(), r.tail()))\n+                Some(vec_ng::append(args.iter().map(|x| *x).collect(), r.tail()))\n             }\n             PatUniq(a) | PatRegion(a) => {\n-                Some(vec::append(~[a], r.tail()))\n+                Some(vec_ng::append(vec!(a), r.tail()))\n             }\n             PatLit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n@@ -812,7 +812,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n-                            let mut result = ~[];\n+                            let mut result = Vec::new();\n                             for pat in before.iter() {\n                                 result.push((*pat).clone());\n                             }\n@@ -827,7 +827,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                             }\n                             Some(result)\n                         } else if num_elements == arity {\n-                            let mut result = ~[];\n+                            let mut result = Vec::new();\n                             for pat in before.iter() {\n                                 result.push((*pat).clone());\n                             }\n@@ -849,7 +849,7 @@ fn specialize(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<~[@Pat]> {\n+fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n     if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n     else { None }\n }"}, {"sha": "9898be5532b51e9740b789f66cc2f3f87219d26f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -321,7 +321,7 @@ pub enum const_val {\n     const_int(i64),\n     const_uint(u64),\n     const_str(InternedString),\n-    const_binary(Rc<~[u8]>),\n+    const_binary(Rc<Vec<u8> >),\n     const_bool(bool)\n }\n "}, {"sha": "e0a9d0080f6a2e24ed666b1b6fc6eac6e500c76f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -54,15 +54,14 @@ pub struct DataFlowContext<O> {\n     // the full vector (see the method `compute_id_range()`).\n \n     /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n-    priv gens: ~[uint],\n+    priv gens: Vec<uint> ,\n \n     /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n-    priv kills: ~[uint],\n+    priv kills: Vec<uint> ,\n \n     /// bits that are valid on entry to the scope `id`. Updated by\n     /// `propagate()`.\n-    priv on_entry: ~[uint]\n-}\n+    priv on_entry: Vec<uint> }\n \n /// Parameterization for the precise form of data flow that is used.\n pub trait DataFlowOperator {\n@@ -80,8 +79,7 @@ struct PropagationContext<'a, O> {\n \n struct LoopScope<'a> {\n     loop_id: ast::NodeId,\n-    break_bits: ~[uint]\n-}\n+    break_bits: Vec<uint> }\n \n impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n     fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -131,9 +129,9 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n \n-        let gens = ~[];\n-        let kills = ~[];\n-        let on_entry = ~[];\n+        let gens = Vec::new();\n+        let kills = Vec::new();\n+        let on_entry = Vec::new();\n \n         DataFlowContext {\n             tcx: tcx,\n@@ -332,7 +330,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n             };\n \n             let mut temp = vec::from_elem(self.words_per_id, 0u);\n-            let mut loop_scopes = ~[];\n+            let mut loop_scopes = Vec::new();\n \n             while propcx.changed {\n                 propcx.changed = false;\n@@ -367,7 +365,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_block(&mut self,\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n-                  loop_scopes: &mut ~[LoopScope]) {\n+                  loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n                blk.id, bits_to_str(in_out));\n \n@@ -385,7 +383,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_stmt(&mut self,\n                  stmt: @ast::Stmt,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         match stmt.node {\n             ast::StmtDecl(decl, _) => {\n                 self.walk_decl(decl, in_out, loop_scopes);\n@@ -404,7 +402,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_decl(&mut self,\n                  decl: @ast::Decl,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         match decl.node {\n             ast::DeclLocal(local) => {\n                 self.walk_opt_expr(local.init, in_out, loop_scopes);\n@@ -418,7 +416,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_expr(&mut self,\n                  expr: &ast::Expr,\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n                expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n@@ -701,7 +699,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_exprs(&mut self,\n                   exprs: &[@ast::Expr],\n                   in_out: &mut [uint],\n-                  loop_scopes: &mut ~[LoopScope]) {\n+                  loop_scopes: &mut Vec<LoopScope> ) {\n         for &expr in exprs.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n@@ -710,7 +708,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_opt_expr(&mut self,\n                      opt_expr: Option<@ast::Expr>,\n                      in_out: &mut [uint],\n-                     loop_scopes: &mut ~[LoopScope]) {\n+                     loop_scopes: &mut Vec<LoopScope> ) {\n         for &expr in opt_expr.iter() {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n@@ -720,7 +718,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                  call_id: ast::NodeId,\n                  args: &[@ast::Expr],\n                  in_out: &mut [uint],\n-                 loop_scopes: &mut ~[LoopScope]) {\n+                 loop_scopes: &mut Vec<LoopScope> ) {\n         self.walk_exprs(args, in_out, loop_scopes);\n \n         // FIXME(#6268) nested method calls\n@@ -737,7 +735,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_pat(&mut self,\n                 pat: @ast::Pat,\n                 in_out: &mut [uint],\n-                _loop_scopes: &mut ~[LoopScope]) {\n+                _loop_scopes: &mut Vec<LoopScope> ) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n@@ -752,7 +750,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn walk_pat_alternatives(&mut self,\n                              pats: &[@ast::Pat],\n                              in_out: &mut [uint],\n-                             loop_scopes: &mut ~[LoopScope]) {\n+                             loop_scopes: &mut Vec<LoopScope> ) {\n         if pats.len() == 1 {\n             // Common special case:\n             return self.walk_pat(pats[0], in_out, loop_scopes);\n@@ -772,7 +770,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn find_scope<'a>(&self,\n                       expr: &ast::Expr,\n                       label: Option<ast::Ident>,\n-                      loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n+                      loop_scopes: &'a mut Vec<LoopScope> ) -> &'a mut LoopScope {\n         let index = match label {\n             None => {\n                 let len = loop_scopes.len();"}, {"sha": "4b4820be3a79aa8de533c318ef327f37401bc399", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -49,7 +49,7 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n struct MarkSymbolVisitor {\n-    worklist: ~[ast::NodeId],\n+    worklist: Vec<ast::NodeId> ,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n@@ -58,7 +58,7 @@ struct MarkSymbolVisitor {\n impl MarkSymbolVisitor {\n     fn new(tcx: ty::ctxt,\n            method_map: typeck::MethodMap,\n-           worklist: ~[ast::NodeId]) -> MarkSymbolVisitor {\n+           worklist: Vec<ast::NodeId> ) -> MarkSymbolVisitor {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             method_map: method_map,\n@@ -216,7 +216,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder {\n-    worklist: ~[ast::NodeId],\n+    worklist: Vec<ast::NodeId> ,\n }\n \n impl Visitor<()> for LifeSeeder {\n@@ -254,8 +254,8 @@ impl Visitor<()> for LifeSeeder {\n fn create_and_seed_worklist(tcx: ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &NodeSet,\n-                            krate: &ast::Crate) -> ~[ast::NodeId] {\n-    let mut worklist = ~[];\n+                            krate: &ast::Crate) -> Vec<ast::NodeId> {\n+    let mut worklist = Vec::new();\n \n     // Preferably, we would only need to seed the worklist with reachable\n     // symbols. However, since the set of reachable symbols differs"}, {"sha": "a2716893430f6baf268398c7961a636cd061e549", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -38,7 +38,7 @@ struct EntryContext<'a> {\n \n     // The functions that one might think are 'main' but aren't, e.g.\n     // main functions not defined at the top level. For diagnostics.\n-    non_main_fns: ~[(NodeId, Span)],\n+    non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n impl<'a> Visitor<()> for EntryContext<'a> {\n@@ -66,7 +66,7 @@ pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map)\n         main_fn: None,\n         attr_main_fn: None,\n         start_fn: None,\n-        non_main_fns: ~[],\n+        non_main_fns: Vec::new(),\n     };\n \n     visit::walk_crate(&mut ctxt, krate, ());"}, {"sha": "acafe550a704b8ef15a5ead7fa18109f5aed87f5", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -29,12 +29,12 @@ pub struct freevar_entry {\n     def: ast::Def, //< The variable being accessed free.\n     span: Span     //< First span where it is accessed (there can be multiple)\n }\n-pub type freevar_info = @~[@freevar_entry];\n+pub type freevar_info = @Vec<@freevar_entry> ;\n pub type freevar_map = NodeMap<freevar_info>;\n \n struct CollectFreevarsVisitor {\n     seen: NodeSet,\n-    refs: ~[@freevar_entry],\n+    refs: Vec<@freevar_entry> ,\n     def_map: resolve::DefMap,\n }\n \n@@ -90,7 +90,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n     let seen = NodeSet::new();\n-    let refs = ~[];\n+    let refs = Vec::new();\n \n     let mut v = CollectFreevarsVisitor {\n         seen: seen,"}, {"sha": "f2973a7b09c732fc9a6ce9ada4b439b3ba9efb1b", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -38,8 +38,8 @@ use std::uint;\n use std::vec;\n \n pub struct Graph<N,E> {\n-    priv nodes: ~[Node<N>],\n-    priv edges: ~[Edge<E>],\n+    priv nodes: Vec<Node<N>> ,\n+    priv edges: Vec<Edge<E>> ,\n }\n \n pub struct Node<N> {\n@@ -77,7 +77,7 @@ impl EdgeIndex {\n \n impl<N,E> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n-        Graph {nodes: ~[], edges: ~[]}\n+        Graph {nodes: Vec::new(), edges: Vec::new()}\n     }\n \n     pub fn with_capacity(num_nodes: uint,"}, {"sha": "392a95ee563ef85a94dc6e2e44cbc4922415a2b1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -94,7 +94,7 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n         let struct_ty = ty::mk_struct(cx.tcx, struct_did, ty::substs {\n             regions: ty::NonerasedRegions(opt_vec::Empty),\n             self_ty: None,\n-            tps: ~[]\n+            tps: Vec::new()\n         });\n         if !ty::type_is_sendable(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n@@ -533,7 +533,7 @@ pub fn check_cast_for_escaping_regions(\n     // Collect up the regions that appear in the target type.  We want to\n     // ensure that these lifetimes are shorter than all lifetimes that are in\n     // the source type.  See test `src/test/compile-fail/regions-trait-2.rs`\n-    let mut target_regions = ~[];\n+    let mut target_regions = Vec::new();\n     ty::walk_regions_and_ty(\n         cx.tcx,\n         target_ty,"}, {"sha": "2dde7003798b5a5217010aa26d4b8e2f1a35b030", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -47,15 +47,15 @@ pub enum LangItem {\n }\n \n pub struct LanguageItems {\n-    items: ~[Option<ast::DefId>],\n+    items: Vec<Option<ast::DefId>> ,\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         fn foo(_: LangItem) -> Option<ast::DefId> { None }\n \n         LanguageItems {\n-            items: ~[$(foo($variant)),*]\n+            items: vec!($(foo($variant)),*)\n         }\n     }\n "}, {"sha": "6b7f25ea21e75de9c010a7a1025f9ae17e66116d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -432,7 +432,7 @@ struct Context<'a> {\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n-    lint_stack: ~[(Lint, level, LintSource)],\n+    lint_stack: Vec<(Lint, level, LintSource)> ,\n \n     // id of the last visited negated expression\n     negated_expr_id: ast::NodeId\n@@ -1738,7 +1738,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         exported_items: exported_items,\n         cur_struct_def_id: -1,\n         is_doc_hidden: false,\n-        lint_stack: ~[],\n+        lint_stack: Vec::new(),\n         negated_expr_id: -1\n     };\n "}, {"sha": "df16a7fe2c7d3d6f3b3da3e9daa157d36c64e44d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -261,8 +261,8 @@ pub struct IrMaps {\n     live_node_map: RefCell<NodeMap<LiveNode>>,\n     variable_map: RefCell<NodeMap<Variable>>,\n     capture_info_map: RefCell<NodeMap<@~[CaptureInfo]>>,\n-    var_kinds: RefCell<~[VarKind]>,\n-    lnks: RefCell<~[LiveNodeKind]>,\n+    var_kinds: RefCell<Vec<VarKind> >,\n+    lnks: RefCell<Vec<LiveNodeKind> >,\n }\n \n fn IrMaps(tcx: ty::ctxt,\n@@ -278,8 +278,8 @@ fn IrMaps(tcx: ty::ctxt,\n         live_node_map: RefCell::new(NodeMap::new()),\n         variable_map: RefCell::new(NodeMap::new()),\n         capture_info_map: RefCell::new(NodeMap::new()),\n-        var_kinds: RefCell::new(~[]),\n-        lnks: RefCell::new(~[]),\n+        var_kinds: RefCell::new(Vec::new()),\n+        lnks: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -347,12 +347,12 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn set_captures(&self, node_id: NodeId, cs: ~[CaptureInfo]) {\n+    pub fn set_captures(&self, node_id: NodeId, cs: Vec<CaptureInfo> ) {\n         let mut capture_info_map = self.capture_info_map.borrow_mut();\n         capture_info_map.get().insert(node_id, @cs);\n     }\n \n-    pub fn captures(&self, expr: &Expr) -> @~[CaptureInfo] {\n+    pub fn captures(&self, expr: &Expr) -> @Vec<CaptureInfo> {\n         let capture_info_map = self.capture_info_map.borrow();\n         match capture_info_map.get().find(&expr.id) {\n           Some(&caps) => caps,\n@@ -504,7 +504,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n         // construction site.\n         let capture_map = this.capture_map.borrow();\n         let cvs = capture_map.get().get(&expr.id);\n-        let mut call_caps = ~[];\n+        let mut call_caps = Vec::new();\n         for cv in cvs.borrow().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n@@ -590,11 +590,11 @@ pub struct Liveness {\n     tcx: ty::ctxt,\n     ir: @IrMaps,\n     s: Specials,\n-    successors: @RefCell<~[LiveNode]>,\n-    users: @RefCell<~[Users]>,\n+    successors: @RefCell<Vec<LiveNode> >,\n+    users: @RefCell<Vec<Users> >,\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @RefCell<~[NodeId]>,\n+    loop_scope: @RefCell<Vec<NodeId> >,\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -612,7 +612,7 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n         users: @RefCell::new(vec::from_elem(ir.num_live_nodes.get() *\n                                             ir.num_vars.get(),\n                                             invalid_users())),\n-        loop_scope: @RefCell::new(~[]),\n+        loop_scope: @RefCell::new(Vec::new()),\n         break_ln: @RefCell::new(NodeMap::new()),\n         cont_ln: @RefCell::new(NodeMap::new()),\n     }"}, {"sha": "609a8d712c8a2f089f5f0c0684dd4892a7381a1d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -723,7 +723,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let opaque_ty = ty::mk_tup(self.tcx(), ~[]);\n+        let opaque_ty = ty::mk_tup(self.tcx(), Vec::new());\n         return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n     }\n "}, {"sha": "92b663ff8db0b96dcc04aba779a74252bb7b0efc", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -159,7 +159,7 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<NodeMap<Rc<~[CaptureVar]>>>;\n+pub type CaptureMap = @RefCell<NodeMap<Rc<Vec<CaptureVar> >>>;\n \n pub type MovesMap = @RefCell<NodeSet>;\n \n@@ -680,7 +680,7 @@ impl VisitContext {\n         self.consume_expr(arg_expr)\n     }\n \n-    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<~[CaptureVar]> {\n+    pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> Rc<Vec<CaptureVar> > {\n         debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n "}, {"sha": "36c6c19028444df0c33cb7b06dd707867e4ea24f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -88,8 +88,8 @@ pub fn pat_bindings(dm: resolve::DefMap,\n     });\n }\n \n-pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n-    let mut found = ~[];\n+pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> Vec<NodeId> {\n+    let mut found = Vec::new();\n     pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }"}, {"sha": "9deb51e412e8d0a2a30183ffbca8570f5b5adf9d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -92,11 +92,11 @@ struct ReachableContext {\n     reachable_symbols: @RefCell<NodeSet>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @RefCell<~[ast::NodeId]>,\n+    worklist: @RefCell<Vec<ast::NodeId> >,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @RefCell<~[ast::NodeId]>,\n+    worklist: @RefCell<Vec<ast::NodeId> >,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n     reachable_symbols: @RefCell<NodeSet>,\n@@ -190,7 +190,7 @@ impl ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n             reachable_symbols: @RefCell::new(NodeSet::new()),\n-            worklist: @RefCell::new(~[]),\n+            worklist: @RefCell::new(Vec::new()),\n         }\n     }\n "}, {"sha": "a575a8e3fcf57325a8ff0b2aa73158d6753b3db2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -77,7 +77,7 @@ The region maps encode information about region relationships.\n pub struct RegionMaps {\n     priv scope_map: RefCell<NodeMap<ast::NodeId>>,\n     priv var_map: RefCell<NodeMap<ast::NodeId>>,\n-    priv free_region_map: RefCell<HashMap<FreeRegion, ~[FreeRegion]>>,\n+    priv free_region_map: RefCell<HashMap<FreeRegion, Vec<FreeRegion> >>,\n     priv rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n     priv terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n@@ -113,7 +113,7 @@ impl RegionMaps {\n \n         debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n-        free_region_map.get().insert(sub, ~[sup]);\n+        free_region_map.get().insert(sub, vec!(sup));\n     }\n \n     pub fn record_encl_scope(&self, sub: ast::NodeId, sup: ast::NodeId) {\n@@ -283,7 +283,7 @@ impl RegionMaps {\n         // doubles as a way to detect if we've seen a particular FR\n         // before.  Note that we expect this graph to be an *extremely\n         // shallow* tree.\n-        let mut queue = ~[sub];\n+        let mut queue = vec!(sub);\n         let mut i = 0;\n         while i < queue.len() {\n             let free_region_map = self.free_region_map.borrow();\n@@ -386,10 +386,9 @@ impl RegionMaps {\n         }\n \n         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n-            -> ~[ast::NodeId]\n-        {\n+            -> Vec<ast::NodeId> {\n             // debug!(\"ancestors_of(scope={})\", scope);\n-            let mut result = ~[scope];\n+            let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n                 let scope_map = this.scope_map.borrow();"}, {"sha": "f75b45f2b21dbc91dc156e01f16270965ff8cad4", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -48,11 +48,11 @@ struct binding_info {\n type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = NodeMap<~[DefId]>;\n+pub type TraitMap = NodeMap<Vec<DefId> >;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @RefCell<NodeMap<~[Export2]>>;\n+pub type ExportMap2 = @RefCell<NodeMap<Vec<Export2> >>;\n \n pub struct Export2 {\n     name: ~str,        // The name of the target.\n@@ -319,15 +319,15 @@ impl Rib {\n \n /// One import directive.\n struct ImportDirective {\n-    module_path: ~[Ident],\n+    module_path: Vec<Ident> ,\n     subclass: @ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolution about how to use this\n }\n \n impl ImportDirective {\n-    fn new(module_path: ~[Ident],\n+    fn new(module_path: Vec<Ident> ,\n            subclass: @ImportDirectiveSubclass,\n            span: Span,\n            id: NodeId,\n@@ -438,7 +438,7 @@ struct Module {\n     is_public: bool,\n \n     children: RefCell<HashMap<Name, @NameBindings>>,\n-    imports: RefCell<~[@ImportDirective]>,\n+    imports: RefCell<Vec<@ImportDirective> >,\n \n     // The external module children of this node that were declared with\n     // `extern crate`.\n@@ -488,7 +488,7 @@ impl Module {\n             kind: Cell::new(kind),\n             is_public: is_public,\n             children: RefCell::new(HashMap::new()),\n-            imports: RefCell::new(~[]),\n+            imports: RefCell::new(Vec::new()),\n             external_module_children: RefCell::new(HashMap::new()),\n             anonymous_children: RefCell::new(NodeMap::new()),\n             import_resolutions: RefCell::new(HashMap::new()),\n@@ -815,9 +815,9 @@ fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @RefCell::new(~[]),\n-        type_ribs: @RefCell::new(~[]),\n-        label_ribs: @RefCell::new(~[]),\n+        value_ribs: @RefCell::new(Vec::new()),\n+        type_ribs: @RefCell::new(Vec::new()),\n+        label_ribs: @RefCell::new(Vec::new()),\n \n         current_trait_refs: None,\n \n@@ -826,7 +826,7 @@ fn Resolver(session: Session,\n \n         primitive_type_table: @PrimitiveTypeTable(),\n \n-        namespaces: ~[ TypeNS, ValueNS ],\n+        namespaces: Vec<TypeNS, ValueNS > ,\n \n         def_map: @RefCell::new(NodeMap::new()),\n         export_map2: @RefCell::new(NodeMap::new()),\n@@ -859,16 +859,16 @@ struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @RefCell<~[@Rib]>,\n+    value_ribs: @RefCell<Vec<@Rib> >,\n \n     // The current set of local scopes, for types.\n-    type_ribs: @RefCell<~[@Rib]>,\n+    type_ribs: @RefCell<Vec<@Rib> >,\n \n     // The current set of local scopes, for labels.\n-    label_ribs: @RefCell<~[@Rib]>,\n+    label_ribs: @RefCell<Vec<@Rib> >,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<~[DefId]>,\n+    current_trait_refs: Option<Vec<DefId> >,\n \n     // The ident for the keyword \"self\".\n     self_ident: Ident,\n@@ -879,7 +879,7 @@ struct Resolver {\n     primitive_type_table: @PrimitiveTypeTable,\n \n     // The four namespaces.\n-    namespaces: ~[Namespace],\n+    namespaces: Vec<Namespace> ,\n \n     def_map: DefMap,\n     export_map2: ExportMap2,\n@@ -1452,7 +1452,7 @@ impl Resolver {\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n-                    let mut module_path = ~[];\n+                    let mut module_path = Vec::new();\n                     match view_path.node {\n                         ViewPathSimple(_, ref full_path, _) => {\n                             let path_len = full_path.segments.len();\n@@ -1951,7 +1951,7 @@ impl Resolver {\n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n                               module_: @Module,\n-                              module_path: ~[Ident],\n+                              module_path: Vec<Ident> ,\n                               subclass: @ImportDirectiveSubclass,\n                               span: Span,\n                               id: NodeId,\n@@ -2124,7 +2124,7 @@ impl Resolver {\n     }\n \n     fn path_idents_to_str(&mut self, path: &Path) -> ~str {\n-        let identifiers: ~[ast::Ident] = path.segments\n+        let identifiers: Vec<ast::Ident> = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n@@ -3374,7 +3374,7 @@ impl Resolver {\n     }\n \n     fn record_exports_for_module(&mut self, module_: @Module) {\n-        let mut exports2 = ~[];\n+        let mut exports2 = Vec::new();\n \n         self.add_exports_for_module(&mut exports2, module_);\n         match module_.def_id.get() {\n@@ -3389,7 +3389,7 @@ impl Resolver {\n     }\n \n     fn add_exports_of_namebindings(&mut self,\n-                                   exports2: &mut ~[Export2],\n+                                   exports2: &mut Vec<Export2> ,\n                                    name: Name,\n                                    namebindings: @NameBindings,\n                                    ns: Namespace) {\n@@ -3410,7 +3410,7 @@ impl Resolver {\n     }\n \n     fn add_exports_for_module(&mut self,\n-                              exports2: &mut ~[Export2],\n+                              exports2: &mut Vec<Export2> ,\n                               module_: @Module) {\n         let import_resolutions = module_.import_resolutions.borrow();\n         for (name, importresolution) in import_resolutions.get().iter() {\n@@ -3495,7 +3495,7 @@ impl Resolver {\n     /// Wraps the given definition in the appropriate number of `def_upvar`\n     /// wrappers.\n     fn upvarify(&mut self,\n-                    ribs: &mut ~[@Rib],\n+                    ribs: &mut Vec<@Rib> ,\n                     rib_index: uint,\n                     def_like: DefLike,\n                     span: Span)\n@@ -3610,7 +3610,7 @@ impl Resolver {\n     }\n \n     fn search_ribs(&mut self,\n-                       ribs: &mut ~[@Rib],\n+                       ribs: &mut Vec<@Rib> ,\n                        name: Name,\n                        span: Span)\n                        -> Option<DefLike> {\n@@ -4095,7 +4095,7 @@ impl Resolver {\n                         TraitImplementation);\n \n                     // Record the current set of trait references.\n-                    let mut new_trait_refs = ~[];\n+                    let mut new_trait_refs = Vec::new();\n                     {\n                         let def_map = this.def_map.borrow();\n                         let r = def_map.get().find(&trait_reference.ref_id);\n@@ -5054,8 +5054,8 @@ impl Resolver {\n                                 -> Option<~str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[token::InternedString] = ~[];\n-        let mut values: ~[uint] = ~[];\n+        let mut maybes: Vec<token::InternedString> = Vec::new();\n+        let mut values: Vec<uint> = Vec::new();\n \n         let mut j = {\n             let value_ribs = this.value_ribs.borrow();\n@@ -5274,11 +5274,11 @@ impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Ident) -> ~[DefId] {\n+    fn search_for_traits_containing_method(&mut self, name: Ident) -> Vec<DefId> {\n         debug!(\"(searching for traits containing method) looking for '{}'\",\n                token::get_ident(name));\n \n-        let mut found_traits = ~[];\n+        let mut found_traits = Vec::new();\n         let mut search_module = self.current_module;\n         let method_map = self.method_map.borrow();\n         match method_map.get().find(&name.name) {\n@@ -5350,7 +5350,7 @@ impl Resolver {\n     }\n \n     fn add_trait_info(&self,\n-                          found_traits: &mut ~[DefId],\n+                          found_traits: &mut Vec<DefId> ,\n                           trait_def_id: DefId,\n                           name: Ident) {\n         debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n@@ -5495,7 +5495,7 @@ impl Resolver {\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(&mut self, module_: @Module) -> ~str {\n-        let mut idents = ~[];\n+        let mut idents = Vec::new();\n         let mut current_module = module_;\n         loop {\n             match current_module.parent_link {\n@@ -5516,7 +5516,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n+        return self.idents_to_str(idents.move_rev_iter().collect::<Vec<ast::Ident> >());\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "f19d168a729be34f0d1c58f7135f4cb9dff06898", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -130,10 +130,10 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n ///////////////////////////////////////////////////////////////////////////\n // Other types\n \n-impl<T:Subst> Subst for ~[T] {\n+impl<T:Subst> Subst for Vec<T> {\n     fn subst_spanned(&self, tcx: ty::ctxt,\n                      substs: &ty::substs,\n-                     span: Option<Span>) -> ~[T] {\n+                     span: Option<Span>) -> Vec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }"}, {"sha": "93040a36c0e2405d7f8a7e55d591acc748692893", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -421,10 +421,9 @@ impl<'a,'b> Clone for ArmData<'a, 'b> {\n  */\n #[deriving(Clone)]\n struct Match<'a,'b> {\n-    pats: ~[@ast::Pat],\n+    pats: Vec<@ast::Pat> ,\n     data: ArmData<'a,'b>,\n-    bound_ptrs: ~[(Ident, ValueRef)]\n-}\n+    bound_ptrs: Vec<(Ident, ValueRef)> }\n \n impl<'a,'b> Repr for Match<'a,'b> {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n@@ -452,7 +451,7 @@ fn expand_nested_bindings<'r,'b>(\n                           m: &[Match<'r,'b>],\n                           col: uint,\n                           val: ValueRef)\n-                          -> ~[Match<'r,'b>] {\n+                          -> vec!(Match<'r,'b>) {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -463,9 +462,9 @@ fn expand_nested_bindings<'r,'b>(\n     m.map(|br| {\n         match br.pats[col].node {\n             ast::PatIdent(_, ref path, Some(inner)) => {\n-                let pats = vec::append(\n+                let pats = vec_ng::append(\n                     br.pats.slice(0u, col).to_owned(),\n-                    vec::append(~[inner],\n+                    vec_ng::append(vec!(inner),\n                                 br.pats.slice(col + 1u,\n                                            br.pats.len())));\n \n@@ -491,7 +490,7 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n+type enter_pat<'a> = 'a |@ast::Pat| -> Option<Vec<@ast::Pat> >;\n \n fn enter_match<'r,'b>(\n                bcx: &'b Block<'b>,\n@@ -500,21 +499,21 @@ fn enter_match<'r,'b>(\n                col: uint,\n                val: ValueRef,\n                e: enter_pat)\n-               -> ~[Match<'r,'b>] {\n+               -> vec!(Match<'r,'b>) {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let mut result = ~[];\n+    let mut result = Vec::new();\n     for br in m.iter() {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n-                    vec::append(\n-                        vec::append(sub, br.pats.slice(0u, col)),\n+                    vec_ng::append(\n+                        vec_ng::append(sub, br.pats.slice(0u, col)),\n                         br.pats.slice(col + 1u, br.pats.len()));\n \n                 let this = br.pats[col];\n@@ -550,7 +549,7 @@ fn enter_default<'r,'b>(\n                  col: uint,\n                  val: ValueRef,\n                  chk: &FailureHandler)\n-                 -> ~[Match<'r,'b>] {\n+                 -> vec!(Match<'r,'b>) {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -561,8 +560,8 @@ fn enter_default<'r,'b>(\n     // Collect all of the matches that can match against anything.\n     let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n-          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(~[]),\n-          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n+          ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(Vec::new()),\n+          ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(Vec::new()),\n           _ => None\n         }\n     });\n@@ -587,7 +586,7 @@ fn enter_default<'r,'b>(\n         _ => false\n     };\n \n-    if is_exhaustive { ~[] } else { matches }\n+    if is_exhaustive { Vec::new() } else { matches }\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -621,7 +620,7 @@ fn enter_opt<'r,'b>(\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> ~[Match<'r,'b>] {\n+             -> vec!(Match<'r,'b>) {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -643,7 +642,7 @@ fn enter_opt<'r,'b>(\n                 };\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n-                    Some(~[])\n+                    Some(Vec::new())\n                 } else {\n                     None\n                 }\n@@ -664,16 +663,16 @@ fn enter_opt<'r,'b>(\n             ast::PatIdent(_, _, None)\n                     if pat_is_variant_or_struct(tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n-                    Some(~[])\n+                    Some(Vec::new())\n                 } else {\n                     None\n                 }\n             }\n             ast::PatLit(l) => {\n-                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(~[])} else {None}\n+                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(Vec::new())} else {None}\n             }\n             ast::PatRange(l1, l2) => {\n-                if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n+                if opt_eq(tcx, &range(l1, l2), opt) {Some(Vec::new())} else {None}\n             }\n             ast::PatStruct(_, ref field_pats, _) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n@@ -695,7 +694,7 @@ fn enter_opt<'r,'b>(\n                     // Reorder the patterns into the same order they were\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n-                    let mut reordered_patterns = ~[];\n+                    let mut reordered_patterns = Vec::new();\n                     let r = ty::lookup_struct_fields(tcx, struct_id);\n                     for field in r.iter() {\n                             match field_pats.iter().find(|p| p.ident.name\n@@ -722,7 +721,7 @@ fn enter_opt<'r,'b>(\n                         let this_opt = vec_len(n, vec_len_ge(before.len()),\n                                                (lo, hi));\n                         if opt_eq(tcx, &this_opt, opt) {\n-                            let mut new_before = ~[];\n+                            let mut new_before = Vec::new();\n                             for pat in before.iter() {\n                                 new_before.push(*pat);\n                             }\n@@ -738,7 +737,7 @@ fn enter_opt<'r,'b>(\n                     None if i >= lo && i <= hi => {\n                         let n = before.len();\n                         if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n-                            let mut new_before = ~[];\n+                            let mut new_before = Vec::new();\n                             for pat in before.iter() {\n                                 new_before.push(*pat);\n                             }\n@@ -778,7 +777,7 @@ fn enter_rec_or_struct<'r,'b>(\n                        col: uint,\n                        fields: &[ast::Ident],\n                        val: ValueRef)\n-                       -> ~[Match<'r,'b>] {\n+                       -> vec!(Match<'r,'b>) {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -790,7 +789,7 @@ fn enter_rec_or_struct<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n-                let mut pats = ~[];\n+                let mut pats = Vec::new();\n                 for fname in fields.iter() {\n                     match fpats.iter().find(|p| p.ident.name == fname.name) {\n                         None => pats.push(dummy),\n@@ -814,7 +813,7 @@ fn enter_tup<'r,'b>(\n              col: uint,\n              val: ValueRef,\n              n_elts: uint)\n-             -> ~[Match<'r,'b>] {\n+             -> vec!(Match<'r,'b>) {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -826,7 +825,7 @@ fn enter_tup<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => {\n-                let mut new_elts = ~[];\n+                let mut new_elts = Vec::new();\n                 for elt in elts.iter() {\n                     new_elts.push((*elt).clone())\n                 }\n@@ -847,7 +846,7 @@ fn enter_tuple_struct<'r,'b>(\n                       col: uint,\n                       val: ValueRef,\n                       n_elts: uint)\n-                      -> ~[Match<'r,'b>] {\n+                      -> vec!(Match<'r,'b>) {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -875,7 +874,7 @@ fn enter_uniq<'r,'b>(\n               m: &[Match<'r,'b>],\n               col: uint,\n               val: ValueRef)\n-              -> ~[Match<'r,'b>] {\n+              -> vec!(Match<'r,'b>) {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -887,11 +886,11 @@ fn enter_uniq<'r,'b>(\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatUniq(sub) => {\n-                Some(~[sub])\n+                Some(vec!(sub))\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(~[dummy])\n+                Some(vec!(dummy))\n             }\n         }\n     })\n@@ -904,7 +903,7 @@ fn enter_region<'r,\n                 m: &[Match<'r,'b>],\n                 col: uint,\n                 val: ValueRef)\n-                -> ~[Match<'r,'b>] {\n+                -> vec!(Match<'r,'b>) {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -916,11 +915,11 @@ fn enter_region<'r,\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n-                Some(~[sub])\n+                Some(vec!(sub))\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(~[dummy])\n+                Some(vec!(dummy))\n             }\n         }\n     })\n@@ -929,17 +928,17 @@ fn enter_region<'r,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut Vec<Opt> , val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n     // Vector comparisions are special in that since the actual\n     // conditions over-match, we need to be careful about them. This\n     // means that in order to properly handle things in order, we need\n     // to not always merge conditions.\n-    fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n+    fn add_veclen_to_set(set: &mut Vec<Opt> , i: uint,\n                          len: uint, vlo: VecLenOpt) {\n         match set.last() {\n             // If the last condition in the list matches the one we want\n@@ -952,7 +951,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n         }\n     }\n \n-    let mut found = ~[];\n+    let mut found = Vec::new();\n     for (i, br) in m.iter().enumerate() {\n         let cur = br.pats[col];\n         match cur.node {\n@@ -1020,7 +1019,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n }\n \n struct ExtractedBlock<'a> {\n-    vals: ~[ValueRef],\n+    vals: Vec<ValueRef> ,\n     bcx: &'a Block<'a>,\n }\n \n@@ -1108,8 +1107,8 @@ fn collect_record_or_struct_fields<'a>(\n                                    bcx: &'a Block<'a>,\n                                    m: &[Match],\n                                    col: uint)\n-                                   -> Option<~[ast::Ident]> {\n-    let mut fields: ~[ast::Ident] = ~[];\n+                                   -> Option<Vec<ast::Ident> > {\n+    let mut fields: Vec<ast::Ident> = Vec::new();\n     let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n@@ -1131,7 +1130,7 @@ fn collect_record_or_struct_fields<'a>(\n         return None;\n     }\n \n-    fn extend(idents: &mut ~[ast::Ident], field_pats: &[ast::FieldPat]) {\n+    fn extend(idents: &mut Vec<ast::Ident> , field_pats: &[ast::FieldPat]) {\n         for field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| x.name == field_ident.name) {\n@@ -1530,7 +1529,7 @@ fn compile_submatch_continue<'r,\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n \n-    let vals_left = vec::append(vals.slice(0u, col).to_owned(),\n+    let vals_left = vec_ng::append(vals.slice(0u, col).to_owned(),\n                                 vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n@@ -1558,7 +1557,7 @@ fn compile_submatch_continue<'r,\n                 compile_submatch(\n                         bcx,\n                         enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n-                        vec::append(rec_vals, vals_left),\n+                        vec_ng::append(rec_vals, vals_left),\n                         chk);\n             });\n             return;\n@@ -1577,7 +1576,7 @@ fn compile_submatch_continue<'r,\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n         });\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n-                         vec::append(tup_vals, vals_left), chk);\n+                         vec_ng::append(tup_vals, vals_left), chk);\n         return;\n     }\n \n@@ -1601,22 +1600,22 @@ fn compile_submatch_continue<'r,\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count),\n-                         vec::append(llstructvals, vals_left),\n+                         vec_ng::append(llstructvals, vals_left),\n                          chk);\n         return;\n     }\n \n     if any_uniq_pat(m, col) {\n         let llbox = Load(bcx, val);\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n-                         vec::append(~[llbox], vals_left), chk);\n+                         vec_ng::append(vec!(llbox), vals_left), chk);\n         return;\n     }\n \n     if any_region_pat(m, col) {\n         let loaded_val = Load(bcx, val);\n         compile_submatch(bcx, enter_region(bcx, dm, m, col, val),\n-                         vec::append(~[loaded_val], vals_left), chk);\n+                         vec_ng::append(vec!(loaded_val), vals_left), chk);\n         return;\n     }\n \n@@ -1773,7 +1772,7 @@ fn compile_submatch_continue<'r,\n         }\n \n         let mut size = 0u;\n-        let mut unpacked = ~[];\n+        let mut unpacked = Vec::new();\n         match *opt {\n             var(disr_val, repr) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n@@ -1796,7 +1795,7 @@ fn compile_submatch_continue<'r,\n             lit(_) | range(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n-        let opt_vals = vec::append(unpacked, vals_left);\n+        let opt_vals = vec_ng::append(unpacked, vals_left);\n \n         match branch_chk {\n             None => compile_submatch(opt_cx, opt_ms, opt_vals, chk),\n@@ -1884,8 +1883,8 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         return bcx;\n     }\n \n-    let mut arm_datas = ~[];\n-    let mut matches = ~[];\n+    let mut arm_datas = Vec::new();\n+    let mut matches = Vec::new();\n     for arm in arms.iter() {\n         let body = fcx.new_id_block(\"case_body\", arm.body.id);\n         let bindings_map = create_bindings_map(bcx, *arm.pats.get(0));\n@@ -1897,9 +1896,9 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         arm_datas.push(arm_data.clone());\n         for p in arm.pats.iter() {\n             matches.push(Match {\n-                pats: ~[*p],\n+                pats: vec!(*p),\n                 data: arm_data.clone(),\n-                bound_ptrs: ~[],\n+                bound_ptrs: Vec::new(),\n             });\n         }\n     }\n@@ -1924,7 +1923,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     let lldiscr = discr_datum.val;\n     compile_submatch(bcx, matches, [lldiscr], &chk);\n \n-    let mut arm_cxs = ~[];\n+    let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n "}, {"sha": "c41783cc29496e17f20d5aff91c64496ccc359d9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -83,7 +83,7 @@ pub enum Repr {\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n      */\n-    General(IntType, ~[Struct]),\n+    General(IntType, Vec<Struct> ),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` is represented by the struct `nonnull`, where the `ptrfield`th\n@@ -96,16 +96,15 @@ pub enum Repr {\n      * identity function.\n      */\n     NullablePointer{ nonnull: Struct, nndiscr: Disr, ptrfield: uint,\n-                     nullfields: ~[ty::t] }\n+                     nullfields: Vec<ty::t> }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n pub struct Struct {\n     size: u64,\n     align: u64,\n     packed: bool,\n-    fields: ~[ty::t]\n-}\n+    fields: Vec<ty::t> }\n \n /**\n  * Convenience for `represent_type`.  There should probably be more or\n@@ -217,7 +216,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n-            let discr = ~[ty_of_inttype(ity)];\n+            let discr = vec!(ty_of_inttype(ity));\n             return General(ity, cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n@@ -254,7 +253,7 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n }\n \n // this should probably all be in ty\n-struct Case { discr: Disr, tys: ~[ty::t] }\n+struct Case { discr: Disr, tys: Vec<ty::t> }\n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys, false).size == 0\n@@ -264,7 +263,7 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n+fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n     ty::enum_variants(tcx, def_id).map(|vi| {\n         let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n@@ -438,9 +437,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             };\n             assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n             assert_eq!(align % discr_size, 0);\n-            let fields = ~[discr_ty,\n+            let fields = vec!(discr_ty,\n                            Type::array(&discr_ty, align / discr_size - 1),\n-                           pad_ty];\n+                           pad_ty);\n             match name {\n                 None => Type::struct_(fields, false),\n                 Some(name) => {\n@@ -453,7 +452,7 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -741,7 +740,7 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             let case = &cases[discr];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-            let contents = build_const_struct(ccx, case, ~[lldiscr] + vals);\n+            let contents = build_const_struct(ccx, case, vec!(lldiscr) + vals);\n             C_struct(contents + &[padding(max_sz - case.size)], false)\n         }\n         Univariant(ref st, _dro) => {\n@@ -757,7 +756,7 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n-                });\n+                }).collect::<Vec<ValueRef> >();\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             }\n         }\n@@ -775,11 +774,11 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n  * will read the wrong memory.\n  */\n fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n-    -> ~[ValueRef] {\n+    -> Vec<ValueRef> {\n     assert_eq!(vals.len(), st.fields.len());\n \n     let mut offset = 0;\n-    let mut cfields = ~[];\n+    let mut cfields = Vec::new();\n     for (i, &ty) in st.fields.iter().enumerate() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = machine::llalign_of_min(ccx, llty)"}, {"sha": "83d5420d5d33f2559148660f922f94fdc0953286", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -32,8 +32,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                         -> &'a Block<'a> {\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let mut constraints = ~[];\n-    let mut output_types = ~[];\n+    let mut constraints = Vec::new();\n+    let mut output_types = Vec::new();\n \n     let temp_scope = fcx.push_custom_cleanup_scope();\n "}, {"sha": "f4540a07794a55b7f6f690d32a5f1119b6540777", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -94,7 +94,7 @@ use time;\n \n pub use middle::trans::context::task_llcx;\n \n-local_data_key!(task_local_insn_key: ~[&'static str])\n+local_data_key!(task_local_insn_key: Vec<&'static str> )\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n     local_data::get(task_local_insn_key, |c| {\n@@ -106,7 +106,7 @@ pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n }\n \n pub fn init_insn_ctxt() {\n-    local_data::set(task_local_insn_key, ~[]);\n+    local_data::set(task_local_insn_key, Vec::new());\n }\n \n pub struct _InsnCtxt { _x: () }\n@@ -902,7 +902,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n pub fn invoke<'a>(\n               bcx: &'a Block<'a>,\n               llfn: ValueRef,\n-              llargs: ~[ValueRef],\n+              llargs: Vec<ValueRef> ,\n               attributes: &[(uint, lib::llvm::Attribute)],\n               call_info: Option<NodeInfo>)\n               -> (ValueRef, &'a Block<'a>) {\n@@ -1255,7 +1255,7 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n           block_arena: block_arena,\n           ccx: ccx,\n           debug_context: debug_context,\n-          scopes: RefCell::new(~[])\n+          scopes: RefCell::new(Vec::new())\n     };\n \n     if has_env {\n@@ -1331,7 +1331,7 @@ pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n // appropriate lvalue datums.\n pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n                                  arg_tys: &[ty::t])\n-                                 -> ~[RvalueDatum] {\n+                                 -> Vec<RvalueDatum> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n     // Return an array wrapping the ValueRefs that we get from\n@@ -1348,7 +1348,7 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             arg_scope: cleanup::CustomScopeIndex,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            arg_datums: ~[RvalueDatum])\n+                            arg_datums: Vec<RvalueDatum> )\n                             -> &'a Block<'a> {\n     debug!(\"copy_args_to_allocas\");\n \n@@ -1633,7 +1633,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n }\n \n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n-                      id: ast::NodeId, vi: @~[@ty::VariantInfo],\n+                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo> ,\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n@@ -1876,19 +1876,19 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n                     });\n \n-                    ~[\n+                    vec!(\n                         opaque_rust_main,\n                         llvm::LLVMGetParam(llfn, 0),\n                         llvm::LLVMGetParam(llfn, 1)\n-                     ]\n+                     )\n                 };\n                 (start_fn, args)\n             } else {\n                 debug!(\"using user-defined start fn\");\n-                let args = ~[\n+                let args = vec!(\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n                     llvm::LLVMGetParam(llfn, 1 as c_uint)\n-                ];\n+                );\n \n                 (rust_main, args)\n             };\n@@ -2450,13 +2450,13 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    let mut elts: ~[ValueRef] = ~[];\n+    let mut elts: Vec<ValueRef> = Vec::new();\n \n     // This is not ideal, but the borrow checker doesn't\n     // like the multiple borrows. At least, it doesn't\n     // like them on the current snapshot. (2013-06-14)\n     let keys = {\n-        let mut keys = ~[];\n+        let mut keys = Vec::new();\n         let module_data = ccx.module_data.borrow();\n         for (k, _) in module_data.get().iter() {\n             keys.push(k.clone());\n@@ -2526,7 +2526,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n }\n \n pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n-    let mut subcrates: ~[ValueRef] = ~[];\n+    let mut subcrates: Vec<ValueRef> = Vec::new();\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n     while cstore.have_crate_data(i) {\n@@ -2600,11 +2600,11 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeI\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> ~[u8] {\n+pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n     if !cx.sess.building_library.get() {\n-        return ~[]\n+        return Vec::new()\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem ="}, {"sha": "74a6edf95e3f5441a993f5c0aedcbcb3d461642b", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -540,7 +540,7 @@ impl<'a> Builder<'a> {\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<~[ValueRef]>();\n+            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<Vec<ValueRef> >();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v)\n         }"}, {"sha": "df916d5800b4fe8db148df58af73ba1d2da5164e", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -83,7 +83,7 @@ impl ArgType {\n /// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n     /// The LLVM types of each argument.\n-    arg_tys: ~[ArgType],\n+    arg_tys: Vec<ArgType> ,\n \n     /// LLVM return type.\n     ret_ty: ArgType,"}, {"sha": "5ae642a24047c138875854cd5efed79c4bfc370a", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -131,7 +131,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     for &aty in atys.iter() {\n         let ty = classify_arg_ty(aty);\n         arg_tys.push(ty);"}, {"sha": "1cc562c8f714898dab3e65628725957927624ff3", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -132,9 +132,9 @@ fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n     return None;\n }\n \n-fn coerce_to_int(size: uint) -> ~[Type] {\n+fn coerce_to_int(size: uint) -> Vec<Type> {\n     let int_ty = Type::i32();\n-    let mut args = ~[];\n+    let mut args = Vec::new();\n \n     let mut n = size / 32;\n     while n > 0 {\n@@ -169,7 +169,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n     };\n \n     let sret = ret_ty.is_indirect();\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n     for aty in atys.iter() {"}, {"sha": "27501e370b5867487fdc59daef65d84fb3ac7c84", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -20,7 +20,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n \n     let ret_ty;\n     if !ret_def {"}, {"sha": "aaa32c2f4c096c84f8f47f857bcd1070af67e0cf", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -84,7 +84,7 @@ impl<'a> ClassList for &'a [RegClass] {\n     }\n }\n \n-fn classify_ty(ty: Type) -> ~[RegClass] {\n+fn classify_ty(ty: Type) -> Vec<RegClass> {\n     fn align(off: uint, ty: Type) -> uint {\n         let a = ty_align(ty);\n         return (off + a - 1u) / a * a;\n@@ -304,7 +304,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         return len;\n     }\n \n-    let mut tys = ~[];\n+    let mut tys = Vec::new();\n     let mut i = 0u;\n     let e = cls.len();\n     while i < e {\n@@ -352,7 +352,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n         }\n     }\n \n-    let mut arg_tys = ~[];\n+    let mut arg_tys = Vec::new();\n     for t in atys.iter() {\n         let ty = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);"}, {"sha": "97b2c0299b23d5a2809a8fca2af6554adf1fe7db", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -218,7 +218,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n                 vtables.len() - num_method_vtables;\n             vtables.tailn(num_impl_type_parameters).to_owned()\n         },\n-        None => vec::from_elem(num_method_vtables, @~[])\n+        None => vec::from_elem(num_method_vtables, @Vec::new())\n     };\n \n     let param_vtables = @(*trait_vtables_fixed + method_vtables);\n@@ -640,7 +640,7 @@ pub fn trans_call_inner<'a>(\n     // written in opt_llretslot (if it is Some) or `llresult` will be\n     // set appropriately (otherwise).\n     if is_rust_fn {\n-        let mut llargs = ~[];\n+        let mut llargs = Vec::new();\n \n         // Push the out-pointer if we use an out-pointer for this\n         // return type, otherwise push \"undef\".\n@@ -666,7 +666,7 @@ pub fn trans_call_inner<'a>(\n         // available, so we have to apply any attributes with ABI\n         // implications directly to the call instruction. Right now,\n         // the only attribute we need to worry about is `sret`.\n-        let mut attrs = ~[];\n+        let mut attrs = Vec::new();\n         if type_of::return_uses_outptr(ccx, ret_ty) {\n             attrs.push((1, StructRetAttribute));\n         }\n@@ -704,7 +704,7 @@ pub fn trans_call_inner<'a>(\n         // they are always Rust fns.\n         assert!(dest.is_some());\n \n-        let mut llargs = ~[];\n+        let mut llargs = Vec::new();\n         bcx = trans_args(bcx, args, callee_ty, &mut llargs,\n                          cleanup::CustomScope(arg_cleanup_scope), false);\n         fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n@@ -746,7 +746,7 @@ pub enum CallArgs<'a> {\n fn trans_args<'a>(cx: &'a Block<'a>,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n-                  llargs: &mut ~[ValueRef],\n+                  llargs: &mut Vec<ValueRef> ,\n                   arg_cleanup_scope: cleanup::ScopeId,\n                   ignore_self: bool)\n                   -> &'a Block<'a> {"}, {"sha": "80cfe2f56905345a60affd6e5f326548d4e448d5", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -152,7 +152,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n \n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n-    ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t])\n+    ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n@@ -191,7 +191,7 @@ pub struct ClosureResult<'a> {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment<'a>(\n                          bcx: &'a Block<'a>,\n-                         bound_values: ~[EnvValue],\n+                         bound_values: Vec<EnvValue> ,\n                          sigil: ast::Sigil)\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n@@ -258,7 +258,7 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n     let bcx = bcx0;\n \n     // Package up the captured upvars\n-    let mut env_vals = ~[];\n+    let mut env_vals = Vec::new();\n     for cap_var in cap_vars.iter() {\n         debug!(\"Building closure: captured variable {:?}\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n@@ -471,7 +471,7 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     let bcx = fcx.entry_bcx.get().unwrap();\n \n     let args = create_datums_for_fn_args(&fcx, ty::ty_fn_args(closure_ty));\n-    let mut llargs = ~[];\n+    let mut llargs = Vec::new();\n     match fcx.llretptr.get() {\n         Some(llretptr) => {\n             llargs.push(llretptr);"}, {"sha": "957b31553a2073d9ce45ced05bec9d032e1d3f40", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -161,7 +161,7 @@ pub struct Stats {\n     n_llvm_insns: Cell<uint>,\n     llvm_insns: RefCell<HashMap<~str, uint>>,\n     // (ident, time-in-ms, llvm-instructions)\n-    fn_stats: RefCell<~[(~str, uint, uint)]>,\n+    fn_stats: RefCell<Vec<(~str, uint, uint)> >,\n }\n \n pub struct BuilderRef_res {\n@@ -187,7 +187,7 @@ pub type ExternMap = HashMap<~str, ValueRef>;\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n-    tys: ~[ty::t],\n+    tys: Vec<ty::t> ,\n     self_ty: Option<ty::t>,\n     vtables: Option<typeck::vtable_res>,\n     self_vtables: Option<typeck::vtable_param_res>\n@@ -285,7 +285,7 @@ pub struct FunctionContext<'a> {\n     debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    scopes: RefCell<~[cleanup::CleanupScope<'a>]>,\n+    scopes: RefCell<Vec<cleanup::CleanupScope<'a>> >,\n }\n \n impl<'a> FunctionContext<'a> {\n@@ -639,7 +639,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n     unsafe {\n         let mut i = 0u;\n-        let mut elts: ~[ValueRef] = ~[];\n+        let mut elts: Vec<ValueRef> = Vec::new();\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n         return llvm::LLVMConstArray(Type::i8().to_ref(),\n                                     elts.as_ptr(), elts.len() as c_uint);\n@@ -725,7 +725,7 @@ pub fn is_null(val: ValueRef) -> bool {\n // Used to identify cached monomorphized functions and vtables\n #[deriving(Eq, Hash)]\n pub enum mono_param_id {\n-    mono_precise(ty::t, Option<@~[mono_id]>),\n+    mono_precise(ty::t, Option<@Vec<mono_id> >),\n     mono_any,\n     mono_repr(uint /* size */,\n               uint /* align */,\n@@ -758,8 +758,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n #[deriving(Eq, Hash)]\n pub struct mono_id_ {\n     def: ast::DefId,\n-    params: ~[mono_param_id]\n-}\n+    params: Vec<mono_param_id> }\n \n pub type mono_id = @mono_id_;\n \n@@ -808,7 +807,7 @@ pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> Vec<ty::t> {\n     let tcx = bcx.tcx();\n     let params = if is_method {\n         bcx.ccx().maps.method_map.borrow().get().get(&id).substs.tps.clone()\n@@ -925,7 +924,7 @@ pub fn find_vtable(tcx: ty::ctxt,\n     param_bounds[n_bound].clone()\n }\n \n-pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n+pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {\n     substs {\n         regions: ty::ErasedRegions,\n         self_ty: None,"}, {"sha": "62723c1c4deb4f99d0e3ec5790aa8e9b3cd58981", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -302,8 +302,9 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[@ast::Expr]| {\n         exprs.iter().map(|&e| const_expr(cx, e, is_local))\n-             .fold((~[], true), |(l, all_inlineable), (val, inlineable)| {\n-                (vec::append_one(l, val), all_inlineable && inlineable)\n+             .fold((Vec::new(), true),\n+                   |(L, all_inlineable), (val, inlineable)| {\n+                (vec::append_one(L, val), all_inlineable && inlineable)\n              })\n     };\n     unsafe {"}, {"sha": "db6bca095b5993935e9171883a5e2778150a11e0", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -226,7 +226,7 @@ impl CrateContext {\n                    n_closures: Cell::new(0u),\n                    n_llvm_insns: Cell::new(0u),\n                    llvm_insns: RefCell::new(HashMap::new()),\n-                   fn_stats: RefCell::new(~[]),\n+                   fn_stats: RefCell::new(Vec::new()),\n                  },\n                  tydesc_type: tydesc_type,\n                  int_type: int_type,\n@@ -250,7 +250,7 @@ impl CrateContext {\n                                indices: &[uint]) -> ValueRef {\n         debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n-        let v: ~[ValueRef] =\n+        let v: Vec<ValueRef> =\n             indices.iter().map(|i| C_i32(*i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,"}, {"sha": "4def17bbea0040ada1917804ba4d2cdfc22fe08f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -341,7 +341,7 @@ pub fn trans_fail<'a>(\n     let v_line = loc.line as int;\n     let v_str = PointerCast(bcx, v_fail_str, Type::i8p());\n     let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n-    let args = ~[v_str, v_filename, C_int(ccx, v_line)];\n+    let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n@@ -356,7 +356,7 @@ pub fn trans_fail_bounds_check<'a>(\n                                -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n-    let args = ~[filename, line, index, len];\n+    let args = vec!(filename, line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n     Unreachable(bcx);"}, {"sha": "76199e50ffa003ff291409208ac0f8fab08a8a9d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -177,7 +177,7 @@ pub struct CrateDebugContext {\n     priv current_debug_location: Cell<DebugLocation>,\n     priv created_files: RefCell<HashMap<~str, DIFile>>,\n     priv created_types: RefCell<HashMap<uint, DIType>>,\n-    priv namespace_map: RefCell<HashMap<~[ast::Name], @NamespaceTreeNode>>,\n+    priv namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n     priv composite_types_completed: RefCell<HashSet<DIType>>,\n@@ -771,7 +771,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         name_to_append_suffix_to.push_char('<');\n \n         // The list to be filled with template parameters:\n-        let mut template_params: ~[DIDescriptor] = vec::with_capacity(generics.ty_params.len() + 1);\n+        let mut template_params: Vec<DIDescriptor> = vec::with_capacity(generics.ty_params.len() + 1);\n \n         // Handle self type\n         if has_self_type {\n@@ -1136,7 +1136,7 @@ enum MemberDescriptionFactory {\n \n impl MemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         match *self {\n             StructMD(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -1155,13 +1155,13 @@ impl MemberDescriptionFactory {\n }\n \n struct StructMemberDescriptionFactory {\n-    fields: ~[ty::field],\n+    fields: Vec<ty::field> ,\n     span: Span,\n }\n \n impl StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 ~\"\"\n@@ -1260,13 +1260,13 @@ impl RecursiveTypeDescription {\n }\n \n struct TupleMemberDescriptionFactory {\n-    component_types: ~[ty::t],\n+    component_types: Vec<ty::t> ,\n     span: Span,\n }\n \n impl TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.component_types.map(|&component_type| {\n             MemberDescription {\n                 name: ~\"\",\n@@ -1308,7 +1308,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n \n struct GeneralMemberDescriptionFactory {\n     type_rep: @adt::Repr,\n-    variants: @~[@ty::VariantInfo],\n+    variants: @Vec<@ty::VariantInfo> ,\n     discriminant_type_metadata: ValueRef,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1317,7 +1317,7 @@ struct GeneralMemberDescriptionFactory {\n \n impl GeneralMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n             adt::General(_, ref struct_defs) => struct_defs,\n@@ -1357,14 +1357,14 @@ impl GeneralMemberDescriptionFactory {\n }\n \n struct EnumVariantMemberDescriptionFactory {\n-    args: ~[(~str, ty::t)],\n+    args: Vec<(~str, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n \n impl EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription] {\n+                                  -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n                 name: name.to_str(),\n@@ -1420,7 +1420,7 @@ fn describe_enum_variant(cx: &CrateContext,\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-    let args: ~[(~str, ty::t)] = arg_names.iter()\n+    let args: Vec<(~str, ty::t)> = arg_names.iter()\n         .zip(struct_def.fields.iter())\n         .map(|(s, &t)| (s.to_str(), t))\n         .collect();\n@@ -1462,7 +1462,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n \n     let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n-    let enumerators_metadata: ~[DIDescriptor] = variants\n+    let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n             token::get_ident(v.name).get().with_c_str(|name| {\n@@ -1650,7 +1650,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n \n     let loc = span_start(cx, definition_span);\n \n-    let member_metadata: ~[DIDescriptor] = member_descriptions\n+    let member_metadata: Vec<DIDescriptor> = member_descriptions\n         .iter()\n         .enumerate()\n         .map(|(i, member_description)| {\n@@ -1954,7 +1954,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let mut signature_metadata: ~[DIType] = vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> = vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n@@ -2265,7 +2265,7 @@ fn populate_scope_map(cx: &CrateContext,\n         ident: Option<ast::Ident>\n     }\n \n-    let mut scope_stack = ~[ScopeStackEntry { scope_metadata: fn_metadata, ident: None }];\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, ident: None });\n \n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n@@ -2288,10 +2288,10 @@ fn populate_scope_map(cx: &CrateContext,\n     // local helper functions for walking the AST.\n     fn with_new_scope(cx: &CrateContext,\n                       scope_span: Span,\n-                      scope_stack: &mut ~[ScopeStackEntry],\n+                      scope_stack: &mut Vec<ScopeStackEntry> ,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n                       inner_walk: |&CrateContext,\n-                                   &mut ~[ScopeStackEntry],\n+                                   &mut Vec<ScopeStackEntry> ,\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n@@ -2325,7 +2325,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_block(cx: &CrateContext,\n                   block: &ast::Block,\n-                  scope_stack: &mut ~[ScopeStackEntry],\n+                  scope_stack: &mut Vec<ScopeStackEntry> ,\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         scope_map.insert(block.id, scope_stack.last().unwrap().scope_metadata);\n \n@@ -2349,7 +2349,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_decl(cx: &CrateContext,\n                  decl: &ast::Decl,\n-                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n             codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n@@ -2367,7 +2367,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_pattern(cx: &CrateContext,\n                     pat: @ast::Pat,\n-                    scope_stack: &mut ~[ScopeStackEntry],\n+                    scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n         let def_map = cx.tcx.def_map;\n@@ -2512,7 +2512,7 @@ fn populate_scope_map(cx: &CrateContext,\n \n     fn walk_expr(cx: &CrateContext,\n                  exp: &ast::Expr,\n-                 scope_stack: &mut ~[ScopeStackEntry],\n+                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n         scope_map.insert(exp.id, scope_stack.last().unwrap().scope_metadata);\n@@ -2741,7 +2741,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         };\n         let mut path = krate.move_iter().chain(path).peekable();\n \n-        let mut current_key = ~[];\n+        let mut current_key = Vec::new();\n         let mut parent_node: Option<@NamespaceTreeNode> = None;\n \n         // Create/Lookup namespace for each element of the path."}, {"sha": "9dae8f435ec91453967105cdfd2325df5970ad74", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -741,7 +741,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprTup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            let numbered_fields: ~[(uint, @ast::Expr)] =\n+            let numbered_fields: Vec<(uint, @ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             trans_adt(bcx, repr, 0, numbered_fields, None, dest)\n         }\n@@ -1047,7 +1047,7 @@ fn trans_rec_or_struct<'a>(\n         });\n         let optbase = match base {\n             Some(base_expr) => {\n-                let mut leftovers = ~[];\n+                let mut leftovers = Vec::new();\n                 for (i, b) in need_base.iter().enumerate() {\n                     if *b {\n                         leftovers.push((i, field_tys[i].mt.ty))\n@@ -1081,8 +1081,7 @@ struct StructBaseInfo {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: @ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: ~[(uint, ty::t)]\n-}\n+    fields: Vec<(uint, ty::t)> }\n \n /**\n  * Constructs an ADT instance:\n@@ -1709,7 +1708,7 @@ fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a, Expr> {\n                     _ => false\n                 }\n             });\n-            let modpath: ~[ast_map::PathElem] = path.collect();\n+            let modpath: Vec<ast_map::PathElem> = path.collect();\n             let modname = ast_map::path_to_str(ast_map::Values(modpath.iter()));\n             (modpath, modname)\n         })"}, {"sha": "1c794728c1ef31aa50a4462ad8137568cb74ab00", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -56,7 +56,7 @@ struct ForeignTypes {\n \n struct LlvmSignature {\n     // LLVM versions of the types of this function's arguments.\n-    llarg_tys: ~[Type],\n+    llarg_tys: Vec<Type> ,\n \n     // LLVM version of the type that this function returns.  Note that\n     // this *may not be* the declared return type of the foreign\n@@ -163,7 +163,7 @@ pub fn trans_native_call<'a>(\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n                          llargs_rust: &[ValueRef],\n-                         passed_arg_tys: ~[ty::t])\n+                         passed_arg_tys: Vec<ty::t> )\n                          -> &'a Block<'a> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n@@ -205,7 +205,7 @@ pub fn trans_native_call<'a>(\n \n     let arg_tys: &[cabi::ArgType] = fn_type.arg_tys;\n \n-    let mut llargs_foreign = ~[];\n+    let mut llargs_foreign = Vec::new();\n \n     // If the foreign ABI expects return value by pointer, supply the\n     // pointer that Rust gave us. Sometimes we have to bitcast\n@@ -503,7 +503,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         llvm::LLVMPositionBuilderAtEnd(builder, the_block);\n \n         // Array for the arguments we will pass to the rust function.\n-        let mut llrust_args = ~[];\n+        let mut llrust_args = Vec::new();\n         let mut next_foreign_arg_counter: c_uint = 0;\n         let next_foreign_arg: |pad: bool| -> c_uint = |pad: bool| {\n             next_foreign_arg_counter += if pad {\n@@ -777,7 +777,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n }\n \n fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n-    let mut llargument_tys = ~[];\n+    let mut llargument_tys = Vec::new();\n \n     let ret_ty = tys.fn_ty.ret_ty;\n     let llreturn_ty = if ret_ty.is_indirect() {"}, {"sha": "c48882f3f528e5949f016aa3895c4faf4b259863", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -263,7 +263,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     let field_scope = bcx.fcx.push_custom_cleanup_scope();\n \n     let self_arg = PointerCast(bcx, v0, params[0]);\n-    let args = ~[self_arg];\n+    let args = vec!(self_arg);\n \n     // Add all the fields as a value which needs to be cleaned at the end of\n     // this scope."}, {"sha": "7bd415b9d54d89ab8c6d3392732ee84591660666", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -207,7 +207,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     // This requires that atomic intrinsics follow a specific naming pattern:\n     // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n     if name.get().starts_with(\"atomic_\") {\n-        let split: ~[&str] = name.get().split('_').collect();\n+        let split: Vec<&str> = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n         let order = if split.len() == 2 {\n             lib::llvm::SequentiallyConsistent"}, {"sha": "16fa8e12f419004dc91b6a3f09715158059c02f3", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -292,7 +292,7 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n                                 is_method: bool,\n                                 rcvr_substs: &[ty::t],\n                                 rcvr_origins: typeck::vtable_res)\n-                                -> (~[ty::t], typeck::vtable_res) {\n+                                -> (Vec<ty::t> , typeck::vtable_res) {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -316,7 +316,7 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let node_substs = node_id_type_params(bcx, expr_id, is_method);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n-        = vec::append(rcvr_substs.to_owned(),\n+        = vec_ng::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n@@ -327,10 +327,10 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     // exist, in which case we need to make them.\n     let r_m_origins = match node_vtables(bcx, expr_id) {\n         Some(vt) => vt,\n-        None => @vec::from_elem(node_substs.len(), @~[])\n+        None => @vec::from_elem(node_substs.len(), @Vec::new())\n     };\n     let vtables\n-        = @vec::append(rcvr_origins.to_owned(),\n+        = @vec_ng::append(rcvr_origins.to_owned(),\n                        r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n     (ty_substs, vtables)\n@@ -496,7 +496,7 @@ pub fn make_vtable(ccx: &CrateContext,\n     unsafe {\n         let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = ~[drop_glue];\n+        let mut components = vec!(drop_glue);\n         for &ptr in ptrs.iter() {\n             components.push(ptr)\n         }\n@@ -517,7 +517,7 @@ fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n-                       -> ~[ValueRef] {\n+                       -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n "}, {"sha": "e5774a5cd6e247a83156b7b3f72f37a54cae82c2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -299,7 +299,7 @@ pub fn make_mono_id(ccx: @CrateContext,\n     // FIXME (possibly #5801): Need a lot of type hints to get\n     // .collect() to work.\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n-    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n+    let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n@@ -309,7 +309,7 @@ pub fn make_mono_id(ccx: @CrateContext,\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         }).collect()\n       }\n-      None => substs_iter.map(|subst| (*subst, None::<@~[mono_id]>)).collect()\n+      None => substs_iter.map(|subst| (*subst, None::<@Vec<mono_id> >)).collect()\n     };\n \n "}, {"sha": "000094245450d128cba84ca5f4f4a66c1583b5c5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -37,7 +37,7 @@ use syntax::parse::token;\n \n pub struct Reflector<'a> {\n     visitor_val: ValueRef,\n-    visitor_methods: @~[@ty::Method],\n+    visitor_methods: @Vec<@ty::Method> ,\n     final_bcx: &'a Block<'a>,\n     tydesc_ty: Type,\n     bcx: &'a Block<'a>\n@@ -70,12 +70,12 @@ impl<'a> Reflector<'a> {\n         scratch.val\n     }\n \n-    pub fn c_size_and_align(&mut self, t: ty::t) -> ~[ValueRef] {\n+    pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n         let tr = type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n         let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n-        return ~[self.c_uint(s as uint),\n-             self.c_uint(a as uint)];\n+        return vec!(self.c_uint(s as uint),\n+             self.c_uint(a as uint));\n     }\n \n     pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n@@ -85,9 +85,9 @@ impl<'a> Reflector<'a> {\n         PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n \n-    pub fn c_mt(&mut self, mt: &ty::mt) -> ~[ValueRef] {\n-        ~[self.c_uint(mt.mutbl as uint),\n-          self.c_tydesc(mt.ty)]\n+    pub fn c_mt(&mut self, mt: &ty::mt) -> Vec<ValueRef> {\n+        vec!(self.c_uint(mt.mutbl as uint),\n+          self.c_tydesc(mt.ty))\n     }\n \n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n@@ -130,15 +130,15 @@ impl<'a> Reflector<'a> {\n     pub fn vstore_name_and_extra(&mut self,\n                                  t: ty::t,\n                                  vstore: ty::vstore)\n-                                 -> (~str, ~[ValueRef]) {\n+                                 -> (~str, Vec<ValueRef> ) {\n         match vstore {\n             ty::vstore_fixed(n) => {\n-                let extra = vec::append(~[self.c_uint(n)],\n+                let extra = vec_ng::append(vec!(self.c_uint(n)),\n                                         self.c_size_and_align(t));\n                 (~\"fixed\", extra)\n             }\n-            ty::vstore_slice(_) => (~\"slice\", ~[]),\n-            ty::vstore_uniq => (~\"uniq\", ~[]),\n+            ty::vstore_slice(_) => (~\"slice\", Vec::new()),\n+            ty::vstore_uniq => (~\"uniq\", Vec::new()),\n         }\n     }\n \n@@ -210,11 +210,11 @@ impl<'a> Reflector<'a> {\n           }\n \n           ty::ty_tup(ref tys) => {\n-              let extra = ~[self.c_uint(tys.len())]\n+              let extra = vec!(self.c_uint(tys.len()))\n                   + self.c_size_and_align(t);\n               self.bracketed(\"tup\", extra, |this| {\n                   for (i, t) in tys.iter().enumerate() {\n-                      let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n+                      let extra = vec!(this.c_uint(i), this.c_tydesc(*t));\n                       this.visit(\"tup_field\", extra);\n                   }\n               })\n@@ -226,10 +226,10 @@ impl<'a> Reflector<'a> {\n             let pureval = ast_purity_constant(fty.purity);\n             let sigilval = ast_sigil_constant(fty.sigil);\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = ~[self.c_uint(pureval),\n+            let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval)];\n+                          self.c_uint(retval));\n             self.visit(\"enter_fn\", extra);\n             self.visit_sig(retval, &fty.sig);\n             self.visit(\"leave_fn\", extra);\n@@ -241,10 +241,10 @@ impl<'a> Reflector<'a> {\n             let pureval = ast_purity_constant(fty.purity);\n             let sigilval = 0u;\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n-            let extra = ~[self.c_uint(pureval),\n+            let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n-                          self.c_uint(retval)];\n+                          self.c_uint(retval));\n             self.visit(\"enter_fn\", extra);\n             self.visit_sig(retval, &fty.sig);\n             self.visit(\"leave_fn\", extra);\n@@ -258,19 +258,19 @@ impl<'a> Reflector<'a> {\n                         fields[0].ident.name != special_idents::unnamed_field.name;\n               }\n \n-              let extra = ~[\n+              let extra = vec!(\n                   self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n                                                                      t))),\n                   self.c_bool(named_fields),\n                   self.c_uint(fields.len())\n-              ] + self.c_size_and_align(t);\n+              ) + self.c_size_and_align(t);\n               self.bracketed(\"class\", extra, |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = ~[\n+                      let extra = vec!(\n                         this.c_uint(i),\n                         this.c_slice(token::get_ident(field.ident)),\n                         this.c_bool(named_fields)\n-                      ] + this.c_mt(&field.mt);\n+                      ) + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n                   }\n               })\n@@ -319,24 +319,24 @@ impl<'a> Reflector<'a> {\n                 llfdecl\n             };\n \n-            let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n+            let enum_args = vec!(self.c_uint(variants.len()), make_get_disr())\n                 + self.c_size_and_align(t);\n             self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = token::get_ident(v.name);\n-                    let variant_args = ~[this.c_uint(i),\n+                    let variant_args = vec!(this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n-                                         this.c_slice(name)];\n+                                         this.c_slice(name));\n                     this.bracketed(\"enum_variant\", variant_args, |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n-                            let field_args = ~[this.c_uint(j),\n+                            let field_args = vec!(this.c_uint(j),\n                                                offset,\n-                                               this.c_tydesc(*a)];\n+                                               this.c_tydesc(*a));\n                             this.visit(\"enum_variant_field\", field_args);\n                         }\n                     })\n@@ -355,7 +355,7 @@ impl<'a> Reflector<'a> {\n           ty::ty_infer(_) => self.leaf(\"infer\"),\n           ty::ty_err => self.leaf(\"err\"),\n           ty::ty_param(ref p) => {\n-              let extra = ~[self.c_uint(p.idx)];\n+              let extra = vec!(self.c_uint(p.idx));\n               self.visit(\"param\", extra)\n           }\n           ty::ty_self(..) => self.leaf(\"self\")\n@@ -365,14 +365,14 @@ impl<'a> Reflector<'a> {\n     pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for (i, arg) in sig.inputs.iter().enumerate() {\n             let modeval = 5u;   // \"by copy\"\n-            let extra = ~[self.c_uint(i),\n+            let extra = vec!(self.c_uint(i),\n                          self.c_uint(modeval),\n-                         self.c_tydesc(*arg)];\n+                         self.c_tydesc(*arg));\n             self.visit(\"fn_input\", extra);\n         }\n-        let extra = ~[self.c_uint(retval),\n+        let extra = vec!(self.c_uint(retval),\n                       self.c_bool(sig.variadic),\n-                      self.c_tydesc(sig.output)];\n+                      self.c_tydesc(sig.output));\n         self.visit(\"fn_output\", extra);\n     }\n }"}, {"sha": "03114ca2842e8c3f975d89de58fff1bb6d5f9065", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -295,11 +295,11 @@ impl Type {\n         }\n     }\n \n-    pub fn field_types(&self) -> ~[Type] {\n+    pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n             let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n             if n_elts == 0 {\n-                return ~[];\n+                return Vec::new();\n             }\n             let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n             llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n@@ -311,7 +311,7 @@ impl Type {\n         ty!(llvm::LLVMGetReturnType(self.to_ref()))\n     }\n \n-    pub fn func_params(&self) -> ~[Type] {\n+    pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n             let args = vec::from_elem(n_args, 0 as TypeRef);"}, {"sha": "36da8be0b5d1b6ebc79de0aa3aae23dc5fec9db8", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -41,7 +41,7 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n \n pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n                        inputs: &[ty::t], output: ty::t) -> Type {\n-    let mut atys: ~[Type] = ~[];\n+    let mut atys: Vec<Type> = Vec::new();\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)"}, {"sha": "ac1ac8105556e0ba10775f61dd3a039f0c0e1dca", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -122,8 +122,7 @@ impl Method {\n pub struct Impl {\n     did: DefId,\n     ident: Ident,\n-    methods: ~[@Method]\n-}\n+    methods: Vec<@Method> }\n \n #[deriving(Clone, Eq, Hash)]\n pub struct mt {\n@@ -280,16 +279,16 @@ pub struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: RefCell<NodeMap<~[t]>>,\n+    node_type_substs: RefCell<NodeMap<vec!(t)>>,\n \n     // Maps from a method to the method \"descriptor\"\n     methods: RefCell<DefIdMap<@Method>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    trait_method_def_ids: RefCell<DefIdMap<@~[DefId]>>,\n+    trait_method_def_ids: RefCell<DefIdMap<@Vec<DefId> >>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: RefCell<DefIdMap<@~[@Method]>>,\n+    trait_methods_cache: RefCell<DefIdMap<@Vec<@Method> >>,\n \n     impl_trait_cache: RefCell<DefIdMap<Option<@ty::TraitRef>>>,\n \n@@ -305,14 +304,14 @@ pub struct ctxt_ {\n     needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n-    enum_var_cache: RefCell<DefIdMap<@~[@VariantInfo]>>,\n+    enum_var_cache: RefCell<DefIdMap<@Vec<@VariantInfo> >>,\n     ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n     adjustments: RefCell<NodeMap<@AutoAdjustment>>,\n     normalized_cache: RefCell<HashMap<t, t>>,\n     lang_items: @middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n     provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    supertraits: RefCell<DefIdMap<@~[@TraitRef]>>,\n+    supertraits: RefCell<DefIdMap<@Vec<@TraitRef> >>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n@@ -328,12 +327,12 @@ pub struct ctxt_ {\n     destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    trait_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n+    trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n+    inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n@@ -461,7 +460,7 @@ pub struct ClosureTy {\n #[deriving(Clone, Eq, Hash)]\n pub struct FnSig {\n     binder_id: ast::NodeId,\n-    inputs: ~[t],\n+    inputs: vec!(t),\n     output: t,\n     variadic: bool\n }\n@@ -684,7 +683,7 @@ pub enum RegionSubsts {\n #[deriving(Clone, Eq, Hash)]\n pub struct substs {\n     self_ty: Option<ty::t>,\n-    tps: ~[t],\n+    tps: vec!(t),\n     regions: RegionSubsts,\n }\n \n@@ -756,7 +755,7 @@ pub enum sty {\n     ty_closure(ClosureTy),\n     ty_trait(DefId, substs, TraitStore, ast::Mutability, BuiltinBounds),\n     ty_struct(DefId, substs),\n-    ty_tup(~[t]),\n+    ty_tup(vec!(t)),\n \n     ty_param(param_ty), // type parameter\n     ty_self(DefId), /* special, implicit `self` type parameter;\n@@ -836,8 +835,7 @@ pub enum type_err {\n #[deriving(Eq, Hash)]\n pub struct ParamBounds {\n     builtin_bounds: BuiltinBounds,\n-    trait_bounds: ~[@TraitRef]\n-}\n+    trait_bounds: Vec<@TraitRef> }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n@@ -1006,10 +1004,10 @@ pub struct RegionParameterDef {\n #[deriving(Clone)]\n pub struct Generics {\n     /// List of type parameters declared on the item.\n-    type_param_defs: Rc<~[TypeParameterDef]>,\n+    type_param_defs: Rc<Vec<TypeParameterDef> >,\n \n     /// List of region parameters declared on the item.\n-    region_param_defs: Rc<~[RegionParameterDef]>,\n+    region_param_defs: Rc<Vec<RegionParameterDef> >,\n }\n \n impl Generics {\n@@ -1048,7 +1046,7 @@ pub struct ParameterEnvironment {\n     self_param_bound: Option<@TraitRef>,\n \n     /// Bounds on each numbered type parameter\n-    type_param_bounds: ~[ParamBounds],\n+    type_param_bounds: Vec<ParamBounds> ,\n }\n \n /// A polytype.\n@@ -1412,7 +1410,7 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n-pub fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, ts: vec!(t)) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n@@ -2391,7 +2389,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n+    fn type_requires(cx: ctxt, seen: &mut Vec<DefId> ,\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2409,7 +2407,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n+    fn subtypes_require(cx: ctxt, seen: &mut Vec<DefId> ,\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2497,7 +2495,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    let mut seen = ~[];\n+    let mut seen = Vec::new();\n     !subtypes_require(cx, &mut seen, r_ty, r_ty)\n }\n \n@@ -2518,7 +2516,7 @@ pub enum Representability {\n pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut ~[DefId],\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut Vec<DefId> ,\n                                               mut iter: It) -> Representability {\n         for ty in iter {\n             let r = type_structurally_recursive(cx, seen, ty);\n@@ -2531,7 +2529,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: ctxt, seen: &mut ~[DefId],\n+    fn type_structurally_recursive(cx: ctxt, seen: &mut Vec<DefId> ,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_str(cx, ty));\n@@ -2597,7 +2595,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n-    let mut seen: ~[DefId] = ~[];\n+    let mut seen: Vec<DefId> = Vec::new();\n     type_structurally_recursive(cx, &mut seen, ty)\n }\n \n@@ -2788,10 +2786,10 @@ pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n }\n \n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> ~[t] {\n+pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> Vec<t> {\n     let node_type_substs = cx.node_type_substs.borrow();\n     match node_type_substs.get().find(&id) {\n-      None => return ~[],\n+      None => return Vec::new(),\n       Some(ts) => return (*ts).clone(),\n     }\n }\n@@ -2822,7 +2820,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args(fty: t) -> ~[t] {\n+pub fn ty_fn_args(fty: t) -> Vec<t> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n@@ -2925,7 +2923,7 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n }\n \n // Returns a vec of all the input and output types of fty.\n-pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n+pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n     vec::append_one(sig.inputs.map(|a| *a), sig.output)\n }\n \n@@ -3213,7 +3211,7 @@ impl AutoRef {\n }\n \n pub struct ParamsTy {\n-    params: ~[t],\n+    params: vec!(t),\n     ty: t\n }\n \n@@ -3231,7 +3229,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n }\n \n pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n-                                   -> Rc<~[TypeParameterDef]> {\n+                                   -> Rc<Vec<TypeParameterDef> > {\n     match origin {\n         typeck::MethodStatic(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3250,7 +3248,7 @@ pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n                 lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n-            Rc::new(vec::append(\n+            Rc::new(vec_ng::append(\n                 trait_type_param_defs.to_owned(),\n                 ty::trait_method(tcx,\n                                  trt_id,\n@@ -3480,8 +3478,8 @@ pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n /// Returns a vector containing the indices of all type parameters that appear\n /// in `ty`.  The vector may contain duplicates.  Probably should be converted\n /// to a bitset or some other representation.\n-pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n-    let mut rslt = ~[];\n+pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n+    let mut rslt = Vec::new();\n     walk_ty(ty, |ty| {\n         match get(ty).sty {\n           ty_param(p) => {\n@@ -3496,8 +3494,8 @@ pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> ~[TyVid] {\n-        let mut rslt = ~[];\n+    fn vars_in_type(ty: t) -> Vec<TyVid> {\n+        let mut rslt = Vec::new();\n         walk_ty(ty, |ty| {\n             match get(ty).sty {\n               ty_infer(TyVar(v)) => rslt.push(v),\n@@ -3742,7 +3740,7 @@ pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     provided_method_sources.get().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n+pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n     if is_local(id) {\n         {\n             match cx.map.find(id.node) {\n@@ -3774,7 +3772,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n     }\n }\n \n-pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @~[@TraitRef] {\n+pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Check the cache.\n     {\n         let supertraits = cx.supertraits.borrow();\n@@ -3796,7 +3794,7 @@ pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @~[@TraitRef] {\n     return result;\n }\n \n-pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef] {\n+pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n@@ -3836,7 +3834,7 @@ pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n }\n \n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @~[@Method] {\n+pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n     match trait_methods_cache.get().find(&trait_did) {\n         Some(&methods) => methods,\n@@ -3856,7 +3854,7 @@ pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n     })\n }\n \n-pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n+pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @Vec<DefId> {\n     let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n@@ -3934,8 +3932,8 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n // Enum information\n #[deriving(Clone)]\n pub struct VariantInfo {\n-    args: ~[t],\n-    arg_names: Option<~[ast::Ident]>,\n+    args: vec!(t),\n+    arg_names: Option<Vec<ast::Ident> >,\n     ctor_ty: t,\n     name: ast::Ident,\n     id: ast::DefId,\n@@ -3955,7 +3953,7 @@ impl VariantInfo {\n \n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { ~[] };\n+                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { Vec::new() };\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3999,7 +3997,7 @@ impl VariantInfo {\n pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n-                         -> ~[@VariantInfo] {\n+                         -> Vec<@VariantInfo> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n@@ -4080,7 +4078,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n     {\n         let enum_var_cache = cx.enum_var_cache.borrow();\n         match enum_var_cache.get().find(&id) {\n@@ -4295,7 +4293,7 @@ pub fn lookup_field_type(tcx: ctxt,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n+pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> Vec<field_ty> {\n   if did.krate == ast::LOCAL_CRATE {\n       {\n           match cx.map.find(did.node) {\n@@ -4342,7 +4340,7 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n+fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n     fields.map(|field| {\n         match field.node.kind {\n             NamedField(ident, visibility) => {\n@@ -4366,7 +4364,7 @@ fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n-                     -> ~[field] {\n+                     -> Vec<field> {\n     lookup_struct_fields(cx, did).map(|f| {\n        field {\n             // FIXME #6993: change type of field to Name and get rid of new()\n@@ -4451,7 +4449,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n+pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> Vec<t> {\n     vec::from_fn(generics.ty_params.len(), |i| {\n         let id = generics.ty_params.get(i).id;\n         ty::mk_param(tcx, i, ast_util::local_def(id))\n@@ -4607,7 +4605,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         -> bool {\n     for &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n-        let mut trait_refs = ~[];\n+        let mut trait_refs = Vec::new();\n         let mut i = 0;\n \n         // Seed the worklist with the trait from the bound\n@@ -4681,7 +4679,7 @@ pub fn visitor_object_ty(tcx: ctxt,\n     let substs = substs {\n         regions: ty::NonerasedRegions(opt_vec::Empty),\n         self_ty: None,\n-        tps: ~[]\n+        tps: Vec::new()\n     };\n     let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n     Ok((trait_ref,\n@@ -4708,7 +4706,7 @@ fn record_trait_implementation(tcx: ctxt,\n     let mut trait_impls = tcx.trait_impls.borrow_mut();\n     match trait_impls.get().find(&trait_def_id) {\n         None => {\n-            implementation_list = @RefCell::new(~[]);\n+            implementation_list = @RefCell::new(Vec::new());\n             trait_impls.get().insert(trait_def_id, implementation_list);\n         }\n         Some(&existing_implementation_list) => {\n@@ -4763,7 +4761,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n             let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n             match inherent_impls.get().find(&type_id) {\n                 None => {\n-                    implementation_list = @RefCell::new(~[]);\n+                    implementation_list = @RefCell::new(Vec::new());\n                     inherent_impls.get().insert(type_id, implementation_list);\n                 }\n                 Some(&existing_implementation_list) => {\n@@ -5128,7 +5126,7 @@ impl substs {\n     pub fn empty() -> substs {\n         substs {\n             self_ty: None,\n-            tps: ~[],\n+            tps: Vec::new(),\n             regions: NonerasedRegions(opt_vec::Empty)\n         }\n     }"}, {"sha": "859423d952393bb0d82c07767d4bd78cfb165e5f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -86,7 +86,7 @@ pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n \n pub fn fold_ty_vec<T:TypeFolder>(this: &mut T,\n                                  tys: &[ty::t])\n-                                 -> ~[ty::t] {\n+                                 -> Vec<ty::t> {\n     tys.map(|t| this.fold_ty(*t))\n }\n "}, {"sha": "f1c8b121b4c6b593ec22740f1f42785b8f06a74f", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -115,7 +115,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types: ~[ty::t];\n+    let arg_types: Vec<ty::t> ;\n     let kind_name;\n \n     // structure_of requires type variables to be resolved.\n@@ -295,7 +295,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: Span,\n                                path: &ast::Path,\n                                fields: &[ast::FieldPat],\n-                               class_fields: ~[ty::field_ty],\n+                               class_fields: Vec<ty::field_ty> ,\n                                class_id: ast::DefId,\n                                substitutions: &ty::substs,\n                                etc: bool) {\n@@ -562,7 +562,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                           supplied_def_id,\n                                           &ty::substs {\n                                               self_ty: None,\n-                                              tps: ~[],\n+                                              tps: Vec::new(),\n                                               regions: ty::ErasedRegions,\n                                           });\n                     }"}, {"sha": "e563e6b2415652979eaf7de0da85db4942b58bc0", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -139,8 +139,8 @@ pub fn lookup(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(~[]),\n-        extension_candidates: @RefCell::new(~[]),\n+        inherent_candidates: @RefCell::new(Vec::new()),\n+        extension_candidates: @RefCell::new(Vec::new()),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n@@ -184,8 +184,8 @@ pub fn lookup_in_trait(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(~[]),\n-        extension_candidates: @RefCell::new(~[]),\n+        inherent_candidates: @RefCell::new(Vec::new()),\n+        extension_candidates: @RefCell::new(Vec::new()),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: autoderef_receiver,\n@@ -208,8 +208,8 @@ pub struct LookupContext<'a> {\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n     impl_dups: @RefCell<HashSet<DefId>>,\n-    inherent_candidates: @RefCell<~[Candidate]>,\n-    extension_candidates: @RefCell<~[Candidate]>,\n+    inherent_candidates: @RefCell<Vec<Candidate> >,\n+    extension_candidates: @RefCell<Vec<Candidate> >,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n@@ -311,8 +311,8 @@ impl<'a> LookupContext<'a> {\n     // Candidate collection (see comment at start of file)\n \n     fn reset_candidates(&self) {\n-        self.inherent_candidates.set(~[]);\n-        self.extension_candidates.set(~[]);\n+        self.inherent_candidates.set(Vec::new());\n+        self.extension_candidates.set(Vec::new());\n     }\n \n     fn push_inherent_candidates(&self, self_ty: ty::t) {\n@@ -584,7 +584,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn push_candidates_from_impl(&self,\n-                                     candidates: &mut ~[Candidate],\n+                                     candidates: &mut Vec<Candidate> ,\n                                      impl_info: &ty::Impl) {\n         {\n             let mut impl_dups = self.impl_dups.borrow_mut();\n@@ -892,10 +892,10 @@ impl<'a> LookupContext<'a> {\n \n     fn consider_candidates(&self,\n                            rcvr_ty: ty::t,\n-                           candidates: &mut ~[Candidate])\n+                           candidates: &mut Vec<Candidate> )\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n-        let relevant_candidates: ~[Candidate] =\n+        let relevant_candidates: Vec<Candidate> =\n             candidates.iter().map(|c| (*c).clone()).\n                 filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n@@ -917,8 +917,8 @@ impl<'a> LookupContext<'a> {\n         Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n-    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n-        let mut merged = ~[];\n+    fn merge_candidates(&self, candidates: &[Candidate]) -> Vec<Candidate> {\n+        let mut merged = Vec::new();\n         let mut i = 0;\n         while i < candidates.len() {\n             let candidate_a = &candidates[i];\n@@ -1011,7 +1011,7 @@ impl<'a> LookupContext<'a> {\n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n-            tps: vec::append(candidate.rcvr_substs.tps.clone(), m_substs),\n+            tps: vec_ng::append(candidate.rcvr_substs.tps.clone(), m_substs),\n             regions: candidate.rcvr_substs.regions.clone(),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };"}, {"sha": "ec2a68d2ae979b736096cc04920f53bf38ef34a9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 122, "deletions": 123, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -280,7 +280,7 @@ pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n                                                self_param_bound: None,\n-                                               type_param_bounds: ~[] };\n+                                               type_param_bounds: Vec::new() };\n     @FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n@@ -510,7 +510,7 @@ fn check_fn(ccx: @CrateCtxt,\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: ~[(ast::Ident, Span)]) {\n+                                 fields: Vec<(ast::Ident, Span)> ) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -730,7 +730,7 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n     // Check for missing methods from trait\n     let provided_methods = ty::provided_trait_methods(tcx,\n                                                       impl_trait_ref.def_id);\n-    let mut missing_methods = ~[];\n+    let mut missing_methods = Vec::new();\n     for trait_method in trait_methods.iter() {\n         let is_implemented =\n             impl_methods.iter().any(\n@@ -887,11 +887,11 @@ fn compare_impl_method(tcx: ty::ctxt,\n     // in the self type with free regions.  So, for example, if the\n     // impl type is \"&'a str\", then this would replace the self\n     // type with a free region `self`.\n-    let dummy_impl_tps: ~[ty::t] =\n+    let dummy_impl_tps: Vec<ty::t> =\n         impl_generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n         collect();\n-    let dummy_method_tps: ~[ty::t] =\n+    let dummy_method_tps: Vec<ty::t> =\n         impl_m.generics.type_param_defs().iter().enumerate().\n         map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n         collect();\n@@ -902,7 +902,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 bound_region: ty::BrNamed(l.def_id, l.ident)})).\n         collect();\n     let dummy_substs = ty::substs {\n-        tps: vec::append(dummy_impl_tps, dummy_method_tps),\n+        tps: vec_ng::append(dummy_impl_tps, dummy_method_tps),\n         regions: ty::NonerasedRegions(dummy_impl_regions),\n         self_ty: None };\n \n@@ -929,7 +929,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                      self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n         let substs = substs {\n             regions: trait_regions,\n-            tps: vec::append(trait_tps, dummy_method_tps),\n+            tps: vec_ng::append(trait_tps, dummy_method_tps),\n             self_ty: self_ty,\n         };\n         debug!(\"trait_fty (pre-subst): {} substs={}\",\n@@ -987,7 +987,7 @@ impl FnCtxt {\n \n impl RegionScope for infer::InferCtxt {\n     fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<~[ty::Region], ()> {\n+                    -> Result<Vec<ty::Region> , ()> {\n         Ok(vec::from_fn(count, |_| {\n             self.next_region_var(infer::MiscVariable(span))\n         }))\n@@ -1259,7 +1259,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n      * so that trans/borrowck/etc know about this autoderef. */\n \n     let mut t1 = t;\n-    let mut enum_dids = ~[];\n+    let mut enum_dids = Vec::new();\n     let mut autoderefs = 0;\n     loop {\n         let sty = structure_of(fcx, sp, t1);\n@@ -1840,7 +1840,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn err_args(len: uint) -> ~[ty::t] {\n+    fn err_args(len: uint) -> Vec<ty::t> {\n         vec::from_fn(len, |_| ty::mk_err())\n     }\n \n@@ -2324,7 +2324,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             _ => ()\n         }\n \n-        let tps: ~[ty::t] = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n+        let tps: Vec<ty::t> = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2426,7 +2426,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             // Make sure the programmer specified all the fields.\n             assert!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n-                let mut missing_fields = ~[];\n+                let mut missing_fields = Vec::new();\n                 for class_field in field_types.iter() {\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n@@ -2652,10 +2652,10 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                       gc_struct_id,\n                                                       substs {\n                                                         self_ty: None,\n-                                                        tps: ~[\n+                                                        tps: vec!(\n                                                             fcx.expr_ty(\n                                                                 subexpr)\n-                                                        ],\n+                                                        ),\n                                                         regions: regions,\n                                                       });\n                               fcx.write_ty(id, sty);\n@@ -3544,11 +3544,11 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n-                -> ~[@ty::VariantInfo] {\n+                -> Vec<@ty::VariantInfo> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: ~[@ty::VariantInfo] = ~[];\n-        let mut disr_vals: ~[ty::Disr] = ~[];\n+        let mut variants: Vec<@ty::VariantInfo> = Vec::new();\n+        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n         for &v in vs.iter() {\n@@ -3797,7 +3797,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         // Build up the list of type parameters, inserting the self parameter\n         // at the appropriate position.\n-        let mut tps = ~[];\n+        let mut tps = Vec::new();\n         let mut pushed = false;\n         for (i, ty) in pth.segments.iter()\n                                    .flat_map(|segment| segment.types.iter())\n@@ -4024,40 +4024,39 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n     let tcx = ccx.tcx;\n     let name = token::get_ident(it.ident);\n     let (n_tps, inputs, output) = if name.get().starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.get().split('_').collect();\n+        let split : Vec<&str> = name.get().split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n         match split[1] {\n-            \"cxchg\" => (1, ~[ty::mk_mut_rptr(tcx,\n+            \"cxchg\" => (1, vec!(ty::mk_mut_rptr(tcx,\n                                              ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                              param(ccx, 0)),\n                         param(ccx, 0),\n-                        param(ccx, 0),\n-                        ], param(ccx, 0)),\n+                        param(ccx, 0)), param(ccx, 0)),\n             \"load\" => (1,\n-               ~[\n+               vec!(\n                   ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                   param(ccx, 0))\n-               ],\n+               ),\n               param(ccx, 0)),\n             \"store\" => (1,\n-               ~[\n+               vec!(\n                   ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                   param(ccx, 0)),\n                   param(ccx, 0)\n-               ],\n+               ),\n                ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, ~[ty::mk_mut_rptr(tcx,\n+                (1, vec!(ty::mk_mut_rptr(tcx,\n                                       ty::ReLateBound(it.id, ty::BrAnon(0)),\n-                                      param(ccx, 0)), param(ccx, 0) ],\n+                                      param(ccx, 0)), param(ccx, 0) ),\n                  param(ccx, 0))\n             }\n             \"fence\" => {\n-                (0, ~[], ty::mk_nil())\n+                (0, Vec::new(), ty::mk_nil())\n             }\n             op => {\n                 tcx.sess.span_err(it.span,\n@@ -4069,24 +4068,24 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n \n     } else {\n         match name.get() {\n-            \"abort\" => (0, ~[], ty::mk_bot()),\n-            \"breakpoint\" => (0, ~[], ty::mk_nil()),\n+            \"abort\" => (0, Vec::new(), ty::mk_bot()),\n+            \"breakpoint\" => (0, Vec::new(), ty::mk_nil()),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-            \"init\" => (1u, ~[], param(ccx, 0u)),\n-            \"uninit\" => (1u, ~[], param(ccx, 0u)),\n-            \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-            \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n+            \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n+            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil()),\n+            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n-                 ~[\n+                 vec!(\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n-                  ],\n+                  ),\n                ty::mk_nil())\n             }\n-            \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-            \"owns_managed\" => (1u, ~[], ty::mk_bool()),\n+            \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n+            \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n@@ -4097,14 +4096,14 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                   ty: tydesc_ty,\n                   mutbl: ast::MutImmutable\n               });\n-              (1u, ~[], td_ptr)\n+              (1u, Vec::new(), td_ptr)\n             }\n             \"type_id\" => {\n                 let langid = ccx.tcx.lang_items.require(TypeIdLangItem);\n                 match langid {\n-                    Ok(did) => (1u, ~[], ty::mk_struct(ccx.tcx, did, substs {\n+                    Ok(did) => (1u, Vec::new(), ty::mk_struct(ccx.tcx, did, substs {\n                                                  self_ty: None,\n-                                                 tps: ~[],\n+                                                 tps: Vec::new(),\n                                                  regions: ty::NonerasedRegions(opt_vec::Empty)\n                                                  }) ),\n                     Err(msg) => { tcx.sess.span_fatal(it.span, msg); }\n@@ -4125,25 +4124,25 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                   ty: tydesc_ty,\n                   mutbl: ast::MutImmutable\n               });\n-              (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n+              (0, vec!( td_ptr, visitor_object_ty ), ty::mk_nil())\n             }\n             \"offset\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_int()\n-               ],\n+               ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n                    mutbl: ast::MutImmutable\n                }))\n             }\n             \"copy_nonoverlapping_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n@@ -4153,12 +4152,12 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n             \"copy_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n@@ -4168,135 +4167,135 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutImmutable\n                   }),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n             \"set_memory\" => {\n               (1,\n-               ~[\n+               vec!(\n                   ty::mk_ptr(tcx, ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   ty::mk_u8(),\n                   ty::mk_uint()\n-               ],\n+               ),\n                ty::mk_nil())\n             }\n-            \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"powif32\" => {\n                (0,\n-                ~[ ty::mk_f32(), ty::mk_i32() ],\n+                vec!( ty::mk_f32(), ty::mk_i32() ),\n                 ty::mk_f32())\n             }\n             \"powif64\" => {\n                (0,\n-                ~[ ty::mk_f64(), ty::mk_i32() ],\n+                vec!( ty::mk_f64(), ty::mk_i32() ),\n                 ty::mk_f64())\n             }\n-            \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"sinf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"sinf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"cosf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"cosf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"powf32\" => {\n                (0,\n-                ~[ ty::mk_f32(), ty::mk_f32() ],\n+                vec!( ty::mk_f32(), ty::mk_f32() ),\n                 ty::mk_f32())\n             }\n             \"powf64\" => {\n                (0,\n-                ~[ ty::mk_f64(), ty::mk_f64() ],\n+                vec!( ty::mk_f64(), ty::mk_f64() ),\n                 ty::mk_f64())\n             }\n-            \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"expf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"expf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"exp2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"exp2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"logf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"logf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"log10f32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"log10f64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"log2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"log2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n             \"fmaf32\" => {\n                 (0,\n-                 ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n+                 vec!( ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ),\n                  ty::mk_f32())\n             }\n             \"fmaf64\" => {\n                 (0,\n-                 ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n+                 vec!( ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ),\n                  ty::mk_f64())\n             }\n-            \"fabsf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"fabsf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"copysignf32\"  => (0, ~[ ty::mk_f32(), ty::mk_f32() ], ty::mk_f32()),\n-            \"copysignf64\"  => (0, ~[ ty::mk_f64(), ty::mk_f64() ], ty::mk_f64()),\n-            \"floorf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"floorf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"ceilf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"ceilf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"truncf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"truncf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"rintf32\"      => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"rintf64\"      => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"nearbyintf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"nearbyintf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"roundf32\"     => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-            \"roundf64\"     => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-            \"ctpop8\"       => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"ctpop16\"      => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"ctpop32\"      => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"ctpop64\"      => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"ctlz8\"        => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"ctlz16\"       => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"ctlz32\"       => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"ctlz64\"       => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"cttz8\"        => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-            \"cttz16\"       => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"cttz32\"       => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"cttz64\"       => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-            \"bswap16\"      => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-            \"bswap32\"      => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-            \"bswap64\"      => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"fabsf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"fabsf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"copysignf32\"  => (0, vec!( ty::mk_f32(), ty::mk_f32() ), ty::mk_f32()),\n+            \"copysignf64\"  => (0, vec!( ty::mk_f64(), ty::mk_f64() ), ty::mk_f64()),\n+            \"floorf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"floorf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"ceilf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"ceilf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"truncf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"truncf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"rintf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"rintf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"nearbyintf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n+            \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"ctpop8\"       => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"ctpop16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"ctpop32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"ctpop64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"ctlz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"ctlz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"ctlz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"ctlz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"cttz8\"        => (0, vec!( ty::mk_i8()  ), ty::mk_i8()),\n+            \"cttz16\"       => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"cttz32\"       => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"cttz64\"       => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n+            \"bswap16\"      => (0, vec!( ty::mk_i16() ), ty::mk_i16()),\n+            \"bswap32\"      => (0, vec!( ty::mk_i32() ), ty::mk_i32()),\n+            \"bswap64\"      => (0, vec!( ty::mk_i64() ), ty::mk_i64()),\n \n             \"volatile_load\" =>\n-                (1, ~[ ty::mk_imm_ptr(tcx, param(ccx, 0)) ], param(ccx, 0)),\n+                (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, ~[ ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ], ty::mk_nil()),\n+                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil()),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i8(), ty::mk_i8()],\n-                ty::mk_tup(tcx, ~[ty::mk_i8(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i8(), ty::mk_i8()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i8(), ty::mk_bool()))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i16(), ty::mk_i16()],\n-                ty::mk_tup(tcx, ~[ty::mk_i16(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i16(), ty::mk_i16()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i16(), ty::mk_bool()))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i32(), ty::mk_i32()],\n-                ty::mk_tup(tcx, ~[ty::mk_i32(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i32(), ty::mk_i32()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i32(), ty::mk_bool()))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, ~[ty::mk_i64(), ty::mk_i64()],\n-                ty::mk_tup(tcx, ~[ty::mk_i64(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_i64(), ty::mk_i64()),\n+                ty::mk_tup(tcx, vec!(ty::mk_i64(), ty::mk_bool()))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u8(), ty::mk_u8()],\n-                ty::mk_tup(tcx, ~[ty::mk_u8(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u8(), ty::mk_u8()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u8(), ty::mk_bool()))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u16(), ty::mk_u16()],\n-                ty::mk_tup(tcx, ~[ty::mk_u16(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u16(), ty::mk_u16()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u16(), ty::mk_bool()))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, ~[ty::mk_u32(), ty::mk_u32()],\n-                ty::mk_tup(tcx, ~[ty::mk_u32(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u32(), ty::mk_u32()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u32(), ty::mk_bool()))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, ~[ty::mk_u64(), ty::mk_u64()],\n-                ty::mk_tup(tcx, ~[ty::mk_u64(), ty::mk_bool()])),\n+                (0, vec!(ty::mk_u64(), ty::mk_u64()),\n+                ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n \n             ref other => {\n                 tcx.sess.span_err(it.span,"}, {"sha": "b05a876ec7a407867ddbe8a594d90e941678e200", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -74,7 +74,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n      */\n \n     let mut rr = RegionRelator { tcx: tcx,\n-                                 stack: ~[],\n+                                 stack: Vec::new(),\n                                  relate_op: relate_op };\n     match opt_region {\n         Some(o_r) => { rr.stack.push(o_r); }\n@@ -84,7 +84,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n \n     struct RegionRelator<'a> {\n         tcx: ty::ctxt,\n-        stack: ~[ty::Region],\n+        stack: Vec<ty::Region> ,\n         relate_op: 'a |ty::Region, ty::Region|,\n     }\n \n@@ -147,7 +147,7 @@ pub fn relate_free_regions(tcx: ty::ctxt, fn_sig: &ty::FnSig) {\n \n     debug!(\"relate_free_regions >>\");\n \n-    let mut all_tys = ~[];\n+    let mut all_tys = Vec::new();\n     for arg in fn_sig.inputs.iter() {\n         all_tys.push(*arg);\n     }"}, {"sha": "1905e1e387bce6e9418ca6094b67fe6db99ea044", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -132,7 +132,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     // ty is the value supplied for the type parameter A...\n-    let mut param_result = ~[];\n+    let mut param_result = Vec::new();\n \n     ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds, |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n@@ -323,7 +323,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                      -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n-    let mut found = ~[];\n+    let mut found = Vec::new();\n     let mut impls_seen = HashSet::new();\n \n     // Load the implementations from external metadata if necessary.\n@@ -336,7 +336,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         let trait_impls = tcx.trait_impls.borrow();\n         trait_impls.get()\n                    .find(&trait_ref.def_id)\n-                   .map_or(@RefCell::new(~[]), |x| *x)\n+                   .map_or(@RefCell::new(Vec::new()), |x| *x)\n     };\n     // impls is the list of all impls in scope for trait_ref.\n     let impls = impls.borrow();\n@@ -614,7 +614,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n \n                       let param_bounds = ty::ParamBounds {\n                           builtin_bounds: ty::EmptyBuiltinBounds(),\n-                          trait_bounds: ~[target_trait_ref]\n+                          trait_bounds: vec!(target_trait_ref)\n                       };\n                       let vtables =\n                             lookup_vtables_for_param(&vcx,\n@@ -625,7 +625,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, ex.id, @~[vtables]);\n+                          insert_vtables(fcx, ex.id, @vec!(vtables));\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -787,7 +787,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: ~[impl_trait_ref]\n+        trait_bounds: vec!(impl_trait_ref)\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);\n     let t = t.subst(tcx, &param_env.free_substs);"}, {"sha": "c22b06996ff43f85295525bdebd8d3f932ebfea6", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -53,7 +53,7 @@ fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n }\n \n fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n-                          -> ~[ty::t] {\n+                          -> Vec<ty::t> {\n     tys.map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n             Some(t1) => t1,\n@@ -78,7 +78,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n                     return;\n                 }\n             };\n-            let mut new_tps = ~[];\n+            let mut new_tps = Vec::new();\n             for &subst in method.substs.tps.iter() {\n                 match resolve_type_vars_in_type(fcx, sp, subst) {\n                     Some(t) => new_tps.push(t),\n@@ -242,7 +242,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n         fcx.opt_node_ty_substs(id, |substs| {\n-          let mut new_tps = ~[];\n+          let mut new_tps = Vec::new();\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n                 Some(t) => new_tps.push(t),"}, {"sha": "e64dbed1b35d0afa8f1ba8ef94fe8fd4e4785ef2", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -53,8 +53,8 @@ use std::vec;\n \n struct UniversalQuantificationResult {\n     monotype: t,\n-    type_variables: ~[ty::t],\n-    type_param_defs: Rc<~[ty::TypeParameterDef]>\n+    type_variables: Vec<ty::t> ,\n+    type_param_defs: Rc<Vec<ty::TypeParameterDef> >\n }\n \n fn get_base_type(inference_context: &InferCtxt,\n@@ -323,7 +323,7 @@ impl CoherenceChecker {\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     fn instantiate_default_methods(&self, impl_id: ast::DefId,\n                                    trait_ref: &ty::TraitRef,\n-                                   all_methods: &mut ~[@Method]) {\n+                                   all_methods: &mut Vec<@Method> ) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -354,7 +354,7 @@ impl CoherenceChecker {\n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n                 type_param_defs:\n-                    Rc::new(vec::append(\n+                    Rc::new(vec_ng::append(\n                         impl_poly_type.generics.type_param_defs().to_owned(),\n                             new_method_ty.generics.type_param_defs())),\n                 region_param_defs:\n@@ -390,7 +390,7 @@ impl CoherenceChecker {\n         let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n         match inherent_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @RefCell::new(~[]);\n+                implementation_list = @RefCell::new(Vec::new());\n                 inherent_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n@@ -409,7 +409,7 @@ impl CoherenceChecker {\n         let mut trait_impls = tcx.trait_impls.borrow_mut();\n         match trait_impls.get().find(&base_def_id) {\n             None => {\n-                implementation_list = @RefCell::new(~[]);\n+                implementation_list = @RefCell::new(Vec::new());\n                 trait_impls.get().insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n@@ -611,7 +611,7 @@ impl CoherenceChecker {\n         let tcx = self.crate_context.tcx;\n         match item.node {\n             ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n-                let mut methods = ~[];\n+                let mut methods = Vec::new();\n                 for ast_method in ast_methods.iter() {\n                     methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }"}, {"sha": "9bfa89819ae898cd1fa13419f02abd01177f270d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -336,7 +336,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         // the substitution to any traits that appear in their bounds.\n \n         // add in the type parameters from the trait\n-        let mut new_type_param_defs = ~[];\n+        let mut new_type_param_defs = Vec::new();\n         let substd_type_param_defs =\n             trait_ty_generics.type_param_defs.subst(tcx, &substs);\n         new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n@@ -349,7 +349,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n             def_id: dummy_defid,\n             bounds: @ty::ParamBounds {\n                 builtin_bounds: ty::EmptyBuiltinBounds(),\n-                trait_bounds: ~[self_trait_ref]\n+                trait_bounds: vec!(self_trait_ref)\n             },\n             default: None\n         });\n@@ -420,7 +420,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n-    let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    let mut ty_trait_refs: Vec<@ty::TraitRef> = Vec::new();\n     let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n@@ -494,7 +494,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                 // itself\n                 ty_param_bounds_and_ty {\n                     generics: ty::Generics {\n-                        type_param_defs: Rc::new(vec::append(\n+                        type_param_defs: Rc::new(vec_ng::append(\n                             rcvr_ty_generics.type_param_defs().to_owned(),\n                             m_ty_generics.type_param_defs())),\n                         region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n@@ -860,7 +860,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let tpt = ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: ty_generics.type_param_defs.clone(),\n-                    region_param_defs: Rc::new(~[]),\n+                    region_param_defs: Rc::new(Vec::new()),\n                 },\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n@@ -946,8 +946,8 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n-                    type_param_defs: Rc::new(~[]),\n-                    region_param_defs: Rc::new(~[]),\n+                    type_param_defs: Rc::new(Vec::new()),\n+                    region_param_defs: Rc::new(Vec::new()),\n                 },\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n@@ -1008,7 +1008,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n \n         let mut param_bounds = ty::ParamBounds {\n             builtin_bounds: ty::EmptyBuiltinBounds(),\n-            trait_bounds: ~[]\n+            trait_bounds: Vec::new()\n         };\n         for ast_bound in ast_bounds.iter() {\n             match *ast_bound {\n@@ -1083,7 +1083,7 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n                       ty_generics: &ty::Generics,\n                       self_ty: Option<ty::t>) -> ty::substs\n {\n-    let params: ~[ty::t] =\n+    let params: Vec<ty::t> =\n         ty_generics.type_param_defs().iter().enumerate().map(\n             |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n "}, {"sha": "076a10fcbfd060a865722da6160bdbb301447e9d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -82,7 +82,7 @@ pub trait Combine {\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n \n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<Vec<ty::t> > {\n \n         // Note: type parameters are always treated as *invariant*\n         // (otherwise the type system would be unsound).  In the\n@@ -396,7 +396,7 @@ pub fn eq_opt_regions<C:Combine>(\n \n pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n-    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n+    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n         if a_args.len() == b_args.len() {\n             result::collect(a_args.iter().zip(b_args.iter())\n                             .map(|(a, b)| this.args(*a, *b)))"}, {"sha": "48bd78457096d78df863f548f941dcc14e10ca5a", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -522,7 +522,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n \n pub fn var_ids<T:Combine>(this: &T,\n                           map: &HashMap<ty::BoundRegion, ty::Region>)\n-                          -> ~[RegionVid] {\n+                          -> Vec<RegionVid> {\n     map.iter().map(|(_, r)| match *r {\n             ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {"}, {"sha": "03db6882a798422aac898f0f064dc23a6bbb5a79", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -260,7 +260,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n         vals: SmallIntMap::new(),\n-        bindings: ~[]\n+        bindings: Vec::new()\n     }\n }\n \n@@ -622,7 +622,7 @@ impl InferCtxt {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n+    pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n@@ -659,7 +659,7 @@ impl InferCtxt {\n     pub fn next_region_vars(&self,\n                             origin: RegionVariableOrigin,\n                             count: uint)\n-                            -> ~[ty::Region] {\n+                            -> Vec<ty::Region> {\n         vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n "}, {"sha": "88c234eb10f143f5462fbd37d0e6311dadc5698e", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -88,7 +88,7 @@ pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_origins: RefCell<~[RegionVariableOrigin]>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin> >,\n     constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n@@ -103,24 +103,24 @@ pub struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    undo_log: RefCell<~[UndoLogEntry]>,\n+    undo_log: RefCell<Vec<UndoLogEntry> >,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: RefCell<Option<~[VarValue]>>,\n+    values: RefCell<Option<Vec<VarValue> >>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_origins: RefCell::new(~[]),\n+        var_origins: RefCell::new(Vec::new()),\n         values: RefCell::new(None),\n         constraints: RefCell::new(HashMap::new()),\n         lubs: RefCell::new(HashMap::new()),\n         glbs: RefCell::new(HashMap::new()),\n         skolemization_count: Cell::new(0),\n         bound_count: Cell::new(0),\n-        undo_log: RefCell::new(~[])\n+        undo_log: RefCell::new(Vec::new())\n     }\n }\n \n@@ -423,7 +423,7 @@ impl RegionVarBindings {\n     }\n \n     pub fn vars_created_since_snapshot(&self, snapshot: uint)\n-                                       -> ~[RegionVid] {\n+                                       -> Vec<RegionVid> {\n         let undo_log = self.undo_log.borrow();\n         undo_log.get().slice_from(snapshot).iter()\n             .filter_map(|&elt| match elt {\n@@ -433,7 +433,7 @@ impl RegionVarBindings {\n             .collect()\n     }\n \n-    pub fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n+    pub fn tainted(&self, snapshot: uint, r0: Region) -> Vec<Region> {\n         /*!\n          * Computes all regions that have been related to `r0` in any\n          * way since the snapshot `snapshot` was taken---`r0` itself\n@@ -453,7 +453,7 @@ impl RegionVarBindings {\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = ~[r0];\n+        let mut result_set = vec!(r0);\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n@@ -504,11 +504,10 @@ impl RegionVarBindings {\n \n         return result_set;\n \n-        fn consider_adding_edge(result_set: ~[Region],\n+        fn consider_adding_edge(result_set: Vec<Region> ,\n                                 r: Region,\n                                 r1: Region,\n-                                r2: Region) -> ~[Region]\n-        {\n+                                r2: Region) -> Vec<Region> {\n             let mut result_set = result_set;\n             if r == r1 { // Clearly, this is potentially inefficient.\n                 if !result_set.iter().any(|x| *x == r2) {\n@@ -781,15 +780,15 @@ type RegionGraph = graph::Graph<(), Constraint>;\n impl RegionVarBindings {\n     fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n-                             -> ~[VarValue] {\n+                             -> Vec<VarValue> {\n         let mut var_data = self.construct_var_data();\n         self.expansion(var_data);\n         self.contraction(var_data);\n         self.collect_concrete_region_errors(errors);\n         self.extract_values_and_collect_conflicts(var_data, errors)\n     }\n \n-    fn construct_var_data(&self) -> ~[VarData] {\n+    fn construct_var_data(&self) -> Vec<VarData> {\n         vec::from_fn(self.num_vars(), |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n@@ -999,8 +998,7 @@ impl RegionVarBindings {\n         &self,\n         var_data: &[VarData],\n         errors: &mut OptVec<RegionResolutionError>)\n-        -> ~[VarValue]\n-    {\n+        -> Vec<VarValue> {\n         debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n@@ -1218,17 +1216,17 @@ impl RegionVarBindings {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n-                                -> (~[RegionAndOrigin], bool) {\n+                                -> (Vec<RegionAndOrigin> , bool) {\n         struct WalkState {\n             set: HashSet<RegionVid>,\n-            stack: ~[RegionVid],\n-            result: ~[RegionAndOrigin],\n+            stack: Vec<RegionVid> ,\n+            result: Vec<RegionAndOrigin> ,\n             dup_found: bool\n         }\n         let mut state = WalkState {\n             set: HashSet::new(),\n-            stack: ~[orig_node_idx],\n-            result: ~[],\n+            stack: vec!(orig_node_idx),\n+            result: Vec::new(),\n             dup_found: false\n         };\n         state.set.insert(orig_node_idx);"}, {"sha": "f698f988c40fe7bd6d6655cb61be032538cb73ac", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -83,7 +83,7 @@ pub struct ResolveState<'a> {\n     infcx: &'a InferCtxt,\n     modes: uint,\n     err: Option<fixup_err>,\n-    v_seen: ~[TyVid],\n+    v_seen: Vec<TyVid> ,\n     type_depth: uint\n }\n \n@@ -92,7 +92,7 @@ pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n         infcx: infcx,\n         modes: modes,\n         err: None,\n-        v_seen: ~[],\n+        v_seen: Vec::new(),\n         type_depth: 0\n     }\n }"}, {"sha": "a3f44c9a06906a4961c0de5c359c6a6e20e17b5d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -46,7 +46,7 @@ static EMPTY_SOURCE_STR: &str = \"/* Hello, world! */\";\n \n fn setup_env(test_name: &str, source_string: &str) -> Env {\n     let messages = @DVec();\n-    let matches = getopts(~[~\"-Z\", ~\"verbose\"], optgroups()).get();\n+    let matches = getopts(vec!(~\"-Z\", ~\"verbose\"), optgroups()).get();\n     let diag = diagnostic::collect(messages);\n     let sessopts = build_session_options(~\"rustc\", &matches, diag);\n     let sess = build_session(sessopts, None, diag);\n@@ -186,7 +186,7 @@ impl Env {\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n                           region: ty::ReStatic,\n-                          bounds: @~[]},\n+                          bounds: @Vec::new()},\n             sig: FnSig {\n                 inputs: inputs,\n                 output: output_ty,"}, {"sha": "5241830ec771ffa4978b8bff6d1b9ac177b29f6f", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -27,7 +27,7 @@ pub enum VarValue<V, T> {\n \n pub struct ValsAndBindings<V, T> {\n     vals: SmallIntMap<VarValue<V, T>>,\n-    bindings: ~[(V, VarValue<V, T>)],\n+    bindings: Vec<(V, VarValue<V, T>)> ,\n }\n \n pub struct Node<V, T> {"}, {"sha": "a21ba0b7a2c17314f337b4ce6188e88f226420d7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -152,9 +152,9 @@ pub struct MethodCallee {\n // of the method to be invoked\n pub type MethodMap = @RefCell<NodeMap<MethodCallee>>;\n \n-pub type vtable_param_res = @~[vtable_origin];\n+pub type vtable_param_res = @Vec<vtable_origin> ;\n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = @~[vtable_param_res];\n+pub type vtable_res = @Vec<vtable_param_res> ;\n \n #[deriving(Clone)]\n pub enum vtable_origin {\n@@ -163,7 +163,7 @@ pub enum vtable_origin {\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself\n      */\n-    vtable_static(ast::DefId, ~[ty::t], vtable_res),\n+    vtable_static(ast::DefId, Vec<ty::t> , vtable_res),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -235,7 +235,7 @@ pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n-                           substs: ~[ty::t]) {\n+                           substs: Vec<ty::t> ) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n@@ -271,8 +271,8 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n \n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n-        generics: ty::Generics {type_param_defs: Rc::new(~[]),\n-                                region_param_defs: Rc::new(~[])},\n+        generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n+                                region_param_defs: Rc::new(Vec::new())},\n         ty: t\n     }\n }\n@@ -352,7 +352,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n-                    inputs: ~[],\n+                    inputs: Vec::new(),\n                     output: ty::mk_nil(),\n                     variadic: false\n                 }\n@@ -398,10 +398,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: start_id,\n-                    inputs: ~[\n+                    inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n-                    ],\n+                    ),\n                     output: ty::mk_int(),\n                     variadic: false\n                 }"}, {"sha": "fb391fe6fc8e593c37ff973d9f7c94d16db67371", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -31,7 +31,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint)\n-                    -> Result<~[ty::Region], ()>;\n+                    -> Result<Vec<ty::Region> , ()>;\n }\n \n // A scope in which all regions must be explicitly named\n@@ -41,7 +41,7 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n-                    -> Result<~[ty::Region], ()> {\n+                    -> Result<Vec<ty::Region> , ()> {\n         Err(())\n     }\n }\n@@ -66,7 +66,7 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: uint)\n-                    -> Result<~[ty::Region], ()> {\n+                    -> Result<Vec<ty::Region> , ()> {\n         let idx = self.anon_bindings.get();\n         self.anon_bindings.set(idx + count);\n         Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,"}, {"sha": "829a4c2f316deba40ddbabdc2ecf4de0619f9218", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -261,7 +261,7 @@ struct TermsContext<'a> {\n     inferred_map: HashMap<ast::NodeId, InferredIndex>,\n \n     // Maps from an InferredIndex to the info for that variable.\n-    inferred_infos: ~[InferredInfo<'a>],\n+    inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n enum ParamKind { TypeParam, RegionParam, SelfParam }\n@@ -282,7 +282,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n         tcx: tcx,\n         arena: arena,\n         inferred_map: HashMap::new(),\n-        inferred_infos: ~[],\n+        inferred_infos: Vec::new(),\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n@@ -410,7 +410,7 @@ struct ConstraintContext<'a> {\n     invariant: VarianceTermPtr<'a>,\n     bivariant: VarianceTermPtr<'a>,\n \n-    constraints: ~[Constraint<'a>],\n+    constraints: Vec<Constraint<'a>> ,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -457,7 +457,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n         contravariant: contravariant,\n         invariant: invariant,\n         bivariant: bivariant,\n-        constraints: ~[],\n+        constraints: Vec::new(),\n     };\n     visit::walk_crate(&mut constraint_cx, krate, ());\n     constraint_cx\n@@ -835,11 +835,10 @@ impl<'a> ConstraintContext<'a> {\n \n struct SolveContext<'a> {\n     terms_cx: TermsContext<'a>,\n-    constraints: ~[Constraint<'a>],\n+    constraints: Vec<Constraint<'a>> ,\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n-    solutions: ~[ty::Variance]\n-}\n+    solutions: Vec<ty::Variance> }\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;"}, {"sha": "732723fec9cd51105a71760f341285aff678202c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -66,7 +66,7 @@ pub fn indenter() -> _indenter {\n \n pub fn field_expr(f: ast::Field) -> @ast::Expr { return f.expr; }\n \n-pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n+pub fn field_exprs(fields: Vec<ast::Field> ) -> Vec<@ast::Expr> {\n     fields.map(|f| f.expr)\n }\n "}, {"sha": "c6ccb4275add4a35ae0dfae0057cc17cf59d1bc7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -501,7 +501,7 @@ pub fn parameterized(cx: ctxt,\n                      did: ast::DefId,\n                      is_trait: bool) -> ~str {\n \n-    let mut strs = ~[];\n+    let mut strs = Vec::new();\n     match *regions {\n         ty::ErasedRegions => { }\n         ty::NonerasedRegions(ref regions) => {\n@@ -610,7 +610,7 @@ impl<T:Repr> Repr for OptVec<T> {\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n-impl<T:Repr> Repr for ~[T] {\n+impl<T:Repr> Repr for Vec<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         repr_vec(tcx, *self)\n     }\n@@ -658,7 +658,7 @@ impl Repr for ty::RegionSubsts {\n \n impl Repr for ty::ParamBounds {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        let mut res = ~[];\n+        let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n                 ty::BoundStatic => ~\"'static\",\n@@ -973,7 +973,7 @@ impl<A:UserString> UserString for @A {\n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n-            let mut result = ~[];\n+            let mut result = Vec::new();\n             for bb in self.iter() {\n                 result.push(bb.user_string(tcx));\n             }"}, {"sha": "8b0b08d9cc30236bee2e528e0f5ab63673dee181", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "patch": "@@ -253,7 +253,7 @@ pub trait Digest {\n \n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n-    fn result_bytes(&mut self) -> ~[u8] {\n+    fn result_bytes(&mut self) -> Vec<u8> {\n         let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n         self.result(buf);\n         buf\n@@ -576,7 +576,7 @@ mod tests {\n     #[test]\n     fn test_sha256() {\n         // Examples from wikipedia\n-        let wikipedia_tests = ~[\n+        let wikipedia_tests = vec!(\n             Test {\n                 input: ~\"\",\n                 output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n@@ -588,8 +588,7 @@ mod tests {\n             Test {\n                 input: ~\"The quick brown fox jumps over the lazy dog.\",\n                 output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n-            },\n-        ];\n+            });\n \n         let tests = wikipedia_tests;\n "}]}