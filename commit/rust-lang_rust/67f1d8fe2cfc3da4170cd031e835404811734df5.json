{"sha": "67f1d8fe2cfc3da4170cd031e835404811734df5", "node_id": "C_kwDOAAsO6NoAKDY3ZjFkOGZlMmNmYzNkYTQxNzBjZDAzMWU4MzU0MDQ4MTE3MzRkZjU", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-25T12:20:16Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-25T14:28:40Z"}, "message": "Test all generic args for trait when finding matching impl", "tree": {"sha": "f966b2e3c4f074a6e6a05ff33dc2979388633037", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f966b2e3c4f074a6e6a05ff33dc2979388633037"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67f1d8fe2cfc3da4170cd031e835404811734df5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmNX8pgACgkQ4laYqTBY\nYXEMohAAsNmLRe41OCU+WyThiQ7QBttf3STkEoAdGpgwnkvO3SkQl14c2FQLhb4e\nm8iQhTAXL4aR0j6rloKaCvBXgJ1WcvDVazh7hh1oxGvVrlZ9uAIarODQyuwq/9jC\nwc6fYaQNLgyItnICTpKgeap3m2QKRcHRRw3LyBJiLiOLTo0V20x0TLg3JcsCcbSX\nk9Hy/X1gVUBq8WoxycducQ84zRNbpua1gn7tQotVG+dKTq9aLVRDHbEsKp/7F8fJ\nLnS4cI1AGuqdPm33JNB0lUwTTI6JWpW93og8tZJqqaUxza/0WsLn20993oIvtLhy\nscga2BcMGNrFENpQ4WcFeHJ4Pklkg8mTiRnSRgEmmN7Cxz314893Oz6oRNwx8eNS\n099asQmhfuB4cy/Le0cMklnhIy4Pon/09UPhvDMXIkKFPoTj/7/nl8eTkKAS7LvC\n/EqCkMAKVk0FgE9l8WO8ZokMuGfnT2XYgxxYQgU0GQcUQga1R/ySZGn6lxOb6g/S\nFa36GJ6EeCUAn9+0QmmItDgWTf3CkIeJ9Lc4q0ku0fsE/XD1J1IhpIuk5D9c95lF\nHGXlhWHPNYsZuowYWgAsd8KvRwkPHp2CflFGMabjBVjLzKweMYhlYUsaq7W1CPJJ\njCjQykncqGEaDRjJdPx/zQVKsLVHwrdnLxdQUjVKZQzKJU+SEl0=\n=L/0G\n-----END PGP SIGNATURE-----", "payload": "tree f966b2e3c4f074a6e6a05ff33dc2979388633037\nparent 15d4383053307a983ea81197ec2a313bc9a471d9\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1666700416 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1666708120 +0900\n\nTest all generic args for trait when finding matching impl\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67f1d8fe2cfc3da4170cd031e835404811734df5", "html_url": "https://github.com/rust-lang/rust/commit/67f1d8fe2cfc3da4170cd031e835404811734df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67f1d8fe2cfc3da4170cd031e835404811734df5/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15d4383053307a983ea81197ec2a313bc9a471d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d4383053307a983ea81197ec2a313bc9a471d9", "html_url": "https://github.com/rust-lang/rust/commit/15d4383053307a983ea81197ec2a313bc9a471d9"}], "stats": {"total": 218, "additions": 156, "deletions": 62}, "files": [{"sha": "b1178ba0d2af78d8a80e274c58f0989003445327", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=67f1d8fe2cfc3da4170cd031e835404811734df5", "patch": "@@ -22,10 +22,10 @@ use crate::{\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n-    static_lifetime,\n+    static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -624,52 +624,76 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+/// Looks up the impl method that actually runs for the trait method `func`.\n+///\n+/// Returns `func` if it's not a method defined in a trait or the lookup failed.\n pub fn lookup_impl_method(\n-    self_ty: &Ty,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: TraitId,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> FunctionId {\n+    let trait_id = match func.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return func,\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+\n+    let name = &db.function_data(func).name;\n+    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+}\n+\n+fn lookup_impl_method_for_trait_ref(\n+    trait_ref: TraitRef,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: &Name,\n ) -> Option<FunctionId> {\n-    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n-    let trait_impls = db.trait_impls_in_deps(env.krate);\n-    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n-    let mut table = InferenceTable::new(db, env.clone());\n-    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n-        data.items.iter().find_map(|it| match it {\n-            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n-            _ => None,\n-        })\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n+    let impls = db.trait_impls_in_deps(env.krate);\n+    let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n+\n+    let table = InferenceTable::new(db, env);\n+\n+    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n+    impl_data.items.iter().find_map(|it| match it {\n+        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        _ => None,\n     })\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n-    table: &mut InferenceTable<'_>,\n-    self_ty: &Ty,\n+    mut table: InferenceTable<'_>,\n+    actual_trait_ref: TraitRef,\n ) -> Option<Arc<ImplData>> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n-            let substs =\n+            let impl_substs =\n                 TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n-            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n-\n-            table\n-                .unify(self_ty, &impl_ty)\n-                .then(|| {\n-                    let wh_goals =\n-                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                            .into_iter()\n-                            .map(|b| b.cast(Interner));\n+            let trait_ref = db\n+                .impl_trait(impl_)\n+                .expect(\"non-trait method in find_matching_impl\")\n+                .substitute(Interner, &impl_substs);\n \n-                    let goal = crate::Goal::all(Interner, wh_goals);\n+            if !table.unify(&trait_ref, &actual_trait_ref) {\n+                return None;\n+            }\n \n-                    table.try_obligation(goal).map(|_| impl_data)\n-                })\n-                .flatten()\n+            let wcs = crate::chalk_db::convert_where_clauses(db, impl_.into(), &impl_substs)\n+                .into_iter()\n+                .map(|b| b.cast(Interner));\n+            let goal = crate::Goal::all(Interner, wcs);\n+            table.try_obligation(goal).map(|_| impl_data)\n         });\n         if r.is_some() {\n             break r;"}, {"sha": "f86c571005367e5b4015472c55d1b8fd694c2d99", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=67f1d8fe2cfc3da4170cd031e835404811734df5", "patch": "@@ -270,7 +270,7 @@ impl SourceAnalyzer {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n \n-        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs))\n     }\n \n     pub(crate) fn resolve_await_to_poll(\n@@ -311,7 +311,7 @@ impl SourceAnalyzer {\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n-        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, substs))\n     }\n \n     pub(crate) fn resolve_prefix_expr(\n@@ -331,7 +331,7 @@ impl SourceAnalyzer {\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_index_expr(\n@@ -351,7 +351,7 @@ impl SourceAnalyzer {\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_bin_expr(\n@@ -372,7 +372,7 @@ impl SourceAnalyzer {\n             .push(rhs.clone())\n             .build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_try_expr(\n@@ -392,7 +392,7 @@ impl SourceAnalyzer {\n         // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -497,9 +497,12 @@ impl SourceAnalyzer {\n                                 None => assoc,\n                                 Some(func_ty) => {\n                                     if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n-                                        self.resolve_impl_method(db, f_in_trait, subs)\n-                                            .map(AssocItemId::FunctionId)\n-                                            .unwrap_or(assoc)\n+                                        self.resolve_impl_method_or_trait_def(\n+                                            db,\n+                                            f_in_trait,\n+                                            subs.clone(),\n+                                        )\n+                                        .into()\n                                     } else {\n                                         assoc\n                                     }\n@@ -779,37 +782,22 @@ impl SourceAnalyzer {\n         false\n     }\n \n-    fn resolve_impl_method(\n+    fn resolve_impl_method_or_trait_def(\n         &self,\n         db: &dyn HirDatabase,\n         func: FunctionId,\n-        substs: &Substitution,\n-    ) -> Option<FunctionId> {\n-        let impled_trait = match func.lookup(db.upcast()).container {\n-            ItemContainerId::TraitId(trait_id) => trait_id,\n-            _ => return None,\n-        };\n-        if substs.is_empty(Interner) {\n-            return None;\n-        }\n-        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        substs: Substitution,\n+    ) -> FunctionId {\n         let krate = self.resolver.krate();\n-        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return func,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-\n-        let fun_data = db.function_data(func);\n-        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n-    }\n-\n-    fn resolve_impl_method_or_trait_def(\n-        &self,\n-        db: &dyn HirDatabase,\n-        func: FunctionId,\n-        substs: &Substitution,\n-    ) -> FunctionId {\n-        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+        method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n     fn lang_trait_fn("}, {"sha": "f97c67b144ac15e4c67d8ee86d2a6563ebdda77d", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f1d8fe2cfc3da4170cd031e835404811734df5/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=67f1d8fe2cfc3da4170cd031e835404811734df5", "patch": "@@ -1834,4 +1834,86 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_bin_op_multiple_impl() {\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 S\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 0usize\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn path_call_multiple_trait_impl() {\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+     //^\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+}\n+fn main() {\n+    usize::f$0(0i32);\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+     //^\n+}\n+fn main() {\n+    usize::f$0(0i64);\n+}\n+\"#,\n+        )\n+    }\n }"}]}