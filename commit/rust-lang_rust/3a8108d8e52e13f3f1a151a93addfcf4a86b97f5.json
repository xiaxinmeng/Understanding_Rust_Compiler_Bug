{"sha": "3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhODEwOGQ4ZTUyZTEzZjNmMWExNTFhOTNhZGRmY2Y0YTg2Yjk3ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-19T04:57:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-19T04:57:10Z"}, "message": "Auto merge of #69113 - ecstatic-morse:unified-dataflow-borrowed, r=wesleywiser\n\nCombine `HaveBeenBorrowedLocals` and `IndirectlyMutableLocals` into one dataflow analysis\n\nThis PR began as an attempt to port `HaveBeenBorrowedLocals` to the new dataflow framework (see #68241 for prior art). Along the way, I noticed that it could share most of its code with `IndirectlyMutableLocals` and then found a few bugs in the two analyses:\n- Neither one marked locals as borrowed after an `Rvalue::AddressOf`.\n- `IndirectlyMutableLocals` was missing a minor fix that `HaveBeenBorrowedLocals` got in #61069. This is not a problem today since it is only used during const-checking, where custom drop glue is forbidden. However, this may change some day.\n\nI decided to combine the two analyses so that they wouldn't diverge in the future while ensuring that they remain distinct types (called `MaybeBorrowedLocals` and `MaybeMutBorrowedLocals` to be consistent with the `Maybe{Un,}InitializedPlaces` naming scheme). I fixed the bugs and switched to exhaustive matching where possible to make them less likely in the future. Finally, I added comments explaining some of the finer points of the transfer function for these analyses (see #61069 and #65006).", "tree": {"sha": "cc8222823aa713e37dbc4bf0c0444bbd16377a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc8222823aa713e37dbc4bf0c0444bbd16377a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "html_url": "https://github.com/rust-lang/rust/commit/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2fb0c28be794f28028884650db70c17fea8e35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fb0c28be794f28028884650db70c17fea8e35b", "html_url": "https://github.com/rust-lang/rust/commit/a2fb0c28be794f28028884650db70c17fea8e35b"}, {"sha": "077a93c6a9b1c8ee0e541ea484f7e13c207d50d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/077a93c6a9b1c8ee0e541ea484f7e13c207d50d0", "html_url": "https://github.com/rust-lang/rust/commit/077a93c6a9b1c8ee0e541ea484f7e13c207d50d0"}], "stats": {"total": 584, "additions": 304, "deletions": 280}, "files": [{"sha": "23b22550a3b0e4c180135b198a0f21c8c4fa4fd6", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -395,5 +395,16 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+// For compatibility with old framework\n+impl<T: Idx> GenKill<T> for crate::dataflow::GenKillSet<T> {\n+    fn gen(&mut self, elem: T) {\n+        self.gen(elem);\n+    }\n+\n+    fn kill(&mut self, elem: T) {\n+        self.kill(elem);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "95a676c0892c5472983d030c628452ec600980ac", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 232, "deletions": 60, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -1,102 +1,274 @@\n pub use super::*;\n \n-use crate::dataflow::{BitDenotation, GenKillSet};\n+use crate::dataflow::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc::mir::visit::Visitor;\n use rustc::mir::*;\n+use rustc::ty::{ParamEnv, TyCtxt};\n+use rustc_span::DUMMY_SP;\n \n-/// This calculates if any part of a MIR local could have previously been borrowed.\n-/// This means that once a local has been borrowed, its bit will be set\n-/// from that point and onwards, until we see a StorageDead statement for the local,\n-/// at which points there is no memory associated with the local, so it cannot be borrowed.\n-/// This is used to compute which locals are live during a yield expression for\n-/// immovable generators.\n-#[derive(Copy, Clone)]\n-pub struct HaveBeenBorrowedLocals<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n+pub type MaybeMutBorrowedLocals<'mir, 'tcx> = MaybeBorrowedLocals<MutBorrow<'mir, 'tcx>>;\n+\n+/// A dataflow analysis that tracks whether a pointer or reference could possibly exist that points\n+/// to a given local.\n+///\n+/// The `K` parameter determines what kind of borrows are tracked. By default,\n+/// `MaybeBorrowedLocals` looks for *any* borrow of a local. If you are only interested in borrows\n+/// that might allow mutation, use the `MaybeMutBorrowedLocals` type alias instead.\n+///\n+/// At present, this is used as a very limited form of alias analysis. For example,\n+/// `MaybeBorrowedLocals` is used to compute which locals are live during a yield expression for\n+/// immovable generators. `MaybeMutBorrowedLocals` is used during const checking to prove that a\n+/// local has not been mutated via indirect assignment (e.g., `*p = 42`), the side-effects of a\n+/// function call or inline assembly.\n+pub struct MaybeBorrowedLocals<K = AnyBorrow> {\n+    kind: K,\n+    ignore_borrow_on_drop: bool,\n+}\n+\n+impl MaybeBorrowedLocals {\n+    /// A dataflow analysis that records whether a pointer or reference exists that may alias the\n+    /// given local.\n+    pub fn all_borrows() -> Self {\n+        MaybeBorrowedLocals { kind: AnyBorrow, ignore_borrow_on_drop: false }\n+    }\n+}\n+\n+impl MaybeMutBorrowedLocals<'mir, 'tcx> {\n+    /// A dataflow analysis that records whether a pointer or reference exists that may *mutably*\n+    /// alias the given local.\n+    ///\n+    /// This includes `&mut` and pointers derived from an `&mut`, as well as shared borrows of\n+    /// types with interior mutability.\n+    pub fn mut_borrows_only(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Self {\n+        MaybeBorrowedLocals {\n+            kind: MutBorrow { body, tcx, param_env },\n+            ignore_borrow_on_drop: false,\n+        }\n+    }\n }\n \n-impl<'a, 'tcx> HaveBeenBorrowedLocals<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>) -> Self {\n-        HaveBeenBorrowedLocals { body }\n+impl<K> MaybeBorrowedLocals<K> {\n+    /// During dataflow analysis, ignore the borrow that may occur when a place is dropped.\n+    ///\n+    /// Drop terminators may call custom drop glue (`Drop::drop`), which takes `&mut self` as a\n+    /// parameter. In the general case, a drop impl could launder that reference into the\n+    /// surrounding environment through a raw pointer, thus creating a valid `*mut` pointing to the\n+    /// dropped local. We are not yet willing to declare this particular case UB, so we must treat\n+    /// all dropped locals as mutably borrowed for now. See discussion on [#61069].\n+    ///\n+    /// In some contexts, we know that this borrow will never occur. For example, during\n+    /// const-eval, custom drop glue cannot be run. Code that calls this should document the\n+    /// assumptions that justify ignoring `Drop` terminators in this way.\n+    ///\n+    /// [#61069]: https://github.com/rust-lang/rust/pull/61069\n+    pub fn unsound_ignore_borrow_on_drop(self) -> Self {\n+        MaybeBorrowedLocals { ignore_borrow_on_drop: true, ..self }\n     }\n \n-    pub fn body(&self) -> &Body<'tcx> {\n-        self.body\n+    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T, K> {\n+        TransferFunction {\n+            kind: &self.kind,\n+            trans,\n+            ignore_borrow_on_drop: self.ignore_borrow_on_drop,\n+        }\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n+impl<K> AnalysisDomain<'tcx> for MaybeBorrowedLocals<K>\n+where\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n     type Idx = Local;\n-    fn name() -> &'static str {\n-        \"has_been_borrowed_locals\"\n+\n+    const NAME: &'static str = K::ANALYSIS_NAME;\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls().len()\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+        // No locals are aliased on function entry\n+    }\n+}\n+\n+impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n+where\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_statement(statement, location);\n     }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_terminator(terminator, location);\n     }\n \n-    fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n-        // Nothing is borrowed on function entry\n+    fn call_return_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n     }\n+}\n+\n+impl<K> BottomValue for MaybeBorrowedLocals<K> {\n+    // bottom = unborrowed\n+    const BOTTOM_VALUE: bool = false;\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+/// A `Visitor` that defines the transfer function for `MaybeBorrowedLocals`.\n+struct TransferFunction<'a, T, K> {\n+    trans: &'a mut T,\n+    kind: &'a K,\n+    ignore_borrow_on_drop: bool,\n+}\n \n-        BorrowedLocalsVisitor { trans }.visit_statement(stmt, loc);\n+impl<T, K> Visitor<'tcx> for TransferFunction<'a, T, K>\n+where\n+    T: GenKill<Local>,\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n+    fn visit_statement(&mut self, stmt: &Statement<'tcx>, location: Location) {\n+        self.super_statement(stmt, location);\n \n-        // StorageDead invalidates all borrows and raw pointers to a local\n-        match stmt.kind {\n-            StatementKind::StorageDead(l) => trans.kill(l),\n-            _ => (),\n+        // When we reach a `StorageDead` statement, we can assume that any pointers to this memory\n+        // are now invalid.\n+        if let StatementKind::StorageDead(local) = stmt.kind {\n+            self.trans.kill(local);\n         }\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let terminator = self.body[loc.block].terminator();\n-        BorrowedLocalsVisitor { trans }.visit_terminator(terminator, loc);\n-        match &terminator.kind {\n-            // Drop terminators borrows the location\n-            TerminatorKind::Drop { location, .. }\n-            | TerminatorKind::DropAndReplace { location, .. } => {\n-                if let Some(local) = find_local(location) {\n-                    trans.gen(local);\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match rvalue {\n+            mir::Rvalue::AddressOf(mt, borrowed_place) => {\n+                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, borrowed_place) {\n+                    self.trans.gen(borrowed_place.local);\n                 }\n             }\n-            _ => (),\n+\n+            mir::Rvalue::Ref(_, kind, borrowed_place) => {\n+                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, borrowed_place) {\n+                    self.trans.gen(borrowed_place.local);\n+                }\n+            }\n+\n+            mir::Rvalue::Cast(..)\n+            | mir::Rvalue::Use(..)\n+            | mir::Rvalue::Repeat(..)\n+            | mir::Rvalue::Len(..)\n+            | mir::Rvalue::BinaryOp(..)\n+            | mir::Rvalue::CheckedBinaryOp(..)\n+            | mir::Rvalue::NullaryOp(..)\n+            | mir::Rvalue::UnaryOp(..)\n+            | mir::Rvalue::Discriminant(..)\n+            | mir::Rvalue::Aggregate(..) => {}\n         }\n     }\n \n-    fn propagate_call_return(\n-        &self,\n-        _in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n-    ) {\n-        // Nothing to do when a call returns successfully\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n+\n+        match terminator.kind {\n+            mir::TerminatorKind::Drop { location: dropped_place, .. }\n+            | mir::TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+                // See documentation for `unsound_ignore_borrow_on_drop` for an explanation.\n+                if !self.ignore_borrow_on_drop {\n+                    self.trans.gen(dropped_place.local);\n+                }\n+            }\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. } => {}\n+        }\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    // bottom = unborrowed\n-    const BOTTOM_VALUE: bool = false;\n+pub struct AnyBorrow;\n+\n+pub struct MutBorrow<'mir, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir Body<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+}\n+\n+impl MutBorrow<'mir, 'tcx> {\n+    /// `&` and `&raw` only allow mutation if the borrowed place is `!Freeze`.\n+    ///\n+    /// This assumes that it is UB to take the address of a struct field whose type is\n+    /// `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n+    /// that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n+    /// have to check the type of the borrowed **local** instead of the borrowed **place**\n+    /// below. See [rust-lang/unsafe-code-guidelines#134].\n+    ///\n+    /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n+    fn shared_borrow_allows_mutation(&self, place: &Place<'tcx>) -> bool {\n+        !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx, self.param_env, DUMMY_SP)\n+    }\n }\n \n-struct BorrowedLocalsVisitor<'gk> {\n-    trans: &'gk mut GenKillSet<Local>,\n+pub trait BorrowAnalysisKind<'tcx> {\n+    const ANALYSIS_NAME: &'static str;\n+\n+    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool;\n+    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool;\n }\n \n-fn find_local(place: &Place<'_>) -> Option<Local> {\n-    if !place.is_indirect() { Some(place.local) } else { None }\n+impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n+    const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n+\n+    fn in_ref(&self, _: mir::BorrowKind, _: &Place<'_>) -> bool {\n+        true\n+    }\n+    fn in_address_of(&self, _: Mutability, _: &Place<'_>) -> bool {\n+        true\n+    }\n }\n \n-impl<'tcx> Visitor<'tcx> for BorrowedLocalsVisitor<'_> {\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, ref place) = *rvalue {\n-            if let Some(local) = find_local(place) {\n-                self.trans.gen(local);\n+impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n+    const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n+\n+    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool {\n+        match kind {\n+            mir::BorrowKind::Mut { .. } => true,\n+            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n+                self.shared_borrow_allows_mutation(place)\n             }\n         }\n+    }\n \n-        self.super_rvalue(rvalue, location)\n+    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool {\n+        match mt {\n+            Mutability::Mut => true,\n+            Mutability::Not => self.shared_borrow_allows_mutation(place),\n+        }\n     }\n }"}, {"sha": "85bf342c8a39a95da5efd20d1367a1656cd88247", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a2fb0c28be794f28028884650db70c17fea8e35b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fb0c28be794f28028884650db70c17fea8e35b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=a2fb0c28be794f28028884650db70c17fea8e35b", "patch": "@@ -1,136 +0,0 @@\n-use rustc::mir::visit::Visitor;\n-use rustc::mir::{self, Local, Location};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_index::bit_set::BitSet;\n-use rustc_span::DUMMY_SP;\n-\n-use crate::dataflow::{self, GenKillSet};\n-\n-/// Whether a borrow to a `Local` has been created that could allow that `Local` to be mutated\n-/// indirectly. This could either be a mutable reference (`&mut`) or a shared borrow if the type of\n-/// that `Local` allows interior mutability. Operations that can mutate local's indirectly include:\n-/// assignments through a pointer (`*p = 42`), function calls, drop terminators and inline assembly.\n-///\n-/// If this returns false for a `Local` at a given statement (or terminator), that `Local` could\n-/// not possibly have been mutated indirectly prior to that statement.\n-#[derive(Copy, Clone)]\n-pub struct IndirectlyMutableLocals<'mir, 'tcx> {\n-    body: &'mir mir::Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'mir, 'tcx> IndirectlyMutableLocals<'mir, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'mir mir::Body<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> Self {\n-        IndirectlyMutableLocals { body, tcx, param_env }\n-    }\n-\n-    fn transfer_function<'a>(\n-        &self,\n-        trans: &'a mut GenKillSet<Local>,\n-    ) -> TransferFunction<'a, 'mir, 'tcx> {\n-        TransferFunction { body: self.body, tcx: self.tcx, param_env: self.param_env, trans }\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::BitDenotation<'tcx> for IndirectlyMutableLocals<'mir, 'tcx> {\n-    type Idx = Local;\n-\n-    fn name() -> &'static str {\n-        \"mut_borrowed_locals\"\n-    }\n-\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n-    }\n-\n-    fn start_block_effect(&self, _entry_set: &mut BitSet<Local>) {\n-        // Nothing is borrowed on function entry\n-    }\n-\n-    fn statement_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-        self.transfer_function(trans).visit_statement(stmt, loc);\n-    }\n-\n-    fn terminator_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let terminator = self.body[loc.block].terminator();\n-        self.transfer_function(trans).visit_terminator(terminator, loc);\n-    }\n-\n-    fn propagate_call_return(\n-        &self,\n-        _in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n-    ) {\n-        // Nothing to do when a call returns successfully\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::BottomValue for IndirectlyMutableLocals<'mir, 'tcx> {\n-    // bottom = unborrowed\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n-/// A `Visitor` that defines the transfer function for `IndirectlyMutableLocals`.\n-struct TransferFunction<'a, 'mir, 'tcx> {\n-    trans: &'a mut GenKillSet<Local>,\n-    body: &'mir mir::Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> TransferFunction<'_, '_, 'tcx> {\n-    /// Returns `true` if this borrow would allow mutation of the `borrowed_place`.\n-    fn borrow_allows_mutation(\n-        &self,\n-        kind: mir::BorrowKind,\n-        borrowed_place: &mir::Place<'tcx>,\n-    ) -> bool {\n-        match kind {\n-            mir::BorrowKind::Mut { .. } => true,\n-\n-            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n-                !borrowed_place.ty(self.body, self.tcx).ty.is_freeze(\n-                    self.tcx,\n-                    self.param_env,\n-                    DUMMY_SP,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx> {\n-    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n-        if let mir::Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            if self.borrow_allows_mutation(kind, borrowed_place) {\n-                if !borrowed_place.is_indirect() {\n-                    self.trans.gen(borrowed_place.local);\n-                }\n-            }\n-        }\n-\n-        self.super_rvalue(rvalue, location);\n-    }\n-\n-    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n-        // This method purposely does nothing except call `super_terminator`. It exists solely to\n-        // document the subtleties around drop terminators.\n-\n-        self.super_terminator(terminator, location);\n-\n-        if let mir::TerminatorKind::Drop { location: _, .. }\n-        | mir::TerminatorKind::DropAndReplace { location: _, .. } = &terminator.kind\n-        {\n-            // Although drop terminators mutably borrow the location being dropped, that borrow\n-            // cannot live beyond the drop terminator because the dropped location is invalidated.\n-        }\n-    }\n-}"}, {"sha": "acea31857818bcc1fd89e4372275467b2a19303e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -20,11 +20,9 @@ use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n \n mod borrowed_locals;\n-mod indirect_mutation;\n mod storage_liveness;\n \n pub use self::borrowed_locals::*;\n-pub use self::indirect_mutation::IndirectlyMutableLocals;\n pub use self::storage_liveness::*;\n \n pub(super) mod borrows;"}, {"sha": "7508d71945e5f30de4bf7ad47e80f35333cbf08d", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -1,8 +1,8 @@\n pub use super::*;\n \n+use crate::dataflow::generic::{Results, ResultsRefCursor};\n use crate::dataflow::BitDenotation;\n-use crate::dataflow::HaveBeenBorrowedLocals;\n-use crate::dataflow::{DataflowResults, DataflowResultsCursor, DataflowResultsRefCursor};\n+use crate::dataflow::MaybeBorrowedLocals;\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n use std::cell::RefCell;\n@@ -69,22 +69,23 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n     const BOTTOM_VALUE: bool = false;\n }\n \n+type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n+\n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n pub struct RequiresStorage<'mir, 'tcx> {\n     body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n-    borrowed_locals:\n-        RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+    borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n }\n \n impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n     pub fn new(\n         body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n-        borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n+        borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n     ) -> Self {\n         RequiresStorage {\n             body,\n-            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, *body)),\n+            borrowed_locals: RefCell::new(ResultsRefCursor::new(*body, borrowed_locals)),\n         }\n     }\n \n@@ -111,11 +112,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n     }\n \n     fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n-        // If we borrow or assign to a place then it needs storage for that\n-        // statement.\n-        self.check_for_borrow(sets, loc);\n-\n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n+\n+        // If a place is borrowed in a statement, it needs storage for that statement.\n+        self.borrowed_locals.borrow().analysis().statement_effect(sets, stmt, loc);\n+\n+        // If a place is assigned to in a statement, it needs storage for that statement.\n         match stmt.kind {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box (ref place, _))\n@@ -138,12 +140,13 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n     }\n \n     fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        self.check_for_borrow(sets, loc);\n+        let terminator = self.body[loc.block].terminator();\n \n-        if let TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. } =\n-            self.body[loc.block].terminator().kind\n-        {\n-            sets.gen(local);\n+        // If a place is borrowed in a terminator, it needs storage for that terminator.\n+        self.borrowed_locals.borrow().analysis().terminator_effect(sets, terminator, loc);\n+\n+        if let TerminatorKind::Call { destination: Some((place, _)), .. } = terminator.kind {\n+            sets.gen(place.local);\n         }\n     }\n \n@@ -179,14 +182,6 @@ impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n         let mut visitor = MoveVisitor { sets, borrowed_locals: &self.borrowed_locals };\n         visitor.visit_location(self.body, loc);\n     }\n-\n-    /// Gen locals that are newly borrowed. This includes borrowing any part of\n-    /// a local (we rely on this behavior of `HaveBeenBorrowedLocals`).\n-    fn check_for_borrow(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-        borrowed_locals.seek(loc);\n-        borrowed_locals.each_gen_bit(|l| sets.gen(l));\n-    }\n }\n \n impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n@@ -195,16 +190,15 @@ impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n }\n \n struct MoveVisitor<'a, 'mir, 'tcx> {\n-    borrowed_locals:\n-        &'a RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+    borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n     sets: &'a mut GenKillSet<Local>,\n }\n \n impl<'a, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx> {\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n         if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n             let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-            borrowed_locals.seek(loc);\n+            borrowed_locals.seek_before(loc);\n             if !borrowed_locals.contains(*local) {\n                 self.sets.kill(*local);\n             }"}, {"sha": "41bac894e48ce6031f5b50def87939ffd663070b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -23,8 +23,7 @@ pub(crate) use self::drop_flag_effects::*;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::HaveBeenBorrowedLocals;\n-pub use self::impls::IndirectlyMutableLocals;\n+pub use self::impls::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::{MaybeStorageLive, RequiresStorage};\n "}, {"sha": "3e14cc6d32a671f579469fd7d6f7ce7a8e56b4c6", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -15,7 +15,7 @@ use crate::dataflow::{self as old_dataflow, generic as dataflow};\n /// `FlowSensitiveAnalysis`.\n ///\n /// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n-/// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n+/// the `MaybeMutBorrowedLocals` dataflow pass to see if a `Local` may have become qualified via\n /// an indirect assignment or function call.\n struct TransferFunction<'a, 'mir, 'tcx, Q> {\n     item: &'a Item<'mir, 'tcx>,"}, {"sha": "c5a51bfb2829e5e1b2f32e12f48f01a712aa8c70", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -16,17 +16,19 @@ use rustc_span::Span;\n use std::borrow::Cow;\n use std::ops::Deref;\n \n-use self::old_dataflow::IndirectlyMutableLocals;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::dataflow::{self as old_dataflow, generic as dataflow};\n-use dataflow::Analysis;\n+use crate::dataflow::generic::{self as dataflow, Analysis};\n+use crate::dataflow::MaybeMutBorrowedLocals;\n \n+// We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n+// through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`\n+// kills locals upon `StorageDead` because a local will never be used after a `StorageDead`.\n pub type IndirectlyMutableResults<'mir, 'tcx> =\n-    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n+    dataflow::ResultsCursor<'mir, 'tcx, MaybeMutBorrowedLocals<'mir, 'tcx>>;\n \n struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n     cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n@@ -59,7 +61,7 @@ pub struct Qualifs<'a, 'mir, 'tcx> {\n \n impl Qualifs<'a, 'mir, 'tcx> {\n     fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n-        self.indirectly_mutable.seek(location);\n+        self.indirectly_mutable.seek_before(location);\n         self.indirectly_mutable.get().contains(local)\n     }\n \n@@ -135,22 +137,21 @@ impl Deref for Validator<'_, 'mir, 'tcx> {\n \n impl Validator<'a, 'mir, 'tcx> {\n     pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n+        let Item { tcx, body, def_id, param_env, .. } = *item;\n+\n         let needs_drop = QualifCursor::new(NeedsDrop, item);\n         let has_mut_interior = QualifCursor::new(HasMutInterior, item);\n \n-        let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n-        let indirectly_mutable = old_dataflow::do_dataflow(\n-            item.tcx,\n-            &*item.body,\n-            item.def_id,\n-            &item.tcx.get_attrs(item.def_id),\n-            &dead_unwinds,\n-            old_dataflow::IndirectlyMutableLocals::new(item.tcx, *item.body, item.param_env),\n-            |_, local| old_dataflow::DebugFormatted::new(&local),\n-        );\n-\n-        let indirectly_mutable =\n-            old_dataflow::DataflowResultsCursor::new(indirectly_mutable, *item.body);\n+        // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n+        // allowed in a const.\n+        //\n+        // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n+        // without breaking stable code?\n+        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, *body, param_env)\n+            .unsound_ignore_borrow_on_drop()\n+            .into_engine(tcx, *body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(*body);\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n "}, {"sha": "b3dc87d1a1628c29a70d11596664f80d4b364035", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -49,9 +49,10 @@\n //! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n+use crate::dataflow::generic::{Analysis, ResultsCursor};\n use crate::dataflow::{do_dataflow, DataflowResultsCursor, DebugFormatted};\n use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n-use crate::dataflow::{HaveBeenBorrowedLocals, MaybeStorageLive, RequiresStorage};\n+use crate::dataflow::{MaybeBorrowedLocals, MaybeStorageLive, RequiresStorage};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n@@ -471,17 +472,10 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body_ref);\n-    let borrowed_locals_results = do_dataflow(\n-        tcx,\n-        body_ref,\n-        def_id,\n-        &[],\n-        &dead_unwinds,\n-        borrowed_locals_analysis,\n-        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]),\n-    );\n-    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body_ref);\n+    let borrowed_locals_results =\n+        MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n+\n+    let mut borrowed_locals_cursor = ResultsCursor::new(body_ref, &borrowed_locals_results);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n@@ -521,7 +515,7 @@ fn locals_live_across_suspend_points(\n                 // If a borrow is converted to a raw reference, we must also assume that it lives\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n-                borrowed_locals_cursor.seek(loc);\n+                borrowed_locals_cursor.seek_before(loc);\n                 liveness.outs[block].union(borrowed_locals_cursor.get());\n             }\n "}, {"sha": "6176cf8bc0fa6a78bab50978d57360b893724ff5", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -12,9 +12,8 @@ use rustc_index::bit_set::BitSet;\n use crate::dataflow::generic::{Analysis, Results, ResultsCursor};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::move_paths::{LookupResult, MovePathIndex};\n-use crate::dataflow::IndirectlyMutableLocals;\n+use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::MoveDataParamEnv;\n-use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces,\n };\n@@ -24,7 +23,6 @@ pub struct SanityCheck;\n impl<'tcx> MirPass<'tcx> for SanityCheck {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n         use crate::dataflow::has_rustc_mir_with;\n-\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -37,7 +35,6 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n \n         let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n             .into_engine(tcx, body, def_id)\n@@ -48,15 +45,9 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n             .into_engine(tcx, body, def_id)\n             .iterate_to_fixpoint();\n-        let _flow_indirectly_mut = do_dataflow(\n-            tcx,\n-            body,\n-            def_id,\n-            &attributes,\n-            &dead_unwinds,\n-            IndirectlyMutableLocals::new(tcx, body, param_env),\n-            |_, i| DebugFormatted::new(&i),\n-        );\n+        let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint();\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n@@ -67,12 +58,9 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n-        // FIXME: Uncomment these as analyses are migrated to the new framework\n-        /*\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_mut_borrowed);\n         }\n-        */\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n@@ -276,8 +264,7 @@ where\n     }\n }\n \n-/* FIXME: Add this back once `IndirectlyMutableLocals` uses the new dataflow framework.\n-impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n+impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n     fn peek_at(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -298,4 +285,3 @@ impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n         }\n     }\n }\n-*/"}, {"sha": "caa307e269fe7f658d99641388b4429ead1b27e6", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -1,6 +1,11 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n \n-// ignore-test Temporarily ignored while this analysis is migrated to the new framework.\n+// This test demonstrates a shortcoming of the `MaybeMutBorrowedLocals` analysis. It does not\n+// handle code that takes a reference to one field of a struct, then use pointer arithmetic to\n+// transform it to another field of that same struct that may have interior mutability. For now,\n+// this is UB, but this may change in the future. See [rust-lang/unsafe-code-guidelines#134].\n+//\n+// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n \n #![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n "}, {"sha": "8d3548ececdd979e3ea349d2055a0b6881aac484", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a8108d8e52e13f3f1a151a93addfcf4a86b97f5/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=3a8108d8e52e13f3f1a151a93addfcf4a86b97f5", "patch": "@@ -1,5 +1,5 @@\n error: rustc_peek: bit not set\n-  --> $DIR/indirect-mutation-offset.rs:34:14\n+  --> $DIR/indirect-mutation-offset.rs:41:14\n    |\n LL |     unsafe { rustc_peek(x) };\n    |              ^^^^^^^^^^^^^"}]}