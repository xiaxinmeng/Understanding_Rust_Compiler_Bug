{"sha": "02b02061b6cb121204a9bd931e7cd541dba2898f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYjAyMDYxYjZjYjEyMTIwNGE5YmQ5MzFlN2NkNTQxZGJhMjg5OGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-04T11:49:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-04T11:49:24Z"}, "message": "Merge #3440\n\n3440: Move search to ra_ide_db r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a8e5e91aeef1d910a77ed2b664cd28e6d033de7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8e5e91aeef1d910a77ed2b664cd28e6d033de7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02b02061b6cb121204a9bd931e7cd541dba2898f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeX5XECRBK7hj4Ov3rIwAAdHIIACJ75sZuKP/3qSVNGXUFPtq3\nOjYziZQRy+nbQKduTXQ/owzhM1ibuFh6+tjB+qQgtsd8pWTae49Q791kcnpuC4/1\nXypsILTAWQ1b6A2Unhb0ST02KXst7kOmc4oDgeoKveOV+V9Bej0a5/gc+e5AaDuy\ncSu1On5B09Ye3MVIVhIR/FipL5UK2740zrIRRHGHHa2usxiGnfV2fEBeuXmGz9HQ\n0sRwkWA9pR9N/zCC22zEM4Egc6LrMCxb0yqJ0Z03NceB6bv2+phBmAi6NgqVZPVT\nKGNVjtiHGUZs+F1T8AHRSqquQotNSEiJ6MrBhDyJEGwX/IhMaBF8oB9pxEC5jWA=\n=bLOV\n-----END PGP SIGNATURE-----\n", "payload": "tree a8e5e91aeef1d910a77ed2b664cd28e6d033de7a\nparent 66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92\nparent 4f50a3718762c9272b1929162ce62415a75eec8f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583322564 +0000\ncommitter GitHub <noreply@github.com> 1583322564 +0000\n\nMerge #3440\n\n3440: Move search to ra_ide_db r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02b02061b6cb121204a9bd931e7cd541dba2898f", "html_url": "https://github.com/rust-lang/rust/commit/02b02061b6cb121204a9bd931e7cd541dba2898f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02b02061b6cb121204a9bd931e7cd541dba2898f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92", "html_url": "https://github.com/rust-lang/rust/commit/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92"}, {"sha": "4f50a3718762c9272b1929162ce62415a75eec8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f50a3718762c9272b1929162ce62415a75eec8f", "html_url": "https://github.com/rust-lang/rust/commit/4f50a3718762c9272b1929162ce62415a75eec8f"}], "stats": {"total": 679, "additions": 344, "deletions": 335}, "files": [{"sha": "316dae053f5936427b2ddb034a9670680f76f221", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -1039,7 +1039,6 @@ dependencies = [\n  \"itertools\",\n  \"join_to_string\",\n  \"log\",\n- \"once_cell\",\n  \"ra_assists\",\n  \"ra_cfg\",\n  \"ra_db\",\n@@ -1060,6 +1059,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"fst\",\n  \"log\",\n+ \"once_cell\",\n  \"ra_db\",\n  \"ra_hir\",\n  \"ra_prof\","}, {"sha": "410d8de6240625fd33e36eb2963c95b6ce26137a", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -19,7 +19,6 @@ join_to_string = \"0.1.3\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n rand = { version = \"0.7.3\", features = [\"small_rng\"] }\n-once_cell = \"1.3.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "5a41f702efb7eed123a527b678e243bef561ac1e", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -68,9 +68,7 @@ pub use crate::{\n     folding_ranges::{Fold, FoldKind},\n     hover::HoverResult,\n     inlay_hints::{InlayHint, InlayKind},\n-    references::{\n-        Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult, SearchScope,\n-    },\n+    references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     ssr::SsrError,\n@@ -88,6 +86,7 @@ pub use ra_ide_db::{\n     feature_flags::FeatureFlags,\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n+    search::SearchScope,\n     symbol_index::Query,\n     RootDatabase,\n };"}, {"sha": "6e2bf4ded9cda11181589430aac41a796b740359", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 19, "deletions": 185, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -10,28 +10,25 @@\n //! resolved to the search element definition, we get a reference.\n \n mod rename;\n-mod search_scope;\n \n use hir::Semantics;\n-use once_cell::unsync::Lazy;\n-use ra_db::SourceDatabaseExt;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n+    search::SearchScope,\n     RootDatabase,\n };\n use ra_prof::profile;\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    match_ast, AstNode, SyntaxKind, SyntaxNode, TextRange, TextUnit, TokenAtOffset,\n+    AstNode, SyntaxKind, SyntaxNode, TextRange, TokenAtOffset,\n };\n-use test_utils::tested_by;\n \n use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n pub(crate) use self::rename::rename;\n \n-pub use self::search_scope::SearchScope;\n+pub use ra_ide_db::search::{Reference, ReferenceAccess, ReferenceKind};\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n@@ -46,25 +43,6 @@ pub struct Declaration {\n     pub access: Option<ReferenceAccess>,\n }\n \n-#[derive(Debug, Clone)]\n-pub struct Reference {\n-    pub file_range: FileRange,\n-    pub kind: ReferenceKind,\n-    pub access: Option<ReferenceAccess>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq)]\n-pub enum ReferenceKind {\n-    StructLiteral,\n-    Other,\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq)]\n-pub enum ReferenceAccess {\n-    Read,\n-    Write,\n-}\n-\n impl ReferenceSearchResult {\n     pub fn declaration(&self) -> &Declaration {\n         &self.declaration\n@@ -125,7 +103,8 @@ pub(crate) fn find_all_refs(\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n-    let references = find_refs_to_def(db, &def, search_scope)\n+    let references = def\n+        .find_usages(db, search_scope)\n         .into_iter()\n         .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n         .collect();\n@@ -141,27 +120,6 @@ pub(crate) fn find_all_refs(\n     Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }))\n }\n \n-pub(crate) fn find_refs_to_def(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    search_scope: Option<SearchScope>,\n-) -> Vec<Reference> {\n-    let search_scope = {\n-        let base = SearchScope::for_def(&def, db);\n-        match search_scope {\n-            None => base,\n-            Some(scope) => base.intersection(&scope),\n-        }\n-    };\n-\n-    let name = match def.name(db) {\n-        None => return Vec::new(),\n-        Some(it) => it.to_string(),\n-    };\n-\n-    process_definition(db, def, name, search_scope)\n-}\n-\n fn find_name(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n@@ -179,72 +137,6 @@ fn find_name(\n     Some(RangeInfo::new(range, def))\n }\n \n-fn process_definition(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    name: String,\n-    scope: SearchScope,\n-) -> Vec<Reference> {\n-    let _p = profile(\"process_definition\");\n-\n-    let pat = name.as_str();\n-    let mut refs = vec![];\n-\n-    for (file_id, search_range) in scope {\n-        let text = db.file_text(file_id);\n-        let search_range =\n-            search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n-\n-        let sema = Semantics::new(db);\n-        let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n-\n-        for (idx, _) in text.match_indices(pat) {\n-            let offset = TextUnit::from_usize(idx);\n-            if !search_range.contains_inclusive(offset) {\n-                tested_by!(search_filters_by_range);\n-                continue;\n-            }\n-\n-            let name_ref =\n-                if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n-                    name_ref\n-                } else {\n-                    // Handle macro token cases\n-                    let token = match tree.token_at_offset(offset) {\n-                        TokenAtOffset::None => continue,\n-                        TokenAtOffset::Single(t) => t,\n-                        TokenAtOffset::Between(_, t) => t,\n-                    };\n-                    let expanded = sema.descend_into_macros(token);\n-                    match ast::NameRef::cast(expanded.parent()) {\n-                        Some(name_ref) => name_ref,\n-                        _ => continue,\n-                    }\n-                };\n-\n-            if let Some(d) = classify_name_ref(&sema, &name_ref) {\n-                let d = d.definition();\n-                if &d == def {\n-                    let kind =\n-                        if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n-                            ReferenceKind::StructLiteral\n-                        } else {\n-                            ReferenceKind::Other\n-                        };\n-\n-                    let file_range = sema.original_range(name_ref.syntax());\n-                    refs.push(Reference {\n-                        file_range,\n-                        kind,\n-                        access: reference_access(&d, &name_ref),\n-                    });\n-                }\n-            }\n-        }\n-    }\n-    refs\n-}\n-\n fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n     match def {\n         Definition::Local(_) | Definition::StructField(_) => {}\n@@ -264,48 +156,6 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     None\n }\n \n-fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n-    // Only Locals and Fields have accesses for now.\n-    match def {\n-        Definition::Local(_) | Definition::StructField(_) => {}\n-        _ => return None,\n-    };\n-\n-    let mode = name_ref.syntax().ancestors().find_map(|node| {\n-        match_ast! {\n-            match (node) {\n-                ast::BinExpr(expr) => {\n-                    if expr.op_kind()?.is_assignment() {\n-                        // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n-                        // FIXME: This is not terribly accurate.\n-                        if let Some(lhs) = expr.lhs() {\n-                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n-                                return Some(ReferenceAccess::Write);\n-                            }\n-                        }\n-                    }\n-                    Some(ReferenceAccess::Read)\n-                },\n-                _ => {None}\n-            }\n-        }\n-    });\n-\n-    // Default Locals and Fields to read\n-    mode.or(Some(ReferenceAccess::Read))\n-}\n-\n-fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::RecordLit::cast)\n-        .and_then(|l| l.path())\n-        .and_then(|p| p.segment())\n-        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n-        .unwrap_or(false)\n-}\n-\n fn get_struct_def_name_for_struc_litetal_search(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n@@ -324,20 +174,6 @@ fn get_struct_def_name_for_struc_litetal_search(\n     None\n }\n \n-fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n-    name_ref\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::CallExpr::cast)\n-        .and_then(|c| match c.expr()? {\n-            ast::Expr::PathExpr(p) => {\n-                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n-            }\n-            _ => None,\n-        })\n-        .unwrap_or(false)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::covers;\n@@ -451,7 +287,7 @@ mod tests {\n \n     #[test]\n     fn search_filters_by_range() {\n-        covers!(search_filters_by_range);\n+        covers!(ra_ide_db::search_filters_by_range);\n         let code = r#\"\n             fn foo() {\n                 let spam<|> = 92;\n@@ -767,7 +603,10 @@ mod tests {\n     fn check_result(res: ReferenceSearchResult, expected_decl: &str, expected_refs: &[&str]) {\n         res.declaration().assert_match(expected_decl);\n         assert_eq!(res.references.len(), expected_refs.len());\n-        res.references().iter().enumerate().for_each(|(i, r)| r.assert_match(expected_refs[i]));\n+        res.references()\n+            .iter()\n+            .enumerate()\n+            .for_each(|(i, r)| ref_assert_match(r, expected_refs[i]));\n     }\n \n     impl Declaration {\n@@ -785,21 +624,16 @@ mod tests {\n         }\n     }\n \n-    impl Reference {\n-        fn debug_render(&self) -> String {\n-            let mut s = format!(\n-                \"{:?} {:?} {:?}\",\n-                self.file_range.file_id, self.file_range.range, self.kind\n-            );\n-            if let Some(access) = self.access {\n-                s.push_str(&format!(\" {:?}\", access));\n-            }\n-            s\n+    fn ref_debug_render(r: &Reference) -> String {\n+        let mut s = format!(\"{:?} {:?} {:?}\", r.file_range.file_id, r.file_range.range, r.kind);\n+        if let Some(access) = r.access {\n+            s.push_str(&format!(\" {:?}\", access));\n         }\n+        s\n+    }\n \n-        fn assert_match(&self, expected: &str) {\n-            let actual = self.debug_render();\n-            test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n-        }\n+    fn ref_assert_match(r: &Reference, expected: &str) {\n+        let actual = ref_debug_render(r);\n+        test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n     }\n }"}, {"sha": "d98c84d91698553b06a3a43fbabe596687f9f165", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=66ec6bdfb0fbb8e99b58f3c184ef5012354e6d92", "patch": "@@ -1,145 +0,0 @@\n-//! Generally, `search_scope` returns files that might contain references for the element.\n-//! For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n-//! In some cases, the location of the references is known to within a `TextRange`,\n-//! e.g. for things like local variables.\n-use std::mem;\n-\n-use hir::{DefWithBody, HasSource, ModuleSource};\n-use ra_db::{FileId, SourceDatabaseExt};\n-use ra_prof::profile;\n-use ra_syntax::{AstNode, TextRange};\n-use rustc_hash::FxHashMap;\n-\n-use ra_ide_db::RootDatabase;\n-\n-use super::Definition;\n-\n-pub struct SearchScope {\n-    entries: FxHashMap<FileId, Option<TextRange>>,\n-}\n-\n-impl SearchScope {\n-    fn empty() -> SearchScope {\n-        SearchScope { entries: FxHashMap::default() }\n-    }\n-\n-    pub(crate) fn for_def(def: &Definition, db: &RootDatabase) -> SearchScope {\n-        let _p = profile(\"search_scope\");\n-        let module = match def.module(db) {\n-            Some(it) => it,\n-            None => return SearchScope::empty(),\n-        };\n-        let module_src = module.definition_source(db);\n-        let file_id = module_src.file_id.original_file(db);\n-\n-        if let Definition::Local(var) = def {\n-            let range = match var.parent(db) {\n-                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n-                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n-                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n-            };\n-            let mut res = FxHashMap::default();\n-            res.insert(file_id, Some(range));\n-            return SearchScope::new(res);\n-        }\n-\n-        let vis = def.visibility(db).as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n-\n-        if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = module.parent(db) {\n-                let mut res = FxHashMap::default();\n-                let parent_src = parent_module.definition_source(db);\n-                let file_id = parent_src.file_id.original_file(db);\n-\n-                match parent_src.value {\n-                    ModuleSource::Module(m) => {\n-                        let range = Some(m.syntax().text_range());\n-                        res.insert(file_id, range);\n-                    }\n-                    ModuleSource::SourceFile(_) => {\n-                        res.insert(file_id, None);\n-                        res.extend(parent_module.children(db).map(|m| {\n-                            let src = m.definition_source(db);\n-                            (src.file_id.original_file(db), None)\n-                        }));\n-                    }\n-                }\n-                return SearchScope::new(res);\n-            }\n-        }\n-\n-        if vis.as_str() != \"\" {\n-            let source_root_id = db.file_source_root(file_id);\n-            let source_root = db.source_root(source_root_id);\n-            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n-\n-            // FIXME: add \"pub(in path)\"\n-\n-            if vis.as_str() == \"pub(crate)\" {\n-                return SearchScope::new(res);\n-            }\n-            if vis.as_str() == \"pub\" {\n-                let krate = module.krate();\n-                for rev_dep in krate.reverse_dependencies(db) {\n-                    let root_file = rev_dep.root_file(db);\n-                    let source_root_id = db.file_source_root(root_file);\n-                    let source_root = db.source_root(source_root_id);\n-                    res.extend(source_root.walk().map(|id| (id, None)));\n-                }\n-                return SearchScope::new(res);\n-            }\n-        }\n-\n-        let mut res = FxHashMap::default();\n-        let range = match module_src.value {\n-            ModuleSource::Module(m) => Some(m.syntax().text_range()),\n-            ModuleSource::SourceFile(_) => None,\n-        };\n-        res.insert(file_id, range);\n-        SearchScope::new(res)\n-    }\n-\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n-        SearchScope { entries }\n-    }\n-    pub fn single_file(file: FileId) -> SearchScope {\n-        SearchScope::new(std::iter::once((file, None)).collect())\n-    }\n-    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n-        let (mut small, mut large) = (&self.entries, &other.entries);\n-        if small.len() > large.len() {\n-            mem::swap(&mut small, &mut large)\n-        }\n-\n-        let res = small\n-            .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n-            })\n-            .collect();\n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl IntoIterator for SearchScope {\n-    type Item = (FileId, Option<TextRange>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.entries.into_iter()\n-    }\n-}"}, {"sha": "52f0f23df50c8b3d61f25653046f0dae8d21220e", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -16,6 +16,7 @@ rayon = \"1.3.0\"\n fst = { version = \"0.3.5\", default-features = false }\n rustc-hash = \"1.1.0\"\n superslice = \"1.0.0\"\n+once_cell = \"1.3.1\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "79f48c9e32e54357e24aa4bb73d33b447210a09b", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -9,6 +9,7 @@ pub mod feature_flags;\n pub mod symbol_index;\n pub mod change;\n pub mod defs;\n+pub mod search;\n pub mod imports_locator;\n mod wasm_shims;\n "}, {"sha": "4f0a22af031656bceb1da5090b1175ab00b0845c", "filename": "crates/ra_ide_db/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fmarks.rs?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -6,4 +6,5 @@ test_utils::marks![\n     goto_def_for_fields\n     goto_def_for_record_fields\n     goto_def_for_field_init_shorthand\n+    search_filters_by_range\n ];"}, {"sha": "6f198df04097e78bf227dda0d3d7084eff41eacb", "filename": "crates/ra_ide_db/src/search.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b02061b6cb121204a9bd931e7cd541dba2898f/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=02b02061b6cb121204a9bd931e7cd541dba2898f", "patch": "@@ -0,0 +1,319 @@\n+//! Implementation of find-usages functionality.\n+//!\n+//! It is based on the standard ide trick: first, we run a fast text search to\n+//! get a super-set of matches. Then, we we confirm each match using precise\n+//! name resolution.\n+\n+use std::mem;\n+\n+use hir::{DefWithBody, HasSource, ModuleSource, Semantics};\n+use once_cell::unsync::Lazy;\n+use ra_db::{FileId, FileRange, SourceDatabaseExt};\n+use ra_prof::profile;\n+use ra_syntax::{\n+    algo::find_node_at_offset, ast, match_ast, AstNode, TextRange, TextUnit, TokenAtOffset,\n+};\n+use rustc_hash::FxHashMap;\n+use test_utils::tested_by;\n+\n+use crate::{\n+    defs::{classify_name_ref, Definition},\n+    RootDatabase,\n+};\n+\n+#[derive(Debug, Clone)]\n+pub struct Reference {\n+    pub file_range: FileRange,\n+    pub kind: ReferenceKind,\n+    pub access: Option<ReferenceAccess>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum ReferenceKind {\n+    StructLiteral,\n+    Other,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum ReferenceAccess {\n+    Read,\n+    Write,\n+}\n+\n+/// Generally, `search_scope` returns files that might contain references for the element.\n+/// For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n+/// In some cases, the location of the references is known to within a `TextRange`,\n+/// e.g. for things like local variables.\n+pub struct SearchScope {\n+    entries: FxHashMap<FileId, Option<TextRange>>,\n+}\n+\n+impl SearchScope {\n+    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+        SearchScope { entries }\n+    }\n+\n+    pub fn empty() -> SearchScope {\n+        SearchScope::new(FxHashMap::default())\n+    }\n+\n+    pub fn single_file(file: FileId) -> SearchScope {\n+        SearchScope::new(std::iter::once((file, None)).collect())\n+    }\n+\n+    pub fn intersection(&self, other: &SearchScope) -> SearchScope {\n+        let (mut small, mut large) = (&self.entries, &other.entries);\n+        if small.len() > large.len() {\n+            mem::swap(&mut small, &mut large)\n+        }\n+\n+        let res = small\n+            .iter()\n+            .filter_map(|(file_id, r1)| {\n+                let r2 = large.get(file_id)?;\n+                let r = intersect_ranges(*r1, *r2)?;\n+                Some((*file_id, r))\n+            })\n+            .collect();\n+\n+        return SearchScope::new(res);\n+\n+        fn intersect_ranges(\n+            r1: Option<TextRange>,\n+            r2: Option<TextRange>,\n+        ) -> Option<Option<TextRange>> {\n+            match (r1, r2) {\n+                (None, r) | (r, None) => Some(r),\n+                (Some(r1), Some(r2)) => {\n+                    let r = r1.intersection(&r2)?;\n+                    Some(Some(r))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl IntoIterator for SearchScope {\n+    type Item = (FileId, Option<TextRange>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.entries.into_iter()\n+    }\n+}\n+\n+impl Definition {\n+    fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n+        let _p = profile(\"search_scope\");\n+        let module = match self.module(db) {\n+            Some(it) => it,\n+            None => return SearchScope::empty(),\n+        };\n+        let module_src = module.definition_source(db);\n+        let file_id = module_src.file_id.original_file(db);\n+\n+        if let Definition::Local(var) = self {\n+            let range = match var.parent(db) {\n+                DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n+                DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n+                DefWithBody::Static(s) => s.source(db).value.syntax().text_range(),\n+            };\n+            let mut res = FxHashMap::default();\n+            res.insert(file_id, Some(range));\n+            return SearchScope::new(res);\n+        }\n+\n+        let vis = self.visibility(db).as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+\n+        if vis.as_str() == \"pub(super)\" {\n+            if let Some(parent_module) = module.parent(db) {\n+                let mut res = FxHashMap::default();\n+                let parent_src = parent_module.definition_source(db);\n+                let file_id = parent_src.file_id.original_file(db);\n+\n+                match parent_src.value {\n+                    ModuleSource::Module(m) => {\n+                        let range = Some(m.syntax().text_range());\n+                        res.insert(file_id, range);\n+                    }\n+                    ModuleSource::SourceFile(_) => {\n+                        res.insert(file_id, None);\n+                        res.extend(parent_module.children(db).map(|m| {\n+                            let src = m.definition_source(db);\n+                            (src.file_id.original_file(db), None)\n+                        }));\n+                    }\n+                }\n+                return SearchScope::new(res);\n+            }\n+        }\n+\n+        if vis.as_str() != \"\" {\n+            let source_root_id = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root_id);\n+            let mut res = source_root.walk().map(|id| (id, None)).collect::<FxHashMap<_, _>>();\n+\n+            // FIXME: add \"pub(in path)\"\n+\n+            if vis.as_str() == \"pub(crate)\" {\n+                return SearchScope::new(res);\n+            }\n+            if vis.as_str() == \"pub\" {\n+                let krate = module.krate();\n+                for rev_dep in krate.reverse_dependencies(db) {\n+                    let root_file = rev_dep.root_file(db);\n+                    let source_root_id = db.file_source_root(root_file);\n+                    let source_root = db.source_root(source_root_id);\n+                    res.extend(source_root.walk().map(|id| (id, None)));\n+                }\n+                return SearchScope::new(res);\n+            }\n+        }\n+\n+        let mut res = FxHashMap::default();\n+        let range = match module_src.value {\n+            ModuleSource::Module(m) => Some(m.syntax().text_range()),\n+            ModuleSource::SourceFile(_) => None,\n+        };\n+        res.insert(file_id, range);\n+        SearchScope::new(res)\n+    }\n+\n+    pub fn find_usages(\n+        &self,\n+        db: &RootDatabase,\n+        search_scope: Option<SearchScope>,\n+    ) -> Vec<Reference> {\n+        let _p = profile(\"Definition::find_usages\");\n+\n+        let search_scope = {\n+            let base = self.search_scope(db);\n+            match search_scope {\n+                None => base,\n+                Some(scope) => base.intersection(&scope),\n+            }\n+        };\n+\n+        let name = match self.name(db) {\n+            None => return Vec::new(),\n+            Some(it) => it.to_string(),\n+        };\n+\n+        let pat = name.as_str();\n+        let mut refs = vec![];\n+\n+        for (file_id, search_range) in search_scope {\n+            let text = db.file_text(file_id);\n+            let search_range =\n+                search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n+\n+            let sema = Semantics::new(db);\n+            let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+\n+            for (idx, _) in text.match_indices(pat) {\n+                let offset = TextUnit::from_usize(idx);\n+                if !search_range.contains_inclusive(offset) {\n+                    tested_by!(search_filters_by_range; force);\n+                    continue;\n+                }\n+\n+                let name_ref =\n+                    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n+                        name_ref\n+                    } else {\n+                        // Handle macro token cases\n+                        let token = match tree.token_at_offset(offset) {\n+                            TokenAtOffset::None => continue,\n+                            TokenAtOffset::Single(t) => t,\n+                            TokenAtOffset::Between(_, t) => t,\n+                        };\n+                        let expanded = sema.descend_into_macros(token);\n+                        match ast::NameRef::cast(expanded.parent()) {\n+                            Some(name_ref) => name_ref,\n+                            _ => continue,\n+                        }\n+                    };\n+\n+                // FIXME: reuse sb\n+                // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n+\n+                if let Some(d) = classify_name_ref(&sema, &name_ref) {\n+                    let d = d.definition();\n+                    if &d == self {\n+                        let kind = if is_record_lit_name_ref(&name_ref)\n+                            || is_call_expr_name_ref(&name_ref)\n+                        {\n+                            ReferenceKind::StructLiteral\n+                        } else {\n+                            ReferenceKind::Other\n+                        };\n+\n+                        let file_range = sema.original_range(name_ref.syntax());\n+                        refs.push(Reference {\n+                            file_range,\n+                            kind,\n+                            access: reference_access(&d, &name_ref),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+        refs\n+    }\n+}\n+\n+fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n+    // Only Locals and Fields have accesses for now.\n+    match def {\n+        Definition::Local(_) | Definition::StructField(_) => {}\n+        _ => return None,\n+    };\n+\n+    let mode = name_ref.syntax().ancestors().find_map(|node| {\n+        match_ast! {\n+            match (node) {\n+                ast::BinExpr(expr) => {\n+                    if expr.op_kind()?.is_assignment() {\n+                        // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n+                        // FIXME: This is not terribly accurate.\n+                        if let Some(lhs) = expr.lhs() {\n+                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n+                                return Some(ReferenceAccess::Write);\n+                            }\n+                        }\n+                    }\n+                    Some(ReferenceAccess::Read)\n+                },\n+                _ => {None}\n+            }\n+        }\n+    });\n+\n+    // Default Locals and Fields to read\n+    mode.or(Some(ReferenceAccess::Read))\n+}\n+\n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordLit::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}"}]}