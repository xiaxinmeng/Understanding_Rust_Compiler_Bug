{"sha": "c71248b70870960af9993de4f31d3cba9bbce7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MTI0OGI3MDg3MDk2MGFmOTk5M2RlNGYzMWQzY2JhOWJiY2U3ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T20:50:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T20:50:02Z"}, "message": "Auto merge of #76859 - Aaron1011:fix/llvm-cgu-reuse, r=davidtwco,nikic\n\nUse llvm::computeLTOCacheKey to determine post-ThinLTO CGU reuse\n\nDuring incremental ThinLTO compilation, we attempt to re-use the\noptimized (post-ThinLTO) bitcode file for a module if it is 'safe' to do\nso.\n\nUp until now, 'safe' has meant that the set of modules that our current\nmodules imports from/exports to is unchanged from the previous\ncompilation session. See PR #67020 and PR #71131 for more details.\n\nHowever, this turns out be insufficient to guarantee that it's safe\nto reuse the post-LTO module (i.e. that optimizing the pre-LTO module\nwould produce the same result). When LLVM optimizes a module during\nThinLTO, it may look at other information from the 'module index', such\nas whether a (non-imported!) global variable is used. If this\ninformation changes between compilation runs, we may end up re-using an\noptimized module that (for example) had dead-code elimination run on a\nfunction that is now used by another module.\n\nFortunately, LLVM implements its own ThinLTO module cache, which is used\nwhen ThinLTO is performed by a linker plugin (e.g. when clang is used to\ncompile a C proect). Using this cache directly would require extensive\nrefactoring of our code - but fortunately for us, LLVM provides a\nfunction that does exactly what we need.\n\nThe function `llvm::computeLTOCacheKey` is used to compute a SHA-1 hash\nfrom all data that might influence the result of ThinLTO on a module.\nIn addition to the module imports/exports that we manually track, it\nalso hashes information about global variables (e.g. their liveness)\nwhich might be used during optimization. By using this function, we\nshouldn't have to worry about new LLVM passes breaking our module re-use\nbehavior.\n\nIn LLVM, the output of this function forms part of the filename used to\nstore the post-ThinLTO module. To keep our current filename structure\nintact, this PR just writes out the mapping 'CGU name -> Hash' to a\nfile. To determine if a post-LTO module should be reused, we compare\nhashes from the previous session.\n\nThis should unblock PR #75199 - by sheer chance, it seems to have hit\nthis issue due to the particular CGU partitioning and optimization\ndecisions that end up getting made.", "tree": {"sha": "b48c7b794eb51a1f726229ee0caa35ae94ae837e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b48c7b794eb51a1f726229ee0caa35ae94ae837e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c71248b70870960af9993de4f31d3cba9bbce7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c71248b70870960af9993de4f31d3cba9bbce7e8", "html_url": "https://github.com/rust-lang/rust/commit/c71248b70870960af9993de4f31d3cba9bbce7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c71248b70870960af9993de4f31d3cba9bbce7e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a079c43efb062e335e6e6c9dabd3c750619980", "url": "https://api.github.com/repos/rust-lang/rust/commits/06a079c43efb062e335e6e6c9dabd3c750619980", "html_url": "https://github.com/rust-lang/rust/commit/06a079c43efb062e335e6e6c9dabd3c750619980"}, {"sha": "cfe07cd42a92610219d6ffc1ae5eefef42f5254a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe07cd42a92610219d6ffc1ae5eefef42f5254a", "html_url": "https://github.com/rust-lang/rust/commit/cfe07cd42a92610219d6ffc1ae5eefef42f5254a"}], "stats": {"total": 361, "additions": 164, "deletions": 197}, "files": [{"sha": "ff312bade2521119841215ba6bc802a189adddfd", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 69, "deletions": 192, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -2,14 +2,14 @@ use crate::back::write::{\n     self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n };\n use crate::llvm::archive_ro::ArchiveRO;\n-use crate::llvm::{self, False, True};\n+use crate::llvm::{self, build_string, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{FatalError, Handler};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n@@ -22,16 +22,14 @@ use tracing::{debug, info};\n use std::ffi::{CStr, CString};\n use std::fs::File;\n use std::io;\n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n-/// We keep track of past LTO imports that were used to produce the current set\n-/// of compiled object files that we might choose to reuse during this\n-/// compilation session.\n-pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n+/// We keep track of the computed LTO cache keys from the previous\n+/// session to determine which CGUs we can reuse.\n+pub const THIN_LTO_KEYS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-keys.bin\";\n \n pub fn crate_type_allows_lto(crate_type: CrateType) -> bool {\n     match crate_type {\n@@ -485,31 +483,31 @@ fn thin_lto(\n         )\n         .ok_or_else(|| write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\"))?;\n \n-        info!(\"thin LTO data created\");\n+        let data = ThinData(data);\n \n-        let (import_map_path, prev_import_map, curr_import_map) =\n-            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-                let path = incr_comp_session_dir.join(THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME);\n-                // If previous imports have been deleted, or we get an IO error\n-                // reading the file storing them, then we'll just use `None` as the\n-                // prev_import_map, which will force the code to be recompiled.\n-                let prev = if path.exists() {\n-                    ThinLTOImportMaps::load_from_file(&path).ok()\n-                } else {\n-                    None\n-                };\n-                let curr = ThinLTOImportMaps::from_thin_lto_data(data);\n-                (Some(path), prev, curr)\n-            } else {\n-                // If we don't compile incrementally, we don't need to load the\n-                // import data from LLVM.\n-                assert!(green_modules.is_empty());\n-                let curr = ThinLTOImportMaps::default();\n-                (None, None, curr)\n-            };\n-        info!(\"thin LTO import map loaded\");\n+        info!(\"thin LTO data created\");\n \n-        let data = ThinData(data);\n+        let (key_map_path, prev_key_map, curr_key_map) = if let Some(ref incr_comp_session_dir) =\n+            cgcx.incr_comp_session_dir\n+        {\n+            let path = incr_comp_session_dir.join(THIN_LTO_KEYS_INCR_COMP_FILE_NAME);\n+            // If the previous file was deleted, or we get an IO error\n+            // reading the file, then we'll just use `None` as the\n+            // prev_key_map, which will force the code to be recompiled.\n+            let prev =\n+                if path.exists() { ThinLTOKeysMap::load_from_file(&path).ok() } else { None };\n+            let curr = ThinLTOKeysMap::from_thin_lto_modules(&data, &thin_modules, &module_names);\n+            (Some(path), prev, curr)\n+        } else {\n+            // If we don't compile incrementally, we don't need to load the\n+            // import data from LLVM.\n+            assert!(green_modules.is_empty());\n+            let curr = ThinLTOKeysMap::default();\n+            (None, None, curr)\n+        };\n+        info!(\"thin LTO cache key map loaded\");\n+        info!(\"prev_key_map: {:#?}\", prev_key_map);\n+        info!(\"curr_key_map: {:#?}\", curr_key_map);\n \n         // Throw our data in an `Arc` as we'll be sharing it across threads. We\n         // also put all memory referenced by the C++ data (buffers, ids, etc)\n@@ -528,60 +526,14 @@ fn thin_lto(\n         info!(\"checking which modules can be-reused and which have to be re-optimized.\");\n         for (module_index, module_name) in shared.module_names.iter().enumerate() {\n             let module_name = module_name_to_str(module_name);\n-\n-            // If (1.) the module hasn't changed, and (2.) none of the modules\n-            // it imports from have changed, *and* (3.) the import and export\n-            // sets themselves have not changed from the previous compile when\n-            // it was last ThinLTO'ed, then we can re-use the post-ThinLTO\n-            // version of the module. Otherwise, freshly perform LTO\n-            // optimization.\n-            //\n-            // (Note that globally, the export set is just the inverse of the\n-            // import set.)\n-            //\n-            // For further justification of why the above is necessary and sufficient,\n-            // see the LLVM blog post on ThinLTO:\n-            //\n-            // http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html\n-            //\n-            // which states the following:\n-            //\n-            // ```quote\n-            // any particular ThinLTO backend must be redone iff:\n-            //\n-            // 1. The corresponding (primary) module\u2019s bitcode changed\n-            // 2. The list of imports into or exports from the module changed\n-            // 3. The bitcode for any module being imported from has changed\n-            // 4. Any global analysis result affecting either the primary module\n-            //    or anything it imports has changed.\n-            // ```\n-            //\n-            // This strategy means we can always save the computed imports as\n-            // canon: when we reuse the post-ThinLTO version, condition (3.)\n-            // ensures that the current import set is the same as the previous\n-            // one. (And of course, when we don't reuse the post-ThinLTO\n-            // version, the current import set *is* the correct one, since we\n-            // are doing the ThinLTO in this current compilation cycle.)\n-            //\n-            // For more discussion, see rust-lang/rust#59535 (where the import\n-            // issue was discovered) and rust-lang/rust#69798 (where the\n-            // analogous export issue was discovered).\n-            if let (Some(prev_import_map), true) =\n-                (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n+            if let (Some(prev_key_map), true) =\n+                (prev_key_map.as_ref(), green_modules.contains_key(module_name))\n             {\n                 assert!(cgcx.incr_comp_session_dir.is_some());\n \n-                let prev_imports = prev_import_map.imports_of(module_name);\n-                let curr_imports = curr_import_map.imports_of(module_name);\n-                let prev_exports = prev_import_map.exports_of(module_name);\n-                let curr_exports = curr_import_map.exports_of(module_name);\n-                let imports_all_green = curr_imports\n-                    .iter()\n-                    .all(|imported_module| green_modules.contains_key(imported_module));\n-                if imports_all_green\n-                    && equivalent_as_sets(prev_imports, curr_imports)\n-                    && equivalent_as_sets(prev_exports, curr_exports)\n-                {\n+                // If a module exists in both the current and the previous session,\n+                // and has the same LTO cache key in both sessions, then we can re-use it\n+                if prev_key_map.keys.get(module_name) == curr_key_map.keys.get(module_name) {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n@@ -599,10 +551,10 @@ fn thin_lto(\n         }\n \n         // Save the current ThinLTO import information for the next compilation\n-        // session, overwriting the previous serialized imports (if any).\n-        if let Some(path) = import_map_path {\n-            if let Err(err) = curr_import_map.save_to_file(&path) {\n-                let msg = format!(\"Error while writing ThinLTO import data: {}\", err);\n+        // session, overwriting the previous serialized data (if any).\n+        if let Some(path) = key_map_path {\n+            if let Err(err) = curr_key_map.save_to_file(&path) {\n+                let msg = format!(\"Error while writing ThinLTO key data: {}\", err);\n                 return Err(write::llvm_err(&diag_handler, &msg));\n             }\n         }\n@@ -611,24 +563,6 @@ fn thin_lto(\n     }\n }\n \n-/// Given two slices, each with no repeat elements. returns true if and only if\n-/// the two slices have the same contents when considered as sets (i.e. when\n-/// element order is disregarded).\n-fn equivalent_as_sets(a: &[String], b: &[String]) -> bool {\n-    // cheap path: unequal lengths means cannot possibly be set equivalent.\n-    if a.len() != b.len() {\n-        return false;\n-    }\n-    // fast path: before building new things, check if inputs are equivalent as is.\n-    if a == b {\n-        return true;\n-    }\n-    // slow path: general set comparison.\n-    let a: FxHashSet<&str> = a.iter().map(|s| s.as_str()).collect();\n-    let b: FxHashSet<&str> = b.iter().map(|s| s.as_str()).collect();\n-    a == b\n-}\n-\n pub(crate) fn run_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -942,113 +876,56 @@ pub unsafe fn optimize_thin_module(\n     Ok(module)\n }\n \n-/// Summarizes module import/export relationships used by LLVM's ThinLTO pass.\n-///\n-/// Note that we tend to have two such instances of `ThinLTOImportMaps` in use:\n-/// one loaded from a file that represents the relationships used during the\n-/// compilation associated with the incremetnal build artifacts we are\n-/// attempting to reuse, and another constructed via `from_thin_lto_data`, which\n-/// captures the relationships of ThinLTO in the current compilation.\n+/// Maps LLVM module identifiers to their corresponding LLVM LTO cache keys\n #[derive(Debug, Default)]\n-pub struct ThinLTOImportMaps {\n-    // key = llvm name of importing module, value = list of modules it imports from\n-    imports: FxHashMap<String, Vec<String>>,\n-    // key = llvm name of exporting module, value = list of modules it exports to\n-    exports: FxHashMap<String, Vec<String>>,\n+pub struct ThinLTOKeysMap {\n+    // key = llvm name of importing module, value = LLVM cache key\n+    keys: FxHashMap<String, String>,\n }\n \n-impl ThinLTOImportMaps {\n-    /// Returns modules imported by `llvm_module_name` during some ThinLTO pass.\n-    fn imports_of(&self, llvm_module_name: &str) -> &[String] {\n-        self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n-    /// Returns modules exported by `llvm_module_name` during some ThinLTO pass.\n-    fn exports_of(&self, llvm_module_name: &str) -> &[String] {\n-        self.exports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n+impl ThinLTOKeysMap {\n     fn save_to_file(&self, path: &Path) -> io::Result<()> {\n         use std::io::Write;\n         let file = File::create(path)?;\n         let mut writer = io::BufWriter::new(file);\n-        for (importing_module_name, imported_modules) in &self.imports {\n-            writeln!(writer, \"{}\", importing_module_name)?;\n-            for imported_module in imported_modules {\n-                writeln!(writer, \" {}\", imported_module)?;\n-            }\n-            writeln!(writer)?;\n+        for (module, key) in &self.keys {\n+            writeln!(writer, \"{} {}\", module, key)?;\n         }\n         Ok(())\n     }\n \n-    fn load_from_file(path: &Path) -> io::Result<ThinLTOImportMaps> {\n+    fn load_from_file(path: &Path) -> io::Result<Self> {\n         use std::io::BufRead;\n-        let mut imports = FxHashMap::default();\n-        let mut exports: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-        let mut current_module: Option<String> = None;\n-        let mut current_imports: Vec<String> = vec![];\n+        let mut keys = FxHashMap::default();\n         let file = File::open(path)?;\n         for line in io::BufReader::new(file).lines() {\n             let line = line?;\n-            if line.is_empty() {\n-                let importing_module = current_module.take().expect(\"Importing module not set\");\n-                for imported in &current_imports {\n-                    exports.entry(imported.clone()).or_default().push(importing_module.clone());\n-                }\n-                imports.insert(importing_module, mem::replace(&mut current_imports, vec![]));\n-            } else if line.starts_with(' ') {\n-                // Space marks an imported module\n-                assert_ne!(current_module, None);\n-                current_imports.push(line.trim().to_string());\n-            } else {\n-                // Otherwise, beginning of a new module (must be start or follow empty line)\n-                assert_eq!(current_module, None);\n-                current_module = Some(line.trim().to_string());\n-            }\n+            let mut split = line.split(\" \");\n+            let module = split.next().unwrap();\n+            let key = split.next().unwrap();\n+            assert_eq!(split.next(), None, \"Expected two space-separated values, found {:?}\", line);\n+            keys.insert(module.to_string(), key.to_string());\n         }\n-        Ok(ThinLTOImportMaps { imports, exports })\n+        Ok(Self { keys })\n     }\n \n-    /// Loads the ThinLTO import map from ThinLTOData.\n-    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImportMaps {\n-        unsafe extern \"C\" fn imported_module_callback(\n-            payload: *mut libc::c_void,\n-            importing_module_name: *const libc::c_char,\n-            imported_module_name: *const libc::c_char,\n-        ) {\n-            let map = &mut *(payload as *mut ThinLTOImportMaps);\n-            let importing_module_name = CStr::from_ptr(importing_module_name);\n-            let importing_module_name = module_name_to_str(&importing_module_name);\n-            let imported_module_name = CStr::from_ptr(imported_module_name);\n-            let imported_module_name = module_name_to_str(&imported_module_name);\n-\n-            if !map.imports.contains_key(importing_module_name) {\n-                map.imports.insert(importing_module_name.to_owned(), vec![]);\n-            }\n-\n-            map.imports\n-                .get_mut(importing_module_name)\n-                .unwrap()\n-                .push(imported_module_name.to_owned());\n-\n-            if !map.exports.contains_key(imported_module_name) {\n-                map.exports.insert(imported_module_name.to_owned(), vec![]);\n-            }\n-\n-            map.exports\n-                .get_mut(imported_module_name)\n-                .unwrap()\n-                .push(importing_module_name.to_owned());\n-        }\n-\n-        let mut map = ThinLTOImportMaps::default();\n-        llvm::LLVMRustGetThinLTOModuleImports(\n-            data,\n-            imported_module_callback,\n-            &mut map as *mut _ as *mut libc::c_void,\n-        );\n-        map\n+    fn from_thin_lto_modules(\n+        data: &ThinData,\n+        modules: &[llvm::ThinLTOModule],\n+        names: &[CString],\n+    ) -> Self {\n+        let keys = modules\n+            .iter()\n+            .zip(names.iter())\n+            .map(|(module, name)| {\n+                let key = build_string(|rust_str| unsafe {\n+                    llvm::LLVMRustComputeLTOCacheKey(rust_str, module.identifier, data.0);\n+                })\n+                .expect(\"Invalid ThinLTO module key\");\n+                (name.clone().into_string().unwrap(), key)\n+            })\n+            .collect();\n+        Self { keys }\n     }\n }\n "}, {"sha": "4c1fee0106a94a9e89782c06ec532884910f28fa", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -2362,4 +2362,10 @@ extern \"C\" {\n         bytecode_len: usize,\n     ) -> bool;\n     pub fn LLVMRustLinkerFree(linker: &'a mut Linker<'a>);\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustComputeLTOCacheKey(\n+        key_out: &RustString,\n+        mod_id: *const c_char,\n+        data: &ThinLTOData,\n+    );\n }"}, {"sha": "71ca4f23bbb170055974812d0ac498ea915fb6c9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -1212,6 +1212,7 @@ struct LLVMRustThinLTOData {\n   StringMap<FunctionImporter::ImportMapTy> ImportLists;\n   StringMap<FunctionImporter::ExportSetTy> ExportLists;\n   StringMap<GVSummaryMapTy> ModuleToDefinedGVSummaries;\n+  StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n \n   LLVMRustThinLTOData() : Index(/* HaveGVs = */ false) {}\n };\n@@ -1308,7 +1309,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   //\n   // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp` with some of this\n   // being lifted from `lib/LTO/LTO.cpp` as well\n-  StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n   DenseMap<GlobalValue::GUID, const GlobalValueSummary *> PrevailingCopy;\n   for (auto &I : Ret->Index) {\n     if (I.second.SummaryList.size() > 1)\n@@ -1323,7 +1323,7 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   auto recordNewLinkage = [&](StringRef ModuleIdentifier,\n                               GlobalValue::GUID GUID,\n                               GlobalValue::LinkageTypes NewLinkage) {\n-    ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n+    Ret->ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n   };\n #if LLVM_VERSION_GE(9, 0)\n   thinLTOResolvePrevailingInIndex(Ret->Index, isPrevailing, recordNewLinkage,\n@@ -1491,7 +1491,7 @@ extern \"C\" typedef void (*LLVMRustModuleNameCallback)(void*, // payload\n // Calls `module_name_callback` for each module import done by ThinLTO.\n // The callback is provided with regular null-terminated C strings.\n extern \"C\" void\n-LLVMRustGetThinLTOModuleImports(const LLVMRustThinLTOData *data,\n+LLVMRustGetThinLTOModules(const LLVMRustThinLTOData *data,\n                                 LLVMRustModuleNameCallback module_name_callback,\n                                 void* callback_payload) {\n   for (const auto& importing_module : data->ImportLists) {\n@@ -1653,3 +1653,36 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n   MD->clearOperands();\n   MD->addOperand(Unit);\n }\n+\n+// Computes the LTO cache key for the provided 'ModId' in the given 'Data',\n+// storing the result in 'KeyOut'.\n+// Currently, this cache key is a SHA-1 hash of anything that could affect\n+// the result of optimizing this module (e.g. module imports, exports, liveness\n+// of access globals, etc).\n+// The precise details are determined by LLVM in `computeLTOCacheKey`, which is\n+// used during the normal linker-plugin incremental thin-LTO process.\n+extern \"C\" void\n+LLVMRustComputeLTOCacheKey(RustStringRef KeyOut, const char *ModId, LLVMRustThinLTOData *Data) {\n+  SmallString<40> Key;\n+  llvm::lto::Config conf;\n+  const auto &ImportList = Data->ImportLists.lookup(ModId);\n+  const auto &ExportList = Data->ExportLists.lookup(ModId);\n+  const auto &ResolvedODR = Data->ResolvedODR.lookup(ModId);\n+  const auto &DefinedGlobals = Data->ModuleToDefinedGVSummaries.lookup(ModId);\n+  std::set<GlobalValue::GUID> CfiFunctionDefs;\n+  std::set<GlobalValue::GUID> CfiFunctionDecls;\n+\n+  // Based on the 'InProcessThinBackend' constructor in LLVM\n+  for (auto &Name : Data->Index.cfiFunctionDefs())\n+    CfiFunctionDefs.insert(\n+        GlobalValue::getGUID(GlobalValue::dropLLVMManglingEscape(Name)));\n+  for (auto &Name : Data->Index.cfiFunctionDecls())\n+    CfiFunctionDecls.insert(\n+        GlobalValue::getGUID(GlobalValue::dropLLVMManglingEscape(Name)));\n+\n+  llvm::computeLTOCacheKey(Key, conf, Data->Index, ModId,\n+      ImportList, ExportList, ResolvedODR, DefinedGlobals, CfiFunctionDefs, CfiFunctionDecls\n+  );\n+\n+  LLVMRustStringWriteImpl(KeyOut, Key.c_str(), Key.size());\n+}"}, {"sha": "5fe435d796f56343df87eea3c067ca4775a70b3e", "filename": "src/test/incremental/thinlto/cgu_invalidated_via_import.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_invalidated_via_import.rs?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -33,7 +33,9 @@ mod foo {\n \n     #[cfg(not(cfail1))]\n     pub fn inlined_fn() -> u32 {\n-        1234\n+        // See `cgu_keeps_identical_fn.rs` for why this is different\n+        // from the other version of this function.\n+        12345\n     }\n }\n "}, {"sha": "0fd5abee11840996a234b0cd64f732d4f4a17878", "filename": "src/test/incremental/thinlto/cgu_keeps_identical_fn.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_keeps_identical_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_keeps_identical_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Fcgu_keeps_identical_fn.rs?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -0,0 +1,47 @@\n+// This test is almost identical to `cgu_invalided_via_import`, except that\n+// the two versions of `inline_fn` are identical. Neither version of `inlined_fn`\n+// ends up with any spans in its LLVM bitecode, so LLVM is able to skip\n+// re-building any modules which import 'inlined_fn'\n+\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -O\n+// build-pass (FIXME(62277): could be check-pass?)\n+\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+#![rustc_expected_cgu_reuse(module=\"cgu_keeps_identical_fn-foo\",\n+                            cfg=\"cfail2\",\n+                            kind=\"no\")]\n+#![rustc_expected_cgu_reuse(module=\"cgu_keeps_identical_fn-foo\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+#![rustc_expected_cgu_reuse(module=\"cgu_keeps_identical_fn-bar\",\n+                            cfg=\"cfail2\",\n+                            kind=\"post-lto\")]\n+#![rustc_expected_cgu_reuse(module=\"cgu_keeps_identical_fn-bar\",\n+                            cfg=\"cfail3\",\n+                            kind=\"post-lto\")]\n+\n+mod foo {\n+\n+    // Trivial functions like this one are imported very reliably by ThinLTO.\n+    #[cfg(cfail1)]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+\n+    #[cfg(not(cfail1))]\n+    pub fn inlined_fn() -> u32 {\n+        1234\n+    }\n+}\n+\n+pub mod bar {\n+    use foo::inlined_fn;\n+\n+    pub fn caller() -> u32 {\n+        inlined_fn()\n+    }\n+}"}, {"sha": "045f2011958bdf6ec9bee94a9a3e5c7b5247653b", "filename": "src/test/incremental/thinlto/independent_cgus_dont_affect_each_other.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71248b70870960af9993de4f31d3cba9bbce7e8/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fthinlto%2Findependent_cgus_dont_affect_each_other.rs?ref=c71248b70870960af9993de4f31d3cba9bbce7e8", "patch": "@@ -37,7 +37,9 @@ mod foo {\n \n     #[cfg(not(cfail1))]\n     pub fn inlined_fn() -> u32 {\n-        1234\n+        // See `cgu_keeps_identical_fn.rs` for why this is different\n+        // from the other version of this function.\n+        12345\n     }\n }\n "}]}