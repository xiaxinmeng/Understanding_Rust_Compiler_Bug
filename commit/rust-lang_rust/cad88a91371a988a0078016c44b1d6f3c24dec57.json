{"sha": "cad88a91371a988a0078016c44b1d6f3c24dec57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZDg4YTkxMzcxYTk4OGEwMDc4MDE2YzQ0YjFkNmYzYzI0ZGVjNTc=", "commit": {"author": {"name": "Florian Hartwig", "email": "florian.j.hartwig@gmail.com", "date": "2015-11-19T13:39:27Z"}, "committer": {"name": "Florian Hartwig", "email": "florian.j.hartwig@gmail.com", "date": "2015-11-19T16:15:21Z"}, "message": "warn on use of ok().expect()", "tree": {"sha": "c1ee41f8b758a07d6f5268b29df19f7cf2993b55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1ee41f8b758a07d6f5268b29df19f7cf2993b55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cad88a91371a988a0078016c44b1d6f3c24dec57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cad88a91371a988a0078016c44b1d6f3c24dec57", "html_url": "https://github.com/rust-lang/rust/commit/cad88a91371a988a0078016c44b1d6f3c24dec57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cad88a91371a988a0078016c44b1d6f3c24dec57/comments", "author": {"login": "fhartwig", "id": 83271, "node_id": "MDQ6VXNlcjgzMjcx", "avatar_url": "https://avatars.githubusercontent.com/u/83271?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhartwig", "html_url": "https://github.com/fhartwig", "followers_url": "https://api.github.com/users/fhartwig/followers", "following_url": "https://api.github.com/users/fhartwig/following{/other_user}", "gists_url": "https://api.github.com/users/fhartwig/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhartwig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhartwig/subscriptions", "organizations_url": "https://api.github.com/users/fhartwig/orgs", "repos_url": "https://api.github.com/users/fhartwig/repos", "events_url": "https://api.github.com/users/fhartwig/events{/privacy}", "received_events_url": "https://api.github.com/users/fhartwig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhartwig", "id": 83271, "node_id": "MDQ6VXNlcjgzMjcx", "avatar_url": "https://avatars.githubusercontent.com/u/83271?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhartwig", "html_url": "https://github.com/fhartwig", "followers_url": "https://api.github.com/users/fhartwig/followers", "following_url": "https://api.github.com/users/fhartwig/following{/other_user}", "gists_url": "https://api.github.com/users/fhartwig/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhartwig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhartwig/subscriptions", "organizations_url": "https://api.github.com/users/fhartwig/orgs", "repos_url": "https://api.github.com/users/fhartwig/repos", "events_url": "https://api.github.com/users/fhartwig/events{/privacy}", "received_events_url": "https://api.github.com/users/fhartwig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68e97ea643a1fbb0e8969a2d825112eee52674a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e97ea643a1fbb0e8969a2d825112eee52674a5", "html_url": "https://github.com/rust-lang/rust/commit/68e97ea643a1fbb0e8969a2d825112eee52674a5"}], "stats": {"total": 134, "additions": 128, "deletions": 6}, "files": [{"sha": "35e303b749b7ea431437b41cc6065045f2936259", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cad88a91371a988a0078016c44b1d6f3c24dec57/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad88a91371a988a0078016c44b1d6f3c24dec57/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cad88a91371a988a0078016c44b1d6f3c24dec57", "patch": "@@ -85,7 +85,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n-    reg.register_late_lint_pass(box methods::MethodsPass);\n+    reg.register_late_lint_pass(box methods::MethodsPass::new());\n     reg.register_late_lint_pass(box shadow::ShadowPass);\n     reg.register_late_lint_pass(box types::LetPass);\n     reg.register_late_lint_pass(box types::UnitCmp);\n@@ -151,6 +151,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::OK_EXPECT,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,"}, {"sha": "dbc18fdfe33ceb3ea6821d809c948cdb67dcc7b7", "filename": "src/methods.rs", "status": "modified", "additions": 103, "deletions": 5, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cad88a91371a988a0078016c44b1d6f3c24dec57/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad88a91371a988a0078016c44b1d6f3c24dec57/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=cad88a91371a988a0078016c44b1d6f3c24dec57", "patch": "@@ -1,18 +1,81 @@\n use rustc_front::hir::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n-use rustc::middle::subst::Subst;\n+use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n+use std::collections::HashSet;\n \n-use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth};\n+use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth,\n+    walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n use self::SelfKind::*;\n use self::OutType::*;\n \n-#[derive(Copy,Clone)]\n-pub struct MethodsPass;\n+use rustc::middle::def_id::DefId;\n+\n+use rustc::middle::ty::TypeFlags;\n+\n+#[derive(Clone)]\n+pub struct MethodsPass { types_implementing_debug: Option<HashSet<DefId>> }\n+\n+impl MethodsPass {\n+    pub fn new() -> MethodsPass {\n+        MethodsPass { types_implementing_debug: None }\n+    }\n+\n+    fn get_debug_impls(&mut self, cx: &LateContext) -> Option<&HashSet<DefId>> {\n+        if self.types_implementing_debug.is_none() {\n+            let debug = match cx.tcx.lang_items.debug_trait() {\n+                Some(debug) => debug,\n+                None => return None\n+            };\n+            let debug_def = cx.tcx.lookup_trait_def(debug);\n+            let mut impls = HashSet::new();\n+            debug_def.for_each_impl(cx.tcx, |d| {\n+                let o_self_ty = &cx.tcx.impl_trait_ref(d)\n+                                    .map(|x| x.substs)\n+                                    .and_then(|x| x.self_ty());\n+                let self_ty = match *o_self_ty {\n+                    Some(self_type) => self_type,\n+                    None => return\n+                };\n+                let self_ty_def_id = self_ty.ty_to_def_id();\n+                if let Some(self_ty_def_id) = self_ty_def_id {\n+                    let has_params = self_ty.flags.get().contains(TypeFlags::HAS_PARAMS);\n+                    if !has_params {\n+                        impls.insert(self_ty_def_id);\n+                    }\n+                }\n+            });\n+            self.types_implementing_debug = Some(impls);\n+        }\n+        self.types_implementing_debug.as_ref()\n+    }\n+\n+    // This checks whether a given type is known to implement Debug. It's\n+    // conservative, i.e. it should not return false positives, but will return\n+    // false negatives.\n+    fn has_debug_impl(&mut self, ty: ty::Ty, cx: &LateContext) -> bool {\n+        let debug_impls = match self.get_debug_impls(cx) {\n+            Some(debug_impls) => debug_impls,\n+            None => return false\n+        };\n+        match walk_ptrs_ty(ty).sty {\n+            ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..)\n+                       | ty::TyFloat(..) | ty::TyStr => true,\n+            ty::TyTuple(ref v) if v.is_empty() => true,\n+            ty::TyStruct(..) | ty::TyEnum(..) => {\n+                match ty.ty_to_def_id() {\n+                    Some(ref ty_def_id) => debug_impls.contains(ty_def_id),\n+                    None => false\n+                }\n+            },\n+            _ => false\n+        }\n+    }\n+}\n \n declare_lint!(pub OPTION_UNWRAP_USED, Allow,\n               \"using `Option.unwrap()`, which should at least get a better message using `expect()`\");\n@@ -30,16 +93,21 @@ declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n declare_lint!(pub WRONG_PUB_SELF_CONVENTION, Allow,\n               \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n                `self` with the wrong convention\");\n+declare_lint!(pub OK_EXPECT, Warn,\n+              \"using `ok().expect()`, which gives worse error messages than \\\n+               calling `expect` directly on the Result\");\n+\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n-                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION)\n+                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION, OK_EXPECT)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+\n         if let ExprMethodCall(ref name, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n             if name.node.as_str() == \"unwrap\" {\n@@ -70,6 +138,22 @@ impl LateLintPass for MethodsPass {\n                                                                 `clone()` to make a copy\");\n                 }\n             }\n+            else if name.node.as_str() == \"expect\" {\n+                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                    if inner_name.node.as_str() == \"ok\"\n+                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n+                        let result_type = cx.tcx.expr_ty(&inner_args[0]);\n+                        if let Some(error_type) = get_error_type(cx, result_type) {\n+                            if self.has_debug_impl(error_type, cx) {\n+                                span_lint(cx, OK_EXPECT, expr.span,\n+                                         \"called `ok().expect()` on a Result \\\n+                                          value. You can call `expect` directly\n+                                          on the `Result`\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -115,6 +199,20 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+// Given a `Result<T, E>` type, return its error type (`E`)\n+fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n+    if !match_type(cx, ty, &RESULT_PATH) {\n+        return None;\n+    }\n+    if let ty::TyEnum(_, substs) = ty.sty {\n+        if let Some(err_ty) = substs.types.opt_get(TypeSpace, 1) {\n+            return Some(err_ty);\n+        }\n+    }\n+    None\n+}\n+\n+\n const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n     (\"into_\", &[ValueSelf]),\n     (\"to_\",   &[RefSelf]),"}, {"sha": "aeb79503504b8bc82aa79a2f12c68eea3d3cdc80", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cad88a91371a988a0078016c44b1d6f3c24dec57/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad88a91371a988a0078016c44b1d6f3c24dec57/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=cad88a91371a988a0078016c44b1d6f3c24dec57", "patch": "@@ -35,6 +35,8 @@ impl Mul<T> for T {\n }\n \n fn main() {\n+    use std::io;\n+\n     let opt = Some(0);\n     let _ = opt.unwrap();  //~ERROR used unwrap() on an Option\n \n@@ -46,4 +48,25 @@ fn main() {\n     let v = &\"str\";\n     let string = v.to_string();  //~ERROR `(*v).to_owned()` is faster\n     let _again = string.to_string();  //~ERROR `String.to_string()` is a no-op\n+\n+    res.ok().expect(\"disaster!\"); //~ERROR called `ok().expect()`\n+    // the following should not warn, since `expect` isn't implemented unless\n+    // the error type implements `Debug`\n+    let res2: Result<i32, MyError> = Ok(0);\n+    res2.ok().expect(\"oh noes!\");\n+    // we're currently don't warn if the error type has a type parameter\n+    // (but it would be nice if we did)\n+    let res3: Result<u32, MyErrorWithParam<u8>>= Ok(0);\n+    res3.ok().expect(\"whoof\");\n+    let res4: Result<u32, io::Error> = Ok(0);\n+    res4.ok().expect(\"argh\"); //~ERROR called `ok().expect()`\n+    let res5: io::Result<u32> = Ok(0);\n+    res5.ok().expect(\"oops\"); //~ERROR called `ok().expect()`\n+}\n+\n+struct MyError(()); // doesn't implement Debug\n+\n+#[derive(Debug)]\n+struct MyErrorWithParam<T> {\n+    x: T\n }"}]}