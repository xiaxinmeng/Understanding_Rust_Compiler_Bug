{"sha": "6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "node_id": "C_kwDOAAsO6NoAKDZmMmI1MmZmMTAzZjkwOTVmYjI4MTc2MzdiYzdkMzg4YmQ0YzdmNmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-04T14:17:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-04T14:17:17Z"}, "message": "Auto merge of #2566 - saethlin:gc-cleanup, r=oli-obk\n\nExpand VisitMachineValues to cover more pointers in the interpreter\n\nFollow-on to https://github.com/rust-lang/miri/pull/2559\n\nThis is making me want to write a proc macro :thinking:\n\nr? `@RalfJung`", "tree": {"sha": "0ab0db15b18fdc965721b26c9552aa0dfb0ca3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab0db15b18fdc965721b26c9552aa0dfb0ca3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "html_url": "https://github.com/rust-lang/rust/commit/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "796bcf99dc27d8ca0194a89c95afd562a41efa3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/796bcf99dc27d8ca0194a89c95afd562a41efa3d", "html_url": "https://github.com/rust-lang/rust/commit/796bcf99dc27d8ca0194a89c95afd562a41efa3d"}, {"sha": "e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "html_url": "https://github.com/rust-lang/rust/commit/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce"}], "stats": {"total": 591, "additions": 464, "deletions": 127}, "files": [{"sha": "d0fc349f1acc3a011d087dc335e3b875b0f198c0", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -696,6 +696,12 @@ pub struct VClockAlloc {\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n }\n \n+impl VisitTags for VClockAlloc {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // No tags here.\n+    }\n+}\n+\n impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n     pub fn new_allocation(\n@@ -1239,6 +1245,12 @@ pub struct GlobalState {\n     pub track_outdated_loads: bool,\n }\n \n+impl VisitTags for GlobalState {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // We don't have any tags.\n+    }\n+}\n+\n impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1."}, {"sha": "dfe2e9f05dafd6d2bee87bb2b3506b7ad58f6b80", "filename": "src/tools/miri/src/concurrency/range_object_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -132,6 +132,10 @@ impl<T> RangeObjectMap<T> {\n     pub fn remove_from_pos(&mut self, pos: Position) {\n         self.v.remove(pos);\n     }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &T> {\n+        self.v.iter().map(|e| &e.data)\n+    }\n }\n \n impl<T> Index<Position> for RangeObjectMap<T> {"}, {"sha": "ec1da4138d448c392155a2adcad3df7ad46c7dbe", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 69, "deletions": 31, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -32,9 +32,11 @@ pub enum SchedulingAction {\n \n /// Timeout callbacks can be created by synchronization primitives to tell the\n /// scheduler that they should be called once some period of time passes.\n-type TimeoutCallback<'mir, 'tcx> = Box<\n-    dyn FnOnce(&mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx,\n->;\n+pub trait MachineCallback<'mir, 'tcx>: VisitTags {\n+    fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n+}\n+\n+type TimeoutCallback<'mir, 'tcx> = Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>;\n \n /// A thread identifier.\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n@@ -181,6 +183,46 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     }\n }\n \n+impl VisitTags for Thread<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n+            self;\n+\n+        panic_payload.visit_tags(visit);\n+        last_error.visit_tags(visit);\n+        for frame in stack {\n+            frame.visit_tags(visit)\n+        }\n+    }\n+}\n+\n+impl VisitTags for Frame<'_, '_, Provenance, FrameData<'_>> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let Frame {\n+            return_place,\n+            locals,\n+            extra,\n+            body: _,\n+            instance: _,\n+            return_to_block: _,\n+            loc: _,\n+            // There are some private fields we cannot access; they contain no tags.\n+            ..\n+        } = self;\n+\n+        // Return place.\n+        return_place.visit_tags(visit);\n+        // Locals.\n+        for local in locals.iter() {\n+            if let LocalValue::Live(value) = &local.value {\n+                value.visit_tags(visit);\n+            }\n+        }\n+\n+        extra.visit_tags(visit);\n+    }\n+}\n+\n /// A specific moment in time.\n #[derive(Debug)]\n pub enum Time {\n@@ -253,6 +295,29 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     }\n }\n \n+impl VisitTags for ThreadManager<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let ThreadManager {\n+            threads,\n+            thread_local_alloc_ids,\n+            timeout_callbacks,\n+            active_thread: _,\n+            yield_active_thread: _,\n+            sync: _,\n+        } = self;\n+\n+        for thread in threads {\n+            thread.visit_tags(visit);\n+        }\n+        for ptr in thread_local_alloc_ids.borrow().values() {\n+            ptr.visit_tags(visit);\n+        }\n+        for callback in timeout_callbacks.values() {\n+            callback.callback.visit_tags(visit);\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     pub(crate) fn init(ecx: &mut MiriInterpCx<'mir, 'tcx>) {\n         if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n@@ -625,33 +690,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n }\n \n-impl VisitMachineValues for ThreadManager<'_, '_> {\n-    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n-        // FIXME some other fields also contain machine values\n-        let ThreadManager { threads, .. } = self;\n-\n-        for thread in threads {\n-            // FIXME: implement VisitMachineValues for `Thread` and `Frame` instead.\n-            // In particular we need to visit the `last_error` and `catch_unwind` fields.\n-            if let Some(payload) = thread.panic_payload {\n-                visit(&Operand::Immediate(Immediate::Scalar(payload)))\n-            }\n-            for frame in &thread.stack {\n-                // Return place.\n-                if let Place::Ptr(mplace) = *frame.return_place {\n-                    visit(&Operand::Indirect(mplace));\n-                }\n-                // Locals.\n-                for local in frame.locals.iter() {\n-                    if let LocalValue::Live(value) = &local.value {\n-                        visit(value);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n // Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n@@ -930,7 +968,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // 2. Make the scheduler the only place that can change the active\n         //    thread.\n         let old_thread = this.set_active_thread(thread);\n-        callback(this)?;\n+        callback.call(this)?;\n         this.set_active_thread(old_thread);\n         Ok(())\n     }"}, {"sha": "9d7a49c0b4301b3260c3080ca024e40fda3a005f", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -108,6 +108,19 @@ pub struct StoreBufferAlloc {\n     store_buffers: RefCell<RangeObjectMap<StoreBuffer>>,\n }\n \n+impl VisitTags for StoreBufferAlloc {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let Self { store_buffers } = self;\n+        for val in store_buffers\n+            .borrow()\n+            .iter()\n+            .flat_map(|buf| buf.buffer.iter().map(|element| &element.val))\n+        {\n+            val.visit_tags(visit);\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(super) struct StoreBuffer {\n     // Stores to this location in modification order"}, {"sha": "9722b7643e426cea90324dc1f7258816a29d7104", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -44,6 +44,12 @@ pub struct GlobalStateInner {\n     provenance_mode: ProvenanceMode,\n }\n \n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // Nothing to visit here.\n+    }\n+}\n+\n impl GlobalStateInner {\n     pub fn new(config: &MiriConfig) -> Self {\n         GlobalStateInner {"}, {"sha": "463feb4dcc8a1ed309e2990dae8e8ac8b9210180", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -112,7 +112,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n-pub use crate::tag_gc::{EvalContextExt as _, VisitMachineValues};\n+pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "20ae908fce87c7db5eb5f5cf34b2a12a7548826f", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -63,6 +63,15 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     }\n }\n \n+impl VisitTags for FrameData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n+\n+        catch_unwind.visit_tags(visit);\n+        stacked_borrows.visit_tags(visit);\n+    }\n+}\n+\n /// Extra memory kinds\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MiriMemoryKind {\n@@ -251,6 +260,16 @@ pub struct AllocExtra {\n     pub weak_memory: Option<weak_memory::AllocExtra>,\n }\n \n+impl VisitTags for AllocExtra {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let AllocExtra { stacked_borrows, data_race, weak_memory } = self;\n+\n+        stacked_borrows.visit_tags(visit);\n+        data_race.visit_tags(visit);\n+        weak_memory.visit_tags(visit);\n+    }\n+}\n+\n /// Precomputed layouts of primitive types\n pub struct PrimitiveLayouts<'tcx> {\n     pub unit: TyAndLayout<'tcx>,\n@@ -591,14 +610,65 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n     }\n }\n \n-impl VisitMachineValues for MiriMachine<'_, '_> {\n-    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n-        // FIXME: visit the missing fields: env vars, weak mem, the MemPlace fields in the machine,\n-        // DirHandler, extern_statics, the Stacked Borrows base pointers; maybe more.\n-        let MiriMachine { threads, tls, .. } = self;\n-\n-        threads.visit_machine_values(visit);\n-        tls.visit_machine_values(visit);\n+impl VisitTags for MiriMachine<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        #[rustfmt::skip]\n+        let MiriMachine {\n+            threads,\n+            tls,\n+            env_vars,\n+            argc,\n+            argv,\n+            cmd_line,\n+            extern_statics,\n+            dir_handler,\n+            stacked_borrows,\n+            data_race,\n+            intptrcast,\n+            file_handler,\n+            tcx: _,\n+            isolated_op: _,\n+            validate: _,\n+            enforce_abi: _,\n+            clock: _,\n+            layouts: _,\n+            static_roots: _,\n+            profiler: _,\n+            string_cache: _,\n+            exported_symbols_cache: _,\n+            panic_on_unsupported: _,\n+            backtrace_style: _,\n+            local_crates: _,\n+            rng: _,\n+            tracked_alloc_ids: _,\n+            check_alignment: _,\n+            cmpxchg_weak_failure_rate: _,\n+            mute_stdout_stderr: _,\n+            weak_memory: _,\n+            preemption_rate: _,\n+            report_progress: _,\n+            basic_block_count: _,\n+            #[cfg(unix)]\n+            external_so_lib: _,\n+            gc_interval: _,\n+            since_gc: _,\n+            num_cpus: _,\n+        } = self;\n+\n+        threads.visit_tags(visit);\n+        tls.visit_tags(visit);\n+        env_vars.visit_tags(visit);\n+        dir_handler.visit_tags(visit);\n+        file_handler.visit_tags(visit);\n+        data_race.visit_tags(visit);\n+        stacked_borrows.visit_tags(visit);\n+        intptrcast.visit_tags(visit);\n+        argc.visit_tags(visit);\n+        argv.visit_tags(visit);\n+        cmd_line.visit_tags(visit);\n+        for ptr in extern_statics.values() {\n+            ptr.visit_tags(visit);\n+        }\n     }\n }\n "}, {"sha": "076d3878de2ac6b0f3e3fa8c922a40f88d25a102", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -36,6 +36,17 @@ pub struct EnvVars<'tcx> {\n     pub(crate) environ: Option<MPlaceTy<'tcx, Provenance>>,\n }\n \n+impl VisitTags for EnvVars<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let EnvVars { map, environ } = self;\n+\n+        environ.visit_tags(visit);\n+        for ptr in map.values() {\n+            ptr.visit_tags(visit);\n+        }\n+    }\n+}\n+\n impl<'tcx> EnvVars<'tcx> {\n     pub(crate) fn init<'mir>(\n         ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,"}, {"sha": "698e025961da83c174affcb58a6572a4a325e8d2", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -35,6 +35,15 @@ pub struct CatchUnwindData<'tcx> {\n     ret: mir::BasicBlock,\n }\n \n+impl VisitTags for CatchUnwindData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let CatchUnwindData { catch_fn, data, dest, ret: _ } = self;\n+        catch_fn.visit_tags(visit);\n+        data.visit_tags(visit);\n+        dest.visit_tags(visit);\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Handles the special `miri_start_panic` intrinsic, which is called"}, {"sha": "9f04034e1a12d9265e3af4b2dbadba8b63b53ab9", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -1,5 +1,6 @@\n use std::time::{Duration, SystemTime};\n \n+use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n /// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n@@ -218,10 +219,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(move |ecx| {\n-                ecx.unblock_thread(active_thread);\n-                Ok(())\n-            }),\n+            Box::new(UnblockCallback { thread_to_unblock: active_thread }),\n         );\n \n         Ok(0)\n@@ -244,12 +242,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(move |ecx| {\n-                ecx.unblock_thread(active_thread);\n-                Ok(())\n-            }),\n+            Box::new(UnblockCallback { thread_to_unblock: active_thread }),\n         );\n \n         Ok(())\n     }\n }\n+\n+struct UnblockCallback {\n+    thread_to_unblock: ThreadId,\n+}\n+\n+impl VisitTags for UnblockCallback {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {}\n+}\n+\n+impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for UnblockCallback {\n+    fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        ecx.unblock_thread(self.thread_to_unblock);\n+        Ok(())\n+    }\n+}"}, {"sha": "430dedbc1700c978dfb048d7c61bdaeb04b06c91", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -235,15 +235,15 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl VisitMachineValues for TlsData<'_> {\n-    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>)) {\n+impl VisitTags for TlsData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let TlsData { keys, macos_thread_dtors, next_key: _, dtors_running: _ } = self;\n \n         for scalar in keys.values().flat_map(|v| v.data.values()) {\n-            visit(&Operand::Immediate(Immediate::Scalar(*scalar)));\n+            scalar.visit_tags(visit);\n         }\n         for (_, scalar) in macos_thread_dtors.values() {\n-            visit(&Operand::Immediate(Immediate::Scalar(*scalar)));\n+            scalar.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "9713cd9265e55e86e55d9013d910d9a24d49a1ca", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -256,6 +256,12 @@ pub struct FileHandler {\n     handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n }\n \n+impl VisitTags for FileHandler {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // All our FileDescriptor do not have any tags.\n+    }\n+}\n+\n impl FileHandler {\n     pub(crate) fn new(mute_stdout_stderr: bool) -> FileHandler {\n         let mut handles: BTreeMap<_, Box<dyn FileDescriptor>> = BTreeMap::new();\n@@ -462,6 +468,16 @@ impl Default for DirHandler {\n     }\n }\n \n+impl VisitTags for DirHandler {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let DirHandler { streams, next_id: _ } = self;\n+\n+        for dir in streams.values() {\n+            dir.entry.visit_tags(visit);\n+        }\n+    }\n+}\n+\n fn maybe_sync_file(\n     file: &File,\n     writable: bool,"}, {"sha": "5762ee27b84af89b69f5d902bcf29ad77fa5ef47", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -1,4 +1,4 @@\n-use crate::concurrency::thread::Time;\n+use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n use rustc_target::abi::{Align, Size};\n use std::time::SystemTime;\n@@ -189,18 +189,36 @@ pub fn futex<'tcx>(\n                 // Register a timeout callback if a timeout was specified.\n                 // This callback will override the return value when the timeout triggers.\n                 if let Some(timeout_time) = timeout_time {\n+                    struct Callback<'tcx> {\n+                        thread: ThreadId,\n+                        addr_usize: u64,\n+                        dest: PlaceTy<'tcx, Provenance>,\n+                    }\n+\n+                    impl<'tcx> VisitTags for Callback<'tcx> {\n+                        fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                            let Callback { thread: _, addr_usize: _, dest } = self;\n+                            dest.visit_tags(visit);\n+                        }\n+                    }\n+\n+                    impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                        fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                            this.unblock_thread(self.thread);\n+                            this.futex_remove_waiter(self.addr_usize, self.thread);\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            this.set_last_error(etimedout)?;\n+                            this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n+\n+                            Ok(())\n+                        }\n+                    }\n+\n                     let dest = dest.clone();\n                     this.register_timeout_callback(\n                         thread,\n                         timeout_time,\n-                        Box::new(move |this| {\n-                            this.unblock_thread(thread);\n-                            this.futex_remove_waiter(addr_usize, thread);\n-                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n-                            this.set_last_error(etimedout)?;\n-                            this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n-                            Ok(())\n-                        }),\n+                        Box::new(Callback { thread, addr_usize, dest }),\n                     );\n                 }\n             } else {"}, {"sha": "5aafe76ade1d44ffd933af47385a3c132d8878ab", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -3,7 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n-use crate::concurrency::thread::Time;\n+use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n \n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n@@ -851,25 +851,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;\n \n-        // Register the timeout callback.\n-        let dest = dest.clone();\n-        this.register_timeout_callback(\n-            active_thread,\n-            timeout_time,\n-            Box::new(move |ecx| {\n+        struct Callback<'tcx> {\n+            active_thread: ThreadId,\n+            mutex_id: MutexId,\n+            id: CondvarId,\n+            dest: PlaceTy<'tcx, Provenance>,\n+        }\n+\n+        impl<'tcx> VisitTags for Callback<'tcx> {\n+            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n+                dest.visit_tags(visit);\n+            }\n+        }\n+\n+        impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+            fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n                 // We are not waiting for the condvar any more, wait for the\n                 // mutex instead.\n-                reacquire_cond_mutex(ecx, active_thread, mutex_id)?;\n+                reacquire_cond_mutex(ecx, self.active_thread, self.mutex_id)?;\n \n                 // Remove the thread from the conditional variable.\n-                ecx.condvar_remove_waiter(id, active_thread);\n+                ecx.condvar_remove_waiter(self.id, self.active_thread);\n \n                 // Set the return value: we timed out.\n                 let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n-                ecx.write_scalar(etimedout, &dest)?;\n+                ecx.write_scalar(etimedout, &self.dest)?;\n \n                 Ok(())\n-            }),\n+            }\n+        }\n+\n+        // Register the timeout callback.\n+        let dest = dest.clone();\n+        this.register_timeout_callback(\n+            active_thread,\n+            timeout_time,\n+            Box::new(Callback { active_thread, mutex_id, id, dest }),\n         );\n \n         Ok(())"}, {"sha": "2888f8e81fb51765f17001b9a3012fb3662b3e22", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -72,6 +72,12 @@ pub struct FrameExtra {\n     protected_tags: SmallVec<[SbTag; 2]>,\n }\n \n+impl VisitTags for FrameExtra {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // `protected_tags` are fine to GC.\n+    }\n+}\n+\n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n pub struct Stacks {\n@@ -110,6 +116,13 @@ pub struct GlobalStateInner {\n     retag_fields: bool,\n }\n \n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n+        // GC the bottommost tag.\n+    }\n+}\n+\n /// We need interior mutable access to the global state.\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n@@ -514,6 +527,14 @@ impl Stacks {\n     }\n }\n \n+impl VisitTags for Stacks {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for tag in self.exposed_tags.iter().copied() {\n+            visit(tag);\n+        }\n+    }\n+}\n+\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates a new stack with an initial tag. For diagnostic purposes, we also need to know"}, {"sha": "57de1c21c8b2de57a0feb284c5bee0457442873b", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -43,8 +43,11 @@ impl Stack {\n     pub fn retain(&mut self, tags: &FxHashSet<SbTag>) {\n         let mut first_removed = None;\n \n-        let mut read_idx = 1;\n-        let mut write_idx = 1;\n+        // For stacks with a known bottom, we never consider removing the bottom-most tag, because\n+        // that is the base tag which exists whether or not there are any pointers to the\n+        // allocation.\n+        let mut read_idx = if self.unknown_bottom.is_some() { 0 } else { 1 };\n+        let mut write_idx = read_idx;\n         while read_idx < self.borrows.len() {\n             let left = self.borrows[read_idx - 1];\n             let this = self.borrows[read_idx];"}, {"sha": "5aa653632f395818dc69ca5b13e34436fec63dbf", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 141, "deletions": 53, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f2b52ff103f9095fb2817637bc7d388bd4c7f6b/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=6f2b52ff103f9095fb2817637bc7d388bd4c7f6b", "patch": "@@ -2,33 +2,155 @@ use rustc_data_structures::fx::FxHashSet;\n \n use crate::*;\n \n-pub trait VisitMachineValues {\n-    fn visit_machine_values(&self, visit: &mut impl FnMut(&Operand<Provenance>));\n+pub trait VisitTags {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag));\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n-    /// Generic GC helper to visit everything that can store a value. The `acc` offers some chance to\n-    /// accumulate everything.\n-    fn visit_all_machine_values<T>(\n-        &self,\n-        acc: &mut T,\n-        mut visit_operand: impl FnMut(&mut T, &Operand<Provenance>),\n-        mut visit_alloc: impl FnMut(&mut T, &Allocation<Provenance, AllocExtra>),\n-    ) {\n-        let this = self.eval_context_ref();\n+impl<T: VisitTags> VisitTags for Option<T> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        if let Some(x) = self {\n+            x.visit_tags(visit);\n+        }\n+    }\n+}\n+\n+impl<T: VisitTags> VisitTags for std::cell::RefCell<T> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        self.borrow().visit_tags(visit)\n+    }\n+}\n+\n+impl VisitTags for SbTag {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        visit(*self)\n+    }\n+}\n+\n+impl VisitTags for Provenance {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        if let Provenance::Concrete { sb, .. } = self {\n+            visit(*sb);\n+        }\n+    }\n+}\n+\n+impl VisitTags for Pointer<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let (prov, _offset) = self.into_parts();\n+        prov.visit_tags(visit);\n+    }\n+}\n+\n+impl VisitTags for Pointer<Option<Provenance>> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let (prov, _offset) = self.into_parts();\n+        prov.visit_tags(visit);\n+    }\n+}\n+\n+impl VisitTags for Scalar<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Scalar::Ptr(ptr, _) => ptr.visit_tags(visit),\n+            Scalar::Int(_) => (),\n+        }\n+    }\n+}\n+\n+impl VisitTags for Immediate<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Immediate::Scalar(s) => {\n+                s.visit_tags(visit);\n+            }\n+            Immediate::ScalarPair(s1, s2) => {\n+                s1.visit_tags(visit);\n+                s2.visit_tags(visit);\n+            }\n+            Immediate::Uninit => {}\n+        }\n+    }\n+}\n+\n+impl VisitTags for MemPlaceMeta<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            MemPlaceMeta::Meta(m) => m.visit_tags(visit),\n+            MemPlaceMeta::None => {}\n+        }\n+    }\n+}\n+\n+impl VisitTags for MemPlace<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let MemPlace { ptr, meta } = self;\n+        ptr.visit_tags(visit);\n+        meta.visit_tags(visit);\n+    }\n+}\n+\n+impl VisitTags for MPlaceTy<'_, Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        (**self).visit_tags(visit)\n+    }\n+}\n+\n+impl VisitTags for Place<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Place::Ptr(p) => p.visit_tags(visit),\n+            Place::Local { .. } => {\n+                // Will be visited as part of the stack frame.\n+            }\n+        }\n+    }\n+}\n+\n+impl VisitTags for PlaceTy<'_, Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        (**self).visit_tags(visit)\n+    }\n+}\n+\n+impl VisitTags for Operand<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Operand::Immediate(imm) => {\n+                imm.visit_tags(visit);\n+            }\n+            Operand::Indirect(p) => {\n+                p.visit_tags(visit);\n+            }\n+        }\n+    }\n+}\n+\n+impl VisitTags for Allocation<Provenance, AllocExtra> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for (_size, prov) in self.provenance().iter() {\n+            prov.visit_tags(visit);\n+        }\n+\n+        self.extra.visit_tags(visit);\n+    }\n+}\n \n+impl VisitTags for crate::MiriInterpCx<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         // Memory.\n-        this.memory.alloc_map().iter(|it| {\n+        self.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n-                visit_alloc(acc, alloc);\n+                alloc.visit_tags(visit);\n             }\n         });\n \n         // And all the other machine values.\n-        this.machine.visit_machine_values(&mut |op| visit_operand(acc, op));\n+        self.machine.visit_tags(visit);\n     }\n+}\n \n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n@@ -37,43 +159,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         let mut tags = FxHashSet::default();\n-\n-        let visit_scalar = |tags: &mut FxHashSet<SbTag>, s: &Scalar<Provenance>| {\n-            if let Scalar::Ptr(ptr, _) = s {\n-                if let Provenance::Concrete { sb, .. } = ptr.provenance {\n-                    tags.insert(sb);\n-                }\n-            }\n-        };\n-\n-        this.visit_all_machine_values(\n-            &mut tags,\n-            |tags, op| {\n-                match op {\n-                    Operand::Immediate(Immediate::Scalar(s)) => {\n-                        visit_scalar(tags, s);\n-                    }\n-                    Operand::Immediate(Immediate::ScalarPair(s1, s2)) => {\n-                        visit_scalar(tags, s1);\n-                        visit_scalar(tags, s2);\n-                    }\n-                    Operand::Immediate(Immediate::Uninit) => {}\n-                    Operand::Indirect(MemPlace { ptr, .. }) => {\n-                        if let Some(Provenance::Concrete { sb, .. }) = ptr.provenance {\n-                            tags.insert(sb);\n-                        }\n-                    }\n-                }\n-            },\n-            |tags, alloc| {\n-                for (_size, prov) in alloc.provenance().iter() {\n-                    if let Provenance::Concrete { sb, .. } = prov {\n-                        tags.insert(*sb);\n-                    }\n-                }\n-            },\n-        );\n-\n+        this.visit_tags(&mut |tag| {\n+            tags.insert(tag);\n+        });\n         self.remove_unreachable_tags(tags);\n \n         Ok(())"}]}