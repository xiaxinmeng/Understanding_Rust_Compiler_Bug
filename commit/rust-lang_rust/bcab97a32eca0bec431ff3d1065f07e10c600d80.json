{"sha": "bcab97a32eca0bec431ff3d1065f07e10c600d80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYWI5N2EzMmVjYTBiZWM0MzFmZjNkMTA2NWYwN2UxMGM2MDBkODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T21:06:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "core: Implement f32/f64 formatting\n\nThis is a migration of the std::{f32, f64}::to_str* functionality to the core\nlibrary. This removes the growable `Vec` used in favor of a large stack buffer.\nThe maximum base 10 exponent for f64 is 308, so a stack buffer of 512 bytes\nshould be sufficient to store all floats.", "tree": {"sha": "8f6a1ef09781b35a20c26197b26d81fb4c1ecf8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6a1ef09781b35a20c26197b26d81fb4c1ecf8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcab97a32eca0bec431ff3d1065f07e10c600d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcab97a32eca0bec431ff3d1065f07e10c600d80", "html_url": "https://github.com/rust-lang/rust/commit/bcab97a32eca0bec431ff3d1065f07e10c600d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcab97a32eca0bec431ff3d1065f07e10c600d80/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1de4b65d2a88e88201026485f9622916c5717555", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de4b65d2a88e88201026485f9622916c5717555", "html_url": "https://github.com/rust-lang/rust/commit/1de4b65d2a88e88201026485f9622916c5717555"}], "stats": {"total": 362, "additions": 362, "deletions": 0}, "files": [{"sha": "e389775ce4c5d88650ef75de787ca46c0acc5a6f", "filename": "src/libcore/fmt/float.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/bcab97a32eca0bec431ff3d1065f07e10c600d80/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcab97a32eca0bec431ff3d1065f07e10c600d80/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=bcab97a32eca0bec431ff3d1065f07e10c600d80", "patch": "@@ -0,0 +1,362 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+\n+use char;\n+use container::Container;\n+use fmt;\n+use iter::{Iterator, range, DoubleEndedIterator};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n+use num::{Zero, One, cast};\n+use option::{None, Some};\n+use result::Ok;\n+use slice::{ImmutableVector, MutableVector};\n+use slice;\n+use str::StrSlice;\n+\n+/// A flag that specifies whether to use exponential (scientific) notation.\n+pub enum ExponentFormat {\n+    /// Do not use exponential notation.\n+    ExpNone,\n+    /// Use exponential notation with the exponent having a base of 10 and the\n+    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n+    /// 1e3.\n+    ExpDec,\n+    /// Use exponential notation with the exponent having a base of 2 and the\n+    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n+    ExpBin,\n+}\n+\n+/// The number of digits used for emitting the fractional part of a number, if\n+/// any.\n+pub enum SignificantDigits {\n+    /// All calculable digits will be printed.\n+    ///\n+    /// Note that bignums or fractions may cause a surprisingly large number\n+    /// of digits to be printed.\n+    DigAll,\n+\n+    /// At most the given number of digits will be printed, truncating any\n+    /// trailing zeroes.\n+    DigMax(uint),\n+\n+    /// Precisely the given number of digits will be printed.\n+    DigExact(uint)\n+}\n+\n+/// How to emit the sign of a number.\n+pub enum SignFormat {\n+    /// No sign will be printed. The exponent sign will also be emitted.\n+    SignNone,\n+    /// `-` will be printed for negative values, but no sign will be emitted\n+    /// for positive numbers.\n+    SignNeg,\n+    /// `+` will be printed for positive values, and `-` will be printed for\n+    /// negative values.\n+    SignAll,\n+}\n+\n+static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+\n+/**\n+ * Converts a number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all numeric string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n+ *                     is used, then this base is only used for the significand. The exponent\n+ *                     itself always printed using a base of 10.\n+ * - `negative_zero` - Whether to treat the special value `-0` as\n+ *                     `-0` or as `+0`.\n+ * - `sign`          - How to emit the sign. See `SignFormat`.\n+ * - `digits`        - The amount of digits to use for emitting the fractional\n+ *                     part, if any. See `SignificantDigits`.\n+ * - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n+ *                    See `ExponentFormat`.\n+ * - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n+ *                     exponential notation is desired.\n+ * - `f`             - A closure to invoke with the bytes representing the\n+ *                     float.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n+ */\n+pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n+    num: T,\n+    radix: uint,\n+    negative_zero: bool,\n+    sign: SignFormat,\n+    digits: SignificantDigits,\n+    exp_format: ExponentFormat,\n+    exp_upper: bool,\n+    f: |&[u8]| -> U\n+) -> U {\n+    assert!(2 <= radix && radix <= 36);\n+    match exp_format {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'e' as decimal exponent\", radix),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'p' as binary exponent\", radix),\n+        _ => ()\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    match num.classify() {\n+        FPNaN => return f(\"NaN\".as_bytes()),\n+        FPInfinite if num > _0 => {\n+            return match sign {\n+                SignAll => return f(\"+inf\".as_bytes()),\n+                _       => return f(\"inf\".as_bytes()),\n+            };\n+        }\n+        FPInfinite if num < _0 => {\n+            return match sign {\n+                SignNone => return f(\"inf\".as_bytes()),\n+                _        => return f(\"-inf\".as_bytes()),\n+            };\n+        }\n+        _ => {}\n+    }\n+\n+    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n+    // For an f64 the exponent is in the range of [-1022, 1023] for base 2, so\n+    // we may have up to that many digits. Give ourselves some extra wiggle room\n+    // otherwise as well.\n+    let mut buf = [0u8, ..1536];\n+    let mut end = 0;\n+    let radix_gen: T = cast(radix as int).unwrap();\n+\n+    let (num, exp) = match exp_format {\n+        ExpNone => (num, 0i32),\n+        ExpDec | ExpBin if num == _0 => (num, 0i32),\n+        ExpDec | ExpBin => {\n+            let (exp, exp_base) = match exp_format {\n+                ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n+                ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                ExpNone => fail!(\"unreachable\"),\n+            };\n+\n+            (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+        }\n+    };\n+\n+    // First emit the non-fractional part, looping at least once to make\n+    // sure at least a `0` gets emitted.\n+    let mut deccum = num.trunc();\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit = (deccum % radix_gen).abs();\n+\n+        // Decrease the deccumulator one digit at a time\n+        deccum = deccum / radix_gen;\n+        deccum = deccum.trunc();\n+\n+        let c = char::from_digit(current_digit.to_int().unwrap() as uint, radix);\n+        buf[end] = c.unwrap() as u8;\n+        end += 1;\n+\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // If limited digits, calculate one digit more for rounding.\n+    let (limit_digits, digit_count, exact) = match digits {\n+        DigAll          => (false, 0u,      false),\n+        DigMax(count)   => (true,  count+1, false),\n+        DigExact(count) => (true,  count+1, true)\n+    };\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => {\n+            buf[end] = '-' as u8;\n+            end += 1;\n+        }\n+        SignAll => {\n+            buf[end] = '+' as u8;\n+            end += 1;\n+        }\n+        _ => ()\n+    }\n+\n+    buf.mut_slice_to(end).reverse();\n+\n+    // Remember start of the fractional digits.\n+    // Points one beyond end of buf if none get generated,\n+    // or at the '.' otherwise.\n+    let start_fractional_digits = end;\n+\n+    // Now emit the fractional part, if any\n+    deccum = num.fract();\n+    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n+        buf[end] = '.' as u8;\n+        end += 1;\n+        let mut dig = 0u;\n+\n+        // calculate new digits while\n+        // - there is no limit and there are digits left\n+        // - or there is a limit, it's not reached yet and\n+        //   - it's exact\n+        //   - or it's a maximum, and there are still digits left\n+        while (!limit_digits && deccum != _0)\n+           || (limit_digits && dig < digit_count && (\n+                   exact\n+                || (!exact && deccum != _0)\n+              )\n+        ) {\n+            // Shift first fractional digit into the integer part\n+            deccum = deccum * radix_gen;\n+\n+            // Calculate the absolute value of each digit.\n+            // See note in first loop.\n+            let current_digit = deccum.trunc().abs();\n+\n+            let c = char::from_digit(current_digit.to_int().unwrap() as uint,\n+                                     radix);\n+            buf[end] = c.unwrap() as u8;\n+            end += 1;\n+\n+            // Decrease the deccumulator one fractional digit at a time\n+            deccum = deccum.fract();\n+            dig += 1u;\n+        }\n+\n+        // If digits are limited, and that limit has been reached,\n+        // cut off the one extra digit, and depending on its value\n+        // round the remaining ones.\n+        if limit_digits && dig == digit_count {\n+            let ascii2value = |chr: u8| {\n+                char::to_digit(chr as char, radix).unwrap()\n+            };\n+            let value2ascii = |val: uint| {\n+                char::from_digit(val, radix).unwrap() as u8\n+            };\n+\n+            let extra_digit = ascii2value(buf[end - 1]);\n+            end -= 1;\n+            if extra_digit >= radix / 2 { // -> need to round\n+                let mut i: int = end as int - 1;\n+                loop {\n+                    // If reached left end of number, have to\n+                    // insert additional digit:\n+                    if i < 0\n+                    || buf[i as uint] == '-' as u8\n+                    || buf[i as uint] == '+' as u8 {\n+                        for j in range(i as uint + 1, end).rev() {\n+                            buf[j + 1] = buf[j];\n+                        }\n+                        buf[(i + 1) as uint] = value2ascii(1);\n+                        end += 1;\n+                        break;\n+                    }\n+\n+                    // Skip the '.'\n+                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n+\n+                    // Either increment the digit,\n+                    // or set to 0 if max and carry the 1.\n+                    let current_digit = ascii2value(buf[i as uint]);\n+                    if current_digit < (radix - 1) {\n+                        buf[i as uint] = value2ascii(current_digit+1);\n+                        break;\n+                    } else {\n+                        buf[i as uint] = value2ascii(0);\n+                        i -= 1;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if number of digits is not exact, remove all trailing '0's up to\n+    // and including the '.'\n+    if !exact {\n+        let buf_max_i = end - 1;\n+\n+        // index to truncate from\n+        let mut i = buf_max_i;\n+\n+        // discover trailing zeros of fractional part\n+        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+            i -= 1;\n+        }\n+\n+        // Only attempt to truncate digits if buf has fractional digits\n+        if i >= start_fractional_digits {\n+            // If buf ends with '.', cut that too.\n+            if buf[i] == '.' as u8 { i -= 1 }\n+\n+            // only resize buf if we actually remove digits\n+            if i < buf_max_i {\n+                end = i + 1;\n+            }\n+        }\n+    } // If exact and trailing '.', just cut that\n+    else {\n+        let max_i = end - 1;\n+        if buf[max_i] == '.' as u8 {\n+            end = max_i;\n+        }\n+    }\n+\n+    match exp_format {\n+        ExpNone => {},\n+        _ => {\n+            buf[end] = match exp_format {\n+                ExpDec if exp_upper => 'E',\n+                ExpDec if !exp_upper => 'e',\n+                ExpBin if exp_upper => 'P',\n+                ExpBin if !exp_upper => 'p',\n+                _ => fail!(\"unreachable\"),\n+            } as u8;\n+            end += 1;\n+\n+            struct Filler<'a> {\n+                buf: &'a mut [u8],\n+                end: &'a mut uint,\n+            }\n+\n+            impl<'a> fmt::FormatWriter for Filler<'a> {\n+                fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+                    slice::bytes::copy_memory(self.buf.mut_slice_from(*self.end),\n+                                              bytes);\n+                    *self.end += bytes.len();\n+                    Ok(())\n+                }\n+            }\n+\n+            let mut filler = Filler { buf: buf, end: &mut end };\n+            match sign {\n+                SignNeg => { let _ = write!(&mut filler, \"{:-}\", exp); }\n+                SignNone | SignAll => { let _ = write!(&mut filler, \"{}\", exp); }\n+            }\n+        }\n+    }\n+\n+    f(buf.slice_to(end))\n+}"}]}