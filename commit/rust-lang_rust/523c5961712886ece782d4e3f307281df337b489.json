{"sha": "523c5961712886ece782d4e3f307281df337b489", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyM2M1OTYxNzEyODg2ZWNlNzgyZDRlM2YzMDcyODFkZjMzN2I0ODk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-21T05:05:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-21T05:05:36Z"}, "message": "Merge pull request #727 from oli-obk/similar_names\n\nlint on binding-names that are too similar", "tree": {"sha": "ae45a756baad03e77b32020a4a7c37559dde6d04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae45a756baad03e77b32020a4a7c37559dde6d04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/523c5961712886ece782d4e3f307281df337b489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/523c5961712886ece782d4e3f307281df337b489", "html_url": "https://github.com/rust-lang/rust/commit/523c5961712886ece782d4e3f307281df337b489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/523c5961712886ece782d4e3f307281df337b489/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90a95016a10e0fe08634dbdb9b8d161ff258917", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90a95016a10e0fe08634dbdb9b8d161ff258917", "html_url": "https://github.com/rust-lang/rust/commit/e90a95016a10e0fe08634dbdb9b8d161ff258917"}, {"sha": "fa739e4a0b17f43f955416788120705001a82666", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa739e4a0b17f43f955416788120705001a82666", "html_url": "https://github.com/rust-lang/rust/commit/fa739e4a0b17f43f955416788120705001a82666"}], "stats": {"total": 651, "additions": 557, "deletions": 94}, "files": [{"sha": "57dedbdb39e76a7c3c17c930debc7d443c40193f", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 136 lints included in this crate:\n+There are 138 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -74,6 +74,7 @@ name\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n [manual_swap](https://github.com/Manishearth/rust-clippy/wiki#manual_swap)                                           | warn    | manual swap\n+[many_single_char_names](https://github.com/Manishearth/rust-clippy/wiki#many_single_char_names)                     | warn    | too many single character bindings\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                               | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                             | warn    | a match on boolean expression; recommends `if..else` block instead\n@@ -119,6 +120,7 @@ name\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                                 | allow   | The name is re-bound without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)                     | warn    | defining a method that should be implementing a std trait\n+[similar_names](https://github.com/Manishearth/rust-clippy/wiki#similar_names)                                       | warn    | similarly named items and bindings\n [single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                           | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                               | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead"}, {"sha": "67da1216c42f24190599acd8ca75655d40291f52", "filename": "src/consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -82,7 +82,7 @@ impl Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n+            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => ls == rs && l_sty == r_sty,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked(),\n@@ -145,8 +145,8 @@ impl Hash for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => {\n-                if lsty == rsty {\n+            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => {\n+                if l_sty == r_sty {\n                     Some(ls.cmp(rs))\n                 } else {\n                     None\n@@ -354,6 +354,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n+\n     fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n         where F: Fn(Constant, Constant) -> Option<Constant>\n     {"}, {"sha": "f6179f4f99324a9c5be5e977574a5bb2563ae2d0", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -3,6 +3,7 @@\n #![feature(rustc_private, collections)]\n #![feature(iter_arith)]\n #![feature(custom_attribute)]\n+#![feature(slice_patterns)]\n #![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work\n@@ -84,6 +85,7 @@ pub mod needless_features;\n pub mod needless_update;\n pub mod new_without_default;\n pub mod no_effect;\n+pub mod non_expressive_names;\n pub mod open_options;\n pub mod overflow_check_conditional;\n pub mod panic;\n@@ -200,6 +202,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n     reg.register_late_lint_pass(box print::PrintLint);\n     reg.register_late_lint_pass(box vec::UselessVec);\n+    reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n+        max_single_char_names: conf.max_single_char_names,\n+    });\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n     reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass::default());\n@@ -326,6 +331,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         needless_update::NEEDLESS_UPDATE,\n         new_without_default::NEW_WITHOUT_DEFAULT,\n         no_effect::NO_EFFECT,\n+        non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n+        non_expressive_names::SIMILAR_NAMES,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         panic::PANIC_PARAMS,"}, {"sha": "43e7cfddadd071709ab84b2b54332ae1982bc946", "filename": "src/needless_bool.rs", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -6,7 +6,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n-use utils::{span_lint, span_lint_and_then, snippet};\n+use utils::{span_lint, span_lint_and_then, snippet, snippet_opt};\n \n /// **What it does:** This lint checks for expressions of the form `if c { true } else { false }` (or vice versa) and suggest using the condition directly.\n ///\n@@ -47,44 +47,39 @@ impl LintPass for NeedlessBool {\n \n impl LateLintPass for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n+            let reduce = |hint: &str, not| {\n+                let hint = match snippet_opt(cx, pred.span) {\n+                    Some(pred_snip) => format!(\"`{}{}`\", not, pred_snip),\n+                    None => hint.into(),\n+                };\n+                span_lint_and_then(cx,\n+                                   NEEDLESS_BOOL,\n+                                   e.span,\n+                                   \"this if-then-else expression returns a bool literal\", |db| {\n+                    db.span_suggestion(e.span, \"you can reduce it to\", hint);\n+                });\n+            };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n-                (Some(true), Some(true)) => {\n+                (RetBool(true), RetBool(true)) |\n+                (Bool(true), Bool(true)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return true\");\n                 }\n-                (Some(false), Some(false)) => {\n+                (RetBool(false), RetBool(false)) |\n+                (Bool(false), Bool(false)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return false\");\n                 }\n-                (Some(true), Some(false)) => {\n-                    let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" {\n-                        \"its predicate\".into()\n-                    } else {\n-                        format!(\"`{}`\", pred_snip)\n-                    };\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n-                }\n-                (Some(false), Some(true)) => {\n-                    let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" {\n-                        \"`!` and its predicate\".into()\n-                    } else {\n-                        format!(\"`!{}`\", pred_snip)\n-                    };\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n-                }\n+                (RetBool(true), RetBool(false)) => reduce(\"its predicate\", \"return \"),\n+                (Bool(true), Bool(false)) => reduce(\"its predicate\", \"\"),\n+                (RetBool(false), RetBool(true)) => reduce(\"`!` and its predicate\", \"return !\"),\n+                (Bool(false), Bool(true)) => reduce(\"`!` and its predicate\", \"!\"),\n                 _ => (),\n             }\n         }\n@@ -102,9 +97,10 @@ impl LintPass for BoolComparison {\n \n impl LateLintPass for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        use self::Expression::*;\n         if let ExprBinary(Spanned{ node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-                (Some(true), None) => {\n+                (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -114,7 +110,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (None, Some(true)) => {\n+                (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -124,7 +120,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (Some(false), None) => {\n+                (Bool(false), Other) => {\n                     let hint = format!(\"!{}\", snippet(cx, right_side.span, \"..\"));\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -134,7 +130,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (None, Some(false)) => {\n+                (Other, Bool(false)) => {\n                     let hint = format!(\"!{}\", snippet(cx, left_side.span, \"..\"));\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -150,24 +146,42 @@ impl LateLintPass for BoolComparison {\n     }\n }\n \n-fn fetch_bool_block(block: &Block) -> Option<bool> {\n-    if block.stmts.is_empty() {\n-        block.expr.as_ref().and_then(|e| fetch_bool_expr(e))\n-    } else {\n-        None\n+enum Expression {\n+    Bool(bool),\n+    RetBool(bool),\n+    Other,\n+}\n+\n+fn fetch_bool_block(block: &Block) -> Expression {\n+    match (&*block.stmts, block.expr.as_ref()) {\n+        ([], Some(e)) => fetch_bool_expr(&**e),\n+        ([ref e], None) => if let StmtSemi(ref e, _) = e.node {\n+            if let ExprRet(_) = e.node {\n+                fetch_bool_expr(&**e)\n+            } else {\n+                Expression::Other\n+            }\n+        } else {\n+            Expression::Other\n+        },\n+        _ => Expression::Other,\n     }\n }\n \n-fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n+fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n         ExprLit(ref lit_ptr) => {\n             if let LitKind::Bool(value) = lit_ptr.node {\n-                Some(value)\n+                Expression::Bool(value)\n             } else {\n-                None\n+                Expression::Other\n             }\n-        }\n-        _ => None,\n+        },\n+        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+            Expression::Bool(value) => Expression::RetBool(value),\n+            _ => Expression::Other,\n+        },\n+        _ => Expression::Other,\n     }\n }"}, {"sha": "b7d2ac80a10f7094636ce5945c34a04d47329d84", "filename": "src/non_expressive_names.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -0,0 +1,274 @@\n+use rustc::lint::*;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::ast::*;\n+use syntax::visit::{self, FnKind};\n+use utils::{span_lint_and_then, in_macro, span_lint};\n+\n+/// **What it does:** This lint warns about names that are very similar and thus confusing\n+///\n+/// **Why is this bad?** It's hard to distinguish between names that differ only by a single character\n+///\n+/// **Known problems:** None?\n+///\n+/// **Example:** `checked_exp` and `checked_expr`\n+declare_lint! {\n+    pub SIMILAR_NAMES,\n+    Warn,\n+    \"similarly named items and bindings\"\n+}\n+\n+/// **What it does:** This lint warns about having too many variables whose name consists of a single character\n+///\n+/// **Why is this bad?** It's hard to memorize what a variable means without a descriptive name.\n+///\n+/// **Known problems:** None?\n+///\n+/// **Example:** let (a, b, c, d, e, f, g) = (...);\n+declare_lint! {\n+    pub MANY_SINGLE_CHAR_NAMES,\n+    Warn,\n+    \"too many single character bindings\"\n+}\n+\n+pub struct NonExpressiveNames {\n+    pub max_single_char_names: u64,\n+}\n+\n+impl LintPass for NonExpressiveNames {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(SIMILAR_NAMES, MANY_SINGLE_CHAR_NAMES)\n+    }\n+}\n+\n+struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n+    names: Vec<(InternedString, Span, usize)>,\n+    cx: &'a EarlyContext<'b>,\n+    lint: &'a NonExpressiveNames,\n+    single_char_names: Vec<char>,\n+}\n+\n+const WHITELIST: &'static [&'static str] = &[\n+    \"lhs\", \"rhs\",\n+];\n+\n+struct SimilarNamesNameVisitor<'a, 'b: 'a, 'c: 'b>(&'a mut SimilarNamesLocalVisitor<'b, 'c>);\n+\n+impl<'v, 'a, 'b, 'c> visit::Visitor<'v> for SimilarNamesNameVisitor<'a, 'b, 'c> {\n+    fn visit_pat(&mut self, pat: &'v Pat) {\n+        if let PatKind::Ident(_, id, _) = pat.node {\n+            self.check_name(id.span, id.node.name);\n+        }\n+        visit::walk_pat(self, pat);\n+    }\n+}\n+\n+fn whitelisted(interned_name: &str) -> bool {\n+    for &allow in WHITELIST {\n+        if interned_name == allow {\n+            return true;\n+        }\n+        if interned_name.len() <= allow.len() {\n+            continue;\n+        }\n+        // allow_*\n+        let allow_start = allow.chars().chain(Some('_'));\n+        if interned_name.chars().zip(allow_start).all(|(l, r)| l == r) {\n+            return true;\n+        }\n+        // *_allow\n+        let allow_end = Some('_').into_iter().chain(allow.chars());\n+        if interned_name.chars().rev().zip(allow_end.rev()).all(|(l, r)| l == r) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n+    fn check_short_name(&mut self, c: char, span: Span) {\n+        // make sure we ignore shadowing\n+        if self.0.single_char_names.contains(&c) {\n+            return;\n+        }\n+        self.0.single_char_names.push(c);\n+        if self.0.single_char_names.len() as u64 >= self.0.lint.max_single_char_names {\n+            span_lint(self.0.cx,\n+                      MANY_SINGLE_CHAR_NAMES,\n+                      span,\n+                      &format!(\"{}th binding whose name is just one char\",\n+                               self.0.single_char_names.len()));\n+        }\n+    }\n+    fn check_name(&mut self, span: Span, name: Name) {\n+        if in_macro(self.0.cx, span) {\n+            return;\n+        }\n+        let interned_name = name.as_str();\n+        if interned_name.chars().any(char::is_uppercase) {\n+            return;\n+        }\n+        let count = interned_name.chars().count();\n+        if count < 3 {\n+            if count != 1 {\n+                return;\n+            }\n+            let c = interned_name.chars().next().expect(\"already checked\");\n+            self.check_short_name(c, span);\n+            return;\n+        }\n+        if whitelisted(&interned_name) {\n+            return;\n+        }\n+        for &(ref existing_name, sp, existing_len) in &self.0.names {\n+            let mut split_at = None;\n+            if existing_len > count {\n+                if existing_len - count != 1 {\n+                    continue;\n+                }\n+                if levenstein_not_1(&interned_name, &existing_name) {\n+                    continue;\n+                }\n+            } else if existing_len < count {\n+                if count - existing_len != 1 {\n+                    continue;\n+                }\n+                if levenstein_not_1(&existing_name, &interned_name) {\n+                    continue;\n+                }\n+            } else {\n+                let mut interned_chars = interned_name.chars();\n+                let mut existing_chars = existing_name.chars();\n+\n+                if interned_chars.next() != existing_chars.next() {\n+                    let i = interned_chars.next().expect(\"we know we have more than 1 char\");\n+                    let e = existing_chars.next().expect(\"we know we have more than 1 char\");\n+                    if i == e {\n+                        if i == '_' {\n+                            // allowed similarity x_foo, y_foo\n+                            // or too many chars differ (x_foo, y_boo)\n+                            continue;\n+                        } else if interned_chars.ne(existing_chars) {\n+                            // too many chars differ\n+                            continue\n+                        }\n+                    } else {\n+                        // too many chars differ\n+                        continue;\n+                    }\n+                    split_at = interned_name.chars().next().map(|c| c.len_utf8());\n+                } else if interned_chars.next_back() == existing_chars.next_back() {\n+                    if interned_chars.zip(existing_chars).filter(|&(i, e)| i != e).count() != 1 {\n+                        // too many chars differ, or none differ (aka shadowing)\n+                        continue;\n+                    }\n+                } else {\n+                    let i = interned_chars.next_back().expect(\"we know we have more than 2 chars\");\n+                    let e = existing_chars.next_back().expect(\"we know we have more than 2 chars\");\n+                    if i == e {\n+                        if i == '_' {\n+                            // allowed similarity foo_x, foo_x\n+                            // or too many chars differ (foo_x, boo_x)\n+                            continue;\n+                        } else if interned_chars.ne(existing_chars) {\n+                            // too many chars differ\n+                            continue\n+                        }\n+                    } else {\n+                        // too many chars differ\n+                        continue;\n+                    }\n+                    split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n+                }\n+            }\n+            span_lint_and_then(self.0.cx,\n+                               SIMILAR_NAMES,\n+                               span,\n+                               \"binding's name is too similar to existing binding\",\n+                               |diag| {\n+                                   diag.span_note(sp, \"existing binding defined here\");\n+                                   if let Some(split) = split_at {\n+                                       diag.span_help(span, &format!(\"separate the discriminating character \\\n+                                                                      by an underscore like: `{}_{}`\",\n+                                                                     &interned_name[..split],\n+                                                                     &interned_name[split..]));\n+                                   }\n+                               });\n+            return;\n+        }\n+        self.0.names.push((interned_name, span, count));\n+    }\n+}\n+\n+impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n+    /// ensure scoping rules work\n+    fn apply<F: for<'c> Fn(&'c mut Self)>(&mut self, f: F) {\n+        let n = self.names.len();\n+        let single_char_count = self.single_char_names.len();\n+        f(self);\n+        self.names.truncate(n);\n+        self.single_char_names.truncate(single_char_count);\n+    }\n+}\n+\n+impl<'v, 'a, 'b> visit::Visitor<'v> for SimilarNamesLocalVisitor<'a, 'b> {\n+    fn visit_local(&mut self, local: &'v Local) {\n+        if let Some(ref init) = local.init {\n+            self.apply(|this| visit::walk_expr(this, &**init));\n+        }\n+        // add the pattern after the expression because the bindings aren't available yet in the init expression\n+        SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n+    }\n+    fn visit_block(&mut self, blk: &'v Block) {\n+        self.apply(|this| visit::walk_block(this, blk));\n+    }\n+    fn visit_arm(&mut self, arm: &'v Arm) {\n+        self.apply(|this| {\n+            // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n+            SimilarNamesNameVisitor(this).visit_pat(&arm.pats[0]);\n+            this.apply(|this| visit::walk_expr(this, &arm.body));\n+        });\n+    }\n+    fn visit_item(&mut self, _: &'v Item) {\n+        // do nothing\n+    }\n+}\n+\n+impl EarlyLintPass for NonExpressiveNames {\n+    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, blk: &Block, _: Span, _: NodeId) {\n+        let mut visitor = SimilarNamesLocalVisitor {\n+            names: Vec::new(),\n+            cx: cx,\n+            lint: &self,\n+            single_char_names: Vec::new(),\n+        };\n+        // initialize with function arguments\n+        for arg in &decl.inputs {\n+            visit::walk_pat(&mut SimilarNamesNameVisitor(&mut visitor), &arg.pat);\n+        }\n+        // walk all other bindings\n+        visit::walk_block(&mut visitor, blk);\n+    }\n+}\n+\n+/// precondition: a_name.chars().count() < b_name.chars().count()\n+fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n+    debug_assert!(a_name.chars().count() < b_name.chars().count());\n+    let mut a_chars = a_name.chars();\n+    let mut b_chars = b_name.chars();\n+    while let (Some(a), Some(b)) = (a_chars.next(), b_chars.next()) {\n+        if a == b {\n+            continue;\n+        }\n+        if let Some(b2) = b_chars.next() {\n+            // check if there's just one character inserted\n+            return !(a == b2 && a_chars.eq(b_chars));\n+        } else {\n+            // tuple\n+            // ntuple\n+            return true;\n+        }\n+    }\n+    // for item in items\n+    true\n+}"}, {"sha": "1dc1f55b773fc88c6eb2322bed7a44ca1524fe25", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -638,16 +638,16 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n         Lt,\n         Le,\n     };\n-    let (rel, lhs2, rhs2) = match op {\n+    let (rel, normalized_lhs, normalized_rhs) = match op {\n         BiLt => (Rel::Lt, lhs, rhs),\n         BiLe => (Rel::Le, lhs, rhs),\n         BiGt => (Rel::Lt, rhs, lhs),\n         BiGe => (Rel::Le, rhs, lhs),\n         _ => return None,\n     };\n \n-    let lx = detect_extreme_expr(cx, lhs2);\n-    let rx = detect_extreme_expr(cx, rhs2);\n+    let lx = detect_extreme_expr(cx, normalized_lhs);\n+    let rx = detect_extreme_expr(cx, normalized_rhs);\n \n     Some(match rel {\n         Rel::Lt => {"}, {"sha": "2411e48997b31c2181e9840bb15caed86c3fb37d", "filename": "src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fconf.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -153,6 +153,8 @@ define_Conf! {\n     (\"too-many-arguments-threshold\", too_many_arguments_threshold, 7 => u64),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n     (\"type-complexity-threshold\", type_complexity_threshold, 250 => u64),\n+    /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n+    (\"single-char-binding-names-threshold\", max_single_char_names, 5 => u64),\n }\n \n /// Read the `toml` configuration file. The function will ignore \u201cFile not found\u201d errors iif"}, {"sha": "ed2a49b3caa4c189ce9b81c5182ae4b2a39fe0fe", "filename": "src/utils/hir.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -67,24 +67,24 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(lmut, ref le), &ExprAddrOf(rmut, ref re)) => lmut == rmut && self.eq_expr(le, re),\n+            (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n             (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n-            (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n-                lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             }\n             (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n-            (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-                !self.ignore_fn && self.eq_expr(lfun, rfun) && self.eq_exprs(largs, rargs)\n+            (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n+                !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             }\n             (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n-            (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-                lfident.node == rfident.node && self.eq_expr(lfexp, rfexp)\n+            (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n+                l_f_ident.node == r_f_ident.node && self.eq_expr(l_f_exp, r_f_exp)\n             }\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n@@ -101,25 +101,25 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             }\n-            (&ExprMethodCall(ref lname, ref ltys, ref largs),\n-             &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+            (&ExprMethodCall(ref l_name, ref l_tys, ref l_args),\n+             &ExprMethodCall(ref r_name, ref r_tys, ref r_args)) => {\n                 // TODO: tys\n-                !self.ignore_fn && lname.node == rname.node && ltys.is_empty() && rtys.is_empty() &&\n-                self.eq_exprs(largs, rargs)\n+                !self.ignore_fn && l_name.node == r_name.node && l_tys.is_empty() && r_tys.is_empty() &&\n+                self.eq_exprs(l_args, r_args)\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n-                both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n+            (&ExprPath(ref l_qself, ref l_subpath), &ExprPath(ref r_qself, ref r_subpath)) => {\n+                both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n             }\n-            (&ExprStruct(ref lpath, ref lf, ref lo), &ExprStruct(ref rpath, ref rf, ref ro)) => {\n-                self.eq_path(lpath, rpath) &&\n+            (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n+                self.eq_path(l_path, r_path) &&\n                     both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                     over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n-            (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n+            (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n-            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => lop == rop && self.eq_expr(le, re),\n+            (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n@@ -179,16 +179,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n-            (&TyVec(ref lvec), &TyVec(ref rvec)) => self.eq_ty(lvec, rvec),\n+            (&TyVec(ref l_vec), &TyVec(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyFixedLengthVec(ref lt, ref ll), &TyFixedLengthVec(ref rt, ref rl)) => {\n                 self.eq_ty(lt, rt) && self.eq_expr(ll, rl)\n             }\n-            (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && self.eq_ty(&*lmut.ty, &*rmut.ty),\n-            (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n-                lrmut.mutbl == rrmut.mutbl && self.eq_ty(&*lrmut.ty, &*rrmut.ty)\n+            (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n+            (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n+                l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n-                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(lpath, rpath)\n+            (&TyPath(ref lq, ref l_path), &TyPath(ref rq, ref r_path)) => {\n+                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(l_path, r_path)\n             }\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,"}, {"sha": "050aec0e43041824864086a02b6108dd26b14c77", "filename": "src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -102,8 +102,8 @@ macro_rules! if_let_chain {\n \n /// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n /// isn't).\n-pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n-    sp1.expn_id != sp2.expn_id\n+pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n+    rhs.expn_id != lhs.expn_id\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {"}, {"sha": "3660fb41919051ed07c51112497176972b70877f", "filename": "tests/compile-fail/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fapprox_const.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #[deny(approx_constant)]\n-#[allow(unused, shadow_unrelated)]\n+#[allow(unused, shadow_unrelated, similar_names)]\n fn main() {\n     let my_e = 2.7182; //~ERROR approximate value of `f{32, 64}::E` found\n     let almost_e = 2.718; //~ERROR approximate value of `f{32, 64}::E` found"}, {"sha": "1afcd94a0b1d43a75e69561b7d096887a2bb5021", "filename": "tests/compile-fail/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblacklisted_name.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -3,7 +3,7 @@\n \n #![allow(dead_code)]\n #![allow(single_match)]\n-#![allow(unused_variables)]\n+#![allow(unused_variables, similar_names)]\n #![deny(blacklisted_name)]\n \n fn test(foo: ()) {} //~ERROR use of a blacklisted/placeholder name `foo`"}, {"sha": "8454a471513dfe1b8585c5ca2ea9ec6682ace32c", "filename": "tests/compile-fail/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdrop_ref.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(drop_ref)]\n-#![allow(toplevel_ref_arg)]\n+#![allow(toplevel_ref_arg, similar_names)]\n \n use std::mem::drop;\n "}, {"sha": "3fd089bf5883906a9436835666a2ea0078f91d10", "filename": "tests/compile-fail/eta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feta.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -1,6 +1,6 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n-#![allow(unknown_lints, unused, no_effect, redundant_closure_call)]\n+#![allow(unknown_lints, unused, no_effect, redundant_closure_call, many_single_char_names)]\n #![deny(redundant_closure)]\n \n fn main() {"}, {"sha": "064f66537eb30255d5e2596cbff162f7611f24fd", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -88,7 +88,8 @@ impl Unrelated {\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity)]\n+#[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity, similar_names)]\n+#[allow(many_single_char_names)]\n fn main() {\n     const MAX_LEN: usize = 42;\n "}, {"sha": "4fd0203b91282efed1e250d7f378cc37b6b55b6c", "filename": "tests/compile-fail/len_zero.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -92,38 +92,38 @@ fn main() {\n         println!(\"Nor should this!\");\n     }\n \n-    let hie = HasIsEmpty;\n-    if hie.len() == 0 {\n+    let has_is_empty = HasIsEmpty;\n+    if has_is_empty.len() == 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION hie.is_empty()\n+        //~|SUGGESTION has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    if hie.len() != 0 {\n+    if has_is_empty.len() != 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION !hie.is_empty()\n+        //~|SUGGESTION !has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    if hie.len() > 0 {\n+    if has_is_empty.len() > 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION !hie.is_empty()\n+        //~|SUGGESTION !has_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    assert!(!hie.is_empty());\n+    assert!(!has_is_empty.is_empty());\n \n-    let wie : &WithIsEmpty = &Wither;\n-    if wie.len() == 0 {\n+    let with_is_empty: &WithIsEmpty = &Wither;\n+    if with_is_empty.len() == 0 {\n         //~^ERROR length comparison to zero\n         //~|HELP consider using `is_empty`\n-        //~|SUGGESTION wie.is_empty()\n+        //~|SUGGESTION with_is_empty.is_empty()\n         println!(\"Or this!\");\n     }\n-    assert!(!wie.is_empty());\n+    assert!(!with_is_empty.is_empty());\n \n-    let hwie = HasWrongIsEmpty;\n-    if hwie.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n+    let has_wrong_is_empty = HasWrongIsEmpty;\n+    if has_wrong_is_empty.len() == 0 { //no error as HasWrongIsEmpty does not have .is_empty()\n         println!(\"Or this!\");\n     }\n }"}, {"sha": "b1a8f6cf77671284a4a4c320ce48a0dadf588d06", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -286,6 +286,7 @@ fn or_fun_call() {\n     //~|SUGGESTION btree.entry(42).or_insert_with(String::new);\n }\n \n+#[allow(similar_names)]\n fn main() {\n     use std::io;\n "}, {"sha": "7f2d7754bda09b928c1d1a9a03ba0b88ac13dbce", "filename": "tests/compile-fail/needless_bool.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_bool.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -7,7 +7,45 @@ fn main() {\n     let x = true;\n     if x { true } else { true }; //~ERROR this if-then-else expression will always return true\n     if x { false } else { false }; //~ERROR this if-then-else expression will always return false\n-    if x { true } else { false }; //~ERROR you can reduce this if-then-else expression to just `x`\n-    if x { false } else { true }; //~ERROR you can reduce this if-then-else expression to just `!x`\n+    if x { true } else { false };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION `x`\n+    if x { false } else { true };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION `!x`\n     if x { x } else { false }; // would also be questionable, but we don't catch this yet\n+    bool_ret(x);\n+    bool_ret2(x);\n+    bool_ret3(x);\n+    bool_ret4(x);\n+}\n+\n+#[deny(needless_bool)]\n+#[allow(if_same_then_else)]\n+fn bool_ret(x: bool) -> bool {\n+    if x { return true } else { return true }; //~ERROR this if-then-else expression will always return true\n+}\n+\n+#[deny(needless_bool)]\n+#[allow(if_same_then_else)]\n+fn bool_ret2(x: bool) -> bool {\n+    if x { return false } else { return false }; //~ERROR this if-then-else expression will always return false\n+}\n+\n+#[deny(needless_bool)]\n+fn bool_ret3(x: bool) -> bool {\n+    if x { return true } else { return false };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION `return x`\n+}\n+\n+#[deny(needless_bool)]\n+fn bool_ret4(x: bool) -> bool {\n+    if x { return false } else { return true };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION `return !x`\n }"}, {"sha": "ac412fb44755daf7dfb3261d1254cb7797963de1", "filename": "tests/compile-fail/non_expressive_names.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnon_expressive_names.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -0,0 +1,122 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+//~^ NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+//~| NOTE: lint level defined here\n+#![allow(unused)]\n+\n+fn main() {\n+    let specter: i32;\n+    let spectre: i32;\n+\n+    let apple: i32; //~ NOTE: existing binding defined here\n+    //~^ NOTE: existing binding defined here\n+    let bpple: i32; //~ ERROR: name is too similar\n+    //~| HELP: separate the discriminating character by an underscore like: `b_pple`\n+    //~| HELP: for further information visit\n+    let cpple: i32; //~ ERROR: name is too similar\n+    //~| HELP: separate the discriminating character by an underscore like: `c_pple`\n+    //~| HELP: for further information visit\n+\n+    let a_bar: i32;\n+    let b_bar: i32;\n+    let c_bar: i32;\n+\n+    let items = [5];\n+    for item in &items {\n+        loop {}\n+    }\n+\n+    let foo_x: i32;\n+    let foo_y: i32;\n+\n+    let rhs: i32;\n+    let lhs: i32;\n+\n+    let bla_rhs: i32;\n+    let bla_lhs: i32;\n+\n+    let blubrhs: i32; //~ NOTE: existing binding defined here\n+    let blublhs: i32; //~ ERROR: name is too similar\n+    //~| HELP: for further information visit\n+\n+    let blubx: i32; //~ NOTE: existing binding defined here\n+    let bluby: i32; //~ ERROR: name is too similar\n+    //~| HELP: for further information visit\n+    //~| HELP: separate the discriminating character by an underscore like: `blub_y`\n+\n+    let cake: i32; //~ NOTE: existing binding defined here\n+    let cakes: i32;\n+    let coke: i32; //~ ERROR: name is too similar\n+    //~| HELP: for further information visit\n+\n+    match 5 {\n+        cheese @ 1 => {},\n+        rabbit => panic!(),\n+    }\n+    let cheese: i32;\n+    match (42, 43) {\n+        (cheese1, 1) => {},\n+        (cheese2, 2) => panic!(),\n+        _ => println!(\"\"),\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum MaybeInst {\n+    Split,\n+    Split1(usize),\n+    Split2(usize),\n+}\n+\n+struct InstSplit {\n+    uiae: usize,\n+}\n+\n+impl MaybeInst {\n+    fn fill(&mut self) {\n+        let filled = match *self {\n+            MaybeInst::Split1(goto1) => panic!(1),\n+            MaybeInst::Split2(goto2) => panic!(2),\n+            _ => unimplemented!(),\n+        };\n+        unimplemented!()\n+    }\n+}\n+\n+fn bla() {\n+    let a: i32;\n+    let (b, c, d): (i32, i64, i16);\n+    {\n+        {\n+            let cdefg: i32;\n+            let blar: i32;\n+        }\n+        {\n+            let e: i32; //~ ERROR: 5th binding whose name is just one char\n+            //~| HELP: for further information visit\n+        }\n+        {\n+            let e: i32; //~ ERROR: 5th binding whose name is just one char\n+            //~| HELP: for further information visit\n+            let f: i32; //~ ERROR: 6th binding whose name is just one char\n+            //~| HELP: for further information visit\n+        }\n+        match 5 {\n+            1 => println!(\"\"),\n+            e => panic!(), //~ ERROR: 5th binding whose name is just one char\n+            //~| HELP: for further information visit\n+        }\n+        match 5 {\n+            1 => println!(\"\"),\n+            _ => panic!(),\n+        }\n+    }\n+}"}, {"sha": "24310eb81dae057e88f909f11748f67b3a79d970", "filename": "tests/compile-fail/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/523c5961712886ece782d4e3f307281df337b489/tests%2Fcompile-fail%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflow_check_conditional.rs?ref=523c5961712886ece782d4e3f307281df337b489", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+#![allow(many_single_char_names)]\n #![deny(overflow_check_conditional)]\n \n fn main() {"}]}