{"sha": "e84ee522a927b3564aea4f0c5d61150f0f7c307a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NGVlNTIyYTkyN2IzNTY0YWVhNGYwYzVkNjExNTBmMGY3YzMwN2E=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-15T08:40:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-15T08:40:10Z"}, "message": "Rollup merge of #86220 - est31:maybe-uninit-extra, r=RalfJung\n\nImprove maybe_uninit_extra docs\n\nFor reasoning, see https://github.com/rust-lang/rust/issues/63567#issuecomment-858640987", "tree": {"sha": "657e8816f3c1d4cc093ff490f40c939f4db7b5eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657e8816f3c1d4cc093ff490f40c939f4db7b5eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84ee522a927b3564aea4f0c5d61150f0f7c307a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyGdrCRBK7hj4Ov3rIwAAK84IAGBlkKiCjrGhDf4YnatsHgkT\nqcfg73kUE6LeFLqM5U8K6J3MLvnF5L4QZGufabshrAkxQtTTR5GXNWdLDJZ/ls3B\n5VlLy3Nxao5VJBU+bw4NzDjIguClKXl/ysl21ioeB3zdfxMpdGxzr/GqvIrG335d\ngTfVKGOR3Vo8RxWLW/BS1Qc4MtXg+0F6Zi4mSYLc7/Qpn8Z9lCd3PjEFnY6Zjob/\nJ6y8EiNUvhrwK7Zic1GURL6ldf5o1WiVme9DvsK2E5gNWAKg5ozpXoHFJ4TrYEf8\nSUnT1tBj7E7LpEU0kX/8kNJI2R+RA+opPESMpXQimp24t9uITcb8mCiDTUdlu6w=\n=GZOO\n-----END PGP SIGNATURE-----\n", "payload": "tree 657e8816f3c1d4cc093ff490f40c939f4db7b5eb\nparent 3f4d6d73a9d01016d8ab689b6be253503d31afa6\nparent 87102587149ce00d008c3463bf6283f5145b2f23\nauthor Yuki Okushi <jtitor@2k36.org> 1623746410 +0900\ncommitter GitHub <noreply@github.com> 1623746410 +0900\n\nRollup merge of #86220 - est31:maybe-uninit-extra, r=RalfJung\n\nImprove maybe_uninit_extra docs\n\nFor reasoning, see https://github.com/rust-lang/rust/issues/63567#issuecomment-858640987\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84ee522a927b3564aea4f0c5d61150f0f7c307a", "html_url": "https://github.com/rust-lang/rust/commit/e84ee522a927b3564aea4f0c5d61150f0f7c307a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84ee522a927b3564aea4f0c5d61150f0f7c307a/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4d6d73a9d01016d8ab689b6be253503d31afa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4d6d73a9d01016d8ab689b6be253503d31afa6", "html_url": "https://github.com/rust-lang/rust/commit/3f4d6d73a9d01016d8ab689b6be253503d31afa6"}, {"sha": "87102587149ce00d008c3463bf6283f5145b2f23", "url": "https://api.github.com/repos/rust-lang/rust/commits/87102587149ce00d008c3463bf6283f5145b2f23", "html_url": "https://github.com/rust-lang/rust/commit/87102587149ce00d008c3463bf6283f5145b2f23"}], "stats": {"total": 80, "additions": 67, "deletions": 13}, "files": [{"sha": "de3367e5e5297b4c3be10f207d19dde5cc8eb577", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e84ee522a927b3564aea4f0c5d61150f0f7c307a/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84ee522a927b3564aea4f0c5d61150f0f7c307a/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=e84ee522a927b3564aea4f0c5d61150f0f7c307a", "patch": "@@ -402,10 +402,60 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`.\n+    ///\n+    /// This overwrites any previous value without dropping it, so be careful\n+    /// not to use this twice unless you want to skip running the destructor.\n+    /// For your convenience, this also returns a mutable reference to the\n+    /// (now safely initialized) contents of `self`.\n+    ///\n+    /// As the content is stored inside a `MaybeUninit`, the destructor is not\n+    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n+    /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n+    /// the mutable reference returned by this function needs to keep this in\n+    /// mind. The safety model of Rust regards leaks as safe, but they are\n+    /// usually still undesirable. This being said, the mutable reference\n+    /// behaves like any other mutable reference would, so assigning a new value\n+    /// to it will drop the old content.\n+    ///\n+    /// [`assume_init`]: Self::assume_init\n+    /// [`assume_init_drop`]: Self::assume_init_drop\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n+    ///\n+    /// {\n+    ///     let hello = x.write((&b\"Hello, world!\").to_vec());\n+    ///     // Setting hello does not leak prior allocations, but drops them\n+    ///     *hello = (&b\"Hello\").to_vec();\n+    ///     hello[0] = 'h' as u8;\n+    /// }\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// assert_eq!(b\"hello\", s.as_slice());\n+    /// ```\n+    ///\n+    /// This usage of the method causes a leak:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<String>::uninit();\n+    ///\n+    /// x.write(\"Hello\".to_string());\n+    /// // This leaks the contained string:\n+    /// x.write(\"hello\".to_string());\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n@@ -564,9 +614,11 @@ impl<T> MaybeUninit<T> {\n     /// behavior. The [type-level documentation][inv] contains more information about\n     /// this initialization invariant.\n     ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `assume_init_read` multiple times, or first\n-    /// calling `assume_init_read` and then [`assume_init`]), it is your responsibility\n+    /// Moreover, similar to the [`ptr::read`] function, this function creates a\n+    /// bitwise copy of the contents, regardless whether the contained type\n+    /// implements the [`Copy`] trait or not. When using multiple copies of the\n+    /// data (by calling `assume_init_read` multiple times, or first calling\n+    /// `assume_init_read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n@@ -622,7 +674,8 @@ impl<T> MaybeUninit<T> {\n \n     /// Drops the contained value in place.\n     ///\n-    /// If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.\n+    /// If you have ownership of the `MaybeUninit`, you can also use\n+    /// [`assume_init`] as an alternative.\n     ///\n     /// # Safety\n     ///\n@@ -632,11 +685,12 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// On top of that, all additional invariants of the type `T` must be\n     /// satisfied, as the `Drop` implementation of `T` (or its members) may\n-    /// rely on this. For example, a `1`-initialized [`Vec<T>`] is considered\n-    /// initialized (under the current implementation; this does not constitute\n-    /// a stable guarantee) because the only requirement the compiler knows\n-    /// about it is that the data pointer must be non-null. Dropping such a\n-    /// `Vec<T>` however will cause undefined behaviour.\n+    /// rely on this. For example, setting a [`Vec<T>`] to an invalid but\n+    /// non-null address makes it initialized (under the current implementation;\n+    /// this does not constitute a stable guarantee), because the only\n+    /// requirement the compiler knows about it is that the data pointer must be\n+    /// non-null. Dropping such a `Vec<T>` however will cause undefined\n+    /// behaviour.\n     ///\n     /// [`assume_init`]: MaybeUninit::assume_init\n     /// [`Vec<T>`]: ../../std/vec/struct.Vec.html"}]}