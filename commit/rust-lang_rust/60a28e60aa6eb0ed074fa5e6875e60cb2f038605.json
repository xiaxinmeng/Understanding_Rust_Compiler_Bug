{"sha": "60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYTI4ZTYwYWE2ZWIwZWQwNzRmYTVlNjg3NWU2MGNiMmYwMzg2MDU=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-03-11T00:14:51Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-03-29T23:57:43Z"}, "message": "Add some standard traversal iterators for MIR\n\nAdds Preorder, Postorder and Reverse Postorder traversal iterators.\n\nAlso makes trans/mir use Reverse Postorder traversal for blocks.", "tree": {"sha": "fe572364bef129b0554a0adad5173a97f60e762d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe572364bef129b0554a0adad5173a97f60e762d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "html_url": "https://github.com/rust-lang/rust/commit/60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5c3f1fcf77ec890d340dc3beb676f2a01ae99c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5c3f1fcf77ec890d340dc3beb676f2a01ae99c", "html_url": "https://github.com/rust-lang/rust/commit/8f5c3f1fcf77ec890d340dc3beb676f2a01ae99c"}], "stats": {"total": 286, "additions": 284, "deletions": 2}, "files": [{"sha": "e45c6cfc6dc3fa8705d598884978b0ab2fb47fba", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n /// A very simple BitVector type.\n+#[derive(Clone)]\n pub struct BitVector {\n     data: Vec<u64>,\n }"}, {"sha": "cbbad057cf9c91374f72945caadd618366382880", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "patch": "@@ -40,3 +40,4 @@ mod hair;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n+pub mod traversal;"}, {"sha": "fc53881bd816cddf95be9f12d31d0f3196acc01d", "filename": "src/librustc_mir/traversal.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_mir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_mir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftraversal.rs?ref=60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "patch": "@@ -0,0 +1,276 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::vec;\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n+use rustc::mir::repr::*;\n+\n+/// Preorder traversal of a graph.\n+///\n+/// Preorder traversal is when each node is visited before an of it's\n+/// successors\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A preorder traversal of this graph is either `A B D C` or `A C D B`\n+#[derive(Clone)]\n+pub struct Preorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visited: BitVector,\n+    worklist: Vec<BasicBlock>,\n+}\n+\n+impl<'a, 'tcx> Preorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n+        let worklist = vec![root];\n+\n+        Preorder {\n+            mir: mir,\n+            visited: BitVector::new(mir.basic_blocks.len()),\n+            worklist: worklist\n+        }\n+    }\n+}\n+\n+pub fn preorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Preorder<'a, 'tcx> {\n+    Preorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        while let Some(idx) = self.worklist.pop() {\n+            if !self.visited.insert(idx.index()) {\n+                continue;\n+            }\n+\n+            let data = self.mir.basic_block_data(idx);\n+\n+            if let Some(ref term) = data.terminator {\n+                for &succ in term.successors().iter() {\n+                    self.worklist.push(succ);\n+                }\n+            }\n+\n+            return Some((idx, data));\n+        }\n+\n+        None\n+    }\n+}\n+\n+/// Postorder traversal of a graph.\n+///\n+/// Postorder traversal is when each node is visited after all of it's\n+/// successors, except when the successor is only reachable by a back-edge\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A Postorder traversal of this graph is `D B C A` or `D C B A`\n+pub struct Postorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visited: BitVector,\n+    visit_stack: Vec<(BasicBlock, vec::IntoIter<BasicBlock>)>\n+}\n+\n+impl<'a, 'tcx> Postorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+        let mut po = Postorder {\n+            mir: mir,\n+            visited: BitVector::new(mir.basic_blocks.len()),\n+            visit_stack: Vec::new()\n+        };\n+\n+\n+        let data = po.mir.basic_block_data(root);\n+\n+        if let Some(ref term) = data.terminator {\n+            po.visited.insert(root.index());\n+\n+            let succs = term.successors().into_owned().into_iter();\n+\n+            po.visit_stack.push((root, succs));\n+            po.traverse_successor();\n+        }\n+\n+        po\n+    }\n+\n+    fn traverse_successor(&mut self) {\n+        // This is quite a complex loop due to 1. the borrow checker not liking it much\n+        // and 2. what exactly is going on is not clear\n+        //\n+        // It does the actual traversal of the graph, while the `next` method on the iterator\n+        // just pops off of the stack. `visit_stack` is a stack containing pairs of nodes and\n+        // iterators over the sucessors of those nodes. Each iteration attempts to get the next\n+        // node from the top of the stack, then pushes that node and an iterator over the\n+        // successors to the top of the stack. This loop only grows `visit_stack`, stopping when\n+        // we reach a child that has no children that we haven't already visited.\n+        //\n+        // For a graph that looks like this:\n+        //\n+        //         A\n+        //        / \\\n+        //       /   \\\n+        //      B     C\n+        //      |     |\n+        //      |     |\n+        //      D     |\n+        //       \\   /\n+        //        \\ /\n+        //         E\n+        //\n+        // The state of the stack starts out with just the root node (`A` in this case);\n+        //     [(A, [B, C])]\n+        //\n+        // When the first call to `traverse_sucessor` happens, the following happens:\n+        //\n+        //     [(B, [D]),  // `B` taken from the successors of `A`, pushed to the\n+        //                 // top of the stack along with the successors of `B`\n+        //      (A, [C])]\n+        //\n+        //     [(D, [E]),  // `D` taken from successors of `B`, pushed to stack\n+        //      (B, []),\n+        //      (A, [C])]\n+        //\n+        //     [(E, []),   // `E` taken from successors of `D`, pushed to stack\n+        //      (D, []),\n+        //      (B, []),\n+        //      (A, [C])]\n+        //\n+        // Now that the top of the stack has no successors we can traverse, each item will\n+        // be popped off during iteration until we get back to `A`. This yeilds [E, D, B].\n+        //\n+        // When we yeild `B` and call `traverse_successor`, We push `C` to the stack, but\n+        // since we've already visited `E`, that child isn't added to the stack. The last\n+        // two iterations yield `C` and finally `A` for a final traversal of [E, D, B, C, A]\n+        loop {\n+            let bb = if let Some(&mut (_, ref mut iter)) = self.visit_stack.last_mut() {\n+                if let Some(bb) = iter.next() {\n+                    bb\n+                } else {\n+                    break;\n+                }\n+            } else {\n+                break;\n+            };\n+\n+            if self.visited.insert(bb.index()) {\n+                let data = self.mir.basic_block_data(bb);\n+\n+                if let Some(ref term) = data.terminator {\n+                    let succs = term.successors().into_owned().into_iter();\n+                    self.visit_stack.push((bb, succs));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Postorder<'a, 'tcx> {\n+    Postorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        let next = self.visit_stack.pop();\n+        if next.is_some() {\n+            self.traverse_successor();\n+        }\n+\n+        next.map(|(bb, _)| {\n+            let data = self.mir.basic_block_data(bb);\n+            (bb, data)\n+        })\n+    }\n+}\n+\n+/// Reverse postorder traversal of a graph\n+///\n+/// Reverse postorder is the reverse order of a postorder traversal.\n+/// This is different to a preorder traversal and represents a natural\n+/// linearisation of control-flow.\n+///\n+///         A\n+///        / \\\n+///       /   \\\n+///      B     C\n+///       \\   /\n+///        \\ /\n+///         D\n+///\n+/// A reverse postorder traversal of this graph is either `A B C D` or `A C B D`\n+/// Note that for a graph containing no loops (i.e. A DAG), this is equivalent to\n+/// a topological sort.\n+///\n+/// Construction of a `ReversePostorder` traversal requires doing a full\n+/// postorder traversal of the graph, therefore this traversal should be\n+/// constructed as few times as possible. Use the `reset` method to be able\n+/// to re-use the traversal\n+#[derive(Clone)]\n+pub struct ReversePostorder<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    blocks: Vec<BasicBlock>,\n+    idx: usize\n+}\n+\n+impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n+        let blocks : Vec<_> = Postorder::new(mir, root).map(|(bb, _)| bb).collect();\n+\n+        let len = blocks.len();\n+\n+        ReversePostorder {\n+            mir: mir,\n+            blocks: blocks,\n+            idx: len\n+        }\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.idx = self.blocks.len();\n+    }\n+}\n+\n+\n+pub fn reverse_postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> ReversePostorder<'a, 'tcx> {\n+    ReversePostorder::new(mir, START_BLOCK)\n+}\n+\n+impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        if self.idx == 0 { return None; }\n+        self.idx -= 1;\n+\n+        self.blocks.get(self.idx).map(|&bb| {\n+            let data = self.mir.basic_block_data(bb);\n+            (bb, data)\n+        })\n+    }\n+}"}, {"sha": "152834a07baa07151539423ead279af935024675", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a28e60aa6eb0ed074fa5e6875e60cb2f038605/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "patch": "@@ -20,6 +20,9 @@ use std::ops::Deref;\n use std::rc::Rc;\n \n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use rustc_mir::traversal;\n+\n+use self::lvalue::LvalueRef;\n use self::operand::OperandRef;\n \n #[derive(Clone)]\n@@ -152,8 +155,9 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         args: args,\n     };\n \n-    // Translate the body of each block\n-    for &bb in &mir_blocks {\n+    let rpo = traversal::reverse_postorder(mir);\n+    // Translate the body of each block using reverse postorder\n+    for (bb, _) in rpo {\n         mircx.trans_block(bb);\n     }\n "}]}