{"sha": "05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZDY2ZGM3YTRmZjA1M2I1Y2JmYTVkZGFmYTg5MGFmMjkxZjRmYzI=", "commit": {"author": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-14T12:47:38Z"}, "committer": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-14T14:38:55Z"}, "message": "rustc_trans: add chunked prefix fields to CastTarget", "tree": {"sha": "b656c0202d7288fcb048f43983670e55eaddf53f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b656c0202d7288fcb048f43983670e55eaddf53f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "html_url": "https://github.com/rust-lang/rust/commit/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2/comments", "author": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68042ba0d35f16d66dadf62334ca6bbf20d97268", "url": "https://api.github.com/repos/rust-lang/rust/commits/68042ba0d35f16d66dadf62334ca6bbf20d97268", "html_url": "https://github.com/rust-lang/rust/commit/68042ba0d35f16d66dadf62334ca6bbf20d97268"}], "stats": {"total": 140, "additions": 53, "deletions": 87}, "files": [{"sha": "ee0f2415bd80861626584d3e61bb92b7b76eb15c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 52, "deletions": 86, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "patch": "@@ -40,7 +40,7 @@ use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n \n use libc::c_uint;\n-use std::{cmp, iter};\n+use std::cmp;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -279,30 +279,6 @@ impl Uniform {\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n         self.unit.align(cx)\n     }\n-\n-    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        let llunit = self.unit.llvm_type(cx);\n-\n-        if self.total <= self.unit.size {\n-            return llunit;\n-        }\n-\n-        let count = self.total.bytes() / self.unit.size.bytes();\n-        let rem_bytes = self.total.bytes() % self.unit.size.bytes();\n-\n-        if rem_bytes == 0 {\n-            return Type::array(&llunit, count);\n-        }\n-\n-        // Only integers can be really split further.\n-        assert_eq!(self.unit.kind, RegKind::Integer);\n-\n-        let args: Vec<_> = (0..count).map(|_| llunit)\n-            .chain(iter::once(Type::ix(cx, rem_bytes * 8)))\n-            .collect();\n-\n-        Type::struct_(cx, &args, false)\n-    }\n }\n \n pub trait LayoutExt<'tcx> {\n@@ -405,91 +381,81 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum CastTarget {\n-    Uniform(Uniform),\n-    Pair(Reg, Reg),\n-    ChunkedPrefix { prefix: [RegKind; 8], chunk: Size, total: Size }\n+pub struct CastTarget {\n+    pub prefix: [Option<RegKind>; 8],\n+    pub prefix_chunk: Size,\n+    pub rest: Uniform,\n }\n \n impl From<Reg> for CastTarget {\n     fn from(unit: Reg) -> CastTarget {\n-        CastTarget::Uniform(Uniform::from(unit))\n+        CastTarget::from(Uniform::from(unit))\n     }\n }\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget::Uniform(uniform)\n+        CastTarget {\n+            prefix: [None; 8],\n+            prefix_chunk: Size::from_bytes(0),\n+            rest: uniform\n+        }\n     }\n }\n \n impl CastTarget {\n-    pub fn size(&self, cx: &CodegenCx) -> Size {\n-        match *self {\n-            CastTarget::Uniform(u) => u.total,\n-            CastTarget::Pair(a, b) => {\n-                (a.size.abi_align(a.align(cx)) + b.size)\n-                    .abi_align(self.align(cx))\n-            },\n-            CastTarget::ChunkedPrefix { total, .. } => total\n+    pub fn pair(a: Reg, b: Reg) -> CastTarget {\n+        CastTarget {\n+            prefix: [Some(a.kind), None, None, None, None, None, None, None],\n+            prefix_chunk: a.size,\n+            rest: Uniform::from(b)\n         }\n     }\n \n+    pub fn size(&self, cx: &CodegenCx) -> Size {\n+        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+            .abi_align(self.rest.align(cx)) + self.rest.total\n+    }\n+\n     pub fn align(&self, cx: &CodegenCx) -> Align {\n-        match *self {\n-            CastTarget::Uniform(u) => u.align(cx),\n-            CastTarget::Pair(a, b) => {\n-                cx.data_layout().aggregate_align\n-                    .max(a.align(cx))\n-                    .max(b.align(cx))\n-            },\n-            CastTarget::ChunkedPrefix { chunk, .. } => {\n-                cx.data_layout().aggregate_align\n-                    .max(Reg { kind: RegKind::Integer, size: chunk }.align(cx))\n-                    .max(Reg { kind: RegKind::Float, size: chunk }.align(cx))\n-                    .max(Reg { kind: RegKind::Vector, size: chunk }.align(cx))\n-            }\n-        }\n+        self.prefix.iter()\n+            .filter_map(|x| x.map(|kind| Reg { kind: kind, size: self.prefix_chunk }.align(cx)))\n+            .fold(cx.data_layout().aggregate_align.max(self.rest.align(cx)),\n+                |acc, align| acc.max(align))\n     }\n \n     pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n-        match *self {\n-            CastTarget::Uniform(u) => u.llvm_type(cx),\n-            CastTarget::Pair(a, b) => {\n-                Type::struct_(cx, &[\n-                    a.llvm_type(cx),\n-                    b.llvm_type(cx)\n-                ], false)\n-            },\n-            CastTarget::ChunkedPrefix { prefix, chunk, total } => {\n-                let total_chunks = total.bytes() / chunk.bytes();\n-                let rem_bytes = total.bytes() % chunk.bytes();\n-                let prefix_chunks = total_chunks.min(prefix.len() as u64);\n-\n-                let int_ll_type = Reg { kind: RegKind::Integer, size: chunk }.llvm_type(cx);\n+        let rest_ll_unit = self.rest.unit.llvm_type(cx);\n+        let rest_count = self.rest.total.bytes() / self.rest.unit.size.bytes();\n+        let rem_bytes = self.rest.total.bytes() % self.rest.unit.size.bytes();\n+\n+        if self.prefix.iter().all(|x| x.is_none()) {\n+            // Simplify to a single unit when there is no prefix and size <= unit size\n+            if self.rest.total <= self.rest.unit.size {\n+                return rest_ll_unit;\n+            }\n \n-                // Simple cases simplify to an array\n-                if rem_bytes == 0 && prefix.into_iter().all(|&kind| kind == RegKind::Integer) {\n-                    return Type::array(&int_ll_type, total_chunks);\n-                }\n+            // Simplify to array when all chunks are the same size and type\n+            if rem_bytes == 0 {\n+                return Type::array(&rest_ll_unit, rest_count);\n+            }\n+        }\n \n-                // The final structure is made up of:\n-                //  Up to 8 chunks of the type specified in the prefix\n-                //  Any other complete chunks as integers\n-                //  One final integer needed to make up the total structure size\n-                let mut args: Vec<_> =\n-                    prefix.into_iter().take(prefix_chunks as usize)\n-                        .map(|&kind| Reg { kind: kind, size: chunk }.llvm_type(cx))\n-                    .chain((0..total_chunks - prefix_chunks).map(|_| int_ll_type))\n-                    .collect();\n-\n-                if rem_bytes > 0 {\n-                    args.push(Type::ix(cx, rem_bytes * 8));\n-                }\n+        // Create list of fields in the main structure\n+        let mut args: Vec<_> =\n+            self.prefix.iter().flat_map(|option_kind| option_kind.map(\n+                    |kind| Reg { kind: kind, size: self.prefix_chunk }.llvm_type(cx)))\n+            .chain((0..rest_count).map(|_| rest_ll_unit))\n+            .collect();\n \n-                Type::struct_(cx, &args, false)\n-            }\n+        // Append final integer\n+        if rem_bytes != 0 {\n+            // Only integers can be really split further.\n+            assert_eq!(self.rest.unit.kind, RegKind::Integer);\n+            args.push(Type::ix(cx, rem_bytes * 8));\n         }\n+\n+        Type::struct_(cx, &args, false)\n     }\n }\n "}, {"sha": "7eadaa7f493a3f52b63c9699123f5e08c478b097", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=05d66dc7a4ff053b5cbfa5ddafa890af291f4fc2", "patch": "@@ -171,7 +171,7 @@ fn cast_target(cls: &[Option<Class>], size: Size) -> CastTarget {\n     let mut target = CastTarget::from(lo);\n     if size > offset {\n         if let Some(hi) = reg_component(cls, &mut i, size - offset) {\n-            target = CastTarget::Pair(lo, hi);\n+            target = CastTarget::pair(lo, hi);\n         }\n     }\n     assert_eq!(reg_component(cls, &mut i, Size::from_bytes(0)), None);"}]}