{"sha": "0a76584dcc6dd6ae8f32f905dde379a99da7e516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNzY1ODRkY2M2ZGQ2YWU4ZjMyZjkwNWRkZTM3OWE5OWRhN2U1MTY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-28T19:29:08Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:30Z"}, "message": "Move some code from rustc_typeck to rustc_trait_selection", "tree": {"sha": "6b3885c8e4c08c96f50ecb6d66f7ac6917df4ef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3885c8e4c08c96f50ecb6d66f7ac6917df4ef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a76584dcc6dd6ae8f32f905dde379a99da7e516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a76584dcc6dd6ae8f32f905dde379a99da7e516", "html_url": "https://github.com/rust-lang/rust/commit/0a76584dcc6dd6ae8f32f905dde379a99da7e516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a76584dcc6dd6ae8f32f905dde379a99da7e516/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d9e7f67fa8661757769b8d87f6343ca8251f24", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d9e7f67fa8661757769b8d87f6343ca8251f24", "html_url": "https://github.com/rust-lang/rust/commit/d4d9e7f67fa8661757769b8d87f6343ca8251f24"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "d819740b596658c93c988d0ecff59aaa1e525178", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a76584dcc6dd6ae8f32f905dde379a99da7e516/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a76584dcc6dd6ae8f32f905dde379a99da7e516/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0a76584dcc6dd6ae8f32f905dde379a99da7e516", "patch": "@@ -59,6 +59,7 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::structural_match::search_for_structural_match_violation;\n pub use self::structural_match::NonStructuralMatchTy;\n+pub use self::util::subst_assoc_item_bound;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{"}, {"sha": "3d52453a5c77afed95d242fdb2ca4ed8e4240697", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0a76584dcc6dd6ae8f32f905dde379a99da7e516/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a76584dcc6dd6ae8f32f905dde379a99da7e516/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=0a76584dcc6dd6ae8f32f905dde379a99da7e516", "patch": "@@ -11,6 +11,8 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n pub use rustc_infer::traits::util::*;\n \n+use std::iter;\n+\n ///////////////////////////////////////////////////////////////////////////\n // `TraitAliasExpander` iterator\n ///////////////////////////////////////////////////////////////////////////\n@@ -357,6 +359,59 @@ pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n     assoc_item.defaultness.is_final() && tcx.impl_defaultness(assoc_item.container.id()).is_final()\n }\n \n+/// Map a bound from an associated item to apply to some other type.\n+/// For example, given the following trait\n+///\n+/// trait X<A> { type Y<'a>: PartialEq<A> }\n+///\n+/// Say that we know that `<() as X<B>>::Y<'c> = i32` and we need to check that\n+/// the `PartialEq` bound applies. This function would return\n+/// `i32: PartialEq<B>`.\n+pub fn subst_assoc_item_bound<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bound: ty::Predicate<'tcx>,\n+    normalized_projection_ty: Ty<'tcx>,\n+    assoc_item_substs: &[GenericArg<'tcx>],\n+) -> ty::Predicate<'tcx> {\n+    let translate_predicate_substs = move |predicate_substs: SubstsRef<'tcx>| {\n+        tcx.mk_substs(\n+            iter::once(normalized_projection_ty.into())\n+                .chain(predicate_substs[1..].iter().map(|s| s.subst(tcx, assoc_item_substs))),\n+        )\n+    };\n+\n+    match bound.kind() {\n+        ty::PredicateKind::Trait(poly_tr, c) => poly_tr\n+            .map_bound(|tr| {\n+                let trait_substs = translate_predicate_substs(tr.trait_ref.substs);\n+                ty::TraitRef { def_id: tr.def_id(), substs: trait_substs }\n+            })\n+            .with_constness(*c)\n+            .to_predicate(tcx),\n+        ty::PredicateKind::Projection(poly_projection) => poly_projection\n+            .map_bound(|projection| {\n+                let projection_substs = translate_predicate_substs(projection.projection_ty.substs);\n+                ty::ProjectionPredicate {\n+                    projection_ty: ty::ProjectionTy {\n+                        substs: projection_substs,\n+                        item_def_id: projection.projection_ty.item_def_id,\n+                    },\n+                    ty: projection.ty.subst(tcx, assoc_item_substs),\n+                }\n+            })\n+            .to_predicate(tcx),\n+        ty::PredicateKind::TypeOutlives(poly_outlives) => poly_outlives\n+            .map_bound(|outlives| {\n+                ty::OutlivesPredicate(\n+                    normalized_projection_ty,\n+                    outlives.1.subst(tcx, assoc_item_substs),\n+                )\n+            })\n+            .to_predicate(tcx),\n+        _ => bug!(\"unexepected projection bound: `{:?}`\", bound),\n+    }\n+}\n+\n pub enum TupleArgumentsFlag {\n     Yes,\n     No,"}]}