{"sha": "42467d57cbe48ab2273a9c72b60708e2de2e362f", "node_id": "C_kwDOAAsO6NoAKDQyNDY3ZDU3Y2JlNDhhYjIyNzNhOWM3MmI2MDcwOGUyZGUyZTM2MmY", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-04-24T17:33:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-24T17:33:25Z"}, "message": "Rollup merge of #110480 - whtahy:105107/known-bug-tests-for-unsound-issues, r=jackh726\n\nAdd `known-bug` tests for 11 unsound issues\n\nr? ``@jackh726``\n\nShould tests for other issues be in separate PRs?  Thanks.\n\nEdit: Partially addresses #105107.  This PR adds `known-bug` tests for 11 unsound issues:\n- #25860\n- #49206\n- #57893\n- #84366\n- #84533\n- #84591\n- #85099\n- #98117\n- #100041\n- #100051\n- #104005", "tree": {"sha": "102a4aa31bc2387a84c95a93c6617cce5b9189ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102a4aa31bc2387a84c95a93c6617cce5b9189ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42467d57cbe48ab2273a9c72b60708e2de2e362f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkRr1lCRBK7hj4Ov3rIwAAE2AIAI0vXcM7bqEpnHDlcANQTDVP\nfmtebRBt+fWuxw6UJbzFg96dVyAwRGq4ZyHCt9RbGv7y2BYwdxlf8V69MShNRM0q\nkvGEsRXH0DY+R1KoR0eomnZ0SbrlYXmAxmC0uK0R8HBEAns5z4GIqfiRHJz9wE0X\nPCD84AY3QZ3Uf1FORdFwAqXa0Lesm79Qy+wh+ppFrDA7ksAGmLLaM5vaGLjK13d4\n3/akDwfcg8SZICB/0XFt6NRt03OPn73lxOagULdkU1MNYSbKdYqezEsRLChRc4gm\nOiVct7KlSJR5d7+nGkpQTMfDUgQVEv1aYyECULDHmuFrpH5NjNTyDsxurslirrE=\n=Is0B\n-----END PGP SIGNATURE-----\n", "payload": "tree 102a4aa31bc2387a84c95a93c6617cce5b9189ca\nparent b72460fe46a873da0c40582636c26e7675e92288\nparent ebe61cefc4fa30f0a719892d544abcaee25da44c\nauthor Yuki Okushi <jtitor@2k36.org> 1682357605 +0900\ncommitter GitHub <noreply@github.com> 1682357605 +0900\n\nRollup merge of #110480 - whtahy:105107/known-bug-tests-for-unsound-issues, r=jackh726\n\nAdd `known-bug` tests for 11 unsound issues\n\nr? ``@jackh726``\n\nShould tests for other issues be in separate PRs?  Thanks.\n\nEdit: Partially addresses #105107.  This PR adds `known-bug` tests for 11 unsound issues:\n- #25860\n- #49206\n- #57893\n- #84366\n- #84533\n- #84591\n- #85099\n- #98117\n- #100041\n- #100051\n- #104005\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42467d57cbe48ab2273a9c72b60708e2de2e362f", "html_url": "https://github.com/rust-lang/rust/commit/42467d57cbe48ab2273a9c72b60708e2de2e362f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42467d57cbe48ab2273a9c72b60708e2de2e362f/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b72460fe46a873da0c40582636c26e7675e92288", "url": "https://api.github.com/repos/rust-lang/rust/commits/b72460fe46a873da0c40582636c26e7675e92288", "html_url": "https://github.com/rust-lang/rust/commit/b72460fe46a873da0c40582636c26e7675e92288"}, {"sha": "ebe61cefc4fa30f0a719892d544abcaee25da44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe61cefc4fa30f0a719892d544abcaee25da44c", "html_url": "https://github.com/rust-lang/rust/commit/ebe61cefc4fa30f0a719892d544abcaee25da44c"}], "stats": {"total": 348, "additions": 348, "deletions": 0}, "files": [{"sha": "b5f0684bae92b007d55ba3dfca2b81377dd12f3f", "filename": "tests/ui/closures/static-closures-with-nonstatic-return.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fclosures%2Fstatic-closures-with-nonstatic-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fclosures%2Fstatic-closures-with-nonstatic-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fstatic-closures-with-nonstatic-return.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+// known-bug: #84366\n+\n+// Should fail. Associated types of 'static types should be `'static`, but\n+// argument-free closures can be `'static` and return non-`'static` types.\n+\n+#[allow(dead_code)]\n+fn foo<'a>() {\n+    let closure = || -> &'a str { \"\" };\n+    assert_static(closure);\n+}\n+\n+fn assert_static<T: 'static>(_: T) {}\n+\n+fn main() {}"}, {"sha": "bb46498f90eba362c4afac803b881051ab704d28", "filename": "tests/ui/coherence/indirect-impl-for-trait-obj-coherence.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fcoherence%2Findirect-impl-for-trait-obj-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fcoherence%2Findirect-impl-for-trait-obj-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Findirect-impl-for-trait-obj-coherence.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+// known-bug: #57893\n+\n+// Should fail. Because we see an impl that uses a certain associated type, we\n+// type-check assuming that impl is used. However, this conflicts with the\n+// \"implicit impl\" that we get for trait objects, violating coherence.\n+\n+trait Object<U> {\n+    type Output;\n+}\n+\n+impl<T: ?Sized, U> Object<U> for T {\n+    type Output = U;\n+}\n+\n+fn foo<T: ?Sized, U>(x: <T as Object<U>>::Output) -> U {\n+    x\n+}\n+\n+#[allow(dead_code)]\n+fn transmute<T, U>(x: T) -> U {\n+    foo::<dyn Object<U, Output = T>, U>(x)\n+}\n+\n+fn main() {}"}, {"sha": "0f668b8d469032f7196687685ac05ec6043492df", "filename": "tests/ui/consts/non-sync-references-in-const.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fconsts%2Fnon-sync-references-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fconsts%2Fnon-sync-references-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fnon-sync-references-in-const.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,38 @@\n+// check-pass\n+// known-bug: #49206\n+\n+// Should fail. Compiles and prints 2 identical addresses, which shows 2 threads\n+// with the same `'static` reference to non-`Sync` struct. The problem is that\n+// promotion to static does not check if the type is `Sync`.\n+\n+#[allow(dead_code)]\n+#[derive(Debug)]\n+struct Foo {\n+    value: u32,\n+}\n+\n+// stable negative impl trick from https://crates.io/crates/negative-impl\n+// see https://github.com/taiki-e/pin-project/issues/102#issuecomment-540472282\n+// for details.\n+struct Wrapper<'a, T>(::std::marker::PhantomData<&'a ()>, T);\n+unsafe impl<T> Sync for Wrapper<'_, T> where T: Sync {}\n+unsafe impl<'a> std::marker::Sync for Foo where Wrapper<'a, *const ()>: Sync {}\n+fn _assert_sync<T: Sync>() {}\n+\n+fn inspect() {\n+    let foo: &'static Foo = &Foo { value: 1 };\n+    println!(\n+        \"I am in thread {:?}, address: {:p}\",\n+        std::thread::current().id(),\n+        foo as *const Foo,\n+    );\n+}\n+\n+fn main() {\n+    // _assert_sync::<Foo>(); // uncomment this line causes compile error\n+    // \"`*const ()` cannot be shared between threads safely\"\n+\n+    let handle = std::thread::spawn(inspect);\n+    inspect();\n+    handle.join().unwrap();\n+}"}, {"sha": "68a1d0ce9b0b2c01e63d4ba010e26df37602c345", "filename": "tests/ui/fn/fn-item-lifetime-bounds.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ffn%2Ffn-item-lifetime-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ffn%2Ffn-item-lifetime-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-item-lifetime-bounds.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// known-bug: #84533\n+\n+// Should fail. Lifetimes are checked correctly when `foo` is called, but NOT\n+// when only the lifetime parameters are instantiated.\n+\n+use std::marker::PhantomData;\n+\n+#[allow(dead_code)]\n+fn foo<'b, 'a>() -> PhantomData<&'b &'a ()> {\n+    PhantomData\n+}\n+\n+#[allow(dead_code)]\n+#[allow(path_statements)]\n+fn caller<'b, 'a>() {\n+    foo::<'b, 'a>;\n+}\n+\n+// In contrast to above, below code correctly does NOT compile.\n+// fn caller<'b, 'a>() {\n+//     foo::<'b, 'a>();\n+// }\n+\n+// error: lifetime may not live long enough\n+//   --> src/main.rs:22:5\n+//   |\n+// 21 | fn caller<'b, 'a>() {\n+//   |           --  -- lifetime `'a` defined here\n+//   |           |\n+//   |           lifetime `'b` defined here\n+// 22 |     foo::<'b, 'a>();\n+//   |     ^^^^^^^^^^^^^^^ requires that `'a` must outlive `'b`\n+//   |\n+//   = help: consider adding the following bound: `'a: 'b`\n+\n+fn main() {}"}, {"sha": "28cec8050327f36ab6e254f259ab9ae9706682b0", "filename": "tests/ui/fn/implied-bounds-impl-header-projections.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ffn%2Fimplied-bounds-impl-header-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ffn%2Fimplied-bounds-impl-header-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Fimplied-bounds-impl-header-projections.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+// known-bug: #100051\n+\n+// Should fail. Implied bounds from projections in impl headers can create\n+// improper lifetimes.  Variant of issue #98543 which was fixed by #99217.\n+\n+trait Trait {\n+    type Type;\n+}\n+\n+impl<T> Trait for T {\n+    type Type = ();\n+}\n+\n+trait Extend<'a, 'b> {\n+    fn extend(self, s: &'a str) -> &'b str;\n+}\n+\n+impl<'a, 'b> Extend<'a, 'b> for <&'b &'a () as Trait>::Type\n+where\n+    for<'what, 'ever> &'what &'ever (): Trait,\n+{\n+    fn extend(self, s: &'a str) -> &'b str {\n+        s\n+    }\n+}\n+\n+fn main() {\n+    let y = <() as Extend<'_, '_>>::extend((), &String::from(\"Hello World\"));\n+    println!(\"{}\", y);\n+}"}, {"sha": "1f5562497c12e0093bef44adf766fc11ff2e29b8", "filename": "tests/ui/implied-bounds/implied-bounds-on-nested-references-plus-variance.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-nested-references-plus-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-nested-references-plus-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-nested-references-plus-variance.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// known-bug: #25860\n+\n+// Should fail. The combination of variance and implied bounds for nested\n+// references allows us to infer a longer lifetime than we can prove.\n+\n+static UNIT: &'static &'static () = &&();\n+\n+fn foo<'a, 'b, T>(_: &'a &'b (), v: &'b T) -> &'a T { v }\n+\n+fn bad<'a, T>(x: &'a T) -> &'static T {\n+    let f: fn(_, &'a T) -> &'static T = foo;\n+    f(UNIT, x)\n+}\n+\n+fn main() {}"}, {"sha": "9c26cd59d100ab00d12cb4edca6283867d2dbcc0", "filename": "tests/ui/implied-bounds/implied-bounds-on-trait-hierarchy.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-trait-hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-trait-hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimplied-bounds-on-trait-hierarchy.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+// known-bug: #84591\n+\n+// Should fail. Subtrait can incorrectly extend supertrait lifetimes even when\n+// supertrait has weaker implied bounds than subtrait. Strongly related to\n+// issue #25860.\n+\n+trait Subtrait<T>: Supertrait {}\n+trait Supertrait {\n+    fn action(self);\n+}\n+\n+fn subs_to_soup<T, U>(x: T)\n+where\n+    T: Subtrait<U>,\n+{\n+    soup(x)\n+}\n+\n+fn soup<T: Supertrait>(x: T) {\n+    x.action();\n+}\n+\n+impl<'a, 'b: 'a> Supertrait for (&'b str, &mut &'a str) {\n+    fn action(self) {\n+        *self.1 = self.0;\n+    }\n+}\n+\n+impl<'a, 'b> Subtrait<&'a &'b str> for (&'b str, &mut &'a str) {}\n+\n+fn main() {\n+    let mut d = \"hi\";\n+    {\n+        let x = \"Hello World\".to_string();\n+        subs_to_soup((x.as_str(), &mut d));\n+    }\n+    println!(\"{}\", d);\n+}"}, {"sha": "03602144e5001b83efcce174edf9e384d92e8cd7", "filename": "tests/ui/typeck/pin-unsound-issue-85099-derefmut.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ftypeck%2Fpin-unsound-issue-85099-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Ftypeck%2Fpin-unsound-issue-85099-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fpin-unsound-issue-85099-derefmut.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,68 @@\n+// check-pass\n+// known-bug: #85099\n+\n+// Should fail. Can coerce `Pin<T>` into `Pin<U>` where\n+// `T: Deref<Target: Unpin>` and `U: Deref<Target: !Unpin>`, using the\n+// `CoerceUnsized` impl on `Pin` and an unorthodox `DerefMut` impl for\n+// `Pin<&_>`.\n+\n+// This should not be allowed, since one can unpin `T::Target` (since it is\n+// `Unpin`) to gain unpinned access to the previously pinned `U::Target` (which\n+// is `!Unpin`) and then move it.\n+\n+use std::{\n+    cell::{RefCell, RefMut},\n+    future::Future,\n+    ops::DerefMut,\n+    pin::Pin,\n+};\n+\n+struct SomeLocalStruct<'a, Fut>(&'a RefCell<Fut>);\n+\n+trait SomeTrait<'a, Fut> {\n+    #[allow(clippy::mut_from_ref)]\n+    fn deref_helper(&self) -> &mut (dyn SomeTrait<'a, Fut> + 'a) {\n+        unimplemented!()\n+    }\n+    fn downcast(self: Pin<&mut Self>) -> Pin<&mut Fut> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'a, Fut: Future<Output = ()>> SomeTrait<'a, Fut> for SomeLocalStruct<'a, Fut> {\n+    fn deref_helper(&self) -> &mut (dyn SomeTrait<'a, Fut> + 'a) {\n+        let x = Box::new(self.0.borrow_mut());\n+        let x: &'a mut RefMut<'a, Fut> = Box::leak(x);\n+        &mut **x\n+    }\n+}\n+impl<'a, Fut: Future<Output = ()>> SomeTrait<'a, Fut> for Fut {\n+    fn downcast(self: Pin<&mut Self>) -> Pin<&mut Fut> {\n+        self\n+    }\n+}\n+\n+impl<'b, 'a, Fut> DerefMut for Pin<&'b dyn SomeTrait<'a, Fut>> {\n+    fn deref_mut<'c>(\n+        self: &'c mut Pin<&'b dyn SomeTrait<'a, Fut>>,\n+    ) -> &'c mut (dyn SomeTrait<'a, Fut> + 'b) {\n+        self.deref_helper()\n+    }\n+}\n+\n+// obviously a \"working\" function with this signature is problematic\n+pub fn unsound_pin<Fut: Future<Output = ()>>(\n+    fut: Fut,\n+    callback: impl FnOnce(Pin<&mut Fut>),\n+) -> Fut {\n+    let cell = RefCell::new(fut);\n+    let s: &SomeLocalStruct<'_, Fut> = &SomeLocalStruct(&cell);\n+    let p: Pin<Pin<&SomeLocalStruct<'_, Fut>>> = Pin::new(Pin::new(s));\n+    let mut p: Pin<Pin<&dyn SomeTrait<'_, Fut>>> = p;\n+    let r: Pin<&mut dyn SomeTrait<'_, Fut>> = p.as_mut();\n+    let f: Pin<&mut Fut> = r.downcast();\n+    callback(f);\n+    cell.into_inner()\n+}\n+\n+fn main() {}"}, {"sha": "c5ff92c88754af80283fe37ac9d04d30fb1e6669", "filename": "tests/ui/wf/wf-in-fn-type-implicit.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-in-fn-type-implicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-in-fn-type-implicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwf%2Fwf-in-fn-type-implicit.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// known-bug: #104005\n+\n+// Should fail. Function type parameters with implicit type annotations are not\n+// checked for well-formedness, which allows incorrect borrowing.\n+\n+// In contrast, user annotations are always checked for well-formedness, and the\n+// commented code below is correctly rejected by the borrow checker.\n+\n+use std::fmt::Display;\n+\n+trait Displayable {\n+    fn display(self) -> Box<dyn Display>;\n+}\n+\n+impl<T: Display> Displayable for (T, Option<&'static T>) {\n+    fn display(self) -> Box<dyn Display> {\n+        Box::new(self.0)\n+    }\n+}\n+\n+fn extend_lt<T, U>(val: T) -> Box<dyn Display>\n+where\n+    (T, Option<U>): Displayable,\n+{\n+    Displayable::display((val, None))\n+}\n+\n+fn main() {\n+    // *incorrectly* compiles\n+    let val = extend_lt(&String::from(\"blah blah blah\"));\n+    println!(\"{}\", val);\n+\n+    // *correctly* fails to compile\n+    // let val = extend_lt::<_, &_>(&String::from(\"blah blah blah\"));\n+    // println!(\"{}\", val);\n+}"}, {"sha": "86722afdf9fdd91601c4f7c16d59f4cb43f0a44c", "filename": "tests/ui/wf/wf-in-where-clause-static.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-in-where-clause-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-in-where-clause-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwf%2Fwf-in-where-clause-static.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+// known-bug: #98117\n+\n+// Should fail. Functions are responsible for checking the well-formedness of\n+// their own where clauses, so this should fail and require an explicit bound\n+// `T: 'static`.\n+\n+use std::fmt::Display;\n+\n+trait Static: 'static {}\n+impl<T> Static for &'static T {}\n+\n+fn foo<S: Display>(x: S) -> Box<dyn Display>\n+where\n+    &'static S: Static,\n+{\n+    Box::new(x)\n+}\n+\n+fn main() {\n+    let s = foo(&String::from(\"blah blah blah\"));\n+    println!(\"{}\", s);\n+}"}, {"sha": "473fc79a8a39dfc0ca022769b69a93fc7c85af89", "filename": "tests/ui/wf/wf-normalization-sized.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-normalization-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42467d57cbe48ab2273a9c72b60708e2de2e362f/tests%2Fui%2Fwf%2Fwf-normalization-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwf%2Fwf-normalization-sized.rs?ref=42467d57cbe48ab2273a9c72b60708e2de2e362f", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+// known-bug: #100041\n+\n+// Should fail. Normalization can bypass well-formedness checking.\n+// `[[[[[[u8]]]]]]` is not a well-formed type since size of type `[u8]` cannot\n+// be known at compile time (since `Sized` is not implemented for `[u8]`).\n+\n+trait WellUnformed {\n+    type RequestNormalize;\n+}\n+\n+impl<T: ?Sized> WellUnformed for T {\n+    type RequestNormalize = ();\n+}\n+\n+const _: <[[[[[[u8]]]]]] as WellUnformed>::RequestNormalize = ();\n+const _: <Vec<str> as WellUnformed>::RequestNormalize = ();\n+\n+fn main() {}"}]}