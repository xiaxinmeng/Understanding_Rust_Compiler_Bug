{"sha": "6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjZkNTBhNmZmNzY4NWI0YWEwOTE3MmQ5ZDA5ZjAzZjI1MGRhOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-19T23:08:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-19T23:08:26Z"}, "message": "Auto merge of #52953 - dsciarra:mv-codemap-sourcemap, r=petrochenkov\n\nRename CodeMap/FileMap to SourceMap/SourceFile\n\nA first renaming for #51574", "tree": {"sha": "45b651039eb9347abbb53fff215e936c402653a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45b651039eb9347abbb53fff215e936c402653a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "html_url": "https://github.com/rust-lang/rust/commit/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f28f648a9699db67b86735f97d609c3dd06f9ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28f648a9699db67b86735f97d609c3dd06f9ded", "html_url": "https://github.com/rust-lang/rust/commit/f28f648a9699db67b86735f97d609c3dd06f9ded"}, {"sha": "6138c82803a77a44e0a56cd8999299fa7f214afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/6138c82803a77a44e0a56cd8999299fa7f214afe", "html_url": "https://github.com/rust-lang/rust/commit/6138c82803a77a44e0a56cd8999299fa7f214afe"}], "stats": {"total": 1737, "additions": 879, "deletions": 858}, "files": [{"sha": "0a32963a861de6c0764eb461a0f4d5cb5a12e5e8", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -63,7 +63,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax_pos::{FileMap, Pos, FileName};\n+use syntax_pos::{Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -308,7 +308,7 @@ impl Span {\n     #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn source_file(&self) -> SourceFile {\n         SourceFile {\n-            filemap: __internal::lookup_char_pos(self.0.lo()).file,\n+            source_file: __internal::lookup_char_pos(self.0.lo()).file,\n         }\n     }\n \n@@ -419,7 +419,7 @@ impl !Sync for LineColumn {}\n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n #[derive(Clone)]\n pub struct SourceFile {\n-    filemap: Lrc<FileMap>,\n+    source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n@@ -432,17 +432,17 @@ impl SourceFile {\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n-    /// may not be an actual path on the filesystem. Use [`is_real`] to check.\n+    /// macro, this may not be an actual path on the filesystem. Use [`is_real`] to check.\n     ///\n     /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n     /// the command line, the path as given may not actually be valid.\n     ///\n     /// [`is_real`]: #method.is_real\n     #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn path(&self) -> PathBuf {\n-        match self.filemap.name {\n+        match self.source_file.name {\n             FileName::Real(ref path) => path.clone(),\n-            _ => PathBuf::from(self.filemap.name.to_string())\n+            _ => PathBuf::from(self.source_file.name.to_string())\n         }\n     }\n \n@@ -453,7 +453,7 @@ impl SourceFile {\n         // This is a hack until intercrate spans are implemented and we can have real source files\n         // for spans generated in external macros.\n         // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n-        self.filemap.is_real_file()\n+        self.source_file.is_real_file()\n     }\n }\n \n@@ -471,7 +471,7 @@ impl fmt::Debug for SourceFile {\n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n impl PartialEq for SourceFile {\n     fn eq(&self, other: &Self) -> bool {\n-        Lrc::ptr_eq(&self.filemap, &other.filemap)\n+        Lrc::ptr_eq(&self.source_file, &other.source_file)\n     }\n }\n \n@@ -1186,7 +1186,7 @@ pub mod __internal {\n     use super::{TokenStream, LexError, Span};\n \n     pub fn lookup_char_pos(pos: BytePos) -> Loc {\n-        with_sess(|sess, _| sess.codemap().lookup_char_pos(pos))\n+        with_sess(|sess, _| sess.source_map().lookup_char_pos(pos))\n     }\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {"}, {"sha": "b5f5f4d5c11794c57ce694274b484784eb2001f5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -68,7 +68,7 @@ use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::codemap::{self, respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream::{Delimited, TokenStream, TokenTree};\n@@ -614,14 +614,14 @@ impl<'a> LoweringContext<'a> {\n \n     fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(codemap::ExpnInfo {\n+        mark.set_expn_info(source_map::ExpnInfo {\n             call_site: span,\n             def_site: Some(span),\n-            format: codemap::CompilerDesugaring(reason),\n+            format: source_map::CompilerDesugaring(reason),\n             allow_internal_unstable: true,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n-            edition: codemap::hygiene::default_edition(),\n+            edition: source_map::hygiene::default_edition(),\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n@@ -3621,7 +3621,7 @@ impl<'a> LoweringContext<'a> {\n                     let tail = block.expr.take().map_or_else(\n                         || {\n                             let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                            let span = this.sess.codemap().end_point(unstable_span);\n+                            let span = this.sess.source_map().end_point(unstable_span);\n                             hir::Expr {\n                                 id: node_id,\n                                 span,"}, {"sha": "a14745a1381273d38bebe104520838dcb86cf6d5", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n-use syntax::codemap::CodeMap;\n+use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n \n use ich::StableHashingContext;\n@@ -122,7 +122,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n-                                                  codemap: &CodeMap,\n+                                                  source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n         self\n@@ -155,11 +155,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // If we included the full mapping in the SVH, we could only have\n         // reproducible builds by compiling from the same directory. So we just\n         // hash the result of the mapping instead of the mapping itself.\n-        let mut source_file_names: Vec<_> = codemap\n+        let mut source_file_names: Vec<_> = source_map\n             .files()\n             .iter()\n-            .filter(|filemap| CrateNum::from_u32(filemap.crate_of_origin) == LOCAL_CRATE)\n-            .map(|filemap| filemap.name_hash)\n+            .filter(|source_file| CrateNum::from_u32(source_file.crate_of_origin) == LOCAL_CRATE)\n+            .map(|source_file| source_file.name_hash)\n             .collect();\n \n         source_file_names.sort_unstable();"}, {"sha": "7ecbf7ebbaff07f63520365a79e33fee18ed05db", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -739,7 +739,7 @@ define_global_metadata_kind!(pub enum GlobalMetaDataKind {\n     LangItems,\n     LangItemsMissing,\n     NativeLibraries,\n-    CodeMap,\n+    SourceMap,\n     Impls,\n     ExportedSymbols\n });"}, {"sha": "ebda91cb7b0775269fb586d87237da406adf1c89", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use middle::cstore::CrateStore;\n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -1202,7 +1202,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n-                                                  sess.codemap(),\n+                                                  sess.source_map(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "795dba93abd6b42492fd5d4eec2aa48185752632", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n-use syntax::codemap::{self, Spanned};\n+use syntax::source_map::{self, Spanned};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n@@ -1100,7 +1100,7 @@ pub type Stmt = Spanned<StmtKind>;\n impl fmt::Debug for StmtKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Sadness.\n-        let spanned = codemap::dummy_spanned(self.clone());\n+        let spanned = source_map::dummy_spanned(self.clone());\n         write!(f,\n                \"stmt({}: {})\",\n                spanned.node.id(),"}, {"sha": "9fe462e65a2cb07fe4aeb9120dc71e68beff8495", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::{CodeMap, Spanned};\n+use syntax::source_map::{SourceMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n@@ -85,7 +85,7 @@ impl PpAnn for hir::Crate {\n \n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n-    cm: Option<&'a CodeMap>,\n+    cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment>>,\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n@@ -129,7 +129,7 @@ pub const default_columns: usize = 78;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n /// copy forward.\n-pub fn print_crate<'a>(cm: &'a CodeMap,\n+pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n                        filename: FileName,\n@@ -149,7 +149,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n }\n \n impl<'a> State<'a> {\n-    pub fn new_from_input(cm: &'a CodeMap,\n+    pub fn new_from_input(cm: &'a SourceMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n@@ -173,7 +173,7 @@ impl<'a> State<'a> {\n                    })\n     }\n \n-    pub fn new(cm: &'a CodeMap,\n+    pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write + 'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,"}, {"sha": "97114779042af612ec3c0750f13889b7dd821c80", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,29 +9,29 @@\n // except according to those terms.\n \n use rustc_data_structures::sync::Lrc;\n-use syntax::codemap::CodeMap;\n-use syntax_pos::{BytePos, FileMap};\n+use syntax::source_map::SourceMap;\n+use syntax_pos::{BytePos, SourceFile};\n \n #[derive(Clone)]\n struct CacheEntry {\n     time_stamp: usize,\n     line_number: usize,\n     line_start: BytePos,\n     line_end: BytePos,\n-    file: Lrc<FileMap>,\n+    file: Lrc<SourceFile>,\n     file_index: usize,\n }\n \n #[derive(Clone)]\n-pub struct CachingCodemapView<'cm> {\n-    codemap: &'cm CodeMap,\n+pub struct CachingSourceMapView<'cm> {\n+    source_map: &'cm SourceMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n }\n \n-impl<'cm> CachingCodemapView<'cm> {\n-    pub fn new(codemap: &'cm CodeMap) -> CachingCodemapView<'cm> {\n-        let files = codemap.files();\n+impl<'cm> CachingSourceMapView<'cm> {\n+    pub fn new(source_map: &'cm SourceMap) -> CachingSourceMapView<'cm> {\n+        let files = source_map.files();\n         let first_file = files[0].clone();\n         let entry = CacheEntry {\n             time_stamp: 0,\n@@ -42,16 +42,16 @@ impl<'cm> CachingCodemapView<'cm> {\n             file_index: 0,\n         };\n \n-        CachingCodemapView {\n-            codemap,\n+        CachingSourceMapView {\n+            source_map,\n             line_cache: [entry.clone(), entry.clone(), entry.clone()],\n             time_stamp: 0,\n         }\n     }\n \n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n-                                    -> Option<(Lrc<FileMap>, usize, BytePos)> {\n+                                    -> Option<(Lrc<SourceFile>, usize, BytePos)> {\n         self.time_stamp += 1;\n \n         // Check if the position is in one of the cached lines\n@@ -78,9 +78,9 @@ impl<'cm> CachingCodemapView<'cm> {\n         // If the entry doesn't point to the correct file, fix it up\n         if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n             let file_valid;\n-            if self.codemap.files().len() > 0 {\n-                let file_index = self.codemap.lookup_filemap_idx(pos);\n-                let file = self.codemap.files()[file_index].clone();\n+            if self.source_map.files().len() > 0 {\n+                let file_index = self.source_map.lookup_source_file_idx(pos);\n+                let file = self.source_map.files()[file_index].clone();\n \n                 if pos >= file.start_pos && pos < file.end_pos {\n                     cache_entry.file = file;"}, {"sha": "f03ad98c7dee4e9bb454fda317521e819a9448d4", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ use hir;\n use hir::def_id::{DefId, DefIndex};\n use hir::map::DefPathHash;\n use hir::map::definitions::Definitions;\n-use ich::{self, CachingCodemapView, Fingerprint};\n+use ich::{self, CachingSourceMapView, Fingerprint};\n use middle::cstore::CrateStore;\n use ty::{TyCtxt, fast_reject};\n use mir::interpret::AllocId;\n@@ -25,7 +25,7 @@ use std::cell::RefCell;\n \n use syntax::ast;\n \n-use syntax::codemap::CodeMap;\n+use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -57,9 +57,9 @@ pub struct StableHashingContext<'a> {\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n-    // CachingCodemapView, so we initialize it lazily.\n-    raw_codemap: &'a CodeMap,\n-    caching_codemap: Option<CachingCodemapView<'a>>,\n+    // CachingSourceMapView, so we initialize it lazily.\n+    raw_source_map: &'a SourceMap,\n+    caching_source_map: Option<CachingSourceMapView<'a>>,\n \n     pub(super) alloc_id_recursion_tracker: FxHashSet<AllocId>,\n }\n@@ -100,8 +100,8 @@ impl<'a> StableHashingContext<'a> {\n             body_resolver: BodyResolver(krate),\n             definitions,\n             cstore,\n-            caching_codemap: None,\n-            raw_codemap: sess.codemap(),\n+            caching_source_map: None,\n+            raw_source_map: sess.source_map(),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n@@ -169,13 +169,13 @@ impl<'a> StableHashingContext<'a> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'a> {\n-        match self.caching_codemap {\n+    pub fn source_map(&mut self) -> &mut CachingSourceMapView<'a> {\n+        match self.caching_source_map {\n             Some(ref mut cm) => {\n                 cm\n             }\n             ref mut none => {\n-                *none = Some(CachingCodemapView::new(self.raw_codemap));\n+                *none = Some(CachingSourceMapView::new(self.raw_source_map));\n                 none.as_mut().unwrap()\n             }\n         }\n@@ -308,9 +308,9 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the CodeMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing FileMap has moved\n-    // within the CodeMap.\n+    // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n+    // triple, which stays the same even if the containing SourceFile has moved\n+    // within the SourceMap.\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n@@ -340,7 +340,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n             return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n         }\n \n-        let (file_lo, line_lo, col_lo) = match hcx.codemap()\n+        let (file_lo, line_lo, col_lo) = match hcx.source_map()\n                                                   .byte_pos_to_line_and_col(span.lo) {\n             Some(pos) => pos,\n             None => {"}, {"sha": "65b84ce4a82251b9864c19eca07aeab1b822dd46", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::symbol::{InternedString, LocalInternedString};\n use syntax::tokenstream;\n-use syntax_pos::FileMap;\n+use syntax_pos::SourceFile;\n \n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n@@ -427,11 +427,11 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Custom(s)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let FileMap {\n+        let SourceFile {\n             name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n             name_was_remapped,\n@@ -458,13 +458,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n \n         src_hash.hash_stable(hcx, hasher);\n \n-        // We only hash the relative position within this filemap\n+        // We only hash the relative position within this source_file\n         lines.len().hash_stable(hcx, hasher);\n         for &line in lines.iter() {\n             stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n         }\n \n-        // We only hash the relative position within this filemap\n+        // We only hash the relative position within this source_file\n         multibyte_chars.len().hash_stable(hcx, hasher);\n         for &char_pos in multibyte_chars.iter() {\n             stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n@@ -478,29 +478,29 @@ impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n }\n \n fn stable_byte_pos(pos: ::syntax_pos::BytePos,\n-                   filemap_start: ::syntax_pos::BytePos)\n+                   source_file_start: ::syntax_pos::BytePos)\n                    -> u32 {\n-    pos.0 - filemap_start.0\n+    pos.0 - source_file_start.0\n }\n \n fn stable_multibyte_char(mbc: ::syntax_pos::MultiByteChar,\n-                         filemap_start: ::syntax_pos::BytePos)\n+                         source_file_start: ::syntax_pos::BytePos)\n                          -> (u32, u32) {\n     let ::syntax_pos::MultiByteChar {\n         pos,\n         bytes,\n     } = mbc;\n \n-    (pos.0 - filemap_start.0, bytes as u32)\n+    (pos.0 - source_file_start.0, bytes as u32)\n }\n \n fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n-                          filemap_start: ::syntax_pos::BytePos)\n+                          source_file_start: ::syntax_pos::BytePos)\n                           -> (u32, u32) {\n     let pos = swc.pos();\n     let width = swc.width();\n \n-    (pos.0 - filemap_start.0, width as u32)\n+    (pos.0 - source_file_start.0, width as u32)\n }\n \n "}, {"sha": "6e5134c3c0545e013eb8386fad8efc25b5029efe", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -11,7 +11,7 @@\n //! ICH - Incremental Compilation Hash\n \n crate use rustc_data_structures::fingerprint::Fingerprint;\n-pub use self::caching_codemap_view::CachingCodemapView;\n+pub use self::caching_codemap_view::CachingSourceMapView;\n pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls};\n mod caching_codemap_view;"}, {"sha": "9b25727112cdf682900c5cb455f012295f36dcb8", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n use std::ops::Index;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n use ty::{self, CanonicalVar, Lift, Region, Slice, TyCtxt};"}, {"sha": "d2987119e299647d870450d078f962dc88305e31", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         region: ty::Region<'tcx>,\n     ) -> (String, Option<Span>) {\n-        let cm = self.sess.codemap();\n+        let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n-        let lo = self.sess.codemap().lookup_char_pos_adj(span.lo());\n+        let lo = self.sess.source_map().lookup_char_pos_adj(span.lo());\n         (\n             format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n             Some(span),\n@@ -502,14 +502,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";\n-                    if self.tcx.sess.codemap().is_multiline(arm_span) {\n+                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n                     } else {\n                         err.span_label(arm_span, msg);\n                     }\n                 },\n                 hir::MatchSource::TryDesugar => { // Issue #51632\n-                    if let Ok(try_snippet) = self.tcx.sess.codemap().span_to_snippet(arm_span) {\n+                    if let Ok(try_snippet) = self.tcx.sess.source_map().span_to_snippet(arm_span) {\n                         err.span_suggestion_with_applicability(\n                             arm_span,\n                             \"try wrapping with a success variant\",\n@@ -520,7 +520,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 _ => {\n                     let msg = \"match arm with an incompatible type\";\n-                    if self.tcx.sess.codemap().is_multiline(arm_span) {\n+                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n                     } else {\n                         err.span_label(arm_span, msg);\n@@ -1136,8 +1136,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             let sp = if has_bounds {\n                                 sp.to(self.tcx\n                                     .sess\n-                                    .codemap()\n-                                    .next_point(self.tcx.sess.codemap().next_point(sp)))\n+                                    .source_map()\n+                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n                             } else {\n                                 sp\n                             };"}, {"sha": "bd2c81c7fb64f4174a5addb700a13be437885de0", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,7 +13,7 @@ use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n use ty::{self, Ty, TyInfer, TyVar};\n-use syntax::codemap::CompilerDesugaringKind;\n+use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n "}, {"sha": "0ff5630f63ed0837b97c8e402b13ef5d83854f23", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -11,7 +11,7 @@\n use infer::InferCtxt;\n use infer::lexical_region_resolve::RegionResolutionError;\n use infer::lexical_region_resolve::RegionResolutionError::*;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use ty::{self, TyCtxt};\n use util::common::ErrorReported;\n "}, {"sha": "d25dcd5b045ca30aef3918c86285e98cfec794c9", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                             }) => name.to_string(),\n                             _ => \"'_\".to_owned(),\n                         };\n-                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(return_sp) {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(return_sp) {\n                             err.span_suggestion(\n                                 return_sp,\n                                 &format!("}, {"sha": "015f755e97d161ae235c3cb560c48d5054337f90", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use lint::{LintPass, LateLintPass, LintArray};\n use session::Session;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n \n declare_lint! {\n     pub EXCEEDING_BITSHIFTS,\n@@ -420,7 +420,7 @@ impl BuiltinLintDiagnostics {\n         match self {\n             BuiltinLintDiagnostics::Normal => (),\n             BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n-                let (sugg, app) = match sess.codemap().span_to_snippet(span) {\n+                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n                     Ok(ref s) if is_global => (format!(\"dyn ({})\", s),\n                                                Applicability::MachineApplicable),\n                     Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n@@ -429,7 +429,7 @@ impl BuiltinLintDiagnostics {\n                 db.span_suggestion_with_applicability(span, \"use `dyn`\", sugg, app);\n             }\n             BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n-                let (sugg, app) = match sess.codemap().span_to_snippet(span) {\n+                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n                     Ok(ref s) => {\n                         // FIXME(Manishearth) ideally the emitting code\n                         // can tell us whether or not this is global\n@@ -462,7 +462,7 @@ impl BuiltinLintDiagnostics {\n                     // When possible, prefer a suggestion that replaces the whole\n                     // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n                     // at a point (which makes for an ugly/confusing label)\n-                    if let Ok(snippet) = sess.codemap().span_to_snippet(path_span) {\n+                    if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n                         // But our spans can get out of whack due to macros; if the place we think\n                         // we want to insert `'_` isn't even within the path expression's span, we\n                         // should bail out of making any suggestion rather than panicking on a"}, {"sha": "5b9ddabf21c1b36fa16681c5ba1eb72c73046338", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n use session::Session;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::MultiSpan;\n+use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n use syntax::symbol::Symbol;\n use util::nodemap::FxHashMap;"}, {"sha": "5872440c36250c9148e1930b7ac25a6d7f0e00b0", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -42,7 +42,7 @@ use lint::builtin::parser::QUESTION_MARK_MACRO_SEP;\n use session::{Session, DiagnosticMessageId};\n use std::{hash, ptr};\n use syntax::ast;\n-use syntax::codemap::{MultiSpan, ExpnFormat};\n+use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n@@ -754,7 +754,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n         None => return true,\n     };\n \n-    match sess.codemap().span_to_snippet(def_site) {\n+    match sess.source_map().span_to_snippet(def_site) {\n         Ok(code) => !code.starts_with(\"macro_rules\"),\n         // no snippet = external macro or compiler-builtin expansion\n         Err(_) => true,"}, {"sha": "759ac1a7952f7165b0ef858f42359513049c7fce", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -147,7 +147,7 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ::syntax::codemap::Spanned<$T>\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ::syntax::source_map::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "8c4c54ec954d0d946367c1852c09a17234d49b6d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use middle::privacy;\n use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n-use syntax::{ast, codemap};\n+use syntax::{ast, source_map};\n use syntax::attr;\n use syntax_pos;\n \n@@ -115,7 +115,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n-                                  pats: &[codemap::Spanned<hir::FieldPat>]) {\n+                                  pats: &[source_map::Spanned<hir::FieldPat>]) {\n         let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n@@ -551,7 +551,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 hir::ItemKind::Struct(..) |\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Trait(..) |\n-                hir::ItemKind::Impl(..) => self.tcx.sess.codemap().def_span(item.span),\n+                hir::ItemKind::Impl(..) => self.tcx.sess.source_map().def_span(item.span),\n                 _ => item.span,\n             };\n             let participle = match item.node {\n@@ -612,7 +612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n-                    let span = self.tcx.sess.codemap().def_span(impl_item.span);\n+                    let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }\n                 self.visit_nested_body(body_id)"}, {"sha": "7d9590ee578e609ab7fbfd6de069263b0d545d6b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -157,7 +157,7 @@ enum LiveNodeKind {\n }\n \n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n-    let cm = tcx.sess.codemap();\n+    let cm = tcx.sess.source_map();\n     match lnk {\n         FreeVarNode(s) => {\n             format!(\"Free var node [{}]\", cm.span_to_string(s))"}, {"sha": "be1d93dbad1b882f20118ae287844aaa679df943", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -23,7 +23,7 @@ use ty;\n use std::fmt;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n-use syntax::codemap;\n+use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use ty::TyCtxt;\n@@ -943,11 +943,15 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::And, .. }, _, ref r) |\n-            hir::ExprKind::Binary(codemap::Spanned { node: hir::BinOpKind::Or, .. }, _, ref r) => {\n-                // For shortcircuiting operators, mark the RHS as a terminating\n-                // scope since it only executes conditionally.\n-                terminating(r.hir_id.local_id);\n+            hir::ExprKind::Binary(\n+                source_map::Spanned { node: hir::BinOpKind::And, .. },\n+                _, ref r) |\n+            hir::ExprKind::Binary(\n+                source_map::Spanned { node: hir::BinOpKind::Or, .. },\n+                _, ref r) => {\n+                    // For shortcircuiting operators, mark the RHS as a terminating\n+                    // scope since it only executes conditionally.\n+                    terminating(r.hir_id.local_id);\n             }\n \n             hir::ExprKind::If(ref expr, ref then, Some(ref otherwise)) => {\n@@ -1310,7 +1314,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n                owner_id,\n-               self.tcx.sess.codemap().span_to_string(body.value.span),\n+               self.tcx.sess.source_map().span_to_string(body.value.span),\n                body_id,\n                self.cx.parent);\n "}, {"sha": "379f4df11fa7b4881da1c7b488278bb6350b4262", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -2457,7 +2457,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n             self.tcx.hir.node_to_string(lifetime_ref.id),\n             def,\n-            self.tcx.sess.codemap().span_to_string(lifetime_ref.span)\n+            self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );\n         self.map.defs.insert(lifetime_ref.id, def);\n "}, {"sha": "efd568b03ab1f3a200d23a907ba65886a09ed0b2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -685,7 +685,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 let msp: MultiSpan = span.into();\n-                let cm = &self.sess.parse_sess.codemap();\n+                let cm = &self.sess.parse_sess.source_map();\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n                     if !sp.is_dummy() {\n                         let file = cm.lookup_char_pos(sp.lo()).file;"}, {"sha": "d5946786252880a01c3c03a24ad10d7eb9f6aeb7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -22,7 +22,7 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::codemap::{FileName, FilePathMapping};\n+use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n use syntax::parse::token;\n use syntax::parse;"}, {"sha": "78f7de0092dba3e7f3c35702ae79a676baf2ab79", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -35,7 +35,7 @@ use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n-use syntax::{ast, codemap};\n+use syntax::{ast, source_map};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{MultiSpan, Span};\n use util::profiling::SelfProfiler;\n@@ -484,8 +484,8 @@ impl Session {\n         );\n     }\n \n-    pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n-        self.parse_sess.codemap()\n+    pub fn source_map<'a>(&'a self) -> &'a source_map::SourceMap {\n+        self.parse_sess.source_map()\n     }\n     pub fn verbose(&self) -> bool {\n         self.opts.debugging_opts.verbose\n@@ -980,20 +980,20 @@ pub fn build_session(\n ) -> Session {\n     let file_path_mapping = sopts.file_path_mapping();\n \n-    build_session_with_codemap(\n+    build_session_with_source_map(\n         sopts,\n         local_crate_source_file,\n         registry,\n-        Lrc::new(codemap::CodeMap::new(file_path_mapping)),\n+        Lrc::new(source_map::SourceMap::new(file_path_mapping)),\n         None,\n     )\n }\n \n-pub fn build_session_with_codemap(\n+pub fn build_session_with_source_map(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: errors::registry::Registry,\n-    codemap: Lrc<codemap::CodeMap>,\n+    source_map: Lrc<source_map::SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Session {\n     // FIXME: This is not general enough to make the warning lint completely override\n@@ -1020,35 +1020,35 @@ pub fn build_session_with_codemap(\n             (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n                 EmitterWriter::stderr(\n                     color_config,\n-                    Some(codemap.clone()),\n+                    Some(source_map.clone()),\n                     false,\n                     sopts.debugging_opts.teach,\n                 ).ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n-                EmitterWriter::new(dst, Some(codemap.clone()), false, false)\n+                EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n                     .ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::Json(pretty), None) => Box::new(\n                 JsonEmitter::stderr(\n                     Some(registry),\n-                    codemap.clone(),\n+                    source_map.clone(),\n                     pretty,\n                 ).ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n                 JsonEmitter::new(\n                     dst,\n                     Some(registry),\n-                    codemap.clone(),\n+                    source_map.clone(),\n                     pretty,\n                 ).ui_testing(sopts.debugging_opts.ui_testing),\n             ),\n             (config::ErrorOutputType::Short(color_config), None) => Box::new(\n-                EmitterWriter::stderr(color_config, Some(codemap.clone()), true, false),\n+                EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n             ),\n             (config::ErrorOutputType::Short(_), Some(dst)) => {\n-                Box::new(EmitterWriter::new(dst, Some(codemap.clone()), true, false))\n+                Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n             }\n         };\n \n@@ -1063,14 +1063,14 @@ pub fn build_session_with_codemap(\n         },\n     );\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map)\n }\n \n pub fn build_session_(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     span_diagnostic: errors::Handler,\n-    codemap: Lrc<codemap::CodeMap>,\n+    source_map: Lrc<source_map::SourceMap>,\n ) -> Session {\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let host = match Target::search(&host_triple) {\n@@ -1083,7 +1083,7 @@ pub fn build_session_(\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n+    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, source_map);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot()),"}, {"sha": "5d45badf49f8d3b17333f584dedf7c5e21fa470a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -528,12 +528,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                         -> DiagnosticBuilder<'tcx>\n     {\n         let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.codemap().def_span(error_span);\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.codemap().def_span(trait_item_span);\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n@@ -715,7 +715,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n-                        let closure_span = self.tcx.sess.codemap()\n+                        let closure_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.hir.span_if_local(closure_def_id).unwrap());\n                         let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n@@ -792,7 +792,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n-                }).map(|sp| self.tcx.sess.codemap().def_span(sp)); // the sp could be an fn def\n+                }).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n                     ty::TyTuple(ref tys) => tys.iter()\n@@ -867,7 +867,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n-                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                             err.span_suggestion_with_applicability(\n                                 expr.span,\n                                 \"consider borrowing here\",\n@@ -890,7 +890,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let trait_ref = trait_ref.skip_binder();\n         let span = obligation.cause.span;\n \n-        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             let refs_number = snippet.chars()\n                 .filter(|c| !c.is_whitespace())\n                 .take_while(|c| *c == '&')\n@@ -909,7 +909,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                          new_trait_ref.to_predicate());\n \n                     if self.predicate_may_hold(&new_obligation) {\n-                        let sp = self.tcx.sess.codemap()\n+                        let sp = self.tcx.sess.source_map()\n                             .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n \n                         let remove_refs = refs_remaining + 1;\n@@ -938,7 +938,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span), self.tcx.hir.body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(args, _),\n@@ -948,13 +948,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter().map(|pat| {\n-                                    let snippet = self.tcx.sess.codemap()\n+                                    let snippet = self.tcx.sess.source_map()\n                                         .span_to_snippet(pat.span).unwrap();\n                                     (snippet, \"_\".to_owned())\n                                 }).collect::<Vec<_>>(),\n                             )\n                         } else {\n-                            let name = self.tcx.sess.codemap()\n+                            let name = self.tcx.sess.source_map()\n                                 .span_to_snippet(arg.pat.span).unwrap();\n                             ArgKind::Arg(name, \"_\".to_owned())\n                         }\n@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                (self.tcx.sess.source_map().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().node {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n@@ -995,13 +995,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 ..\n             }) => {\n-                (self.tcx.sess.codemap().def_span(span),\n+                (self.tcx.sess.source_map().def_span(span),\n                  fields.iter().map(|field| {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n             hir::map::NodeStructCtor(ref variant_data) => {\n-                (self.tcx.sess.codemap().def_span(self.tcx.hir.span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))\n                     .collect())\n@@ -1192,7 +1192,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         assert!(type_def_id.is_local());\n         let span = self.hir.span_if_local(type_def_id).unwrap();\n-        let span = self.sess.codemap().def_span(span);\n+        let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n                                        self.item_path_str(type_def_id));\n@@ -1210,7 +1210,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                       -> DiagnosticBuilder<'tcx>\n     {\n         let trait_str = self.item_path_str(trait_def_id);\n-        let span = self.sess.codemap().def_span(span);\n+        let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(\n             self.sess, span, E0038,\n             \"the trait `{}` cannot be made into an object\",\n@@ -1438,7 +1438,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n                 if let Some(sp) = tcx.hir.span_if_local(item_def_id) {\n-                    let sp = tcx.sess.codemap().def_span(sp);\n+                    let sp = tcx.sess.source_map().def_span(sp);\n                     err.span_note(sp, &msg);\n                 } else {\n                     err.note(&msg);"}, {"sha": "0ba94b5275cb2e1f90f9ebd5507a52b7e93b7b76", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::CompareImplMethodObligation { .. } |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType => {\n-                tcx.sess.codemap().def_span(self.span)\n+                tcx.sess.source_map().def_span(self.span)\n             }\n             _ => self.span,\n         }"}, {"sha": "56484e17777fe46af755c223ecf258651ecbeab2", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ use infer::at::At;\n use infer::InferOk;\n use rustc_data_structures::small_vec::SmallVec;\n use std::iter::FromIterator;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use ty::subst::Kind;\n use ty::{self, Ty, TyCtxt};\n "}, {"sha": "868b8dfc885439389d083b231c5a044dd4838822", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,7 +10,7 @@\n \n use infer::InferCtxt;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use rustc_data_structures::small_vec::SmallVec;\n use traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n use traits::query::NoSolution;"}, {"sha": "737388ad411017541abb3aff5490b4e9b7de896d", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -15,7 +15,7 @@ use traits::query::Fallible;\n use infer::canonical::query_result;\n use infer::canonical::QueryRegionConstraint;\n use std::rc::Rc;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n use traits::{ObligationCause, TraitEngine, TraitEngineExt};\n \n pub struct CustomTypeOp<F, G> {"}, {"sha": "caebcbec3903e4569dd029aacd8428d11517fb04", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -344,7 +344,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                         }),\n                     if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n                 );\n-                let impl_span = tcx.sess.codemap().def_span(\n+                let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n                 let mut err = if used_to_be_allowed {\n@@ -363,7 +363,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n \n                 match tcx.span_of_impl(overlap.with_impl) {\n                     Ok(span) => {\n-                        err.span_label(tcx.sess.codemap().def_span(span),\n+                        err.span_label(tcx.sess.source_map().def_span(span),\n                                        \"first implementation here\".to_string());\n                         err.span_label(impl_span,\n                                        format!(\"conflicting implementation{}\","}, {"sha": "ef363459108c9b13d2090203224631f430481ec6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -73,7 +73,7 @@ use std::sync::Arc;\n use rustc_target::spec::abi;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n-use syntax::codemap::MultiSpan;\n+use syntax::source_map::MultiSpan;\n use syntax::edition::Edition;\n use syntax::feature_gate;\n use syntax::symbol::{Symbol, keywords, InternedString};\n@@ -1818,7 +1818,7 @@ pub mod tls {\n     /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n-            write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n+            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n         })\n     }\n "}, {"sha": "e23034bde7672ff9d1e5260de0c52feb6744c336", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 match (&values.found.sty, &values.expected.sty) { // Issue #53280\n                     (ty::TyInfer(ty::IntVar(_)), ty::TyFloat(_)) => {\n-                        if let Ok(snippet) = self.sess.codemap().span_to_snippet(sp) {\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n                             if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n                                 db.span_suggestion_with_applicability(\n                                     sp,"}, {"sha": "593470b5d1ecd49f66eb79cdcdc67890da37a06e", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.push_item_path(buffer, parent_def_id);\n         let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n         let item = self.hir.expect_item(node_id);\n-        let span_str = self.sess.codemap().span_to_string(item.span);\n+        let span_str = self.sess.source_map().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }\n "}, {"sha": "6e16d92ba0c8d91ef45e9bf0274530698de2f0af", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -14,7 +14,7 @@ use hir;\n use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n                   RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n-use ich::{CachingCodemapView, Fingerprint};\n+use ich::{CachingSourceMapView, Fingerprint};\n use mir::{self, interpret};\n use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n@@ -26,8 +26,8 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n use session::{CrateDisambiguator, Session};\n use std::mem;\n use syntax::ast::NodeId;\n-use syntax::codemap::{CodeMap, StableFilemapId};\n-use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n+use syntax::source_map::{SourceMap, StableFilemapId};\n+use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -62,11 +62,11 @@ pub struct OnDiskCache<'sess> {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n \n-    codemap: &'sess CodeMap,\n-    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+    source_map: &'sess SourceMap,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableFilemapId>,\n \n     // These two fields caches that are populated lazily during decoding.\n-    file_index_to_file: Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n+    file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n@@ -83,7 +83,7 @@ pub struct OnDiskCache<'sess> {\n // This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Footer {\n-    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableFilemapId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n@@ -96,7 +96,7 @@ type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-struct FileMapIndex(u32);\n+struct SourceFileIndex(u32);\n \n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n struct AbsoluteBytePos(u32);\n@@ -140,7 +140,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_file: Lock::new(FxHashMap()),\n             prev_cnums: footer.prev_cnums,\n             cnum_map: Once::new(),\n-            codemap: sess.codemap(),\n+            source_map: sess.source_map(),\n             current_diagnostics: Lock::new(FxHashMap()),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n@@ -149,14 +149,14 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n+    pub fn new_empty(source_map: &'sess SourceMap) -> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: FxHashMap(),\n             file_index_to_file: Lock::new(FxHashMap()),\n             prev_cnums: vec![],\n             cnum_map: Once::new(),\n-            codemap,\n+            source_map,\n             current_diagnostics: Lock::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n             prev_diagnostics_index: FxHashMap(),\n@@ -173,14 +173,14 @@ impl<'sess> OnDiskCache<'sess> {\n      {\n         // Serializing the DepGraph should not modify it:\n         tcx.dep_graph.with_ignore(|| {\n-            // Allocate FileMapIndices\n+            // Allocate SourceFileIndices\n             let (file_to_file_index, file_index_to_stable_id) = {\n                 let mut file_to_file_index = FxHashMap();\n                 let mut file_index_to_stable_id = FxHashMap();\n \n-                for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n-                    let index = FileMapIndex(index as u32);\n-                    let file_ptr: *const FileMap = &**file as *const _;\n+                for (index, file) in tcx.sess.source_map().files().iter().enumerate() {\n+                    let index = SourceFileIndex(index as u32);\n+                    let file_ptr: *const SourceFile = &**file as *const _;\n                     file_to_file_index.insert(file_ptr, index);\n                     file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n                 }\n@@ -196,7 +196,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 expn_info_shorthands: FxHashMap(),\n                 interpret_allocs: FxHashMap(),\n                 interpret_allocs_inverse: Vec::new(),\n-                codemap: CachingCodemapView::new(tcx.sess.codemap()),\n+                source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n             };\n \n@@ -413,7 +413,7 @@ impl<'sess> OnDiskCache<'sess> {\n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n-            codemap: self.codemap,\n+            source_map: self.source_map,\n             cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n@@ -475,27 +475,27 @@ impl<'sess> OnDiskCache<'sess> {\n struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     opaque: opaque::Decoder<'x>,\n-    codemap: &'x CodeMap,\n+    source_map: &'x SourceMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n     synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n-    file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n+    file_index_to_file: &'x Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n+    file_index_to_stable_id: &'x FxHashMap<SourceFileIndex, StableFilemapId>,\n     alloc_decoding_session: AllocDecodingSession<'x>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn file_index_to_file(&self, index: FileMapIndex) -> Lrc<FileMap> {\n+    fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n             ref file_index_to_file,\n             ref file_index_to_stable_id,\n-            ref codemap,\n+            ref source_map,\n             ..\n         } = *self;\n \n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n-            codemap.filemap_by_stable_id(stable_id)\n-                   .expect(\"Failed to lookup FileMap in new context.\")\n+            source_map.source_file_by_stable_id(stable_id)\n+                   .expect(\"Failed to lookup SourceFile in new context.\")\n         }).clone()\n     }\n }\n@@ -617,7 +617,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n             debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        let file_lo_index = FileMapIndex::decode(self)?;\n+        let file_lo_index = SourceFileIndex::decode(self)?;\n         let line_lo = usize::decode(self)?;\n         let col_lo = BytePos::decode(self)?;\n         let len = BytePos::decode(self)?;\n@@ -770,15 +770,15 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n-    codemap: CachingCodemapView<'tcx>,\n-    file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n+    source_map: CachingSourceMapView<'tcx>,\n+    file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n }\n \n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n-    fn filemap_index(&mut self, filemap: Lrc<FileMap>) -> FileMapIndex {\n-        self.file_to_file_index[&(&*filemap as *const FileMap)]\n+    fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n+        self.file_to_file_index[&(&*source_file as *const SourceFile)]\n     }\n \n     /// Encode something with additional information that allows to do some\n@@ -836,7 +836,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n             return TAG_INVALID_SPAN.encode(self);\n         }\n \n-        let (file_lo, line_lo, col_lo) = match self.codemap\n+        let (file_lo, line_lo, col_lo) = match self.source_map\n                                                    .byte_pos_to_line_and_col(span_data.lo) {\n             Some(pos) => pos,\n             None => {\n@@ -850,10 +850,10 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n \n         let len = span_data.hi - span_data.lo;\n \n-        let filemap_index = self.filemap_index(file_lo);\n+        let source_file_index = self.source_file_index(file_lo);\n \n         TAG_VALID_SPAN.encode(self)?;\n-        filemap_index.encode(self)?;\n+        source_file_index.encode(self)?;\n         line_lo.encode(self)?;\n         col_lo.encode(self)?;\n         len.encode(self)?;"}, {"sha": "bf721ddd13fc6bd7088bec7612e8cdff78c5cc9f", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -32,7 +32,7 @@ use std::mem;\n use std::ptr;\n use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n \n pub struct QueryCache<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n     pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'gcx>| {\n-            self.sess.codemap().def_span(query.default_span(self, span))\n+            self.sess.source_map().def_span(query.default_span(self, span))\n         };\n \n         // Disable naming impls with types in this path, since that\n@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  i,\n                                  query.info.query.name(),\n                                  query.info.query.describe(icx.tcx)));\n-                    db.set_span(icx.tcx.sess.codemap().def_span(query.info.span));\n+                    db.set_span(icx.tcx.sess.source_map().def_span(query.info.span));\n                     icx.tcx.sess.diagnostic().force_print_db(db);\n \n                     current_query = query.parent.clone();"}, {"sha": "da60f41ee680ecbfc628dbd6f2b9180d789a05ba", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -17,7 +17,7 @@ use syntax::{\n         Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n     },\n     attr,\n-    codemap::{\n+    source_map::{\n         respan, ExpnInfo, MacroAttribute,\n     },\n     ext::{"}, {"sha": "dab60ef16613d77971791544a852685671cfb20f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                Some(self.tcx().sess.codemap().end_point(\n+                Some(self.tcx().sess.source_map().end_point(\n                         old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree)));\n \n             let mut err = match (new_loan.kind, old_loan.kind) {"}, {"sha": "e1c3ac839902f0f52faee714205483488815dd21", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -79,7 +79,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n                 // see `get_pattern_source()` for details\n                 let initializer =\n                     e.init.as_ref().expect(\"should have an initializer to get an error\");\n-                if let Ok(snippet) = bccx.tcx.sess.codemap().span_to_snippet(initializer.span) {\n+                if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n                     err.span_suggestion(initializer.span,\n                                         \"consider using a reference instead\",\n                                         format!(\"&{}\", snippet));"}, {"sha": "7208e1ca36299f7e20d9aed5625239ad3a5ab163", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -848,7 +848,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             let sp = self.tcx.hir.span(node_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n-                            match (self.tcx.sess.codemap().span_to_snippet(sp), &err.cmt.cat) {\n+                            match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n                                 (_, &Categorization::Upvar(mc::Upvar {\n                                     kind: ty::ClosureKind::Fn, ..\n                                 })) => {\n@@ -1160,13 +1160,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            let pointee_snippet = match self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+            let pointee_snippet = match self.tcx.sess.source_map().span_to_snippet(ty.span) {\n                 Ok(snippet) => snippet,\n                 _ => return None\n             };\n \n             let lifetime_snippet = if !lifetime.is_elided() {\n-                format!(\"{} \", match self.tcx.sess.codemap().span_to_snippet(lifetime.span) {\n+                format!(\"{} \", match self.tcx.sess.source_map().span_to_snippet(lifetime.span) {\n                     Ok(lifetime_snippet) => lifetime_snippet,\n                     _ => return None\n                 })\n@@ -1277,7 +1277,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             binding_node_id: ast::NodeId) {\n         let let_span = self.tcx.hir.span(binding_node_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n-            if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n                 if is_implicit_self && snippet != \"self\" {\n                     // avoid suggesting `mut &self`.\n@@ -1315,7 +1315,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n \n         let suggestion =\n-            match self.tcx.sess.codemap().span_to_snippet(err.span) {\n+            match self.tcx.sess.source_map().span_to_snippet(err.span) {\n                 Ok(string) => format!(\"move {}\", string),\n                 Err(_) => \"move |<args>| <body>\".to_string()\n             };\n@@ -1337,7 +1337,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                Some(self.tcx.sess.codemap().end_point(\n+                Some(self.tcx.sess.source_map().end_point(\n                         scope.span(self.tcx, &self.region_scope_tree)))\n             }\n             _ => None\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n                     let span = self.tcx.hir.span(local_id);\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n                             db.span_label(*error_span, \"try removing `&mut` here\");"}, {"sha": "c5571ecb97cd9f92bf41d9351061bddc71a2bd22", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n             }\n \n             let (hir_id, span) = ids[0];\n-            let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n \n             // Ok, every name wasn't used mutably, so issue a warning that this\n             // didn't need to be mutable."}, {"sha": "cac2ae0302e3ed72116de1030ef8d9d7409fa103", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -1745,7 +1745,7 @@ pub fn create_global_var_metadata(\n pub fn extend_scope_to_file(\n     cx: &CodegenCx<'ll, '_>,\n     scope_metadata: &'ll DIScope,\n-    file: &syntax_pos::FileMap,\n+    file: &syntax_pos::SourceFile,\n     defining_crate: CrateNum,\n ) -> &'ll DILexicalBlock {\n     let file_metadata = file_metadata(cx, &file.name, defining_crate);"}, {"sha": "c59b5e2b8f5f596937e459aeee42e083c20127db", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -40,7 +40,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", bx.sess().codemap().span_to_string(span));\n+        debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n         let loc = span_start(bx.cx, span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {"}, {"sha": "19bc4ac39d308dcf76e3f00847e110d8f9a5ffe9", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -47,7 +47,7 @@ pub fn create_DIArray(\n \n /// Return syntax_pos::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n-    cx.sess().codemap().lookup_char_pos(span.lo())\n+    cx.sess().source_map().lookup_char_pos(span.lo())\n }\n \n #[inline]"}, {"sha": "1104408c1c8d76f0a4041685f3623d8050a23bb6", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -359,7 +359,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 self.set_debug_loc(&bx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bx.sess().codemap().lookup_char_pos(span.lo());\n+                let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n                 let filename = C_str_slice(bx.cx, filename);\n                 let line = C_u32(bx.cx, loc.line as u32);"}, {"sha": "47fd92682fdc4b8787f13621815cb0c26d8bff30", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -25,7 +25,7 @@ use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use value::Value;\n \n use super::super::callee;"}, {"sha": "d3cb97f65ce264c132abcace628b0d13650e9839", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -166,7 +166,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.cx.sess().codemap();\n+            let cm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n             Some(debuginfo::extend_scope_to_file(self.cx,\n                                             scope_metadata.unwrap(),"}, {"sha": "1c2c0ad73a89751a587904d666bdeead2e19a3df", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -695,7 +695,7 @@ pub fn phase_1_parse_input<'a>(\n     if sess.opts.debugging_opts.input_stats {\n         println!(\n             \"Lines of code:             {}\",\n-            sess.codemap().count_lines()\n+            sess.source_map().count_lines()\n         );\n         println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n@@ -1462,7 +1462,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n     let result = (|| -> io::Result<()> {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n-        let files: Vec<String> = sess.codemap()\n+        let files: Vec<String> = sess.source_map()\n             .files()\n             .iter()\n             .filter(|fmap| fmap.is_real_file())"}, {"sha": "f88c619bf77918454f11db0771c4dc2f7c73de65", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -107,7 +107,7 @@ use std::sync::{Once, ONCE_INIT};\n use std::thread;\n \n use syntax::ast;\n-use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n+use syntax::source_map::{SourceMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n@@ -522,9 +522,9 @@ fn run_compiler_with_pool<'a>(\n     };\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let codemap = Lrc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n-    let mut sess = session::build_session_with_codemap(\n-        sopts, input_file_path.clone(), descriptions, codemap, emitter_dest,\n+    let source_map = Lrc::new(SourceMap::with_file_loader(loader, sopts.file_path_mapping()));\n+    let mut sess = session::build_session_with_source_map(\n+        sopts, input_file_path.clone(), descriptions, source_map, emitter_dest,\n     );\n \n     if let Some(err) = input_err {"}, {"sha": "65cbee821e86443cd31e27e9737b96e99f9061a0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -915,8 +915,8 @@ pub fn fold_crate(sess: &Session, krate: ast::Crate, ppm: PpMode) -> ast::Crate\n \n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n     let src_name = driver::source_name(input);\n-    let src = sess.codemap()\n-        .get_filemap(&src_name)\n+    let src = sess.source_map()\n+        .get_source_file(&src_name)\n         .unwrap()\n         .src\n         .as_ref()\n@@ -954,7 +954,7 @@ pub fn print_after_parsing(sess: &Session,\n         s.call_with_pp_support(sess, None, move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n-                pprust::print_crate(sess.codemap(),\n+                pprust::print_crate(sess.source_map(),\n                                     &sess.parse_sess,\n                                     krate,\n                                     src_name,\n@@ -1011,7 +1011,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                 s.call_with_pp_support(sess, Some(hir_map), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust::print_crate(sess.codemap(),\n+                    pprust::print_crate(sess.source_map(),\n                                         &sess.parse_sess,\n                                         krate,\n                                         src_name,\n@@ -1035,7 +1035,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n-                    pprust_hir::print_crate(sess.codemap(),\n+                    pprust_hir::print_crate(sess.source_map(),\n                                             &sess.parse_sess,\n                                             krate,\n                                             src_name,\n@@ -1076,7 +1076,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n-                    let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n+                    let mut pp_state = pprust_hir::State::new_from_input(sess.source_map(),\n                                                                          &sess.parse_sess,\n                                                                          src_name,\n                                                                          &mut rdr,"}, {"sha": "175422975e006cb43e14adffee121df70e8eaf51", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -32,7 +32,7 @@ use rustc_data_structures::sync::{self, Lrc};\n use syntax;\n use syntax::ast;\n use rustc_target::spec::abi::Abi;\n-use syntax::codemap::{CodeMap, FilePathMapping, FileName};\n+use syntax::source_map::{SourceMap, FilePathMapping, FileName};\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n@@ -121,7 +121,7 @@ fn test_env_with_pool<F>(\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,\n-                                       Lrc::new(CodeMap::new(FilePathMapping::empty())));\n+                                       Lrc::new(SourceMap::new(FilePathMapping::empty())));\n     let cstore = CStore::new(::get_codegen_backend(&sess).metadata_loader());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n@@ -162,7 +162,7 @@ fn test_env_with_pool<F>(\n                              &arenas,\n                              resolutions,\n                              hir_map,\n-                             OnDiskCache::new_empty(sess.codemap()),\n+                             OnDiskCache::new_empty(sess.source_map()),\n                              \"test_crate\",\n                              tx,\n                              &outputs,"}, {"sha": "b4034a6a529bd65313240732ae5f1e93124103f5", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,9 +10,9 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{FileMap, Span, MultiSpan};\n+use syntax_pos::{SourceFile, Span, MultiSpan};\n \n-use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapperDyn, DiagnosticId};\n+use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, SourceMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n@@ -120,21 +120,21 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    cm: Option<Lrc<CodeMapperDyn>>,\n+    cm: Option<Lrc<SourceMapperDyn>>,\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n }\n \n struct FileWithAnnotatedLines {\n-    file: Lrc<FileMap>,\n+    file: Lrc<SourceFile>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n }\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  code_map: Option<Lrc<CodeMapperDyn>>,\n+                  code_map: Option<Lrc<SourceMapperDyn>>,\n                   short_message: bool,\n                   teach: bool)\n                   -> EmitterWriter {\n@@ -149,7 +149,7 @@ impl EmitterWriter {\n     }\n \n     pub fn new(dst: Box<dyn Write + Send>,\n-               code_map: Option<Lrc<CodeMapperDyn>>,\n+               code_map: Option<Lrc<SourceMapperDyn>>,\n                short_message: bool,\n                teach: bool)\n                -> EmitterWriter {\n@@ -177,7 +177,7 @@ impl EmitterWriter {\n \n     fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<FileMap>,\n+                                  file: Lrc<SourceFile>,\n                                   line_index: usize,\n                                   ann: Annotation) {\n \n@@ -307,7 +307,7 @@ impl EmitterWriter {\n \n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n-                          file: Lrc<FileMap>,\n+                          file: Lrc<SourceFile>,\n                           line: &Line,\n                           width_offset: usize,\n                           code_offset: usize) -> Vec<(usize, Style)> {\n@@ -1021,7 +1021,7 @@ impl EmitterWriter {\n         // Print out the annotate source lines that correspond with the error\n         for annotated_file in annotated_files {\n             // we can't annotate anything if the source is unavailable.\n-            if !cm.ensure_filemap_source_present(annotated_file.file.clone()) {\n+            if !cm.ensure_source_file_source_present(annotated_file.file.clone()) {\n                 continue;\n             }\n "}, {"sha": "3582c2359c8b9f653f5ed5d27148f2845e18e801", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -55,7 +55,14 @@ pub mod registry;\n mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos, Loc, FileLinesResult, FileMap, FileName, MultiSpan, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos,\n+                 Loc,\n+                 FileLinesResult,\n+                 SourceFile,\n+                 FileName,\n+                 MultiSpan,\n+                 Span,\n+                 NO_EXPANSION};\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Applicability {\n@@ -111,22 +118,22 @@ pub struct SubstitutionPart {\n     pub snippet: String,\n }\n \n-pub type CodeMapperDyn = dyn CodeMapper + sync::Send + sync::Sync;\n+pub type SourceMapperDyn = dyn SourceMapper + sync::Send + sync::Sync;\n \n-pub trait CodeMapper {\n+pub trait SourceMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n-    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool;\n+    fn ensure_source_file_source_present(&self, file_map: Lrc<SourceFile>) -> bool;\n     fn doctest_offset_line(&self, line: usize) -> usize;\n }\n \n impl CodeSuggestion {\n     /// Returns the assembled code suggestions and whether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &CodeMapperDyn)\n+    pub fn splice_lines(&self, cm: &SourceMapperDyn)\n                         -> Vec<(String, Vec<SubstitutionPart>)> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n@@ -321,7 +328,7 @@ impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n-                            cm: Option<Lrc<CodeMapperDyn>>)\n+                            cm: Option<Lrc<SourceMapperDyn>>)\n                             -> Handler {\n         Handler::with_tty_emitter_and_flags(\n             color_config,\n@@ -334,7 +341,7 @@ impl Handler {\n     }\n \n     pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<CodeMapperDyn>>,\n+                                      cm: Option<Lrc<SourceMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n         let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false));"}, {"sha": "fbc3bf03599fc5eedb21692283bcb26c9c6d2fcb", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -207,11 +207,11 @@ pub fn load_dep_graph(sess: &Session) ->\n pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n     if sess.opts.incremental.is_none() ||\n        !sess.opts.debugging_opts.incremental_queries {\n-        return OnDiskCache::new_empty(sess.codemap());\n+        return OnDiskCache::new_empty(sess.source_map());\n     }\n \n     match load_data(sess.opts.debugging_opts.incremental_info, &query_cache_path(sess)) {\n         LoadResult::Ok{ data: (bytes, start_pos) } => OnDiskCache::new(sess, bytes, start_pos),\n-        _ => OnDiskCache::new_empty(sess.codemap())\n+        _ => OnDiskCache::new_empty(sess.source_map())\n     }\n }"}, {"sha": "0936f28a8fb1e991f4496dfb94d797adfd0df213", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -45,7 +45,7 @@ use rustc::util::nodemap::FxHashSet;\n use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.tcx.sess.codemap().def_span(e.span);\n+                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);\n                         let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);\n                         err.span_suggestion_short_with_applicability(\n                             condition_span,\n@@ -195,7 +195,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));\n-                        let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n+                        let subspan = cx.tcx.sess.source_map().span_through_char(fieldpat.span,\n+                                                                                 ':');\n                         err.span_suggestion_short_with_applicability(\n                             subspan,\n                             \"remove this\",\n@@ -367,7 +368,7 @@ impl MissingDoc {\n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS,\n-                         cx.tcx.sess.codemap().def_span(sp),\n+                         cx.tcx.sess.source_map().def_span(sp),\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -651,7 +652,7 @@ impl EarlyLintPass for AnonymousParameters {\n                             if ident.name == keywords::Invalid.name() {\n                                 let ty_snip = cx\n                                     .sess\n-                                    .codemap()\n+                                    .source_map()\n                                     .span_to_snippet(arg.ty.span);\n \n                                 let (ty_snip, appl) = if let Ok(snip) = ty_snip {\n@@ -958,7 +959,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            let sp = cx.tcx.sess.codemap().def_span(sp);\n+            let sp = cx.tcx.sess.source_map().def_span(sp);\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n                                              sp,\n                                              \"function cannot return without recurring\");\n@@ -1278,7 +1279,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     let mut err = cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n \n                     // account for \"pub const\" (#45562)\n-                    let start = cx.tcx.sess.codemap().span_to_snippet(it.span)\n+                    let start = cx.tcx.sess.source_map().span_to_snippet(it.span)\n                         .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n                         .unwrap_or(0) as u32;\n                     // `const` is 5 chars\n@@ -1440,7 +1441,7 @@ impl UnreachablePub {\n                 if span.ctxt().outer().expn_info().is_some() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n-                let def_span = cx.tcx.sess.codemap().def_span(span);\n+                let def_span = cx.tcx.sess.source_map().def_span(span);\n                 let mut err = cx.struct_span_lint(UNREACHABLE_PUB, def_span,\n                                                   &format!(\"unreachable `pub` {}\", what));\n                 let replacement = if cx.tcx.features().crate_visibility_modifier {"}, {"sha": "46b33255b45a2de8988c0cb6ba1180e37315444c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -25,7 +25,7 @@ use syntax::{ast, attr};\n use syntax::errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::Span;\n-use syntax::codemap;\n+use syntax::source_map;\n \n use rustc::hir;\n \n@@ -208,7 +208,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n-            codemap::respan(binop.span,\n+            source_map::respan(binop.span,\n                             match binop.node {\n                                 hir::BinOpKind::Lt => hir::BinOpKind::Gt,\n                                 hir::BinOpKind::Le => hir::BinOpKind::Ge,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n-            let src = cx.sess().codemap().span_to_snippet(lit.span).ok()?;\n+            let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n             let firstch = src.chars().next()?;\n \n             if firstch == '0' {"}, {"sha": "c242f8d476a71c2bbbf314984b3f08475c244792", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -245,7 +245,7 @@ impl<'a> CrateLoader<'a> {\n             cnum_map,\n             cnum,\n             dependencies: Lock::new(dependencies),\n-            codemap_import_info: RwLock::new(vec![]),\n+            source_map_import_info: RwLock::new(vec![]),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n             source: cstore::CrateSource {"}, {"sha": "aad632f89180dd09e52b5fe963f5b82fcba71b03", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -41,15 +41,15 @@ pub use rustc_data_structures::sync::MetadataRef;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n-/// Holds information about a syntax_pos::FileMap imported from another crate.\n-/// See `imported_filemaps()` for more information.\n-pub struct ImportedFileMap {\n-    /// This FileMap's byte-offset within the codemap of its original crate\n+/// Holds information about a syntax_pos::SourceFile imported from another crate.\n+/// See `imported_source_files()` for more information.\n+pub struct ImportedSourceFile {\n+    /// This SourceFile's byte-offset within the source_map of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n-    /// The end of this FileMap within the codemap of its original crate\n+    /// The end of this SourceFile within the source_map of its original crate\n     pub original_end_pos: syntax_pos::BytePos,\n-    /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Lrc<syntax_pos::FileMap>,\n+    /// The imported SourceFile's representation within the local source_map\n+    pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n pub struct CrateMetadata {\n@@ -64,7 +64,7 @@ pub struct CrateMetadata {\n     pub cnum_map: CrateNumMap,\n     pub cnum: CrateNum,\n     pub dependencies: Lock<Vec<CrateNum>>,\n-    pub codemap_import_info: RwLock<Vec<ImportedFileMap>>,\n+    pub source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n \n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     pub alloc_decoding_state: AllocDecodingState,"}, {"sha": "c51bebd2e3b6373e7f07dd69cab27bee24cf8509", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -38,9 +38,9 @@ use std::sync::Arc;\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap;\n+use syntax::source_map;\n use syntax::edition::Edition;\n-use syntax::parse::filemap_to_stream;\n+use syntax::parse::source_file_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -463,9 +463,9 @@ impl cstore::CStore {\n         let (name, def) = data.get_macro(id.index);\n         let source_name = FileName::Macros(name.to_string());\n \n-        let filemap = sess.parse_sess.codemap().new_filemap(source_name, def.body);\n-        let local_span = Span::new(filemap.start_pos, filemap.end_pos, NO_EXPANSION);\n-        let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n+        let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n+        let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n+        let body = source_file_to_stream(&sess.parse_sess, source_file, None);\n \n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index, sess);\n@@ -487,7 +487,7 @@ impl cstore::CStore {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),\n-            vis: codemap::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+            vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n             tokens: None,\n         })\n     }"}, {"sha": "f4dd8861e2a2ce2c81eb8cc2536443f3c98bd2b4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -39,7 +39,7 @@ use std::u32;\n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n-use syntax::codemap;\n+use syntax::source_map;\n use syntax::symbol::InternedString;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -50,8 +50,8 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     sess: Option<&'a Session>,\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n \n-    // Cache the last used filemap for translating spans as an optimization.\n-    last_filemap_index: usize,\n+    // Cache the last used source_file for translating spans as an optimization.\n+    last_source_file_index: usize,\n \n     lazy_state: LazyState,\n \n@@ -73,7 +73,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             cdata: self.cdata(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx,\n-            last_filemap_index: 0,\n+            last_source_file_index: 0,\n             lazy_state: LazyState::NoNode,\n             alloc_decoding_session: self.cdata().map(|cdata| {\n                 cdata.alloc_decoding_state.new_decoding_session()\n@@ -314,43 +314,45 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n-        let imported_filemaps = self.cdata().imported_filemaps(&sess.codemap());\n-        let filemap = {\n+        let imported_source_files = self.cdata().imported_source_files(&sess.source_map());\n+        let source_file = {\n             // Optimize for the case that most spans within a translated item\n-            // originate from the same filemap.\n-            let last_filemap = &imported_filemaps[self.last_filemap_index];\n+            // originate from the same source_file.\n+            let last_source_file = &imported_source_files[self.last_source_file_index];\n \n-            if lo >= last_filemap.original_start_pos &&\n-               lo <= last_filemap.original_end_pos {\n-                last_filemap\n+            if lo >= last_source_file.original_start_pos &&\n+               lo <= last_source_file.original_end_pos {\n+                last_source_file\n             } else {\n                 let mut a = 0;\n-                let mut b = imported_filemaps.len();\n+                let mut b = imported_source_files.len();\n \n                 while b - a > 1 {\n                     let m = (a + b) / 2;\n-                    if imported_filemaps[m].original_start_pos > lo {\n+                    if imported_source_files[m].original_start_pos > lo {\n                         b = m;\n                     } else {\n                         a = m;\n                     }\n                 }\n \n-                self.last_filemap_index = a;\n-                &imported_filemaps[a]\n+                self.last_source_file_index = a;\n+                &imported_source_files[a]\n             }\n         };\n \n         // Make sure our binary search above is correct.\n-        debug_assert!(lo >= filemap.original_start_pos &&\n-                      lo <= filemap.original_end_pos);\n+        debug_assert!(lo >= source_file.original_start_pos &&\n+                      lo <= source_file.original_end_pos);\n \n         // Make sure we correctly filtered out invalid spans during encoding\n-        debug_assert!(hi >= filemap.original_start_pos &&\n-                      hi <= filemap.original_end_pos);\n+        debug_assert!(hi >= source_file.original_start_pos &&\n+                      hi <= source_file.original_end_pos);\n \n-        let lo = (lo + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n-        let hi = (hi + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n+        let lo = (lo + source_file.translated_source_file.start_pos)\n+                 - source_file.original_start_pos;\n+        let hi = (hi + source_file.translated_source_file.start_pos)\n+                 - source_file.original_start_pos;\n \n         Ok(Span::new(lo, hi, NO_EXPANSION))\n     }\n@@ -1094,52 +1096,52 @@ impl<'a, 'tcx> CrateMetadata {\n         self.def_path_table.def_path_hash(index)\n     }\n \n-    /// Imports the codemap from an external crate into the codemap of the crate\n+    /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n     /// The import algorithm works analogous to how AST items are inlined from an\n     /// external crate's metadata:\n-    /// For every FileMap in the external codemap an 'inline' copy is created in the\n-    /// local codemap. The correspondence relation between external and local\n-    /// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n+    /// For every SourceFile in the external source_map an 'inline' copy is created in the\n+    /// local source_map. The correspondence relation between external and local\n+    /// SourceFiles is recorded in the `ImportedSourceFile` objects returned from this\n     /// function. When an item from an external crate is later inlined into this\n     /// crate, this correspondence information is used to translate the span\n     /// information of the inlined item so that it refers the correct positions in\n-    /// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n+    /// the local source_map (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n     ///\n-    /// The import algorithm in the function below will reuse FileMaps already\n-    /// existing in the local codemap. For example, even if the FileMap of some\n+    /// The import algorithm in the function below will reuse SourceFiles already\n+    /// existing in the local source_map. For example, even if the SourceFile of some\n     /// source file of libstd gets imported many times, there will only ever be\n-    /// one FileMap object for the corresponding file in the local codemap.\n+    /// one SourceFile object for the corresponding file in the local source_map.\n     ///\n-    /// Note that imported FileMaps do not actually contain the source code of the\n+    /// Note that imported SourceFiles do not actually contain the source code of the\n     /// file they represent, just information about length, line breaks, and\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n-    pub fn imported_filemaps(&'a self,\n-                             local_codemap: &codemap::CodeMap)\n-                             -> ReadGuard<'a, Vec<cstore::ImportedFileMap>> {\n+    pub fn imported_source_files(&'a self,\n+                             local_source_map: &source_map::SourceMap)\n+                             -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n-            let filemaps = self.codemap_import_info.borrow();\n-            if !filemaps.is_empty() {\n-                return filemaps;\n+            let source_files = self.source_map_import_info.borrow();\n+            if !source_files.is_empty() {\n+                return source_files;\n             }\n         }\n \n-        // Lock the codemap_import_info to ensure this only happens once\n-        let mut codemap_import_info = self.codemap_import_info.borrow_mut();\n+        // Lock the source_map_import_info to ensure this only happens once\n+        let mut source_map_import_info = self.source_map_import_info.borrow_mut();\n \n-        if !codemap_import_info.is_empty() {\n-            drop(codemap_import_info);\n-            return self.codemap_import_info.borrow();\n+        if !source_map_import_info.is_empty() {\n+            drop(source_map_import_info);\n+            return self.source_map_import_info.borrow();\n         }\n \n-        let external_codemap = self.root.codemap.decode(self);\n+        let external_source_map = self.root.source_map.decode(self);\n \n-        let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-            // We can't reuse an existing FileMap, so allocate a new one\n+        let imported_source_files = external_source_map.map(|source_file_to_import| {\n+            // We can't reuse an existing SourceFile, so allocate a new one\n             // containing the information we need.\n-            let syntax_pos::FileMap { name,\n+            let syntax_pos::SourceFile { name,\n                                       name_was_remapped,\n                                       src_hash,\n                                       start_pos,\n@@ -1148,15 +1150,15 @@ impl<'a, 'tcx> CrateMetadata {\n                                       mut multibyte_chars,\n                                       mut non_narrow_chars,\n                                       name_hash,\n-                                      .. } = filemap_to_import;\n+                                      .. } = source_file_to_import;\n \n             let source_length = (end_pos - start_pos).to_usize();\n \n             // Translate line-start positions and multibyte character\n             // position into frame of reference local to file.\n-            // `CodeMap::new_imported_filemap()` will then translate those\n+            // `SourceMap::new_imported_source_file()` will then translate those\n             // coordinates to their new global frame of reference when the\n-            // offset of the FileMap is known.\n+            // offset of the SourceFile is known.\n             for pos in &mut lines {\n                 *pos = *pos - start_pos;\n             }\n@@ -1167,7 +1169,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 *swc = *swc - start_pos;\n             }\n \n-            let local_version = local_codemap.new_imported_filemap(name,\n+            let local_version = local_source_map.new_imported_source_file(name,\n                                                                    name_was_remapped,\n                                                                    self.cnum.as_u32(),\n                                                                    src_hash,\n@@ -1176,23 +1178,23 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    lines,\n                                                                    multibyte_chars,\n                                                                    non_narrow_chars);\n-            debug!(\"CrateMetaData::imported_filemaps alloc \\\n-                    filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n+            debug!(\"CrateMetaData::imported_source_files alloc \\\n+                    source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                     translated (start_pos {:?} end_pos {:?})\",\n                    local_version.name, start_pos, end_pos,\n                    local_version.start_pos, local_version.end_pos);\n \n-            cstore::ImportedFileMap {\n+            cstore::ImportedSourceFile {\n                 original_start_pos: start_pos,\n                 original_end_pos: end_pos,\n-                translated_filemap: local_version,\n+                translated_source_file: local_version,\n             }\n         }).collect();\n \n-        *codemap_import_info = imported_filemaps;\n-        drop(codemap_import_info);\n+        *source_map_import_info = imported_source_files;\n+        drop(source_map_import_info);\n \n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n-        self.codemap_import_info.borrow()\n+        self.source_map_import_info.borrow()\n     }\n }"}, {"sha": "4b5c9d68fd7f2e018bd188868ef8e2a18670f96f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -40,9 +40,9 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::symbol::keywords;\n-use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n+use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -62,7 +62,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n-    filemap_cache: Lrc<FileMap>,\n+    source_file_cache: Lrc<SourceFile>,\n }\n \n macro_rules! encoder_methods {\n@@ -157,13 +157,13 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // The Span infrastructure should make sure that this invariant holds:\n         debug_assert!(span.lo <= span.hi);\n \n-        if !self.filemap_cache.contains(span.lo) {\n-            let codemap = self.tcx.sess.codemap();\n-            let filemap_index = codemap.lookup_filemap_idx(span.lo);\n-            self.filemap_cache = codemap.files()[filemap_index].clone();\n+        if !self.source_file_cache.contains(span.lo) {\n+            let source_map = self.tcx.sess.source_map();\n+            let source_file_index = source_map.lookup_source_file_idx(span.lo);\n+            self.source_file_cache = source_map.files()[source_file_index].clone();\n         }\n \n-        if !self.filemap_cache.contains(span.hi) {\n+        if !self.source_file_cache.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n             return TAG_INVALID_SPAN.encode(self)\n@@ -337,36 +337,36 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n-        let codemap = self.tcx.sess.codemap();\n-        let all_filemaps = codemap.files();\n+    fn encode_source_map(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n+        let source_map = self.tcx.sess.source_map();\n+        let all_source_files = source_map.files();\n \n         let (working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir.clone();\n \n-        let adapted = all_filemaps.iter()\n-            .filter(|filemap| {\n-                // No need to re-export imported filemaps, as any downstream\n+        let adapted = all_source_files.iter()\n+            .filter(|source_file| {\n+                // No need to re-export imported source_files, as any downstream\n                 // crate will import them from their original source.\n-                !filemap.is_imported()\n+                !source_file.is_imported()\n             })\n-            .map(|filemap| {\n-                // When exporting FileMaps, we expand all paths to absolute\n+            .map(|source_file| {\n+                // When exporting SourceFiles, we expand all paths to absolute\n                 // paths because any relative paths are potentially relative to\n                 // a wrong directory.\n                 // However, if a path has been modified via\n                 // `--remap-path-prefix` we assume the user has already set\n                 // things up the way they want and don't touch the path values\n                 // anymore.\n-                match filemap.name {\n+                match source_file.name {\n                     FileName::Real(ref name) => {\n-                        if filemap.name_was_remapped ||\n+                        if source_file.name_was_remapped ||\n                         (name.is_relative() && working_dir_was_remapped) {\n-                            // This path of this FileMap has been modified by\n+                            // This path of this SourceFile has been modified by\n                             // path-remapping, so we use it verbatim (and avoid cloning\n                             // the whole map in the process).\n-                            filemap.clone()\n+                            source_file.clone()\n                         } else {\n-                            let mut adapted = (**filemap).clone();\n+                            let mut adapted = (**source_file).clone();\n                             adapted.name = Path::new(&working_dir).join(name).into();\n                             adapted.name_hash = {\n                                 let mut hasher: StableHasher<u128> = StableHasher::new();\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         }\n                     },\n                     // expanded code, not from a file\n-                    _ => filemap.clone(),\n+                    _ => source_file.clone(),\n                 }\n             })\n             .collect::<Vec<_>>();\n@@ -418,10 +418,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             IsolatedEncoder::encode_foreign_modules,\n             ());\n \n-        // Encode codemap\n+        // Encode source_map\n         i = self.position();\n-        let codemap = self.encode_codemap();\n-        let codemap_bytes = self.position() - i;\n+        let source_map = self.encode_source_map();\n+        let source_map_bytes = self.position() - i;\n \n         // Encode DefPathTable\n         i = self.position();\n@@ -523,7 +523,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing,\n             native_libraries,\n             foreign_modules,\n-            codemap,\n+            source_map,\n             def_path_table,\n             impls,\n             exported_symbols,\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"     lib feature bytes: {}\", lib_feature_bytes);\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n-            println!(\"         codemap bytes: {}\", codemap_bytes);\n+            println!(\"         source_map bytes: {}\", source_map_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n@@ -1842,7 +1842,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n-            filemap_cache: tcx.sess.codemap().files()[0].clone(),\n+            source_file_cache: tcx.sess.source_map().files()[0].clone(),\n             interpret_allocs: Default::default(),\n             interpret_allocs_inverse: Default::default(),\n         };"}, {"sha": "70eda895bd0a24029d9439d52fb14ac7978392b5", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FxHashSet;\n use rustc_target::spec::abi::Abi;\n use syntax::attr;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::Symbol;\n "}, {"sha": "8e454ddc0adc4589be929da3c4e09af60e110c44", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -204,7 +204,7 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub foreign_modules: LazySeq<ForeignModule>,\n-    pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub source_map: LazySeq<syntax_pos::SourceFile>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: EncodedExportedSymbols,"}, {"sha": "82d3d31a52eb3b33e82a986e62e865f3469dabca", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -316,7 +316,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             }\n \n             let span = local_decl.source_info.span;\n-            let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n \n             let mut err = tcx.struct_span_lint_node(\n                 UNUSED_MUT,\n@@ -1509,7 +1509,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n-            let span = self.tcx.sess.codemap().end_point(span);\n+            let span = self.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n                 context,\n                 borrow,"}, {"sha": "5ef647585c38e8d00871e77403a48beb59a47f38", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.tcx.sess.codemap().span_to_snippet(span).unwrap();\n+        let snippet = self.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n@@ -394,7 +394,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }))\n             ) = bind_to.is_user_variable {\n                 let pat_snippet = self\n-                    .tcx.sess.codemap()\n+                    .tcx.sess.source_map()\n                     .span_to_snippet(pat_span)\n                     .unwrap();\n                 if pat_snippet.starts_with('&') {"}, {"sha": "05d6f49d97c6cce3177d6545e4da9a4bee82cc10", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             Place::Local(_)\n                 if {\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n                     } else {\n                         false\n@@ -406,7 +406,7 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n-    (sp, match tcx.sess.codemap().span_to_snippet(sp) {\n+    (sp, match tcx.sess.source_map().span_to_snippet(sp) {\n         Ok(snippet) => {\n             let lt_pos = snippet.find('\\'');\n             if let Some(lt_pos) = lt_pos {\n@@ -444,7 +444,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     let locations = mir.find_assignments(local);\n     if locations.len() > 0 {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n-        if let Ok(src) = tcx.sess.codemap().span_to_snippet(assignment_rhs_span) {\n+        if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n                 src.starts_with(\"&'\"),\n                 src.find(|c: char| -> bool { c.is_whitespace() }),\n@@ -469,7 +469,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n         None => local_decl.source_info.span,\n     };\n \n-    if let Ok(src) = tcx.sess.codemap().span_to_snippet(highlight_span) {\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span) {\n         if let (true, Some(ws_pos)) = (\n             src.starts_with(\"&'\"),\n             src.find(|c: char| -> bool { c.is_whitespace() }),"}, {"sha": "532c36f427b5a1ad62c79607b4b2eadc4e44f75a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -189,7 +189,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         name: &InternedString,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n-        let cm = tcx.sess.codemap();\n+        let cm = tcx.sess.source_map();\n \n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n@@ -383,8 +383,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let region_name = self.synthesize_region_name(counter);\n \n                         // Just grab the first character, the `&`.\n-                        let codemap = tcx.sess.codemap();\n-                        let ampersand_span = codemap.start_point(hir_ty.span);\n+                        let source_map = tcx.sess.source_map();\n+                        let ampersand_span = source_map.start_point(hir_ty.span);\n \n                         diag.span_label(\n                             ampersand_span,\n@@ -593,7 +593,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             = tcx.hir.expect_expr(mir_node_id).node\n         {\n             (\n-                tcx.sess.codemap().end_point(span),\n+                tcx.sess.source_map().end_point(span),\n                 if gen_move.is_some() { \" of generator\" } else { \" of closure\" }\n             )\n         } else {"}, {"sha": "57ff0f4c10a4b3bf1a36f08ee64a270f606d5fe5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,7 +13,7 @@ use borrow_check::nll::ToRegionVid;\n use rustc::mir::{Local, Mir};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax_pos::symbol::Symbol;\n \n impl<'tcx> RegionInferenceContext<'tcx> {"}, {"sha": "8e99a45c87fdc3393012f58821aeeb0d51a86af9", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let region_scope_span = region_scope.span(self.hir.tcx(),\n                                                           &self.hir.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n-                let scope_end = self.hir.tcx().sess.codemap().end_point(region_scope_span);\n+                let scope_end = self.hir.tcx().sess.source_map().end_point(region_scope_span);\n \n                 scope.drops.push(DropData {\n                     span: scope_end,"}, {"sha": "dd298d9becbedbab82dd76c60c7c5c32c8629b29", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,8 +10,8 @@ use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n use syntax::ast::Mutability;\n-use syntax::codemap::Span;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::Span;\n+use syntax::source_map::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,"}, {"sha": "3329a47759beae867f48b12c0f85132d82a14e75", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::interpret::{\n     ScalarMaybeUndef,\n };\n \n-use syntax::codemap::{self, Span};\n+use syntax::source_map::{self, Span};\n use syntax::ast::Mutability;\n \n use super::{Place, PlaceExtra, Memory,\n@@ -91,7 +91,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub instance: ty::Instance<'tcx>,\n \n     /// The span of the call site.\n-    pub span: codemap::Span,\n+    pub span: source_map::Span,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n@@ -545,7 +545,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn push_stack_frame(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        span: codemap::Span,\n+        span: source_map::Span,\n         mir: &'mir mir::Mir<'tcx>,\n         return_place: Place,\n         return_to_block: StackPopCleanup,"}, {"sha": "112d8759c6832b1b48f979829b109a9b400884d7", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,7 +10,7 @@ use super::{EvalContext, Place, ValTy, Memory};\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::Size;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax::ast::Mutability;\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail"}, {"sha": "f86c0e89954d20669df1a0461b0acec8a7f7efcd", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir::BasicBlock;\n use rustc::ty::{self, Ty};\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n \n use rustc::mir::interpret::{EvalResult, Value};\n use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};"}, {"sha": "3a772559d6de42ce4559891edd6d3f20987aebf2", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -1,7 +1,7 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{LayoutOf, Size};\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, Scalar, Value};"}, {"sha": "f73c9d43699fcf86aa41e183fc82fc9c03340d7b", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -26,7 +26,7 @@ use std::fmt::{self, Write};\n use std::iter;\n use rustc::mir::mono::Linkage;\n use syntax_pos::symbol::Symbol;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n pub use rustc::mir::mono::MonoItem;\n \n /// Describes how a monomorphization will be instantiated in object files."}, {"sha": "80e484d5957140e2d311e256d03e0516f84487b3", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -424,12 +424,12 @@ fn is_enclosed(tcx: TyCtxt,\n }\n \n fn report_unused_unsafe(tcx: TyCtxt, used_unsafe: &FxHashSet<ast::NodeId>, id: ast::NodeId) {\n-    let span = tcx.sess.codemap().def_span(tcx.hir.span(id));\n+    let span = tcx.sess.source_map().def_span(tcx.hir.span(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_node(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.codemap().def_span(tcx.hir.span(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir.span(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();"}, {"sha": "47c45adb85f5af9e969bad255a0839bed0f7b55e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use interpret::EvalContext;\n use interpret::CompileTimeEvaluator;\n use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n use transform::{MirPass, MirSource};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::ParamEnv;"}, {"sha": "1e624081bcfb559775090617eaf77b2945c7b20a", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -33,7 +33,7 @@ pub fn suggest_ref_mut<'cx, 'gcx, 'tcx>(\n     tcx: ty::TyCtxt<'cx, 'gcx, 'tcx>,\n     binding_span: Span,\n ) -> Option<(String)> {\n-    let hi_src = tcx.sess.codemap().span_to_snippet(binding_span).unwrap();\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n     {"}, {"sha": "df975998edcf8f6b400e898d3e1be8b377d0bc15", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -441,7 +441,7 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\",\n         scope.index(),\n-        tcx.sess.codemap().span_to_string(span)\n+        tcx.sess.source_map().span_to_string(span)\n     )\n }\n "}, {"sha": "99ea62e80298ca06f32d80598c5fb3a62622cb91", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -20,7 +20,7 @@ use rustc::lint;\n use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;"}, {"sha": "de9481579e2f429a5c6625eb9b1ff3a87add293e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -175,7 +175,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n             .filter_map(|s| {\n-                match visitor.session.codemap().span_to_snippet(*s) {\n+                match visitor.session.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 }"}, {"sha": "282589c4e68cf4c6462b5ab6a24a9467a83c0b1a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -49,7 +49,7 @@ use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::codemap::CodeMap;\n+use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -195,7 +195,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            \"can't use type parameters from outer function\");\n             err.span_label(span, \"use of type variable from outer function\");\n \n-            let cm = resolver.session.codemap();\n+            let cm = resolver.session.source_map();\n             match outer_def {\n                 Def::SelfTy(_, maybe_impl_defid) => {\n                     if let Some(impl_span) = maybe_impl_defid.map_or(None,\n@@ -414,8 +414,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n ///\n /// Attention: The method used is very fragile since it essentially duplicates the work of the\n /// parser. If you need to use this function or something similar, please consider updating the\n-/// codemap functions and this function to something more robust.\n-fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n+/// source_map functions and this function to something more robust.\n+fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n     let impl_span = cm.span_until_char(impl_span, '<');\n     let impl_span = cm.span_until_whitespace(impl_span);\n     impl_span\n@@ -3085,7 +3085,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             // parser issue where a struct literal is being used on an expression\n                             // where a brace being opened means a block is being started. Look\n                             // ahead for the next text to see if `span` is followed by a `{`.\n-                            let cm = this.session.codemap();\n+                            let cm = this.session.source_map();\n                             let mut sp = span;\n                             loop {\n                                 sp = cm.next_point(sp);\n@@ -3212,7 +3212,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                   err: &mut DiagnosticBuilder,\n                                   base_span: Span) {\n         debug!(\"type_ascription_suggetion {:?}\", base_span);\n-        let cm = self.session.codemap();\n+        let cm = self.session.source_map();\n         debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n         if let Some(sp) = self.current_type_ascription.last() {\n             let mut sp = *sp;\n@@ -4527,7 +4527,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             false => \"defined\",\n         };\n \n-        let (name, span) = (ident.name, self.session.codemap().def_span(new_binding.span));\n+        let (name, span) = (ident.name, self.session.source_map().def_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -4566,7 +4566,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         if !old_binding.span.is_dummy() {\n-            err.span_label(self.session.codemap().def_span(old_binding.span),\n+            err.span_label(self.session.source_map().def_span(old_binding.span),\n                            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name));\n         }\n \n@@ -4578,7 +4578,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 old_binding\n             };\n \n-            let cm = self.session.codemap();\n+            let cm = self.session.source_map();\n             let rename_msg = \"You can use `as` to change the binding name of the import\";\n \n             if let (Ok(snippet), false) = (cm.span_to_snippet(binding.span),"}, {"sha": "58390c228869964e8049fa0262ee0b313e7a4239", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -1205,8 +1205,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             let enum_span = enum_resolution.borrow()\n                                 .binding.expect(\"binding should exist\")\n                                 .span;\n-                            let enum_def_span = self.session.codemap().def_span(enum_span);\n-                            let enum_def_snippet = self.session.codemap()\n+                            let enum_def_span = self.session.source_map().def_span(enum_span);\n+                            let enum_def_snippet = self.session.source_map()\n                                 .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                             // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                             let after_vis_index = enum_def_snippet.find(\"enum\")"}, {"sha": "c6cec2ecca674292ed6ba3389978ff97e4b33850", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -41,7 +41,7 @@ use syntax::print::pprust::{\n     ty_to_string\n };\n use syntax::ptr::P;\n-use syntax::codemap::{Spanned, DUMMY_SP, respan};\n+use syntax::source_map::{Spanned, DUMMY_SP, respan};\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n@@ -1368,7 +1368,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n-        let cm = self.tcx.sess.codemap();\n+        let cm = self.tcx.sess.source_map();\n         let filename = cm.span_to_filename(span);\n         let data_id = ::id_from_node_id(id, &self.save_ctxt);\n         let children = m.items"}, {"sha": "b2d78850cbab9f2de9d720156f69a8afe0c6294e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -56,14 +56,14 @@ use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, Attribute, NodeId, PatKind};\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n-use syntax::codemap::MacroAttribute;\n+use syntax::source_map::MacroAttribute;\n use syntax_pos::*;\n \n use json_dumper::JsonDumper;\n@@ -95,7 +95,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n-        let cm = self.tcx.sess.codemap();\n+        let cm = self.tcx.sess.source_map();\n         let start = cm.lookup_char_pos(span.lo());\n         let end = cm.lookup_char_pos(span.hi());\n \n@@ -122,7 +122,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     continue;\n                 }\n             };\n-            let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n+            let lo_loc = self.span_utils.sess.source_map().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n                 // FIXME: change file_name field to PathBuf in rls-data\n                 // https://github.com/nrc/rls-data/issues/7\n@@ -268,7 +268,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Mod(ref m) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-                let cm = self.tcx.sess.codemap();\n+                let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n \n                 let sub_span = self.span_utils"}, {"sha": "e1a3829cd75388cabb18002acecdb57fee585f6a", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -47,7 +47,7 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     pub fn snippet(&self, span: Span) -> String {\n-        match self.sess.codemap().span_to_snippet(span) {\n+        match self.sess.source_map().span_to_snippet(span) {\n             Ok(s) => s,\n             Err(_) => String::new(),\n         }\n@@ -151,7 +151,7 @@ impl<'a> SpanUtils<'a> {\n         }\n         #[cfg(debug_assertions)] {\n             if angle_count != 0 || bracket_count != 0 {\n-                let loc = self.sess.codemap().lookup_char_pos(span.lo());\n+                let loc = self.sess.source_map().lookup_char_pos(span.lo());\n                 span_bug!(\n                     span,\n                     \"Mis-counted brackets when breaking path? Parsing '{}' \\\n@@ -276,9 +276,9 @@ impl<'a> SpanUtils<'a> {\n             None => return true,\n         };\n \n-        //If the span comes from a fake filemap, filter it.\n+        //If the span comes from a fake source_file, filter it.\n         if !self.sess\n-            .codemap()\n+            .source_map()\n             .lookup_char_pos(parent.lo())\n             .file\n             .is_real_file()"}, {"sha": "8bffecfc7c90110b82c14d2e1bab30ea273686d2", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::source_map::{Span, DUMMY_SP};\n \n crate fn provide(p: &mut Providers) {\n     *p = Providers {"}, {"sha": "b5ee346569a694ec2e73c22f92b46e19d11f1df3", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,7 +13,7 @@ use rustc::traits::{EvaluationResult, Obligation, ObligationCause,\n use rustc::traits::query::CanonicalPredicateGoal;\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n \n crate fn provide(p: &mut Providers) {\n     *p = Providers {"}, {"sha": "7b31518c07b18fe411d9202f0aca07e31651d2d8", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::wf;\n use syntax::ast::DUMMY_NODE_ID;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n use rustc::traits::FulfillmentContext;\n \n use rustc_data_structures::sync::Lrc;"}, {"sha": "c14a07b7cf5d0b0d417be78e23f80f3d2ca381e2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -22,7 +22,7 @@ use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n use syntax::ast;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -350,7 +350,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             if let Some(mut err) = err {\n                                 if is_arg {\n                                     if let PatKind::Binding(..) = inner.node {\n-                                        if let Ok(snippet) = tcx.sess.codemap()\n+                                        if let Ok(snippet) = tcx.sess.source_map()\n                                                                      .span_to_snippet(pat.span)\n                                         {\n                                             err.help(&format!(\"did you mean `{}: &{}`?\","}, {"sha": "29d2fe2c7b63eaf93fe11b5d0b55306d805c89a2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n-                if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n+                if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n                     err.span_help(self.expr.span,\n                                    &format!(\"did you mean `*{}`?\", snippet));\n                 }\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     hir::MutImmutable => \"\",\n                 };\n                 if self.cast_ty.is_trait() {\n-                    match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n+                    match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n                             err.span_suggestion(self.cast_span,\n                                                 \"try casting to a reference instead\",\n@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 }\n             }\n             ty::TyAdt(def, ..) if def.is_box() => {\n-                match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n+                match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n                                             \"try casting to a `Box` instead\","}, {"sha": "242b69294a5bcf8797062c7384da00e2b610891f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::subst::Substs;\n use std::cmp;\n use std::iter;\n use rustc_target::spec::abi::Abi;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use rustc::hir;\n \n /// What signature do we *expect* the closure to have from context?"}, {"sha": "9aa2ba363ed7ab41870188de93b2d8bf101ab303", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -40,7 +40,7 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let impl_m_span = tcx.sess.codemap().def_span(impl_m_span);\n+    let impl_m_span = tcx.sess.source_map().def_span(impl_m_span);\n \n     if let Err(ErrorReported) = compare_self_type(tcx,\n                                                   impl_m,\n@@ -319,7 +319,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_m.ident);\n             if let TypeError::Mutability = terr {\n                 if let Some(trait_err_span) = trait_err_span {\n-                    if let Ok(trait_err_str) = tcx.sess.codemap().span_to_snippet(trait_err_span) {\n+                    if let Ok(trait_err_str) = tcx.sess.source_map().\n+                                               span_to_snippet(trait_err_span) {\n                         diag.span_suggestion(\n                             impl_err_span,\n                             \"consider change the type to match the mutability in trait\",\n@@ -386,7 +387,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n-        let def_span = tcx.sess.codemap().def_span(span);\n+        let def_span = tcx.sess.source_map().def_span(span);\n         let span = tcx.hir.get_generics_span(impl_m.def_id).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -397,7 +398,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         );\n         err.span_label(span, \"lifetimes do not match method in trait\");\n         if let Some(sp) = tcx.hir.span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.codemap().def_span(sp);\n+            let def_sp = tcx.sess.source_map().def_span(sp);\n             let sp = tcx.hir.get_generics_span(trait_m.def_id).unwrap_or(def_sp);\n             err.span_label(sp, \"lifetimes in impl do not match this method in trait\");\n         }\n@@ -770,7 +771,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // as another generic argument\n                         let new_name = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(trait_span)\n                             .ok()?;\n                         let trait_m = tcx.hir.as_local_node_id(trait_m.def_id)?;\n@@ -783,7 +784,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // and the opening paren of the argument list\n                         let new_generics_span = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .generate_fn_name_span(impl_span)?\n                             .shrink_to_hi();\n                         // in case there are generics, just replace them\n@@ -794,7 +795,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // replace with the generics from the trait\n                         let new_generics = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(trait_m.generics.span)\n                             .ok()?;\n \n@@ -865,7 +866,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx\n                             .sess\n-                            .codemap()\n+                            .source_map()\n                             .span_to_snippet(bounds)\n                             .ok()?;\n "}, {"sha": "00cc36ecd428c8863d9b156104ad215e38a328ec", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::map::{NodeItem, NodeExpr};\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n-use errors::{DiagnosticBuilder, CodeMapper};\n+use errors::{DiagnosticBuilder, SourceMapper};\n \n use super::method::probe;\n \n@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  checked_ty: Ty<'tcx>,\n                  expected: Ty<'tcx>)\n                  -> Option<(Span, &'static str, String)> {\n-        let cm = self.sess().codemap();\n+        let cm = self.sess().source_map();\n         // Use the callsite's span if this is a macro call. #41858\n         let sp = cm.call_span_if_macro(expr.span);\n         if !cm.span_to_filename(sp).is_real() {\n@@ -405,7 +405,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let needs_paren = expr.precedence().order() < (PREC_POSTFIX as i8);\n \n-        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n             let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n             let cast_suggestion = format!(\"{}{}{} as {}\",\n                                           if needs_paren { \"(\" } else { \"\" },"}, {"sha": "31ec62ba70a956478917afc6d7ad410e66eb0562", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -132,7 +132,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         };\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n-                            err.span_note(self.tcx.sess.codemap().def_span(note_span), &note_str);\n+                            err.span_note(self.tcx.sess.source_map().def_span(note_span),\n+                                          &note_str);\n                         } else {\n                             err.note(&note_str);\n                         }\n@@ -141,7 +142,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let item = self\n                             .associated_item(trait_did, item_name, Namespace::Value)\n                             .unwrap();\n-                        let item_span = self.tcx.sess.codemap()\n+                        let item_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.def_span(item.def_id));\n                         if sources.len() > 1 {\n                             span_note!(err,\n@@ -246,7 +247,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         };\n                         match expr.node {\n                             hir::ExprKind::Lit(ref lit) => {  // numeric literal\n-                                let snippet = tcx.sess.codemap().span_to_snippet(lit.span)\n+                                let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or(\"<numeric literal>\".to_string());\n \n                                 err.span_suggestion(lit.span,\n@@ -261,9 +262,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir.span(node_id);\n-                                        let snippet = tcx.sess.codemap().span_to_snippet(span)\n+                                        let snippet = tcx.sess.source_map().span_to_snippet(span)\n                                             .unwrap();\n-                                        let filename = tcx.sess.codemap().span_to_filename(span);\n+                                        let filename = tcx.sess.source_map().span_to_filename(span);\n \n                                         let parent_node = self.tcx.hir.get(\n                                             self.tcx.hir.get_parent_node(node_id),\n@@ -320,7 +321,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some(def) = actual.ty_adt_def() {\n                     if let Some(full_sp) = tcx.hir.span_if_local(def.did) {\n-                        let def_sp = tcx.sess.codemap().def_span(full_sp);\n+                        let def_sp = tcx.sess.source_map().def_span(full_sp);\n                         err.span_label(def_sp, format!(\"{} `{}` not found {}\",\n                                                        item_kind,\n                                                        item_name,\n@@ -341,7 +342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n-                                    let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n+                                    let snippet = tcx.sess.source_map().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,\n                                         _ => \"s\".into(), // Default to a generic placeholder for the\n@@ -387,7 +388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     if let Some(expr) = rcvr_expr {\n-                        if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n                         } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n                             expr.node"}, {"sha": "b57967a7aab211bf8ed5fddc8f59790b21bcfe6a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -122,7 +122,7 @@ use std::ops::{self, Deref};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::original_sp;\n+use syntax::source_map::original_sp;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, LocalInternedString, keywords};\n@@ -1447,7 +1447,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n                                             impl_item_refs: &[hir::ImplItemRef]) {\n-    let impl_span = tcx.sess.codemap().def_span(impl_span);\n+    let impl_span = tcx.sess.source_map().def_span(impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -2668,11 +2668,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if arg_count == 1 {\" was\"} else {\"s were\"}),\n                 DiagnosticId::Error(error_code.to_owned()));\n \n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.codemap().def_span(sp)) {\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n-                let sugg_span = tcx.sess.codemap().end_point(expr_sp);\n+                let sugg_span = tcx.sess.source_map().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -2937,8 +2937,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n                     let msg = \"try comparing for equality\";\n                     if let (Ok(left), Ok(right)) = (\n-                        self.tcx.sess.codemap().span_to_snippet(lhs.span),\n-                        self.tcx.sess.codemap().span_to_snippet(rhs.span))\n+                        self.tcx.sess.source_map().span_to_snippet(lhs.span),\n+                        self.tcx.sess.source_map().span_to_snippet(rhs.span))\n                     {\n                         err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n                     } else {\n@@ -4232,7 +4232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 if let hir::ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n-                                        let snip = tcx.sess.codemap().span_to_snippet(base.span);\n+                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n                                         if let Ok(snip) = snip {\n                                             err.span_suggestion(expr.span,\n                                                                 \"to access tuple elements, use\",\n@@ -4629,7 +4629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             err.span_suggestion(sp, msg, suggestion);\n         } else if !self.check_for_cast(err, expr, found, expected) {\n             let methods = self.get_conversion_methods(expr.span, expected, found);\n-            if let Ok(expr_text) = self.sess().codemap().span_to_snippet(expr.span) {\n+            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n                     .filter_map(|(receiver, method)| {\n                         let method_call = format!(\".{}()\", method.ident);\n@@ -4673,7 +4673,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::ExprKind::Loop(..) |\n                 hir::ExprKind::Match(..) |\n                 hir::ExprKind::Block(..) => {\n-                    let sp = self.tcx.sess.codemap().next_point(cause_span);\n+                    let sp = self.tcx.sess.source_map().next_point(cause_span);\n                     err.span_suggestion(sp,\n                                         \"try adding a semicolon\",\n                                         \";\".to_string());"}, {"sha": "de211d2209c9a085961f5a1f0592863b1ad7a4e7", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n-                    let codemap = self.tcx.sess.codemap();\n+                    let source_map = self.tcx.sess.source_map();\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0368,\n@@ -275,7 +275,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                               Op::Binary(op, is_assign))\n                                             .is_ok()\n                                 } {\n-                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                                         while let TyRef(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n@@ -343,7 +343,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                               Op::Binary(op, is_assign))\n                                             .is_ok()\n                                 } {\n-                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                                         while let TyRef(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n@@ -420,7 +420,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err: &mut errors::DiagnosticBuilder,\n         is_assign: bool,\n     ) -> bool {\n-        let codemap = self.tcx.sess.codemap();\n+        let source_map = self.tcx.sess.source_map();\n         let msg = \"`to_owned()` can be used to create an owned `String` \\\n                    from a string reference. String concatenation \\\n                    appends the string on the right to the string \\\n@@ -434,7 +434,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if !is_assign {\n                     err.span_label(expr.span,\n                                    \"`+` can't be used to concatenate two `&str` strings\");\n-                    match codemap.span_to_snippet(lhs_expr.span) {\n+                    match source_map.span_to_snippet(lhs_expr.span) {\n                         Ok(lstring) => err.span_suggestion(lhs_expr.span,\n                                                            msg,\n                                                            format!(\"{}.to_owned()\", lstring)),\n@@ -448,8 +448,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate a `&str` with a `String`\");\n                 match (\n-                    codemap.span_to_snippet(lhs_expr.span),\n-                    codemap.span_to_snippet(rhs_expr.span),\n+                    source_map.span_to_snippet(lhs_expr.span),\n+                    source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), false) => {"}, {"sha": "086243314330d7d8ae119c5a550363a26761ea86", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        let msg = if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+        let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {\n             \"unused import\".to_string()"}, {"sha": "1b04c5da59b2853bf40274096d14ecb3475630e0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -52,7 +52,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n-    let span = tcx.sess.codemap().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {\n@@ -169,7 +169,7 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n                 traits::supertrait_def_ids(tcx,\n                                            data.principal().unwrap().def_id());\n             if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                let sp = tcx.sess.codemap().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 struct_span_err!(tcx.sess,\n                                  sp,\n                                  E0371,"}, {"sha": "4a3747017dfc139357985d753dca970ea9a3caed", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -40,7 +40,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                        self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n-                let cm = self.tcx.sess.codemap();\n+                let cm = self.tcx.sess.source_map();\n                 let sp = cm.def_span(item.span);\n                 match traits::orphan_check(self.tcx, def_id) {\n                     Ok(()) => {}"}, {"sha": "956d542ab7d4e108a5edd61bf6fef3b5777ac635", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -43,7 +43,7 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::MetaItemKind;\n use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax::feature_gate;\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "ffd9da8c8b95c803ec870ff93738027effccda2d", "filename": "src/librustc_typeck/structured_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustc_typeck%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fstructured_errors.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> StructuredDiagnostic<'tcx> for VariadicError<'tcx> {\n                 self.code(),\n             )\n         };\n-        if let Ok(snippet) = self.sess.codemap().span_to_snippet(self.span) {\n+        if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n             err.span_suggestion(self.span,\n                                 &format!(\"cast the value to `{}`\", self.cast_ty),\n                                 format!(\"{} as {}\", snippet, self.cast_ty));"}, {"sha": "d5aab1fb098e155cf6db2285759924787b7041ac", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -417,7 +417,7 @@ mod test {\n \n     use syntax::symbol::Symbol;\n     use syntax::ast::*;\n-    use syntax::codemap::dummy_spanned;\n+    use syntax::source_map::dummy_spanned;\n     use syntax_pos::DUMMY_SP;\n     use syntax::with_globals;\n "}, {"sha": "9b77ff82f9096e36e5874ff5dfd1b14904b28d3f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ pub use self::Visibility::{Public, Inherited};\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n-use syntax::codemap::{dummy_spanned, Spanned};\n+use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n use syntax::symbol::InternedString;\n@@ -239,7 +239,7 @@ impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = cx.tcx.def_span(root);\n-        let krate_src = cx.sess().codemap().span_to_filename(krate_span);\n+        let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n \n         // Collect all inner modules which are tagged as implementations of\n         // primitives.\n@@ -596,14 +596,14 @@ impl Clean<Item> for doctree::Module {\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n-            let cm = cx.sess().codemap();\n+            let cm = cx.sess().source_map();\n             let outer = cm.lookup_char_pos(self.where_outer.lo());\n             let inner = cm.lookup_char_pos(self.where_inner.lo());\n             if outer.file.start_pos == inner.file.start_pos {\n                 // mod foo { ... }\n                 self.where_outer\n             } else {\n-                // mod foo; (and a separate FileMap for the contents)\n+                // mod foo; (and a separate SourceFile for the contents)\n                 self.where_inner\n             }\n         };\n@@ -3015,7 +3015,7 @@ impl Clean<Span> for syntax_pos::Span {\n             return Span::empty();\n         }\n \n-        let cm = cx.sess().codemap();\n+        let cm = cx.sess().source_map();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo());\n         let hi = cm.lookup_char_pos(self.hi());\n@@ -3620,7 +3620,7 @@ pub trait ToSource {\n impl ToSource for syntax_pos::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n-        let sn = match cx.sess().codemap().span_to_snippet(*self) {\n+        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x.to_string(),\n             Err(_) => \"\".to_string()\n         };"}, {"sha": "a312913a69c17bf2ffd23e18acd40a608d6cdee3", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -27,7 +27,7 @@ use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n use syntax::ast::{self, Ident};\n-use syntax::codemap;\n+use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n@@ -258,9 +258,9 @@ impl DocAccessLevels for AccessLevels<DefId> {\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n ///\n-/// If the given `error_format` is `ErrorOutputType::Json` and no `CodeMap` is given, a new one\n+/// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::CodeMap>>)\n+pub fn new_handler(error_format: ErrorOutputType, source_map: Option<Lrc<source_map::SourceMap>>)\n     -> errors::Handler\n {\n     // rustdoc doesn't override (or allow to override) anything from this that is relevant here, so\n@@ -270,26 +270,26 @@ pub fn new_handler(error_format: ErrorOutputType, codemap: Option<Lrc<codemap::C\n         ErrorOutputType::HumanReadable(color_config) => Box::new(\n             EmitterWriter::stderr(\n                 color_config,\n-                codemap.map(|cm| cm as _),\n+                source_map.map(|cm| cm as _),\n                 false,\n                 sessopts.debugging_opts.teach,\n             ).ui_testing(sessopts.debugging_opts.ui_testing)\n         ),\n         ErrorOutputType::Json(pretty) => {\n-            let codemap = codemap.unwrap_or_else(\n-                || Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping())));\n+            let source_map = source_map.unwrap_or_else(\n+                || Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping())));\n             Box::new(\n                 JsonEmitter::stderr(\n                     None,\n-                    codemap,\n+                    source_map,\n                     pretty,\n                 ).ui_testing(sessopts.debugging_opts.ui_testing)\n             )\n         },\n         ErrorOutputType::Short(color_config) => Box::new(\n             EmitterWriter::stderr(\n                 color_config,\n-                codemap.map(|cm| cm as _),\n+                source_map.map(|cm| cm as _),\n                 true,\n                 false)\n         ),\n@@ -387,11 +387,11 @@ pub fn run_core(search_paths: SearchPaths,\n         ..Options::default()\n     };\n     driver::spawn_thread_pool(sessopts, move |sessopts| {\n-        let codemap = Lrc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n-        let diagnostic_handler = new_handler(error_format, Some(codemap.clone()));\n+        let source_map = Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping()));\n+        let diagnostic_handler = new_handler(error_format, Some(source_map.clone()));\n \n         let mut sess = session::build_session_(\n-            sessopts, cpath, diagnostic_handler, codemap,\n+            sessopts, cpath, diagnostic_handler, source_map,\n         );\n \n         lint::builtin::HardwiredLints.get_lints()"}, {"sha": "dd1e1e99957cea9cdca83cc679fee2ecbc83cf2b", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir;"}, {"sha": "5df4862290e3c0d990e980320e3d85570a5c1495", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@ use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n \n-use syntax::codemap::{CodeMap, FilePathMapping};\n+use syntax::source_map::{SourceMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n@@ -33,7 +33,8 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new(FilePathMapping::empty());\n-    let fm = sess.codemap().new_filemap(FileName::Custom(\"stdin\".to_string()), src.to_string());\n+    let fm = sess.source_map().new_source_file(FileName::Custom(\"stdin\".to_string()),\n+                                               src.to_string());\n \n     let mut out = Vec::new();\n     if let Some((tooltip, class)) = tooltip {\n@@ -43,7 +44,8 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n     }\n     write_header(class, &mut out).unwrap();\n \n-    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None),\n+                                         sess.source_map());\n     if classifier.write_source(&mut out).is_err() {\n         return format!(\"<pre>{}</pre>\", src);\n     }\n@@ -60,7 +62,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>,\n /// each span of text in sequence.\n struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n-    codemap: &'a CodeMap,\n+    source_map: &'a SourceMap,\n \n     // State of the classifier.\n     in_attribute: bool,\n@@ -145,10 +147,10 @@ impl<U: Write> Writer for U {\n }\n \n impl<'a> Classifier<'a> {\n-    fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+    fn new(lexer: lexer::StringReader<'a>, source_map: &'a SourceMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n-            codemap,\n+            source_map,\n             in_attribute: false,\n             in_macro: false,\n             in_macro_nonterminal: false,\n@@ -338,9 +340,9 @@ impl<'a> Classifier<'a> {\n         out.string(Escape(&self.snip(tas.sp)), klass)\n     }\n \n-    // Helper function to get a snippet from the codemap.\n+    // Helper function to get a snippet from the source_map.\n     fn snip(&self, sp: Span) -> String {\n-        self.codemap.span_to_snippet(sp).unwrap()\n+        self.source_map.span_to_snippet(sp).unwrap()\n     }\n }\n "}, {"sha": "44a9710e30f7ddc257b606604a931b8e0806745c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -56,7 +56,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n-use syntax::codemap::FileName;\n+use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;"}, {"sha": "a3ae953e6ee9b99cdf19705905c2534e86617756", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -19,7 +19,7 @@ use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{Externs, CodegenOptions};\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::edition::Edition;\n "}, {"sha": "3b07a2ccdde09379e8e10fd706d8db6b733f80ca", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -33,7 +33,7 @@ use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use syntax::ast;\n-use syntax::codemap::CodeMap;\n+use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::with_globals;\n@@ -86,14 +86,14 @@ pub fn run(input_path: &Path,\n         ..config::Options::default()\n     };\n     driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let codemap = Lrc::new(CodeMap::new(sessopts.file_path_mapping()));\n+        let source_map = Lrc::new(SourceMap::new(sessopts.file_path_mapping()));\n         let handler =\n             errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                             true, false,\n-                                            Some(codemap.clone()));\n+                                            Some(source_map.clone()));\n \n         let mut sess = session::build_session_(\n-            sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n+            sessopts, Some(input_path.to_owned()), handler, source_map.clone(),\n         );\n         let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n         let cstore = CStore::new(codegen_backend.metadata_loader());\n@@ -133,7 +133,7 @@ pub fn run(input_path: &Path,\n             false,\n             opts,\n             maybe_sysroot,\n-            Some(codemap),\n+            Some(source_map),\n              None,\n             linker,\n             edition\n@@ -205,7 +205,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     // never wrap the test in `fn main() { ... }`\n     let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts);\n     // FIXME(#44940): if doctests ever support path remapping, then this filename\n-    // needs to be the result of CodeMap::span_to_unmapped_path\n+    // needs to be the result of SourceMap::span_to_unmapped_path\n     let input = config::Input::Str {\n         name: filename.to_owned(),\n         input: test.to_owned(),\n@@ -262,19 +262,19 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n \n     let (libdir, outdir, compile_result) = driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let codemap = Lrc::new(CodeMap::new_doctest(\n+        let source_map = Lrc::new(SourceMap::new_doctest(\n             sessopts.file_path_mapping(), filename.clone(), line as isize - line_offset as isize\n         ));\n         let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                        Some(codemap.clone()),\n+                                                        Some(source_map.clone()),\n                                                         false,\n                                                         false);\n \n         // Compile the code\n         let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n         let mut sess = session::build_session_(\n-            sessopts, None, diagnostic_handler, codemap,\n+            sessopts, None, diagnostic_handler, source_map,\n         );\n         let codegen_backend = rustc_driver::get_codegen_backend(&sess);\n         let cstore = CStore::new(codegen_backend.metadata_loader());\n@@ -500,7 +500,7 @@ pub struct Collector {\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n     position: Span,\n-    codemap: Option<Lrc<CodeMap>>,\n+    source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n     linker: Option<PathBuf>,\n     edition: Edition,\n@@ -509,7 +509,7 @@ pub struct Collector {\n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, cg: CodegenOptions,\n                externs: Externs, use_headers: bool, opts: TestOptions,\n-               maybe_sysroot: Option<PathBuf>, codemap: Option<Lrc<CodeMap>>,\n+               maybe_sysroot: Option<PathBuf>, source_map: Option<Lrc<SourceMap>>,\n                filename: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition) -> Collector {\n         Collector {\n             tests: Vec::new(),\n@@ -523,7 +523,7 @@ impl Collector {\n             opts,\n             maybe_sysroot,\n             position: DUMMY_SP,\n-            codemap,\n+            source_map,\n             filename,\n             linker,\n             edition,\n@@ -589,9 +589,9 @@ impl Collector {\n     }\n \n     pub fn get_line(&self) -> usize {\n-        if let Some(ref codemap) = self.codemap {\n+        if let Some(ref source_map) = self.source_map {\n             let line = self.position.lo().to_usize();\n-            let line = codemap.lookup_char_pos(BytePos(line as u32)).line;\n+            let line = source_map.lookup_char_pos(BytePos(line as u32)).line;\n             if line > 0 { line - 1 } else { line }\n         } else {\n             0\n@@ -603,8 +603,8 @@ impl Collector {\n     }\n \n     fn get_filename(&self) -> FileName {\n-        if let Some(ref codemap) = self.codemap {\n-            let filename = codemap.span_to_filename(self.position);\n+        if let Some(ref source_map) = self.source_map {\n+            let filename = source_map.span_to_filename(self.position);\n             if let FileName::Real(ref filename) = filename {\n                 if let Ok(cur_dir) = env::current_dir() {\n                     if let Ok(path) = filename.strip_prefix(&cur_dir) {"}, {"sha": "68ddf72da0617bb4d9011c11425dd67ce7abb68d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -15,7 +15,7 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir::map as hir_map;"}, {"sha": "ec6ac86ba6bd39dd24e6227846c6dfb5adce86a7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@ pub use symbol::{Ident, Symbol as Name};\n pub use util::parser::ExprPrecedence;\n \n use syntax_pos::{Span, DUMMY_SP};\n-use codemap::{dummy_spanned, respan, Spanned};\n+use source_map::{dummy_spanned, respan, Spanned};\n use rustc_target::spec::abi::Abi;\n use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;"}, {"sha": "cd9d76822106c431cd07254805310e7e8b1e1227", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -25,7 +25,7 @@ use ast;\n use ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n-use codemap::{BytePos, Spanned, respan, dummy_spanned};\n+use source_map::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::{FileName, Span};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::parser::Parser;"}, {"sha": "0e52434ec0170dc0dcd37600b61da7867fe3dfd3", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ use attr::HasAttrs;\n use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use {fold, attr};\n use ast;\n-use codemap::Spanned;\n+use source_map::Spanned;\n use edition::Edition;\n use parse::{token, ParseSess};\n use OneVector;"}, {"sha": "1438299d375b649ba2609c12a03eb82ce84771ae", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -45,7 +45,7 @@ pub struct ErrorLocation {\n impl ErrorLocation {\n     /// Create an error location from a span.\n     pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n-        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo());\n+        let loc = ecx.source_map().lookup_char_pos_adj(sp.lo());\n         ErrorLocation {\n             filename: loc.filename,\n             line: loc.line"}, {"sha": "d044efa3c38af20be7fcca1f01ad125520c4aaf4", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,7 +13,7 @@ use std::env;\n \n use ast;\n use ast::{Ident, Name};\n-use codemap;\n+use source_map;\n use syntax_pos::Span;\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n@@ -223,7 +223,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 ty,\n                 expr,\n             ),\n-            vis: codemap::respan(span.shrink_to_lo(), ast::VisibilityKind::Public),\n+            vis: source_map::respan(span.shrink_to_lo(), ast::VisibilityKind::Public),\n             span,\n             tokens: None,\n         })"}, {"sha": "154fe11dd352c45882a15fe65001ddcac8558044", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ pub use self::SyntaxExtension::*;\n \n use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, Spanned, respan};\n+use source_map::{self, SourceMap, Spanned, respan};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -481,7 +481,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitKind::Bool(false)))),\n+            node: ast::ExprKind::Lit(P(source_map::respan(sp, ast::LitKind::Bool(false)))),\n             span: sp,\n             attrs: ThinVec::new(),\n         })\n@@ -836,7 +836,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n         parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect())\n     }\n-    pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n+    pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {"}, {"sha": "b1bed9602f3629cd9cdaee863eecaa56ca2d0e25", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ use rustc_target::spec::abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use syntax_pos::{Pos, Span, DUMMY_SP};\n-use codemap::{dummy_spanned, respan, Spanned};\n+use source_map::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n use symbol::{Symbol, keywords};\n@@ -764,7 +764,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.codemap().lookup_char_pos(span.lo());\n+        let loc = self.source_map().lookup_char_pos(span.lo());\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);"}, {"sha": "80bbc618932ef7f89613e9ff82e4527a42e96a04", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,7 +10,7 @@\n \n use attr::HasAttrs;\n use ast;\n-use codemap::{hygiene, ExpnInfo, ExpnFormat};\n+use source_map::{hygiene, ExpnInfo, ExpnFormat};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use parse::parser::PathStyle;"}, {"sha": "b12b2c49caa58608c737675bb1565e610f58ef61", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n-use codemap::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::{Applicability, FatalError};\n use ext::base::*;\n@@ -267,7 +267,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.codemap().span_to_unmapped_path(krate.span) {\n+            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n                 FileName::Real(path) => path,\n                 other => PathBuf::from(other.to_string()),\n             },\n@@ -1355,7 +1355,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         module.directory.push(&*item.ident.as_str());\n                     }\n                 } else {\n-                    let path = self.cx.parse_sess.codemap().span_to_unmapped_path(inner);\n+                    let path = self.cx.parse_sess.source_map().span_to_unmapped_path(inner);\n                     let mut path = match path {\n                         FileName::Real(path) => path,\n                         other => PathBuf::from(other.to_string()),\n@@ -1563,7 +1563,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                             // Add this input file to the code map to make it available as\n                             // dependency information\n-                            self.cx.codemap().new_filemap(filename.into(), src);\n+                            self.cx.source_map().new_source_file(filename.into(), src);\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem("}, {"sha": "18b4119fde8e49767d270bff3c14ce3cfece17fc", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{self, NodeId};\n-use codemap::{DUMMY_SP, dummy_spanned};\n+use source_map::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{AstFragment, AstFragmentKind};\n use ext::hygiene::Mark;"}, {"sha": "13a139deea4c31f7205cb183192bdf2164ae4d62", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, Ty};\n-use codemap::respan;\n+use source_map::respan;\n use syntax_pos::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n@@ -28,7 +28,7 @@ use tokenstream::{TokenStream, TokenTree};\n \n pub mod rt {\n     use ast;\n-    use codemap::Spanned;\n+    use source_map::Spanned;\n     use ext::base::ExtCtxt;\n     use parse::{self, classify};\n     use parse::token::{self, Token};\n@@ -40,7 +40,7 @@ pub mod rt {\n \n     pub use parse::new_parser_from_tts;\n     pub use syntax_pos::{BytePos, Span, DUMMY_SP, FileName};\n-    pub use codemap::{dummy_spanned};\n+    pub use source_map::{dummy_spanned};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n@@ -802,7 +802,7 @@ fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> {\n     // they happen to have a compiler on hand). Over all, the phase distinction\n     // just makes quotes \"hard to attribute\". Possibly this could be fixed\n     // by recreating some of the original qq machinery in the tt regime\n-    // (pushing fake FileMaps onto the parser to account for original sites\n+    // (pushing fake SourceFiles onto the parser to account for original sites\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n "}, {"sha": "19a204cc989bfeb9f05dbdf775a08ca78f32d6ce", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -36,7 +36,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.line as u32))\n }\n@@ -47,7 +47,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32 + 1))\n }\n@@ -63,14 +63,14 @@ pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n }\n \n /// file!(): expands to the current filename */\n-/// The filemap (`loc.file`) contains a bunch more information we could spit\n+/// The source_file (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n+    let loc = cx.source_map().lookup_char_pos(topmost.lo());\n     base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n }\n \n@@ -154,7 +154,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n \n             // Add this input file to the code map to make it available as\n             // dependency information\n-            cx.codemap().new_filemap(file.into(), src);\n+            cx.source_map().new_source_file(file.into(), src);\n \n             base::MacEager::expr(cx.expr_str(sp, interned_src))\n         }\n@@ -184,7 +184,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Ok(..) => {\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n-            cx.codemap().new_filemap(file.into(), \"\".to_string());\n+            cx.source_map().new_source_file(file.into(), \"\".to_string());\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Lrc::new(bytes))))\n         }\n@@ -199,7 +199,7 @@ fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: String) -> PathBuf\n     // after macro expansion (that is, they are unhygienic).\n     if !arg.is_absolute() {\n         let callsite = sp.source_callsite();\n-        let mut path = match cx.codemap().span_to_unmapped_path(callsite) {\n+        let mut path = match cx.source_map().span_to_unmapped_path(callsite) {\n             FileName::Real(path) => path,\n             other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n         };"}, {"sha": "74f573fceba813eb5ee404fc7df061e3ce46e333", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -29,7 +29,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n use ast::{self, NodeId, PatKind, RangeEnd};\n use attr;\n-use codemap::Spanned;\n+use source_map::Spanned;\n use edition::{ALL_EDITIONS, Edition};\n use syntax_pos::{Span, DUMMY_SP};\n use errors::{DiagnosticBuilder, Handler};\n@@ -1556,7 +1556,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         if !name.as_str().is_ascii() {\n             gate_feature_post!(&self,\n                                non_ascii_idents,\n-                               self.context.parse_sess.codemap().def_span(sp),\n+                               self.context.parse_sess.source_map().def_span(sp),\n                                \"non-ascii idents are not fully supported.\");\n         }\n     }"}, {"sha": "50a49e2f548e82a18b5bd8d6a5198d11a4ccd1b2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@\n use ast::*;\n use ast;\n use syntax_pos::Span;\n-use codemap::{Spanned, respan};\n+use source_map::{Spanned, respan};\n use parse::token::{self, Token};\n use ptr::P;\n use OneVector;"}, {"sha": "b0cf29e9f63a4a2322467778dba3767ca543a29a", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -19,10 +19,10 @@\n \n // FIXME spec the JSON output properly.\n \n-use codemap::{CodeMap, FilePathMapping};\n+use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n use errors::{DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -36,14 +36,14 @@ use rustc_serialize::json::{as_json, as_pretty_json};\n pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n-    cm: Lrc<dyn CodeMapper + sync::Send + sync::Sync>,\n+    cm: Lrc<dyn SourceMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     ui_testing: bool,\n }\n \n impl JsonEmitter {\n     pub fn stderr(registry: Option<Registry>,\n-                  code_map: Lrc<CodeMap>,\n+                  code_map: Lrc<SourceMap>,\n                   pretty: bool) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::stderr()),\n@@ -56,13 +56,13 @@ impl JsonEmitter {\n \n     pub fn basic(pretty: bool) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n-        JsonEmitter::stderr(None, Lrc::new(CodeMap::new(file_path_mapping)),\n+        JsonEmitter::stderr(None, Lrc::new(SourceMap::new(file_path_mapping)),\n                             pretty)\n     }\n \n     pub fn new(dst: Box<dyn Write + Send>,\n                registry: Option<Registry>,\n-               code_map: Lrc<CodeMap>,\n+               code_map: Lrc<SourceMap>,\n                pretty: bool) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n@@ -340,7 +340,7 @@ impl DiagnosticSpan {\n }\n \n impl DiagnosticSpanLine {\n-    fn line_from_filemap(fm: &syntax_pos::FileMap,\n+    fn line_from_source_file(fm: &syntax_pos::SourceFile,\n                          index: usize,\n                          h_start: usize,\n                          h_end: usize)\n@@ -362,7 +362,7 @@ impl DiagnosticSpanLine {\n                  lines.lines\n                       .iter()\n                       .map(|line| {\n-                          DiagnosticSpanLine::line_from_filemap(fm,\n+                          DiagnosticSpanLine::line_from_source_file(fm,\n                                                                 line.line_index,\n                                                                 line.start_col.0 + 1,\n                                                                 line.end_col.0 + 1)"}, {"sha": "289f023cefae390fca0b112cc6a0cb776bff7011", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -145,7 +145,7 @@ pub mod syntax {\n \n pub mod ast;\n pub mod attr;\n-pub mod codemap;\n+pub mod source_map;\n #[macro_use]\n pub mod config;\n pub mod entry;"}, {"sha": "a240604bfe0ad1cc855aca1aa3df10c65083f641", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,7 +10,7 @@\n \n use attr;\n use ast;\n-use codemap::respan;\n+use source_map::respan;\n use parse::{SeqSep, PResult};\n use parse::token::{self, Nonterminal, DelimToken};\n use parse::parser::{Parser, TokenType, PathStyle};"}, {"sha": "dde0466f43c2d4cb540094f302327a3bc91cfa78", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -11,7 +11,7 @@\n pub use self::CommentStyle::*;\n \n use ast;\n-use codemap::CodeMap;\n+use source_map::SourceMap;\n use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n use parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n@@ -247,11 +247,11 @@ fn read_block_comment(rdr: &mut StringReader,\n     let mut lines: Vec<String> = Vec::new();\n \n     // Count the number of chars since the start of the line by rescanning.\n-    let mut src_index = rdr.src_index(rdr.filemap.line_begin_pos(rdr.pos));\n+    let mut src_index = rdr.src_index(rdr.source_file.line_begin_pos(rdr.pos));\n     let end_src_index = rdr.src_index(rdr.pos);\n     assert!(src_index <= end_src_index,\n         \"src_index={}, end_src_index={}, line_begin_pos={}\",\n-        src_index, end_src_index, rdr.filemap.line_begin_pos(rdr.pos).to_u32());\n+        src_index, end_src_index, rdr.source_file.line_begin_pos(rdr.pos).to_u32());\n     let mut n = 0;\n \n     while src_index < end_src_index {\n@@ -371,9 +371,9 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut\n {\n     let mut src = String::new();\n     srdr.read_to_string(&mut src).unwrap();\n-    let cm = CodeMap::new(sess.codemap().path_mapping().clone());\n-    let filemap = cm.new_filemap(path, src);\n-    let mut rdr = lexer::StringReader::new_raw(sess, filemap, None);\n+    let cm = SourceMap::new(sess.source_map().path_mapping().clone());\n+    let source_file = cm.new_source_file(path, src);\n+    let mut rdr = lexer::StringReader::new_raw(sess, source_file, None);\n \n     let mut comments: Vec<Comment> = Vec::new();\n     let mut literals: Vec<Literal> = Vec::new();"}, {"sha": "448ff9676c927492791e6ac08ec42391fdecfc0f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n-use codemap::{CodeMap, FilePathMapping};\n+use source_map::{SourceMap, FilePathMapping};\n use errors::{Applicability, FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n@@ -43,13 +43,13 @@ impl Default for TokenAndSpan {\n \n pub struct StringReader<'a> {\n     pub sess: &'a ParseSess,\n-    /// The absolute offset within the codemap of the next character to read\n+    /// The absolute offset within the source_map of the next character to read\n     pub next_pos: BytePos,\n-    /// The absolute offset within the codemap of the current character\n+    /// The absolute offset within the source_map of the current character\n     pub pos: BytePos,\n     /// The current character (which has been read from self.pos)\n     pub ch: Option<char>,\n-    pub filemap: Lrc<syntax_pos::FileMap>,\n+    pub source_file: Lrc<syntax_pos::SourceFile>,\n     /// Stop reading src at this index.\n     pub end_src_index: usize,\n     // cached:\n@@ -58,7 +58,7 @@ pub struct StringReader<'a> {\n     peek_span_src_raw: Span,\n     fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n-    // retrieve it via `self.filemap.src.as_ref().unwrap()` all the time.\n+    // retrieve it via `self.source_file.src.as_ref().unwrap()` all the time.\n     src: Lrc<String>,\n     /// Stack of open delimiters and their spans. Used for error message.\n     token: token::Token,\n@@ -180,31 +180,31 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// For comments.rs, which hackily pokes into next_pos and ch\n-    fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>, override_span: Option<Span>)\n-        -> Self\n-    {\n-        let mut sr = StringReader::new_raw_internal(sess, filemap, override_span);\n+    fn new_raw(sess: &'a ParseSess,\n+               source_file: Lrc<syntax_pos::SourceFile>,\n+               override_span: Option<Span>) -> Self {\n+        let mut sr = StringReader::new_raw_internal(sess, source_file, override_span);\n         sr.bump();\n \n         sr\n     }\n \n-    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>,\n+    fn new_raw_internal(sess: &'a ParseSess, source_file: Lrc<syntax_pos::SourceFile>,\n         override_span: Option<Span>) -> Self\n     {\n-        if filemap.src.is_none() {\n-            sess.span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n-                                              filemap.name));\n+        if source_file.src.is_none() {\n+            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n+                                              source_file.name));\n         }\n \n-        let src = (*filemap.src.as_ref().unwrap()).clone();\n+        let src = (*source_file.src.as_ref().unwrap()).clone();\n \n         StringReader {\n             sess,\n-            next_pos: filemap.start_pos,\n-            pos: filemap.start_pos,\n+            next_pos: source_file.start_pos,\n+            pos: source_file.start_pos,\n             ch: Some('\\n'),\n-            filemap,\n+            source_file,\n             end_src_index: src.len(),\n             // dummy values; not read\n             peek_tok: token::Eof,\n@@ -221,10 +221,10 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>, override_span: Option<Span>)\n-        -> Self\n-    {\n-        let mut sr = StringReader::new_raw(sess, filemap, override_span);\n+    pub fn new(sess: &'a ParseSess,\n+               source_file: Lrc<syntax_pos::SourceFile>,\n+               override_span: Option<Span>) -> Self {\n+        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n         if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n             FatalError.raise();\n@@ -234,8 +234,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.codemap().lookup_byte_offset(span.lo());\n-        let end = sess.codemap().lookup_byte_offset(span.hi());\n+        let begin = sess.source_map().lookup_byte_offset(span.lo());\n+        let end = sess.source_map().lookup_byte_offset(span.hi());\n \n         // Make the range zero-length if the span is invalid.\n         if span.lo() > span.hi() || begin.fm.start_pos != end.fm.start_pos {\n@@ -364,8 +364,8 @@ impl<'a> StringReader<'a> {\n                 if self.is_eof() {\n                     self.peek_tok = token::Eof;\n                     let (real, raw) = self.mk_sp_and_raw(\n-                        self.filemap.end_pos,\n-                        self.filemap.end_pos,\n+                        self.source_file.end_pos,\n+                        self.source_file.end_pos,\n                     );\n                     self.peek_span = real;\n                     self.peek_span_src_raw = raw;\n@@ -384,7 +384,7 @@ impl<'a> StringReader<'a> {\n \n     #[inline]\n     fn src_index(&self, pos: BytePos) -> usize {\n-        (pos - self.filemap.start_pos).to_usize()\n+        (pos - self.source_file.start_pos).to_usize()\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -468,7 +468,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Advance the StringReader by one character. If a newline is\n-    /// discovered, add it to the FileMap's list of line start offsets.\n+    /// discovered, add it to the SourceFile's list of line start offsets.\n     crate fn bump(&mut self) {\n         let next_src_index = self.src_index(self.next_pos);\n         if next_src_index < self.end_src_index {\n@@ -622,8 +622,8 @@ impl<'a> StringReader<'a> {\n \n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n-                let cmap = CodeMap::new(FilePathMapping::empty());\n-                cmap.files.borrow_mut().file_maps.push(self.filemap.clone());\n+                let cmap = SourceMap::new(FilePathMapping::empty());\n+                cmap.files.borrow_mut().file_maps.push(self.source_file.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n                 if loc.line == 1 && loc.col == CharPos(0) {\n@@ -1827,7 +1827,7 @@ mod tests {\n     use ast::{Ident, CrateConfig};\n     use symbol::Symbol;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n-    use codemap::CodeMap;\n+    use source_map::SourceMap;\n     use errors;\n     use feature_gate::UnstableFeatures;\n     use parse::token;\n@@ -1837,7 +1837,7 @@ mod tests {\n     use diagnostics::plugin::ErrorMap;\n     use rustc_data_structures::sync::Lock;\n     use with_globals;\n-    fn mk_sess(cm: Lrc<CodeMap>) -> ParseSess {\n+    fn mk_sess(cm: Lrc<SourceMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(cm.clone()),\n                                                           false,\n@@ -1857,18 +1857,18 @@ mod tests {\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(cm: &CodeMap,\n+    fn setup<'a>(cm: &SourceMap,\n                  sess: &'a ParseSess,\n                  teststr: String)\n                  -> StringReader<'a> {\n-        let fm = cm.new_filemap(PathBuf::from(\"zebra.rs\").into(), teststr);\n+        let fm = cm.new_source_file(PathBuf::from(\"zebra.rs\").into(), teststr);\n         StringReader::new(sess, fm, None)\n     }\n \n     #[test]\n     fn t1() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut string_reader = setup(&cm,\n                                         &sh,\n@@ -1916,7 +1916,7 @@ mod tests {\n     #[test]\n     fn doublecolonparsing() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                             vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n@@ -1926,7 +1926,7 @@ mod tests {\n     #[test]\n     fn dcparsing_2() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                             vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n@@ -1936,7 +1936,7 @@ mod tests {\n     #[test]\n     fn dcparsing_3() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                             vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n@@ -1946,7 +1946,7 @@ mod tests {\n     #[test]\n     fn dcparsing_4() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                             vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n@@ -1956,7 +1956,7 @@ mod tests {\n     #[test]\n     fn character_a() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\"a\")), None));\n@@ -1966,7 +1966,7 @@ mod tests {\n     #[test]\n     fn character_space() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\" \")), None));\n@@ -1976,7 +1976,7 @@ mod tests {\n     #[test]\n     fn character_escaped() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                     token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n@@ -1986,7 +1986,7 @@ mod tests {\n     #[test]\n     fn lifetime_name() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                     token::Lifetime(Ident::from_str(\"'abc\")));\n@@ -1996,7 +1996,7 @@ mod tests {\n     #[test]\n     fn raw_string() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                         .next_token()\n@@ -2008,7 +2008,7 @@ mod tests {\n     #[test]\n     fn literal_suffixes() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             macro_rules! test {\n                 ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n@@ -2054,7 +2054,7 @@ mod tests {\n     #[test]\n     fn nested_block_comments() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n             match lexer.next_token().tok {\n@@ -2069,7 +2069,7 @@ mod tests {\n     #[test]\n     fn crlf_comments() {\n         with_globals(|| {\n-            let cm = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n             let sh = mk_sess(cm.clone());\n             let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n             let comment = lexer.next_token();"}, {"sha": "adf01197c6d9f3f6b43586763fc6cdb250d06515", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,8 +13,8 @@\n use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n-use codemap::{CodeMap, FilePathMapping};\n-use syntax_pos::{Span, FileMap, FileName, MultiSpan};\n+use source_map::{SourceMap, FilePathMapping};\n+use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -57,21 +57,21 @@ pub struct ParseSess {\n     pub non_modrs_mods: Lock<Vec<(ast::Ident, Span)>>,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: Lock<Vec<PathBuf>>,\n-    code_map: Lrc<CodeMap>,\n+    code_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n }\n \n impl ParseSess {\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n-        let cm = Lrc::new(CodeMap::new(file_path_mapping));\n+        let cm = Lrc::new(SourceMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n                                                 false,\n                                                 Some(cm.clone()));\n         ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(handler: Handler, code_map: Lrc<CodeMap>) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Lrc<SourceMap>) -> ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n@@ -86,7 +86,7 @@ impl ParseSess {\n         }\n     }\n \n-    pub fn codemap(&self) -> &CodeMap {\n+    pub fn source_map(&self) -> &SourceMap {\n         &self.code_map\n     }\n \n@@ -171,41 +171,41 @@ crate fn parse_stmt_from_source_str(name: FileName, source: String, sess: &Parse\n pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &ParseSess,\n                                     override_span: Option<Span>)\n                                     -> TokenStream {\n-    filemap_to_stream(sess, sess.codemap().new_filemap(name, source), override_span)\n+    source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n                                       -> Parser {\n-    let mut parser = filemap_to_parser(sess, sess.codemap().new_filemap(name, source));\n+    let mut parser = source_file_to_parser(sess, sess.source_map().new_source_file(name, source));\n     parser.recurse_into_file_modules = false;\n     parser\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a> {\n-    filemap_to_parser(sess, file_to_filemap(sess, path, None))\n+    source_file_to_parser(sess, file_to_source_file(sess, path, None))\n }\n \n /// Given a session, a crate config, a path, and a span, add\n-/// the file at the given path to the codemap, and return a parser.\n+/// the file at the given path to the source_map, and return a parser.\n /// On an error, use the given span as the source of the problem.\n crate fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     path: &Path,\n                                     directory_ownership: DirectoryOwnership,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n-    let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n+    let mut p = source_file_to_parser(sess, file_to_source_file(sess, path, Some(sp)));\n     p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }\n \n-/// Given a filemap and config, return a parser\n-fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<FileMap>) -> Parser {\n-    let end_pos = filemap.end_pos;\n-    let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n+/// Given a source_file and config, return a parser\n+fn source_file_to_parser(sess: & ParseSess, source_file: Lrc<SourceFile>) -> Parser {\n+    let end_pos = source_file.end_pos;\n+    let mut parser = stream_to_parser(sess, source_file_to_stream(sess, source_file, None));\n \n     if parser.token == token::Eof && parser.span.is_dummy() {\n         parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n@@ -224,11 +224,11 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n // base abstractions\n \n /// Given a session and a path and an optional span (for error reporting),\n-/// add the path to the session's codemap and return the new filemap.\n-fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n-                   -> Lrc<FileMap> {\n-    match sess.codemap().load_file(path) {\n-        Ok(filemap) => filemap,\n+/// add the path to the session's source_map and return the new source_file.\n+fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n+                   -> Lrc<SourceFile> {\n+    match sess.source_map().load_file(path) {\n+        Ok(source_file) => source_file,\n         Err(e) => {\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n@@ -239,10 +239,11 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     }\n }\n \n-/// Given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_stream(sess: &ParseSess, filemap: Lrc<FileMap>, override_span: Option<Span>)\n-                         -> TokenStream {\n-    let mut srdr = lexer::StringReader::new(sess, filemap, override_span);\n+/// Given a source_file, produce a sequence of token-trees\n+pub fn source_file_to_stream(sess: &ParseSess,\n+                             source_file: Lrc<SourceFile>,\n+                             override_span: Option<Span>) -> TokenStream {\n+    let mut srdr = lexer::StringReader::new(sess, source_file, override_span);\n     srdr.real_token();\n     panictry!(srdr.parse_all_token_trees())\n }\n@@ -969,7 +970,7 @@ mod tests {\n \n             let span = tts.iter().rev().next().unwrap().span();\n \n-            match sess.codemap().span_to_snippet(span) {\n+            match sess.source_map().span_to_snippet(span) {\n                 Ok(s) => assert_eq!(&s[..], \"{ body }\"),\n                 Err(_) => panic!(\"could not get snippet\"),\n             }"}, {"sha": "b1e2e69863d97107b5db07753ece874390b6a8a3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -42,7 +42,7 @@ use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n-use codemap::{self, CodeMap, Spanned, respan};\n+use source_map::{self, SourceMap, Spanned, respan};\n use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use parse::{self, SeqSep, classify, token};\n@@ -577,7 +577,7 @@ impl<'a> Parser<'a> {\n         if let Some(directory) = directory {\n             parser.directory = directory;\n         } else if !parser.span.is_dummy() {\n-            if let FileName::Real(mut path) = sess.codemap().span_to_unmapped_path(parser.span) {\n+            if let FileName::Real(mut path) = sess.source_map().span_to_unmapped_path(parser.span) {\n                 path.pop();\n                 parser.directory.path = Cow::from(path);\n             }\n@@ -652,10 +652,10 @@ impl<'a> Parser<'a> {\n                     // EOF, don't want to point at the following char, but rather the last token\n                     self.prev_span\n                 } else {\n-                    self.sess.codemap().next_point(self.prev_span)\n+                    self.sess.source_map().next_point(self.prev_span)\n                 };\n                 let label_exp = format!(\"expected `{}`\", token_str);\n-                let cm = self.sess.codemap();\n+                let cm = self.sess.source_map();\n                 match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n                     (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n                         // When the spans are in the same line, it means that the only content\n@@ -720,14 +720,14 @@ impl<'a> Parser<'a> {\n                     expect.clone()\n                 };\n                 (format!(\"expected one of {}, found `{}`\", expect, actual),\n-                 (self.sess.codemap().next_point(self.prev_span),\n+                 (self.sess.source_map().next_point(self.prev_span),\n                   format!(\"expected one of {} here\", short_expect)))\n             } else if expected.is_empty() {\n                 (format!(\"unexpected token: `{}`\", actual),\n                  (self.prev_span, \"unexpected token after this\".to_string()))\n             } else {\n                 (format!(\"expected {}, found `{}`\", expect, actual),\n-                 (self.sess.codemap().next_point(self.prev_span),\n+                 (self.sess.source_map().next_point(self.prev_span),\n                   format!(\"expected {} here\", expect)))\n             };\n             let mut err = self.fatal(&msg_exp);\n@@ -738,7 +738,7 @@ impl<'a> Parser<'a> {\n                 label_sp\n             };\n \n-            let cm = self.sess.codemap();\n+            let cm = self.sess.source_map();\n             match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n                 (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n                     // When the spans are in the same line, it means that the only content between\n@@ -1879,7 +1879,7 @@ impl<'a> Parser<'a> {\n             let lit = self.parse_lit_token()?;\n             lit\n         };\n-        Ok(codemap::Spanned { node: lit, span: lo.to(self.prev_span) })\n+        Ok(source_map::Spanned { node: lit, span: lo.to(self.prev_span) })\n     }\n \n     /// matches '-' lit | lit (cf. ast_validation::AstValidator::check_expr_within_pat)\n@@ -2185,7 +2185,7 @@ impl<'a> Parser<'a> {\n     pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprKind::Mac(codemap::Spanned {node: m, span: span}),\n+            node: ExprKind::Mac(source_map::Spanned {node: m, span: span}),\n             span,\n             attrs,\n         })\n@@ -2902,7 +2902,7 @@ impl<'a> Parser<'a> {\n                                                   self.this_token_descr()));\n                     // span the `not` plus trailing whitespace to avoid\n                     // trailing whitespace after the `!` in our suggestion\n-                    let to_replace = self.sess.codemap()\n+                    let to_replace = self.sess.source_map()\n                         .span_until_non_whitespace(lo.to(self.span));\n                     err.span_suggestion_short_with_applicability(\n                         to_replace,\n@@ -3000,7 +3000,7 @@ impl<'a> Parser<'a> {\n                     Err(mut err) => {\n                         err.span_label(self.span,\n                                        \"expecting a type here because of type ascription\");\n-                        let cm = self.sess.codemap();\n+                        let cm = self.sess.source_map();\n                         let cur_pos = cm.lookup_char_pos(self.span.lo());\n                         let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n                         if cur_pos.line != op_pos.line {\n@@ -3074,7 +3074,7 @@ impl<'a> Parser<'a> {\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n+                    let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n                     self.mk_expr(span, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n@@ -3094,7 +3094,7 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BinOpKind::Shl,\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n-                    let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n+                    let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(span, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n@@ -3161,7 +3161,7 @@ impl<'a> Parser<'a> {\n                             id: ast::DUMMY_NODE_ID\n                         }));\n \n-                        let expr_str = self.sess.codemap().span_to_snippet(expr.span)\n+                        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n                                                 .unwrap_or(pprust::expr_to_string(&expr));\n                         err.span_suggestion_with_applicability(\n                             expr.span,\n@@ -3277,7 +3277,7 @@ impl<'a> Parser<'a> {\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n         // the dead code lint.\n         if self.eat_keyword(keywords::Else) || !cond.returns() {\n-            let sp = self.sess.codemap().next_point(lo);\n+            let sp = self.sess.source_map().next_point(lo);\n             let mut err = self.diagnostic()\n                 .struct_span_err(sp, \"missing condition for `if` statemement\");\n             err.span_label(sp, \"expected if condition here\");\n@@ -3527,7 +3527,7 @@ impl<'a> Parser<'a> {\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            let cm = self.sess.codemap();\n+            let cm = self.sess.source_map();\n             self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n                 .map_err(|mut err| {\n                     match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n@@ -3736,7 +3736,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         attrs: Vec<Attribute>\n-    ) -> PResult<'a, codemap::Spanned<ast::FieldPat>> {\n+    ) -> PResult<'a, source_map::Spanned<ast::FieldPat>> {\n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let hi;\n         let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n@@ -3779,7 +3779,7 @@ impl<'a> Parser<'a> {\n             (subpat, fieldname, true)\n         };\n \n-        Ok(codemap::Spanned {\n+        Ok(source_map::Spanned {\n             span: lo.to(hi),\n             node: ast::FieldPat {\n                 ident: fieldname,\n@@ -3791,7 +3791,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>>, bool)> {\n+    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<source_map::Spanned<ast::FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n         let mut ate_comma = true;\n@@ -3837,7 +3837,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(self.span, \"expected `}`\");\n                 let mut comma_sp = None;\n                 if self.token == token::Comma { // Issue #49257\n-                    etc_sp = etc_sp.to(self.sess.codemap().span_until_non_whitespace(self.span));\n+                    etc_sp = etc_sp.to(self.sess.source_map().span_until_non_whitespace(self.span));\n                     err.span_label(etc_sp,\n                                    \"`..` must be at the end and cannot have a trailing comma\");\n                     comma_sp = Some(self.span);\n@@ -3955,7 +3955,7 @@ impl<'a> Parser<'a> {\n             let seq_span = pat.span.to(self.prev_span);\n             let mut err = self.struct_span_err(comma_span,\n                                                \"unexpected `,` in pattern\");\n-            if let Ok(seq_snippet) = self.sess.codemap().span_to_snippet(seq_span) {\n+            if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n                 err.span_suggestion_with_applicability(\n                     seq_span,\n                     \"try adding parentheses\",\n@@ -4220,7 +4220,7 @@ impl<'a> Parser<'a> {\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n \n-                    let snippet = self.sess.codemap().span_to_snippet(pat.span).unwrap();\n+                    let snippet = self.sess.source_map().span_to_snippet(pat.span).unwrap();\n                     err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n@@ -4518,7 +4518,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if let Some(macro_def) = self.eat_macro_def(\n             &attrs,\n-            &codemap::respan(lo, VisibilityKind::Inherited),\n+            &source_map::respan(lo, VisibilityKind::Inherited),\n             lo,\n         )? {\n             Stmt {\n@@ -5398,7 +5398,7 @@ impl<'a> Parser<'a> {\n             _ => return Ok(None),\n         };\n \n-        let eself = codemap::respan(eself_lo.to(eself_hi), eself);\n+        let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n         Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n \n@@ -6039,7 +6039,7 @@ impl<'a> Parser<'a> {\n                     err.emit();\n                 } else {\n                     if seen_comma == false {\n-                        let sp = self.sess.codemap().next_point(previous_span);\n+                        let sp = self.sess.source_map().next_point(previous_span);\n                         err.span_suggestion_with_applicability(\n                             sp,\n                             \"missing comma here\",\n@@ -6051,7 +6051,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             _ => {\n-                let sp = self.sess.codemap().next_point(self.prev_span);\n+                let sp = self.sess.source_map().next_point(self.prev_span);\n                 let mut err = self.struct_span_err(sp, &format!(\"expected `,`, or `}}`, found `{}`\",\n                                                                 self.this_token_to_string()));\n                 if self.token.is_ident() {\n@@ -6322,7 +6322,7 @@ impl<'a> Parser<'a> {\n         id: ast::Ident,\n         relative: Option<ast::Ident>,\n         dir_path: &Path,\n-        codemap: &CodeMap) -> ModulePath\n+        source_map: &SourceMap) -> ModulePath\n     {\n         // If we're in a foo.rs file instead of a mod.rs file,\n         // we need to look for submodules in\n@@ -6342,8 +6342,8 @@ impl<'a> Parser<'a> {\n                                          relative_prefix, mod_name, path::MAIN_SEPARATOR);\n         let default_path = dir_path.join(&default_path_str);\n         let secondary_path = dir_path.join(&secondary_path_str);\n-        let default_exists = codemap.file_exists(&default_path);\n-        let secondary_exists = codemap.file_exists(&secondary_path);\n+        let default_exists = source_map.file_exists(&default_path);\n+        let secondary_exists = source_map.file_exists(&secondary_path);\n \n         let result = match (default_exists, secondary_exists) {\n             (true, false) => Ok(ModulePathSuccess {\n@@ -6418,7 +6418,7 @@ impl<'a> Parser<'a> {\n             DirectoryOwnership::UnownedViaMod(_) => None,\n         };\n         let paths = Parser::default_submod_path(\n-                        id, relative, &self.directory.path, self.sess.codemap());\n+                        id, relative, &self.directory.path, self.sess.source_map());\n \n         match self.directory.ownership {\n             DirectoryOwnership::Owned { .. } => {\n@@ -6445,7 +6445,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.diagnostic().struct_span_err(id_sp,\n                     \"cannot declare a new module at this location\");\n                 if !id_sp.is_dummy() {\n-                    let src_path = self.sess.codemap().span_to_filename(id_sp);\n+                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n                     if let FileName::Real(src_path) = src_path {\n                         if let Some(stem) = src_path.file_stem() {\n                             let mut dest_path = src_path.clone();\n@@ -7207,7 +7207,7 @@ impl<'a> Parser<'a> {\n                         sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.sess.codemap().span_to_snippet(ident_sp) {\n+                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(ident_sp) {\n                         err.span_suggestion_with_applicability(\n                             full_sp,\n                             \"if you meant to call a macro, try\","}, {"sha": "3065e795ed81fd8e6f7e33134a09821b83989b5f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@ use ast::{SelfKind, GenericBound, TraitBoundModifier};\n use ast::{Attribute, MacDelimiter, GenericArg};\n use util::parser::{self, AssocOp, Fixity};\n use attr;\n-use codemap::{self, CodeMap, Spanned};\n+use source_map::{self, SourceMap, Spanned};\n use syntax_pos::{self, BytePos};\n use syntax_pos::hygiene::{Mark, SyntaxContext};\n use parse::token::{self, BinOpToken, Token};\n@@ -57,7 +57,7 @@ impl PpAnn for NoAnn {}\n \n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n-    cm: Option<&'a CodeMap>,\n+    cm: Option<&'a SourceMap>,\n     comments: Option<Vec<comments::Comment> >,\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n@@ -84,7 +84,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n /// copy forward.\n-pub fn print_crate<'a>(cm: &'a CodeMap,\n+pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n@@ -118,7 +118,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n }\n \n impl<'a> State<'a> {\n-    pub fn new_from_input(cm: &'a CodeMap,\n+    pub fn new_from_input(cm: &'a SourceMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n                           input: &mut dyn Read,\n@@ -138,7 +138,7 @@ impl<'a> State<'a> {\n             if is_expanded { None } else { Some(lits) })\n     }\n \n-    pub fn new(cm: &'a CodeMap,\n+    pub fn new(cm: &'a SourceMap,\n                out: Box<dyn Write+'a>,\n                ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n@@ -380,7 +380,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, header, Some(name),\n-                   generics, &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n+                   generics, &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -1606,7 +1606,7 @@ impl<'a> State<'a> {\n                     ti.ident,\n                     ty,\n                     default.as_ref().map(|expr| &**expr),\n-                    &codemap::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                    &source_map::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 )?;\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n@@ -1617,7 +1617,7 @@ impl<'a> State<'a> {\n                     ti.ident,\n                     &ti.generics,\n                     sig,\n-                    &codemap::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                    &source_map::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 )?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n@@ -3085,7 +3085,7 @@ impl<'a> State<'a> {\n                       ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n-                      &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n+                      &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         self.end()\n     }\n \n@@ -3185,7 +3185,7 @@ mod tests {\n     use super::*;\n \n     use ast;\n-    use codemap;\n+    use source_map;\n     use syntax_pos;\n     use with_globals;\n \n@@ -3205,7 +3205,7 @@ mod tests {\n                     &decl,\n                     ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n-                        constness: codemap::dummy_spanned(ast::Constness::NotConst),\n+                        constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: ast::IsAsync::NotAsync,\n                         abi: Abi::Rust,\n                     },\n@@ -3222,7 +3222,7 @@ mod tests {\n         with_globals(|| {\n             let ident = ast::Ident::from_str(\"principal_skinner\");\n \n-            let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n+            let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n                 ident,\n                 attrs: Vec::new(),\n                 // making this up as I go.... ?"}, {"sha": "c65931a8577183452e063f0019edb2c7f46463bd", "filename": "src/libsyntax/source_map.rs", "status": "renamed", "additions": 94, "deletions": 92, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The CodeMap tracks all the source code used within a single crate, mapping\n+//! The SourceMap tracks all the source code used within a single crate, mapping\n //! from integer byte positions to the original source code location. Each bit\n //! of source parsed during crate parsing (typically files, in-memory strings,\n //! or various bits of macro expansion) cover a continuous range of bytes in the\n-//! CodeMap and are represented by FileMaps. Byte positions are stored in\n+//! SourceMap and are represented by SourceFiles. Byte positions are stored in\n //! `spans` and used pervasively in the compiler. They are absolute positions\n-//! within the CodeMap, which upon request can be converted to line and column\n+//! within the SourceMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n \n@@ -32,7 +32,7 @@ use std::path::{Path, PathBuf};\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n-use errors::CodeMapper;\n+use errors::SourceMapper;\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n@@ -62,7 +62,7 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n }\n \n // _____________________________________________________________________________\n-// FileMap, MultiByteChar, FileName, FileLines\n+// SourceFile, MultiByteChar, FileName, FileLines\n //\n \n /// An abstraction over the fs operations used by the Parser.\n@@ -102,50 +102,50 @@ impl FileLoader for RealFileLoader {\n     }\n }\n \n-// This is a FileMap identifier that is used to correlate FileMaps between\n+// This is a SourceFile identifier that is used to correlate SourceFiles between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct StableFilemapId(u128);\n \n impl StableFilemapId {\n-    pub fn new(filemap: &FileMap) -> StableFilemapId {\n+    pub fn new(source_file: &SourceFile) -> StableFilemapId {\n         let mut hasher = StableHasher::new();\n \n-        filemap.name.hash(&mut hasher);\n-        filemap.name_was_remapped.hash(&mut hasher);\n-        filemap.unmapped_path.hash(&mut hasher);\n+        source_file.name.hash(&mut hasher);\n+        source_file.name_was_remapped.hash(&mut hasher);\n+        source_file.unmapped_path.hash(&mut hasher);\n \n         StableFilemapId(hasher.finish())\n     }\n }\n \n // _____________________________________________________________________________\n-// CodeMap\n+// SourceMap\n //\n \n-pub(super) struct CodeMapFiles {\n-    pub(super) file_maps: Vec<Lrc<FileMap>>,\n-    stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<FileMap>>\n+pub(super) struct SourceMapFiles {\n+    pub(super) file_maps: Vec<Lrc<SourceFile>>,\n+    stable_id_to_source_file: FxHashMap<StableFilemapId, Lrc<SourceFile>>\n }\n \n-pub struct CodeMap {\n-    pub(super) files: Lock<CodeMapFiles>,\n+pub struct SourceMap {\n+    pub(super) files: Lock<SourceMapFiles>,\n     file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n-    // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n+    // --remap-path-prefix to all SourceFiles allocated within this SourceMap.\n     path_mapping: FilePathMapping,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n     doctest_offset: Option<(FileName, isize)>,\n }\n \n-impl CodeMap {\n-    pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n-        CodeMap {\n-            files: Lock::new(CodeMapFiles {\n+impl SourceMap {\n+    pub fn new(path_mapping: FilePathMapping) -> SourceMap {\n+        SourceMap {\n+            files: Lock::new(SourceMapFiles {\n                 file_maps: Vec::new(),\n-                stable_id_to_filemap: FxHashMap(),\n+                stable_id_to_source_file: FxHashMap(),\n             }),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping,\n@@ -154,21 +154,21 @@ impl CodeMap {\n     }\n \n     pub fn new_doctest(path_mapping: FilePathMapping,\n-                       file: FileName, line: isize) -> CodeMap {\n-        CodeMap {\n+                       file: FileName, line: isize) -> SourceMap {\n+        SourceMap {\n             doctest_offset: Some((file, line)),\n-            ..CodeMap::new(path_mapping)\n+            ..SourceMap::new(path_mapping)\n         }\n \n     }\n \n     pub fn with_file_loader(file_loader: Box<dyn FileLoader + Sync + Send>,\n                             path_mapping: FilePathMapping)\n-                            -> CodeMap {\n-        CodeMap {\n-            files: Lock::new(CodeMapFiles {\n+                            -> SourceMap {\n+        SourceMap {\n+            files: Lock::new(SourceMapFiles {\n                 file_maps: Vec::new(),\n-                stable_id_to_filemap: FxHashMap(),\n+                stable_id_to_source_file: FxHashMap(),\n             }),\n             file_loader: file_loader,\n             path_mapping,\n@@ -184,36 +184,36 @@ impl CodeMap {\n         self.file_loader.file_exists(path)\n     }\n \n-    pub fn load_file(&self, path: &Path) -> io::Result<Lrc<FileMap>> {\n+    pub fn load_file(&self, path: &Path) -> io::Result<Lrc<SourceFile>> {\n         let src = self.file_loader.read_file(path)?;\n         let filename = if let Some((ref name, _)) = self.doctest_offset {\n             name.clone()\n         } else {\n             path.to_owned().into()\n         };\n-        Ok(self.new_filemap(filename, src))\n+        Ok(self.new_source_file(filename, src))\n     }\n \n-    pub fn files(&self) -> LockGuard<Vec<Lrc<FileMap>>> {\n+    pub fn files(&self) -> LockGuard<Vec<Lrc<SourceFile>>> {\n         LockGuard::map(self.files.borrow(), |files| &mut files.file_maps)\n     }\n \n-    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<FileMap>> {\n-        self.files.borrow().stable_id_to_filemap.get(&stable_id).map(|fm| fm.clone())\n+    pub fn source_file_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<SourceFile>> {\n+        self.files.borrow().stable_id_to_source_file.get(&stable_id).map(|fm| fm.clone())\n     }\n \n     fn next_start_pos(&self) -> usize {\n         match self.files.borrow().file_maps.last() {\n             None => 0,\n             // Add one so there is some space between files. This lets us distinguish\n-            // positions in the codemap, even in the presence of zero-length files.\n+            // positions in the source_map, even in the presence of zero-length files.\n             Some(last) => last.end_pos.to_usize() + 1,\n         }\n     }\n \n-    /// Creates a new filemap.\n-    /// This does not ensure that only one FileMap exists per file name.\n-    pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n+    /// Creates a new source_file.\n+    /// This does not ensure that only one SourceFile exists per file name.\n+    pub fn new_source_file(&self, filename: FileName, src: String) -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n         // The path is used to determine the directory for loading submodules and\n@@ -230,7 +230,7 @@ impl CodeMap {\n             },\n             other => (other, false),\n         };\n-        let filemap = Lrc::new(FileMap::new(\n+        let source_file = Lrc::new(SourceFile::new(\n             filename,\n             was_remapped,\n             unmapped_path,\n@@ -240,17 +240,18 @@ impl CodeMap {\n \n         let mut files = self.files.borrow_mut();\n \n-        files.file_maps.push(filemap.clone());\n-        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(source_file.clone());\n+        files.stable_id_to_source_file.insert(StableFilemapId::new(&source_file),\n+                                              source_file.clone());\n \n-        filemap\n+        source_file\n     }\n \n-    /// Allocates a new FileMap representing a source file from an external\n-    /// crate. The source code of such an \"imported filemap\" is not available,\n+    /// Allocates a new SourceFile representing a source file from an external\n+    /// crate. The source code of such an \"imported source_file\" is not available,\n     /// but we still know enough to generate accurate debuginfo location\n     /// information for things inlined from other crates.\n-    pub fn new_imported_filemap(&self,\n+    pub fn new_imported_source_file(&self,\n                                 filename: FileName,\n                                 name_was_remapped: bool,\n                                 crate_of_origin: u32,\n@@ -260,7 +261,7 @@ impl CodeMap {\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>,\n                                 mut file_local_non_narrow_chars: Vec<NonNarrowChar>)\n-                                -> Lrc<FileMap> {\n+                                -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n@@ -278,7 +279,7 @@ impl CodeMap {\n             *swc = *swc + start_pos;\n         }\n \n-        let filemap = Lrc::new(FileMap {\n+        let source_file = Lrc::new(SourceFile {\n             name: filename,\n             name_was_remapped,\n             unmapped_path: None,\n@@ -296,10 +297,11 @@ impl CodeMap {\n \n         let mut files = self.files.borrow_mut();\n \n-        files.file_maps.push(filemap.clone());\n-        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(source_file.clone());\n+        files.stable_id_to_source_file.insert(StableFilemapId::new(&source_file),\n+                                              source_file.clone());\n \n-        filemap\n+        source_file\n     }\n \n     pub fn mk_substr_filename(&self, sp: Span) -> String {\n@@ -326,7 +328,7 @@ impl CodeMap {\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         let chpos = self.bytepos_to_file_charpos(pos);\n         match self.lookup_line(pos) {\n-            Ok(FileMapAndLine { fm: f, line: a }) => {\n+            Ok(SourceFileAndLine { fm: f, line: a }) => {\n                 let line = a + 1; // Line numbers start at 1\n                 let linebpos = f.lines[a];\n                 let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -385,14 +387,14 @@ impl CodeMap {\n         }\n     }\n \n-    // If the relevant filemap is empty, we don't return a line number.\n-    pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Lrc<FileMap>> {\n-        let idx = self.lookup_filemap_idx(pos);\n+    // If the relevant source_file is empty, we don't return a line number.\n+    pub fn lookup_line(&self, pos: BytePos) -> Result<SourceFileAndLine, Lrc<SourceFile>> {\n+        let idx = self.lookup_source_file_idx(pos);\n \n         let f = (*self.files.borrow().file_maps)[idx].clone();\n \n         match f.lookup_line(pos) {\n-            Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n+            Some(line) => Ok(SourceFileAndLine { fm: f, line: line }),\n             None => Err(f)\n         }\n     }\n@@ -463,7 +465,7 @@ impl CodeMap {\n \n     pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo()).file.unmapped_path.clone()\n-            .expect(\"CodeMap::span_to_unmapped_path called for imported FileMap?\")\n+            .expect(\"SourceMap::span_to_unmapped_path called for imported SourceFile?\")\n     }\n \n     pub fn is_multiline(&self, sp: Span) -> bool {\n@@ -541,7 +543,7 @@ impl CodeMap {\n                       local_end.fm.start_pos)\n             }));\n         } else {\n-            self.ensure_filemap_source_present(local_begin.fm.clone());\n+            self.ensure_source_file_source_present(local_begin.fm.clone());\n \n             let start_index = local_begin.pos.to_usize();\n             let end_index = local_end.pos.to_usize();\n@@ -798,7 +800,7 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<FileMap>> {\n+    pub fn get_source_file(&self, filename: &FileName) -> Option<Lrc<SourceFile>> {\n         for fm in self.files.borrow().file_maps.iter() {\n             if *filename == fm.name {\n                 return Some(fm.clone());\n@@ -807,20 +809,20 @@ impl CodeMap {\n         None\n     }\n \n-    /// For a global BytePos compute the local offset within the containing FileMap\n-    pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n-        let idx = self.lookup_filemap_idx(bpos);\n+    /// For a global BytePos compute the local offset within the containing SourceFile\n+    pub fn lookup_byte_offset(&self, bpos: BytePos) -> SourceFileAndBytePos {\n+        let idx = self.lookup_source_file_idx(bpos);\n         let fm = (*self.files.borrow().file_maps)[idx].clone();\n         let offset = bpos - fm.start_pos;\n-        FileMapAndBytePos {fm: fm, pos: offset}\n+        SourceFileAndBytePos {fm: fm, pos: offset}\n     }\n \n-    /// Converts an absolute BytePos to a CharPos relative to the filemap.\n+    /// Converts an absolute BytePos to a CharPos relative to the source_file.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n-        let idx = self.lookup_filemap_idx(bpos);\n+        let idx = self.lookup_source_file_idx(bpos);\n         let map = &(*self.files.borrow().file_maps)[idx];\n \n-        // The number of extra bytes due to multibyte chars in the FileMap\n+        // The number of extra bytes due to multibyte chars in the SourceFile\n         let mut total_extra_bytes = 0;\n \n         for mbc in map.multibyte_chars.iter() {\n@@ -841,13 +843,13 @@ impl CodeMap {\n         CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes as usize)\n     }\n \n-    // Return the index of the filemap (in self.files) which contains pos.\n-    pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n+    // Return the index of the source_file (in self.files) which contains pos.\n+    pub fn lookup_source_file_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &files.file_maps;\n         let count = files.len();\n \n-        // Binary search for the filemap.\n+        // Binary search for the source_file.\n         let mut a = 0;\n         let mut b = count;\n         while b - a > 1 {\n@@ -895,7 +897,7 @@ impl CodeMap {\n     ///\n     /// Attention: The method used is very fragile since it essentially duplicates the work of the\n     /// parser. If you need to use this function or something similar, please consider updating the\n-    /// codemap functions and this function to something more robust.\n+    /// source_map functions and this function to something more robust.\n     pub fn generate_local_type_param_snippet(&self, span: Span) -> Option<(Span, String)> {\n         // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n         // signature\n@@ -941,7 +943,7 @@ impl CodeMap {\n     }\n }\n \n-impl CodeMapper for CodeMap {\n+impl SourceMapper for SourceMap {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         self.lookup_char_pos(pos)\n     }\n@@ -966,7 +968,7 @@ impl CodeMapper for CodeMap {\n         }\n         sp\n     }\n-    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool {\n+    fn ensure_source_file_source_present(&self, file_map: Lrc<SourceFile>) -> bool {\n         file_map.add_external_src(\n             || match file_map.name {\n                 FileName::Real(ref name) => self.file_loader.read_file(name).ok(),\n@@ -1023,13 +1025,13 @@ mod tests {\n     use super::*;\n     use rustc_data_structures::sync::Lrc;\n \n-    fn init_code_map() -> CodeMap {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n-        cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n+    fn init_code_map() -> SourceMap {\n+        let cm = SourceMap::new(FilePathMapping::empty());\n+        cm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n                        \"first line.\\nsecond line\".to_string());\n-        cm.new_filemap(PathBuf::from(\"empty.rs\").into(),\n+        cm.new_source_file(PathBuf::from(\"empty.rs\").into(),\n                        \"\".to_string());\n-        cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n+        cm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n                        \"first line.\\nsecond line\".to_string());\n         cm\n     }\n@@ -1066,7 +1068,7 @@ mod tests {\n \n     #[test]\n     fn t5() {\n-        // Test zero-length filemaps.\n+        // Test zero-length source_files.\n         let cm = init_code_map();\n \n         let loc1 = cm.lookup_char_pos(BytePos(22));\n@@ -1080,12 +1082,12 @@ mod tests {\n         assert_eq!(loc2.col, CharPos(0));\n     }\n \n-    fn init_code_map_mbc() -> CodeMap {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+    fn init_code_map_mbc() -> SourceMap {\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n-        cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n+        cm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n                        \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n-        cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n+        cm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n                        \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n         cm\n     }\n@@ -1110,7 +1112,7 @@ mod tests {\n \n     #[test]\n     fn t7() {\n-        // Test span_to_lines for a span ending at the end of filemap\n+        // Test span_to_lines for a span ending at the end of source_file\n         let cm = init_code_map();\n         let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let file_lines = cm.span_to_lines(span).unwrap();\n@@ -1135,10 +1137,10 @@ mod tests {\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n+        cm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting\n@@ -1156,7 +1158,7 @@ mod tests {\n \n     #[test]\n     fn t8() {\n-        // Test span_to_snippet for a span ending at the end of filemap\n+        // Test span_to_snippet for a span ending at the end of source_file\n         let cm = init_code_map();\n         let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let snippet = cm.span_to_snippet(span);\n@@ -1166,7 +1168,7 @@ mod tests {\n \n     #[test]\n     fn t9() {\n-        // Test span_to_str for a span ending at the end of filemap\n+        // Test span_to_str for a span ending at the end of source_file\n         let cm = init_code_map();\n         let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let sstr =  cm.span_to_string(span);\n@@ -1177,11 +1179,11 @@ mod tests {\n     /// Test failing to merge two spans on different lines\n     #[test]\n     fn span_merging_fail() {\n-        let cm = CodeMap::new(FilePathMapping::empty());\n+        let cm = SourceMap::new(FilePathMapping::empty());\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n-        cm.new_filemap(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_owned());\n+        cm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_owned());\n         let span1 = span_from_selection(inputtext, selection1);\n         let span2 = span_from_selection(inputtext, selection2);\n \n@@ -1190,18 +1192,18 @@ mod tests {\n \n     /// Returns the span corresponding to the `n`th occurrence of\n     /// `substring` in `source_text`.\n-    trait CodeMapExtension {\n+    trait SourceMapExtension {\n         fn span_substr(&self,\n-                    file: &Lrc<FileMap>,\n+                    file: &Lrc<SourceFile>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)\n                     -> Span;\n     }\n \n-    impl CodeMapExtension for CodeMap {\n+    impl SourceMapExtension for SourceMap {\n         fn span_substr(&self,\n-                    file: &Lrc<FileMap>,\n+                    file: &Lrc<SourceFile>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)", "previous_filename": "src/libsyntax/codemap.rs"}, {"sha": "1210f331b285b7c4d7fd820c81076b2800c16e50", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,12 +16,12 @@ use edition::Edition;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use codemap::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n+use source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use ptr::P;\n use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n-/// call to codemap's `is_internal` check.\n+/// call to source_map's `is_internal` check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span) -> Span {\n     let mark = Mark::fresh(Mark::root());"}, {"sha": "988f50b4f0c9ed845d7d5d3ac0cd8386e06ea966", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -20,9 +20,9 @@ use std::slice;\n use std::mem;\n use std::vec;\n use attr::{self, HasAttrs};\n-use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n+use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n-use codemap::{self, CodeMap, ExpnInfo, MacroAttribute, dummy_spanned};\n+use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned};\n use errors;\n use config;\n use entry::{self, EntryPointType};\n@@ -324,7 +324,7 @@ fn generate_test_harness(sess: &ParseSess,\n }\n \n /// Craft a span that will be ignored by the stability lint's\n-/// call to codemap's `is_internal` check.\n+/// call to source_map's `is_internal` check.\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     sp.with_ctxt(cx.ctxt)\n@@ -616,8 +616,8 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n     (item, reexport)\n }\n \n-fn nospan<T>(t: T) -> codemap::Spanned<T> {\n-    codemap::Spanned { node: t, span: DUMMY_SP }\n+fn nospan<T>(t: T) -> source_map::Spanned<T> {\n+    source_map::Spanned { node: t, span: DUMMY_SP }\n }\n \n fn path_node(ids: Vec<Ident>) -> ast::Path {"}, {"sha": "d49965fd93642dd957aa92a56dba3ab5370acce6", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use codemap::{CodeMap, FilePathMapping};\n+use source_map::{SourceMap, FilePathMapping};\n use errors::Handler;\n use errors::emitter::EmitterWriter;\n use std::io;\n@@ -50,8 +50,8 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     with_globals(|| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n-        let code_map = Lrc::new(CodeMap::new(FilePathMapping::empty()));\n-        code_map.new_filemap(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n+        let code_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        code_map.new_source_file(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n \n         let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n         let mut msp = MultiSpan::from_span(primary_span);"}, {"sha": "374154e63333d221ce0f381cc9dfa7414949ebbd", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use ast::{self, Ident};\n-use codemap::FilePathMapping;\n-use parse::{ParseSess, PResult, filemap_to_stream};\n+use source_map::FilePathMapping;\n+use parse::{ParseSess, PResult, source_file_to_stream};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n use ptr::P;\n@@ -21,8 +21,8 @@ use std::path::PathBuf;\n /// Map a string to tts, using a made-up filename:\n pub fn string_to_stream(source_str: String) -> TokenStream {\n     let ps = ParseSess::new(FilePathMapping::empty());\n-    filemap_to_stream(&ps, ps.codemap()\n-                             .new_filemap(PathBuf::from(\"bogofile\").into(), source_str), None)\n+    source_file_to_stream(&ps, ps.source_map()\n+                             .new_source_file(PathBuf::from(\"bogofile\").into(), source_str), None)\n }\n \n /// Map string to parser (via tts)"}, {"sha": "e3bd2ca01310bca7a0bc5bb57642091a9ef669db", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use syntax::ast::*;\n-use syntax::codemap::Spanned;\n+use syntax::source_map::Spanned;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;"}, {"sha": "973ad631b8343928aa84cdbfe648b1540c161a2b", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -14,7 +14,7 @@ use errors::FatalError;\n use proc_macro::{TokenStream, __internal};\n use syntax::ast::{self, ItemKind, Attribute, Mac};\n use syntax::attr::{mark_used, mark_known};\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax::ext::base::*;\n use syntax::visit::Visitor;\n "}, {"sha": "28a2c11ceb1047fc3e876ddd0dddef1c9e059f97", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -198,7 +198,7 @@ use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, respan};\n+use syntax::source_map::{self, respan};\n use syntax::util::move_map::MoveMap;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -1619,7 +1619,7 @@ impl<'a> TraitDef<'a> {\n                         if ident.is_none() {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n-                        codemap::Spanned {\n+                        source_map::Spanned {\n                             span: pat.span.with_ctxt(self.span.ctxt()),\n                             node: ast::FieldPat {\n                                 ident: ident.unwrap(),"}, {"sha": "fa284f4ab0e17bb7623aca19a56f05af614bbafd", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n use syntax::ast::{Expr, GenericParamKind, Generics, Ident, SelfKind, GenericArg};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{respan, DUMMY_SP};\n+use syntax::source_map::{respan, DUMMY_SP};\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax_pos::symbol::keywords;"}, {"sha": "d97c0b14f797a998fa8bff2701b97f412d749b32", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -801,7 +801,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     };\n \n-    let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n+    let is_literal = match ecx.source_map().span_to_snippet(fmt_sp) {\n         Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n         _ => false,\n     };"}, {"sha": "56f28d04e9d5c4bd8bc8f09eb79cbcd851df2867", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -21,7 +21,7 @@\n use rustc_data_structures::small_vec::OneVector;\n \n use syntax::ast;\n-use syntax::codemap::respan;\n+use syntax::source_map::respan;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;"}, {"sha": "ff60262055bf3d5c309ace3506cf5d9cba7b6cf4", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,7 +12,7 @@ use std::panic;\n \n use errors::FatalError;\n \n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax::ext::base::*;\n use syntax::tokenstream::TokenStream;\n use syntax::ext::base;"}, {"sha": "65e175f95df8118e5bfc1c4712785b8c41536d6b", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -14,7 +14,7 @@ use errors;\n \n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::codemap::{ExpnInfo, MacroAttribute, hygiene, respan};\n+use syntax::source_map::{ExpnInfo, MacroAttribute, hygiene, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;"}, {"sha": "e468aaac7a30686d46d640d0581e07d03a10083a", "filename": "src/libsyntax_pos/analyze_source_file.rs", "status": "renamed", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_pos%2Fanalyze_source_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_pos%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fanalyze_source_file.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -12,31 +12,31 @@ use unicode_width::UnicodeWidthChar;\n use super::*;\n \n /// Find all newlines, multi-byte characters, and non-narrow characters in a\n-/// FileMap.\n+/// SourceFile.\n ///\n /// This function will use an SSE2 enhanced implementation if hardware support\n /// is detected at runtime.\n-pub fn analyze_filemap(\n+pub fn analyze_source_file(\n     src: &str,\n-    filemap_start_pos: BytePos)\n+    source_file_start_pos: BytePos)\n     -> (Vec<BytePos>, Vec<MultiByteChar>, Vec<NonNarrowChar>)\n {\n-    let mut lines = vec![filemap_start_pos];\n+    let mut lines = vec![source_file_start_pos];\n     let mut multi_byte_chars = vec![];\n     let mut non_narrow_chars = vec![];\n \n     // Calls the right implementation, depending on hardware support available.\n-    analyze_filemap_dispatch(src,\n-                             filemap_start_pos,\n+    analyze_source_file_dispatch(src,\n+                             source_file_start_pos,\n                              &mut lines,\n                              &mut multi_byte_chars,\n                              &mut non_narrow_chars);\n \n     // The code above optimistically registers a new line *after* each \\n\n-    // it encounters. If that point is already outside the filemap, remove\n+    // it encounters. If that point is already outside the source_file, remove\n     // it again.\n     if let Some(&last_line_start) = lines.last() {\n-        let file_map_end = filemap_start_pos + BytePos::from_usize(src.len());\n+        let file_map_end = source_file_start_pos + BytePos::from_usize(src.len());\n         assert!(file_map_end >= last_line_start);\n         if last_line_start == file_map_end {\n             lines.pop();\n@@ -49,23 +49,23 @@ pub fn analyze_filemap(\n cfg_if! {\n     if #[cfg(all(any(target_arch = \"x86\", target_arch = \"x86_64\"),\n                  not(stage0)))] {\n-        fn analyze_filemap_dispatch(src: &str,\n-                                    filemap_start_pos: BytePos,\n+        fn analyze_source_file_dispatch(src: &str,\n+                                    source_file_start_pos: BytePos,\n                                     lines: &mut Vec<BytePos>,\n                                     multi_byte_chars: &mut Vec<MultiByteChar>,\n                                     non_narrow_chars: &mut Vec<NonNarrowChar>) {\n             if is_x86_feature_detected!(\"sse2\") {\n                 unsafe {\n-                    analyze_filemap_sse2(src,\n-                                         filemap_start_pos,\n+                    analyze_source_file_sse2(src,\n+                                         source_file_start_pos,\n                                          lines,\n                                          multi_byte_chars,\n                                          non_narrow_chars);\n                 }\n             } else {\n-                analyze_filemap_generic(src,\n+                analyze_source_file_generic(src,\n                                         src.len(),\n-                                        filemap_start_pos,\n+                                        source_file_start_pos,\n                                         lines,\n                                         multi_byte_chars,\n                                         non_narrow_chars);\n@@ -78,7 +78,7 @@ cfg_if! {\n         /// function falls back to the generic implementation. Otherwise it uses\n         /// SSE2 intrinsics to quickly find all newlines.\n         #[target_feature(enable = \"sse2\")]\n-        unsafe fn analyze_filemap_sse2(src: &str,\n+        unsafe fn analyze_source_file_sse2(src: &str,\n                                        output_offset: BytePos,\n                                        lines: &mut Vec<BytePos>,\n                                        multi_byte_chars: &mut Vec<MultiByteChar>,\n@@ -169,7 +169,7 @@ cfg_if! {\n                 // The slow path.\n                 // There are control chars in here, fallback to generic decoding.\n                 let scan_start = chunk_index * CHUNK_SIZE + intra_chunk_offset;\n-                intra_chunk_offset = analyze_filemap_generic(\n+                intra_chunk_offset = analyze_source_file_generic(\n                     &src[scan_start .. ],\n                     CHUNK_SIZE - intra_chunk_offset,\n                     BytePos::from_usize(scan_start) + output_offset,\n@@ -182,7 +182,7 @@ cfg_if! {\n             // There might still be a tail left to analyze\n             let tail_start = chunk_count * CHUNK_SIZE + intra_chunk_offset;\n             if tail_start < src.len() {\n-                analyze_filemap_generic(&src[tail_start as usize ..],\n+                analyze_source_file_generic(&src[tail_start as usize ..],\n                                         src.len() - tail_start,\n                                         output_offset + BytePos::from_usize(tail_start),\n                                         lines,\n@@ -193,14 +193,14 @@ cfg_if! {\n     } else {\n \n         // The target (or compiler version) does not support SSE2 ...\n-        fn analyze_filemap_dispatch(src: &str,\n-                                    filemap_start_pos: BytePos,\n+        fn analyze_source_file_dispatch(src: &str,\n+                                    source_file_start_pos: BytePos,\n                                     lines: &mut Vec<BytePos>,\n                                     multi_byte_chars: &mut Vec<MultiByteChar>,\n                                     non_narrow_chars: &mut Vec<NonNarrowChar>) {\n-            analyze_filemap_generic(src,\n+            analyze_source_file_generic(src,\n                                     src.len(),\n-                                    filemap_start_pos,\n+                                    source_file_start_pos,\n                                     lines,\n                                     multi_byte_chars,\n                                     non_narrow_chars);\n@@ -211,7 +211,7 @@ cfg_if! {\n // `scan_len` determines the number of bytes in `src` to scan. Note that the\n // function can read past `scan_len` if a multi-byte character start within the\n // range but extends past it. The overflow is returned by the function.\n-fn analyze_filemap_generic(src: &str,\n+fn analyze_source_file_generic(src: &str,\n                            scan_len: usize,\n                            output_offset: BytePos,\n                            lines: &mut Vec<BytePos>,\n@@ -288,7 +288,7 @@ fn analyze_filemap_generic(src: &str,\n macro_rules! test {\n     (case: $test_name:ident,\n      text: $text:expr,\n-     filemap_start_pos: $filemap_start_pos:expr,\n+     source_file_start_pos: $source_file_start_pos:expr,\n      lines: $lines:expr,\n      multi_byte_chars: $multi_byte_chars:expr,\n      non_narrow_chars: $non_narrow_chars:expr,) => (\n@@ -297,7 +297,7 @@ macro_rules! test {\n     fn $test_name() {\n \n         let (lines, multi_byte_chars, non_narrow_chars) =\n-            analyze_filemap($text, BytePos($filemap_start_pos));\n+            analyze_source_file($text, BytePos($source_file_start_pos));\n \n         let expected_lines: Vec<BytePos> = $lines\n             .into_iter()\n@@ -330,7 +330,7 @@ macro_rules! test {\n test!(\n     case: empty_text,\n     text: \"\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![],\n@@ -339,7 +339,7 @@ test!(\n test!(\n     case: newlines_short,\n     text: \"a\\nc\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0, 2],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![],\n@@ -348,7 +348,7 @@ test!(\n test!(\n     case: newlines_long,\n     text: \"012345678\\nabcdef012345678\\na\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0, 10, 26],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![],\n@@ -357,7 +357,7 @@ test!(\n test!(\n     case: newline_and_multi_byte_char_in_same_chunk,\n     text: \"01234\u03b2789\\nbcdef0123456789abcdef\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0, 11],\n     multi_byte_chars: vec![(5, 2)],\n     non_narrow_chars: vec![],\n@@ -366,7 +366,7 @@ test!(\n test!(\n     case: newline_and_control_char_in_same_chunk,\n     text: \"01234\\u{07}6789\\nbcdef0123456789abcdef\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0, 11],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![(5, 0)],\n@@ -375,7 +375,7 @@ test!(\n test!(\n     case: multi_byte_char_short,\n     text: \"a\u03b2c\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![(1, 2)],\n     non_narrow_chars: vec![],\n@@ -384,7 +384,7 @@ test!(\n test!(\n     case: multi_byte_char_long,\n     text: \"0123456789abc\u0394f012345\u03b2\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![(13, 2), (22, 2)],\n     non_narrow_chars: vec![],\n@@ -393,7 +393,7 @@ test!(\n test!(\n     case: multi_byte_char_across_chunk_boundary,\n     text: \"0123456789abcde\u0394123456789abcdef01234\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![(15, 2)],\n     non_narrow_chars: vec![],\n@@ -402,7 +402,7 @@ test!(\n test!(\n     case: multi_byte_char_across_chunk_boundary_tail,\n     text: \"0123456789abcde\u0394....\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![(15, 2)],\n     non_narrow_chars: vec![],\n@@ -411,7 +411,7 @@ test!(\n test!(\n     case: non_narrow_short,\n     text: \"0\\t2\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![(1, 4)],\n@@ -420,7 +420,7 @@ test!(\n test!(\n     case: non_narrow_long,\n     text: \"01\\t3456789abcdef01234567\\u{07}9\",\n-    filemap_start_pos: 0,\n+    source_file_start_pos: 0,\n     lines: vec![0],\n     multi_byte_chars: vec![],\n     non_narrow_chars: vec![(2, 4), (24, 0)],\n@@ -429,7 +429,7 @@ test!(\n test!(\n     case: output_offset_all,\n     text: \"01\\t345\\n789abc\u0394f01234567\\u{07}9\\nbc\u0394f\",\n-    filemap_start_pos: 1000,\n+    source_file_start_pos: 1000,\n     lines: vec![0 + 1000, 7 + 1000, 27 + 1000],\n     multi_byte_chars: vec![(13 + 1000, 2), (29 + 1000, 2)],\n     non_narrow_chars: vec![(2 + 1000, 4), (24 + 1000, 0)],", "previous_filename": "src/libsyntax_pos/analyze_filemap.rs"}, {"sha": "bd70344b018127992879e1f0684868c91cad8035", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -63,7 +63,7 @@ pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n \n-mod analyze_filemap;\n+mod analyze_source_file;\n \n pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n@@ -162,11 +162,11 @@ impl FileName {\n }\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n-/// are *absolute* positions from the beginning of the codemap, not positions\n-/// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n+/// are *absolute* positions from the beginning of the source_map, not positions\n+/// relative to SourceFiles. Methods on the SourceMap can be used to relate spans back\n /// to the original source.\n /// You must be careful if the span crosses more than one file - you will not be\n-/// able to use many of the functions on spans in codemap and you cannot assume\n+/// able to use many of the functions on spans in source_map and you cannot assume\n /// that the length of the span = hi - lo; there may be space in the BytePos\n /// range between files.\n ///\n@@ -675,16 +675,16 @@ impl From<Vec<Span>> for MultiSpan {\n \n pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n-/// Identifies an offset of a multi-byte character in a FileMap\n+/// Identifies an offset of a multi-byte character in a SourceFile\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n-    /// The absolute offset of the character in the CodeMap\n+    /// The absolute offset of the character in the SourceMap\n     pub pos: BytePos,\n     /// The number of bytes, >=2\n     pub bytes: u8,\n }\n \n-/// Identifies an offset of a non-narrow character in a FileMap\n+/// Identifies an offset of a non-narrow character in a SourceFile\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub enum NonNarrowChar {\n     /// Represents a zero-width character\n@@ -705,7 +705,7 @@ impl NonNarrowChar {\n         }\n     }\n \n-    /// Returns the absolute offset of the character in the CodeMap\n+    /// Returns the absolute offset of the character in the SourceMap\n     pub fn pos(&self) -> BytePos {\n         match *self {\n             NonNarrowChar::ZeroWidth(p) |\n@@ -748,7 +748,7 @@ impl Sub<BytePos> for NonNarrowChar {\n     }\n }\n \n-/// The state of the lazy external source loading mechanism of a FileMap.\n+/// The state of the lazy external source loading mechanism of a SourceFile.\n #[derive(PartialEq, Eq, Clone)]\n pub enum ExternalSource {\n     /// The external source has been loaded already.\n@@ -757,7 +757,7 @@ pub enum ExternalSource {\n     AbsentOk,\n     /// A failed attempt has been made to load the external source.\n     AbsentErr,\n-    /// No external source has to be loaded, since the FileMap represents a local crate.\n+    /// No external source has to be loaded, since the SourceFile represents a local crate.\n     Unneeded,\n }\n \n@@ -777,19 +777,19 @@ impl ExternalSource {\n     }\n }\n \n-/// A single source in the CodeMap.\n+/// A single source in the SourceMap.\n #[derive(Clone)]\n-pub struct FileMap {\n+pub struct SourceFile {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n     /// True if the `name` field above has been modified by --remap-path-prefix\n     pub name_was_remapped: bool,\n     /// The unmapped path of the file that the source came from.\n-    /// Set to `None` if the FileMap was imported from an external crate.\n+    /// Set to `None` if the SourceFile was imported from an external crate.\n     pub unmapped_path: Option<FileName>,\n-    /// Indicates which crate this FileMap was imported from.\n+    /// Indicates which crate this SourceFile was imported from.\n     pub crate_of_origin: u32,\n     /// The complete source code\n     pub src: Option<Lrc<String>>,\n@@ -798,9 +798,9 @@ pub struct FileMap {\n     /// The external source code (used for external crates, which will have a `None`\n     /// value as `self.src`.\n     pub external_src: Lock<ExternalSource>,\n-    /// The start position of this source in the CodeMap\n+    /// The start position of this source in the SourceMap\n     pub start_pos: BytePos,\n-    /// The end position of this source in the CodeMap\n+    /// The end position of this source in the SourceMap\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n     pub lines: Vec<BytePos>,\n@@ -812,9 +812,9 @@ pub struct FileMap {\n     pub name_hash: u128,\n }\n \n-impl Encodable for FileMap {\n+impl Encodable for SourceFile {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"FileMap\", 8, |s| {\n+        s.emit_struct(\"SourceFile\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n@@ -879,10 +879,10 @@ impl Encodable for FileMap {\n     }\n }\n \n-impl Decodable for FileMap {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n+impl Decodable for SourceFile {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n \n-        d.read_struct(\"FileMap\", 8, |d| {\n+        d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n@@ -925,7 +925,7 @@ impl Decodable for FileMap {\n                 d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n                 d.read_struct_field(\"name_hash\", 9, |d| Decodable::decode(d))?;\n-            Ok(FileMap {\n+            Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n                 unmapped_path: None,\n@@ -947,18 +947,18 @@ impl Decodable for FileMap {\n     }\n }\n \n-impl fmt::Debug for FileMap {\n+impl fmt::Debug for SourceFile {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"FileMap({})\", self.name)\n+        write!(fmt, \"SourceFile({})\", self.name)\n     }\n }\n \n-impl FileMap {\n+impl SourceFile {\n     pub fn new(name: FileName,\n                name_was_remapped: bool,\n                unmapped_path: FileName,\n                mut src: String,\n-               start_pos: BytePos) -> FileMap {\n+               start_pos: BytePos) -> SourceFile {\n         remove_bom(&mut src);\n \n         let src_hash = {\n@@ -974,9 +974,9 @@ impl FileMap {\n         let end_pos = start_pos.to_usize() + src.len();\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n-            analyze_filemap::analyze_filemap(&src[..], start_pos);\n+            analyze_source_file::analyze_source_file(&src[..], start_pos);\n \n-        FileMap {\n+        SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1081,8 +1081,8 @@ impl FileMap {\n     }\n \n     /// Find the line containing the given position. The return value is the\n-    /// index into the `lines` array of this FileMap, not the 1-based line\n-    /// number. If the filemap is empty or the position is located before the\n+    /// index into the `lines` array of this SourceFile, not the 1-based line\n+    /// number. If the source_file is empty or the position is located before the\n     /// first line, None is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n         if self.lines.len() == 0 {\n@@ -1141,7 +1141,7 @@ pub trait Pos {\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n-/// is not equivalent to a character offset. The CodeMap will convert BytePos\n+/// is not equivalent to a character offset. The SourceMap will convert BytePos\n /// values to CharPos values as necessary.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);\n@@ -1226,14 +1226,14 @@ impl Sub for CharPos {\n }\n \n // _____________________________________________________________________________\n-// Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n+// Loc, LocWithOpt, SourceFileAndLine, SourceFileAndBytePos\n //\n \n /// A source code location used for error reporting\n #[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n-    pub file: Lrc<FileMap>,\n+    pub file: Lrc<SourceFile>,\n     /// The (1-based) line number\n     pub line: usize,\n     /// The (0-based) column offset\n@@ -1250,14 +1250,14 @@ pub struct LocWithOpt {\n     pub filename: FileName,\n     pub line: usize,\n     pub col: CharPos,\n-    pub file: Option<Lrc<FileMap>>,\n+    pub file: Option<Lrc<SourceFile>>,\n }\n \n // used to be structural records. Better names, anyone?\n #[derive(Debug)]\n-pub struct FileMapAndLine { pub fm: Lrc<FileMap>, pub line: usize }\n+pub struct SourceFileAndLine { pub fm: Lrc<SourceFile>, pub line: usize }\n #[derive(Debug)]\n-pub struct FileMapAndBytePos { pub fm: Lrc<FileMap>, pub pos: BytePos }\n+pub struct SourceFileAndBytePos { pub fm: Lrc<SourceFile>, pub pos: BytePos }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct LineInfo {\n@@ -1272,7 +1272,7 @@ pub struct LineInfo {\n }\n \n pub struct FileLines {\n-    pub file: Lrc<FileMap>,\n+    pub file: Lrc<SourceFile>,\n     pub lines: Vec<LineInfo>\n }\n "}, {"sha": "4b0bc8f02b4f9a5add0feb810e1bf1ccad304678", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::codemap::FilePathMapping;\n+use syntax::source_map::FilePathMapping;\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;"}, {"sha": "75fe6d9511cab3fc9798affec127e31d43db6725", "filename": "src/test/incremental/remove_source_file/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -13,7 +13,7 @@\n \n // revisions:cfail1 cfail2\n \n-// Note that we specify -g so that the FileMaps actually get referenced by the\n+// Note that we specify -g so that the SourceFiles actually get referenced by the\n // incr. comp. cache:\n // compile-flags: -Z query-dep-graph -g\n // compile-pass"}, {"sha": "646a388c8776e505d6836fce1c21f6a09e274f6f", "filename": "src/test/incremental/span_hash_stable/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspan_hash_stable%2Fmain.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // This test makes sure that it doesn't make a difference in which order we are\n-// adding source files to the codemap. The order affects the BytePos values of\n+// adding source files to the source_map. The order affects the BytePos values of\n // the spans and this test makes sure that we handle them correctly by hashing\n // file:line:column instead of raw byte offset.\n "}, {"sha": "d757dd97e94b6218a00bf87b0a4471389ff40a8d", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::codemap;\n+use syntax::source_map;\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n@@ -28,7 +28,7 @@ fn main() {\n }\n \n fn run() {\n-    let ps = syntax::parse::ParseSess::new(codemap::FilePathMapping::empty());\n+    let ps = syntax::parse::ParseSess::new(source_map::FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "4dfecb33c144d003b4dfeccd63ad240813d894f8", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -24,7 +24,7 @@ use rustc::session::config::{Input, Options,\n use rustc_driver::driver::{self, compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n-use syntax::codemap::FileName;\n+use syntax::source_map::FileName;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n use std::path::PathBuf;"}, {"sha": "6a706bdb9b2b6af133d24c63b3da2eaa57afe8f4", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -17,7 +17,7 @@ extern crate syntax;\n use syntax::ast::*;\n use syntax::attr::*;\n use syntax::ast;\n-use syntax::codemap::{FilePathMapping, FileName};\n+use syntax::source_map::{FilePathMapping, FileName};\n use syntax::parse;\n use syntax::parse::{ParseSess, PResult};\n use syntax::parse::new_parser_from_source_str;"}, {"sha": "985f31296fb87f187b16e3abc06fae3d3032dc23", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -22,7 +22,7 @@ use deriving::generic::ty::*;\n \n use rustc_plugin::Registry;\n use syntax::ast::*;\n-use syntax::codemap::Span;\n+use syntax::source_map::Span;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::symbol::Symbol;"}, {"sha": "14e9dbf3a37bca6eba3f21567cca6016160e6d70", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -18,7 +18,7 @@ extern crate rustc_plugin;\n extern crate syntax_pos;\n \n use syntax::ast::{self, Item, MetaItem, ItemKind};\n-use syntax::codemap::DUMMY_SP;\n+use syntax::source_map::DUMMY_SP;\n use syntax::ext::base::*;\n use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};"}, {"sha": "ee424b31636e1b1e5b00ebd3863dfd2c07422eb9", "filename": "src/test/run-pass-fulldeps/mod_dir_path_canonicalized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmod_dir_path_canonicalized.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -16,7 +16,7 @@\n extern crate syntax;\n \n use std::path::Path;\n-use syntax::codemap::FilePathMapping;\n+use syntax::source_map::FilePathMapping;\n use syntax::parse::{self, ParseSess};\n \n #[path = \"mod_dir_simple/test.rs\"]"}, {"sha": "e944ef2b620df39cdfba04c748bf836a57ae6b7b", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -35,8 +35,8 @@ extern crate syntax;\n \n use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::*;\n-use syntax::codemap::{Spanned, DUMMY_SP, FileName};\n-use syntax::codemap::FilePathMapping;\n+use syntax::source_map::{Spanned, DUMMY_SP, FileName};\n+use syntax::source_map::FilePathMapping;\n use syntax::fold::{self, Folder};\n use syntax::parse::{self, ParseSess};\n use syntax::print::pprust;"}, {"sha": "7edb3e0f8a08314191df44482ba9a58d53ca9cea", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::intravisit;\n use rustc::hir::map as hir_map;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n use rustc::ty;\n-use syntax::{ast, codemap};\n+use syntax::{ast, source_map};\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 _: intravisit::FnKind<'tcx>,\n                 _: &'tcx hir::FnDecl,\n                 _: &'tcx hir::Body,\n-                span: codemap::Span,\n+                span: source_map::Span,\n                 id: ast::NodeId) {\n \n         let item = match cx.tcx.hir.get(id) {"}, {"sha": "55fed8693a06517eb4b0d2562d82e9987636071b", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -15,7 +15,7 @@\n extern crate syntax;\n extern crate syntax_pos;\n \n-use syntax::codemap::FilePathMapping;\n+use syntax::source_map::FilePathMapping;\n use syntax::print::pprust::*;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;"}, {"sha": "f06d22d985f49f176f5c88da18d14aab87e7873c", "filename": "src/test/ui/cfg-empty-codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fui%2Fcfg-empty-codemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fui%2Fcfg-empty-codemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-empty-codemap.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that empty codemaps don't ICE (#23301)\n+// Tests that empty source_maps don't ICE (#23301)\n \n // compile-flags: --cfg \"\"\n "}, {"sha": "1efd9ba8e55ebcee3886695c4098184e53da3f09", "filename": "src/test/ui/mod/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fui%2Fmod%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6d50a6ff7685b4aa09172d9d09f03f250da9d/src%2Ftest%2Fui%2Fmod%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod%2Fmod_file_correct_spans.rs?ref=6bf6d50a6ff7685b4aa09172d9d09f03f250da9d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Testing that the codemap is maintained correctly when parsing mods from external files\n+// Testing that the source_map is maintained correctly when parsing mods from external files\n \n mod mod_file_aux;\n "}]}