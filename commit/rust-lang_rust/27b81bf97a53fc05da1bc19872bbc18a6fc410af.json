{"sha": "27b81bf97a53fc05da1bc19872bbc18a6fc410af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YjgxYmY5N2E1M2ZjMDVkYTFiYzE5ODcyYmJjMThhNmZjNDEwYWY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-17T22:57:29Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-30T21:49:08Z"}, "message": "Remove all doc_comment!{} hacks by using #[doc = expr] where needed.", "tree": {"sha": "4aec59b276804d49c4927d3633d9a2cd2fd4ed99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aec59b276804d49c4927d3633d9a2cd2fd4ed99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27b81bf97a53fc05da1bc19872bbc18a6fc410af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27b81bf97a53fc05da1bc19872bbc18a6fc410af", "html_url": "https://github.com/rust-lang/rust/commit/27b81bf97a53fc05da1bc19872bbc18a6fc410af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27b81bf97a53fc05da1bc19872bbc18a6fc410af/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2267046859c9ceb932abc983561d53a117089f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2267046859c9ceb932abc983561d53a117089f6", "html_url": "https://github.com/rust-lang/rust/commit/e2267046859c9ceb932abc983561d53a117089f6"}], "stats": {"total": 9781, "additions": 4642, "deletions": 5139}, "files": [{"sha": "099b98b824d82a0d02f117dc9f72e1495d772010", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -113,6 +113,7 @@\n #![feature(doc_spotlight)]\n #![feature(duration_consts_2)]\n #![feature(duration_saturating_ops)]\n+#![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(intrinsics)]"}, {"sha": "162ed7d1b8dfecd1b5a54b947f6b6172bcb2bb12", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 1987, "deletions": 2219, "changes": 4206, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af"}, {"sha": "6bdfa18fa434ccf8ccf53a9f1499b22bf40c986c", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -23,13 +23,6 @@ macro_rules! unlikely {\n     };\n }\n \n-macro_rules! doc_comment {\n-    ($x:expr, $($tt:tt)*) => {\n-        #[doc = $x]\n-        $($tt)*\n-    };\n-}\n-\n // All these modules are technically private and only exposed for coretests:\n pub mod bignum;\n pub mod dec2flt;\n@@ -95,26 +88,26 @@ depending on the target pointer size.\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n+    int_impl! { i8, i8, u8, 8, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n+    int_impl! { i16, i16, u16, 16, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n+    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n+    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n@@ -123,7 +116,7 @@ impl i64 {\n #[lang = \"i128\"]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n-    170141183460469231731687303715884105727, \"\", \"\", 16,\n+    170141183460469231731687303715884105727, 16,\n     \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n     \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n     \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n@@ -135,15 +128,15 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i16, usize, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n+    int_impl! { isize, i16, usize, 16, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i32, usize, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n+    int_impl! { isize, i32, usize, 32, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n@@ -152,7 +145,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i64, usize, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n+    int_impl! { isize, i64, usize, 64, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n      \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n      \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n@@ -161,7 +154,7 @@ impl isize {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n+    uint_impl! { u8, u8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n \n     /// Checks if the value is within the ASCII range.\n@@ -660,19 +653,19 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { u16, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { u32, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { u64, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n@@ -681,7 +674,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n+    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, 16,\n     \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n     \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n     \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n@@ -694,22 +687,22 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { usize, u16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { usize, u32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { usize, u64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n      \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\","}, {"sha": "947287688292af6e156490206e3b279b483b75d6", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -8,13 +8,6 @@ use super::from_str_radix;\n use super::{IntErrorKind, ParseIntError};\n use crate::intrinsics;\n \n-macro_rules! doc_comment {\n-    ($x:expr, $($tt:tt)*) => {\n-        #[doc = $x]\n-        $($tt)*\n-    };\n-}\n-\n macro_rules! impl_nonzero_fmt {\n     ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n         $(\n@@ -32,24 +25,21 @@ macro_rules! impl_nonzero_fmt {\n macro_rules! nonzero_integers {\n     ( $( #[$stability: meta] $Ty: ident($Int: ty); )+ ) => {\n         $(\n-            doc_comment! {\n-                concat!(\"An integer that is known not to equal zero.\n-\n-This enables some memory layout optimization.\n-For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\n-\n-```rust\n-use std::mem::size_of;\n-assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int),\n-\">());\n-```\"),\n-                #[$stability]\n-                #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-                #[repr(transparent)]\n-                #[rustc_layout_scalar_valid_range_start(1)]\n-                #[rustc_nonnull_optimization_guaranteed]\n-                pub struct $Ty($Int);\n-            }\n+            /// An integer that is known not to equal zero.\n+            ///\n+            /// This enables some memory layout optimization.\n+            #[doc = concat!(\"For example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\")]\n+            ///\n+            /// ```rust\n+            /// use std::mem::size_of;\n+            #[doc = concat!(\"assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int), \">());\")]\n+            /// ```\n+            #[$stability]\n+            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            #[repr(transparent)]\n+            #[rustc_layout_scalar_valid_range_start(1)]\n+            #[rustc_nonnull_optimization_guaranteed]\n+            pub struct $Ty($Int);\n \n             impl $Ty {\n                 /// Creates a non-zero without checking the value.\n@@ -90,13 +80,10 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n             impl From<$Ty> for $Int {\n-                doc_comment! {\n-                    concat!(\n-\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n-                    #[inline]\n-                    fn from(nonzero: $Ty) -> Self {\n-                        nonzero.0\n-                    }\n+                #[doc = concat!(\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\")]\n+                #[inline]\n+                fn from(nonzero: $Ty) -> Self {\n+                    nonzero.0\n                 }\n             }\n "}, {"sha": "0c31bfc149d7f8cedb7919fd660fc0de944e3064", "filename": "library/core/src/num/shells/int_macros.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fshells%2Fint_macros.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -1,49 +1,44 @@\n #![doc(hidden)]\n \n-macro_rules! doc_comment {\n-    ($x:expr, $($tt:tt)*) => {\n-        #[doc = $x]\n-        $($tt)*\n-    };\n-}\n-\n macro_rules! int_module {\n     ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n     ($T:ident, #[$attr:meta]) => (\n-        doc_comment! {\n-            concat!(\"The smallest value that can be represented by this integer type.\n-Use [`\", stringify!($T), \"::MIN\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MIN) instead.\n-\n-# Examples\n-\n-```rust\n-// deprecated way\n-let min = std::\", stringify!($T), \"::MIN;\n-\n-// intended way\n-let min = \", stringify!($T), \"::MIN;\n-```\n-\"),\n-            #[$attr]\n-            pub const MIN: $T = $T::MIN;\n-        }\n-\n-        doc_comment! {\n-            concat!(\"The largest value that can be represented by this integer type.\n-Use [`\", stringify!($T), \"::MAX\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MAX) instead.\n-\n-# Examples\n-\n-```rust\n-// deprecated way\n-let max = std::\", stringify!($T), \"::MAX;\n-\n-// intended way\n-let max = \", stringify!($T), \"::MAX;\n-```\n-\"),\n-            #[$attr]\n-            pub const MAX: $T = $T::MAX;\n-        }\n+        #[doc = concat!(\n+            \"The smallest value that can be represented by this integer type. Use \",\n+            \"[`\", stringify!($T), \"::MIN\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MIN)\",\n+            \"intead.\",\n+        )]\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// // deprecated way\n+        #[doc = concat!(\"let min = std::\", stringify!($T), \"::MIN;\")]\n+        ///\n+        /// // intended way\n+        #[doc = concat!(\"let min = \", stringify!($T), \"::MIN;\")]\n+        /// ```\n+        ///\n+        #[$attr]\n+        pub const MIN: $T = $T::MIN;\n+\n+        #[doc = concat!(\n+            \"The largest value that can be represented by this integer type. Use \",\n+            \"[`\", stringify!($T), \"::MAX\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MAX)\",\n+            \"instead.\",\n+        )]\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```rust\n+        /// // deprecated way\n+        #[doc = concat!(\"let max = std::\", stringify!($T), \"::MAX;\")]\n+        ///\n+        /// // intended way\n+        #[doc = concat!(\"let max = \", stringify!($T), \"::MAX;\")]\n+        /// ```\n+        ///\n+        #[$attr]\n+        pub const MAX: $T = $T::MAX;\n     )\n }"}, {"sha": "8f141a3ff9e97c5db11eb9f1e7fdaa1567e365b0", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 1559, "deletions": 1719, "changes": 3278, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af"}, {"sha": "f1b9dabe7d6b769bc8fb3d746eeccca150cd01fb", "filename": "library/core/src/num/wrapping.rs", "status": "modified", "additions": 365, "deletions": 402, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -403,105 +403,94 @@ wrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n macro_rules! wrapping_int_impl {\n     ($($t:ty)*) => ($(\n         impl Wrapping<$t> {\n-            doc_comment! {\n-                concat!(\"Returns the smallest value that can be represented by this integer type.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(<Wrapping<\", stringify!($t), \">>::MIN, Wrapping(\", stringify!($t), \"::MIN));\n-```\"),\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const MIN: Self = Self(<$t>::MIN);\n-            }\n-\n-            doc_comment! {\n-                concat!(\"Returns the largest value that can be represented by this integer type.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(<Wrapping<\", stringify!($t), \">>::MAX, Wrapping(\", stringify!($t), \"::MAX));\n-```\"),\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const MAX: Self = Self(<$t>::MAX);\n-            }\n-\n-            doc_comment! {\n-                concat!(\"Returns the number of ones in the binary representation of `self`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n+            /// Returns the smallest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MIN, Wrapping(\", stringify!($t), \"::MIN));\")]\n+            /// ```\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const MIN: Self = Self(<$t>::MIN);\n \n-let n = Wrapping(0b01001100\", stringify!($t), \");\n+            /// Returns the largest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Wrapping<\", stringify!($t), \">>::MAX, Wrapping(\", stringify!($t), \"::MAX));\")]\n+            /// ```\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const MAX: Self = Self(<$t>::MAX);\n \n-assert_eq!(n.count_ones(), 3);\n-```\"),\n-                #[inline]\n-                #[doc(alias = \"popcount\")]\n-                #[doc(alias = \"popcnt\")]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn count_ones(self) -> u32 {\n-                    self.0.count_ones()\n-                }\n+            /// Returns the number of ones in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0b01001100\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.count_ones(), 3);\n+            /// ```\n+            #[inline]\n+            #[doc(alias = \"popcount\")]\n+            #[doc(alias = \"popcnt\")]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn count_ones(self) -> u32 {\n+                self.0.count_ones()\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns the number of zeros in the binary representation of `self`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(!0\", stringify!($t), \").count_zeros(), 0);\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn count_zeros(self) -> u32 {\n-                    self.0.count_zeros()\n-                }\n+            /// Returns the number of zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Wrapping(!0\", stringify!($t), \").count_zeros(), 0);\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn count_zeros(self) -> u32 {\n+                self.0.count_zeros()\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns the number of trailing zeros in the binary representation\n-of `self`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(0b0101000\", stringify!($t), \");\n-\n-assert_eq!(n.trailing_zeros(), 3);\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn trailing_zeros(self) -> u32 {\n-                    self.0.trailing_zeros()\n-                }\n+            /// Returns the number of trailing zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0b0101000\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                self.0.trailing_zeros()\n             }\n \n             /// Shifts the bits to the left by a specified amount, `n`,\n@@ -608,150 +597,140 @@ assert_eq!(n.trailing_zeros(), 3);\n                 Wrapping(self.0.reverse_bits())\n             }\n \n-            doc_comment! {\n-                concat!(\"Converts an integer from big endian to the target's endianness.\n-\n-On big endian this is a no-op. On little endian the bytes are\n-swapped.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(0x1A\", stringify!($t), \");\n-\n-if cfg!(target_endian = \\\"big\\\") {\n-    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n)\n-} else {\n-    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\n-}\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn from_be(x: Self) -> Self {\n-                    Wrapping(<$t>::from_be(x.0))\n-                }\n+            /// Converts an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn from_be(x: Self) -> Self {\n+                Wrapping(<$t>::from_be(x.0))\n             }\n \n-            doc_comment! {\n-                concat!(\"Converts an integer from little endian to the target's endianness.\n-\n-On little endian this is a no-op. On big endian the bytes are\n-swapped.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(0x1A\", stringify!($t), \");\n-\n-if cfg!(target_endian = \\\"little\\\") {\n-    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n)\n-} else {\n-    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\n-}\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn from_le(x: Self) -> Self {\n-                    Wrapping(<$t>::from_le(x.0))\n-                }\n+            /// Converts an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn from_le(x: Self) -> Self {\n+                Wrapping(<$t>::from_le(x.0))\n             }\n \n-            doc_comment! {\n-                concat!(\"Converts `self` to big endian from the target's endianness.\n-\n-On big endian this is a no-op. On little endian the bytes are\n-swapped.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(0x1A\", stringify!($t), \");\n-\n-if cfg!(target_endian = \\\"big\\\") {\n-    assert_eq!(n.to_be(), n)\n-} else {\n-    assert_eq!(n.to_be(), n.swap_bytes())\n-}\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn to_be(self) -> Self {\n-                    Wrapping(self.0.to_be())\n-                }\n+            /// Converts `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn to_be(self) -> Self {\n+                Wrapping(self.0.to_be())\n             }\n \n-            doc_comment! {\n-                concat!(\"Converts `self` to little endian from the target's endianness.\n-\n-On little endian this is a no-op. On big endian the bytes are\n-swapped.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(0x1A\", stringify!($t), \");\n-\n-if cfg!(target_endian = \\\"little\\\") {\n-    assert_eq!(n.to_le(), n)\n-} else {\n-    assert_eq!(n.to_le(), n.swap_bytes())\n-}\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn to_le(self) -> Self {\n-                    Wrapping(self.0.to_le())\n-                }\n+            /// Converts `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn to_le(self) -> Self {\n+                Wrapping(self.0.to_le())\n             }\n \n-        doc_comment! {\n-            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(3\", stringify!($t), \").pow(4), Wrapping(81));\n-```\n-\n-Results that are too large are wrapped:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\n-assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub fn pow(self, exp: u32) -> Self {\n-                    Wrapping(self.0.wrapping_pow(exp))\n-                }\n+            /// Raises self to the power of `exp`, using exponentiation by squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Wrapping(3\", stringify!($t), \").pow(4), Wrapping(81));\")]\n+            /// ```\n+            ///\n+            /// Results that are too large are wrapped:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// assert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\n+            /// assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn pow(self, exp: u32) -> Self {\n+                Wrapping(self.0.wrapping_pow(exp))\n             }\n         }\n     )*)\n@@ -762,124 +741,114 @@ wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n macro_rules! wrapping_int_impl_signed {\n     ($($t:ty)*) => ($(\n         impl Wrapping<$t> {\n-            doc_comment! {\n-                concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n-\n-assert_eq!(n.leading_zeros(), 3);\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn leading_zeros(self) -> u32 {\n-                    self.0.leading_zeros()\n-                }\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n             }\n \n-            doc_comment! {\n-                concat!(\"Computes the absolute value of `self`, wrapping around at\n-the boundary of the type.\n-\n-The only case where such wrapping can occur is when one takes the absolute value of the negative\n-minimal value for the type this is a positive value that is too large to represent in the type. In\n-such a case, this function returns `MIN` itself.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\n-assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\n-assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\n-assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub fn abs(self) -> Wrapping<$t> {\n-                    Wrapping(self.0.wrapping_abs())\n-                }\n+            /// Computes the absolute value of `self`, wrapping around at\n+            /// the boundary of the type.\n+            ///\n+            /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n+            /// minimal value for the type this is a positive value that is too large to represent in the type. In\n+            /// such a case, this function returns `MIN` itself.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(\", stringify!($t), \"::MIN).abs(), Wrapping(\", stringify!($t), \"::MIN));\")]\n+            /// assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn abs(self) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_abs())\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns a number representing sign of `self`.\n-\n- - `0` if the number is zero\n- - `1` if the number is positive\n- - `-1` if the number is negative\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(10\", stringify!($t), \").signum(), Wrapping(1));\n-assert_eq!(Wrapping(0\", stringify!($t), \").signum(), Wrapping(0));\n-assert_eq!(Wrapping(-10\", stringify!($t), \").signum(), Wrapping(-1));\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub fn signum(self) -> Wrapping<$t> {\n-                    Wrapping(self.0.signum())\n-                }\n+            /// Returns a number representing sign of `self`.\n+            ///\n+            ///  - `0` if the number is zero\n+            ///  - `1` if the number is positive\n+            ///  - `-1` if the number is negative\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Wrapping(10\", stringify!($t), \").signum(), Wrapping(1));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(0\", stringify!($t), \").signum(), Wrapping(0));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(-10\", stringify!($t), \").signum(), Wrapping(-1));\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn signum(self) -> Wrapping<$t> {\n+                Wrapping(self.0.signum())\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\n-negative.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert!(Wrapping(10\", stringify!($t), \").is_positive());\n-assert!(!Wrapping(-10\", stringify!($t), \").is_positive());\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn is_positive(self) -> bool {\n-                    self.0.is_positive()\n-                }\n+            /// Returns `true` if `self` is positive and `false` if the number is zero or\n+            /// negative.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert!(Wrapping(10\", stringify!($t), \").is_positive());\")]\n+            #[doc = concat!(\"assert!(!Wrapping(-10\", stringify!($t), \").is_positive());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn is_positive(self) -> bool {\n+                self.0.is_positive()\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\n-positive.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert!(Wrapping(-10\", stringify!($t), \").is_negative());\n-assert!(!Wrapping(10\", stringify!($t), \").is_negative());\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn is_negative(self) -> bool {\n-                    self.0.is_negative()\n-                }\n+            /// Returns `true` if `self` is negative and `false` if the number is zero or\n+            /// positive.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert!(Wrapping(-10\", stringify!($t), \").is_negative());\")]\n+            #[doc = concat!(\"assert!(!Wrapping(10\", stringify!($t), \").is_negative());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn is_negative(self) -> bool {\n+                self.0.is_negative()\n             }\n         }\n     )*)\n@@ -890,73 +859,67 @@ wrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n macro_rules! wrapping_int_impl_unsigned {\n     ($($t:ty)*) => ($(\n         impl Wrapping<$t> {\n-            doc_comment! {\n-                concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\n-\n-assert_eq!(n.leading_zeros(), 2);\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub const fn leading_zeros(self) -> u32 {\n-                    self.0.leading_zeros()\n-                }\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"let n = Wrapping(\", stringify!($t), \"::MAX) >> 2;\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 2);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_int_impl)]\n-use std::num::Wrapping;\n-\n-assert!(Wrapping(16\", stringify!($t), \").is_power_of_two());\n-assert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n-                pub fn is_power_of_two(self) -> bool {\n-                    self.0.is_power_of_two()\n-                }\n+            /// Returns `true` if and only if `self == 2^k` for some `k`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert!(Wrapping(16\", stringify!($t), \").is_power_of_two());\")]\n+            #[doc = concat!(\"assert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn is_power_of_two(self) -> bool {\n+                self.0.is_power_of_two()\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns the smallest power of two greater than or equal to `self`.\n-\n-When return value overflows (i.e., `self > (1 << (N-1))` for type\n-`uN`), overflows to `2^N = 0`.\n-\n-# Examples\n-\n-Basic usage:\n-\n-```\n-#![feature(wrapping_next_power_of_two)]\n-use std::num::Wrapping;\n-\n-assert_eq!(Wrapping(2\", stringify!($t), \").next_power_of_two(), Wrapping(2));\n-assert_eq!(Wrapping(3\", stringify!($t), \").next_power_of_two(), Wrapping(4));\n-assert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n-                           reason = \"needs decision on wrapping behaviour\")]\n-                pub fn next_power_of_two(self) -> Self {\n-                    Wrapping(self.0.wrapping_next_power_of_two())\n-                }\n+            /// Returns the smallest power of two greater than or equal to `self`.\n+            ///\n+            /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n+            /// `uN`), overflows to `2^N = 0`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_next_power_of_two)]\n+            /// use std::num::Wrapping;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Wrapping(2\", stringify!($t), \").next_power_of_two(), Wrapping(2));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(3\", stringify!($t), \").next_power_of_two(), Wrapping(4));\")]\n+            #[doc = concat!(\"assert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n+                       reason = \"needs decision on wrapping behaviour\")]\n+            pub fn next_power_of_two(self) -> Self {\n+                Wrapping(self.0.wrapping_next_power_of_two())\n             }\n         }\n     )*)"}, {"sha": "d03c19e51f3fa4eca22579d43895cf9e011b4bfd", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 658, "deletions": 702, "changes": 1360, "blob_url": "https://github.com/rust-lang/rust/blob/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27b81bf97a53fc05da1bc19872bbc18a6fc410af/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=27b81bf97a53fc05da1bc19872bbc18a6fc410af", "patch": "@@ -1372,12 +1372,9 @@ macro_rules! atomic_int {\n \n         #[$stable_from]\n         impl From<$int_type> for $atomic_type {\n-            doc_comment! {\n-                concat!(\n-\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\"),\n-                #[inline]\n-                fn from(v: $int_type) -> Self { Self::new(v) }\n-            }\n+            #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n+            #[inline]\n+            fn from(v: $int_type) -> Self { Self::new(v) }\n         }\n \n         #[$stable_debug]\n@@ -1392,744 +1389,703 @@ macro_rules! atomic_int {\n         unsafe impl Sync for $atomic_type {}\n \n         impl $atomic_type {\n-            doc_comment! {\n-                concat!(\"Creates a new atomic integer.\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n-\n-let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$const_stable]\n-                pub const fn new(v: $int_type) -> Self {\n-                    Self {v: UnsafeCell::new(v)}\n-                }\n+            /// Creates a new atomic integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n+            ///\n+            #[doc = concat!(\"let atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\")]\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$const_stable]\n+            pub const fn new(v: $int_type) -> Self {\n+                Self {v: UnsafeCell::new(v)}\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns a mutable reference to the underlying integer.\n-\n-This is safe because the mutable reference guarantees that no other threads are\n-concurrently accessing the atomic data.\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let mut some_var = \", stringify!($atomic_type), \"::new(10);\n-assert_eq!(*some_var.get_mut(), 10);\n-*some_var.get_mut() = 5;\n-assert_eq!(some_var.load(Ordering::SeqCst), 5);\n-```\"),\n-                #[inline]\n-                #[$stable_access]\n-                pub fn get_mut(&mut self) -> &mut $int_type {\n-                    self.v.get_mut()\n-                }\n+            /// Returns a mutable reference to the underlying integer.\n+            ///\n+            /// This is safe because the mutable reference guarantees that no other threads are\n+            /// concurrently accessing the atomic data.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let mut some_var = \", stringify!($atomic_type), \"::new(10);\")]\n+            /// assert_eq!(*some_var.get_mut(), 10);\n+            /// *some_var.get_mut() = 5;\n+            /// assert_eq!(some_var.load(Ordering::SeqCst), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable_access]\n+            pub fn get_mut(&mut self) -> &mut $int_type {\n+                self.v.get_mut()\n             }\n \n-            doc_comment! {\n-                concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\n-\n-\",\n-if_not_8_bit! {\n-    $int_type,\n-    concat!(\n-        \"**Note:** This function is only available on targets where `\",\n-        stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n-    )\n-},\n-\"\n-\n-# Examples\n-\n-```\n-#![feature(atomic_from_mut)]\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let mut some_int = 123;\n-let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\n-a.store(100, Ordering::Relaxed);\n-assert_eq!(some_int, 100);\n-```\n-                \"),\n-                #[inline]\n-                #[$cfg_align]\n-                #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-                pub fn from_mut(v: &mut $int_type) -> &Self {\n-                    use crate::mem::align_of;\n-                    let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n-                    // SAFETY:\n-                    //  - the mutable reference guarantees unique ownership.\n-                    //  - the alignment of `$int_type` and `Self` is the\n-                    //    same, as promised by $cfg_align and verified above.\n-                    unsafe { &*(v as *mut $int_type as *mut Self) }\n-                }\n+            #[doc = concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\")]\n+            ///\n+            #[doc = if_not_8_bit! {\n+                $int_type,\n+                concat!(\n+                    \"**Note:** This function is only available on targets where `\",\n+                    stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n+                )\n+            }]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// #![feature(atomic_from_mut)]\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            /// let mut some_int = 123;\n+            #[doc = concat!(\"let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\")]\n+            /// a.store(100, Ordering::Relaxed);\n+            /// assert_eq!(some_int, 100);\n+            /// ```\n+            ///\n+            #[inline]\n+            #[$cfg_align]\n+            #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+            pub fn from_mut(v: &mut $int_type) -> &Self {\n+                use crate::mem::align_of;\n+                let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n+                // SAFETY:\n+                //  - the mutable reference guarantees unique ownership.\n+                //  - the alignment of `$int_type` and `Self` is the\n+                //    same, as promised by $cfg_align and verified above.\n+                unsafe { &*(v as *mut $int_type as *mut Self) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Consumes the atomic and returns the contained value.\n-\n-This is safe because passing `self` by value guarantees that no other threads are\n-concurrently accessing the atomic data.\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-assert_eq!(some_var.into_inner(), 5);\n-```\"),\n-                #[inline]\n-                #[$stable_access]\n-                #[rustc_const_unstable(feature = \"const_cell_into_inner\", issue = \"78729\")]\n-                pub const fn into_inner(self) -> $int_type {\n-                    self.v.into_inner()\n-                }\n+            /// Consumes the atomic and returns the contained value.\n+            ///\n+            /// This is safe because passing `self` by value guarantees that no other threads are\n+            /// concurrently accessing the atomic data.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            /// assert_eq!(some_var.into_inner(), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable_access]\n+            #[rustc_const_unstable(feature = \"const_cell_into_inner\", issue = \"78729\")]\n+            pub const fn into_inner(self) -> $int_type {\n+                self.v.into_inner()\n             }\n \n-            doc_comment! {\n-                concat!(\"Loads a value from the atomic integer.\n-\n-`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n-Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n-\n-# Panics\n-\n-Panics if `order` is [`Release`] or [`AcqRel`].\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-\n-assert_eq!(some_var.load(Ordering::Relaxed), 5);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                pub fn load(&self, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_load(self.v.get(), order) }\n-                }\n+            /// Loads a value from the atomic integer.\n+            ///\n+            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+            /// Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is [`Release`] or [`AcqRel`].\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            ///\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn load(&self, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_load(self.v.get(), order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Stores a value into the atomic integer.\n-\n-`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n- Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n-\n-# Panics\n-\n-Panics if `order` is [`Acquire`] or [`AcqRel`].\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-\n-some_var.store(10, Ordering::Relaxed);\n-assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                pub fn store(&self, val: $int_type, order: Ordering) {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_store(self.v.get(), val, order); }\n-                }\n+            /// Stores a value into the atomic integer.\n+            ///\n+            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+            ///  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+            ///\n+            /// # Panics\n+            ///\n+            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            ///\n+            /// some_var.store(10, Ordering::Relaxed);\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            pub fn store(&self, val: $int_type, order: Ordering) {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_store(self.v.get(), val, order); }\n             }\n \n-            doc_comment! {\n-                concat!(\"Stores a value into the atomic integer, returning the previous value.\n-\n-`swap` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-\n-assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_swap(self.v.get(), val, order) }\n-                }\n+            /// Stores a value into the atomic integer, returning the previous value.\n+            ///\n+            /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            ///\n+            /// assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_swap(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Stores a value into the atomic integer if the current value is the same as\n-the `current` value.\n-\n-The return value is always the previous value. If it is equal to `current`, then the\n-value was updated.\n-\n-`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-ordering of this operation. Notice that even when using [`AcqRel`], the operation\n-might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n-Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n-happens, and using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Migrating to `compare_exchange` and `compare_exchange_weak`\n-\n-`compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n-memory orderings:\n-\n-Original | Success | Failure\n--------- | ------- | -------\n-Relaxed  | Relaxed | Relaxed\n-Acquire  | Acquire | Acquire\n-Release  | Release | Relaxed\n-AcqRel   | AcqRel  | Acquire\n-SeqCst   | SeqCst  | SeqCst\n-\n-`compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n-which allows the compiler to generate better assembly code when the compare and swap\n-is used in a loop.\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-\n-assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n-assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-\n-assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n-assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[rustc_deprecated(\n-                    since = \"1.50.0\",\n-                    reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n-                ]\n-                #[$cfg_cas]\n-                pub fn compare_and_swap(&self,\n-                                        current: $int_type,\n-                                        new: $int_type,\n-                                        order: Ordering) -> $int_type {\n-                    match self.compare_exchange(current,\n-                                                new,\n-                                                order,\n-                                                strongest_failure_ordering(order)) {\n-                        Ok(x) => x,\n-                        Err(x) => x,\n-                    }\n+            /// Stores a value into the atomic integer if the current value is the same as\n+            /// the `current` value.\n+            ///\n+            /// The return value is always the previous value. If it is equal to `current`, then the\n+            /// value was updated.\n+            ///\n+            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+            /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+            /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+            /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+            /// happens, and using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Migrating to `compare_exchange` and `compare_exchange_weak`\n+            ///\n+            /// `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n+            /// memory orderings:\n+            ///\n+            /// Original | Success | Failure\n+            /// -------- | ------- | -------\n+            /// Relaxed  | Relaxed | Relaxed\n+            /// Acquire  | Acquire | Acquire\n+            /// Release  | Release | Relaxed\n+            /// AcqRel   | AcqRel  | Acquire\n+            /// SeqCst   | SeqCst  | SeqCst\n+            ///\n+            /// `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n+            /// which allows the compiler to generate better assembly code when the compare and swap\n+            /// is used in a loop.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            ///\n+            /// assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[rustc_deprecated(\n+                since = \"1.50.0\",\n+                reason = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n+            ]\n+            #[$cfg_cas]\n+            pub fn compare_and_swap(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    order: Ordering) -> $int_type {\n+                match self.compare_exchange(current,\n+                                            new,\n+                                            order,\n+                                            strongest_failure_ordering(order)) {\n+                    Ok(x) => x,\n+                    Err(x) => x,\n                 }\n             }\n \n-            doc_comment! {\n-                concat!(\"Stores a value into the atomic integer if the current value is the same as\n-the `current` value.\n-\n-The return value is a result indicating whether the new value was written and\n-containing the previous value. On success this value is guaranteed to be equal to\n-`current`.\n-\n-`compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. `success` describes the required ordering for the\n-read-modify-write operation that takes place if the comparison with `current` succeeds.\n-`failure` describes the required ordering for the load operation that takes place when\n-the comparison fails. Using [`Acquire`] as success ordering makes the store part\n-of this operation [`Relaxed`], and using [`Release`] makes the successful load\n-[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n-and must be equivalent to or weaker than the success ordering.\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let some_var = \", stringify!($atomic_type), \"::new(5);\n-\n-assert_eq!(some_var.compare_exchange(5, 10,\n-                                     Ordering::Acquire,\n-                                     Ordering::Relaxed),\n-           Ok(5));\n-assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-\n-assert_eq!(some_var.compare_exchange(6, 12,\n-                                     Ordering::SeqCst,\n-                                     Ordering::Acquire),\n-           Err(10));\n-assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-```\"),\n-                #[inline]\n-                #[$stable_cxchg]\n-                #[$cfg_cas]\n-                pub fn compare_exchange(&self,\n-                                        current: $int_type,\n-                                        new: $int_type,\n-                                        success: Ordering,\n-                                        failure: Ordering) -> Result<$int_type, $int_type> {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n-                }\n+            /// Stores a value into the atomic integer if the current value is the same as\n+            /// the `current` value.\n+            ///\n+            /// The return value is a result indicating whether the new value was written and\n+            /// containing the previous value. On success this value is guaranteed to be equal to\n+            /// `current`.\n+            ///\n+            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+            /// ordering of this operation. `success` describes the required ordering for the\n+            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+            /// `failure` describes the required ordering for the load operation that takes place when\n+            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n+            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+            /// and must be equivalent to or weaker than the success ordering.\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let some_var = \", stringify!($atomic_type), \"::new(5);\")]\n+            ///\n+            /// assert_eq!(some_var.compare_exchange(5, 10,\n+            ///                                      Ordering::Acquire,\n+            ///                                      Ordering::Relaxed),\n+            ///            Ok(5));\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+            ///\n+            /// assert_eq!(some_var.compare_exchange(6, 12,\n+            ///                                      Ordering::SeqCst,\n+            ///                                      Ordering::Acquire),\n+            ///            Err(10));\n+            /// assert_eq!(some_var.load(Ordering::Relaxed), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            #[$cfg_cas]\n+            pub fn compare_exchange(&self,\n+                                    current: $int_type,\n+                                    new: $int_type,\n+                                    success: Ordering,\n+                                    failure: Ordering) -> Result<$int_type, $int_type> {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Stores a value into the atomic integer if the current value is the same as\n-the `current` value.\n-\n-Unlike [`\", stringify!($atomic_type), \"::compare_exchange`], this function is allowed to spuriously fail even\n-when the comparison succeeds, which can result in more efficient code on some\n-platforms. The return value is a result indicating whether the new value was\n-written and containing the previous value.\n-\n-`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. `success` describes the required ordering for the\n-read-modify-write operation that takes place if the comparison with `current` succeeds.\n-`failure` describes the required ordering for the load operation that takes place when\n-the comparison fails. Using [`Acquire`] as success ordering makes the store part\n-of this operation [`Relaxed`], and using [`Release`] makes the successful load\n-[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n-and must be equivalent to or weaker than the success ordering.\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let val = \", stringify!($atomic_type), \"::new(4);\n-\n-let mut old = val.load(Ordering::Relaxed);\n-loop {\n-    let new = old * 2;\n-    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n-        Ok(_) => break,\n-        Err(x) => old = x,\n-    }\n-}\n-```\"),\n-                #[inline]\n-                #[$stable_cxchg]\n-                #[$cfg_cas]\n-                pub fn compare_exchange_weak(&self,\n-                                             current: $int_type,\n-                                             new: $int_type,\n-                                             success: Ordering,\n-                                             failure: Ordering) -> Result<$int_type, $int_type> {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe {\n-                        atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n-                    }\n+            /// Stores a value into the atomic integer if the current value is the same as\n+            /// the `current` value.\n+            ///\n+            #[doc = concat!(\"Unlike [`\", stringify!($atomic_type), \"::compare_exchange`],\")]\n+            /// this function is allowed to spuriously fail even\n+            /// when the comparison succeeds, which can result in more efficient code on some\n+            /// platforms. The return value is a result indicating whether the new value was\n+            /// written and containing the previous value.\n+            ///\n+            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+            /// ordering of this operation. `success` describes the required ordering for the\n+            /// read-modify-write operation that takes place if the comparison with `current` succeeds.\n+            /// `failure` describes the required ordering for the load operation that takes place when\n+            /// the comparison fails. Using [`Acquire`] as success ordering makes the store part\n+            /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+            /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+            /// and must be equivalent to or weaker than the success ordering.\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let val = \", stringify!($atomic_type), \"::new(4);\")]\n+            ///\n+            /// let mut old = val.load(Ordering::Relaxed);\n+            /// loop {\n+            ///     let new = old * 2;\n+            ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n+            ///         Ok(_) => break,\n+            ///         Err(x) => old = x,\n+            ///     }\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[$stable_cxchg]\n+            #[$cfg_cas]\n+            pub fn compare_exchange_weak(&self,\n+                                         current: $int_type,\n+                                         new: $int_type,\n+                                         success: Ordering,\n+                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe {\n+                    atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                 }\n             }\n \n-            doc_comment! {\n-                concat!(\"Adds to the current value, returning the previous value.\n-\n-This operation wraps around on overflow.\n-\n-`fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(0);\n-assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n-assert_eq!(foo.load(Ordering::SeqCst), 10);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_add(self.v.get(), val, order) }\n-                }\n+            /// Adds to the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n+            ///\n+            /// `fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0);\")]\n+            /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_add(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Subtracts from the current value, returning the previous value.\n-\n-This operation wraps around on overflow.\n-\n-`fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(20);\n-assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n-assert_eq!(foo.load(Ordering::SeqCst), 10);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_sub(self.v.get(), val, order) }\n-                }\n+            /// Subtracts from the current value, returning the previous value.\n+            ///\n+            /// This operation wraps around on overflow.\n+            ///\n+            /// `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(20);\")]\n+            /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 10);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_sub(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Bitwise \\\"and\\\" with the current value.\n-\n-Performs a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(0b101101);\n-assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n-assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_and(self.v.get(), val, order) }\n-                }\n+            /// Bitwise \"and\" with the current value.\n+            ///\n+            /// Performs a bitwise \"and\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n+            /// assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_and(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Bitwise \\\"nand\\\" with the current value.\n-\n-Performs a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"\n-use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(0x13);\n-assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n-assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n-```\"),\n-                #[inline]\n-                #[$stable_nand]\n-                #[$cfg_cas]\n-                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_nand(self.v.get(), val, order) }\n-                }\n+            /// Bitwise \"nand\" with the current value.\n+            ///\n+            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0x13);\")]\n+            /// assert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n+            /// ```\n+            #[inline]\n+            #[$stable_nand]\n+            #[$cfg_cas]\n+            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_nand(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Bitwise \\\"or\\\" with the current value.\n-\n-Performs a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(0b101101);\n-assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n-assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_or(self.v.get(), val, order) }\n-                }\n+            /// Bitwise \"or\" with the current value.\n+            ///\n+            /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n+            /// assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_or(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Bitwise \\\"xor\\\" with the current value.\n-\n-Performs a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(0b101101);\n-assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n-assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n-```\"),\n-                #[inline]\n-                #[$stable]\n-                #[$cfg_cas]\n-                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { atomic_xor(self.v.get(), val, order) }\n-                }\n+            /// Bitwise \"xor\" with the current value.\n+            ///\n+            /// Performs a bitwise \"xor\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(0b101101);\")]\n+            /// assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n+            /// ```\n+            #[inline]\n+            #[$stable]\n+            #[$cfg_cas]\n+            pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { atomic_xor(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Fetches the value, and applies a function to it that returns an optional\n-new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n-`Err(previous_value)`.\n-\n-Note: This may call the function multiple times if the value has been changed from other threads in\n-the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n-only once to the stored value.\n-\n-`fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n-The first describes the required ordering for when the operation finally succeeds while the second\n-describes the required ordering for loads. These correspond to the success and failure orderings of\n-[`\", stringify!($atomic_type), \"::compare_exchange`] respectively.\n-\n-Using [`Acquire`] as success ordering makes the store part\n-of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n-[`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n-and must be equivalent to or weaker than the success ordering.\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```rust\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let x = \", stringify!($atomic_type), \"::new(7);\n-assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n-assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n-assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n-assert_eq!(x.load(Ordering::SeqCst), 9);\n-```\"),\n-                #[inline]\n-                #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n-                #[$cfg_cas]\n-                pub fn fetch_update<F>(&self,\n-                                       set_order: Ordering,\n-                                       fetch_order: Ordering,\n-                                       mut f: F) -> Result<$int_type, $int_type>\n-                where F: FnMut($int_type) -> Option<$int_type> {\n-                    let mut prev = self.load(fetch_order);\n-                    while let Some(next) = f(prev) {\n-                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n-                            x @ Ok(_) => return x,\n-                            Err(next_prev) => prev = next_prev\n-                        }\n+            /// Fetches the value, and applies a function to it that returns an optional\n+            /// new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n+            /// `Err(previous_value)`.\n+            ///\n+            /// Note: This may call the function multiple times if the value has been changed from other threads in\n+            /// the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+            /// only once to the stored value.\n+            ///\n+            /// `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n+            /// The first describes the required ordering for when the operation finally succeeds while the second\n+            /// describes the required ordering for loads. These correspond to the success and failure orderings of\n+            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange`]\")]\n+            /// respectively.\n+            ///\n+            /// Using [`Acquire`] as success ordering makes the store part\n+            /// of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n+            /// [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+            /// and must be equivalent to or weaker than the success ordering.\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let x = \", stringify!($atomic_type), \"::new(7);\")]\n+            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n+            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n+            /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n+            /// assert_eq!(x.load(Ordering::SeqCst), 9);\n+            /// ```\n+            #[inline]\n+            #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n+            #[$cfg_cas]\n+            pub fn fetch_update<F>(&self,\n+                                   set_order: Ordering,\n+                                   fetch_order: Ordering,\n+                                   mut f: F) -> Result<$int_type, $int_type>\n+            where F: FnMut($int_type) -> Option<$int_type> {\n+                let mut prev = self.load(fetch_order);\n+                while let Some(next) = f(prev) {\n+                    match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                        x @ Ok(_) => return x,\n+                        Err(next_prev) => prev = next_prev\n                     }\n-                    Err(prev)\n                 }\n+                Err(prev)\n             }\n \n-            doc_comment! {\n-                concat!(\"Maximum with the current value.\n-\n-Finds the maximum of the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(23);\n-assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n-assert_eq!(foo.load(Ordering::SeqCst), 42);\n-```\n-\n-If you want to obtain the maximum value in one step, you can use the following:\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(23);\n-let bar = 42;\n-let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n-assert!(max_foo == 42);\n-```\"),\n-                #[inline]\n-                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n-                #[$cfg_cas]\n-                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { $max_fn(self.v.get(), val, order) }\n-                }\n+            /// Maximum with the current value.\n+            ///\n+            /// Finds the maximum of the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n+            /// assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), 42);\n+            /// ```\n+            ///\n+            /// If you want to obtain the maximum value in one step, you can use the following:\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n+            /// let bar = 42;\n+            /// let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+            /// assert!(max_foo == 42);\n+            /// ```\n+            #[inline]\n+            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n+            #[$cfg_cas]\n+            pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { $max_fn(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Minimum with the current value.\n-\n-Finds the minimum of the current value and the argument `val`, and\n-sets the new value to the result.\n-\n-Returns the previous value.\n-\n-`fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n-of this operation. All ordering modes are possible. Note that using\n-[`Acquire`] makes the store part of this operation [`Relaxed`], and\n-using [`Release`] makes the load part [`Relaxed`].\n-\n-**Note**: This method is only available on platforms that support atomic\n-operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n-\n-# Examples\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(23);\n-assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n-assert_eq!(foo.load(Ordering::Relaxed), 23);\n-assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n-assert_eq!(foo.load(Ordering::Relaxed), 22);\n-```\n-\n-If you want to obtain the minimum value in one step, you can use the following:\n-\n-```\n-\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n-\n-let foo = \", stringify!($atomic_type), \"::new(23);\n-let bar = 12;\n-let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n-assert_eq!(min_foo, 12);\n-```\"),\n-                #[inline]\n-                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n-                #[$cfg_cas]\n-                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n-                    // SAFETY: data races are prevented by atomic intrinsics.\n-                    unsafe { $min_fn(self.v.get(), val, order) }\n-                }\n+            /// Minimum with the current value.\n+            ///\n+            /// Finds the minimum of the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// `fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n+            /// of this operation. All ordering modes are possible. Note that using\n+            /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+            /// using [`Release`] makes the load part [`Relaxed`].\n+            ///\n+            /// **Note**: This method is only available on platforms that support atomic operations on\n+            #[doc = concat!(\"[`\", $s_int_type, \"`](\", $int_ref, \").\")]\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n+            /// assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+            /// assert_eq!(foo.load(Ordering::Relaxed), 23);\n+            /// assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+            /// assert_eq!(foo.load(Ordering::Relaxed), 22);\n+            /// ```\n+            ///\n+            /// If you want to obtain the minimum value in one step, you can use the following:\n+            ///\n+            /// ```\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\")]\n+            ///\n+            #[doc = concat!(\"let foo = \", stringify!($atomic_type), \"::new(23);\")]\n+            /// let bar = 12;\n+            /// let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+            /// assert_eq!(min_foo, 12);\n+            /// ```\n+            #[inline]\n+            #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n+            #[$cfg_cas]\n+            pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                // SAFETY: data races are prevented by atomic intrinsics.\n+                unsafe { $min_fn(self.v.get(), val, order) }\n             }\n \n-            doc_comment! {\n-                concat!(\"Returns a mutable pointer to the underlying integer.\n-\n-Doing non-atomic reads and writes on the resulting integer can be a data race.\n-This method is mostly useful for FFI, where the function signature may use\n-`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\n-\n-Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n-atomic types work with interior mutability. All modifications of an atomic change the value\n-through a shared reference, and can do so safely as long as they use atomic operations. Any\n-use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n-restriction: operations on it must be atomic.\n-\n-# Examples\n-\n-```ignore (extern-declaration)\n-# fn main() {\n-\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n-\n-extern {\n-    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\n-}\n-\n-let mut atomic = \", stringify!($atomic_type), \"::new(1);\n-\",\n-// SAFETY: Safe as long as `my_atomic_op` is atomic.\n-\"unsafe {\n-    my_atomic_op(atomic.as_mut_ptr());\n-}\n-# }\n-```\"),\n-                #[inline]\n-                #[unstable(feature = \"atomic_mut_ptr\",\n-                       reason = \"recently added\",\n-                       issue = \"66893\")]\n-                pub fn as_mut_ptr(&self) -> *mut $int_type {\n-                    self.v.get()\n-                }\n+            /// Returns a mutable pointer to the underlying integer.\n+            ///\n+            /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n+            /// This method is mostly useful for FFI, where the function signature may use\n+            #[doc = concat!(\"`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\")]\n+            ///\n+            /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n+            /// atomic types work with interior mutability. All modifications of an atomic change the value\n+            /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n+            /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n+            /// restriction: operations on it must be atomic.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```ignore (extern-declaration)\n+            /// # fn main() {\n+            #[doc = concat!($extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\")]\n+            ///\n+            /// extern {\n+            #[doc = concat!(\"    fn my_atomic_op(arg: *mut \", stringify!($int_type), \");\")]\n+            /// }\n+            ///\n+            #[doc = concat!(\"let mut atomic = \", stringify!($atomic_type), \"::new(1);\")]\n+            ///\n+            // SAFETY: Safe as long as `my_atomic_op` is atomic.\n+            /// unsafe {\n+            ///     my_atomic_op(atomic.as_mut_ptr());\n+            /// }\n+            /// # }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"atomic_mut_ptr\",\n+                   reason = \"recently added\",\n+                   issue = \"66893\")]\n+            pub fn as_mut_ptr(&self) -> *mut $int_type {\n+                self.v.get()\n             }\n         }\n     }"}]}