{"sha": "daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjVlNmY2ZjRiMjY4YjcwYmZkMGIwMzIyNWNhZTkwOWRjZDM3NGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-31T20:25:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:49Z"}, "message": "librustc: De-`@str` resolve", "tree": {"sha": "7592e0efcc95e013e7ed5b96fba53556a9737bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7592e0efcc95e013e7ed5b96fba53556a9737bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "html_url": "https://github.com/rust-lang/rust/commit/daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf5e6f6f4b268b70bfd0b03225cae909dcd374c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "986937425636c3174dfe11bb6309865e8a1e0350", "url": "https://api.github.com/repos/rust-lang/rust/commits/986937425636c3174dfe11bb6309865e8a1e0350", "html_url": "https://github.com/rust-lang/rust/commit/986937425636c3174dfe11bb6309865e8a1e0350"}], "stats": {"total": 80, "additions": 47, "deletions": 33}, "files": [{"sha": "261544adfd1f9d8efa4e8b6c219b168beec57519", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5e6f6f4b268b70bfd0b03225cae909dcd374c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5e6f6f4b268b70bfd0b03225cae909dcd374c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "patch": "@@ -490,7 +490,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     exp: &middle::resolve::Export2) {\n     match ecx.tcx.items.find(exp.def_id.node) {\n         Some(ast_map::NodeItem(item, path)) => {\n-            let original_name = ecx.tcx.sess.str_of(item.ident);\n+            let original_name = token::get_ident(item.ident.name);\n \n             //\n             // We don't need to reexport static methods on items\n@@ -502,7 +502,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             // encoded metadata for static methods relative to Bar,\n             // but not yet for Foo.\n             //\n-            if mod_path != *path || exp.name != original_name {\n+            if mod_path != *path || original_name.get() != exp.name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n                         debug!(\"(encode reexported static methods) {} \\"}, {"sha": "26e04110a7b49a4f11aecb5bacf9a6830da3b497", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/daf5e6f6f4b268b70bfd0b03225cae909dcd374c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5e6f6f4b268b70bfd0b03225cae909dcd374c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=daf5e6f6f4b268b70bfd0b03225cae909dcd374c", "patch": "@@ -20,9 +20,8 @@ use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n+use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n-use syntax::parse::token::{IdentInterner, interner_get};\n-use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::opt_vec::OptVec;\n@@ -53,7 +52,7 @@ pub type TraitMap = HashMap<NodeId,@RefCell<~[DefId]>>;\n pub type ExportMap2 = @RefCell<HashMap<NodeId, ~[Export2]>>;\n \n pub struct Export2 {\n-    name: @str,        // The name of the target.\n+    name: ~str,        // The name of the target.\n     def_id: DefId,     // The definition of the target.\n }\n \n@@ -2114,24 +2113,26 @@ impl Resolver {\n     }\n \n     fn import_directive_subclass_to_str(&mut self,\n-                                            subclass: ImportDirectiveSubclass)\n-                                            -> @str {\n+                                        subclass: ImportDirectiveSubclass)\n+                                        -> ~str {\n         match subclass {\n-            SingleImport(_target, source) => self.session.str_of(source),\n-            GlobImport => @\"*\"\n+            SingleImport(_target, source) => {\n+                self.session.str_of(source).to_str()\n+            }\n+            GlobImport => ~\"*\"\n         }\n     }\n \n     fn import_path_to_str(&mut self,\n-                              idents: &[Ident],\n-                              subclass: ImportDirectiveSubclass)\n-                              -> @str {\n+                          idents: &[Ident],\n+                          subclass: ImportDirectiveSubclass)\n+                          -> ~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n             (format!(\"{}::{}\",\n-                  self.idents_to_str(idents),\n-                  self.import_directive_subclass_to_str(subclass))).to_managed()\n+                     self.idents_to_str(idents),\n+                     self.import_directive_subclass_to_str(subclass)))\n         }\n     }\n \n@@ -2584,7 +2585,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                     to `{}`\",\n-                   interner_get(name),\n+                   token::get_ident(name).get().to_str(),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_));\n \n@@ -3354,10 +3355,10 @@ impl Resolver {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n-                       interner_get(name),\n+                       token::get_ident(name).get().to_str(),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n-                    name: interner_get(name),\n+                    name: token::get_ident(name).get().to_str(),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -3380,7 +3381,7 @@ impl Resolver {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n-                               interner_get(*name));\n+                               token::get_ident(*name).get().to_str());\n                         self.add_exports_of_namebindings(exports2,\n                                                          *name,\n                                                          target.bindings,\n@@ -4155,31 +4156,37 @@ impl Resolver {\n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n+                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         p.span,\n                         format!(\"variable `{}` from pattern \\\\#1 is \\\n                                   not bound in pattern \\\\#{}\",\n-                             interner_get(key), i + 1));\n+                                string.get(),\n+                                i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n+                        let string = token::get_ident(key);\n                         self.resolve_error(\n                             binding_i.span,\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern \\\\#{} than in pattern \\\\#1\",\n-                                 interner_get(key), i + 1));\n+                                    string.get(),\n+                                    i + 1));\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n+                    let string = token::get_ident(key);\n                     self.resolve_error(\n                         binding.span,\n                         format!(\"variable `{}` from pattern \\\\#{} is \\\n                                   not bound in pattern \\\\#1\",\n-                             interner_get(key), i + 1));\n+                                string.get(),\n+                                i + 1));\n                 }\n             }\n         }\n@@ -4371,9 +4378,10 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4382,17 +4390,19 @@ impl Resolver {\n                             self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n+                            let string = token::get_ident(renamed);\n                             self.resolve_error(pattern.span,\n                                                   format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                       interner_get(renamed)));\n+                                                          string.get()));\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4406,8 +4416,9 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n+                            let string = token::get_ident(renamed);\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   interner_get(renamed));\n+                                   string.get());\n \n                             let def = match mode {\n                                 RefutableMode => {\n@@ -5009,10 +5020,10 @@ impl Resolver {\n     }\n \n     fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n-                                -> Option<@str> {\n+                                -> Option<~str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[@str] = ~[];\n+        let mut maybes: ~[~str] = ~[];\n         let mut values: ~[uint] = ~[];\n \n         let mut j = {\n@@ -5024,14 +5035,15 @@ impl Resolver {\n             let value_ribs = this.value_ribs.borrow();\n             let bindings = value_ribs.get()[j].bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n-                maybes.push(interner_get(k));\n+                let string = token::get_ident(k);\n+                maybes.push(string.get().to_str());\n                 values.push(uint::MAX);\n             }\n         }\n \n         let mut smallest = 0;\n-        for (i, &other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other);\n+        for (i, other) in maybes.iter().enumerate() {\n+            values[i] = name.lev_distance(*other);\n \n             if values[i] <= values[smallest] {\n                 smallest = i;\n@@ -5190,7 +5202,9 @@ impl Resolver {\n                         self.resolve_error(expr.span,\n                                               format!(\"use of undeclared label \\\n                                                    `{}`\",\n-                                                   interner_get(label))),\n+                                                   token::get_ident(label)\n+                                                    .get()\n+                                                    .to_str())),\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // FIXME: is AllPublic correct?\n                         self.record_def(expr.id, (def, AllPublic))\n@@ -5510,7 +5524,7 @@ impl Resolver {\n         self.populate_module_if_necessary(module_);\n         let children = module_.children.borrow();\n         for (&name, _) in children.get().iter() {\n-            debug!(\"* {}\", interner_get(name));\n+            debug!(\"* {}\", token::get_ident(name).get().to_str());\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5534,7 +5548,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", interner_get(*name),\n+            debug!(\"* {}:{}{}\", token::get_ident(*name).get().to_str(),\n                    value_repr, type_repr);\n         }\n     }"}]}