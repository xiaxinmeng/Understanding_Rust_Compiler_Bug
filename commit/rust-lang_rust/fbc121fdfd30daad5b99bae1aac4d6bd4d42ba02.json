{"sha": "fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "node_id": "C_kwDOAAsO6NoAKGZiYzEyMWZkZmQzMGRhYWQ1Yjk5YmFlMWFhYzRkNmJkNGQ0MmJhMDI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-11T14:43:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-11T14:43:11Z"}, "message": "Rollup merge of #104363 - WaffleLapkin:bonk_box_new, r=Nilstrieb\n\nMake `unused_allocation` lint against `Box::new` too\n\nPreviously it only linted against `box` syntax, which likely won't ever be stabilized, which is pretty useless. Even now I'm not sure if it's a meaningful lint, but it's at least something :shrug:\n\nThis means that code like the following will be linted against:\n```rust\nBox::new([1, 2, 3]).len();\nf(&Box::new(1)); // where f : &i32 -> ()\n```\nThe lint works by checking if a `Box::new` (or `box`) expression has an a borrow adjustment, meaning that the code that first stores the box in a variable won't be linted against:\n```rust\nlet boxed = Box::new([1, 2, 3]); // no lint\nboxed.len();\n```", "tree": {"sha": "20a69adee2d22412e2e043ff363156dde11ef4f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a69adee2d22412e2e043ff363156dde11ef4f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkDJN/CRBK7hj4Ov3rIwAArt4IAEKFEDlvqqgT5GjIPmkCmS7e\n3gVkKsdD/d0bsXE5OJv/OhUHDXt8wktuc9xq8/Syd4/iTR2HhJck+70lHoLNY9Fh\nE5kQeqPdgbpD3r7XzMoTiAvNSoguOVus5lVNPPatsTDZBDPFadpd4m/gfKwilG6h\nOWBzsSd1MaR1tFFAKf4FR1F3QRhu/mS+ASTJPatFiTUaBiazmoLD0F5Oyh2lQKX/\n8sfF0eyB91sFrw3Ioj36qKUJhOppoFT9rwyRprPwXNt3J6xmPuMKn6+xMP2S5ZNY\nBp1uyAOZ6K1lAIGfMWBtLmkDz4K68TF9AfSbQPKzq157x7tSgIQtvnwGP7mP8ys=\n=Ak+C\n-----END PGP SIGNATURE-----\n", "payload": "tree 20a69adee2d22412e2e043ff363156dde11ef4f5\nparent e350fe4e608b653da47e8012d13ef701613e717b\nparent a90abd64fbb0764007d93d60823161f05f564259\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678545791 +0100\ncommitter GitHub <noreply@github.com> 1678545791 +0100\n\nRollup merge of #104363 - WaffleLapkin:bonk_box_new, r=Nilstrieb\n\nMake `unused_allocation` lint against `Box::new` too\n\nPreviously it only linted against `box` syntax, which likely won't ever be stabilized, which is pretty useless. Even now I'm not sure if it's a meaningful lint, but it's at least something :shrug:\n\nThis means that code like the following will be linted against:\n```rust\nBox::new([1, 2, 3]).len();\nf(&Box::new(1)); // where f : &i32 -> ()\n```\nThe lint works by checking if a `Box::new` (or `box`) expression has an a borrow adjustment, meaning that the code that first stores the box in a variable won't be linted against:\n```rust\nlet boxed = Box::new([1, 2, 3]); // no lint\nboxed.len();\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "html_url": "https://github.com/rust-lang/rust/commit/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e350fe4e608b653da47e8012d13ef701613e717b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e350fe4e608b653da47e8012d13ef701613e717b", "html_url": "https://github.com/rust-lang/rust/commit/e350fe4e608b653da47e8012d13ef701613e717b"}, {"sha": "a90abd64fbb0764007d93d60823161f05f564259", "url": "https://api.github.com/repos/rust-lang/rust/commits/a90abd64fbb0764007d93d60823161f05f564259", "html_url": "https://github.com/rust-lang/rust/commit/a90abd64fbb0764007d93d60823161f05f564259"}], "stats": {"total": 98, "additions": 59, "deletions": 39}, "files": [{"sha": "2ba365e298f587ffe80246481eb804271c1e1753", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -1349,9 +1349,8 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n-    /// #![feature(box_syntax)]\n     /// fn main() {\n-    ///     let a = (box [1, 2, 3]).len();\n+    ///     let a = Box::new([1, 2, 3]).len();\n     /// }\n     /// ```\n     ///\n@@ -1373,6 +1372,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Box(_) => {}\n+            hir::ExprKind::Call(path_expr, [_])\n+                if let hir::ExprKind::Path(qpath) = &path_expr.kind\n+                && let Some(did) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()\n+                && cx.tcx.is_diagnostic_item(sym::box_new, did)\n+                => {}\n             _ => return,\n         }\n "}, {"sha": "bf27bd6c5ad4233c83de8130ea281bf4e5d1e71e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -429,6 +429,7 @@ symbols! {\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         box_free,\n+        box_new,\n         box_patterns,\n         box_syntax,\n         bpf_target_feature,"}, {"sha": "241b11c3f5f5219650c8f534156426eca0be8364", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -214,6 +214,7 @@ impl<T> Box<T> {\n     #[inline(always)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n+    #[rustc_diagnostic_item = \"box_new\"]\n     pub fn new(x: T) -> Self {\n         #[rustc_box]\n         Box::new(x)"}, {"sha": "b1d3a9fa8ac9035239a7aae6cb5d3a530d3e6cf3", "filename": "library/alloc/src/tests.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/library%2Falloc%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/library%2Falloc%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ftests.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -4,7 +4,6 @@ use core::any::Any;\n use core::clone::Clone;\n use core::convert::TryInto;\n use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n \n@@ -15,32 +14,25 @@ fn test_owned_clone() {\n     assert!(a == b);\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n struct Test;\n \n #[test]\n fn any_move() {\n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    match a.downcast::<i32>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(8));\n-        }\n-        Err(..) => panic!(),\n-    }\n-    match b.downcast::<Test>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(Test));\n-        }\n-        Err(..) => panic!(),\n-    }\n+    let a: Box<i32> = a.downcast::<i32>().unwrap();\n+    assert_eq!(*a, 8);\n+\n+    let b: Box<Test> = b.downcast::<Test>().unwrap();\n+    assert_eq!(*b, Test);\n \n     let a = Box::new(8) as Box<dyn Any>;\n     let b = Box::new(Test) as Box<dyn Any>;\n \n-    assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<i32>>().is_err());\n+    assert!(a.downcast::<Box<i32>>().is_err());\n+    assert!(b.downcast::<Box<Test>>().is_err());\n }\n \n #[test]"}, {"sha": "43c8a0a23fb5bafa6b7003775fb113e109692bcd", "filename": "tests/ui/issues/issue-3029.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fissues%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fissues%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-3029.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -2,9 +2,7 @@\n // error-pattern:so long\n // ignore-emscripten no processes\n \n-#![allow(unused_allocation)]\n #![allow(unreachable_code)]\n-#![allow(unused_variables)]\n \n fn main() {\n     let mut x = Vec::new();"}, {"sha": "5b91aaf9ea5541db509a26ff361c5880038275c6", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "25b0cef73d77784ee20342fa2fd1d71cddb5ee1f", "filename": "tests/ui/iterators/into-iter-on-arrays-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -2,7 +2,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n-#[allow(unused_must_use)]\n+#[allow(unused_must_use, unused_allocation)]\n fn main() {\n     let small = [1, 2];\n     let big = [0u8; 33];"}, {"sha": "c1a6f5ceaf17880e7d3381886b80c09016697d3b", "filename": "tests/ui/lint/unused/unused-allocation.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-allocation.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -0,0 +1,7 @@\n+#![feature(rustc_attrs, stmt_expr_attributes)]\n+#![deny(unused_allocation)]\n+\n+fn main() {\n+    _ = (#[rustc_box] Box::new([1])).len(); //~ error: unnecessary allocation, use `&` instead\n+    _ = Box::new([1]).len(); //~ error: unnecessary allocation, use `&` instead\n+}"}, {"sha": "c9ccfbd30e5d42d0135499bc57dcdb899eeb714c", "filename": "tests/ui/lint/unused/unused-allocation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-allocation.stderr?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -0,0 +1,20 @@\n+error: unnecessary allocation, use `&` instead\n+  --> $DIR/unused-allocation.rs:5:9\n+   |\n+LL |     _ = (#[rustc_box] Box::new([1])).len();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-allocation.rs:2:9\n+   |\n+LL | #![deny(unused_allocation)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary allocation, use `&` instead\n+  --> $DIR/unused-allocation.rs:6:9\n+   |\n+LL |     _ = Box::new([1]).len();\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c4651ec717787edd9faf1e4e4282554e9682de0c", "filename": "tests/ui/self/arbitrary_self_types_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary_self_types_trait.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_allocation)]\n \n use std::rc::Rc;\n \n@@ -13,7 +14,7 @@ impl Trait for Vec<i32> {\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n+    let v = vec![1, 2, 3];\n \n-    assert_eq!(&[1,2,3], Box::new(Rc::new(v)).trait_method());\n+    assert_eq!(&[1, 2, 3], Box::new(Rc::new(v)).trait_method());\n }"}, {"sha": "54092542f98fae143ce38e0124524c0755ef5ec5", "filename": "tests/ui/structs-enums/align-struct.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02/tests%2Fui%2Fstructs-enums%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Falign-struct.rs?ref=fbc121fdfd30daad5b99bae1aac4d6bd4d42ba02", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(dead_code)]\n+#![allow(dead_code, unused_allocation)]\n \n use std::mem;\n \n@@ -20,7 +20,6 @@ struct AlignMany(i32);\n \n // Raising alignment may not alter size.\n #[repr(align(8))]\n-#[allow(dead_code)]\n struct Align8Many {\n     a: i32,\n     b: i32,\n@@ -29,9 +28,8 @@ struct Align8Many {\n }\n \n enum Enum {\n-    #[allow(dead_code)]\n     A(i32),\n-    B(Align16)\n+    B(Align16),\n }\n \n // Nested alignment - use `#[repr(C)]` to suppress field reordering for sizeof test\n@@ -73,7 +71,7 @@ struct AlignLarge {\n \n union UnionContainsAlign {\n     a: Align16,\n-    b: f32\n+    b: f32,\n }\n \n impl Align16 {\n@@ -158,7 +156,7 @@ pub fn main() {\n     // Note that the size of Nested may change if struct field re-ordering is enabled\n     assert_eq!(mem::align_of::<Nested>(), 16);\n     assert_eq!(mem::size_of::<Nested>(), 48);\n-    let a = Nested{ a: 1, b: 2, c: Align16(3), d: 4};\n+    let a = Nested { a: 1, b: 2, c: Align16(3), d: 4 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.b), 4);\n     assert_eq!(mem::align_of_val(&a.c), 16);\n@@ -179,8 +177,8 @@ pub fn main() {\n             assert_eq!(a.0, 15);\n             assert_eq!(mem::align_of_val(a), 16);\n             assert_eq!(mem::size_of_val(a), 16);\n-        },\n-        _ => ()\n+        }\n+        _ => (),\n     }\n     assert!(is_aligned_to(&e, 16));\n \n@@ -197,8 +195,8 @@ pub fn main() {\n     }\n \n     // arrays of aligned elements should also be aligned\n-    assert_eq!(mem::align_of::<[Align16;2]>(), 16);\n-    assert_eq!(mem::size_of::<[Align16;2]>(), 32);\n+    assert_eq!(mem::align_of::<[Align16; 2]>(), 16);\n+    assert_eq!(mem::size_of::<[Align16; 2]>(), 32);\n \n     let a = [Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n@@ -209,7 +207,7 @@ pub fn main() {\n     assert_eq!(mem::align_of_val(Box::new(Align16(0)).as_ref()), 16);\n \n     // check heap array is aligned\n-    let a = vec!(Align16(0), Align16(1));\n+    let a = vec![Align16(0), Align16(1)];\n     assert_eq!(mem::align_of_val(&a[0]), 16);\n     assert_eq!(mem::align_of_val(&a[1]), 16);\n \n@@ -224,16 +222,14 @@ pub fn main() {\n \n     assert_eq!(mem::align_of::<AlignContainsPacked4C>(), 16);\n     assert_eq!(mem::size_of::<AlignContainsPacked4C>(), 32);\n-    let a = AlignContainsPacked4C { a: Packed4C{ a: 1, b: 2 }, b: 3 };\n+    let a = AlignContainsPacked4C { a: Packed4C { a: 1, b: 2 }, b: 3 };\n     assert_eq!(mem::align_of_val(&a), 16);\n     assert_eq!(mem::align_of_val(&a.a), 4);\n     assert_eq!(mem::align_of_val(&a.b), mem::align_of::<u64>());\n     assert_eq!(mem::size_of_val(&a), 32);\n     assert!(is_aligned_to(&a, 16));\n \n-    let mut large = Box::new(AlignLarge {\n-        stuff: [0; 0x10000],\n-    });\n+    let mut large = Box::new(AlignLarge { stuff: [0; 0x10000] });\n     large.stuff[0] = 132;\n     *large.stuff.last_mut().unwrap() = 102;\n     assert_eq!(large.stuff[0], 132);"}]}