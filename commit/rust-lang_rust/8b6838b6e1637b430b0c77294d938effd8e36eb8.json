{"sha": "8b6838b6e1637b430b0c77294d938effd8e36eb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNjgzOGI2ZTE2MzdiNDMwYjBjNzcyOTRkOTM4ZWZmZDhlMzZlYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T03:59:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-12T03:59:46Z"}, "message": "Auto merge of #75021 - cuviper:array_chunks_mut, r=scottmcm\n\nAdd `slice::array_chunks_mut`\n\nThis follows `array_chunks` from #74373 with a mutable version, `array_chunks_mut`. The implementation is identical apart from mutability. The new tests are adaptations of the `chunks_exact_mut` tests, plus an inference test like the one for `array_chunks`.\n\nI reused the unstable feature `array_chunks` and tracking issue #74985, but I can separate that if desired.\n\nr? `@withoutboats`\ncc `@lcnr`", "tree": {"sha": "f61f4b82c886c2432b89b36584e6e5b15f8d3bdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f61f4b82c886c2432b89b36584e6e5b15f8d3bdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b6838b6e1637b430b0c77294d938effd8e36eb8", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b6838b6e1637b430b0c77294d938effd8e36eb8", "html_url": "https://github.com/rust-lang/rust/commit/8b6838b6e1637b430b0c77294d938effd8e36eb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b6838b6e1637b430b0c77294d938effd8e36eb8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a7ea271f0996848f8fa03c61067620736b1242", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a7ea271f0996848f8fa03c61067620736b1242", "html_url": "https://github.com/rust-lang/rust/commit/94a7ea271f0996848f8fa03c61067620736b1242"}, {"sha": "86b9f710d0c90068866e736bbbb7b89ac93ff2e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b9f710d0c90068866e736bbbb7b89ac93ff2e6", "html_url": "https://github.com/rust-lang/rust/commit/86b9f710d0c90068866e736bbbb7b89ac93ff2e6"}], "stats": {"total": 247, "additions": 242, "deletions": 5}, "files": [{"sha": "677bfdd2349ec4c17f2a492a93408b0db0913cfa", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=8b6838b6e1637b430b0c77294d938effd8e36eb8", "patch": "@@ -93,6 +93,8 @@ use crate::vec::Vec;\n \n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub use core::slice::ArrayChunks;\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub use core::slice::ArrayChunksMut;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]"}, {"sha": "4c027b23584bf7cd6c2102fbe5c3c0f2ceefce96", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=8b6838b6e1637b430b0c77294d938effd8e36eb8", "patch": "@@ -996,9 +996,9 @@ impl<T> [T] {\n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n     /// beginning of the slice.\n     ///\n-    /// The chunks are slices and do not overlap. If `N` does not divide the length of the\n-    /// slice, then the last up to `N-1` elements will be omitted and can be retrieved\n-    /// from the `remainder` function of the iterator.\n+    /// The chunks are array references and do not overlap. If `N` does not divide the\n+    /// length of the slice, then the last up to `N-1` elements will be omitted and can be\n+    /// retrieved from the `remainder` function of the iterator.\n     ///\n     /// This method is the const generic equivalent of [`chunks_exact`].\n     ///\n@@ -1032,6 +1032,49 @@ impl<T> [T] {\n         ArrayChunks { iter: array_slice.iter(), rem: snd }\n     }\n \n+    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are mutable array references and do not overlap. If `N` does not divide\n+    /// the length of the slice, then the last up to `N-1` elements will be omitted and\n+    /// can be retrieved from the `into_remainder` function of the iterator.\n+    ///\n+    /// This method is the const generic equivalent of [`chunks_exact_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n+    /// error before this method gets stabilized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_chunks)]\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.array_chunks_mut() {\n+    ///     *chunk = [count; 2];\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    ///\n+    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    #[inline]\n+    pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n+        assert_ne!(N, 0);\n+        let len = self.len() / N;\n+        let (fst, snd) = self.split_at_mut(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        unsafe {\n+            let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n+            ArrayChunksMut { iter: array_slice.iter_mut(), rem: snd }\n+        }\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n     /// of the slice.\n     ///\n@@ -5826,7 +5869,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n /// time), starting at the beginning of the slice.\n ///\n /// When the slice len is not evenly divided by the chunk size, the last\n-/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// up to `N-1` elements will be omitted but can be retrieved from\n /// the [`remainder`] function from the iterator.\n ///\n /// This struct is created by the [`array_chunks`] method on [slices].\n@@ -5843,7 +5886,7 @@ pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n \n impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n     /// Returns the remainder of the original slice that is not going to be\n-    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     pub fn remainder(&self) -> &'a [T] {\n@@ -5929,6 +5972,105 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N>\n     }\n }\n \n+/// An iterator over a slice in (non-overlapping) mutable chunks (`N` elements\n+/// at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `N-1` elements will be omitted but can be retrieved from\n+/// the [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks_mut`] method on [slices].\n+///\n+/// [`array_chunks_mut`]: ../../std/primitive.slice.html#method.array_chunks_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ArrayChunksMut.html#method.into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n+    iter: IterMut<'a, [T; N]>,\n+    rem: &'a mut [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `N-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunksMut<'a, T, N> {\n+    type Item = &'a mut [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {\n+        // SAFETY: The safety guarantees of `get_unchecked` are transferred to\n+        // the caller.\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunksMut<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunksMut<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunksMut<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunksMut<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T, N> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time), starting at the end of the slice.\n ///"}, {"sha": "9b31e532a6a9fc2f6d8f41d7f070faf0757c2463", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b6838b6e1637b430b0c77294d938effd8e36eb8/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=8b6838b6e1637b430b0c77294d938effd8e36eb8", "patch": "@@ -564,6 +564,99 @@ fn test_array_chunks_zip() {\n     assert_eq!(res, vec![14, 22]);\n }\n \n+#[test]\n+fn test_array_chunks_mut_infer() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    for a in v.array_chunks_mut() {\n+        let sum = a.iter().sum::<i32>();\n+        *a = [sum; 3];\n+    }\n+    assert_eq!(v, &[3, 3, 3, 12, 12, 12, 6]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    v2.array_chunks_mut().for_each(|[a, b]| core::mem::swap(a, b));\n+    assert_eq!(v2, &[1, 0, 3, 2, 5, 4, 6]);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_count() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks_mut::<3>();\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks_mut::<2>();\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &mut [i32] = &mut [];\n+    let c3 = v3.array_chunks_mut::<2>();\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_nth() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks_mut::<2>();\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.array_chunks_mut::<3>();\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks_mut::<2>();\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.array_chunks_mut::<3>();\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c3 = v3.array_chunks_mut::<10>();\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_last() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks_mut::<2>();\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks_mut::<2>();\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_remainder() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let c = v.array_chunks_mut::<2>();\n+    assert_eq!(c.into_remainder(), &[4]);\n+}\n+\n+#[test]\n+fn test_array_chunks_mut_zip() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    for (a, b) in v1.array_chunks_mut::<2>().zip(v2.array_chunks::<2>()) {\n+        let sum = b.iter().sum::<i32>();\n+        for v in a {\n+            *v += sum;\n+        }\n+    }\n+    assert_eq!(v1, [13, 14, 19, 20, 4]);\n+}\n+\n #[test]\n fn test_rchunks_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}