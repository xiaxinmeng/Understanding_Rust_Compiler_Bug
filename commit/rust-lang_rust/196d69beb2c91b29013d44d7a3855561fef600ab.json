{"sha": "196d69beb2c91b29013d44d7a3855561fef600ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NmQ2OWJlYjJjOTFiMjkwMTNkNDRkN2EzODU1NTYxZmVmNjAwYWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-02T02:52:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-02T02:52:08Z"}, "message": "make boxes self-describing (fixes #1493)\" (take 2)\n\nthis will be used to generate a new snapshot.", "tree": {"sha": "01c3878cd9fea6364d8659da36fae42c2b69cfc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c3878cd9fea6364d8659da36fae42c2b69cfc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/196d69beb2c91b29013d44d7a3855561fef600ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/196d69beb2c91b29013d44d7a3855561fef600ab", "html_url": "https://github.com/rust-lang/rust/commit/196d69beb2c91b29013d44d7a3855561fef600ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/196d69beb2c91b29013d44d7a3855561fef600ab/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31166438063236e6d2ad021cf2169fce2b3839b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/31166438063236e6d2ad021cf2169fce2b3839b4", "html_url": "https://github.com/rust-lang/rust/commit/31166438063236e6d2ad021cf2169fce2b3839b4"}], "stats": {"total": 1182, "additions": 584, "deletions": 598}, "files": [{"sha": "a1cd23f1d24237e648b69c24a227ffd302ee2845", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -61,6 +61,7 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_cc.cpp \\\n               rt/rust_debug.cpp \\\n               rt/memory_region.cpp \\\n+              rt/boxed_region.cpp \\\n               rt/test/rust_test_harness.cpp \\\n               rt/test/rust_test_runtime.cpp \\\n               rt/test/rust_test_util.cpp \\"}, {"sha": "4905dffd2a666c639bcdeb239d1ae22fd92e6d72", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -7,7 +7,7 @@\n # If you are making non-backwards compatible changes to the runtime,\n # set this flag to 1.  It will cause stage1 to use the snapshot\n # runtime rather than the runtime from the working directory.\n-USE_SNAPSHOT_RUNTIME=0\n+USE_SNAPSHOT_RUNTIME=1\n \n define TARGET_STAGE_N\n "}, {"sha": "a5670a03fa9ca6899fd6d28fea00768fe3a13f3e", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -26,9 +26,11 @@ const frame_glue_fns_field_drop: int = 1;\n \n const frame_glue_fns_field_reloc: int = 2;\n \n-// n.b. must be same as cbox_elt_refcnt\n-const box_rc_field_refcnt: int = 0;\n-const box_rc_field_body: int = 1;\n+const box_field_refcnt: int = 0;\n+const box_field_tydesc: int = 1;\n+const box_field_prev: int = 2;\n+const box_field_next: int = 3;\n+const box_field_body: int = 4;\n \n const general_code_alignment: int = 16;\n \n@@ -59,13 +61,9 @@ const cmp_glue_op_le: uint = 2u;\n const fn_field_code: int = 0;\n const fn_field_box: int = 1;\n \n-// closure_box, see trans_closure.rs\n-//\n-// n.b. the refcnt must be compatible with a normal box\n-const cbox_elt_refcnt: int = 0;\n-const cbox_elt_tydesc: int = 1;\n-const cbox_elt_ty_params: int = 2;\n-const cbox_elt_bindings: int = 3;\n+// closures, see trans_closure.rs\n+const closure_body_ty_params: int = 0;\n+const closure_body_bindings: int = 1;\n \n const vec_elt_fill: int = 0;\n "}, {"sha": "c78e329e66ba959eb06f66617004efeaf647051d", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -11,6 +11,7 @@ type upcalls =\n     {_fail: ValueRef,\n      malloc: ValueRef,\n      free: ValueRef,\n+     validate_box: ValueRef,\n      shared_malloc: ValueRef,\n      shared_free: ValueRef,\n      mark: ValueRef,\n@@ -52,10 +53,12 @@ fn declare_upcalls(targ_cfg: @session::config,\n                              T_ptr(T_i8()),\n                              size_t]),\n           malloc:\n-              d(\"malloc\", [size_t, T_ptr(tydesc_type)],\n+              d(\"malloc\", [T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n           free:\n               dv(\"free\", [T_ptr(T_i8()), int_t]),\n+          validate_box:\n+              dv(\"validate_box\", [T_ptr(T_i8())]),\n           shared_malloc:\n               d(\"shared_malloc\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),"}, {"sha": "b63a90e7f96891bf0fc2d1e39b833a2b362901d4", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -14,6 +14,7 @@ import syntax::ast_util::{dummy_sp};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n+import back::abi;\n \n import common::*;\n \n@@ -465,7 +466,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n-        let unboxed = GEPi(bcx, box, [0, back::abi::box_rc_field_body]);\n+        let unboxed = GEPi(bcx, box, [0, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n                          f, exits);\n         ret;\n@@ -776,7 +777,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n       ast::pat_box(inner) {\n         let box = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0, back::abi::box_rc_field_body]);\n+            GEPi(bcx, box, [0, abi::box_field_body]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {"}, {"sha": "461aea91a9465ae6505dead214ab18f34159b30b", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -91,7 +91,7 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n     atys += [out_ty];\n \n     // Arg 1: Environment\n-    atys += [T_opaque_cbox_ptr(cx)];\n+    atys += [T_opaque_box_ptr(cx)];\n \n     // Args >2: ty params, if not acquired via capture...\n     for bounds in params {\n@@ -193,7 +193,7 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n         T_struct(tys)\n       }\n       ty::ty_opaque_closure_ptr(_) {\n-        T_opaque_cbox_ptr(cx)\n+        T_opaque_box_ptr(cx)\n       }\n       ty::ty_constr(subt,_) {\n         // FIXME: could be a constraint on ty_fn\n@@ -764,54 +764,54 @@ fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n     ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n }\n \n-// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n-// enough space for something of that type, along with space for a reference\n-// count; in other words, it allocates a box for something of that type.\n-fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n-    let bcx = cx;\n-\n-    // Synthesize a fake box type structurally so we have something\n-    // to measure the size of.\n-\n-    // We synthesize two types here because we want both the type of the\n-    // pointer and the pointee.  boxed_body is the type that we measure the\n-    // size of; box_ptr is the type that's converted to a TypeRef and used as\n-    // the pointer cast target in trans_raw_malloc.\n+// Returns a pointer to the body for the box. The box may be an opaque\n+// box. The result will be casted to the type of body_t, if it is statically\n+// known.\n+//\n+// The runtime equivalent is box_body() in \"rust_internal.h\".\n+fn opaque_box_body(bcx: @block_ctxt,\n+                      body_t: ty::t,\n+                      boxptr: ValueRef) -> ValueRef {\n+    let ccx = bcx_ccx(bcx);\n+    let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n+    let bodyptr = GEPi(bcx, boxptr, [1]);\n+    if check type_has_static_size(ccx, body_t) {\n+        PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n+    } else {\n+        PointerCast(bcx, bodyptr, T_ptr(T_i8()))\n+    }\n+}\n \n-    // The mk_int here is the space being\n-    // reserved for the refcount.\n-    let boxed_body = ty::mk_tup(bcx_tcx(bcx), [ty::mk_int(bcx_tcx(cx)), t]);\n-    let box_ptr = ty::mk_imm_box(bcx_tcx(bcx), t);\n-    let r = size_of(cx, boxed_body);\n-    let llsz = r.val; bcx = r.bcx;\n+// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n+// enough space for a box of that type.  This includes a rust_opaque_box\n+// header.\n+fn trans_malloc_boxed_raw(bcx: @block_ctxt, t: ty::t,\n+                          &static_ti: option<@tydesc_info>) -> result {\n+    let bcx = bcx;\n+    let ccx = bcx_ccx(bcx);\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n-    // FIXME: Could avoid this check with a postcondition on mk_imm_box?\n-    // (requires Issue #586)\n-    let ccx = bcx_ccx(bcx);\n+    let box_ptr = ty::mk_imm_box(bcx_tcx(bcx), t);\n     check (type_has_static_size(ccx, box_ptr));\n     let llty = type_of(ccx, box_ptr);\n \n-    let ti = none;\n-    let tydesc_result = get_tydesc(bcx, t, true, ti);\n-    let lltydesc = tydesc_result.result.val; bcx = tydesc_result.result.bcx;\n+    // Get the tydesc for the body:\n+    let {bcx, val: lltydesc} = get_tydesc(bcx, t, true, static_ti).result;\n \n-    let rval = Call(cx, ccx.upcalls.malloc,\n-                    [llsz, lltydesc]);\n-    ret rslt(cx, PointerCast(cx, rval, llty));\n+    // Allocate space:\n+    let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n+    ret rslt(bcx, PointerCast(bcx, rval, llty));\n }\n \n // trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n // initializes the reference count to 1, and pulls out the body and rc\n-fn trans_malloc_boxed(cx: @block_ctxt, t: ty::t) ->\n+fn trans_malloc_boxed(bcx: @block_ctxt, t: ty::t) ->\n    {bcx: @block_ctxt, box: ValueRef, body: ValueRef} {\n-    let res = trans_malloc_boxed_raw(cx, t);\n-    let box = res.val;\n-    let rc = GEPi(res.bcx, box, [0, abi::box_rc_field_refcnt]);\n-    Store(res.bcx, C_int(bcx_ccx(cx), 1), rc);\n-    let body = GEPi(res.bcx, box, [0, abi::box_rc_field_body]);\n-    ret {bcx: res.bcx, box: res.val, body: body};\n+    let ti = none;\n+    let {bcx, val:box} = trans_malloc_boxed_raw(bcx, t, ti);\n+    let body = GEPi(bcx, box, [0, abi::box_field_body]);\n+    ret {bcx: bcx, box: box, body: body};\n }\n \n // Type descriptor and type glue stuff\n@@ -1231,8 +1231,8 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n \n fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n-    let rc_ptr =\n-        GEPi(cx, box_ptr, [0, abi::box_rc_field_refcnt]);\n+    maybe_validate_box(cx, box_ptr);\n+    let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n     rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n@@ -1243,7 +1243,7 @@ fn free_box(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     ret alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_box(body_mt) {\n         let v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n+        let body = GEPi(bcx, v, [0, abi::box_field_body]);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free_if_not_gc(bcx, v)\n       }\n@@ -1274,7 +1274,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         let ccx = bcx_ccx(bcx);\n         let llbox_ty = T_opaque_iface_ptr(ccx);\n         let b = PointerCast(bcx, v, llbox_ty);\n-        let body = GEPi(bcx, b, [0, abi::box_rc_field_body]);\n+        let body = GEPi(bcx, b, [0, abi::box_field_body]);\n         let tydescptr = GEPi(bcx, body, [0, 0]);\n         let tydesc = Load(bcx, tydescptr);\n         let ti = none;\n@@ -1375,18 +1375,31 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     ret next_cx;\n }\n \n+fn maybe_validate_box(_cx: @block_ctxt, _box_ptr: ValueRef) {\n+    // Uncomment this when debugging annoying use-after-free\n+    // bugs.  But do not commit with this uncommented!  Big performance hit.\n+\n+    // let cx = _cx, box_ptr = _box_ptr;\n+    // let ccx = bcx_ccx(cx);\n+    // warn_not_to_commit(ccx, \"validate_box() is uncommented\");\n+    // let raw_box_ptr = PointerCast(cx, box_ptr, T_ptr(T_i8()));\n+    // Call(cx, ccx.upcalls.validate_box, [raw_box_ptr]);\n+}\n+\n fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n+\n+    maybe_validate_box(cx, box_ptr);\n+\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let llbox_ty = T_opaque_iface_ptr(ccx);\n     let box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n-    let rc_ptr =\n-        GEPi(rc_adj_cx, box_ptr, [0, abi::box_rc_field_refcnt]);\n+    let rc_ptr = GEPi(rc_adj_cx, box_ptr, [0, abi::box_field_refcnt]);\n     let rc = Load(rc_adj_cx, rc_ptr);\n     rc = Sub(rc_adj_cx, rc, C_int(ccx, 1));\n     Store(rc_adj_cx, rc, rc_ptr);\n@@ -1397,7 +1410,6 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     ret next_cx;\n }\n \n-\n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n     if cx.sess.opts.save_temps {\n@@ -2208,7 +2220,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     while true {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n-            let body = GEPi(cx, v1, [0, abi::box_rc_field_body]);\n+            let body = GEPi(cx, v1, [0, abi::box_field_body]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -2514,7 +2526,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           generic: option<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n-    C_null(T_opaque_cbox_ptr(bcx_ccx(bcx)))\n+    C_null(T_opaque_box_ptr(bcx_ccx(bcx)))\n }\n \n fn lval_from_local_var(bcx: @block_ctxt, r: local_var_result) -> lval_result {\n@@ -2790,7 +2802,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         let val =\n             alt ty::struct(ccx.tcx, t) {\n               ty::ty_box(_) {\n-                GEPi(sub.bcx, sub.val, [0, abi::box_rc_field_body])\n+                GEPi(sub.bcx, sub.val, [0, abi::box_field_body])\n               }\n               ty::ty_res(_, _, _) {\n                 GEPi(sub.bcx, sub.val, [0, 1])\n@@ -3160,7 +3172,7 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n     let llenv, dict_param = none;\n     alt f_res.env {\n       null_env {\n-        llenv = llvm::LLVMGetUndef(T_opaque_cbox_ptr(bcx_ccx(cx)));\n+        llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(bcx_ccx(cx)));\n       }\n       self_env(e) { llenv = e; }\n       dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n@@ -3465,6 +3477,8 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n     debuginfo::update_source_pos(bcx, e.span);\n \n+    #debug[\"trans_expr(%s,%?)\", expr_to_str(e), dest];\n+\n     if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n     }\n@@ -3998,6 +4012,8 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n }\n \n fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n+    #debug[\"trans_expr(%s)\", stmt_to_str(s)];\n+\n     if (!bcx_ccx(cx).sess.opts.no_asm_comments) {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n     }\n@@ -5122,8 +5138,7 @@ fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n     let code_cell = GEPi(bcx, pair, [0, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n-    let llenvblobptr =\n-        PointerCast(bcx, llenvptr, T_opaque_cbox_ptr(ccx));\n+    let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n@@ -5591,7 +5606,8 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           shape_cx: shape::mk_ctxt(llmod),\n           gc_cx: gc::mk_ctxt(),\n           crate_map: crate_map,\n-          dbg_cx: dbg_cx};\n+          dbg_cx: dbg_cx,\n+          mutable do_not_commit_warning_issued: false};\n     let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n     trans_constants(ccx, crate);"}, {"sha": "a9bd2a33bfb0b0ddcce719ed41f01d3a63bbc9f1", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -8,7 +8,7 @@ import lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n import lib::llvm::{Opcode, IntPredicate, RealPredicate, True, False,\n                    CallConv};\n import common::{block_ctxt, T_ptr, T_nil, T_i8, T_i1, T_void,\n-                T_fn, val_ty, bcx_ccx, C_i32};\n+                T_fn, val_ty, bcx_ccx, C_i32, val_str};\n \n fn B(cx: @block_ctxt) -> BuilderRef {\n     let b = *cx.fcx.lcx.ccx.builder;\n@@ -95,6 +95,10 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n+    #debug[\"Invoke(%s with arguments (%s))\",\n+           val_str(bcx_ccx(cx).tn, Fn),\n+           str::connect(vec::map(Args, {|a|val_str(bcx_ccx(cx).tn, a)}),\n+                        \", \")];\n     unsafe {\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n                               vec::len(Args) as c_uint, Then, Catch,"}, {"sha": "ad2c9e1d3098001d520443bad0f8069a65c0dfd8", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 158, "deletions": 204, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -15,52 +15,38 @@ import back::link::{\n     mangle_internal_name_by_path,\n     mangle_internal_name_by_path_and_seq};\n import util::ppaux::ty_to_str;\n-import base::{\n-    trans_shared_malloc,\n-    type_of_inner,\n-    node_id_type,\n-    INIT,\n-    trans_shared_free,\n-    drop_ty,\n-    new_sub_block_ctxt,\n-    load_if_immediate,\n-    dest\n-};\n import shape::{size_of};\n \n // ___Good to know (tm)__________________________________________________\n //\n // The layout of a closure environment in memory is\n // roughly as follows:\n //\n-// struct closure_box {\n-//   unsigned ref_count; // only used for shared environments\n-//   type_desc *tydesc;  // descriptor for the \"struct closure_box\" type\n-//   type_desc *bound_tdescs[]; // bound descriptors\n-//   struct {\n-//     upvar1_t upvar1;\n-//     ...\n-//     upvarN_t upvarN;\n-//   } bound_data;\n+// struct rust_opaque_box {         // see rust_internal.h\n+//   unsigned ref_count;            // only used for fn@()\n+//   type_desc *tydesc;             // describes closure_data struct\n+//   rust_opaque_box *prev;         // (used internally by memory alloc)\n+//   rust_opaque_box *next;         // (used internally by memory alloc)\n+//   struct closure_data {\n+//       type_desc *bound_tdescs[]; // bound descriptors\n+//       struct {\n+//         upvar1_t upvar1;\n+//         ...\n+//         upvarN_t upvarN;\n+//       } bound_data;\n+//    }\n // };\n //\n-// Note that the closure carries a type descriptor that describes the\n-// closure itself.  Trippy.  This is needed because the precise types\n-// of the closed over data are lost in the closure type (`fn(T)->U`),\n-// so if we need to take/drop, we must know what data is in the upvars\n-// and so forth.  This struct is defined in the code in mk_closure_tys()\n-// below.\n-//\n-// The allocation strategy for this closure depends on the closure\n-// type.  For a sendfn, the closure (and the referenced type\n-// descriptors) will be allocated in the exchange heap.  For a fn, the\n-// closure is allocated in the task heap and is reference counted.\n-// For a block, the closure is allocated on the stack.  Note that in\n-// all cases we allocate space for a ref count just to make our lives\n-// easier when upcasting to fn(T)->U, in the shape code, and so\n-// forth.\n+// Note that the closure is itself a rust_opaque_box.  This is true\n+// even for fn~ and fn&, because we wish to keep binary compatibility\n+// between all kinds of closures.  The allocation strategy for this\n+// closure depends on the closure type.  For a sendfn, the closure\n+// (and the referenced type descriptors) will be allocated in the\n+// exchange heap.  For a fn, the closure is allocated in the task heap\n+// and is reference counted.  For a block, the closure is allocated on\n+// the stack.\n //\n-// ## Opaque Closures ##\n+// ## Opaque closures and the embedded type descriptor ##\n //\n // One interesting part of closures is that they encapsulate the data\n // that they close over.  So when I have a ptr to a closure, I do not\n@@ -69,10 +55,10 @@ import shape::{size_of};\n // nor where its fields are located.  This is called an \"opaque\n // closure\".\n //\n-// Typically an opaque closure suffices because I only manipulate it\n-// by ptr.  The routine common::T_opaque_cbox_ptr() returns an\n-// appropriate type for such an opaque closure; it allows access to the\n-// first two fields, but not the others.\n+// Typically an opaque closure suffices because we only manipulate it\n+// by ptr.  The routine common::T_opaque_box_ptr() returns an\n+// appropriate type for such an opaque closure; it allows access to\n+// the box fields, but not the closure_data itself.\n //\n // But sometimes, such as when cloning or freeing a closure, we need\n // to know the full information.  That is where the type descriptor\n@@ -81,31 +67,22 @@ import shape::{size_of};\n //\n // ## Subtleties concerning alignment ##\n //\n-// You'll note that the closure_box structure is a flat structure with\n-// four fields.  In some ways, it would be more convenient to use a nested\n-// structure like so:\n-//\n-// struct {\n-//   int;\n-//   struct {\n-//     type_desc*;\n-//     type_desc*[];\n-//     bound_data;\n-// } }\n+// It is important that we be able to locate the closure data *without\n+// knowing the kind of data that is being bound*.  This can be tricky\n+// because the alignment requirements of the bound data affects the\n+// alignment requires of the closure_data struct as a whole.  However,\n+// right now this is a non-issue in any case, because the size of the\n+// rust_opaque_box header is always a mutiple of 16-bytes, which is\n+// the maximum alignment requirement we ever have to worry about.\n //\n-// This would be more convenient because it would allow us to use more\n-// of the existing infrastructure: we could treat the inner struct as\n-// a type and then hvae a boxed variant (which would add the int) etc.\n-// However, there is one subtle problem with this: grouping the latter\n-// 3 fields into an inner struct causes the alignment of the entire\n-// struct to be the max alignment of the bound_data.  This will\n-// therefore vary from closure to closure.  That would mean that we\n-// cannot reliably locate the initial type_desc* in an opaque closure!\n-// That's definitely a bad thing.  Therefore, I have elected to create\n-// a flat structure, even though it means some mild amount of code\n-// duplication (however, we used to do it the other way, and we were\n-// jumping through about as many hoops just trying to wedge a ref\n-// count into a unique pointer, so it's kind of a wash in the end).\n+// The only reason alignment matters is that, in order to learn what data\n+// is bound, we would normally first load the type descriptors: but their\n+// location is ultimately depend on their content!  There is, however, a\n+// workaround.  We can load the tydesc from the rust_opaque_box, which\n+// describes the closure_data struct and has self-contained derived type\n+// descriptors, and read the alignment from there.   It's just annoying to\n+// do.  Hopefully should this ever become an issue we'll have monomorphized\n+// and type descriptors will all be a bad dream.\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n@@ -142,16 +119,21 @@ fn mk_tydesc_ty(tcx: ty::ctxt, ck: ty::closure_kind) -> ty::t {\n     };\n }\n \n+fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n+    let tydesc_ty = mk_tydesc_ty(tcx, ty::ck_uniq);\n+    let cbox_ty = tuplify_cbox_ty(tcx, cdata_ty, tydesc_ty);\n+    ret ty::mk_imm_uniq(tcx, cbox_ty);\n+}\n+\n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_tys(tcx: ty::ctxt,\n                   ck: ty::closure_kind,\n                   ty_params: [fn_ty_param],\n                   bound_values: [environment_value])\n-    -> (ty::t, ty::t, [ty::t]) {\n+    -> (ty::t, [ty::t]) {\n     let bound_tys = [];\n \n-    let tydesc_ty =\n-        mk_tydesc_ty(tcx, ck);\n+    let tydesc_ty = mk_tydesc_ty(tcx, ck);\n \n     // Compute the closed over tydescs\n     let param_ptrs = [];\n@@ -173,95 +155,76 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n \n-    let norc_tys = [tydesc_ty, ty::mk_tup(tcx, param_ptrs), bound_data_ty];\n-\n-    // closure_norc_ty == everything but ref count\n-    //\n-    // This is a hack to integrate with the cycle coll.  When you\n-    // allocate memory in the task-local space, you are expected to\n-    // provide a descriptor for that memory which excludes the ref\n-    // count. That's what this represents.  However, this really\n-    // assumes a type setup like [uint, data] where data can be a\n-    // struct.  We don't use that structure here because we don't want\n-    // to alignment of the first few fields being bound up in the\n-    // alignment of the bound data, as would happen if we laid out\n-    // that way.  For now this should be fine but ultimately we need\n-    // to modify CC code or else modify box allocation interface to be\n-    // a bit more flexible, perhaps taking a vec of tys in the box\n-    // (which for normal rust code is always of length 1).\n-    let closure_norc_ty = ty::mk_tup(tcx, norc_tys);\n-\n-    #debug[\"closure_norc_ty=%s\", ty_to_str(tcx, closure_norc_ty)];\n-\n-    // closure_ty == ref count, data tydesc, typarams, bound data\n-    let closure_ty = ty::mk_tup(tcx, [ty::mk_int(tcx)] + norc_tys);\n-\n-    #debug[\"closure_ty=%s\", ty_to_str(tcx, closure_norc_ty)];\n-\n-    ret (closure_ty, closure_norc_ty, bound_tys);\n+    let cdata_ty = ty::mk_tup(tcx, [ty::mk_tup(tcx, param_ptrs),\n+                                    bound_data_ty]);\n+    #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n+    ret (cdata_ty, bound_tys);\n }\n \n fn allocate_cbox(bcx: @block_ctxt,\n                  ck: ty::closure_kind,\n-                 cbox_ty: ty::t,\n-                 cbox_norc_ty: ty::t)\n+                 cdata_ty: ty::t)\n     -> (@block_ctxt, ValueRef, [ValueRef]) {\n \n-    let ccx = bcx_ccx(bcx);\n-\n-    let alloc_in_heap = fn@(bcx: @block_ctxt,\n-                            xchgheap: bool,\n-                            &temp_cleanups: [ValueRef])\n-        -> (@block_ctxt, ValueRef) {\n+    // let ccx = bcx_ccx(bcx);\n+    let tcx = bcx_tcx(bcx);\n \n-        // n.b. If you are wondering why we don't use\n-        // trans_malloc_boxed() or alloc_uniq(), see the section about\n-        // \"Subtleties concerning alignment\" in the big comment at the\n-        // top of the file.\n+    fn nuke_ref_count(bcx: @block_ctxt, box: ValueRef) {\n+        // Initialize ref count to arbitrary value for debugging:\n+        let ccx = bcx_ccx(bcx);\n+        let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n+        let ref_cnt = GEPi(bcx, box, [0, abi::box_field_refcnt]);\n+        let rc = C_int(ccx, 0x12345678);\n+        Store(bcx, rc, ref_cnt);\n+    }\n \n-        let {bcx, val:llsz} = size_of(bcx, cbox_ty);\n-        let ti = none;\n-        let tydesc_ty = if xchgheap { cbox_ty } else { cbox_norc_ty };\n-        let {bcx, val:lltydesc} =\n-            get_tydesc(bcx, tydesc_ty, true, ti).result;\n-        let malloc = {\n-            if xchgheap { ccx.upcalls.shared_malloc}\n-            else { ccx.upcalls.malloc }\n-        };\n-        let box = Call(bcx, malloc, [llsz, lltydesc]);\n-        add_clean_free(bcx, box, xchgheap);\n-        temp_cleanups += [box];\n-        (bcx, box)\n-    };\n+    fn store_uniq_tydesc(bcx: @block_ctxt,\n+                         cdata_ty: ty::t,\n+                         box: ValueRef,\n+                         &ti: option::t<@tydesc_info>) -> @block_ctxt {\n+        let ccx = bcx_ccx(bcx);\n+        let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n+        let {bcx, val: td} =\n+            base::get_tydesc(bcx, cdata_ty, true, ti).result;\n+        let td = Call(bcx, ccx.upcalls.create_shared_type_desc, [td]);\n+        Store(bcx, td, bound_tydesc);\n+        bcx\n+    }\n \n-    // Allocate the box:\n+    // Allocate and initialize the box:\n+    let ti = none;\n     let temp_cleanups = [];\n-    let (bcx, box, rc) = alt ck {\n+    let (bcx, box) = alt ck {\n       ty::ck_box {\n-        let (bcx, box) = alloc_in_heap(bcx, false, temp_cleanups);\n-        (bcx, box, 1)\n+        let {bcx, val: box} = trans_malloc_boxed_raw(bcx, cdata_ty, ti);\n+        (bcx, box)\n       }\n       ty::ck_uniq {\n-        let (bcx, box) = alloc_in_heap(bcx, true, temp_cleanups);\n-        (bcx, box, 0x12345678) // use arbitrary value for debugging\n+        let uniq_cbox_ty = mk_tuplified_uniq_cbox_ty(tcx, cdata_ty);\n+        check uniq::type_is_unique_box(bcx, uniq_cbox_ty);\n+        let {bcx, val: box} = uniq::alloc_uniq(bcx, uniq_cbox_ty);\n+        nuke_ref_count(bcx, box);\n+        let bcx = store_uniq_tydesc(bcx, cdata_ty, box, ti);\n+        (bcx, box)\n       }\n       ty::ck_block {\n+        let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n         let {bcx, val: box} = base::alloc_ty(bcx, cbox_ty);\n-        (bcx, box, 0x12345678) // use arbitrary value for debugging\n+        nuke_ref_count(bcx, box);\n+        (bcx, box)\n       }\n     };\n \n-    // Initialize ref count\n-    let box = PointerCast(bcx, box, T_opaque_cbox_ptr(ccx));\n-    let ref_cnt = GEPi(bcx, box, [0, abi::box_rc_field_refcnt]);\n-    Store(bcx, C_int(ccx, rc), ref_cnt);\n+    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n+    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+    base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n \n     ret (bcx, box, temp_cleanups);\n }\n \n type closure_result = {\n     llbox: ValueRef,     // llvalue of ptr to closure\n-    cbox_ty: ty::t,      // type of the closure data\n+    cdata_ty: ty::t,      // type of the closure data\n     bcx: @block_ctxt     // final bcx\n };\n \n@@ -302,42 +265,26 @@ fn store_environment(\n     let tcx = bcx_tcx(bcx);\n \n     // compute the shape of the closure\n-    let (cbox_ty, cbox_norc_ty, bound_tys) =\n+    let (cdata_ty, bound_tys) =\n         mk_closure_tys(tcx, ck, lltyparams, bound_values);\n \n     // allocate closure in the heap\n     let (bcx, llbox, temp_cleanups) =\n-        allocate_cbox(bcx, ck, cbox_ty, cbox_norc_ty);\n-\n-    // store data tydesc.\n-    alt ck {\n-      ty::ck_box | ty::ck_uniq {\n-        let bound_tydesc = GEPi(bcx, llbox, [0, abi::cbox_elt_tydesc]);\n-        let ti = none;\n-\n-        let {result:closure_td, _} =\n-            base::get_tydesc(bcx, cbox_ty, true, ti);\n-        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n-        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-        base::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = closure_td.bcx;\n-        let td = maybe_clone_tydesc(bcx, ck, closure_td.val);\n-        Store(bcx, td, bound_tydesc);\n-      }\n-      ty::ck_block { /* skip this for blocks, not really relevant */ }\n-    }\n+        allocate_cbox(bcx, ck, cdata_ty);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n+    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n     check type_is_tup_like(bcx, cbox_ty);\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n     let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like(bcx, cbox_ty, llbox, [0, abi::cbox_elt_ty_params]);\n+        GEP_tup_like(bcx, cbox_ty, llbox,\n+                     [0, abi::box_field_body, abi::closure_body_ty_params]);\n     let off = 0;\n     for tp in lltyparams {\n         let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n@@ -361,7 +308,9 @@ fn store_environment(\n         }\n \n         let bound_data = GEP_tup_like_1(bcx, cbox_ty, llbox,\n-                                        [0, abi::cbox_elt_bindings,\n+                                        [0,\n+                                         abi::box_field_body,\n+                                         abi::closure_body_bindings,\n                                          i as int]);\n         bcx = bound_data.bcx;\n         let bound_data = bound_data.val;\n@@ -399,7 +348,7 @@ fn store_environment(\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n \n-    ret {llbox: llbox, cbox_ty: cbox_ty, bcx: bcx};\n+    ret {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n@@ -443,22 +392,20 @@ fn build_closure(bcx0: @block_ctxt,\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: @block_ctxt,\n                     fcx: @fn_ctxt,\n-                    cbox_ty: ty::t,\n+                    cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n-    let ccx = bcx_ccx(bcx);\n-    let tcx = bcx_tcx(bcx);\n \n-    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n-    check (type_has_static_size(ccx, cboxptr_ty));\n-    let llty = type_of(ccx, cboxptr_ty);\n-    let llclosure = PointerCast(bcx, fcx.llenv, llty);\n+    // Load a pointer to the closure data, skipping over the box header:\n+    let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let lltydescs = GEPi(bcx, llclosure, [0, abi::cbox_elt_ty_params]);\n+    check type_is_tup_like(bcx, cdata_ty);\n+    let {bcx, val: lltydescs} = GEP_tup_like(bcx, cdata_ty, llcdata,\n+                                            [0, abi::closure_body_ty_params]);\n     let off = 0;\n     for tp in copy enclosing_cx.fcx.lltyparams {\n         let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n@@ -476,15 +423,15 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     }\n \n     // Populate the upvars from the environment.\n-    let path = [0, abi::cbox_elt_bindings];\n     let i = 0u;\n     vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n-            check type_is_tup_like(bcx, cbox_ty);\n-            let upvarptr = GEP_tup_like(\n-                bcx, cbox_ty, llclosure, path + [i as int]);\n+            check type_is_tup_like(bcx, cdata_ty);\n+            let upvarptr =\n+                GEP_tup_like(bcx, cdata_ty, llcdata,\n+                             [0, abi::closure_body_bindings, i as int]);\n             bcx = upvarptr.bcx;\n             let llupvarptr = upvarptr.val;\n             alt ck {\n@@ -519,9 +466,9 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let {llbox, cbox_ty, bcx} = build_closure(bcx, cap_vars, ck);\n+        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck);\n         trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|fcx|\n-            load_environment(bcx, fcx, cbox_ty, cap_vars, ck);\n+            load_environment(bcx, fcx, cdata_ty, cap_vars, ck);\n         });\n         llbox\n     };\n@@ -531,9 +478,8 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_box { trans_closure_env(ty::ck_box) }\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n-        let closure = C_null(T_opaque_cbox_ptr(ccx));\n-        trans_closure(sub_cx, decl, body, llfn, no_self, [],\n-                      id, {|_fcx|});\n+        let closure = C_null(T_opaque_box_ptr(ccx));\n+        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|_fcx|});\n         closure\n       }\n     };\n@@ -617,15 +563,15 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     };\n \n     // Actually construct the closure\n-    let {llbox, cbox_ty, bcx} = store_environment(\n+    let {llbox, cdata_ty, bcx} = store_environment(\n         bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::ck_box);\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty_real, args,\n-                         cbox_ty, *param_bounds, target_res);\n+                         cdata_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -688,26 +634,35 @@ fn make_opaque_cbox_take_glue(\n \n     // Hard case, a deep copy:\n     let ccx = bcx_ccx(bcx);\n-    let llopaquecboxty = T_opaque_cbox_ptr(ccx);\n+    let tcx = bcx_tcx(bcx);\n+    let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n     make_null_test(bcx, cbox_in) {|bcx|\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, [0, abi::cbox_elt_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox_in, [0, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n         let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n \n+        // Adjust sz to account for the rust_opaque_box header fields\n+        let sz = Add(bcx, sz, base::llsize_of(ccx, T_box_header(ccx)));\n+\n         // Allocate memory, update original ptr, and copy existing data\n         let malloc = ccx.upcalls.shared_malloc;\n         let cbox_out = Call(bcx, malloc, [sz, tydesc]);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n         let {bcx, val: _} = call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);\n \n+        // Take the (deeply cloned) type descriptor\n+        let tydesc_out = GEPi(bcx, cbox_out, [0, abi::box_field_tydesc]);\n+        let bcx = take_ty(bcx, tydesc_out, mk_tydesc_ty(tcx, ty::ck_uniq));\n+\n         // Take the data in the tuple\n         let ti = none;\n-        call_tydesc_glue_full(bcx, cbox_out, tydesc,\n+        let cdata_out = GEPi(bcx, cbox_out, [0, abi::box_field_body]);\n+        call_tydesc_glue_full(bcx, cdata_out, tydesc,\n                               abi::tydesc_field_take_glue, ti);\n         bcx\n     }\n@@ -747,20 +702,14 @@ fn make_opaque_cbox_free_glue(\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n-        let tydescptr = GEPi(bcx, cbox, [0, abi::cbox_elt_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox, [0, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);\n \n-        // Null out the type descr in the cbox.  This is subtle:\n-        // we will be freeing the data in the cbox, and we may need the\n-        // information in the type descr to guide the GEP_tup_like process\n-        // etc if generic types are involved.  So we null it out at first\n-        // then free it manually below.\n-        Store(bcx, C_null(lltydescty), tydescptr);\n-\n         // Drop the tuple data then free the descriptor\n         let ti = none;\n-        call_tydesc_glue_full(bcx, cbox, tydesc,\n+        let cdata = GEPi(bcx, cbox, [0, abi::box_field_body]);\n+        call_tydesc_glue_full(bcx, cdata, tydesc,\n                               abi::tydesc_field_drop_glue, ti);\n \n         // Free the ty descr (if necc) and the box itself\n@@ -782,10 +731,11 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n                     args: [option<@ast::expr>],\n-                    cbox_ty: ty::t,\n+                    cdata_ty: ty::t,\n                     param_bounds: [ty::param_bounds],\n                     target_fn: option<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n+\n     // If we supported constraints on record fields, we could make the\n     // constraints for this function:\n     /*\n@@ -797,6 +747,13 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let tcx = ccx_tcx(ccx);\n     check type_has_static_size(ccx, incoming_fty);\n \n+    #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n+            cdata_ty=%s,param_bounds=%?]\",\n+           ty_to_str(tcx, incoming_fty),\n+           ty_to_str(tcx, outgoing_fty),\n+           ty_to_str(tcx, cdata_ty),\n+           param_bounds];\n+\n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n     // bar, baz)' would be a thunk that, when called, applies f to those\n@@ -835,15 +792,12 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let l_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     // The 'llenv' that will arrive in the thunk we're creating is an\n-    // environment that will contain the values of its arguments and a pointer\n-    // to the original function.  So, let's create one of those:\n-\n-    // The llenv pointer needs to be the correct size.  That size is\n-    // 'cbox_ty', which was determined by trans_bind.\n-    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n-    check type_has_static_size(ccx, cboxptr_ty);\n-    let llclosure_ptr_ty = type_of(ccx, cboxptr_ty);\n-    let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n+    // environment that will contain the values of its arguments and a\n+    // pointer to the original function.  This environment is always\n+    // stored like an opaque box (see big comment at the header of the\n+    // file), so we load the body body, which contains the type descr\n+    // and cached data.\n+    let llcdata = base::opaque_box_body(l_bcx, cdata_ty, fcx.llenv);\n \n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n@@ -856,10 +810,10 @@ fn trans_bind_thunk(cx: @local_ctxt,\n       }\n       none {\n         // Silly check\n-        check type_is_tup_like(bcx, cbox_ty);\n+        check type_is_tup_like(bcx, cdata_ty);\n         let {bcx: cx, val: pair} =\n-            GEP_tup_like(bcx, cbox_ty, llclosure,\n-                         [0, abi::cbox_elt_bindings, 0]);\n+            GEP_tup_like(bcx, cdata_ty, llcdata,\n+                         [0, abi::closure_body_bindings, 0]);\n         let lltargetenv =\n             Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n         let lltargetfn = Load\n@@ -893,10 +847,10 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    check type_is_tup_like(l_bcx, cbox_ty);\n+    check type_is_tup_like(l_bcx, cdata_ty);\n     let {bcx: l_bcx, val: param_record} =\n-        GEP_tup_like(l_bcx, cbox_ty, llclosure,\n-                     [0, abi::cbox_elt_ty_params]);\n+        GEP_tup_like(l_bcx, cdata_ty, llcdata,\n+                     [0, abi::closure_body_ty_params]);\n     let off = 0;\n     for param in param_bounds {\n         let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n@@ -934,10 +888,10 @@ fn trans_bind_thunk(cx: @local_ctxt,\n           // closure.\n           some(e) {\n             // Silly check\n-            check type_is_tup_like(bcx, cbox_ty);\n+            check type_is_tup_like(bcx, cdata_ty);\n             let bound_arg =\n-                GEP_tup_like(bcx, cbox_ty, llclosure,\n-                             [0, abi::cbox_elt_bindings, b]);\n+                GEP_tup_like(bcx, cdata_ty, llcdata,\n+                             [0, abi::closure_body_bindings, b]);\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;\n             if out_arg.mode == ast::by_val { val = Load(bcx, val); }"}, {"sha": "2670571aa6e3083b183e7f5cf51072d48c4801e0", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -122,7 +122,8 @@ type crate_ctxt =\n      shape_cx: shape::ctxt,\n      gc_cx: gc::ctxt,\n      crate_map: ValueRef,\n-     dbg_cx: option<@debuginfo::debug_ctxt>};\n+     dbg_cx: option<@debuginfo::debug_ctxt>,\n+     mutable do_not_commit_warning_issued: bool};\n \n type local_ctxt =\n     {path: [str],\n@@ -243,6 +244,13 @@ type fn_ctxt =\n      span: option<span>,\n      lcx: @local_ctxt};\n \n+fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n+    if !ccx.do_not_commit_warning_issued {\n+        ccx.do_not_commit_warning_issued = true;\n+        ccx.sess.warn(msg + \" -- do not commit like this!\");\n+    }\n+}\n+\n enum cleanup {\n     clean(fn@(@block_ctxt) -> @block_ctxt),\n     clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt),\n@@ -652,8 +660,42 @@ fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n     ret T_vec2(targ_cfg, T_i8());\n }\n \n+// Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n+// representation of @T as a tuple (i.e., the ty::t version of what T_box()\n+// returns).\n+fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+    ret tuplify_cbox_ty(tcx, t, ty::mk_type(tcx));\n+}\n+\n+// As tuplify_box_ty(), but allows the caller to specify what type of type\n+// descr is embedded in the box (ty::type vs ty::send_type).  This is useful\n+// for unique closure boxes, hence the name \"cbox_ty\" (closure box type).\n+fn tuplify_cbox_ty(tcx: ty::ctxt, t: ty::t, tydesc_t: ty::t) -> ty::t {\n+    let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mut: ast::imm});\n+    ret ty::mk_tup(tcx, [ty::mk_uint(tcx), tydesc_t,\n+                         ptr, ptr,\n+                         t]);\n+}\n+\n+fn T_box_header_fields(cx: @crate_ctxt) -> [TypeRef] {\n+    let ptr = T_ptr(T_i8());\n+    ret [cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n+}\n+\n+fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n+    ret T_struct(T_box_header_fields(cx));\n+}\n+\n fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct([cx.int_type, t]);\n+    ret T_struct(T_box_header_fields(cx) + [t]);\n+}\n+\n+fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n+    ret T_box(cx, T_i8());\n+}\n+\n+fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n+    ret T_ptr(T_opaque_box(cx));\n }\n \n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n@@ -681,15 +723,9 @@ fn T_typaram(tn: type_names) -> TypeRef {\n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n-    let s = \"*cbox\";\n-    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n-    let t = T_ptr(T_struct([cx.int_type,\n-                            T_ptr(cx.tydesc_type),\n-                            T_i8() /* represents closed over tydescs\n-                            and data go here; see trans_closure.rs*/\n-                           ]));\n-    associate_type(cx.tn, s, t);\n-    ret t;\n+    // closures look like boxes (even when they are fn~ or fn&)\n+    // see trans_closure.rs\n+    ret T_opaque_box_ptr(cx);\n }\n \n fn T_enum_variant(cx: @crate_ctxt) -> TypeRef {"}, {"sha": "9988508903c62b85432c408397eba07f63e55eef", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -145,7 +145,7 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n     -> lval_maybe_callee {\n     let tcx = bcx_tcx(bcx);\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let box_body = GEPi(bcx, val, [0, abi::box_rc_field_body]);\n+    let box_body = GEPi(bcx, val, [0, abi::box_field_body]);\n     let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, box_body, [0, 1]),\n                                      T_ptr(T_ptr(T_dict()))));\n     // FIXME[impl] I doubt this is alignment-safe\n@@ -266,7 +266,7 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n         let self = Load(bcx, PointerCast(bcx,\n                                          LLVMGetParam(llfn, 2u as c_uint),\n                                          T_ptr(T_opaque_iface_ptr(ccx))));\n-        let boxed = GEPi(bcx, self, [0, abi::box_rc_field_body]);\n+        let boxed = GEPi(bcx, self, [0, abi::box_field_body]);\n         let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, boxed, [0, 1]),\n                                          T_ptr(T_ptr(T_dict()))));\n         let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),"}, {"sha": "4a7b25f7c084b10850fafa1202eff2c9c1f7dd11", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -1928,13 +1928,15 @@ fn parse_mod_items(p: parser, term: token::token,\n     while p.token != term {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = [];\n+        #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n         alt parse_item(p, attrs) {\n           some(i) { items += [i]; }\n           _ {\n             p.fatal(\"expected item but found '\" +\n                     token::to_str(p.reader, p.token) + \"'\");\n           }\n         }\n+        #debug[\"parse_mod_items: attrs=%?\", attrs];\n     }\n     ret {view_items: view_items, items: items};\n }"}, {"sha": "bd2c7b369cf3a32cd9aeb7d5fb761842131daff7", "filename": "src/libcore/task.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -75,8 +75,6 @@ native mod rustrt {\n     fn drop_task(task_id: *rust_task);\n     fn get_task_pointer(id: task_id) -> *rust_task;\n \n-    fn migrate_alloc(alloc: *u8, target: task_id);\n-\n     fn start_task(id: task, closure: *rust_closure);\n \n     fn rust_task_is_unwinding(rt: *rust_task) -> bool;"}, {"sha": "937069bc38c32de1f8f26a0331996cfb3556076e", "filename": "src/rt/boxed_region.cpp", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -0,0 +1,59 @@\n+#include <assert.h>\n+#include \"boxed_region.h\"\n+#include \"rust_internal.h\"\n+\n+// #define DUMP_BOXED_REGION\n+\n+rust_opaque_box *boxed_region::malloc(type_desc *td) {\n+    size_t header_size = sizeof(rust_opaque_box);\n+    size_t body_size = td->size;\n+    size_t body_align = td->align;\n+    size_t total_size = align_to(header_size, body_align) + body_size;\n+    rust_opaque_box *box =\n+      (rust_opaque_box*)backing_region->malloc(total_size, \"@\");\n+    box->td = td;\n+    box->ref_count = 1;\n+    box->prev = NULL;\n+    box->next = live_allocs;\n+    if (live_allocs) live_allocs->prev = box;\n+    live_allocs = box;\n+\n+#   ifdef DUMP_BOXED_REGION\n+    fprintf(stderr, \"Allocated box %p with td %p,\"\n+            \" size %lu==%lu+%lu, align %lu, prev %p, next %p\\n\",\n+            box, td, total_size, header_size, body_size, body_align,\n+            box->prev, box->next);\n+#   endif\n+\n+    return box;\n+}\n+\n+rust_opaque_box *boxed_region::calloc(type_desc *td) {\n+    rust_opaque_box *box = malloc(td);\n+    memset(box_body(box), 0, td->size);\n+    return box;\n+}\n+\n+void boxed_region::free(rust_opaque_box *box) {\n+    // This turns out to not be true in various situations,\n+    // like when we are unwinding after a failure.\n+    //\n+    // assert(box->ref_count == 0);\n+\n+    // This however should always be true.  Helps to detect\n+    // double frees (kind of).\n+    assert(box->td != NULL);\n+\n+#   ifdef DUMP_BOXED_REGION\n+    fprintf(stderr, \"Freed box %p with td %p, prev %p, next %p\\n\",\n+            box, box->td, box->prev, box->next);\n+#   endif\n+\n+    if (box->prev) box->prev->next = box->next;\n+    if (box->next) box->next->prev = box->prev;\n+    if (live_allocs == box) live_allocs = box->next;\n+    box->prev = NULL;\n+    box->next = NULL;\n+    box->td = NULL;\n+    backing_region->free(box);\n+}"}, {"sha": "bd5312fee99f02379772f3a815b9e760b874ce9d", "filename": "src/rt/boxed_region.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fboxed_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fboxed_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -0,0 +1,39 @@\n+#ifndef BOXED_REGION_H\n+#define BOXED_REGION_H\n+\n+#include <stdlib.h>\n+\n+struct type_desc;\n+class memory_region;\n+struct rust_opaque_box;\n+\n+/* Tracks the data allocated by a particular task in the '@' region.\n+ * Currently still relies on the standard malloc as a backing allocator, but\n+ * this could be improved someday if necessary. Every allocation must provide\n+ * a type descr which describes the payload (what follows the header). */\n+class boxed_region {\n+private:\n+    memory_region *backing_region;\n+    rust_opaque_box *live_allocs;\n+\n+    size_t align_to(size_t v, size_t align) {\n+        size_t alignm1 = align - 1;\n+        v += alignm1;\n+        v &= ~alignm1;\n+        return v;\n+    }\n+\n+public:\n+    boxed_region(memory_region *br)\n+        : backing_region(br)\n+        , live_allocs(NULL)\n+    {}\n+\n+    rust_opaque_box *first_live_alloc() { return live_allocs; }\n+\n+    rust_opaque_box *malloc(type_desc *td);\n+    rust_opaque_box *calloc(type_desc *td);\n+    void free(rust_opaque_box *box);\n+};\n+\n+#endif /* BOXED_REGION_H */"}, {"sha": "a3d7270e79d0014e22c1f4a366c83b8177c1ea99", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -50,6 +50,9 @@ class memory_region {\n     void dec_alloc();\n     void maybe_poison(void *mem);\n \n+    void release_alloc(void *mem);\n+    void claim_alloc(void *mem);\n+\n public:\n     memory_region(rust_srv *srv, bool synchronized);\n     memory_region(memory_region *parent);\n@@ -58,10 +61,7 @@ class memory_region {\n     void *realloc(void *mem, size_t size);\n     void free(void *mem);\n     virtual ~memory_region();\n-\n-    void release_alloc(void *mem);\n-    void claim_alloc(void *mem);\n-};\n+ };\n \n inline void *operator new(size_t size, memory_region &region,\n                           const char *tag) {"}, {"sha": "ea2e8de256c4c567c11c8d785dbb56fd999d9da4", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -429,22 +429,6 @@ start_task(rust_task_id id, fn_env_pair *f) {\n     target->deref();\n }\n \n-extern \"C\" CDECL void\n-migrate_alloc(void *alloc, rust_task_id tid) {\n-    rust_task *task = rust_scheduler::get_task();\n-    if(!alloc) return;\n-    rust_task *target = task->kernel->get_task_by_id(tid);\n-    if(target) {\n-        const type_desc *tydesc = task->release_alloc(alloc);\n-        target->claim_alloc(alloc, tydesc);\n-        target->deref();\n-    }\n-    else {\n-        // We couldn't find the target. Maybe we should just free?\n-        task->fail();\n-    }\n-}\n-\n extern \"C\" CDECL int\n sched_threads() {\n     rust_task *task = rust_scheduler::get_task();"}, {"sha": "60b0b8d2fd000fb180852fb8e4b7bc3f1e8637a2", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 86, "deletions": 116, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -25,7 +25,7 @@ namespace cc {\n \n // Internal reference count computation\n \n-typedef std::map<void *,uintptr_t> irc_map;\n+typedef std::map<rust_opaque_box*,uintptr_t> irc_map;\n \n class irc : public shape::data<irc,shape::ptr> {\n     friend class shape::data<irc,shape::ptr>;\n@@ -118,13 +118,6 @@ class irc : public shape::data<irc,shape::ptr> {\n         }\n     }\n \n-    void walk_obj2() {\n-        dp += sizeof(void *); // skip vtable\n-        uint8_t *box_ptr = shape::bump_dp<uint8_t *>(dp);\n-        shape::ptr ref_count_dp(box_ptr);\n-        maybe_record_irc(ref_count_dp);\n-    }\n-\n     void walk_iface2() {\n         walk_box2();\n     }\n@@ -145,30 +138,32 @@ class irc : public shape::data<irc,shape::ptr> {\n \n     void walk_uniq_contents2(irc &sub) { sub.walk(); }\n \n-    void walk_box_contents2(irc &sub, shape::ptr &ref_count_dp) {\n-        maybe_record_irc(ref_count_dp);\n+    void walk_box_contents2(irc &sub, shape::ptr &box_dp) {\n+        maybe_record_irc(box_dp);\n \n         // Do not traverse the contents of this box; it's in the allocation\n         // somewhere, so we're guaranteed to come back to it (if we haven't\n         // traversed it already).\n     }\n \n-    void maybe_record_irc(shape::ptr &ref_count_dp) {\n-        if (!ref_count_dp)\n+    void maybe_record_irc(shape::ptr &box_dp) {\n+        if (!box_dp)\n             return;\n \n+        rust_opaque_box *box_ptr = (rust_opaque_box *) box_dp;\n+\n         // Bump the internal reference count of the box.\n-        if (ircs.find((void *)ref_count_dp) == ircs.end()) {\n+        if (ircs.find(box_ptr) == ircs.end()) {\n           LOG(task, gc,\n               \"setting internal reference count for %p to 1\",\n-              (void *)ref_count_dp);\n-          ircs[(void *)ref_count_dp] = 1;\n+              box_ptr);\n+          ircs[box_ptr] = 1;\n         } else {\n-          uintptr_t newcount = ircs[(void *)ref_count_dp] + 1;\n+          uintptr_t newcount = ircs[box_ptr] + 1;\n           LOG(task, gc,\n               \"bumping internal reference count for %p to %lu\",\n-              (void *)ref_count_dp, newcount);\n-          ircs[(void *)ref_count_dp] = newcount;\n+              box_ptr, newcount);\n+          ircs[box_ptr] = newcount;\n         }\n     }\n \n@@ -207,71 +202,58 @@ irc::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n \n void\n irc::compute_ircs(rust_task *task, irc_map &ircs) {\n-    std::map<void *,const type_desc *>::iterator\n-        begin(task->local_allocs.begin()), end(task->local_allocs.end());\n-    while (begin != end) {\n-        uint8_t *p = reinterpret_cast<uint8_t *>(begin->first);\n-\n-        const type_desc *tydesc = begin->second;\n-\n-        LOG(task, gc, \"determining internal ref counts: %p, tydesc=%p\", p,\n-            tydesc);\n-\n+    boxed_region *boxed = &task->boxed;\n+    for (rust_opaque_box *box = boxed->first_live_alloc();\n+         box != NULL;\n+         box = box->next) {\n+        type_desc *tydesc = box->td;\n+        uint8_t *body = (uint8_t*) box_body(box);\n+\n+        LOG(task, gc, \n+            \"determining internal ref counts: \"\n+            \"box=%p tydesc=%p body=%p\",\n+            box, tydesc, body);\n+        \n         shape::arena arena;\n         shape::type_param *params =\n-            shape::type_param::from_tydesc_and_data(tydesc, p, arena);\n-\n-#if 0\n-        shape::print print(task, true, tydesc->shape, params,\n-                           tydesc->shape_tables);\n-        print.walk();\n-\n-        shape::log log(task, true, tydesc->shape, params,\n-                       tydesc->shape_tables, p + sizeof(uintptr_t),\n-                       std::cerr);\n-        log.walk();\n-#endif\n+            shape::type_param::from_tydesc_and_data(tydesc, body, arena);\n \n         irc irc(task, true, tydesc->shape, params, tydesc->shape_tables,\n-                p + sizeof(uintptr_t), ircs);\n+                body, ircs);\n         irc.walk();\n-\n-        ++begin;\n     }\n }\n \n \n // Root finding\n \n void\n-find_roots(rust_task *task, irc_map &ircs, std::vector<void *> &roots) {\n-    std::map<void *,const type_desc *>::iterator\n-        begin(task->local_allocs.begin()), end(task->local_allocs.end());\n-    while (begin != end) {\n-        void *alloc = begin->first;\n-        uintptr_t *ref_count_ptr = reinterpret_cast<uintptr_t *>(alloc);\n-        uintptr_t ref_count = *ref_count_ptr;\n+find_roots(rust_task *task, irc_map &ircs,\n+           std::vector<rust_opaque_box *> &roots) {\n+    boxed_region *boxed = &task->boxed;\n+    for (rust_opaque_box *box = boxed->first_live_alloc();\n+         box != NULL;\n+         box = box->next) {\n+        uintptr_t ref_count = box->ref_count;\n \n         uintptr_t irc;\n-        if (ircs.find(alloc) != ircs.end())\n-            irc = ircs[alloc];\n+        if (ircs.find(box) != ircs.end())\n+            irc = ircs[box];\n         else\n             irc = 0;\n \n         if (irc < ref_count) {\n             // This allocation must be a root, because the internal reference\n             // count is smaller than the total reference count.\n             LOG(task, gc,\"root found: %p, irc %lu, ref count %lu\",\n-                alloc, irc, ref_count);\n-            roots.push_back(alloc);\n+                box, irc, ref_count);\n+            roots.push_back(box);\n         } else {\n             LOG(task, gc, \"nonroot found: %p, irc %lu, ref count %lu\",\n-                alloc, irc, ref_count);\n+                box, irc, ref_count);\n             assert(irc == ref_count && \"Internal reference count must be \"\n                    \"less than or equal to the total reference count!\");\n         }\n-\n-        ++begin;\n     }\n }\n \n@@ -281,7 +263,7 @@ find_roots(rust_task *task, irc_map &ircs, std::vector<void *> &roots) {\n class mark : public shape::data<mark,shape::ptr> {\n     friend class shape::data<mark,shape::ptr>;\n \n-    std::set<void *> &marked;\n+    std::set<rust_opaque_box *> &marked;\n \n     mark(const mark &other, const shape::ptr &in_dp)\n     : shape::data<mark,shape::ptr>(other.task, other.align, other.sp,\n@@ -319,7 +301,7 @@ class mark : public shape::data<mark,shape::ptr> {\n          const shape::type_param *in_params,\n          const rust_shape_tables *in_tables,\n          uint8_t *in_data,\n-         std::set<void *> &in_marked)\n+         std::set<rust_opaque_box*> &in_marked)\n     : shape::data<mark,shape::ptr>(in_task, in_align, in_sp, in_params,\n                                    in_tables, in_data),\n       marked(in_marked) {}\n@@ -357,7 +339,7 @@ class mark : public shape::data<mark,shape::ptr> {\n           case shape::SHAPE_BOX_FN: {\n               // Record an irc for the environment box, but don't descend\n               // into it since it will be walked via the box's allocation\n-              shape::data<mark,shape::ptr>::walk_fn_contents1(dp, false);\n+              shape::data<mark,shape::ptr>::walk_fn_contents1();\n               break;\n           }\n           case shape::SHAPE_BARE_FN:        // Does not close over data.\n@@ -368,10 +350,6 @@ class mark : public shape::data<mark,shape::ptr> {\n         }\n     }\n \n-    void walk_obj2() {\n-        shape::data<mark,shape::ptr>::walk_obj_contents1(dp);\n-    }\n-\n     void walk_res2(const shape::rust_fn *dtor, unsigned n_params,\n                   const shape::type_param *params, const uint8_t *end_sp,\n                   bool live) {\n@@ -392,14 +370,16 @@ class mark : public shape::data<mark,shape::ptr> {\n \n     void walk_uniq_contents2(mark &sub) { sub.walk(); }\n \n-    void walk_box_contents2(mark &sub, shape::ptr &ref_count_dp) {\n-        if (!ref_count_dp)\n+    void walk_box_contents2(mark &sub, shape::ptr &box_dp) {\n+        if (!box_dp)\n             return;\n \n-        if (marked.find((void *)ref_count_dp) != marked.end())\n+        rust_opaque_box *box_ptr = (rust_opaque_box *) box_dp;\n+\n+        if (marked.find(box_ptr) != marked.end())\n             return; // Skip to avoid chasing cycles.\n \n-        marked.insert((void *)ref_count_dp);\n+        marked.insert(box_ptr);\n         sub.walk();\n     }\n \n@@ -418,8 +398,9 @@ class mark : public shape::data<mark,shape::ptr> {\n     inline void walk_number2() { /* no-op */ }\n \n public:\n-    static void do_mark(rust_task *task, const std::vector<void *> &roots,\n-                        std::set<void *> &marked);\n+    static void do_mark(rust_task *task,\n+                        const std::vector<rust_opaque_box *> &roots,\n+                        std::set<rust_opaque_box*> &marked);\n };\n \n void\n@@ -438,35 +419,28 @@ mark::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n }\n \n void\n-mark::do_mark(rust_task *task, const std::vector<void *> &roots,\n-              std::set<void *> &marked) {\n-    std::vector<void *>::const_iterator begin(roots.begin()),\n-                                        end(roots.end());\n+mark::do_mark(rust_task *task,\n+              const std::vector<rust_opaque_box *> &roots,\n+              std::set<rust_opaque_box *> &marked) {\n+    std::vector<rust_opaque_box *>::const_iterator \n+      begin(roots.begin()),\n+      end(roots.end());\n     while (begin != end) {\n-        void *alloc = *begin;\n-        if (marked.find(alloc) == marked.end()) {\n-            marked.insert(alloc);\n+        rust_opaque_box *box = *begin;\n+        if (marked.find(box) == marked.end()) {\n+            marked.insert(box);\n \n-            const type_desc *tydesc = task->local_allocs[alloc];\n+            const type_desc *tydesc = box->td;\n \n-            LOG(task, gc, \"marking: %p, tydesc=%p\", alloc, tydesc);\n+            LOG(task, gc, \"marking: %p, tydesc=%p\", box, tydesc);\n \n-            uint8_t *p = reinterpret_cast<uint8_t *>(alloc);\n+            uint8_t *p = (uint8_t*) box_body(box);\n             shape::arena arena;\n             shape::type_param *params =\n                 shape::type_param::from_tydesc_and_data(tydesc, p, arena);\n \n-#if 0\n-            // We skip over the reference count here.\n-            shape::log log(task, true, tydesc->shape, params,\n-                           tydesc->shape_tables, p + sizeof(uintptr_t),\n-                           std::cerr);\n-            log.walk();\n-#endif\n-\n-            // We skip over the reference count here.\n             mark mark(task, true, tydesc->shape, params, tydesc->shape_tables,\n-                      p + sizeof(uintptr_t), marked);\n+                      p, marked);\n             mark.walk();\n         }\n \n@@ -552,13 +526,9 @@ class sweep : public shape::data<sweep,shape::ptr> {\n               fn_env_pair pair = *(fn_env_pair*)dp;\n \n               // free closed over data:\n-              shape::data<sweep,shape::ptr>::walk_fn_contents1(dp, true);\n+              shape::data<sweep,shape::ptr>::walk_fn_contents1();\n \n               // now free the embedded type descr:\n-              //\n-              // see comment in walk_fn_contents1() concerning null_td\n-              // to understand why this does not occur during the normal\n-              // walk.\n               upcall_s_free_shared_type_desc((type_desc*)pair.env->td);\n \n               // now free the ptr:\n@@ -610,7 +580,7 @@ class sweep : public shape::data<sweep,shape::ptr> {\n \n     void walk_uniq_contents2(sweep &sub) { sub.walk(); }\n \n-    void walk_box_contents2(sweep &sub, shape::ptr &ref_count_dp) {\n+    void walk_box_contents2(sweep &sub, shape::ptr &box_dp) {\n         return;\n     }\n \n@@ -637,50 +607,50 @@ class sweep : public shape::data<sweep,shape::ptr> {\n     inline void walk_number2() { /* no-op */ }\n \n public:\n-    static void do_sweep(rust_task *task, const std::set<void *> &marked);\n+    static void do_sweep(rust_task *task,\n+                         const std::set<rust_opaque_box*> &marked);\n };\n \n void\n-sweep::do_sweep(rust_task *task, const std::set<void *> &marked) {\n-    std::map<void *,const type_desc *>::iterator\n-        begin(task->local_allocs.begin()), end(task->local_allocs.end());\n-    while (begin != end) {\n-        void *alloc = begin->first;\n-\n-        if (marked.find(alloc) == marked.end()) {\n-            LOG(task, gc, \"object is part of a cycle: %p\", alloc);\n-\n-            const type_desc *tydesc = begin->second;\n-            uint8_t *p = reinterpret_cast<uint8_t *>(alloc);\n+sweep::do_sweep(rust_task *task,\n+                const std::set<rust_opaque_box*> &marked) {\n+    boxed_region *boxed = &task->boxed;\n+    rust_opaque_box *box = boxed->first_live_alloc();\n+    while (box != NULL) {\n+        // save next ptr as we may be freeing box\n+        rust_opaque_box *box_next = box->next;\n+        if (marked.find(box) == marked.end()) {\n+            LOG(task, gc, \"object is part of a cycle: %p\", box);\n+\n+            const type_desc *tydesc = box->td;\n+            uint8_t *p = (uint8_t*) box_body(box);\n             shape::arena arena;\n             shape::type_param *params =\n                 shape::type_param::from_tydesc_and_data(tydesc, p, arena);\n \n             sweep sweep(task, true, tydesc->shape,\n                         params, tydesc->shape_tables,\n-                        p + sizeof(uintptr_t));\n+                        p);\n             sweep.walk();\n \n-            // FIXME: Run the destructor, *if* it's a resource.\n-            task->free(alloc);\n+            boxed->free(box);\n         }\n-        ++begin;\n+        box = box_next;\n     }\n }\n \n \n void\n do_cc(rust_task *task) {\n-    LOG(task, gc, \"cc; n allocs = %lu\",\n-        (long unsigned int)task->local_allocs.size());\n+    LOG(task, gc, \"cc\");\n \n     irc_map ircs;\n     irc::compute_ircs(task, ircs);\n \n-    std::vector<void *> roots;\n+    std::vector<rust_opaque_box*> roots;\n     find_roots(task, ircs, roots);\n \n-    std::set<void *> marked;\n+    std::set<rust_opaque_box*> marked;\n     mark::do_mark(task, roots, marked);\n \n     sweep::do_sweep(task, marked);"}, {"sha": "6fa049054ec094cc460963a4d108af216df973c2", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -231,29 +231,36 @@ struct rust_shape_tables {\n     uint8_t *resources;\n };\n \n-struct rust_opaque_closure;\n+typedef unsigned long ref_cnt_t;\n+\n+// Corresponds to the boxed data in the @ region.  The body follows the\n+// header; you can obtain a ptr via box_body() below.\n+struct rust_opaque_box {\n+    ref_cnt_t ref_count;\n+    type_desc *td;\n+    rust_opaque_box *prev;\n+    rust_opaque_box *next;\n+};\n \n // The type of functions that we spawn, which fall into two categories:\n // - the main function: has a NULL environment, but uses the void* arg\n // - unique closures of type fn~(): have a non-NULL environment, but\n //   no arguments (and hence the final void*) is harmless\n-typedef void (*CDECL spawn_fn)(void*, rust_opaque_closure*, void *);\n+typedef void (*CDECL spawn_fn)(void*, rust_opaque_box*, void *);\n \n // corresponds to the layout of a fn(), fn@(), fn~() etc\n struct fn_env_pair {\n     spawn_fn f;\n-    rust_opaque_closure *env;\n+    rust_opaque_box *env;\n };\n \n-// corresponds the closures generated in trans_closure.rs\n-struct rust_opaque_closure {\n-    intptr_t ref_count;\n-    const type_desc *td;\n-    // The size/types of these will vary per closure, so they\n-    // cannot be statically expressed.  See trans_closure.rs:\n-    const type_desc *captured_tds[0];\n-    // struct bound_data;\n-};\n+static inline void *box_body(rust_opaque_box *box) {\n+    // Here we take advantage of the fact that the size of a box in 32\n+    // (resp. 64) bit is 16 (resp. 32) bytes, and thus always 16-byte aligned.\n+    // If this were to change, we would have to update the method\n+    // rustc::middle::trans::base::opaque_box_body() as well.\n+    return (void*)(box + 1);\n+}\n \n struct type_desc {\n     // First part of type_desc is known to compiler."}, {"sha": "875513ca2644e8b54650e7b1942cd898868e626c", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -264,7 +264,7 @@ class cmp : public data<cmp,ptr_pair> {\n         result = sub.result;\n     }\n \n-    inline void walk_box_contents2(cmp &sub, ptr_pair &ref_count_dp) {\n+    inline void walk_box_contents2(cmp &sub, ptr_pair &box_dp) {\n         sub.align = true;\n         sub.walk();\n         result = sub.result;"}, {"sha": "92f660db741a7117dd33c8c3ec4a266f6ba96b3a", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 20, "deletions": 84, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -28,7 +28,6 @@ namespace shape {\n \n typedef unsigned long tag_variant_t;\n typedef unsigned long tag_align_t;\n-typedef unsigned long ref_cnt_t;\n \n // Constants\n \n@@ -376,7 +375,6 @@ ctxt<T>::walk() {\n     case SHAPE_TAG:      walk_tag0();             break;\n     case SHAPE_BOX:      walk_box0();             break;\n     case SHAPE_STRUCT:   walk_struct0();          break;\n-    case SHAPE_OBJ:      WALK_SIMPLE(walk_obj1);      break;\n     case SHAPE_RES:      walk_res0();             break;\n     case SHAPE_VAR:      walk_var0();             break;\n     case SHAPE_UNIQ:     walk_uniq0();            break;\n@@ -591,7 +589,6 @@ class print : public ctxt<print> {\n           default: abort();\n         }\n     }\n-    void walk_obj1() { DPRINT(\"obj\"); }\n     void walk_iface1() { DPRINT(\"iface\"); }\n \n     void walk_tydesc1(char kind) {\n@@ -645,7 +642,6 @@ class size_of : public ctxt<size_of> {\n     void walk_uniq1()       { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_box1()        { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_fn1(char)     { sa.set(sizeof(void *)*2, sizeof(void *)); }\n-    void walk_obj1()        { sa.set(sizeof(void *)*2, sizeof(void *)); }\n     void walk_iface1()      { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_tydesc1(char) { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_closure1();\n@@ -854,9 +850,8 @@ class data : public ctxt< data<T,U> > {\n \n     void walk_box_contents1();\n     void walk_uniq_contents1();\n-    void walk_fn_contents1(ptr &dp, bool null_td);\n-    void walk_obj_contents1(ptr &dp);\n-    void walk_iface_contents1(ptr &dp);\n+    void walk_fn_contents1();\n+    void walk_iface_contents1();\n     void walk_variant1(tag_info &tinfo, tag_variant_t variant);\n \n     static std::pair<uint8_t *,uint8_t *> get_vec_data_range(ptr dp);\n@@ -894,13 +889,6 @@ class data : public ctxt< data<T,U> > {\n         dp = next_dp;\n     }\n \n-    void walk_obj1() {\n-        ALIGN_TO(alignof<void *>());\n-        U next_dp = dp + sizeof(void *) * 2;\n-        static_cast<T *>(this)->walk_obj2();\n-        dp = next_dp;\n-    }\n-\n     void walk_iface1() {\n         ALIGN_TO(alignof<void *>());\n         U next_dp = dp + sizeof(void *);\n@@ -946,9 +934,17 @@ template<typename T,typename U>\n void\n data<T,U>::walk_box_contents1() {\n     typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n-    U ref_count_dp(box_ptr);\n-    T sub(*static_cast<T *>(this), ref_count_dp + sizeof(ref_cnt_t));\n-    static_cast<T *>(this)->walk_box_contents2(sub, ref_count_dp);\n+    U box_dp(box_ptr);\n+\n+    // No need to worry about alignment so long as the box header is\n+    // a multiple of 16 bytes.  We can just find the body by adding\n+    // the size of header to box_dp.\n+    assert ((sizeof(rust_opaque_box) % 16) == 0 ||\n+            !\"Must align to find the box body\");\n+\n+    U body_dp = box_dp + sizeof(rust_opaque_box);\n+    T sub(*static_cast<T *>(this), body_dp);\n+    static_cast<T *>(this)->walk_box_contents2(sub, box_dp);\n }\n \n template<typename T,typename U>\n@@ -1010,80 +1006,26 @@ data<T,U>::walk_tag1(tag_info &tinfo) {\n \n template<typename T,typename U>\n void\n-data<T,U>::walk_fn_contents1(ptr &dp, bool null_td) {\n+data<T,U>::walk_fn_contents1() {\n     fn_env_pair pair = bump_dp<fn_env_pair>(dp);\n     if (!pair.env)\n         return;\n \n     arena arena;\n     const type_desc *closure_td = pair.env->td;\n-    type_param *params =\n-      type_param::from_tydesc(closure_td, arena);\n-    ptr closure_dp((uintptr_t)pair.env);\n+    type_param *params = type_param::from_tydesc(closure_td, arena);\n+    ptr closure_dp((uintptr_t)box_body(pair.env));\n     T sub(*static_cast<T *>(this), closure_td->shape, params,\n           closure_td->shape_tables, closure_dp);\n     sub.align = true;\n \n-    if (null_td) {\n-        // if null_td flag is true, null out the type descr from\n-        // the data structure while we walk.  This is used in cycle\n-        // collector when we are sweeping up data.  The idea is that\n-        // we are using the information in the embedded type desc to\n-        // walk the contents, so we do not want to free it during that\n-        // walk.  This is not *strictly* necessary today because\n-        // type_param::from_tydesc() actually pulls out the \"shape\"\n-        // string and other information and copies it into a new\n-        // location that is unaffected by the free.  But it seems\n-        // safer, particularly as this pulling out of information will\n-        // not cope with nested, derived type descriptors.\n-        pair.env->td = NULL;\n-    }\n-\n-    sub.walk();\n-\n-    if (null_td) {\n-        pair.env->td = closure_td;\n-    }\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_obj_contents1(ptr &dp) {\n-    dp += sizeof(void *);   // Skip over the vtable.\n-\n-    uint8_t *box_ptr = bump_dp<uint8_t *>(dp);\n-    type_desc *subtydesc =\n-        *reinterpret_cast<type_desc **>(box_ptr + sizeof(void *));\n-    ptr obj_closure_dp(box_ptr + sizeof(void *));\n-    if (!box_ptr)   // Null check.\n-        return;\n-\n-    arena arena;\n-    type_param *params = type_param::from_obj_shape(subtydesc->shape,\n-                                                    obj_closure_dp, arena);\n-    T sub(*static_cast<T *>(this), subtydesc->shape, params,\n-          subtydesc->shape_tables, obj_closure_dp);\n-    sub.align = true;\n     sub.walk();\n }\n \n template<typename T,typename U>\n void\n-data<T,U>::walk_iface_contents1(ptr &dp) {\n-    uint8_t *box_ptr = bump_dp<uint8_t *>(dp);\n-    if (!box_ptr) return;\n-    U ref_count_dp(box_ptr);\n-    uint8_t *body_ptr = box_ptr + sizeof(void*);\n-    type_desc *valtydesc =\n-        *reinterpret_cast<type_desc **>(body_ptr);\n-    ptr value_dp(body_ptr + sizeof(void*) * 2);\n-    // FIXME The 5 is a hard-coded way to skip over a struct shape\n-    // header and the first two (number-typed) fields. This is too\n-    // fragile, but I didn't see a good way to properly encode it.\n-    T sub(*static_cast<T *>(this), valtydesc->shape + 5, NULL, NULL,\n-          value_dp);\n-    sub.align = true;\n-    static_cast<T *>(this)->walk_box_contents2(sub, ref_count_dp);\n+data<T,U>::walk_iface_contents1() {\n+    walk_box_contents1();\n }\n \n // Polymorphic logging, for convenience\n@@ -1161,19 +1103,13 @@ class log : public data<log,ptr> {\n     void walk_fn2(char kind) {\n         out << prefix << \"fn\";\n         prefix = \"\";\n-        data<log,ptr>::walk_fn_contents1(dp, false);\n-    }\n-\n-    void walk_obj2() {\n-        out << prefix << \"obj\";\n-        prefix = \"\";\n-        data<log,ptr>::walk_obj_contents1(dp);\n+        data<log,ptr>::walk_fn_contents1();\n     }\n \n     void walk_iface2() {\n         out << prefix << \"iface(\";\n         prefix = \"\";\n-        data<log,ptr>::walk_iface_contents1(dp);\n+        data<log,ptr>::walk_iface_contents1();\n         out << prefix << \")\";\n     }\n "}, {"sha": "4acef16a2090bd04fee401542ff889dfd1d8d04c", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -14,6 +14,7 @@\n #include <algorithm>\n \n #include \"globals.h\"\n+#include \"rust_upcall.h\"\n \n // The amount of extra space at the end of each stack segment, available\n // to the rt, compiler and dynamic linker for running small functions\n@@ -246,6 +247,7 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     running_on(-1),\n     pinned_on(-1),\n     local_region(&sched->srv->local_region),\n+    boxed(&local_region),\n     unwinding(false),\n     killed(false),\n     propagate_failure(true),\n@@ -295,7 +297,7 @@ rust_task::~rust_task()\n struct spawn_args {\n     rust_task *task;\n     spawn_fn f;\n-    rust_opaque_closure *envptr;\n+    rust_opaque_box *envptr;\n     void *argptr;\n };\n \n@@ -330,8 +332,6 @@ cleanup_task(cleanup_args *args) {\n     }\n }\n \n-extern \"C\" void upcall_shared_free(void* ptr);\n-\n // This runs on the Rust stack\n extern \"C\" CDECL\n void task_start_wrapper(spawn_args *a)\n@@ -349,12 +349,13 @@ void task_start_wrapper(spawn_args *a)\n         threw_exception = true;\n     }\n \n-    rust_opaque_closure* env = a->envptr;\n+    rust_opaque_box* env = a->envptr;\n     if(env) {\n-        // free the environment.\n+        // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n         LOG(task, task, \"Freeing env %p with td %p\", env, td);\n-        td->drop_glue(NULL, NULL, td->first_param, env);\n+        td->drop_glue(NULL, NULL, td->first_param, box_body(env));\n+        upcall_free_shared_type_desc(env->td);\n         upcall_shared_free(env);\n     }\n \n@@ -367,7 +368,7 @@ void task_start_wrapper(spawn_args *a)\n \n void\n rust_task::start(spawn_fn spawnee_fn,\n-                 rust_opaque_closure *envptr,\n+                 rust_opaque_box *envptr,\n                  void *argptr)\n {\n     LOG(this, task, \"starting task from fn 0x%\" PRIxPTR\n@@ -678,38 +679,6 @@ rust_port *rust_task::get_port_by_id(rust_port_id id) {\n     return port;\n }\n \n-\n-// Temporary routine to allow boxes on one task's shared heap to be reparented\n-// to another.\n-const type_desc *\n-rust_task::release_alloc(void *alloc) {\n-    I(sched, !lock.lock_held_by_current_thread());\n-    lock.lock();\n-\n-    assert(local_allocs.find(alloc) != local_allocs.end());\n-    const type_desc *tydesc = local_allocs[alloc];\n-    local_allocs.erase(alloc);\n-\n-    local_region.release_alloc(alloc);\n-\n-    lock.unlock();\n-    return tydesc;\n-}\n-\n-// Temporary routine to allow boxes from one task's shared heap to be\n-// reparented to this one.\n-void\n-rust_task::claim_alloc(void *alloc, const type_desc *tydesc) {\n-    I(sched, !lock.lock_held_by_current_thread());\n-    lock.lock();\n-\n-    assert(local_allocs.find(alloc) == local_allocs.end());\n-    local_allocs[alloc] = tydesc;\n-    local_region.claim_alloc(alloc);\n-\n-    lock.unlock();\n-}\n-\n void\n rust_task::notify(bool success) {\n     // FIXME (1078) Do this in rust code"}, {"sha": "418eb54cab5bfdc609b3e7dcf84a0f26b9f5fe5f", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -14,6 +14,7 @@\n #include \"rust_internal.h\"\n #include \"rust_kernel.h\"\n #include \"rust_obstack.h\"\n+#include \"boxed_region.h\"\n \n // Corresponds to the rust chan (currently _chan) type.\n struct chan_handle {\n@@ -106,6 +107,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     int pinned_on;\n \n     memory_region local_region;\n+    boxed_region boxed;\n \n     // Indicates that fail() has been called and we are cleaning up.\n     // We use this to suppress the \"killed\" flag during calls to yield.\n@@ -121,7 +123,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n     rust_obstack dynastack;\n \n-    std::map<void *,const type_desc *> local_allocs;\n     uint32_t cc_counter;\n \n     debug::task_debug_info debug;\n@@ -139,7 +140,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     ~rust_task();\n \n     void start(spawn_fn spawnee_fn,\n-               rust_opaque_closure *env,\n+               rust_opaque_box *env,\n                void *args);\n     void start();\n     bool running();\n@@ -194,11 +195,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     // not at all safe.\n     intptr_t get_ref_count() const { return ref_count; }\n \n-    // FIXME: These functions only exist to get the tasking system off the\n-    // ground. We should never be migrating shared boxes between tasks.\n-    const type_desc *release_alloc(void *alloc);\n-    void claim_alloc(void *alloc, const type_desc *tydesc);\n-\n     void notify(bool success);\n \n     void *new_stack(size_t stk_sz, void *args_addr, size_t args_sz);"}, {"sha": "09ad8d930c6cd5ac71b4048d64e9b6477eea361d", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -16,6 +16,20 @@\n #include <stdint.h>\n \n \n+#ifdef __GNUC__\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall,                                     \\\n+        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n+        \" retpc: x%\" PRIxPTR,                             \\\n+        __FUNCTION__,                                     \\\n+        (task)->name, (task),                             \\\n+        __builtin_return_address(0));\n+#else\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n+        (task)->name, (task));\n+#endif\n+\n // This is called to ensure we've set up our rust stacks\n // correctly. Strategically placed at entry to upcalls because they begin on\n // the rust stack and happen frequently enough to catch most stack changes,\n@@ -98,7 +112,6 @@ upcall_fail(char const *expr,\n \n struct s_malloc_args {\n     uintptr_t retval;\n-    size_t nbytes;\n     type_desc *td;\n };\n \n@@ -107,31 +120,27 @@ upcall_s_malloc(s_malloc_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    LOG(task, mem,\n-        \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \")\",\n-        args->nbytes, args->td);\n+    LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n \n     gc::maybe_gc(task);\n     cc::maybe_cc(task);\n \n-    // TODO: Maybe use dladdr here to find a more useful name for the\n-    // type_desc.\n-\n-    void *p = task->malloc(args->nbytes, \"tdesc\", args->td);\n-    memset(p, '\\0', args->nbytes);\n+    // FIXME--does this have to be calloc?\n+    rust_opaque_box *box = task->boxed.calloc(args->td);\n+    void *body = box_body(box);\n \n-    task->local_allocs[p] = args->td;\n-    debug::maybe_track_origin(task, p);\n+    debug::maybe_track_origin(task, box);\n \n     LOG(task, mem,\n-        \"upcall malloc(%\" PRIdPTR \", 0x%\" PRIxPTR \") = 0x%\" PRIxPTR,\n-        args->nbytes, args->td, (uintptr_t)p);\n-    args->retval = (uintptr_t) p;\n+        \"upcall malloc(0x%\" PRIxPTR \") = box 0x%\" PRIxPTR\n+        \" with body 0x%\" PRIxPTR,\n+        args->td, (uintptr_t)box, (uintptr_t)body);\n+    args->retval = (uintptr_t) box;\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_malloc(size_t nbytes, type_desc *td) {\n-    s_malloc_args args = {0, nbytes, td};\n+upcall_malloc(type_desc *td) {\n+    s_malloc_args args = {0, td};\n     UPCALL_SWITCH_STACK(&args, upcall_s_malloc);\n     return args.retval;\n }\n@@ -155,10 +164,10 @@ upcall_s_free(s_free_args *args) {\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)args->ptr, args->is_gc);\n \n-    task->local_allocs.erase(args->ptr);\n     debug::maybe_untrack_origin(task, args->ptr);\n \n-    task->free(args->ptr, (bool) args->is_gc);\n+    rust_opaque_box *box = (rust_opaque_box*) args->ptr;\n+    task->boxed.free(box);\n }\n \n extern \"C\" CDECL void\n@@ -167,6 +176,21 @@ upcall_free(void* ptr, uintptr_t is_gc) {\n     UPCALL_SWITCH_STACK(&args, upcall_s_free);\n }\n \n+/**********************************************************************\n+ * Sanity checks on boxes, insert when debugging possible\n+ * use-after-free bugs.  See maybe_validate_box() in trans.rs.\n+ */\n+\n+extern \"C\" CDECL void\n+upcall_validate_box(rust_opaque_box* ptr) {\n+    if (ptr) {\n+        assert(ptr->ref_count > 0);\n+        assert(ptr->td != NULL);\n+        assert(ptr->td->align <= 8);\n+        assert(ptr->td->size <= 4096); // might not really be true...\n+    }\n+}\n+\n /**********************************************************************\n  * Allocate an object in the exchange heap.\n  */"}, {"sha": "46676497d6330f4e3ca35e7d3640a0504c0a93f4", "filename": "src/rt/rust_upcall.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_upcall.h", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frust_upcall.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.h?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -1,17 +1,7 @@\n #pragma once\n \n-#ifdef __GNUC__\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall,                                     \\\n-        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n-        \" retpc: x%\" PRIxPTR,                             \\\n-        __FUNCTION__,                                     \\\n-        (task)->name, (task),                             \\\n-        __builtin_return_address(0));\n-#else\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n-        (task)->name, (task));\n-#endif\n+// Upcalls used from C code on occasion:\n \n+extern \"C\" CDECL void upcall_shared_free(void* ptr);\n+extern \"C\" CDECL void upcall_free_shared_type_desc(type_desc *td);\n "}, {"sha": "3701f73b0a82305566d6c92ba4bfe024c15bd2f2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -17,7 +17,6 @@ get_task_pointer\n get_time\n last_os_error\n leak\n-migrate_alloc\n nano_time\n new_port\n new_task\n@@ -63,6 +62,7 @@ upcall_dynastack_free\n upcall_dynastack_mark\n upcall_fail\n upcall_free\n+upcall_validate_box\n upcall_create_shared_type_desc\n upcall_free_shared_type_desc\n upcall_get_type_desc\n@@ -98,4 +98,3 @@ rust_uvtmp_read_start\n rust_uvtmp_timer\n rust_uvtmp_delete_buf\n rust_uvtmp_get_req_id\n-"}, {"sha": "51ec9219396c1b9672f8d57d50bb602770b997ec", "filename": "src/rt/test/rust_test_runtime.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/196d69beb2c91b29013d44d7a3855561fef600ab/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Ftest%2Frust_test_runtime.cpp?ref=196d69beb2c91b29013d44d7a3855561fef600ab", "patch": "@@ -39,7 +39,7 @@ rust_domain_test::run() {\n     return true;\n }\n \n-void task_entry(void *, rust_opaque_closure *, void *) {\n+void task_entry(void *, rust_opaque_box*, void *) {\n     printf(\"task entry\\n\");\n }\n "}]}