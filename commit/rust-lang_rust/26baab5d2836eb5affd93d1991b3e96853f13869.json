{"sha": "26baab5d2836eb5affd93d1991b3e96853f13869", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmFhYjVkMjgzNmViNWFmZmQ5M2QxOTkxYjNlOTY4NTNmMTM4Njk=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-28T18:25:01Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:45Z"}, "message": "Enable generation of non-exhaustiveness witnesses", "tree": {"sha": "58a34d9449743150e6e0e9d256742aa9d8cc0653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a34d9449743150e6e0e9d256742aa9d8cc0653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26baab5d2836eb5affd93d1991b3e96853f13869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26baab5d2836eb5affd93d1991b3e96853f13869", "html_url": "https://github.com/rust-lang/rust/commit/26baab5d2836eb5affd93d1991b3e96853f13869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26baab5d2836eb5affd93d1991b3e96853f13869/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b", "html_url": "https://github.com/rust-lang/rust/commit/c3c2893f302d087ff3c1ddd3a1d4e88c03c4356b"}], "stats": {"total": 89, "additions": 76, "deletions": 13}, "files": [{"sha": "4d17e8c9a1b97c2410b52f5eec493ac243307bf1", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=26baab5d2836eb5affd93d1991b3e96853f13869", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         } else {\n             &infer.type_of_expr[match_expr]\n         };\n-        eprintln!(\"ExprValidator::validate_match2({:?})\", match_expr_ty.kind(&Interner));\n+        // eprintln!(\"ExprValidator::validate_match2({:?})\", match_expr_ty.kind(&Interner));\n \n         let pattern_arena = usefulness::PatternArena::clone_from(&body.pats);\n         let cx = usefulness::MatchCheckCtx {\n@@ -408,6 +408,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         // }\n \n         let witnesses = report.non_exhaustiveness_witnesses;\n+        eprintln!(\"compute_match_usefulness(..) -> {:?}\", &witnesses);\n         if !witnesses.is_empty() {\n             if let Ok(source_ptr) = source_map.expr_syntax(id) {\n                 let root = source_ptr.file_syntax(db.upcast());"}, {"sha": "2f35552055f78c9935260c0b9d641ee7844a7a38", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=26baab5d2836eb5affd93d1991b3e96853f13869", "patch": "@@ -109,6 +109,7 @@ impl Constructor {\n         }\n     }\n \n+    /// Determines the constructor that the given pattern can be specialized to.\n     pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n         match &cx.pattern_arena.borrow()[pat] {\n             Pat::Bind { .. } | Pat::Wild => Wildcard,\n@@ -312,7 +313,6 @@ impl SplitWildcard {\n             //\n             // The exception is: if we are at the top-level, for example in an empty match, we\n             // sometimes prefer reporting the list of constructors instead of just `_`.\n-\n             let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(&pcx.ty);\n             let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n                 Missing"}, {"sha": "89e6c6593288ed0251b85de5fa24fbabd5a8debd", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26baab5d2836eb5affd93d1991b3e96853f13869/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=26baab5d2836eb5affd93d1991b3e96853f13869", "patch": "@@ -179,6 +179,7 @@ impl FromIterator<PatId> for PatStack {\n     }\n }\n \n+/// A 2D matrix.\n #[derive(Clone)]\n pub(super) struct Matrix {\n     patterns: Vec<PatStack>,\n@@ -321,6 +322,10 @@ impl SubPatSet {\n             }\n             _ => panic!(\"bug\"),\n         }\n+\n+        if self.is_full() {\n+            *self = Full;\n+        }\n     }\n \n     /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n@@ -449,14 +454,37 @@ impl Usefulness {\n     ) -> Self {\n         match self {\n             WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n-            WithWitnesses(w) => {\n+            WithWitnesses(witnesses) => {\n                 let new_witnesses = if matches!(ctor, Constructor::Missing) {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n                     split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    // Construct for each missing constructor a \"wild\" version of this\n+                    // constructor, that matches everything that can be built with\n+                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                    // `Option::Some`, we get the pattern `Some(_)`.\n+                    let new_patterns: Vec<_> = split_wildcard\n+                        .iter_missing(pcx)\n+                        .map(|missing_ctor| {\n+                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                        })\n+                        .collect();\n+                    witnesses\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect()\n                 } else {\n-                    todo!(\"Usefulness::apply_constructor({:?})\", ctor)\n+                    witnesses\n+                        .into_iter()\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .collect()\n                 };\n-                todo!(\"Usefulness::apply_constructor({:?})\", ctor)\n+                WithWitnesses(new_witnesses)\n             }\n             NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n         }\n@@ -469,6 +497,39 @@ enum WitnessPreference {\n     LeaveOutWitness,\n }\n \n+/// A witness of non-exhaustiveness for error reporting, represented\n+/// as a list of patterns (in reverse order of construction) with\n+/// wildcards inside to represent elements that can take any inhabitant\n+/// of the type as a value.\n+///\n+/// A witness against a list of patterns should have the same types\n+/// and length as the pattern matched against. Because Rust `match`\n+/// is always against a single pattern, at the end the witness will\n+/// have length 1, but in the middle of the algorithm, it can contain\n+/// multiple patterns.\n+///\n+/// For example, if we are constructing a witness for the match against\n+///\n+/// ```\n+/// struct Pair(Option<(u32, u32)>, bool);\n+///\n+/// match (p: Pair) {\n+///    Pair(None, _) => {}\n+///    Pair(_, false) => {}\n+/// }\n+/// ```\n+///\n+/// We'll perform the following steps:\n+/// 1. Start with an empty witness\n+///     `Witness(vec![])`\n+/// 2. Push a witness `true` against the `false`\n+///     `Witness(vec![true])`\n+/// 3. Push a witness `Some(_)` against the `None`\n+///     `Witness(vec![true, Some(_)])`\n+/// 4. Apply the `Pair` constructor to the witnesses\n+///     `Witness(vec![Pair(Some(_), true)])`\n+///\n+/// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Clone, Debug)]\n pub(crate) struct Witness(Vec<Pat>);\n \n@@ -560,7 +621,7 @@ fn is_useful(\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n-    // TODO(iDawer): ty.as_reference()\n+    // TODO(iDawer): ty.strip_references()  ?\n     let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n     let pcx = PatCtxt { cx, ty, is_top_level };\n \n@@ -643,6 +704,11 @@ pub(crate) struct UsefulnessReport {\n     pub(crate) non_exhaustiveness_witnesses: Vec<Pat>,\n }\n \n+/// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n+/// of its arms are reachable.\n+///\n+/// Note: the input patterns must have been lowered through\n+/// `check_match::MatchVisitor::lower_pattern`.\n pub(crate) fn compute_match_usefulness(\n     cx: &MatchCheckCtx<'_>,\n     arms: &[MatchArm],\n@@ -670,14 +736,10 @@ pub(crate) fn compute_match_usefulness(\n \n     let wild_pattern = cx.pattern_arena.borrow_mut().alloc(Pat::Wild, &cx.infer[cx.match_expr]);\n     let v = PatStack::from_pattern(wild_pattern);\n-    let usefulness = is_useful(cx, &matrix, &v, LeaveOutWitness, false, true);\n+    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n-        // TODO: ConstructWitness\n-        // WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n-        // NoWitnesses(_) => panic!(\"bug\"),\n-        NoWitnesses(subpats) if subpats.is_empty() => Vec::new(),\n-        NoWitnesses(subpats) => vec![Pat::Wild],\n-        WithWitnesses(..) => panic!(\"bug\"),\n+        WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n+        NoWitnesses(_) => panic!(\"bug\"),\n     };\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }"}]}