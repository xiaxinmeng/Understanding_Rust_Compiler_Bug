{"sha": "50b816f71f9055d6f162bec69c30b7574bb8e91a", "node_id": "C_kwDOAAsO6NoAKDUwYjgxNmY3MWY5MDU1ZDZmMTYyYmVjNjljMzBiNzU3NGJiOGU5MWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-15T21:43:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-15T21:43:36Z"}, "message": "Auto merge of #110319 - ferrocene:pa-more-ignore-reasons, r=ehuss\n\n[compiletest] Add more test ignore reasons, `needs-` validation, and improved error messages\n\nThis PR makes more improvements to the way compiletest ignoring headers are handled, following up on #108905:\n\n* Human-readable ignore reasons have been added for the remaining ignore causes (`needs-*` directives, `*llvm*` directives, and debugger version directives). All ignored tests should now have a human-readable reason.\n* The code handling `needs-*` directives has been refactored, and now invalid `needs-*` directive emit errors like `ignore-*` and `only-*`.\n* All errors are now displayed at startup (with line numbers) rather than just the first error of the first file.\n\nThis PR is best reviewed commit-by-commit.\n\nr? `@ehuss`", "tree": {"sha": "cdf61596f5b850448d4affa5854b1bd9e7a9271b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdf61596f5b850448d4affa5854b1bd9e7a9271b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50b816f71f9055d6f162bec69c30b7574bb8e91a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50b816f71f9055d6f162bec69c30b7574bb8e91a", "html_url": "https://github.com/rust-lang/rust/commit/50b816f71f9055d6f162bec69c30b7574bb8e91a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50b816f71f9055d6f162bec69c30b7574bb8e91a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cdb7886a5ece816864fab177f0c266ad4dd5358", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cdb7886a5ece816864fab177f0c266ad4dd5358", "html_url": "https://github.com/rust-lang/rust/commit/5cdb7886a5ece816864fab177f0c266ad4dd5358"}, {"sha": "34a52dfc7a8a650d940fac1a6258c7a4fb2ae19a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a52dfc7a8a650d940fac1a6258c7a4fb2ae19a", "html_url": "https://github.com/rust-lang/rust/commit/34a52dfc7a8a650d940fac1a6258c7a4fb2ae19a"}], "stats": {"total": 663, "additions": 467, "deletions": 196}, "files": [{"sha": "aaa70bf19b2fb73f50ce45c9d88c898bbf985735", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 133, "deletions": 178, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -12,13 +12,24 @@ use tracing::*;\n use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n use crate::header::cfg::parse_cfg_name_directive;\n use crate::header::cfg::MatchOutcome;\n-use crate::util;\n+use crate::header::needs::CachedNeedsConditions;\n use crate::{extract_cdb_version, extract_gdb_version};\n \n mod cfg;\n+mod needs;\n #[cfg(test)]\n mod tests;\n \n+pub struct HeadersCache {\n+    needs: CachedNeedsConditions,\n+}\n+\n+impl HeadersCache {\n+    pub fn load(config: &Config) -> Self {\n+        Self { needs: CachedNeedsConditions::load(config) }\n+    }\n+}\n+\n /// Properties which must be known very early, before actually running\n /// the test.\n #[derive(Default)]\n@@ -36,7 +47,7 @@ impl EarlyProps {\n \n     pub fn from_reader<R: Read>(config: &Config, testfile: &Path, rdr: R) -> Self {\n         let mut props = EarlyProps::default();\n-        iter_header(testfile, rdr, &mut |_, ln| {\n+        iter_header(testfile, rdr, &mut |_, ln, _| {\n             config.push_name_value_directive(ln, directives::AUX_BUILD, &mut props.aux, |r| {\n                 r.trim().to_string()\n             });\n@@ -288,7 +299,7 @@ impl TestProps {\n         if !testfile.is_dir() {\n             let file = File::open(testfile).unwrap();\n \n-            iter_header(testfile, file, &mut |revision, ln| {\n+            iter_header(testfile, file, &mut |revision, ln, _| {\n                 if revision.is_some() && revision != cfg {\n                     return;\n                 }\n@@ -582,7 +593,7 @@ pub fn line_directive<'line>(\n     }\n }\n \n-fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>, &str)) {\n+fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>, &str, usize)) {\n     if testfile.is_dir() {\n         return;\n     }\n@@ -591,8 +602,10 @@ fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>\n \n     let mut rdr = BufReader::new(rdr);\n     let mut ln = String::new();\n+    let mut line_number = 0;\n \n     loop {\n+        line_number += 1;\n         ln.clear();\n         if rdr.read_line(&mut ln).unwrap() == 0 {\n             break;\n@@ -605,7 +618,7 @@ fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return;\n         } else if let Some((lncfg, ln)) = line_directive(comment, ln) {\n-            it(lncfg, ln);\n+            it(lncfg, ln, line_number);\n         }\n     }\n }\n@@ -665,21 +678,6 @@ impl Config {\n         }\n     }\n \n-    fn parse_needs_matching_clang(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-matching-clang\")\n-    }\n-\n-    fn parse_needs_profiler_support(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-profiler-support\")\n-    }\n-\n-    fn has_cfg_prefix(&self, line: &str, prefix: &str) -> bool {\n-        // returns whether this line contains this prefix or not. For prefix\n-        // \"ignore\", returns true if line says \"ignore-x86_64\", \"ignore-arch\",\n-        // \"ignore-android\" etc.\n-        line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-')\n-    }\n-\n     fn parse_name_directive(&self, line: &str, directive: &str) -> bool {\n         // Ensure the directive is a whole word. Do not match \"ignore-x86\" when\n         // the line says \"ignore-x86_64\".\n@@ -867,155 +865,58 @@ where\n \n pub fn make_test_description<R: Read>(\n     config: &Config,\n+    cache: &HeadersCache,\n     name: test::TestName,\n     path: &Path,\n     src: R,\n     cfg: Option<&str>,\n+    poisoned: &mut bool,\n ) -> test::TestDesc {\n     let mut ignore = false;\n     let mut ignore_message = None;\n     let mut should_fail = false;\n \n-    let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n-    let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n-    let has_asm_support = config.has_asm_support();\n-    let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_cfi = util::CFI_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_kcfi = util::KCFI_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_kasan = util::KASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_hwasan = util::HWASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_memtag = util::MEMTAG_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_shadow_call_stack = util::SHADOWCALLSTACK_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_xray = util::XRAY_SUPPORTED_TARGETS.contains(&&*config.target);\n-\n-    // For tests using the `needs-rust-lld` directive (e.g. for `-Zgcc-ld=lld`), we need to find\n-    // whether `rust-lld` is present in the compiler under test.\n-    //\n-    // The --compile-lib-path is the path to host shared libraries, but depends on the OS. For\n-    // example:\n-    // - on linux, it can be <sysroot>/lib\n-    // - on windows, it can be <sysroot>/bin\n-    //\n-    // However, `rust-lld` is only located under the lib path, so we look for it there.\n-    let has_rust_lld = config\n-        .compile_lib_path\n-        .parent()\n-        .expect(\"couldn't traverse to the parent of the specified --compile-lib-path\")\n-        .join(\"lib\")\n-        .join(\"rustlib\")\n-        .join(&config.target)\n-        .join(\"bin\")\n-        .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n-        .exists();\n-\n-    fn is_on_path(file: &'static str) -> impl Fn() -> bool {\n-        move || env::split_paths(&env::var_os(\"PATH\").unwrap()).any(|dir| dir.join(file).is_file())\n-    }\n-\n-    // On Windows, dlltool.exe is used for all architectures.\n-    #[cfg(windows)]\n-    let (has_i686_dlltool, has_x86_64_dlltool) =\n-        (is_on_path(\"dlltool.exe\"), is_on_path(\"dlltool.exe\"));\n-    // For non-Windows, there are architecture specific dlltool binaries.\n-    #[cfg(not(windows))]\n-    let (has_i686_dlltool, has_x86_64_dlltool) =\n-        (is_on_path(\"i686-w64-mingw32-dlltool\"), is_on_path(\"x86_64-w64-mingw32-dlltool\"));\n-\n-    iter_header(path, src, &mut |revision, ln| {\n+    iter_header(path, src, &mut |revision, ln, line_number| {\n         if revision.is_some() && revision != cfg {\n             return;\n         }\n-        macro_rules! reason {\n+\n+        macro_rules! decision {\n             ($e:expr) => {\n-                ignore |= match $e {\n-                    true => {\n-                        ignore_message = Some(stringify!($e));\n-                        true\n+                match $e {\n+                    IgnoreDecision::Ignore { reason } => {\n+                        ignore = true;\n+                        // The ignore reason must be a &'static str, so we have to leak memory to\n+                        // create it. This is fine, as the header is parsed only at the start of\n+                        // compiletest so it won't grow indefinitely.\n+                        ignore_message = Some(&*Box::leak(Box::<str>::from(reason)));\n                     }\n-                    false => ignore,\n-                }\n-            };\n-        }\n-\n-        {\n-            let parsed = parse_cfg_name_directive(config, ln, \"ignore\");\n-            ignore = match parsed.outcome {\n-                MatchOutcome::Match => {\n-                    let reason = parsed.pretty_reason.unwrap();\n-                    // The ignore reason must be a &'static str, so we have to leak memory to\n-                    // create it. This is fine, as the header is parsed only at the start of\n-                    // compiletest so it won't grow indefinitely.\n-                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n-                        Some(comment) => format!(\"ignored {reason} ({comment})\"),\n-                        None => format!(\"ignored {reason}\"),\n-                    })) as &str);\n-                    true\n+                    IgnoreDecision::Error { message } => {\n+                        eprintln!(\"error: {}:{line_number}: {message}\", path.display());\n+                        *poisoned = true;\n+                        return;\n+                    }\n+                    IgnoreDecision::Continue => {}\n                 }\n-                MatchOutcome::NoMatch => ignore,\n-                MatchOutcome::External => ignore,\n-                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n             };\n         }\n \n-        if config.has_cfg_prefix(ln, \"only\") {\n-            let parsed = parse_cfg_name_directive(config, ln, \"only\");\n-            ignore = match parsed.outcome {\n-                MatchOutcome::Match => ignore,\n-                MatchOutcome::NoMatch => {\n-                    let reason = parsed.pretty_reason.unwrap();\n-                    // The ignore reason must be a &'static str, so we have to leak memory to\n-                    // create it. This is fine, as the header is parsed only at the start of\n-                    // compiletest so it won't grow indefinitely.\n-                    ignore_message = Some(Box::leak(Box::<str>::from(match parsed.comment {\n-                        Some(comment) => format!(\"only executed {reason} ({comment})\"),\n-                        None => format!(\"only executed {reason}\"),\n-                    })) as &str);\n-                    true\n-                }\n-                MatchOutcome::External => ignore,\n-                MatchOutcome::Invalid => panic!(\"invalid line in {}: {ln}\", path.display()),\n-            };\n+        decision!(cfg::handle_ignore(config, ln));\n+        decision!(cfg::handle_only(config, ln));\n+        decision!(needs::handle_needs(&cache.needs, config, ln));\n+        decision!(ignore_llvm(config, ln));\n+        decision!(ignore_cdb(config, ln));\n+        decision!(ignore_gdb(config, ln));\n+        decision!(ignore_lldb(config, ln));\n+\n+        if config.target == \"wasm32-unknown-unknown\" {\n+            if config.parse_name_directive(ln, directives::CHECK_RUN_RESULTS) {\n+                decision!(IgnoreDecision::Ignore {\n+                    reason: \"ignored when checking the run results on WASM\".into(),\n+                });\n+            }\n         }\n \n-        reason!(ignore_llvm(config, ln));\n-        reason!(\n-            config.run_clang_based_tests_with.is_none() && config.parse_needs_matching_clang(ln)\n-        );\n-        reason!(!has_asm_support && config.parse_name_directive(ln, \"needs-asm-support\"));\n-        reason!(!rustc_has_profiler_support && config.parse_needs_profiler_support(ln));\n-        reason!(!config.run_enabled() && config.parse_name_directive(ln, \"needs-run-enabled\"));\n-        reason!(\n-            !rustc_has_sanitizer_support\n-                && config.parse_name_directive(ln, \"needs-sanitizer-support\")\n-        );\n-        reason!(!has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\"));\n-        reason!(!has_cfi && config.parse_name_directive(ln, \"needs-sanitizer-cfi\"));\n-        reason!(!has_kcfi && config.parse_name_directive(ln, \"needs-sanitizer-kcfi\"));\n-        reason!(!has_kasan && config.parse_name_directive(ln, \"needs-sanitizer-kasan\"));\n-        reason!(!has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\"));\n-        reason!(!has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\"));\n-        reason!(!has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\"));\n-        reason!(!has_hwasan && config.parse_name_directive(ln, \"needs-sanitizer-hwaddress\"));\n-        reason!(!has_memtag && config.parse_name_directive(ln, \"needs-sanitizer-memtag\"));\n-        reason!(\n-            !has_shadow_call_stack\n-                && config.parse_name_directive(ln, \"needs-sanitizer-shadow-call-stack\")\n-        );\n-        reason!(!config.can_unwind() && config.parse_name_directive(ln, \"needs-unwind\"));\n-        reason!(!has_xray && config.parse_name_directive(ln, \"needs-xray\"));\n-        reason!(\n-            config.target == \"wasm32-unknown-unknown\"\n-                && config.parse_name_directive(ln, directives::CHECK_RUN_RESULTS)\n-        );\n-        reason!(config.debugger == Some(Debugger::Cdb) && ignore_cdb(config, ln));\n-        reason!(config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln));\n-        reason!(config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln));\n-        reason!(!has_rust_lld && config.parse_name_directive(ln, \"needs-rust-lld\"));\n-        reason!(config.parse_name_directive(ln, \"needs-i686-dlltool\") && !has_i686_dlltool());\n-        reason!(config.parse_name_directive(ln, \"needs-x86_64-dlltool\") && !has_x86_64_dlltool());\n         should_fail |= config.parse_name_directive(ln, \"should-fail\");\n     });\n \n@@ -1049,22 +950,34 @@ pub fn make_test_description<R: Read>(\n     }\n }\n \n-fn ignore_cdb(config: &Config, line: &str) -> bool {\n+fn ignore_cdb(config: &Config, line: &str) -> IgnoreDecision {\n+    if config.debugger != Some(Debugger::Cdb) {\n+        return IgnoreDecision::Continue;\n+    }\n+\n     if let Some(actual_version) = config.cdb_version {\n-        if let Some(min_version) = line.strip_prefix(\"min-cdb-version:\").map(str::trim) {\n-            let min_version = extract_cdb_version(min_version).unwrap_or_else(|| {\n-                panic!(\"couldn't parse version range: {:?}\", min_version);\n+        if let Some(rest) = line.strip_prefix(\"min-cdb-version:\").map(str::trim) {\n+            let min_version = extract_cdb_version(rest).unwrap_or_else(|| {\n+                panic!(\"couldn't parse version range: {:?}\", rest);\n             });\n \n             // Ignore if actual version is smaller than the minimum\n             // required version\n-            return actual_version < min_version;\n+            if actual_version < min_version {\n+                return IgnoreDecision::Ignore {\n+                    reason: format!(\"ignored when the CDB version is lower than {rest}\"),\n+                };\n+            }\n         }\n     }\n-    false\n+    IgnoreDecision::Continue\n }\n \n-fn ignore_gdb(config: &Config, line: &str) -> bool {\n+fn ignore_gdb(config: &Config, line: &str) -> IgnoreDecision {\n+    if config.debugger != Some(Debugger::Gdb) {\n+        return IgnoreDecision::Continue;\n+    }\n+\n     if let Some(actual_version) = config.gdb_version {\n         if let Some(rest) = line.strip_prefix(\"min-gdb-version:\").map(str::trim) {\n             let (start_ver, end_ver) = extract_version_range(rest, extract_gdb_version)\n@@ -1077,7 +990,11 @@ fn ignore_gdb(config: &Config, line: &str) -> bool {\n             }\n             // Ignore if actual version is smaller than the minimum\n             // required version\n-            return actual_version < start_ver;\n+            if actual_version < start_ver {\n+                return IgnoreDecision::Ignore {\n+                    reason: format!(\"ignored when the GDB version is lower than {rest}\"),\n+                };\n+            }\n         } else if let Some(rest) = line.strip_prefix(\"ignore-gdb-version:\").map(str::trim) {\n             let (min_version, max_version) = extract_version_range(rest, extract_gdb_version)\n                 .unwrap_or_else(|| {\n@@ -1088,32 +1005,47 @@ fn ignore_gdb(config: &Config, line: &str) -> bool {\n                 panic!(\"Malformed GDB version range: max < min\")\n             }\n \n-            return actual_version >= min_version && actual_version <= max_version;\n+            if actual_version >= min_version && actual_version <= max_version {\n+                if min_version == max_version {\n+                    return IgnoreDecision::Ignore {\n+                        reason: format!(\"ignored when the GDB version is {rest}\"),\n+                    };\n+                } else {\n+                    return IgnoreDecision::Ignore {\n+                        reason: format!(\"ignored when the GDB version is between {rest}\"),\n+                    };\n+                }\n+            }\n         }\n     }\n-    false\n+    IgnoreDecision::Continue\n }\n \n-fn ignore_lldb(config: &Config, line: &str) -> bool {\n+fn ignore_lldb(config: &Config, line: &str) -> IgnoreDecision {\n+    if config.debugger != Some(Debugger::Lldb) {\n+        return IgnoreDecision::Continue;\n+    }\n+\n     if let Some(actual_version) = config.lldb_version {\n-        if let Some(min_version) = line.strip_prefix(\"min-lldb-version:\").map(str::trim) {\n-            let min_version = min_version.parse().unwrap_or_else(|e| {\n-                panic!(\"Unexpected format of LLDB version string: {}\\n{:?}\", min_version, e);\n+        if let Some(rest) = line.strip_prefix(\"min-lldb-version:\").map(str::trim) {\n+            let min_version = rest.parse().unwrap_or_else(|e| {\n+                panic!(\"Unexpected format of LLDB version string: {}\\n{:?}\", rest, e);\n             });\n             // Ignore if actual version is smaller the minimum required\n             // version\n-            actual_version < min_version\n-        } else {\n-            line.starts_with(\"rust-lldb\") && !config.lldb_native_rust\n+            if actual_version < min_version {\n+                return IgnoreDecision::Ignore {\n+                    reason: format!(\"ignored when the LLDB version is {rest}\"),\n+                };\n+            }\n         }\n-    } else {\n-        false\n     }\n+    IgnoreDecision::Continue\n }\n \n-fn ignore_llvm(config: &Config, line: &str) -> bool {\n+fn ignore_llvm(config: &Config, line: &str) -> IgnoreDecision {\n     if config.system_llvm && line.starts_with(\"no-system-llvm\") {\n-        return true;\n+        return IgnoreDecision::Ignore { reason: \"ignored when the system LLVM is used\".into() };\n     }\n     if let Some(needed_components) =\n         config.parse_name_value_directive(line, \"needs-llvm-components\")\n@@ -1126,20 +1058,30 @@ fn ignore_llvm(config: &Config, line: &str) -> bool {\n             if env::var_os(\"COMPILETEST_NEEDS_ALL_LLVM_COMPONENTS\").is_some() {\n                 panic!(\"missing LLVM component: {}\", missing_component);\n             }\n-            return true;\n+            return IgnoreDecision::Ignore {\n+                reason: format!(\"ignored when the {missing_component} LLVM component is missing\"),\n+            };\n         }\n     }\n     if let Some(actual_version) = config.llvm_version {\n         if let Some(rest) = line.strip_prefix(\"min-llvm-version:\").map(str::trim) {\n             let min_version = extract_llvm_version(rest).unwrap();\n             // Ignore if actual version is smaller the minimum required\n             // version\n-            actual_version < min_version\n+            if actual_version < min_version {\n+                return IgnoreDecision::Ignore {\n+                    reason: format!(\"ignored when the LLVM version is older than {rest}\"),\n+                };\n+            }\n         } else if let Some(rest) = line.strip_prefix(\"min-system-llvm-version:\").map(str::trim) {\n             let min_version = extract_llvm_version(rest).unwrap();\n             // Ignore if using system LLVM and actual version\n             // is smaller the minimum required version\n-            config.system_llvm && actual_version < min_version\n+            if config.system_llvm && actual_version < min_version {\n+                return IgnoreDecision::Ignore {\n+                    reason: format!(\"ignored when the system LLVM version is older than {rest}\"),\n+                };\n+            }\n         } else if let Some(rest) = line.strip_prefix(\"ignore-llvm-version:\").map(str::trim) {\n             // Syntax is: \"ignore-llvm-version: <version1> [- <version2>]\"\n             let (v_min, v_max) =\n@@ -1150,11 +1092,24 @@ fn ignore_llvm(config: &Config, line: &str) -> bool {\n                 panic!(\"Malformed LLVM version range: max < min\")\n             }\n             // Ignore if version lies inside of range.\n-            actual_version >= v_min && actual_version <= v_max\n-        } else {\n-            false\n+            if actual_version >= v_min && actual_version <= v_max {\n+                if v_min == v_max {\n+                    return IgnoreDecision::Ignore {\n+                        reason: format!(\"ignored when the LLVM version is {rest}\"),\n+                    };\n+                } else {\n+                    return IgnoreDecision::Ignore {\n+                        reason: format!(\"ignored when the LLVM version is between {rest}\"),\n+                    };\n+                }\n+            }\n         }\n-    } else {\n-        false\n     }\n+    IgnoreDecision::Continue\n+}\n+\n+enum IgnoreDecision {\n+    Ignore { reason: String },\n+    Continue,\n+    Error { message: String },\n }"}, {"sha": "a9694d4d52c883206ce2ff2bd93d43f6ae627e95", "filename": "src/tools/compiletest/src/header/cfg.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,8 +1,43 @@\n use crate::common::{CompareMode, Config, Debugger};\n+use crate::header::IgnoreDecision;\n use std::collections::HashSet;\n \n const EXTRA_ARCHS: &[&str] = &[\"spirv\"];\n \n+pub(super) fn handle_ignore(config: &Config, line: &str) -> IgnoreDecision {\n+    let parsed = parse_cfg_name_directive(config, line, \"ignore\");\n+    match parsed.outcome {\n+        MatchOutcome::NoMatch => IgnoreDecision::Continue,\n+        MatchOutcome::Match => IgnoreDecision::Ignore {\n+            reason: match parsed.comment {\n+                Some(comment) => format!(\"ignored {} ({comment})\", parsed.pretty_reason.unwrap()),\n+                None => format!(\"ignored {}\", parsed.pretty_reason.unwrap()),\n+            },\n+        },\n+        MatchOutcome::Invalid => IgnoreDecision::Error { message: format!(\"invalid line: {line}\") },\n+        MatchOutcome::External => IgnoreDecision::Continue,\n+        MatchOutcome::NotADirective => IgnoreDecision::Continue,\n+    }\n+}\n+\n+pub(super) fn handle_only(config: &Config, line: &str) -> IgnoreDecision {\n+    let parsed = parse_cfg_name_directive(config, line, \"only\");\n+    match parsed.outcome {\n+        MatchOutcome::Match => IgnoreDecision::Continue,\n+        MatchOutcome::NoMatch => IgnoreDecision::Ignore {\n+            reason: match parsed.comment {\n+                Some(comment) => {\n+                    format!(\"only executed {} ({comment})\", parsed.pretty_reason.unwrap())\n+                }\n+                None => format!(\"only executed {}\", parsed.pretty_reason.unwrap()),\n+            },\n+        },\n+        MatchOutcome::Invalid => IgnoreDecision::Error { message: format!(\"invalid line: {line}\") },\n+        MatchOutcome::External => IgnoreDecision::Continue,\n+        MatchOutcome::NotADirective => IgnoreDecision::Continue,\n+    }\n+}\n+\n /// Parses a name-value directive which contains config-specific information, e.g., `ignore-x86`\n /// or `normalize-stderr-32bit`.\n pub(super) fn parse_cfg_name_directive<'a>(\n@@ -11,10 +46,10 @@ pub(super) fn parse_cfg_name_directive<'a>(\n     prefix: &str,\n ) -> ParsedNameDirective<'a> {\n     if !line.as_bytes().starts_with(prefix.as_bytes()) {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n     if line.as_bytes().get(prefix.len()) != Some(&b'-') {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n     let line = &line[prefix.len() + 1..];\n \n@@ -24,7 +59,7 @@ pub(super) fn parse_cfg_name_directive<'a>(\n     // Some of the matchers might be \"\" depending on what the target information is. To avoid\n     // problems we outright reject empty directives.\n     if name == \"\" {\n-        return ParsedNameDirective::invalid();\n+        return ParsedNameDirective::not_a_directive();\n     }\n \n     let mut outcome = MatchOutcome::Invalid;\n@@ -218,8 +253,13 @@ pub(super) struct ParsedNameDirective<'a> {\n }\n \n impl ParsedNameDirective<'_> {\n-    fn invalid() -> Self {\n-        Self { name: None, pretty_reason: None, comment: None, outcome: MatchOutcome::NoMatch }\n+    fn not_a_directive() -> Self {\n+        Self {\n+            name: None,\n+            pretty_reason: None,\n+            comment: None,\n+            outcome: MatchOutcome::NotADirective,\n+        }\n     }\n }\n \n@@ -233,6 +273,8 @@ pub(super) enum MatchOutcome {\n     Invalid,\n     /// The directive is handled by other parts of our tooling.\n     External,\n+    /// The line is not actually a directive.\n+    NotADirective,\n }\n \n trait CustomContains {"}, {"sha": "35d6179abaa6bb98c106e342d2b7078075c4df68", "filename": "src/tools/compiletest/src/header/needs.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -0,0 +1,236 @@\n+use crate::common::{Config, Debugger};\n+use crate::header::IgnoreDecision;\n+use crate::util;\n+\n+pub(super) fn handle_needs(\n+    cache: &CachedNeedsConditions,\n+    config: &Config,\n+    ln: &str,\n+) -> IgnoreDecision {\n+    // Note thet we intentionally still put the needs- prefix here to make the file show up when\n+    // grepping for a directive name, even though we could technically strip that.\n+    let needs = &[\n+        Need {\n+            name: \"needs-asm-support\",\n+            condition: config.has_asm_support(),\n+            ignore_reason: \"ignored on targets without inline assembly support\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-support\",\n+            condition: cache.sanitizer_support,\n+            ignore_reason: \"ignored on targets without sanitizers support\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-address\",\n+            condition: cache.sanitizer_address,\n+            ignore_reason: \"ignored on targets without address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-cfi\",\n+            condition: cache.sanitizer_cfi,\n+            ignore_reason: \"ignored on targets without CFI sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-kcfi\",\n+            condition: cache.sanitizer_kcfi,\n+            ignore_reason: \"ignored on targets without kernel CFI sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-kasan\",\n+            condition: cache.sanitizer_kasan,\n+            ignore_reason: \"ignored on targets without kernel address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-leak\",\n+            condition: cache.sanitizer_leak,\n+            ignore_reason: \"ignored on targets without leak sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-memory\",\n+            condition: cache.sanitizer_memory,\n+            ignore_reason: \"ignored on targets without memory sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-thread\",\n+            condition: cache.sanitizer_thread,\n+            ignore_reason: \"ignored on targets without thread sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-hwaddress\",\n+            condition: cache.sanitizer_hwaddress,\n+            ignore_reason: \"ignored on targets without hardware-assisted address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-memtag\",\n+            condition: cache.sanitizer_memtag,\n+            ignore_reason: \"ignored on targets without memory tagging sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-shadow-call-stack\",\n+            condition: cache.sanitizer_shadow_call_stack,\n+            ignore_reason: \"ignored on targets without shadow call stacks\",\n+        },\n+        Need {\n+            name: \"needs-run-enabled\",\n+            condition: config.run_enabled(),\n+            ignore_reason: \"ignored when running the resulting test binaries is disabled\",\n+        },\n+        Need {\n+            name: \"needs-unwind\",\n+            condition: config.can_unwind(),\n+            ignore_reason: \"ignored on targets without unwinding support\",\n+        },\n+        Need {\n+            name: \"needs-profiler-support\",\n+            condition: std::env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some(),\n+            ignore_reason: \"ignored when profiler support is disabled\",\n+        },\n+        Need {\n+            name: \"needs-matching-clang\",\n+            condition: config.run_clang_based_tests_with.is_some(),\n+            ignore_reason: \"ignored when the used clang does not match the built LLVM\",\n+        },\n+        Need {\n+            name: \"needs-xray\",\n+            condition: cache.xray,\n+            ignore_reason: \"ignored on targets without xray tracing\",\n+        },\n+        Need {\n+            name: \"needs-rust-lld\",\n+            condition: cache.rust_lld,\n+            ignore_reason: \"ignored on targets without Rust's LLD\",\n+        },\n+        Need {\n+            name: \"needs-rust-lldb\",\n+            condition: config.debugger != Some(Debugger::Lldb) || config.lldb_native_rust,\n+            ignore_reason: \"ignored on targets without Rust's LLDB\",\n+        },\n+        Need {\n+            name: \"needs-i686-dlltool\",\n+            condition: cache.i686_dlltool,\n+            ignore_reason: \"ignored when dlltool for i686 is not present\",\n+        },\n+        Need {\n+            name: \"needs-x86_64-dlltool\",\n+            condition: cache.x86_64_dlltool,\n+            ignore_reason: \"ignored when dlltool for x86_64 is not present\",\n+        },\n+    ];\n+\n+    let (name, comment) = match ln.split_once([':', ' ']) {\n+        Some((name, comment)) => (name, Some(comment)),\n+        None => (ln, None),\n+    };\n+\n+    if !name.starts_with(\"needs-\") {\n+        return IgnoreDecision::Continue;\n+    }\n+\n+    // Handled elsewhere.\n+    if name == \"needs-llvm-components\" {\n+        return IgnoreDecision::Continue;\n+    }\n+\n+    let mut found_valid = false;\n+    for need in needs {\n+        if need.name == name {\n+            if need.condition {\n+                found_valid = true;\n+                break;\n+            } else {\n+                return IgnoreDecision::Ignore {\n+                    reason: if let Some(comment) = comment {\n+                        format!(\"{} ({comment})\", need.ignore_reason)\n+                    } else {\n+                        need.ignore_reason.into()\n+                    },\n+                };\n+            }\n+        }\n+    }\n+\n+    if found_valid {\n+        IgnoreDecision::Continue\n+    } else {\n+        IgnoreDecision::Error { message: format!(\"invalid needs directive: {name}\") }\n+    }\n+}\n+\n+struct Need {\n+    name: &'static str,\n+    condition: bool,\n+    ignore_reason: &'static str,\n+}\n+\n+pub(super) struct CachedNeedsConditions {\n+    sanitizer_support: bool,\n+    sanitizer_address: bool,\n+    sanitizer_cfi: bool,\n+    sanitizer_kcfi: bool,\n+    sanitizer_kasan: bool,\n+    sanitizer_leak: bool,\n+    sanitizer_memory: bool,\n+    sanitizer_thread: bool,\n+    sanitizer_hwaddress: bool,\n+    sanitizer_memtag: bool,\n+    sanitizer_shadow_call_stack: bool,\n+    xray: bool,\n+    rust_lld: bool,\n+    i686_dlltool: bool,\n+    x86_64_dlltool: bool,\n+}\n+\n+impl CachedNeedsConditions {\n+    pub(super) fn load(config: &Config) -> Self {\n+        let path = std::env::var_os(\"PATH\").expect(\"missing PATH environment variable\");\n+        let path = std::env::split_paths(&path).collect::<Vec<_>>();\n+\n+        let target = &&*config.target;\n+        Self {\n+            sanitizer_support: std::env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some(),\n+            sanitizer_address: util::ASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_cfi: util::CFI_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_kcfi: util::KCFI_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_kasan: util::KASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_leak: util::LSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_memory: util::MSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_thread: util::TSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_hwaddress: util::HWASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_memtag: util::MEMTAG_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_shadow_call_stack: util::SHADOWCALLSTACK_SUPPORTED_TARGETS.contains(target),\n+            xray: util::XRAY_SUPPORTED_TARGETS.contains(target),\n+\n+            // For tests using the `needs-rust-lld` directive (e.g. for `-Zgcc-ld=lld`), we need to find\n+            // whether `rust-lld` is present in the compiler under test.\n+            //\n+            // The --compile-lib-path is the path to host shared libraries, but depends on the OS. For\n+            // example:\n+            // - on linux, it can be <sysroot>/lib\n+            // - on windows, it can be <sysroot>/bin\n+            //\n+            // However, `rust-lld` is only located under the lib path, so we look for it there.\n+            rust_lld: config\n+                .compile_lib_path\n+                .parent()\n+                .expect(\"couldn't traverse to the parent of the specified --compile-lib-path\")\n+                .join(\"lib\")\n+                .join(\"rustlib\")\n+                .join(target)\n+                .join(\"bin\")\n+                .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n+                .exists(),\n+\n+            // On Windows, dlltool.exe is used for all architectures.\n+            #[cfg(windows)]\n+            i686_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+            #[cfg(windows)]\n+            x86_64_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+\n+            // For non-Windows, there are architecture specific dlltool binaries.\n+            #[cfg(not(windows))]\n+            i686_dlltool: path.iter().any(|dir| dir.join(\"i686-w64-mingw32-dlltool\").is_file()),\n+            #[cfg(not(windows))]\n+            x86_64_dlltool: path.iter().any(|dir| dir.join(\"x86_64-w64-mingw32-dlltool\").is_file()),\n+        }\n+    }\n+}"}, {"sha": "9af7bd5e20145bb73ab8f6e90a536840797a4484", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,7 +1,25 @@\n+use std::io::Read;\n use std::path::Path;\n \n use crate::common::{Config, Debugger};\n-use crate::header::{make_test_description, parse_normalization_string, EarlyProps};\n+use crate::header::{parse_normalization_string, EarlyProps, HeadersCache};\n+\n+fn make_test_description<R: Read>(\n+    config: &Config,\n+    name: test::TestName,\n+    path: &Path,\n+    src: R,\n+    cfg: Option<&str>,\n+) -> test::TestDesc {\n+    let cache = HeadersCache::load(config);\n+    let mut poisoned = false;\n+    let test =\n+        crate::header::make_test_description(config, &cache, name, path, src, cfg, &mut poisoned);\n+    if poisoned {\n+        panic!(\"poisoned!\");\n+    }\n+    test\n+}\n \n #[test]\n fn test_parse_normalization_string() {"}, {"sha": "4a2b9de8aee6b04c50f29345d8371e1b8fdfb3c1", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -25,6 +25,7 @@ use tracing::*;\n use walkdir::WalkDir;\n \n use self::header::{make_test_description, EarlyProps};\n+use crate::header::HeadersCache;\n use std::sync::Arc;\n \n #[cfg(test)]\n@@ -558,16 +559,26 @@ pub fn make_tests(\n     let modified_tests = modified_tests(&config, &config.src_base).unwrap_or_else(|err| {\n         panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n     });\n+\n+    let cache = HeadersCache::load(&config);\n+    let mut poisoned = false;\n     collect_tests_from_dir(\n         config.clone(),\n+        &cache,\n         &config.src_base,\n         &PathBuf::new(),\n         &inputs,\n         tests,\n         found_paths,\n         &modified_tests,\n+        &mut poisoned,\n     )\n     .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n+\n+    if poisoned {\n+        eprintln!();\n+        panic!(\"there are errors in tests\");\n+    }\n }\n \n /// Returns a stamp constructed from input files common to all test cases.\n@@ -631,12 +642,14 @@ fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n \n fn collect_tests_from_dir(\n     config: Arc<Config>,\n+    cache: &HeadersCache,\n     dir: &Path,\n     relative_dir_path: &Path,\n     inputs: &Stamp,\n     tests: &mut Vec<test::TestDescAndFn>,\n     found_paths: &mut BTreeSet<PathBuf>,\n     modified_tests: &Vec<PathBuf>,\n+    poisoned: &mut bool,\n ) -> io::Result<()> {\n     // Ignore directories that contain a file named `compiletest-ignore-dir`.\n     if dir.join(\"compiletest-ignore-dir\").exists() {\n@@ -648,7 +661,7 @@ fn collect_tests_from_dir(\n             file: dir.to_path_buf(),\n             relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n         };\n-        tests.extend(make_test(config, &paths, inputs));\n+        tests.extend(make_test(config, cache, &paths, inputs, poisoned));\n         return Ok(());\n     }\n \n@@ -674,19 +687,21 @@ fn collect_tests_from_dir(\n             let paths =\n                 TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n \n-            tests.extend(make_test(config.clone(), &paths, inputs))\n+            tests.extend(make_test(config.clone(), cache, &paths, inputs, poisoned))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n                 collect_tests_from_dir(\n                     config.clone(),\n+                    cache,\n                     &file_path,\n                     &relative_file_path,\n                     inputs,\n                     tests,\n                     found_paths,\n                     modified_tests,\n+                    poisoned,\n                 )?;\n             }\n         } else {\n@@ -711,8 +726,10 @@ pub fn is_test(file_name: &OsString) -> bool {\n \n fn make_test(\n     config: Arc<Config>,\n+    cache: &HeadersCache,\n     testpaths: &TestPaths,\n     inputs: &Stamp,\n+    poisoned: &mut bool,\n ) -> Vec<test::TestDescAndFn> {\n     let test_path = if config.mode == Mode::RunMake {\n         // Parse directives in the Makefile\n@@ -729,14 +746,17 @@ fn make_test(\n     } else {\n         early_props.revisions.iter().map(Some).collect()\n     };\n+\n     revisions\n         .into_iter()\n         .map(|revision| {\n             let src_file =\n                 std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n             let cfg = revision.map(|v| &**v);\n             let test_name = crate::make_test_name(&config, testpaths, revision);\n-            let mut desc = make_test_description(&config, test_name, &test_path, src_file, cfg);\n+            let mut desc = make_test_description(\n+                &config, cache, test_name, &test_path, src_file, cfg, poisoned,\n+            );\n             // Ignore tests that already run and are up to date with respect to inputs.\n             if !config.force_rerun {\n                 desc.ignore |= is_up_to_date("}, {"sha": "a1735520b11736f581d242cacb0cc9310cce8768", "filename": "tests/debuginfo/associated-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fassociated-types.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Some versions of the non-rust-enabled LLDB print the wrong generic\n // parameter type names in this test.\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "37d458cb494ce69e7846ec5356b3dd733bd65817", "filename": "tests/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fborrowed-enum.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Require a gdb or lldb that can read DW_TAG_variant_part.\n // min-gdb-version: 8.2\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "2d54c2b07df309aa308208176c95ed09a63fddd7", "filename": "tests/debuginfo/generic-method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -2,7 +2,7 @@\n \n // Some versions of the non-rust-enabled LLDB print the wrong generic\n // parameter type names in this test.\n-// rust-lldb\n+// needs-rust-lldb\n \n // === GDB TESTS ===================================================================================\n "}, {"sha": "5213eebc18bd2a0c2e315d1e9bdbf6cb45db0949", "filename": "tests/debuginfo/generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fgeneric-struct.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Some versions of the non-rust-enabled LLDB print the wrong generic\n // parameter type names in this test.\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "a55402691dc309ae63ea7798804d698c6dc15478", "filename": "tests/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Require a gdb or lldb that can read DW_TAG_variant_part.\n // min-gdb-version: 8.2\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "138d8391d40ab63542273b5f2e4e90da5cc8307b", "filename": "tests/debuginfo/method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fmethod-on-generic-struct.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Some versions of the non-rust-enabled LLDB print the wrong generic\n // parameter type names in this test.\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "0152dd9ea9b11e83279ec9036c28461dfe4c228a", "filename": "tests/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fstruct-style-enum.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Require a gdb or lldb that can read DW_TAG_variant_part.\n // min-gdb-version: 8.2\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "60f3ecbd21e2698266835db644752b9a7a29fb18", "filename": "tests/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Ftuple-style-enum.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Require a gdb or lldb that can read DW_TAG_variant_part.\n // min-gdb-version: 8.2\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}, {"sha": "1ff6f5d9cbe1e720edda65092f896f3a0c155918", "filename": "tests/debuginfo/unique-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50b816f71f9055d6f162bec69c30b7574bb8e91a/tests%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Funique-enum.rs?ref=50b816f71f9055d6f162bec69c30b7574bb8e91a", "patch": "@@ -1,6 +1,6 @@\n // Require a gdb or lldb that can read DW_TAG_variant_part.\n // min-gdb-version: 8.2\n-// rust-lldb\n+// needs-rust-lldb\n \n // compile-flags:-g\n "}]}