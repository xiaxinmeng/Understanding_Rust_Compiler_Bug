{"sha": "612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "node_id": "C_kwDOAAsO6NoAKDYxMmU4OWExZmJhMzU0ZjM2ZjRhZTc0MDk2ZTNhNjlkMWFiZmNiYzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-05T19:43:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-05T19:43:45Z"}, "message": "Rollup merge of #105301 - RalfJung:miri, r=oli-obk\n\nupdate Miri\n\nLet's ship the work-around for https://github.com/rust-lang/unsafe-code-guidelines/issues/381.", "tree": {"sha": "f6726c02bd36dc0c9f2e2481d4dd9b4a35cb387f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6726c02bd36dc0c9f2e2481d4dd9b4a35cb387f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjjknxCRBK7hj4Ov3rIwAAl5EIADlMyVFVOUivRc5iQ6sfOWte\nHPBHCw/uvWs+kaPVfHsQZPVGto6sXJclOhduahnkFi5zHYxj3sGyeZYzw04jxzCf\nNCGeDnse+wJWxiusW86OQmoK1UnxaG+v22Wk4/zfbNAyHMU+dPiebQH+rWoEv0+I\nmeM9IYWqw96cV7rR6SbcjDet7UR6Wo1fBmhW6lrtNrhuDlY66gpVcttEpP5opROY\nvcj/gZjLAYieqCxPYcXnJgASt1B5zvqe+HdWBmo+po9NxBNzcE2j9GnxHf8zvYhd\nr7uQ8Wpk0beTknKi1d5nx/27EVzrq0Q38sA3na50G/516qMk+5si2AgA3NUiLeY=\n=9gdg\n-----END PGP SIGNATURE-----\n", "payload": "tree f6726c02bd36dc0c9f2e2481d4dd9b4a35cb387f\nparent 4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437\nparent 552b63c1619498f1a17fd482f4bb87815d8fdc48\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670269425 +0100\ncommitter GitHub <noreply@github.com> 1670269425 +0100\n\nRollup merge of #105301 - RalfJung:miri, r=oli-obk\n\nupdate Miri\n\nLet's ship the work-around for https://github.com/rust-lang/unsafe-code-guidelines/issues/381.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "html_url": "https://github.com/rust-lang/rust/commit/612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437", "html_url": "https://github.com/rust-lang/rust/commit/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437"}, {"sha": "552b63c1619498f1a17fd482f4bb87815d8fdc48", "url": "https://api.github.com/repos/rust-lang/rust/commits/552b63c1619498f1a17fd482f4bb87815d8fdc48", "html_url": "https://github.com/rust-lang/rust/commit/552b63c1619498f1a17fd482f4bb87815d8fdc48"}], "stats": {"total": 172, "additions": 117, "deletions": 55}, "files": [{"sha": "8dd18ae98e6d62304a55fc6417ac2f021fbd4fef", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "patch": "@@ -1 +1 @@\n-cef44f53034eac46be3a0e3eec7b2b3d4ef5140b\n+203c8765ea33c65d888febe0e8219c4bb11b0d89"}, {"sha": "bcac873251f587509c766cd4197cb929feb950f2", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "patch": "@@ -45,7 +45,9 @@ pub struct Stacks {\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n enum RefKind {\n-    /// `&mut` and `Box`.\n+    /// `Box`.\n+    Box,\n+    /// `&mut`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n@@ -56,6 +58,7 @@ enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n+            RefKind::Box => write!(f, \"Box\"),\n             RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n             RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared reference\"),\n@@ -654,15 +657,17 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let (perm, access) = match kind {\n             RefKind::Unique { two_phase } => {\n                 // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    Permission::Unique\n+                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    (Permission::Unique, Some(AccessKind::Write))\n                 } else {\n-                    Permission::SharedReadWrite\n-                };\n-                // We do an access for all full borrows, even if `!Unpin`.\n-                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n-                (perm, access)\n+                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                    // should do fake accesses here. But then we run into\n+                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                    // we don't do that.\n+                    (Permission::SharedReadWrite, None)\n+                }\n             }\n+            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n             RefKind::Raw { mutable: true } => {\n                 // Creating a raw ptr does not count as an access\n                 (Permission::SharedReadWrite, None)\n@@ -853,7 +858,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n-                    RefKind::Unique { two_phase: false },\n+                    RefKind::Box,\n                     self.retag_cause,\n                     /*protector*/\n                     (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437", "patch": "@@ -1,17 +0,0 @@\n-//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n-use std::marker::PhantomPinned;\n-\n-struct NotUnpin(i32, PhantomPinned);\n-\n-fn main() {\n-    unsafe {\n-        let mut x = NotUnpin(0, PhantomPinned);\n-        // Mutable borrow of `Unpin` field (with lifetime laundering)\n-        let fieldref = &mut *(&mut x.0 as *mut i32);\n-        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n-        // still count as a read since we would add `dereferenceable`.\n-        let _xref = &mut x;\n-        // That read should have invalidated `fieldref`.\n-        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n-    }\n-}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=4ebbb20dadc0dd559bf42f6232b8ebf7b42cd437", "patch": "@@ -1,28 +0,0 @@\n-error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         *fieldref = 0;\n-   |         ^^^^^^^^^^^^^\n-   |         |\n-   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let _xref = &mut x;\n-   |                     ^^^^^^\n-   = note: BACKTRACE:\n-   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "3ba21552fd362da1ce18c442c6e4a559e095f17e", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612e89a1fba354f36f4ae74096e3a69d1abfcbc8/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "patch": "@@ -0,0 +1,102 @@\n+#![feature(pin_macro)]\n+\n+use std::future::*;\n+use std::marker::PhantomPinned;\n+use std::pin::*;\n+use std::ptr;\n+use std::task::*;\n+\n+struct Delay {\n+    delay: usize,\n+}\n+\n+impl Delay {\n+    fn new(delay: usize) -> Self {\n+        Delay { delay }\n+    }\n+}\n+\n+impl Future for Delay {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<()> {\n+        if self.delay > 0 {\n+            self.delay -= 1;\n+            Poll::Pending\n+        } else {\n+            Poll::Ready(())\n+        }\n+    }\n+}\n+\n+async fn do_stuff() {\n+    (&mut Delay::new(1)).await;\n+}\n+\n+// Same thing implemented by hand\n+struct DoStuff {\n+    state: usize,\n+    delay: Delay,\n+    delay_ref: *mut Delay,\n+    _marker: PhantomPinned,\n+}\n+\n+impl DoStuff {\n+    fn new() -> Self {\n+        DoStuff {\n+            state: 0,\n+            delay: Delay::new(1),\n+            delay_ref: ptr::null_mut(),\n+            _marker: PhantomPinned,\n+        }\n+    }\n+}\n+\n+impl Future for DoStuff {\n+    type Output = ();\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+        unsafe {\n+            let this = self.get_unchecked_mut();\n+            match this.state {\n+                0 => {\n+                    // Set up self-ref.\n+                    this.delay_ref = &mut this.delay;\n+                    // Move to next state.\n+                    this.state = 1;\n+                    Poll::Pending\n+                }\n+                1 => {\n+                    let delay = &mut *this.delay_ref;\n+                    Pin::new_unchecked(delay).poll(cx)\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+}\n+\n+fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    let waker = Waker::from(Arc::new(MyWaker));\n+    let mut context = Context::from_waker(&waker);\n+\n+    let mut pinned = pin!(fut);\n+    loop {\n+        match pinned.as_mut().poll(&mut context) {\n+            Poll::Pending => continue,\n+            Poll::Ready(v) => return v,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    run_fut(do_stuff());\n+    run_fut(DoStuff::new());\n+}"}]}