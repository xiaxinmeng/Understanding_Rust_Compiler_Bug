{"sha": "7d8100a068151512774caf15a6a88766ca9cf434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODEwMGEwNjgxNTE1MTI3NzRjYWYxNWE2YTg4NzY2Y2E5Y2Y0MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-03T06:56:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-03T06:56:48Z"}, "message": "Auto merge of #33119 - nrc:pretty, r=pnkfelix\n\nRefactor pretty printing to use the compiler API", "tree": {"sha": "3210e9d72b9cbb2c771db4dac3323f3f927ad709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3210e9d72b9cbb2c771db4dac3323f3f927ad709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d8100a068151512774caf15a6a88766ca9cf434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8100a068151512774caf15a6a88766ca9cf434", "html_url": "https://github.com/rust-lang/rust/commit/7d8100a068151512774caf15a6a88766ca9cf434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d8100a068151512774caf15a6a88766ca9cf434/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43c5fef47dcaebea4c77771cc6f187b2a72b3639", "url": "https://api.github.com/repos/rust-lang/rust/commits/43c5fef47dcaebea4c77771cc6f187b2a72b3639", "html_url": "https://github.com/rust-lang/rust/commit/43c5fef47dcaebea4c77771cc6f187b2a72b3639"}, {"sha": "c1c6e99bfd3296954a192d9fe3151a222dd9045c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c6e99bfd3296954a192d9fe3151a222dd9045c", "html_url": "https://github.com/rust-lang/rust/commit/c1c6e99bfd3296954a192d9fe3151a222dd9045c"}], "stats": {"total": 735, "additions": 402, "deletions": 333}, "files": [{"sha": "2b56366f1c69794ac1b7c6fcd2c955888085735c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 96, "deletions": 55, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7d8100a068151512774caf15a6a88766ca9cf434", "patch": "@@ -70,7 +70,7 @@ pub fn compile_input(sess: &Session,\n                      control: &CompileController) -> CompileResult {\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n-            let state = $make_state;\n+            let state = &mut $make_state;\n             let phase_result: &CompileResult = &$phase_result;\n             if phase_result.is_ok() || control.$point.run_callback_on_error {\n                 (control.$point.callback)(state);\n@@ -95,17 +95,24 @@ pub fn compile_input(sess: &Session,\n                 }\n             };\n \n+            let mut compile_state = CompileState::state_after_parse(input,\n+                                                                    sess,\n+                                                                    outdir,\n+                                                                    output,\n+                                                                    krate,\n+                                                                    &cstore);\n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input, sess, outdir, &krate),\n+                                    compile_state,\n                                     Ok(()));\n+            let krate = compile_state.krate.unwrap();\n \n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n             let expanded_crate = phase_2_configure_and_expand(sess,\n                                                               &cstore,\n                                                               krate,\n-                                                              &id[..],\n+                                                              &id,\n                                                               addl_plugins)?;\n \n             (outputs, expanded_crate, id)\n@@ -116,8 +123,10 @@ pub fn compile_input(sess: &Session,\n                                 CompileState::state_after_expand(input,\n                                                                  sess,\n                                                                  outdir,\n+                                                                 output,\n+                                                                 &cstore,\n                                                                  &expanded_crate,\n-                                                                 &id[..]),\n+                                                                 &id),\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n@@ -162,10 +171,13 @@ pub fn compile_input(sess: &Session,\n                                     CompileState::state_after_write_deps(input,\n                                                                          sess,\n                                                                          outdir,\n+                                                                         output,\n+                                                                         &arenas,\n+                                                                         &cstore,\n                                                                          &hir_map,\n                                                                          &expanded_crate,\n                                                                          &hir_map.krate(),\n-                                                                         &id[..]),\n+                                                                         &id),\n                                     Ok(()));\n         }\n \n@@ -194,16 +206,17 @@ pub fn compile_input(sess: &Session,\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n \n-                let state = CompileState::state_after_analysis(input,\n-                                                               &tcx.sess,\n-                                                               outdir,\n-                                                               opt_crate,\n-                                                               tcx.map.krate(),\n-                                                               &analysis,\n-                                                               mir_map.as_ref(),\n-                                                               tcx,\n-                                                               &id);\n-                (control.after_analysis.callback)(state);\n+                let mut state = CompileState::state_after_analysis(input,\n+                                                                   sess,\n+                                                                   outdir,\n+                                                                   output,\n+                                                                   opt_crate,\n+                                                                   tcx.map.krate(),\n+                                                                   &analysis,\n+                                                                   mir_map.as_ref(),\n+                                                                   tcx,\n+                                                                   &id);\n+                (control.after_analysis.callback)(&mut state);\n \n                 if control.after_analysis.stop == Compilation::Stop {\n                     return result.and_then(|_| Err(0usize));\n@@ -236,7 +249,7 @@ pub fn compile_input(sess: &Session,\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, &trans),\n+                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n                             phase5_result);\n     phase5_result?;\n \n@@ -311,7 +324,7 @@ pub struct PhaseController<'a> {\n     // If true then the compiler will try to run the callback even if the phase\n     // ends with an error. Note that this is not always possible.\n     pub run_callback_on_error: bool,\n-    pub callback: Box<Fn(CompileState) -> () + 'a>,\n+    pub callback: Box<Fn(&mut CompileState) + 'a>,\n }\n \n impl<'a> PhaseController<'a> {\n@@ -327,34 +340,38 @@ impl<'a> PhaseController<'a> {\n /// State that is passed to a callback. What state is available depends on when\n /// during compilation the callback is made. See the various constructor methods\n /// (`state_*`) in the impl to see which data is provided for any given entry point.\n-pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n+pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub input: &'a Input,\n-    pub session: &'a Session,\n-    pub cfg: Option<&'a ast::CrateConfig>,\n-    pub krate: Option<&'a ast::Crate>,\n+    pub session: &'ast Session,\n+    pub krate: Option<ast::Crate>,\n+    pub cstore: Option<&'a CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n+    pub out_file: Option<&'a Path>,\n+    pub arenas: Option<&'ast ty::CtxtArenas<'ast>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n-    pub mir_map: Option<&'a MirMap<'tcx>>,\n+    pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<&'a TyCtxt<'tcx>>,\n+    pub tcx: Option<&'b TyCtxt<'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n-impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n+impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     fn empty(input: &'a Input,\n-             session: &'a Session,\n+             session: &'ast Session,\n              out_dir: &'a Option<PathBuf>)\n-             -> CompileState<'a, 'ast, 'tcx> {\n+             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             input: input,\n             session: session,\n             out_dir: out_dir.as_ref().map(|s| &**s),\n-            cfg: None,\n+            out_file: None,\n+            arenas: None,\n             krate: None,\n+            cstore: None,\n             crate_name: None,\n             output_filenames: None,\n             expanded_crate: None,\n@@ -368,71 +385,95 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     }\n \n     fn state_after_parse(input: &'a Input,\n-                         session: &'a Session,\n+                         session: &'ast Session,\n                          out_dir: &'a Option<PathBuf>,\n-                         krate: &'a ast::Crate)\n-                         -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState { krate: Some(krate), ..CompileState::empty(input, session, out_dir) }\n+                         out_file: &'a Option<PathBuf>,\n+                         krate: ast::Crate,\n+                         cstore: &'a CStore)\n+                         -> CompileState<'a, 'b, 'ast, 'tcx> {\n+        CompileState {\n+            krate: Some(krate),\n+            cstore: Some(cstore),\n+            out_file: out_file.as_ref().map(|s| &**s),\n+            ..CompileState::empty(input, session, out_dir)\n+        }\n     }\n \n     fn state_after_expand(input: &'a Input,\n-                          session: &'a Session,\n+                          session: &'ast Session,\n                           out_dir: &'a Option<PathBuf>,\n+                          out_file: &'a Option<PathBuf>,\n+                          cstore: &'a CStore,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n-                          -> CompileState<'a, 'ast, 'tcx> {\n+                          -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n+            cstore: Some(cstore),\n             expanded_crate: Some(expanded_crate),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_write_deps(input: &'a Input,\n-                              session: &'a Session,\n+                              session: &'ast Session,\n                               out_dir: &'a Option<PathBuf>,\n+                              out_file: &'a Option<PathBuf>,\n+                              arenas: &'ast ty::CtxtArenas<'ast>,\n+                              cstore: &'a CStore,\n                               hir_map: &'a hir_map::Map<'ast>,\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n                               crate_name: &'a str)\n-                              -> CompileState<'a, 'ast, 'tcx> {\n+                              -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n+            arenas: Some(arenas),\n+            cstore: Some(cstore),\n             ast_map: Some(hir_map),\n-            krate: Some(krate),\n+            expanded_crate: Some(krate),\n             hir_crate: Some(hir_crate),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_analysis(input: &'a Input,\n-                            session: &'a Session,\n+                            session: &'ast Session,\n                             out_dir: &'a Option<PathBuf>,\n+                            out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis,\n-                            mir_map: Option<&'a MirMap<'tcx>>,\n-                            tcx: &'a TyCtxt<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis<'a>,\n+                            mir_map: Option<&'b MirMap<'tcx>>,\n+                            tcx: &'b TyCtxt<'tcx>,\n                             crate_name: &'a str)\n-                            -> CompileState<'a, 'ast, 'tcx> {\n+                            -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n             mir_map: mir_map,\n             tcx: Some(tcx),\n-            krate: krate,\n+            expanded_crate: krate,\n             hir_crate: Some(hir_crate),\n             crate_name: Some(crate_name),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n \n     fn state_after_llvm(input: &'a Input,\n-                        session: &'a Session,\n+                        session: &'ast Session,\n                         out_dir: &'a Option<PathBuf>,\n+                        out_file: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n-                        -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState { trans: Some(trans), ..CompileState::empty(input, session, out_dir) }\n+                        -> CompileState<'a, 'b, 'ast, 'tcx> {\n+        CompileState {\n+            trans: Some(trans),\n+            out_file: out_file.as_ref().map(|s| &**s),\n+            ..CompileState::empty(input, session, out_dir)\n+        }\n     }\n }\n \n@@ -798,16 +839,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let index = stability::Index::new(&hir_map);\n \n     TyCtxt::create_and_enter(sess,\n-                               arenas,\n-                               def_map,\n-                               named_region_map,\n-                               hir_map,\n-                               freevars,\n-                               region_map,\n-                               lang_items,\n-                               index,\n-                               name,\n-                               |tcx| {\n+                             arenas,\n+                             def_map,\n+                             named_region_map,\n+                             hir_map,\n+                             freevars,\n+                             region_map,\n+                             lang_items,\n+                             index,\n+                             name,\n+                             |tcx| {\n         time(time_passes,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx));"}, {"sha": "4aaeeed34301679be0133c1f95fbd9476ac8716b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7d8100a068151512774caf15a6a88766ca9cf434", "patch": "@@ -31,6 +31,7 @@\n #![feature(set_stdio)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(unboxed_closures)]\n \n extern crate arena;\n extern crate flate;\n@@ -209,16 +210,8 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n \n     do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n \n-    // It is somewhat unfortunate that this is hardwired in - this is forced by\n-    // the fact that pretty_print_input requires the session by value.\n-    let pretty = callbacks.parse_pretty(&sess, &matches);\n-    if let Some((ppm, opt_uii)) = pretty {\n-        pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n-        return (Ok(()), None);\n-    }\n-\n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n-    let control = callbacks.build_controller(&sess);\n+    let control = callbacks.build_controller(&sess, &matches);\n     (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n                            Some(plugins), &control),\n      Some(sess))\n@@ -249,6 +242,27 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n     }\n }\n \n+fn parse_pretty(sess: &Session,\n+                matches: &getopts::Matches)\n+                -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+    let pretty = if sess.opts.debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            pretty::parse_pretty(sess, &a, false)\n+        })\n+    } else {\n+        None\n+    };\n+    if pretty.is_none() && sess.unstable_options() {\n+        matches.opt_str(\"unpretty\").map(|a| {\n+            // extended with unstable pretty-print variants\n+            pretty::parse_pretty(sess, &a, true)\n+        })\n+    } else {\n+        pretty\n+    }\n+}\n+\n // Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {\n@@ -318,29 +332,9 @@ pub trait CompilerCalls<'a> {\n         None\n     }\n \n-    // Parse pretty printing information from the arguments. The implementer can\n-    // choose to ignore this (the default will return None) which will skip pretty\n-    // printing. If you do want to pretty print, it is recommended to use the\n-    // implementation of this method from RustcDefaultCalls.\n-    // FIXME, this is a terrible bit of API. Parsing of pretty printing stuff\n-    // should be done as part of the framework and the implementor should customise\n-    // handling of it. However, that is not possible atm because pretty printing\n-    // essentially goes off and takes another path through the compiler which\n-    // means the session is either moved or not depending on what parse_pretty\n-    // returns (we could fix this by cloning, but it's another hack). The proper\n-    // solution is to handle pretty printing as if it were a compiler extension,\n-    // extending CompileController to make this work (see for example the treatment\n-    // of save-analysis in RustcDefaultCalls::build_controller).\n-    fn parse_pretty(&mut self,\n-                    _sess: &Session,\n-                    _matches: &getopts::Matches)\n-                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-        None\n-    }\n-\n     // Create a CompilController struct for controlling the behaviour of\n     // compilation.\n-    fn build_controller(&mut self, &Session) -> CompileController<'a>;\n+    fn build_controller(&mut self, &Session, &getopts::Matches) -> CompileController<'a>;\n }\n \n // CompilerCalls instance for a regular rustc build.\n@@ -443,28 +437,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         None\n     }\n \n-    fn parse_pretty(&mut self,\n-                    sess: &Session,\n-                    matches: &getopts::Matches)\n-                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-        let pretty = if sess.opts.debugging_opts.unstable_options {\n-            matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-                // stable pretty-print variants only\n-                pretty::parse_pretty(sess, &a, false)\n-            })\n-        } else {\n-            None\n-        };\n-        if pretty.is_none() && sess.unstable_options() {\n-            matches.opt_str(\"unpretty\").map(|a| {\n-                // extended with unstable pretty-print variants\n-                pretty::parse_pretty(sess, &a, true)\n-            })\n-        } else {\n-            pretty\n-        }\n-    }\n-\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n@@ -476,9 +448,46 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n-    fn build_controller(&mut self, sess: &Session) -> CompileController<'a> {\n+    fn build_controller(&mut self,\n+                        sess: &Session,\n+                        matches: &getopts::Matches)\n+                        -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n+        if let Some((ppm, opt_uii)) = parse_pretty(sess, matches) {\n+            if ppm.needs_ast_map(&opt_uii) {\n+                control.after_write_deps.stop = Compilation::Stop;\n+\n+                control.after_parse.callback = box move |state| {\n+                    state.krate = Some(pretty::fold_crate(state.krate.take().unwrap(), ppm));\n+                };\n+                control.after_write_deps.callback = box move |state| {\n+                    pretty::print_after_write_deps(state.session,\n+                                                   state.ast_map.unwrap(),\n+                                                   state.input,\n+                                                   &state.expanded_crate.take().unwrap(),\n+                                                   state.crate_name.unwrap(),\n+                                                   ppm,\n+                                                   state.arenas.unwrap(),\n+                                                   opt_uii.clone(),\n+                                                   state.out_file);\n+                };\n+            } else {\n+                control.after_parse.stop = Compilation::Stop;\n+\n+                control.after_parse.callback = box move |state| {\n+                    let krate = pretty::fold_crate(state.krate.take().unwrap(), ppm);\n+                    pretty::print_after_parsing(state.session,\n+                                                state.input,\n+                                                &krate,\n+                                                ppm,\n+                                                state.out_file);\n+                };\n+            }\n+\n+            return control;\n+        }\n+\n         if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n@@ -500,7 +509,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(), \"save analysis\", || {\n                     save::process_crate(state.tcx.unwrap(),\n-                                        state.krate.unwrap(),\n+                                        state.expanded_crate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),\n                                         state.out_dir,"}, {"sha": "30f943bd9a4441cd362ea8f06c81e78e4d634d29", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 239, "deletions": 223, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d8100a068151512774caf15a6a88766ca9cf434/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7d8100a068151512774caf15a6a88766ca9cf434", "patch": "@@ -15,8 +15,6 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use rustc_trans::back::link;\n-\n use {driver, abort_on_err};\n \n use rustc::dep_graph::DepGraph;\n@@ -28,8 +26,6 @@ use rustc::session::config::Input;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n-use rustc_metadata::cstore::CStore;\n-use rustc_metadata::creader::LocalCrateReader;\n \n use rustc_mir::pretty::write_mir_pretty;\n use rustc_mir::graphviz::write_mir_graphviz;\n@@ -44,18 +40,16 @@ use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n-use std::cell::RefCell;\n use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n use std::option;\n-use std::path::PathBuf;\n+use std::path::Path;\n use std::str::FromStr;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::{blocks, NodePrinter};\n use rustc::hir;\n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc::hir::print as pprust_hir;\n \n use rustc::mir::mir_map::MirMap;\n@@ -89,6 +83,32 @@ pub enum PpMode {\n     PpmMirCFG,\n }\n \n+impl PpMode {\n+    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+        match *self {\n+            PpmSource(PpmNormal) |\n+            PpmSource(PpmEveryBodyLoops) |\n+            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+            PpmSource(PpmExpanded) |\n+            PpmSource(PpmExpandedIdentified) |\n+            PpmSource(PpmExpandedHygiene) |\n+            PpmHir(_) |\n+            PpmMir |\n+            PpmMirCFG |\n+            PpmFlowGraph(_) => true,\n+            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+        }\n+    }\n+\n+    pub fn needs_analysis(&self) -> bool {\n+        match *self {\n+             PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+             _ => false,\n+        }\n+    }\n+}\n+\n pub fn parse_pretty(sess: &Session,\n                     name: &str,\n                     extended: bool)\n@@ -147,7 +167,7 @@ impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n                                            sess: &'tcx Session,\n-                                           ast_map: Option<hir_map::Map<'tcx>>,\n+                                           ast_map: Option<&hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F)\n                                            -> A\n@@ -157,22 +177,22 @@ impl PpSourceMode {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n             PpmExpandedHygiene => {\n                 let annotation = HygieneAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n@@ -582,40 +602,6 @@ impl UserIdentifiedItem {\n     }\n }\n \n-fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmEveryBodyLoops) |\n-        PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmExpandedHygiene) |\n-        PpmHir(_) |\n-        PpmMir |\n-        PpmMirCFG |\n-        PpmFlowGraph(_) => true,\n-        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-    }\n-}\n-\n-fn needs_expansion(ppm: &PpMode) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmEveryBodyLoops) |\n-        PpmSource(PpmIdentified) => false,\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmExpandedHygiene) |\n-        PpmHir(_) |\n-        PpmMir |\n-        PpmMirCFG |\n-        PpmFlowGraph(_) => true,\n-        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-    }\n-}\n-\n struct ReplaceBodyWithLoop {\n     within_static_or_const: bool,\n }\n@@ -700,90 +686,175 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     }\n }\n \n-pub fn pretty_print_input(sess: Session,\n-                          cstore: &CStore,\n-                          cfg: ast::CrateConfig,\n-                          input: &Input,\n-                          ppm: PpMode,\n-                          opt_uii: Option<UserIdentifiedItem>,\n-                          ofile: Option<PathBuf>) {\n-    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, input));\n-\n-    let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        let mut fold = ReplaceBodyWithLoop::new();\n-        fold.fold_crate(krate)\n-    } else {\n-        krate\n+fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                   tcx: &TyCtxt<'tcx>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   code: blocks::Code,\n+                                   mode: PpFlowGraphMode,\n+                                   mut out: W)\n+                                   -> io::Result<()> {\n+    let cfg = match code {\n+        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n+    };\n+    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n+    let lcfg = LabelledCFG {\n+        ast_map: &tcx.map,\n+        cfg: &cfg,\n+        name: format!(\"node_{}\", code.id()),\n+        labelled_edges: labelled_edges,\n     };\n \n-    let id = link::find_crate_name(Some(&sess), &krate.attrs, input);\n+    match code {\n+        _ if variants.is_empty() => {\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+        blocks::BlockCode(_) => {\n+            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n+                          fn-like node id.\");\n+            return Ok(());\n+        }\n+        blocks::FnLikeCode(fn_like) => {\n+            let (bccx, analysis_data) =\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n+                                                              mir_map,\n+                                                              fn_like.to_fn_parts(),\n+                                                              &cfg);\n \n-    let is_expanded = needs_expansion(&ppm);\n-    let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n-    let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id, None) {\n-            Err(_) => return,\n-            Ok(k) => driver::assign_node_ids(&sess, k),\n+            let lcfg = borrowck_dot::DataflowLabeller {\n+                inner: lcfg,\n+                variants: variants,\n+                borrowck_ctxt: &bccx,\n+                analysis_data: &analysis_data,\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n         }\n-    } else {\n-        krate\n-    };\n+    }\n \n-    // There is some twisted, god-forsaken tangle of lifetimes here which makes\n-    // the ordering of stuff super-finicky.\n-    let mut hir_forest;\n-    let mut _defs = None;\n-    let dep_graph = DepGraph::new(false);\n-    let arenas = ty::CtxtArenas::new();\n-    let _ignore = dep_graph.in_ignore();\n-    let ast_map = if compute_ast_map {\n-        _defs = Some(RefCell::new(hir_map::collect_definitions(&krate)));\n-        let defs = _defs.as_ref().unwrap();\n-        LocalCrateReader::new(&sess, &cstore, defs, &krate, &id).read_crates(&dep_graph);\n-        let lcx = LoweringContext::new(&sess, Some(&krate), defs);\n-\n-        hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n-        Some(hir_map::map_crate(&mut hir_forest, defs))\n+    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n+        r.map_err(|ioerr| {\n+            io::Error::new(io::ErrorKind::Other,\n+                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n+        })\n+    }\n+}\n+\n+pub fn fold_crate(krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n+    if let PpmSource(PpmEveryBodyLoops) = ppm {\n+        let mut fold = ReplaceBodyWithLoop::new();\n+        fold.fold_crate(krate)\n     } else {\n-        None\n-    };\n+        krate\n+    }\n+}\n \n+fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n-                  .get_filemap(&src_name[..])\n+                  .get_filemap(&src_name)\n                   .src\n                   .as_ref()\n                   .unwrap()\n                   .as_bytes()\n                   .to_vec();\n+    (src, src_name)\n+}\n+\n+fn write_output(out: Vec<u8>, ofile: Option<&Path>) {\n+    match ofile {\n+        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n+        Some(p) => {\n+            match File::create(p) {\n+                Ok(mut w) => w.write_all(&out).unwrap(),\n+                Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n+            }\n+        }\n+    }\n+}\n+\n+pub fn print_after_parsing(sess: &Session,\n+                           input: &Input,\n+                           krate: &ast::Crate,\n+                           ppm: PpMode,\n+                           ofile: Option<&Path>) {\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+\n+    let (src, src_name) = get_source(input, sess);\n+\n     let mut rdr = &*src;\n+    let mut out = Vec::new();\n+\n+    if let PpmSource(s) = ppm {\n+        // Silently ignores an identified node.\n+        let out: &mut Write = &mut out;\n+        s.call_with_pp_support(sess, None, box out, |annotation, out| {\n+            debug!(\"pretty printing source code {:?}\", s);\n+            let sess = annotation.sess();\n+            pprust::print_crate(sess.codemap(),\n+                                sess.diagnostic(),\n+                                krate,\n+                                src_name.to_string(),\n+                                &mut rdr,\n+                                out,\n+                                annotation.pp_ann(),\n+                                false)\n+        }).unwrap()\n+    } else {\n+        unreachable!();\n+    };\n+\n+    write_output(out, ofile);\n+}\n+\n+pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                              ast_map: &hir_map::Map<'tcx>,\n+                                              input: &Input,\n+                                              krate: &ast::Crate,\n+                                              crate_name: &str,\n+                                              ppm: PpMode,\n+                                              arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                              opt_uii: Option<UserIdentifiedItem>,\n+                                              ofile: Option<&Path>) {\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+\n+    if ppm.needs_analysis() {\n+        print_with_analysis(sess, ast_map, crate_name, arenas, ppm, opt_uii, ofile);\n+        return;\n+    }\n \n+    let (src, src_name) = get_source(input, sess);\n+\n+    let mut rdr = &src[..];\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n         (PpmSource(s), _) => {\n             // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support(&sess, ast_map, box out, |annotation, out| {\n+            s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n                 pprust::print_crate(sess.codemap(),\n                                     sess.diagnostic(),\n-                                    &krate,\n+                                    krate,\n                                     src_name.to_string(),\n                                     &mut rdr,\n                                     out,\n                                     annotation.pp_ann(),\n-                                    is_expanded)\n+                                    true)\n             })\n         }\n \n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(&sess,\n-                                       &ast_map.unwrap(),\n-                                       &arenas,\n-                                       &id,\n+            s.call_with_pp_support_hir(sess,\n+                                       ast_map,\n+                                       arenas,\n+                                       crate_name,\n                                        box out,\n                                        |annotation, out, krate| {\n                                            debug!(\"pretty printing source code {:?}\", s);\n@@ -795,16 +866,16 @@ pub fn pretty_print_input(sess: Session,\n                                                                    &mut rdr,\n                                                                    out,\n                                                                    annotation.pp_ann(),\n-                                                                   is_expanded)\n+                                                                   true)\n                                        })\n         }\n \n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(&sess,\n-                                       &ast_map.unwrap(),\n-                                       &arenas,\n-                                       &id,\n+            s.call_with_pp_support_hir(sess,\n+                                       ast_map,\n+                                       arenas,\n+                                       crate_name,\n                                        (out,uii),\n                                        |annotation, (out,uii), _| {\n                 debug!(\"pretty printing source code {:?}\", s);\n@@ -830,156 +901,101 @@ pub fn pretty_print_input(sess: Session,\n                 }\n                 pp::eof(&mut pp_state.s)\n             })\n-        }\n+       }\n+       _ => unreachable!(),\n+    }.unwrap();\n+\n+    write_output(out, ofile);\n+}\n+\n+// In an ideal world, this would be a public function called by the driver after\n+// analsysis is performed. However, we want to call `phase_3_run_analysis_passes`\n+// with a different callback than the standard driver, so that isn't easy.\n+// Instead, we call that function ourselves.\n+fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                       ast_map: &hir_map::Map<'tcx>,\n+                                       crate_name: &str,\n+                                       arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                       ppm: PpMode,\n+                                       uii: Option<UserIdentifiedItem>,\n+                                       ofile: Option<&Path>) {\n+    let nodeid = if let Some(uii) = uii {\n+        debug!(\"pretty printing for {:?}\", uii);\n+        Some(uii.to_one_node_id(\"--unpretty\", sess, &ast_map))\n+    } else {\n+        debug!(\"pretty printing for whole crate\");\n+        None\n+    };\n \n-        (pp_type@PpmMir, uii) | (pp_type@PpmMirCFG, uii) => {\n-            let ast_map = ast_map.expect(\"--unpretty missing ast_map\");\n-            let nodeid = if let Some(uii) = uii {\n-                debug!(\"pretty printing MIR for {:?}\", uii);\n-                Some(uii.to_one_node_id(\"--unpretty\", &sess, &ast_map))\n-            } else {\n-                debug!(\"pretty printing MIR for whole crate\");\n-                None\n-            };\n-            abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                             ast_map,\n-                                                             &arenas,\n-                                                             &id,\n-                                                             resolve::MakeGlobMap::No,\n-                                                             |tcx, mir_map, _, _| {\n+    let mut out = Vec::new();\n+\n+    abort_on_err(driver::phase_3_run_analysis_passes(sess,\n+                                                     ast_map.clone(),\n+                                                     arenas,\n+                                                     crate_name,\n+                                                     resolve::MakeGlobMap::No,\n+                                                     |tcx, mir_map, _, _| {\n+        match ppm {\n+            PpmMir | PpmMirCFG => {\n                 if let Some(mir_map) = mir_map {\n                     if let Some(nodeid) = nodeid {\n                         let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n                             sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n                         });\n-                        match pp_type {\n+                        match ppm {\n                             PpmMir => write_mir_pretty(tcx, iter::once((&nodeid, mir)), &mut out),\n-                            _ => write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n+                            PpmMirCFG => {\n+                                write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n+                            }\n+                            _ => unreachable!(),\n                         }?;\n                     } else {\n-                        match pp_type {\n+                        match ppm {\n                             PpmMir => write_mir_pretty(tcx, mir_map.map.iter(), &mut out),\n-                            _ => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out)\n+                            PpmMirCFG => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out),\n+                            _ => unreachable!(),\n                         }?;\n                     }\n                 }\n                 Ok(())\n-            }), &sess)\n-        }\n-\n-        (PpmFlowGraph(mode), opt_uii) => {\n-            debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n-            let uii = opt_uii.unwrap_or_else(|| {\n-                sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     \\\n-                                     unique path suffix (b::c::d)\"))\n+            }\n+            PpmFlowGraph(mode) => {\n+                let nodeid = nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or \\\n+                                            unique path suffix (b::c::d)\");\n+                let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n+                    tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n+                });\n \n-            });\n-            let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n-            let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n+                let code = blocks::Code::from_node(node);\n+                match code {\n+                    Some(code) => {\n+                        let variants = gather_flowgraph_variants(tcx.sess);\n \n-            let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n-            });\n+                        let out: &mut Write = &mut out;\n \n-            let code = blocks::Code::from_node(node);\n-            let out: &mut Write = &mut out;\n-            match code {\n-                Some(code) => {\n-                    let variants = gather_flowgraph_variants(&sess);\n-                    abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n-                                                                     ast_map,\n-                                                                     &arenas,\n-                                                                     &id,\n-                                                                     resolve::MakeGlobMap::No,\n-                                                                     |tcx, mir_map, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n                                         mir_map.as_ref(),\n                                         code,\n                                         mode,\n                                         out)\n-                    }), &sess)\n-                }\n-                None => {\n-                    let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n-                                           {:?}\",\n-                                          node);\n-\n-                    // point to what was found, if there's an\n-                    // accessible span.\n-                    match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, &message[..]),\n-                        None => sess.fatal(&message[..]),\n+                    }\n+                    None => {\n+                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n+                                               {:?}\",\n+                                              node);\n+\n+                        // Point to what was found, if there's an accessible span.\n+                        match tcx.map.opt_span(nodeid) {\n+                            Some(sp) => tcx.sess.span_fatal(sp, &message),\n+                            None => tcx.sess.fatal(&message),\n+                        }\n                     }\n                 }\n             }\n+            _ => unreachable!(),\n         }\n-    }\n-    .unwrap();\n-\n-    match ofile {\n-        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n-        Some(p) => {\n-            match File::create(&p) {\n-                Ok(mut w) => w.write_all(&out).unwrap(),\n-                Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n-            }\n-        }\n-    }\n-}\n-\n-fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   code: blocks::Code,\n-                                   mode: PpFlowGraphMode,\n-                                   mut out: W)\n-                                   -> io::Result<()> {\n-    let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n-    };\n-    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n-    let lcfg = LabelledCFG {\n-        ast_map: &tcx.map,\n-        cfg: &cfg,\n-        name: format!(\"node_{}\", code.id()),\n-        labelled_edges: labelled_edges,\n-    };\n-\n-    match code {\n-        _ if variants.is_empty() => {\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-        blocks::BlockCode(_) => {\n-            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n-                          fn-like node id.\");\n-            return Ok(());\n-        }\n-        blocks::FnLikeCode(fn_like) => {\n-            let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              mir_map,\n-                                                              fn_like.to_fn_parts(),\n-                                                              &cfg);\n-\n-            let lcfg = borrowck_dot::DataflowLabeller {\n-                inner: lcfg,\n-                variants: variants,\n-                borrowck_ctxt: &bccx,\n-                analysis_data: &analysis_data,\n-            };\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-    }\n+    }), sess).unwrap();\n \n-    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n-        r.map_err(|ioerr| {\n-            io::Error::new(io::ErrorKind::Other,\n-                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n-        })\n-    }\n+    write_output(out, ofile);\n }"}, {"sha": "af641d717edd9224b4719bc4ef419fb8c01979bb", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d8100a068151512774caf15a6a88766ca9cf434/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d8100a068151512774caf15a6a88766ca9cf434/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=7d8100a068151512774caf15a6a88766ca9cf434", "patch": "@@ -69,7 +69,10 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n         panic!(\"This shouldn't happen\");\n     }\n \n-    fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n+    fn build_controller(&mut self,\n+                        _: &Session,\n+                        _: &getopts::Matches)\n+                        -> driver::CompileController<'a> {\n         panic!(\"This shouldn't be called\");\n     }\n }"}]}