{"sha": "088c94ae96aa139db6b6f0c5640c720ff107ee0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4OGM5NGFlOTZhYTEzOWRiNmI2ZjBjNTY0MGM3MjBmZjEwN2VlMGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-12T15:42:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-15T19:28:12Z"}, "message": "trans -- stop tracking vtables precisely, instead recompute as needed.", "tree": {"sha": "3198fe5f828e8172e7e430acf9e216d9e8d0190d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3198fe5f828e8172e7e430acf9e216d9e8d0190d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/088c94ae96aa139db6b6f0c5640c720ff107ee0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/088c94ae96aa139db6b6f0c5640c720ff107ee0f", "html_url": "https://github.com/rust-lang/rust/commit/088c94ae96aa139db6b6f0c5640c720ff107ee0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/088c94ae96aa139db6b6f0c5640c720ff107ee0f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6349a61231b8c0571cf3db97a68c7215e04a8791", "url": "https://api.github.com/repos/rust-lang/rust/commits/6349a61231b8c0571cf3db97a68c7215e04a8791", "html_url": "https://github.com/rust-lang/rust/commit/6349a61231b8c0571cf3db97a68c7215e04a8791"}], "stats": {"total": 1267, "additions": 723, "deletions": 544}, "files": [{"sha": "eed41edac9d6c2dda244b4c8c52c2fcd941b84cd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -1470,17 +1470,17 @@ impl LintPass for Stability {\n                                 def_id\n                             }\n                             typeck::MethodParam(typeck::MethodParam {\n-                                trait_id: trait_id,\n+                                trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n-                            })\n-                            | typeck::MethodObject(typeck::MethodObject {\n-                                trait_id: trait_id,\n+                            }) |\n+                            typeck::MethodObject(typeck::MethodObject {\n+                                trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n                             }) => {\n                                 match ty::trait_item(cx.tcx,\n-                                                     trait_id,\n+                                                     trait_ref.def_id,\n                                                      index) {\n                                     ty::MethodTraitItem(method) => {\n                                         method.def_id"}, {"sha": "3ec91bf9840527668c442f0eb67ca881dcfabac4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -140,9 +140,10 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_unboxed_closures = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n     tag_table_capture_modes = 0x56,\n+    tag_table_object_cast_map = 0x57,\n }\n static first_astencode_tag: uint = tag_ast as uint;\n-static last_astencode_tag: uint = tag_table_capture_modes as uint;\n+static last_astencode_tag: uint = tag_table_object_cast_map as uint;\n impl astencode_tag {\n     pub fn from_uint(value : uint) -> Option<astencode_tag> {\n         let is_a_tag = first_astencode_tag <= value && value <= last_astencode_tag;"}, {"sha": "3ab50b0efd17c77b980e719756e885be79bb3f3b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -20,9 +20,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{lookup_item_type};\n-use middle::astencode;\n use middle::ty;\n-use middle::typeck;\n use middle::stability;\n use middle;\n use util::nodemap::{NodeMap, NodeSet};\n@@ -125,14 +123,6 @@ fn encode_trait_ref(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_impl_vtables(rbml_w: &mut Encoder,\n-                       ecx: &EncodeContext,\n-                       vtables: &typeck::vtable_res) {\n-    rbml_w.start_tag(tag_item_impl_vtables);\n-    astencode::encode_vtable_res(ecx, rbml_w, vtables);\n-    rbml_w.end_tag();\n-}\n-\n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.start_tag(tag_items_data_item_family);\n@@ -191,6 +181,18 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n+pub fn write_trait_ref(ecx: &EncodeContext,\n+                       rbml_w: &mut Encoder,\n+                       trait_ref: &ty::TraitRef) {\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+    tyencode::enc_trait_ref(rbml_w.writer, ty_str_ctxt, trait_ref);\n+}\n+\n pub fn write_region(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder,\n                     r: ty::Region) {\n@@ -399,7 +401,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     let impl_items = ecx.tcx.impl_items.borrow();\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n-            for base_impl_did in implementations.borrow().iter() {\n+            for base_impl_did in implementations.iter() {\n                 for &method_did in impl_items.get(base_impl_did).iter() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n@@ -946,7 +948,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(implementations) => {\n-            for &impl_def_id in implementations.borrow().iter() {\n+            for &impl_def_id in implementations.iter() {\n                 rbml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(rbml_w, impl_def_id);\n                 rbml_w.end_tag();\n@@ -1203,8 +1205,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n-            let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n-            encode_impl_vtables(rbml_w, ecx, &impl_vtables);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);"}, {"sha": "21d0292d2fe3a2508af08aa69041096cfbe1aa7a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 180, "deletions": 60, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -43,6 +43,7 @@ use libc;\n use std::io::Seek;\n use std::mem;\n use std::gc::GC;\n+use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;\n use rbml::{reader, writer};\n@@ -589,7 +590,7 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n             adjustment.encode(rbml_w)\n         });\n         rbml_w.emit_struct_field(\"origin\", 1u, |rbml_w| {\n-            method.origin.encode(rbml_w)\n+            Ok(rbml_w.emit_method_origin(ecx, &method.origin))\n         });\n         rbml_w.emit_struct_field(\"ty\", 2u, |rbml_w| {\n             Ok(rbml_w.emit_ty(ecx, method.ty))\n@@ -610,9 +611,7 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n             }).unwrap();\n             Ok((adjustment, MethodCallee {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n-                    let method_origin: MethodOrigin =\n-                        Decodable::decode(this).unwrap();\n-                    Ok(method_origin.tr(dcx))\n+                    Ok(this.read_method_origin(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n                     Ok(this.read_ty(dcx))\n@@ -635,15 +634,16 @@ impl tr for MethodOrigin {\n             typeck::MethodParam(ref mp) => {\n                 typeck::MethodParam(\n                     typeck::MethodParam {\n-                        trait_id: mp.trait_id.tr(dcx),\n-                        .. *mp\n+                        // def-id is already translated when we read it out\n+                        trait_ref: mp.trait_ref.clone(),\n+                        method_num: mp.method_num,\n                     }\n                 )\n             }\n             typeck::MethodObject(ref mo) => {\n                 typeck::MethodObject(\n                     typeck::MethodObject {\n-                        trait_id: mo.trait_id.tr(dcx),\n+                        trait_ref: mo.trait_ref.clone(),\n                         .. *mo\n                     }\n                 )\n@@ -655,22 +655,6 @@ impl tr for MethodOrigin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n-                              rbml_w: &mut Encoder,\n-                              adjustment: typeck::ExprAdjustment,\n-                              dr: &typeck::vtable_res) {\n-    use serialize::Encoder;\n-\n-    rbml_w.emit_struct(\"VtableWithKey\", 2, |rbml_w| {\n-        rbml_w.emit_struct_field(\"adjustment\", 0u, |rbml_w| {\n-            adjustment.encode(rbml_w)\n-        });\n-        rbml_w.emit_struct_field(\"vtable_res\", 1u, |rbml_w| {\n-            Ok(encode_vtable_res(ecx, rbml_w, dr))\n-        })\n-    }).unwrap()\n-}\n-\n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                          rbml_w: &mut Encoder,\n                          dr: &typeck::vtable_res) {\n@@ -913,11 +897,15 @@ trait rbml_writer_helpers {\n     fn emit_closure_type(&mut self,\n                          ecx: &e::EncodeContext,\n                          closure_type: &ty::ClosureTy);\n+    fn emit_method_origin(&mut self,\n+                          ecx: &e::EncodeContext,\n+                          method_origin: &typeck::MethodOrigin);\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef);\n+    fn emit_trait_ref(&mut self, ecx: &e::EncodeContext, ty: &ty::TraitRef);\n     fn emit_polytype(&mut self,\n                      ecx: &e::EncodeContext,\n                      pty: ty::Polytype);\n@@ -939,6 +927,63 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n+    fn emit_method_origin(&mut self,\n+                          ecx: &e::EncodeContext,\n+                          method_origin: &typeck::MethodOrigin)\n+    {\n+        use serialize::Encoder;\n+\n+        self.emit_enum(\"MethodOrigin\", |this| {\n+            match *method_origin {\n+                typeck::MethodStatic(def_id) => {\n+                    this.emit_enum_variant(\"MethodStatic\", 0, 1, |this| {\n+                        Ok(this.emit_def_id(def_id))\n+                    })\n+                }\n+\n+                typeck::MethodStaticUnboxedClosure(def_id) => {\n+                    this.emit_enum_variant(\"MethodStaticUnboxedClosure\", 1, 1, |this| {\n+                        Ok(this.emit_def_id(def_id))\n+                    })\n+                }\n+\n+                typeck::MethodParam(ref p) => {\n+                    this.emit_enum_variant(\"MethodParam\", 2, 1, |this| {\n+                        this.emit_struct(\"MethodParam\", 2, |this| {\n+                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n+                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n+                            }));\n+                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n+                                this.emit_uint(p.method_num)\n+                            }));\n+                            Ok(())\n+                        })\n+                    })\n+                }\n+\n+                typeck::MethodObject(ref o) => {\n+                    this.emit_enum_variant(\"MethodObject\", 3, 1, |this| {\n+                        this.emit_struct(\"MethodObject\", 2, |this| {\n+                            try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n+                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n+                            }));\n+                            try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n+                                Ok(this.emit_def_id(o.object_trait_id))\n+                            }));\n+                            try!(this.emit_struct_field(\"method_num\", 0, |this| {\n+                                this.emit_uint(o.method_num)\n+                            }));\n+                            try!(this.emit_struct_field(\"real_index\", 0, |this| {\n+                                this.emit_uint(o.real_index)\n+                            }));\n+                            Ok(())\n+                        })\n+                    })\n+                }\n+            }\n+        });\n+    }\n+\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -947,6 +992,12 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n+    fn emit_trait_ref(&mut self,\n+                      ecx: &e::EncodeContext,\n+                      trait_ref: &ty::TraitRef) {\n+        self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n+    }\n+\n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n@@ -1103,12 +1154,16 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(1, |this| idx.encode(this))\n                     })\n                 }\n-                ty::UnsizeVtable(ref b, def_id, ref substs) => {\n-                    this.emit_enum_variant(\"UnsizeVtable\", 2, 3, |this| {\n+                ty::UnsizeVtable(ty::TyTrait { def_id: def_id,\n+                                               bounds: ref b,\n+                                               substs: ref substs },\n+                                 self_ty) => {\n+                    this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(\n                             0, |this| Ok(this.emit_existential_bounds(ecx, b)));\n                         this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_substs(ecx, substs)))\n+                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_ty(ecx, self_ty)));\n+                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1282,11 +1337,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n+    for &trait_ref in tcx.object_cast_map.borrow().find(&id).iter() {\n+        rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n+                rbml_w.emit_trait_ref(ecx, &**trait_ref);\n             })\n         })\n     }\n@@ -1303,15 +1358,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                         })\n                     })\n                 }\n-\n-                for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n-                        })\n-                    })\n-                }\n             }\n             ty::AutoDerefRef(ref adj) => {\n                 assert!(!ty::adjust_is_object(adjustment));\n@@ -1326,16 +1372,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                             })\n                         })\n                     }\n-\n-                    for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n-                        rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n-                            rbml_w.id(id);\n-                            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                                encode_vtable_res_with_key(ecx, rbml_w,\n-                                                           method_call.adjustment, dr);\n-                            })\n-                        })\n-                    }\n                 }\n             }\n             _ => {\n@@ -1378,8 +1414,10 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers {\n+    fn read_method_origin(&mut self, dcx: &DecodeContext) -> typeck::MethodOrigin;\n     fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n     fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n+    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef>;\n     fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef;\n     fn read_polytype(&mut self, dcx: &DecodeContext)\n@@ -1447,6 +1485,77 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_method_origin(&mut self, dcx: &DecodeContext)\n+                          -> typeck::MethodOrigin\n+    {\n+        self.read_enum(\"MethodOrigin\", |this| {\n+            let variants = [\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n+                            \"MethodParam\", \"MethodObject\"];\n+            this.read_enum_variant(variants, |this, i| {\n+                Ok(match i {\n+                    0 => {\n+                        let def_id = this.read_def_id(dcx);\n+                        typeck::MethodStatic(def_id)\n+                    }\n+\n+                    1 => {\n+                        let def_id = this.read_def_id(dcx);\n+                        typeck::MethodStaticUnboxedClosure(def_id)\n+                    }\n+\n+                    2 => {\n+                        this.read_struct(\"MethodParam\", 2, |this| {\n+                            Ok(typeck::MethodParam(\n+                                typeck::MethodParam {\n+                                    trait_ref: {\n+                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n+                                            Ok(this.read_trait_ref(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    method_num: {\n+                                        this.read_struct_field(\"method_num\", 1, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    }\n+                                }))\n+                        }).unwrap()\n+                    }\n+\n+                    3 => {\n+                        this.read_struct(\"MethodObject\", 2, |this| {\n+                            Ok(typeck::MethodObject(\n+                                typeck::MethodObject {\n+                                    trait_ref: {\n+                                        this.read_struct_field(\"trait_ref\", 0, |this| {\n+                                            Ok(this.read_trait_ref(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    object_trait_id: {\n+                                        this.read_struct_field(\"object_trait_id\", 1, |this| {\n+                                            Ok(this.read_def_id(dcx))\n+                                        }).unwrap()\n+                                    },\n+                                    method_num: {\n+                                        this.read_struct_field(\"method_num\", 2, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    },\n+                                    real_index: {\n+                                        this.read_struct_field(\"real_index\", 3, |this| {\n+                                            this.read_uint()\n+                                        }).unwrap()\n+                                    },\n+                                }))\n+                        }).unwrap()\n+                    }\n+\n+                    _ => fail!(\"..\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n+\n+\n     fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1479,6 +1588,18 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().move_iter().collect()\n     }\n \n+    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef> {\n+        Rc::new(self.read_opaque(|this, doc| {\n+            let ty = tydecode::parse_trait_ref_data(\n+                doc.data,\n+                dcx.cdata.cnum,\n+                doc.start,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n+            Ok(ty)\n+        }).unwrap())\n+    }\n+\n     fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n@@ -1667,10 +1788,14 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                 0, |this| Ok(this.read_existential_bounds(dcx))).unwrap();\n                         let def_id: ast::DefId =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n-                        let substs = this.read_enum_variant_arg(2,\n+                        let self_ty =\n+                            this.read_enum_variant_arg(2, |this| Ok(this.read_ty(dcx))).unwrap();\n+                        let substs = this.read_enum_variant_arg(3,\n                             |this| Ok(this.read_substs(dcx))).unwrap();\n-\n-                        ty::UnsizeVtable(b, def_id.tr(dcx), substs)\n+                        let ty_trait = ty::TyTrait { def_id: def_id.tr(dcx),\n+                                                     bounds: b,\n+                                                     substs: substs };\n+                        ty::UnsizeVtable(ty_trait, self_ty)\n                     }\n                     _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n@@ -1828,15 +1953,10 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         };\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n-                    c::tag_table_vtable_map => {\n-                        let (adjustment, vtable_res) =\n-                            val_dsr.read_vtable_res_with_key(dcx.tcx,\n-                                                             dcx.cdata);\n-                        let vtable_key = MethodCall {\n-                            expr_id: id,\n-                            adjustment: adjustment\n-                        };\n-                        dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n+                    c::tag_table_object_cast_map => {\n+                        let trait_ref = val_dsr.read_trait_ref(dcx);\n+                        dcx.tcx.object_cast_map.borrow_mut()\n+                                               .insert(id, trait_ref);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);"}, {"sha": "f13c6bc3336fc429c62a277489a54c7968100933", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -102,17 +102,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     }\n                     typeck::MethodStaticUnboxedClosure(_) => {}\n                     typeck::MethodParam(typeck::MethodParam {\n-                        trait_id: trait_id,\n+                        trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n-                    })\n-                    | typeck::MethodObject(typeck::MethodObject {\n-                        trait_id: trait_id,\n+                    }) |\n+                    typeck::MethodObject(typeck::MethodObject {\n+                        trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n                     }) => {\n                         let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_id,\n+                                                        trait_ref.def_id,\n                                                         index);\n                         match trait_item {\n                             ty::MethodTraitItem(method) => {"}, {"sha": "d6c11caefe84b2c14b96c39e0c3b43b131a3d589", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -174,11 +174,9 @@ impl OverloadedCallType {\n             MethodStaticUnboxedClosure(def_id) => {\n                 OverloadedCallType::from_unboxed_closure(tcx, def_id)\n             }\n-            MethodParam(ref method_param) => {\n-                OverloadedCallType::from_trait_id(tcx, method_param.trait_id)\n-            }\n-            MethodObject(ref method_object) => {\n-                OverloadedCallType::from_trait_id(tcx, method_object.trait_id)\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n             }\n         }\n     }"}, {"sha": "56c785d3c2592845c1a07bd550f10a71a5b62378", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -782,19 +782,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, origin: MethodOrigin,\n+    fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n                     ident: ast::Ident) {\n-        match origin {\n+        match *origin {\n             MethodStatic(method_id) => {\n                 self.check_static_method(span, method_id, ident)\n             }\n             MethodStaticUnboxedClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodParam(MethodParam { trait_id: trait_id, .. }) |\n-            MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_id, None,\n-                                                     \"source trait\"));\n+            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+                self.report_error(self.ensure_public(span, trait_ref.def_id,\n+                                                     None, \"source trait\"));\n             }\n         }\n     }\n@@ -835,7 +835,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                     Some(method) => {\n                         debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, method.origin, ident.node);\n+                        self.check_method(expr.span, &method.origin, ident.node);\n                     }\n                 }\n             }"}, {"sha": "5859e5ceeeeb1af4e6c0a66ca3a8c06f55fdd855", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -908,21 +908,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 };\n                 (Some(def_id), decl_id)\n             }\n-            typeck::MethodParam(mp) => {\n+            typeck::MethodParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_id,\n+                                                mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 match trait_item {\n                     ty::MethodTraitItem(method) => {\n                         (None, Some(method.def_id))\n                     }\n                 }\n             },\n-            typeck::MethodObject(mo) => {\n+            typeck::MethodObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_id,\n+                                                mo.trait_ref.def_id,\n                                                 mo.method_num);\n                 match trait_item {\n                     ty::MethodTraitItem(method) => {"}, {"sha": "d7e6fd18ed5633a5d602de61f3a20e9e9c33d019", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -164,6 +164,11 @@ impl Substs {\n         s\n     }\n \n+    pub fn erase_regions(self) -> Substs {\n+        let Substs { types: types, regions: _ } = self;\n+        Substs { types: types, regions: ErasedRegions }\n+    }\n+\n     pub fn regions<'a>(&'a self) -> &'a VecPerParamSpace<ty::Region> {\n         /*!\n          * Since ErasedRegions are only to be used in trans, most of"}, {"sha": "0230668b15aec61a0f849ce3d9b7c16ad40320b8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -75,7 +75,6 @@ use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::trans::value::Value;\n use middle::ty;\n-use middle::typeck;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_string};\n use util::sha2::Sha256;\n@@ -547,8 +546,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         // Since we're in trans we don't care for any region parameters\n         let ref substs = subst::Substs::erased(substs.types.clone());\n \n-        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, substs);\n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, vtables, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {"}, {"sha": "ef98a73430264e312169789f419174fdc6c04e5e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 29, "deletions": 82, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -25,7 +25,7 @@ use llvm;\n use metadata::csearch;\n use middle::def;\n use middle::subst;\n-use middle::subst::{Subst, VecPerParamSpace};\n+use middle::subst::{Subst};\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::base::*;\n@@ -47,7 +47,6 @@ use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n-use middle::typeck;\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -227,61 +226,27 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let substs = node_id_substs(bcx, node);\n-    let vtable_key = match node {\n-        ExprId(id) => MethodCall::expr(id),\n-        MethodCall(method_call) => method_call\n-    };\n-    let vtables = node_vtables(bcx, vtable_key);\n-    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={}, vtables={})\",\n+    debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(bcx.tcx()),\n            node,\n-           substs.repr(bcx.tcx()),\n-           vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, node, substs, vtables)\n+           substs.repr(bcx.tcx()));\n+    trans_fn_ref_with_substs(bcx, def_id, node, substs)\n }\n \n-fn trans_fn_ref_with_vtables_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                   def_id: ast::DefId,\n-                                                   ref_id: ast::NodeId,\n-                                                   substs: subst::Substs,\n-                                                   vtables: typeck::vtable_res)\n-                                                   -> Callee<'blk, 'tcx> {\n+fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                  def_id: ast::DefId,\n+                                                  ref_id: ast::NodeId,\n+                                                  substs: subst::Substs)\n+                                                  -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n-        data: Fn(trans_fn_ref_with_vtables(bcx,\n-                                           def_id,\n-                                           ExprId(ref_id),\n-                                           substs,\n-                                           vtables)),\n+        data: Fn(trans_fn_ref_with_substs(bcx,\n+                                          def_id,\n+                                          ExprId(ref_id),\n+                                          substs)),\n     }\n }\n \n-fn resolve_default_method_vtables(bcx: Block,\n-                                  impl_id: ast::DefId,\n-                                  substs: &subst::Substs,\n-                                  impl_vtables: typeck::vtable_res)\n-                                  -> typeck::vtable_res\n-{\n-    // Get the vtables that the impl implements the trait at\n-    let impl_res = ty::lookup_impl_vtables(bcx.tcx(), impl_id);\n-\n-    // Build up a param_substs that we are going to resolve the\n-    // trait_vtables under.\n-    let param_substs = param_substs {\n-        substs: (*substs).clone(),\n-        vtables: impl_vtables.clone()\n-    };\n-\n-    let mut param_vtables = resolve_vtables_under_param_substs(\n-        bcx.tcx(), &param_substs, &impl_res);\n-\n-    // Now we pull any vtables for parameters on the actual method.\n-    param_vtables.push_all(subst::FnSpace,\n-                           impl_vtables.get_slice(subst::FnSpace));\n-\n-    param_vtables\n-}\n-\n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n pub fn trans_unboxing_shim(bcx: Block,\n@@ -408,12 +373,11 @@ pub fn trans_unboxing_shim(bcx: Block,\n     llfn\n }\n \n-pub fn trans_fn_ref_with_vtables(\n+pub fn trans_fn_ref_with_substs(\n     bcx: Block,                  //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n-    substs: subst::Substs,       // values for fn's ty params\n-    vtables: typeck::vtable_res) // vtables for the call\n+    substs: subst::Substs)       // vtables for the call\n     -> ValueRef\n {\n     /*!\n@@ -428,20 +392,18 @@ pub fn trans_fn_ref_with_vtables(\n      *   This parameter may be zero; but, if so, the resulting value may not\n      *   have the right type, so it must be cast before being used.\n      * - `substs`: values for each of the fn/method's parameters\n-     * - `vtables`: values for each bound on each of the type parameters\n      */\n \n-    let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n+    let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n-            substs={}, vtables={})\",\n+    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={:?}, \\\n+            substs={})\",\n            bcx.to_str(),\n            def_id.repr(tcx),\n            node,\n-           substs.repr(tcx),\n-           vtables.repr(tcx));\n+           substs.repr(tcx));\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n \n@@ -456,9 +418,8 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs, vtables) =\n-        match ty::provided_source(tcx, def_id) {\n-        None => (false, def_id, substs, vtables),\n+    let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n+        None => (false, def_id, substs),\n         Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -491,23 +452,11 @@ pub fn trans_fn_ref_with_vtables(\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n-                            first_subst = {}, new_subst = {}, \\\n-                            vtables = {}\",\n+                            first_subst = {}, new_subst = {}\",\n                            substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                           first_subst.repr(tcx), new_substs.repr(tcx),\n-                           vtables.repr(tcx));\n-\n-                    let param_vtables =\n-                        resolve_default_method_vtables(bcx,\n-                                                       impl_id,\n-                                                       &substs,\n-                                                       vtables);\n-\n-                    debug!(\"trans_fn_with_vtables - default method: \\\n-                            param_vtables = {}\",\n-                           param_vtables.repr(tcx));\n+                           first_subst.repr(tcx), new_substs.repr(tcx));\n \n-                    (true, source_id, new_substs, param_vtables)\n+                    (true, source_id, new_substs)\n                 }\n             }\n         }\n@@ -556,8 +505,7 @@ pub fn trans_fn_ref_with_vtables(\n         };\n \n         let (val, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, &substs,\n-                                         vtables, opt_ref_id);\n+            monomorphize::monomorphic_fn(ccx, def_id, &substs, opt_ref_id);\n         let mut val = val;\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n@@ -678,11 +626,10 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              fty,\n                              |bcx, _| {\n-                                trans_fn_ref_with_vtables_to_callee(bcx,\n-                                                                    did,\n-                                                                    0,\n-                                                                    subst::Substs::empty(),\n-                                                                    VecPerParamSpace::empty())\n+                                trans_fn_ref_with_substs_to_callee(bcx,\n+                                                                   did,\n+                                                                   0,\n+                                                                   subst::Substs::empty())\n                              },\n                              ArgVals(args),\n                              dest)"}, {"sha": "60ae26439b4831ec9f1cbd519209af216ffe1359", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 100, "deletions": 88, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -29,8 +29,11 @@ use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n+use middle::traits;\n use middle::ty;\n+use middle::ty_fold;\n use middle::typeck;\n+use middle::typeck::infer;\n use util::ppaux::Repr;\n use util::nodemap::{DefIdMap, NodeMap};\n \n@@ -39,6 +42,7 @@ use std::collections::HashMap;\n use libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n+use std::rc::Rc;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n@@ -188,14 +192,12 @@ pub type ExternMap = HashMap<String, ValueRef>;\n // will only be set in the case of default methods.\n pub struct param_substs {\n     pub substs: subst::Substs,\n-    pub vtables: typeck::vtable_res,\n }\n \n impl param_substs {\n     pub fn empty() -> param_substs {\n         param_substs {\n             substs: subst::Substs::trans_empty(),\n-            vtables: subst::VecPerParamSpace::empty(),\n         }\n     }\n \n@@ -204,15 +206,9 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_string(this: &param_substs, tcx: &ty::ctxt) -> String {\n-    format!(\"param_substs(substs={},vtables={})\",\n-            this.substs.repr(tcx),\n-            this.vtables.repr(tcx))\n-}\n-\n impl Repr for param_substs {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        param_substs_to_string(self, tcx)\n+        self.substs.repr(tcx)\n     }\n }\n \n@@ -766,6 +762,98 @@ pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n+pub fn fulfill_obligation(ccx: &CrateContext,\n+                          span: Span,\n+                          trait_ref: Rc<ty::TraitRef>)\n+                          -> traits::Vtable<()>\n+{\n+    /*!\n+     * Attempts to resolve an obligation. The result is a shallow\n+     * vtable resolution -- meaning that we do not (necessarily) resolve\n+     * all nested obligations on the impl. Note that type check should\n+     * guarantee to us that all nested obligations *could be* resolved\n+     * if we wanted to.\n+     */\n+\n+    let tcx = ccx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n+\n+    // First check the cache.\n+    match ccx.trait_cache().borrow().find(&trait_ref) {\n+        Some(vtable) => {\n+            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            return (*vtable).clone();\n+        }\n+        None => { }\n+    }\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    // Parameter environment is used to give details about type parameters,\n+    // but since we are in trans, everything is fully monomorphized.\n+    let param_env = ty::empty_parameter_environment();\n+    let unboxed_closures = tcx.unboxed_closures.borrow();\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    let selcx = traits::SelectionContext::new(&infcx, &param_env,\n+                                              &*unboxed_closures);\n+    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered ambiguity selecting `{}` during trans\",\n+                        trait_ref.repr(tcx)).as_slice())\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered error `{}` selecting `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx)).as_slice())\n+        }\n+    };\n+\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters. However, in principle,\n+    // we only need to do this until the impl's type parameters are\n+    // fully bound. It could be a slight optimization to stop\n+    // iterating early.\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let vtable = selection.map_move_nested(|obligation| {\n+        fulfill_cx.register_obligation(tcx, obligation);\n+    });\n+    match fulfill_cx.select_all_or_error(&infcx, &param_env, &*unboxed_closures) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                format!(\"Encountered errors `{}` fulfilling `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx)).as_slice());\n+        }\n+    }\n+\n+    // Use skolemize to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no skolemized types should ever\n+    // be inserted.\n+    let vtable = infer::skolemize(&infcx, vtable);\n+\n+    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    ccx.trait_cache().borrow_mut().insert(trait_ref,\n+                                          vtable.clone());\n+\n+    vtable\n+}\n+\n // Key used to lookup values supplied for type parameters in an expr.\n #[deriving(PartialEq)]\n pub enum ExprOrMethodCall {\n@@ -778,7 +866,8 @@ pub enum ExprOrMethodCall {\n \n pub fn node_id_substs(bcx: Block,\n                       node: ExprOrMethodCall)\n-                      -> subst::Substs {\n+                      -> subst::Substs\n+{\n     let tcx = bcx.tcx();\n \n     let substs = match node {\n@@ -798,87 +887,10 @@ pub fn node_id_substs(bcx: Block,\n                     substs.repr(bcx.tcx())).as_slice());\n     }\n \n+    let substs = substs.erase_regions();\n     substs.substp(tcx, bcx.fcx.param_substs)\n }\n \n-pub fn node_vtables(bcx: Block, id: typeck::MethodCall)\n-                 -> typeck::vtable_res {\n-    bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n-        resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n-    }).unwrap_or_else(|| subst::VecPerParamSpace::empty())\n-}\n-\n-// Apply the typaram substitutions in the FunctionContext to some\n-// vtables. This should eliminate any vtable_params.\n-pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext,\n-                                  vts: &typeck::vtable_res)\n-                                  -> typeck::vtable_res {\n-    resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n-                                       fcx.param_substs,\n-                                       vts)\n-}\n-\n-pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                          param_substs: &param_substs,\n-                                          vts: &typeck::vtable_res)\n-                                          -> typeck::vtable_res\n-{\n-    vts.map(|ds| {\n-        resolve_param_vtables_under_param_substs(tcx,\n-                                                 param_substs,\n-                                                 ds)\n-    })\n-}\n-\n-pub fn resolve_param_vtables_under_param_substs(tcx: &ty::ctxt,\n-                                                param_substs: &param_substs,\n-                                                ds: &typeck::vtable_param_res)\n-                                                -> typeck::vtable_param_res\n-{\n-    ds.iter().map(|d| {\n-        resolve_vtable_under_param_substs(tcx,\n-                                          param_substs,\n-                                          d)\n-    }).collect()\n-}\n-\n-\n-\n-pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n-                                         param_substs: &param_substs,\n-                                         vt: &typeck::vtable_origin)\n-                                         -> typeck::vtable_origin\n-{\n-    match *vt {\n-        typeck::vtable_static(trait_id, ref vtable_substs, ref sub) => {\n-            let vtable_substs = vtable_substs.substp(tcx, param_substs);\n-            typeck::vtable_static(\n-                trait_id,\n-                vtable_substs,\n-                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n-        }\n-        typeck::vtable_param(n_param, n_bound) => {\n-            find_vtable(tcx, param_substs, n_param, n_bound)\n-        }\n-        typeck::vtable_unboxed_closure(def_id) => {\n-            typeck::vtable_unboxed_closure(def_id)\n-        }\n-        typeck::vtable_error => typeck::vtable_error\n-    }\n-}\n-\n-pub fn find_vtable(tcx: &ty::ctxt,\n-                   ps: &param_substs,\n-                   n_param: typeck::param_index,\n-                   n_bound: uint)\n-                   -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n-           n_param, n_bound, ps.repr(tcx));\n-\n-    let param_bounds = ps.vtables.get(n_param.space, n_param.index);\n-    param_bounds.get(n_bound).clone()\n-}\n-\n pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "093849b47ad9833410b83e30ab1b99512abf5734", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -16,6 +16,7 @@ use llvm::{TargetData};\n use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n use middle::resolve;\n+use middle::traits;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n@@ -103,7 +104,7 @@ pub struct LocalCrateContext {\n     monomorphized: RefCell<HashMap<MonoId, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<HashMap<(ty::t, MonoId), ValueRef>>,\n+    vtables: RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n@@ -150,6 +151,9 @@ pub struct LocalCrateContext {\n     /// This is used to perform some basic load-balancing to keep all LLVM\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n+\n+    trait_cache: RefCell<HashMap<Rc<ty::TraitRef>,\n+                                 traits::Vtable<()>>>,\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n@@ -426,6 +430,7 @@ impl LocalCrateContext {\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n                 n_llvm_insns: Cell::new(0u),\n+                trait_cache: RefCell::new(HashMap::new()),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n@@ -617,7 +622,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t, MonoId), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<HashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n         &self.local.vtables\n     }\n \n@@ -713,6 +718,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn count_llvm_insn(&self) {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n+\n+    pub fn trait_cache(&self) -> &RefCell<HashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n+        &self.local.trait_cache\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "af57d49d9d81568dd3834832a2bb075cb9ebebf0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -41,6 +41,7 @@ use middle::def;\n use middle::lang_items::MallocFnLangItem;\n use middle::mem_categorization::Typer;\n use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::asm;\n@@ -78,6 +79,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n+use std::rc::Rc;\n \n // Destinations\n \n@@ -319,10 +321,18 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n                                           bcx.ty_to_string(unsized_ty)).as_slice())\n             },\n-            &ty::UnsizeVtable(..) =>\n+            &ty::UnsizeVtable(ty::TyTrait { def_id: def_id, substs: ref substs, .. }, _) => {\n+                let substs = substs.with_self_ty(unsized_ty);\n+                let trait_ref =\n+                    Rc::new(ty::TraitRef { def_id: def_id,\n+                                           substs: substs });\n+                let trait_ref =\n+                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n+                let box_ty = mk_ty(unsized_ty);\n                 PointerCast(bcx,\n-                            meth::vtable_ptr(bcx, id, mk_ty(unsized_ty)),\n+                            meth::get_vtable(bcx, box_ty, trait_ref),\n                             Type::vtable_ptr(bcx.ccx()))\n+            }\n         }\n     }\n \n@@ -1052,8 +1062,16 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprCast(ref val, _) => {\n             // DPS output mode means this is a trait cast:\n             if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n+                let trait_ref =\n+                    bcx.tcx().object_cast_map.borrow()\n+                                             .find(&expr.id)\n+                                             .map(|t| (*t).clone())\n+                                             .unwrap();\n+                let trait_ref =\n+                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n-                meth::trans_trait_cast(bcx, datum, expr.id, dest)\n+                meth::trans_trait_cast(bcx, datum, expr.id,\n+                                       trait_ref, dest)\n             } else {\n                 bcx.tcx().sess.span_bug(expr.span,\n                                         \"expr_cast of non-trait\");"}, {"sha": "a87557a26cc67b2272b3f157f25f1524662b4c40", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 199, "deletions": 168, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -13,8 +13,10 @@ use back::abi;\n use llvm;\n use llvm::ValueRef;\n use metadata::csearch;\n+use middle::subst::{Subst,Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n+use middle::traits;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee::*;\n@@ -26,20 +28,20 @@ use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::machine;\n-use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n use middle::typeck::MethodCall;\n-use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n use syntax::ast_util::PostExpansionMethod;\n+use syntax::codemap::DUMMY_SP;\n \n // drop_glue pointer, size, align.\n static VTABLE_OFFSET: uint = 3;\n@@ -109,18 +111,12 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n-    let (origin, method_ty) = match bcx.tcx().method_map\n-                                       .borrow().find(&method_call) {\n-        Some(method) => {\n-            debug!(\"trans_method_callee({:?}, method={})\",\n-                   method_call, method.repr(bcx.tcx()));\n-            (method.origin, method.ty)\n-        }\n-        None => {\n-            bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                \"method call expr wasn't in method map\")\n-        }\n-    };\n+    let (origin, method_ty) =\n+        bcx.tcx().method_map\n+                 .borrow()\n+                 .find(&method_call)\n+                 .map(|method| (method.origin.clone(), method.ty))\n+                 .unwrap();\n \n     match origin {\n         typeck::MethodStatic(did) |\n@@ -132,19 +128,21 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               MethodCall(method_call))),\n             }\n         }\n+\n         typeck::MethodParam(typeck::MethodParam {\n-            trait_id: trait_id,\n-            method_num: off,\n-            param_num: p,\n-            bound_num: b\n+            trait_ref: ref trait_ref,\n+            method_num: method_num\n         }) => {\n-            ty::populate_implementations_for_trait_if_necessary(\n-                bcx.tcx(),\n-                trait_id);\n-\n-            let vtbl = find_vtable(bcx.tcx(), bcx.fcx.param_substs, p, b);\n-            trans_monomorphized_callee(bcx, method_call,\n-                                       trait_id, off, vtbl)\n+            let trait_ref =\n+                Rc::new(trait_ref.subst(bcx.tcx(),\n+                                        &bcx.fcx.param_substs.substs));\n+            let span = bcx.tcx().map.span(method_call.expr_id);\n+            let origin = fulfill_obligation(bcx.ccx(),\n+                                            span,\n+                                            (*trait_ref).clone());\n+            debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n+            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id,\n+                                       method_num, origin)\n         }\n \n         typeck::MethodObject(ref mt) => {\n@@ -169,7 +167,8 @@ pub fn trans_static_method_callee(bcx: Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   expr_id: ast::NodeId)\n-                                  -> ValueRef {\n+                                  -> ValueRef\n+{\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n@@ -178,9 +177,6 @@ pub fn trans_static_method_callee(bcx: Block,\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n            expr_id);\n-    let _indenter = indenter();\n-\n-    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n         match bcx.tcx().map.get(method_id.node) {\n@@ -196,38 +192,91 @@ pub fn trans_static_method_callee(bcx: Block,\n     } else {\n         csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()\n     };\n-    debug!(\"trans_static_method_callee: method_id={:?}, expr_id={:?}, \\\n+    debug!(\"trans_static_method_callee: method_id={}, expr_id={}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n-    let vtable_key = MethodCall::expr(expr_id);\n-    let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx,\n-        ccx.tcx().vtable_map.borrow().get(&vtable_key));\n-\n-    match *vtbls.get_self().unwrap().get(0) {\n-        typeck::vtable_static(impl_did, ref rcvr_substs, ref rcvr_origins) => {\n-            assert!(rcvr_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    // Find the substitutions for the fn itself. This includes\n+    // type parameters that belong to the trait but also some that\n+    // belong to the method:\n+    let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n+    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.split();\n+\n+    // Lookup the precise impl being called. To do that, we need to\n+    // create a trait reference identifying the self type and other\n+    // input type parameters. To create that trait reference, we have\n+    // to pick apart the type parameters to identify just those that\n+    // pertain to the trait. This is easiest to explain by example:\n+    //\n+    //     trait Convert {\n+    //         fn from<U:Foo>(n: U) -> Option<Self>;\n+    //     }\n+    //     ...\n+    //     let f = <Vec<int> as Convert>::from::<String>(...)\n+    //\n+    // Here, in this call, which I've written with explicit UFCS\n+    // notation, the set of type parameters will be:\n+    //\n+    //     rcvr_type: [] <-- nothing declared on the trait itself\n+    //     rcvr_self: [Vec<int>] <-- the self type\n+    //     rcvr_method: [String] <-- method type parameter\n+    //\n+    // So we create a trait reference using the first two,\n+    // basically corresponding to `<Vec<int> as Convert>`.\n+    // The remaining type parameters (`rcvr_method`) will be used below.\n+    let trait_substs =\n+        Substs::erased(VecPerParamSpace::new(rcvr_type,\n+                                             rcvr_self,\n+                                             Vec::new()));\n+    debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n+    let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n+                                           substs: trait_substs });\n+    let vtbl = fulfill_obligation(bcx.ccx(),\n+                                  DUMMY_SP,\n+                                  trait_ref);\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(traits::VtableImpl {\n+            impl_def_id: impl_did,\n+            substs: impl_substs,\n+            nested: _ }) =>\n+        {\n+            assert!(impl_substs.types.all(|t| !ty::type_needs_infer(*t)));\n+\n+            // Create the substitutions that are in scope. This combines\n+            // the type parameters from the impl with those declared earlier.\n+            // To see what I mean, consider a possible impl:\n+            //\n+            //    impl<T> Convert for Vec<T> {\n+            //        fn from<U:Foo>(n: U) { ... }\n+            //    }\n+            //\n+            // Recall that we matched `<Vec<int> as Convert>`. Trait\n+            // resolution will have given us a substitution\n+            // containing `impl_substs=[[T=int],[],[]]` (the type\n+            // parameters defined on the impl). We combine\n+            // that with the `rcvr_method` from before, which tells us\n+            // the type parameters from the *method*, to yield\n+            // `callee_substs=[[T=int],[],[U=String]]`.\n+            let (impl_type, impl_self, _) = impl_substs.types.split();\n+            let callee_substs =\n+                Substs::erased(VecPerParamSpace::new(impl_type,\n+                                                     impl_self,\n+                                                     rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n-            let (callee_substs, callee_origins) =\n-                combine_impl_and_methods_tps(\n-                    bcx, ExprId(expr_id),\n-                    (*rcvr_substs).clone(), (*rcvr_origins).clone());\n-\n-            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, ExprId(expr_id),\n-                                                 callee_substs,\n-                                                 callee_origins);\n+            let llfn = trans_fn_ref_with_substs(bcx, mth_id, ExprId(expr_id),\n+                                                callee_substs);\n \n             let callee_ty = node_id_type(bcx, expr_id);\n             let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n             PointerCast(bcx, llfn, llty)\n         }\n-        typeck::vtable_unboxed_closure(_) => {\n-            bcx.tcx().sess.bug(\"can't call a closure vtable in a static way\");\n-        }\n         _ => {\n-            fail!(\"vtable_param left in monomorphized \\\n-                   function's vtable substs\");\n+            bcx.tcx().sess.bug(\n+                format!(\"static call to invalid vtable: {}\",\n+                        vtbl.repr(bcx.tcx())).as_slice());\n         }\n     }\n }\n@@ -265,33 +314,33 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n                                           n_method: uint,\n-                                          vtbl: typeck::vtable_origin)\n+                                          vtable: traits::Vtable<()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n-    match vtbl {\n-      typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n-          let ccx = bcx.ccx();\n-          let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n-              ty::MethodTraitItem(method) => method.ident,\n-          };\n-          let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n-\n-          // create a concatenated set of substitutions which includes\n-          // those from the impl and those from the method:\n-          let (callee_substs, callee_origins) =\n-              combine_impl_and_methods_tps(\n-                  bcx, MethodCall(method_call), rcvr_substs, rcvr_origins);\n-\n-          // translate the function\n-          let llfn = trans_fn_ref_with_vtables(bcx,\n-                                               mth_id,\n-                                               MethodCall(method_call),\n-                                               callee_substs,\n-                                               callee_origins);\n-\n-          Callee { bcx: bcx, data: Fn(llfn) }\n-      }\n-      typeck::vtable_unboxed_closure(closure_def_id) => {\n+    match vtable {\n+        traits::VtableImpl(vtable_impl) => {\n+            let ccx = bcx.ccx();\n+            let impl_did = vtable_impl.impl_def_id;\n+            let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n+                ty::MethodTraitItem(method) => method.ident,\n+            };\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n+\n+            // create a concatenated set of substitutions which includes\n+            // those from the impl and those from the method:\n+            let callee_substs =\n+                combine_impl_and_methods_tps(\n+                    bcx, MethodCall(method_call), vtable_impl.substs);\n+\n+            // translate the function\n+            let llfn = trans_fn_ref_with_substs(bcx,\n+                                                mth_id,\n+                                                MethodCall(method_call),\n+                                                callee_substs);\n+\n+            Callee { bcx: bcx, data: Fn(llfn) }\n+        }\n+        traits::VtableUnboxedClosure(closure_def_id) => {\n           // The static region and type parameters are lies, but we're in\n           // trans so it doesn't matter.\n           //\n@@ -300,33 +349,27 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx,\n                 closure_def_id);\n \n-          let llfn = trans_fn_ref_with_vtables(bcx,\n-                                               closure_def_id,\n-                                               MethodCall(method_call),\n-                                               callee_substs,\n-                                               VecPerParamSpace::empty());\n-\n-          Callee {\n-              bcx: bcx,\n-              data: Fn(llfn),\n-          }\n-      }\n-      typeck::vtable_param(..) => {\n-          bcx.tcx().sess.bug(\n-              \"vtable_param left in monomorphized function's vtable substs\");\n-      }\n-      typeck::vtable_error => {\n-          bcx.tcx().sess.bug(\n-              \"vtable_error left in monomorphized function's vtable substs\");\n-      }\n+            let llfn = trans_fn_ref_with_substs(bcx,\n+                                                closure_def_id,\n+                                                MethodCall(method_call),\n+                                                callee_substs);\n+\n+            Callee {\n+                bcx: bcx,\n+                data: Fn(llfn),\n+            }\n+        }\n+        _ => {\n+            bcx.tcx().sess.bug(\n+                \"vtable_param left in monomorphized function's vtable substs\");\n+        }\n     }\n }\n \n fn combine_impl_and_methods_tps(bcx: Block,\n                                 node: ExprOrMethodCall,\n-                                rcvr_substs: subst::Substs,\n-                                rcvr_origins: typeck::vtable_res)\n-                                -> (subst::Substs, typeck::vtable_res)\n+                                rcvr_substs: subst::Substs)\n+                                -> subst::Substs\n {\n     /*!\n      * Creates a concatenated set of substitutions which includes\n@@ -347,33 +390,20 @@ fn combine_impl_and_methods_tps(bcx: Block,\n \n     let ccx = bcx.ccx();\n \n-    let vtable_key = match node {\n-        ExprId(id) => MethodCall::expr(id),\n-        MethodCall(method_call) => method_call\n-    };\n     let node_substs = node_id_substs(bcx, node);\n-    let node_vtables = node_vtables(bcx, vtable_key);\n \n-    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n-    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"rcvr_substs={}\", rcvr_substs.repr(ccx.tcx()));\n+    debug!(\"node_substs={}\", node_substs.repr(ccx.tcx()));\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n     let (_, _, node_method) = node_substs.types.split();\n     let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n-    let ty_substs = subst::Substs {\n+    subst::Substs {\n         regions: subst::ErasedRegions,\n         types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n-    };\n-\n-    // Now do the same work for the vtables.\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_origins.split();\n-    let (_, _, node_method) = node_vtables.split();\n-    assert!(rcvr_method.is_empty());\n-    let vtables = subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method);\n-\n-    (ty_substs, vtables)\n+    }\n }\n \n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -493,43 +523,56 @@ fn get_callee_substitutions_for_unboxed_closure(bcx: Block,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-fn get_vtable(bcx: Block,\n-              self_ty: ty::t,\n-              origins: typeck::vtable_param_res)\n-              -> ValueRef\n+///\n+/// The `trait_ref` encodes the erased self type. Hence if we are\n+/// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n+/// `trait_ref` would map `T:Trait`, but `box_ty` would be\n+/// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n+/// This will hopefully change now that DST is underway.\n+pub fn get_vtable(bcx: Block,\n+                  box_ty: ty::t,\n+                  trait_ref: Rc<ty::TraitRef>)\n+                  -> ValueRef\n {\n-    debug!(\"get_vtable(self_ty={}, origins={})\",\n-           self_ty.repr(bcx.tcx()),\n-           origins.repr(bcx.tcx()));\n+    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n+           box_ty.repr(bcx.tcx()),\n+           trait_ref.repr(bcx.tcx()));\n \n+    let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, monomorphize::make_vtable_id(ccx, origins.get(0)));\n-    match ccx.vtables().borrow().find(&hash_id) {\n+    let cache_key = (box_ty, trait_ref.clone());\n+    match ccx.vtables().borrow().find(&cache_key) {\n         Some(&val) => { return val }\n         None => { }\n     }\n \n-    // Not in the cache. Actually build it.\n-    let methods = origins.move_iter().flat_map(|origin| {\n-        match origin {\n-            typeck::vtable_static(id, substs, sub_vtables) => {\n-                emit_vtable_methods(bcx, id, substs, sub_vtables).move_iter()\n+    // Not in the cache. Build it.\n+    let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n+        let vtable = fulfill_obligation(bcx.ccx(),\n+                                        DUMMY_SP,\n+                                        trait_ref.clone());\n+        match vtable {\n+            traits::VtableImpl(\n+                traits::VtableImpl {\n+                    impl_def_id: id,\n+                    substs: substs,\n+                    nested: _ }) => {\n+                emit_vtable_methods(bcx, id, substs).move_iter()\n             }\n-            typeck::vtable_unboxed_closure(closure_def_id) => {\n+            traits::VtableUnboxedClosure(closure_def_id) => {\n                 let callee_substs =\n                     get_callee_substitutions_for_unboxed_closure(\n                         bcx,\n                         closure_def_id);\n \n-                let mut llfn = trans_fn_ref_with_vtables(\n+                let mut llfn = trans_fn_ref_with_substs(\n                     bcx,\n                     closure_def_id,\n                     ExprId(0),\n-                    callee_substs.clone(),\n-                    VecPerParamSpace::empty());\n+                    callee_substs.clone());\n \n                 {\n                     let unboxed_closures = bcx.tcx()\n@@ -585,21 +628,27 @@ fn get_vtable(bcx: Block,\n \n                 (vec!(llfn)).move_iter()\n             }\n-            _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n+            traits::VtableBuiltin |\n+            traits::VtableParam(..) => {\n+                bcx.sess().bug(\n+                    format!(\"resolved vtable for {} to bad vtable {} in trans\",\n+                            trait_ref.repr(bcx.tcx()),\n+                            vtable.repr(bcx.tcx())).as_slice());\n+            }\n         }\n     });\n \n-    let size_ty = sizing_type_of(ccx, self_ty);\n+    let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n     let ll_size = C_uint(ccx, size as uint);\n-    let align = align_of(ccx, self_ty);\n+    let align = align_of(ccx, trait_ref.self_ty());\n     let ll_align = C_uint(ccx, align as uint);\n \n     // Generate a destructor for the vtable.\n-    let drop_glue = glue::get_drop_glue(ccx, self_ty);\n+    let drop_glue = glue::get_drop_glue(ccx, box_ty);\n     let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n-    ccx.vtables().borrow_mut().insert(hash_id, vtable);\n+    ccx.vtables().borrow_mut().insert(cache_key, vtable);\n     vtable\n }\n \n@@ -630,8 +679,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n \n fn emit_vtable_methods(bcx: Block,\n                        impl_id: ast::DefId,\n-                       substs: subst::Substs,\n-                       vtables: typeck::vtable_res)\n+                       substs: subst::Substs)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx();\n@@ -664,12 +712,11 @@ fn emit_vtable_methods(bcx: Block,\n                            token::get_ident(ident));\n                     C_null(Type::nil(ccx).ptr_to())\n                 } else {\n-                    let mut fn_ref = trans_fn_ref_with_vtables(\n+                    let mut fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n                         m_id,\n                         ExprId(0),\n-                        substs.clone(),\n-                        vtables.clone());\n+                        substs.clone());\n                     if m.explicit_self == ty::ByValueExplicitSelfCategory {\n                         fn_ref = trans_unboxing_shim(bcx,\n                                                      fn_ref,\n@@ -684,29 +731,10 @@ fn emit_vtable_methods(bcx: Block,\n     }).collect()\n }\n \n-pub fn vtable_ptr(bcx: Block,\n-                  id: ast::NodeId,\n-                  self_ty: ty::t) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    let origins = {\n-        let vtable_map = ccx.tcx().vtable_map.borrow();\n-        // This trait cast might be because of implicit coercion\n-        let adjs = ccx.tcx().adjustments.borrow();\n-        let adjust = adjs.find(&id);\n-        let method_call = if adjust.is_some() && ty::adjust_is_object(adjust.unwrap()) {\n-            MethodCall::autoobject(id)\n-        } else {\n-            MethodCall::expr(id)\n-        };\n-        let vres = vtable_map.get(&method_call).get_self().unwrap();\n-        resolve_param_vtables_under_param_substs(ccx.tcx(), bcx.fcx.param_substs, vres)\n-    };\n-    get_vtable(bcx, self_ty, origins)\n-}\n-\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<Expr>,\n                                     id: ast::NodeId,\n+                                    trait_ref: Rc<ty::TraitRef>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     /*!\n@@ -717,25 +745,28 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n      */\n \n     let mut bcx = bcx;\n-    let _icx = push_ctxt(\"meth::trans_cast\");\n+    let _icx = push_ctxt(\"meth::trans_trait_cast\");\n \n     let lldest = match dest {\n         Ignore => {\n-            return datum.clean(bcx, \"trait_cast\", id);\n+            return datum.clean(bcx, \"trait_trait_cast\", id);\n         }\n         SaveIn(dest) => dest\n     };\n \n-    let v_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), v_ty);\n+    debug!(\"trans_trait_cast: trait_ref={}\",\n+           trait_ref.repr(bcx.tcx()));\n+\n+    let datum_ty = datum.ty;\n+    let llbox_ty = type_of(bcx.ccx(), datum_ty);\n \n     // Store the pointer into the first half of pair.\n     let llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n     let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = vtable_ptr(bcx, id, v_ty);\n+    let vtable = get_vtable(bcx, datum_ty, trait_ref);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "00e9d9f0e39b6af8750a321d1cbbc4ef798f25c8", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -34,17 +34,14 @@ use std::hash::{sip, Hash};\n pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &subst::Substs,\n-                      vtables: typeck::vtable_res,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n-            vtables={}, \\\n             ref_id={:?})\",\n            fn_id.repr(ccx.tcx()),\n            real_substs.repr(ccx.tcx()),\n-           vtables.repr(ccx.tcx()),\n            ref_id);\n \n     assert!(real_substs.types.all(|t| {\n@@ -69,7 +66,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let psubsts = param_substs {\n         substs: (*real_substs).clone(),\n-        vtables: vtables,\n     };\n \n     debug!(\"monomorphic_fn(\\\n@@ -286,7 +282,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-// Used to identify cached monomorphized functions and vtables\n+// Used to identify cached monomorphized functions\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoParamId {\n     pub subst: ty::t,"}, {"sha": "c26505fdc65787fe381d9219500cd3041ebb8feb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -28,6 +28,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::subst;\n+use middle::traits;\n use middle::ty;\n use middle::typeck;\n use middle::ty_fold;\n@@ -272,9 +273,7 @@ pub enum UnsizeKind {\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n     UnsizeStruct(Box<UnsizeKind>, uint),\n-    UnsizeVtable(ty::ExistentialBounds,\n-                 ast::DefId, /* Trait ID */\n-                 subst::Substs /* Trait substitutions */)\n+    UnsizeVtable(TyTrait, /* the self type of the trait */ ty::t)\n }\n \n #[deriving(Clone)]\n@@ -365,13 +364,13 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n     fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n                     Some(mk_trait(cx, def_id, substs.clone(), bounds))\n                 }\n                 _ => None\n             },\n             &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(bounds, def_id, ref substs) => {\n+                &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n                     Some(mk_uniq(cx, mk_trait(cx, def_id, substs.clone(), bounds)))\n                 }\n                 _ => None\n@@ -458,6 +457,10 @@ pub struct ctxt<'tcx> {\n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n+    /// Maps from node-id of a trait object cast (like `foo as\n+    /// Box<Trait>`) to the trait reference.\n+    pub object_cast_map: typeck::ObjectCastMap,\n+\n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n     pub freevars: RefCell<freevars::freevar_map>,\n@@ -499,7 +502,7 @@ pub struct ctxt<'tcx> {\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n+    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<ast::DefId>>>>,\n \n     /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n@@ -516,9 +519,6 @@ pub struct ctxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// vtable resolution information for impl declarations\n-    pub impl_vtables: typeck::impl_vtable_map,\n-\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n@@ -536,7 +536,6 @@ pub struct ctxt<'tcx> {\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: typeck::MethodMap,\n-    pub vtable_map: typeck::vtable_map,\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n@@ -1435,6 +1434,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         item_substs: RefCell::new(NodeMap::new()),\n         trait_refs: RefCell::new(NodeMap::new()),\n         trait_defs: RefCell::new(DefIdMap::new()),\n+        object_cast_map: RefCell::new(NodeMap::new()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n         freevars: RefCell::new(freevars),\n@@ -1463,14 +1463,12 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         impl_items: RefCell::new(DefIdMap::new()),\n         used_unsafe: RefCell::new(NodeSet::new()),\n         used_mut_nodes: RefCell::new(NodeSet::new()),\n-        impl_vtables: RefCell::new(DefIdMap::new()),\n         populated_external_types: RefCell::new(DefIdSet::new()),\n         populated_external_traits: RefCell::new(DefIdSet::new()),\n         upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(DefIdMap::new()),\n         extern_const_variants: RefCell::new(DefIdMap::new()),\n         method_map: RefCell::new(FnvHashMap::new()),\n-        vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n         unboxed_closures: RefCell::new(DefIdMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n@@ -2944,13 +2942,17 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n }\n \n pub fn type_is_trait(ty: t) -> bool {\n+    type_trait_info(ty).is_some()\n+}\n+\n+pub fn type_trait_info(ty: t) -> Option<&'static TyTrait> {\n     match get(ty).sty {\n         ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n-            ty_trait(..) => true,\n-            _ => false\n+            ty_trait(ref t) => Some(&**t),\n+            _ => None\n         },\n-        ty_trait(..) => true,\n-        _ => false\n+        ty_trait(ref t) => Some(&**t),\n+        _ => None\n     }\n }\n \n@@ -3491,7 +3493,7 @@ pub fn unsize_ty(cx: &ctxt,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n                                           ty_to_string(cx, ty)).as_slice())\n         },\n-        &UnsizeVtable(bounds, def_id, ref substs) => {\n+        &UnsizeVtable(TyTrait { def_id, substs: ref substs, bounds }, _) => {\n             mk_trait(cx, def_id, substs.clone(), bounds)\n         }\n     }\n@@ -3511,10 +3513,10 @@ impl AutoRef {\n }\n \n pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n-                                            origin: typeck::MethodOrigin)\n+                                            origin: &typeck::MethodOrigin)\n                                             -> VecPerParamSpace<TypeParameterDef>\n                                             where T: mc::Typer<'tcx> {\n-    match origin {\n+    match *origin {\n         typeck::MethodStatic(did) => {\n             ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n         }\n@@ -3529,16 +3531,16 @@ pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n             lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n         }\n         typeck::MethodParam(typeck::MethodParam{\n-            trait_id: trt_id,\n+            trait_ref: ref trait_ref,\n             method_num: n_mth,\n             ..\n         }) |\n         typeck::MethodObject(typeck::MethodObject{\n-                trait_id: trt_id,\n+                trait_ref: ref trait_ref,\n                 method_num: n_mth,\n                 ..\n         }) => {\n-            match ty::trait_item(typer.tcx(), trt_id, n_mth) {\n+            match ty::trait_item(typer.tcx(), trait_ref.def_id, n_mth) {\n                 ty::MethodTraitItem(method) => method.generics.types.clone(),\n             }\n         }\n@@ -4407,14 +4409,6 @@ pub fn lookup_item_type(cx: &ctxt,\n         || csearch::get_type(cx, did))\n }\n \n-pub fn lookup_impl_vtables(cx: &ctxt,\n-                           did: ast::DefId)\n-                           -> typeck::vtable_res {\n-    lookup_locally_or_in_crate_store(\n-        \"impl_vtables\", did, &mut *cx.impl_vtables.borrow_mut(),\n-        || csearch::get_impl_vtables(cx, did) )\n-}\n-\n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n@@ -4958,6 +4952,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n+    let mut inherent_impls = Vec::new();\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n@@ -4989,18 +4984,11 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n-            match tcx.inherent_impls.borrow().find(&type_id) {\n-                Some(implementation_list) => {\n-                    implementation_list.borrow_mut().push(impl_def_id);\n-                    return;\n-                }\n-                None => {}\n-            }\n-            tcx.inherent_impls.borrow_mut().insert(type_id,\n-                                                   Rc::new(RefCell::new(vec!(impl_def_id))));\n+            inherent_impls.push(impl_def_id);\n         }\n     });\n \n+    tcx.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n     tcx.populated_external_types.borrow_mut().insert(type_id);\n }\n \n@@ -5232,7 +5220,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                     }\n                 }\n             }\n-            ty_trait(box ty::TyTrait { def_id: d, bounds, .. }) => {\n+            ty_trait(box TyTrait { def_id: d, bounds, .. }) => {\n                 byte!(17);\n                 did(&mut state, d);\n                 hash!(bounds);\n@@ -5430,6 +5418,26 @@ impl BorrowKind {\n         }\n     }\n \n+    pub fn to_mutbl_lossy(self) -> ast::Mutability {\n+        /*!\n+         * Returns a mutability `m` such that an `&m T` pointer could\n+         * be used to obtain this borrow kind. Because borrow kinds\n+         * are richer than mutabilities, we sometimes have to pick a\n+         * mutability that is stornger than necessary so that it at\n+         * least *would permit* the borrow in question.\n+         */\n+\n+        match self {\n+            MutBorrow => ast::MutMutable,\n+            ImmBorrow => ast::MutImmutable,\n+\n+            // We have no type correponding to a unique imm borrow, so\n+            // use `&mut`. It gives all the capabilities of an `&uniq`\n+            // and hence is a safe \"over approximation\".\n+            UniqueImmBorrow => ast::MutMutable,\n+        }\n+    }\n+\n     pub fn to_user_str(&self) -> &'static str {\n         match *self {\n             MutBorrow => \"mutable\","}, {"sha": "549f0daef81121c838cff4accc38634c95fc0350", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -680,3 +680,28 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region eraser\n+//\n+// Replaces all free regions with 'static. Useful in trans.\n+\n+pub struct RegionEraser<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+pub fn erase_regions<T:TypeFoldable>(tcx: &ty::ctxt, t: T) -> T {\n+    let mut eraser = RegionEraser { tcx: tcx };\n+    t.fold_with(&mut eraser)\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n+            _ => ty::ReStatic\n+        }\n+    }\n+}"}, {"sha": "c66d10138d8bbeddc6fc46896661cfeb9a90dbb8", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -370,7 +370,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n-                    match self.unsize_ty(sty_a, t_b) {\n+                    match self.unsize_ty(t_a, sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n@@ -393,6 +393,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // performed to unsize it.\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n+                 ty_a: ty::t,\n                  sty_a: &ty::sty,\n                  ty_b: ty::t)\n                  -> Option<(ty::t, ty::UnsizeKind)> {\n@@ -412,9 +413,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                           def_id,\n                                           substs.clone(),\n                                           bounds);\n-                    Some((ty, ty::UnsizeVtable(bounds,\n-                                               def_id,\n-                                               substs.clone())))\n+                    Some((ty, ty::UnsizeVtable(ty::TyTrait { def_id: def_id,\n+                                                             bounds: bounds,\n+                                                             substs: substs.clone() },\n+                                               ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n                   if did_a == did_b => {\n@@ -432,7 +434,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n-                        match self.unpack_actual_value(*tp_a, |tp| self.unsize_ty(tp, *tp_b)) {\n+                        match\n+                            self.unpack_actual_value(\n+                                *tp_a,\n+                                |tp| self.unsize_ty(*tp_a, tp, *tp_b))\n+                        {\n                             Some((new_tp, k)) => {\n                                 // Check that the whole types match.\n                                 let mut new_substs = substs_a.clone();\n@@ -471,14 +477,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n-               b.repr(tcx));\n+               b.repr(tcx), b_mutbl);\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        self.coerce_object(a, sty_a, b,\n+        self.coerce_object(a, sty_a, b, b_mutbl,\n                            |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n@@ -491,11 +497,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n-        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={}, b_mutbl={})\",\n                a.repr(tcx), sty_a,\n-               b.repr(tcx));\n+               b.repr(tcx), b_mutbl);\n \n-        self.coerce_object(a, sty_a, b,\n+        self.coerce_object(a, sty_a, b, b_mutbl,\n                            |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoUnsafe(b_mutbl, None))\n     }"}, {"sha": "4412b7d94d4687b4a33b939a5ecd038217f32bc4", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -34,7 +34,7 @@\n \n \n use middle::subst;\n-use middle::subst::Substs;\n+use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n@@ -113,29 +113,40 @@ pub trait Combine<'tcx> {\n             let a_tps = a_subst.types.get_slice(space);\n             let b_tps = b_subst.types.get_slice(space);\n             let tps = try!(self.tps(space, a_tps, b_tps));\n+            substs.types.replace(space, tps);\n+        }\n \n-            let a_regions = a_subst.regions().get_slice(space);\n-            let b_regions = b_subst.regions().get_slice(space);\n-\n-            let mut invariance = Vec::new();\n-            let r_variances = match variances {\n-                Some(ref variances) => variances.regions.get_slice(space),\n-                None => {\n-                    for _ in a_regions.iter() {\n-                        invariance.push(ty::Invariant);\n-                    }\n-                    invariance.as_slice()\n-                }\n-            };\n+        match (&a_subst.regions, &b_subst.regions) {\n+            (&ErasedRegions, _) | (_, &ErasedRegions) => {\n+                substs.regions = ErasedRegions;\n+            }\n \n-            let regions = try!(relate_region_params(self,\n-                                                    item_def_id,\n-                                                    r_variances,\n-                                                    a_regions,\n-                                                    b_regions));\n+            (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n+                for &space in subst::ParamSpace::all().iter() {\n+                    let a_regions = a.get_slice(space);\n+                    let b_regions = b.get_slice(space);\n \n-            substs.types.replace(space, tps);\n-            substs.mut_regions().replace(space, regions);\n+                    let mut invariance = Vec::new();\n+                    let r_variances = match variances {\n+                        Some(ref variances) => {\n+                            variances.regions.get_slice(space)\n+                        }\n+                        None => {\n+                            for _ in a_regions.iter() {\n+                                invariance.push(ty::Invariant);\n+                            }\n+                            invariance.as_slice()\n+                        }\n+                    };\n+\n+                    let regions = try!(relate_region_params(self,\n+                                                            item_def_id,\n+                                                            r_variances,\n+                                                            a_regions,\n+                                                            b_regions));\n+                    substs.mut_regions().replace(space, regions);\n+                }\n+            }\n         }\n \n         return Ok(substs);"}, {"sha": "7a913699280bce8b42de68cebe16d231ce76e806", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088c94ae96aa139db6b6f0c5640c720ff107ee0f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=088c94ae96aa139db6b6f0c5640c720ff107ee0f", "patch": "@@ -71,9 +71,10 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n+use util::nodemap::{NodeMap, FnvHashMap};\n \n use std::cell::RefCell;\n+use std::rc::Rc;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -92,7 +93,7 @@ pub struct param_index {\n     pub index: uint\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub enum MethodOrigin {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -110,27 +111,21 @@ pub enum MethodOrigin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub struct MethodParam {\n-    // the trait containing the method to be invoked\n-    pub trait_id: ast::DefId,\n+    // the precise trait reference that occurs as a bound -- this may\n+    // be a supertrait of what the user actually typed.\n+    pub trait_ref: Rc<ty::TraitRef>,\n \n-    // index of the method to be invoked amongst the trait's methods\n+    // index of uint in the list of methods for the trait\n     pub method_num: uint,\n-\n-    // index of the type parameter (from those that are in scope) that is\n-    // the type of the receiver\n-    pub param_num: param_index,\n-\n-    // index of the bound for this type parameter which specifies the trait\n-    pub bound_num: uint,\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone)]\n pub struct MethodObject {\n     // the (super)trait containing the method to be invoked\n-    pub trait_id: ast::DefId,\n+    pub trait_ref: Rc<ty::TraitRef>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -154,7 +149,7 @@ pub struct MethodCallee {\n \n /**\n  * With method calls, we store some extra information in\n- * side tables (i.e method_map, vtable_map). We use\n+ * side tables (i.e method_map). We use\n  * MethodCall as a key to index into these tables instead of\n  * just directly using the expression's NodeId. The reason\n  * for this being that we may apply adjustments (coercions)\n@@ -276,10 +271,9 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n-\n-\n-pub type impl_vtable_map = RefCell<DefIdMap<vtable_res>>;\n+// For every explicit cast into an object type, maps from the cast\n+// expr to the associated trait ref.\n+pub type ObjectCastMap = RefCell<NodeMap<Rc<ty::TraitRef>>>;\n \n pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method."}]}