{"sha": "ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYWViNjY3YjMyN2NmZjdhZDI4NjI1NWQ2OGNiNWE4YmE4YTRkN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-11T22:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-11T22:36:59Z"}, "message": "auto merge of #14703 : alexcrichton/rust/no-more-owned-vectors, r=brson\n\nThe following features have been removed\r\n\r\n* `box [a, b, c]`\r\n* `~[a, b, c]`\r\n* `box [a, ..N]`\r\n* `~[a, ..N]`\r\n* `~[T]` (as a type)\r\n* deprecated_owned_vector lint\r\n\r\nAll users of ~[T] should move to using Vec<T> instead.", "tree": {"sha": "c94cde854a882cad33d8ec7fe0067b43b5cb96d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c94cde854a882cad33d8ec7fe0067b43b5cb96d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "html_url": "https://github.com/rust-lang/rust/commit/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9260d41d6e37653bf71b08a041be0310098716a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9260d41d6e37653bf71b08a041be0310098716a", "html_url": "https://github.com/rust-lang/rust/commit/f9260d41d6e37653bf71b08a041be0310098716a"}, {"sha": "3316b1eb7c3eb520896af489dd45c4d17190d0a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3316b1eb7c3eb520896af489dd45c4d17190d0a8", "html_url": "https://github.com/rust-lang/rust/commit/3316b1eb7c3eb520896af489dd45c4d17190d0a8"}], "stats": {"total": 1178, "additions": 355, "deletions": 823}, "files": [{"sha": "b03486a6c224c5ccd4cf580f5f686e0adb21e684", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -155,24 +155,6 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uin\n     alloc as *mut u8\n }\n \n-// hack for libcore\n-#[no_mangle]\n-#[doc(hidden)]\n-#[deprecated]\n-#[cfg(not(test))]\n-pub unsafe extern \"C\" fn rust_allocate(size: uint, align: uint) -> *mut u8 {\n-    allocate(size, align)\n-}\n-\n-// hack for libcore\n-#[no_mangle]\n-#[doc(hidden)]\n-#[deprecated]\n-#[cfg(not(test))]\n-pub unsafe extern \"C\" fn rust_deallocate(ptr: *mut u8, size: uint, align: uint) {\n-    deallocate(ptr, size, align)\n-}\n-\n #[cfg(test)]\n mod bench {\n     extern crate test;\n@@ -184,11 +166,4 @@ mod bench {\n             box 10\n         })\n     }\n-\n-    #[bench]\n-    fn alloc_owned_big(b: &mut Bencher) {\n-        b.iter(|| {\n-            box [10, ..1000]\n-        })\n-    }\n }"}, {"sha": "bd7bab456ba012cb962336c9498d895459d7ccf9", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -213,13 +213,6 @@ impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a mut [T] {\n     }\n }\n \n-impl<S: Writer, T: Hash<S>> Hash<S> for ~[T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n impl<S: Writer, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "887b0fb0b8abe22b51facc05e4721fc023c24d66", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -276,6 +276,7 @@ mod tests {\n     use str::Str;\n     use string::String;\n     use slice::{Vector, ImmutableVector};\n+    use vec::Vec;\n \n     use super::super::{Hash, Writer};\n     use super::{SipState, hash, hash_with_keys};\n@@ -376,8 +377,8 @@ mod tests {\n             s\n         }\n \n-        fn result_bytes(h: u64) -> ~[u8] {\n-            box [(h >> 0) as u8,\n+        fn result_bytes(h: u64) -> Vec<u8> {\n+            vec![(h >> 0) as u8,\n               (h >> 8) as u8,\n               (h >> 16) as u8,\n               (h >> 24) as u8,"}, {"sha": "865da9eff136a1a6527965bb427ae0dcf104b04a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 83, "deletions": 236, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -101,11 +101,8 @@ There are a number of free functions that create or take vectors, for example:\n \n use core::prelude::*;\n \n-use alloc::heap::{allocate, deallocate};\n use core::cmp;\n-use core::finally::try_finally;\n use core::mem::size_of;\n-use core::mem::transmute;\n use core::mem;\n use core::ptr;\n use core::iter::{range_step, MultiplicativeIterator};\n@@ -255,18 +252,18 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n /// Generates even and odd permutations alternately.\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n-    v: ~[T],\n+    v: Vec<T>,\n }\n \n-impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n+impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     #[inline]\n-    fn next(&mut self) -> Option<~[T]> {\n+    fn next(&mut self) -> Option<Vec<T>> {\n         match self.swaps.next() {\n             None => None,\n             Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n-                self.v.swap(a, b);\n+                self.v.as_mut_slice().swap(a, b);\n                 Some(elt)\n             }\n         }\n@@ -281,73 +278,20 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n /// Extension methods for vector slices with cloneable elements\n pub trait CloneableVector<T> {\n     /// Copy `self` into a new owned vector\n-    fn to_owned(&self) -> ~[T];\n+    fn to_owned(&self) -> Vec<T>;\n \n     /// Convert `self` into an owned vector, not making a copy if possible.\n-    fn into_owned(self) -> ~[T];\n+    fn into_owned(self) -> Vec<T>;\n }\n \n /// Extension methods for vector slices\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_owned(&self) -> ~[T] {\n-        use RawVec = core::raw::Vec;\n-        use core::num::{CheckedAdd, CheckedMul};\n-        use core::ptr;\n-\n-        let len = self.len();\n-        let data_size = len.checked_mul(&mem::size_of::<T>());\n-        let data_size = data_size.expect(\"overflow in to_owned()\");\n-        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in to_owned()\");\n-\n-        unsafe {\n-            // this should pass the real required alignment\n-            let ret = allocate(size, 8) as *mut RawVec<()>;\n-\n-            let a_size = mem::size_of::<T>();\n-            let a_size = if a_size == 0 {1} else {a_size};\n-            (*ret).fill = len * a_size;\n-            (*ret).alloc = len * a_size;\n-\n-            // Be careful with the following loop. We want it to be optimized\n-            // to a memcpy (or something similarly fast) when T is Copy. LLVM\n-            // is easily confused, so any extra operations during the loop can\n-            // prevent this optimization.\n-            let mut i = 0;\n-            let p = &mut (*ret).data as *mut _ as *mut T;\n-            try_finally(\n-                &mut i, (),\n-                |i, ()| while *i < len {\n-                    ptr::write(\n-                        &mut(*p.offset(*i as int)),\n-                        self.unsafe_ref(*i).clone());\n-                    *i += 1;\n-                },\n-                |i| if *i < len {\n-                    // we must be failing, clean up after ourselves\n-                    for j in range(0, *i as int) {\n-                        ptr::read(&*p.offset(j));\n-                    }\n-                    // FIXME: #13994 (should pass align and size here)\n-                    deallocate(ret as *mut u8, 0, 8);\n-                });\n-            mem::transmute(ret)\n-        }\n-    }\n+    fn to_owned(&self) -> Vec<T> { Vec::from_slice(*self) }\n \n     #[inline(always)]\n-    fn into_owned(self) -> ~[T] { self.to_owned() }\n-}\n-\n-/// Extension methods for owned vectors\n-impl<T: Clone> CloneableVector<T> for ~[T] {\n-    #[inline]\n-    fn to_owned(&self) -> ~[T] { self.clone() }\n-\n-    #[inline(always)]\n-    fn into_owned(self) -> ~[T] { self }\n+    fn into_owned(self) -> Vec<T> { self.to_owned() }\n }\n \n /// Extension methods for vectors containing `Clone` elements.\n@@ -387,57 +331,6 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n \n }\n \n-/// Extension methods for owned vectors.\n-pub trait OwnedVector<T> {\n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = ~[\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.move_iter() {\n-    ///   // s has type ~str, not &~str\n-    ///   println!(\"{}\", s);\n-    /// }\n-    /// ```\n-    fn move_iter(self) -> MoveItems<T>;\n-\n-    /**\n-     * Partitions the vector into two vectors `(A,B)`, where all\n-     * elements of `A` satisfy `f` and all elements of `B` do not.\n-     */\n-    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n-}\n-\n-impl<T> OwnedVector<T> for ~[T] {\n-    #[inline]\n-    fn move_iter(self) -> MoveItems<T> {\n-        unsafe {\n-            let iter = transmute(self.iter());\n-            let ptr = transmute(self);\n-            MoveItems { allocation: ptr, iter: iter }\n-        }\n-    }\n-\n-    #[inline]\n-    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.move_iter() {\n-            if f(&elt) {\n-                lefts.push(elt);\n-            } else {\n-                rights.push(elt);\n-            }\n-        }\n-\n-        (lefts, rights)\n-    }\n-}\n-\n fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     let len = v.len() as int;\n     let buf_v = v.as_mut_ptr();\n@@ -676,7 +569,7 @@ pub trait MutableVectorAllocating<'a, T> {\n      * * start - The index into `src` to start copying from\n      * * end - The index into `str` to stop copying from\n      */\n-    fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n+    fn move_from(self, src: Vec<T>, start: uint, end: uint) -> uint;\n }\n \n impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n@@ -686,7 +579,7 @@ impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn move_from(self, mut src: ~[T], start: uint, end: uint) -> uint {\n+    fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n         for (a, b) in self.mut_iter().zip(src.mut_slice(start, end).mut_iter()) {\n             mem::swap(a, b);\n         }\n@@ -815,47 +708,6 @@ pub mod raw {\n     pub use core::slice::raw::{shift_ptr, pop_ptr};\n }\n \n-/// An iterator that moves out of a vector.\n-pub struct MoveItems<T> {\n-    allocation: *mut u8, // the block of memory allocated for the vector\n-    iter: Items<'static, T>\n-}\n-\n-impl<T> Iterator<T> for MoveItems<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            self.iter.next().map(|x| ptr::read(x))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        unsafe {\n-            self.iter.next_back().map(|x| ptr::read(x))\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for MoveItems<T> {\n-    fn drop(&mut self) {\n-        // destroy the remaining elements\n-        for _x in *self {}\n-        unsafe {\n-            // FIXME: #13994 (should pass align and size here)\n-            deallocate(self.allocation, 0, 8)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::cell::Cell;\n@@ -944,92 +796,92 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut a = box [11];\n-        assert_eq!(a.get(1), None);\n-        a = box [11, 12];\n-        assert_eq!(a.get(1).unwrap(), &12);\n-        a = box [11, 12, 13];\n-        assert_eq!(a.get(1).unwrap(), &12);\n+        let mut a = vec![11];\n+        assert_eq!(a.as_slice().get(1), None);\n+        a = vec![11, 12];\n+        assert_eq!(a.as_slice().get(1).unwrap(), &12);\n+        a = vec![11, 12, 13];\n+        assert_eq!(a.as_slice().get(1).unwrap(), &12);\n     }\n \n     #[test]\n     fn test_head() {\n-        let mut a = box [];\n-        assert_eq!(a.head(), None);\n-        a = box [11];\n-        assert_eq!(a.head().unwrap(), &11);\n-        a = box [11, 12];\n-        assert_eq!(a.head().unwrap(), &11);\n+        let mut a = vec![];\n+        assert_eq!(a.as_slice().head(), None);\n+        a = vec![11];\n+        assert_eq!(a.as_slice().head().unwrap(), &11);\n+        a = vec![11, 12];\n+        assert_eq!(a.as_slice().head().unwrap(), &11);\n     }\n \n     #[test]\n     fn test_tail() {\n-        let mut a = box [11];\n+        let mut a = vec![11];\n         assert_eq!(a.tail(), &[]);\n-        a = box [11, 12];\n+        a = vec![11, 12];\n         assert_eq!(a.tail(), &[12]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_empty() {\n-        let a: ~[int] = box [];\n+        let a: Vec<int> = vec![];\n         a.tail();\n     }\n \n     #[test]\n     fn test_tailn() {\n-        let mut a = box [11, 12, 13];\n+        let mut a = vec![11, 12, 13];\n         assert_eq!(a.tailn(0), &[11, 12, 13]);\n-        a = box [11, 12, 13];\n+        a = vec![11, 12, 13];\n         assert_eq!(a.tailn(2), &[13]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tailn_empty() {\n-        let a: ~[int] = box [];\n+        let a: Vec<int> = vec![];\n         a.tailn(2);\n     }\n \n     #[test]\n     fn test_init() {\n-        let mut a = box [11];\n+        let mut a = vec![11];\n         assert_eq!(a.init(), &[]);\n-        a = box [11, 12];\n+        a = vec![11, 12];\n         assert_eq!(a.init(), &[11]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_empty() {\n-        let a: ~[int] = box [];\n+        let a: Vec<int> = vec![];\n         a.init();\n     }\n \n     #[test]\n     fn test_initn() {\n-        let mut a = box [11, 12, 13];\n-        assert_eq!(a.initn(0), &[11, 12, 13]);\n-        a = box [11, 12, 13];\n-        assert_eq!(a.initn(2), &[11]);\n+        let mut a = vec![11, 12, 13];\n+        assert_eq!(a.as_slice().initn(0), &[11, 12, 13]);\n+        a = vec![11, 12, 13];\n+        assert_eq!(a.as_slice().initn(2), &[11]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_initn_empty() {\n-        let a: ~[int] = box [];\n-        a.initn(2);\n+        let a: Vec<int> = vec![];\n+        a.as_slice().initn(2);\n     }\n \n     #[test]\n     fn test_last() {\n-        let mut a = box [];\n-        assert_eq!(a.last(), None);\n-        a = box [11];\n-        assert_eq!(a.last().unwrap(), &11);\n-        a = box [11, 12];\n-        assert_eq!(a.last().unwrap(), &12);\n+        let mut a = vec![];\n+        assert_eq!(a.as_slice().last(), None);\n+        a = vec![11];\n+        assert_eq!(a.as_slice().last().unwrap(), &11);\n+        a = vec![11, 12];\n+        assert_eq!(a.as_slice().last().unwrap(), &12);\n     }\n \n     #[test]\n@@ -1038,6 +890,7 @@ mod tests {\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_owned();\n         assert_eq!(v_a.len(), 3u);\n+        let v_a = v_a.as_slice();\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n@@ -1046,13 +899,15 @@ mod tests {\n         let vec_stack = &[1, 2, 3];\n         let v_b = vec_stack.slice(1u, 3u).to_owned();\n         assert_eq!(v_b.len(), 2u);\n+        let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n-        let vec_unique = box [1, 2, 3, 4, 5, 6];\n+        let vec_unique = vec![1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n+        let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);\n         assert_eq!(v_d[2], 4);\n@@ -1295,15 +1150,15 @@ mod tests {\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3*2);\n             assert_eq!(max_opt.unwrap(), 3*2);\n-            assert_eq!(it.next(), Some(box [1,2,3]));\n-            assert_eq!(it.next(), Some(box [1,3,2]));\n-            assert_eq!(it.next(), Some(box [3,1,2]));\n+            assert_eq!(it.next(), Some(vec![1,2,3]));\n+            assert_eq!(it.next(), Some(vec![1,3,2]));\n+            assert_eq!(it.next(), Some(vec![3,1,2]));\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3);\n             assert_eq!(max_opt.unwrap(), 3);\n-            assert_eq!(it.next(), Some(box [3,2,1]));\n-            assert_eq!(it.next(), Some(box [2,3,1]));\n-            assert_eq!(it.next(), Some(box [2,1,3]));\n+            assert_eq!(it.next(), Some(vec![3,2,1]));\n+            assert_eq!(it.next(), Some(vec![2,3,1]));\n+            assert_eq!(it.next(), Some(vec![2,1,3]));\n             assert_eq!(it.next(), None);\n         }\n         {\n@@ -1378,11 +1233,11 @@ mod tests {\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());\n \n-        let v1 = box [1, 2, 3, 3, 2, 5];\n-        assert_eq!(v1.position_elem(&1), Some(0u));\n-        assert_eq!(v1.position_elem(&2), Some(1u));\n-        assert_eq!(v1.position_elem(&5), Some(5u));\n-        assert!(v1.position_elem(&4).is_none());\n+        let v1 = vec![1, 2, 3, 3, 2, 5];\n+        assert_eq!(v1.as_slice().position_elem(&1), Some(0u));\n+        assert_eq!(v1.as_slice().position_elem(&2), Some(1u));\n+        assert_eq!(v1.as_slice().position_elem(&5), Some(5u));\n+        assert!(v1.as_slice().position_elem(&4).is_none());\n     }\n \n     #[test]\n@@ -1432,14 +1287,14 @@ mod tests {\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: ~[int] = box [10, 20];\n-        assert_eq!(v[0], 10);\n-        assert_eq!(v[1], 20);\n+        let mut v: Vec<int> = vec![10, 20];\n+        assert_eq!(*v.get(0), 10);\n+        assert_eq!(*v.get(1), 20);\n         v.reverse();\n-        assert_eq!(v[0], 20);\n-        assert_eq!(v[1], 10);\n+        assert_eq!(*v.get(0), 20);\n+        assert_eq!(*v.get(1), 10);\n \n-        let mut v3: ~[int] = box [];\n+        let mut v3: Vec<int> = vec![];\n         v3.reverse();\n         assert!(v3.is_empty());\n     }\n@@ -1505,10 +1360,10 @@ mod tests {\n \n     #[test]\n     fn test_partition() {\n-        assert_eq!((box []).partition(|x: &int| *x < 3), (vec![], vec![]));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+        assert_eq!((vec![]).partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!((vec![1, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n     }\n \n     #[test]\n@@ -1521,19 +1376,19 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        let v: [~[int], ..0] = [];\n+        let v: [Vec<int>, ..0] = [];\n         assert_eq!(v.concat_vec(), vec![]);\n-        assert_eq!([box [1], box [2,3]].concat_vec(), vec![1, 2, 3]);\n+        assert_eq!([vec![1], vec![2,3]].concat_vec(), vec![1, 2, 3]);\n \n         assert_eq!([&[1], &[2,3]].concat_vec(), vec![1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        let v: [~[int], ..0] = [];\n+        let v: [Vec<int>, ..0] = [];\n         assert_eq!(v.connect_vec(&0), vec![]);\n-        assert_eq!([box [1], box [2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([box [1], box [2], box [3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!([vec![1], vec![2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1], vec![2], vec![3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n         assert_eq!([&[1], &[2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n         assert_eq!([&[1], &[2], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n@@ -1808,13 +1663,13 @@ mod tests {\n \n     #[test]\n     fn test_move_iterator() {\n-        let xs = box [1u,2,3,4,5];\n+        let xs = vec![1u,2,3,4,5];\n         assert_eq!(xs.move_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n-        let xs = box [1u,2,3,4,5];\n+        let xs = vec![1u,2,3,4,5];\n         assert_eq!(xs.move_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n@@ -1927,19 +1782,19 @@ mod tests {\n     #[test]\n     fn test_move_from() {\n         let mut a = [1,2,3,4,5];\n-        let b = box [6,7,8];\n+        let b = vec![6,7,8];\n         assert_eq!(a.move_from(b, 0, 3), 3);\n         assert!(a == [6,7,8,4,5]);\n         let mut a = [7,2,8,1];\n-        let b = box [3,1,4,1,5,9];\n+        let b = vec![3,1,4,1,5,9];\n         assert_eq!(a.move_from(b, 0, 6), 4);\n         assert!(a == [3,1,4,1]);\n         let mut a = [1,2,3,4];\n-        let b = box [5,6,7,8,9,0];\n+        let b = vec![5,6,7,8,9,0];\n         assert_eq!(a.move_from(b, 2, 3), 1);\n         assert!(a == [7,2,3,4]);\n         let mut a = [1,2,3,4,5];\n-        let b = box [5,6,7,8,9,0];\n+        let b = vec![5,6,7,8,9,0];\n         assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n         assert!(a == [1,2,6,7,5]);\n     }\n@@ -1972,11 +1827,11 @@ mod tests {\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n         )\n-        let empty: ~[int] = box [];\n+        let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\".to_string());\n-        test_show_vec!(box [1], \"[1]\".to_string());\n-        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_string());\n-        test_show_vec!(box [box [], box [1u], box [1u, 1u]],\n+        test_show_vec!(vec![1], \"[1]\".to_string());\n+        test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\".to_string());\n+        test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n                        \"[[], [1], [1, 1]]\".to_string());\n \n         let empty_mut: &mut [int] = &mut[];\n@@ -1997,7 +1852,6 @@ mod tests {\n         );\n \n         t!(&[int]);\n-        t!(~[int]);\n         t!(Vec<int>);\n     }\n \n@@ -2392,13 +2246,6 @@ mod bench {\n         });\n     }\n \n-    #[bench]\n-    fn zero_1kb_fixed_repeat(b: &mut Bencher) {\n-        b.iter(|| {\n-            box [0u8, ..1024]\n-        });\n-    }\n-\n     #[bench]\n     fn zero_1kb_loop_set(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "83601be83dec0f194ae923a26edcd6aa54d968b0", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -707,7 +707,7 @@ pub mod raw {\n         use str::StrAllocating;\n \n         unsafe {\n-            let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let a = vec![65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n             assert_eq!(c, \"AAA\".to_string());\n@@ -1124,7 +1124,7 @@ mod tests {\n         assert!(half_a_million_letter_a() ==\n             unsafe {raw::slice_bytes(letters.as_slice(),\n                                      0u,\n-                                     500000)}.to_owned());\n+                                     500000)}.to_string());\n     }\n \n     #[test]\n@@ -1219,7 +1219,7 @@ mod tests {\n         assert_eq!(\"\", data.slice(3, 3));\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n-        fn a_million_letter_X() -> String {\n+        fn a_million_letter_x() -> String {\n             let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n@@ -1228,7 +1228,7 @@ mod tests {\n             }\n             rs\n         }\n-        fn half_a_million_letter_X() -> String {\n+        fn half_a_million_letter_x() -> String {\n             let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n@@ -1237,9 +1237,9 @@ mod tests {\n             }\n             rs\n         }\n-        let letters = a_million_letter_X();\n-        assert!(half_a_million_letter_X() ==\n-            letters.as_slice().slice(0u, 3u * 500000u).to_owned());\n+        let letters = a_million_letter_x();\n+        assert!(half_a_million_letter_x() ==\n+            letters.as_slice().slice(0u, 3u * 500000u).to_string());\n     }\n \n     #[test]\n@@ -1464,7 +1464,7 @@ mod tests {\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n-            let a = box [65, 65, 65, 65, 65, 65, 65, 0];\n+            let a = vec![65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n             assert_eq!(c, \"AAAAAAA\".to_string());\n@@ -1682,7 +1682,7 @@ mod tests {\n     #[test]\n     fn test_char_at() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n@@ -1693,7 +1693,7 @@ mod tests {\n     #[test]\n     fn test_char_at_reverse() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n         for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n@@ -1756,7 +1756,7 @@ mod tests {\n     #[test]\n     fn test_iterator() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n         let mut it = s.chars();\n@@ -1771,7 +1771,7 @@ mod tests {\n     #[test]\n     fn test_rev_iterator() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = box ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+        let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n         let mut it = s.chars().rev();"}, {"sha": "acb7b2c27040fd384f0fe82d3d57d256f88ee39a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 13, "deletions": 77, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -13,7 +13,6 @@\n use core::prelude::*;\n \n use alloc::heap::{allocate, reallocate, deallocate};\n-use RawVec = core::raw::Vec;\n use core::raw::Slice;\n use core::cmp::max;\n use core::default::Default;\n@@ -25,7 +24,7 @@ use core::ptr;\n use core::uint;\n \n use {Collection, Mutable};\n-use slice::{MutableOrdVector, OwnedVector, MutableVectorAllocating};\n+use slice::{MutableOrdVector, MutableVectorAllocating, CloneableVector};\n use slice::{Items, MutItems};\n \n /// An owned, growable vector.\n@@ -387,6 +386,11 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n \n impl<T: Eq> Eq for Vec<T> {}\n \n+impl<T: PartialEq, V: Vector<T>> Equiv<V> for Vec<T> {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -401,6 +405,11 @@ impl<T> Collection for Vec<T> {\n     }\n }\n \n+impl<T: Clone> CloneableVector<T> for Vec<T> {\n+    fn to_owned(&self) -> Vec<T> { self.clone() }\n+    fn into_owned(self) -> Vec<T> { self }\n+}\n+\n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n unsafe fn alloc_or_realloc<T>(ptr: *mut T, size: uint, old_size: uint) -> *mut T {\n@@ -1511,52 +1520,6 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     (ts, us)\n }\n \n-/// Mechanism to convert from a `Vec<T>` to a `[T]`.\n-///\n-/// In a post-DST world this will be used to convert to any `Ptr<[T]>`.\n-///\n-/// This could be implemented on more types than just pointers to vectors, but\n-/// the recommended approach for those types is to implement `FromIterator`.\n-// FIXME(#12938): Update doc comment when DST lands\n-pub trait FromVec<T> {\n-    /// Convert a `Vec<T>` into the receiver type.\n-    fn from_vec(v: Vec<T>) -> Self;\n-}\n-\n-impl<T> FromVec<T> for ~[T] {\n-    fn from_vec(mut v: Vec<T>) -> ~[T] {\n-        let len = v.len();\n-        let data_size = len.checked_mul(&mem::size_of::<T>());\n-        let data_size = data_size.expect(\"overflow in from_vec()\");\n-        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in from_vec()\");\n-\n-        // In a post-DST world, we can attempt to reuse the Vec allocation by calling\n-        // shrink_to_fit() on it. That may involve a reallocation+memcpy, but that's no\n-        // different than what we're doing manually here.\n-\n-        let vp = v.as_mut_ptr();\n-\n-        unsafe {\n-            let ret = allocate(size, 8) as *mut RawVec<()>;\n-\n-            let a_size = mem::size_of::<T>();\n-            let a_size = if a_size == 0 {1} else {a_size};\n-            (*ret).fill = len * a_size;\n-            (*ret).alloc = len * a_size;\n-\n-            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n-                                            vp as *u8, data_size);\n-\n-            // we've transferred ownership of the contents from v, but we can't drop it\n-            // as it still needs to free its own allocation.\n-            v.set_len(0);\n-\n-            mem::transmute(ret)\n-        }\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use super::Vec;\n@@ -1580,8 +1543,7 @@ pub mod raw {\n mod tests {\n     use std::prelude::*;\n     use std::mem::size_of;\n-    use std::kinds::marker;\n-    use super::{unzip, raw, FromVec, Vec};\n+    use super::{unzip, raw, Vec};\n \n     #[test]\n     fn test_small_vec_struct() {\n@@ -1830,39 +1792,13 @@ mod tests {\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n-            let c = box [1, 2, 3, 4, 5];\n+            let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n             let d = raw::from_buf(ptr, 5u);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n         }\n     }\n \n-    #[test]\n-    fn test_from_vec() {\n-        let a = vec![1u, 2, 3];\n-        let b: ~[uint] = FromVec::from_vec(a);\n-        assert_eq!(b.as_slice(), &[1u, 2, 3]);\n-\n-        let a = vec![];\n-        let b: ~[u8] = FromVec::from_vec(a);\n-        assert_eq!(b.as_slice(), &[]);\n-\n-        let a = vec![\"one\".to_string(), \"two\".to_string()];\n-        let b: ~[String] = FromVec::from_vec(a);\n-        assert_eq!(b.as_slice(), &[\"one\".to_string(), \"two\".to_string()]);\n-\n-        struct Foo {\n-            x: uint,\n-            nocopy: marker::NoCopy\n-        }\n-\n-        let a = vec![Foo{x: 42, nocopy: marker::NoCopy}, Foo{x: 84, nocopy: marker::NoCopy}];\n-        let b: ~[Foo] = FromVec::from_vec(a);\n-        assert_eq!(b.len(), 2);\n-        assert_eq!(b[0].x, 42);\n-        assert_eq!(b[1].x, 84);\n-    }\n-\n     #[test]\n     fn test_vec_truncate_drop() {\n         static mut drops: uint = 0;"}, {"sha": "e6c462c62d2979fd98757d508783b70da07f3e60", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -159,7 +159,7 @@ mod test {\n \n         fn test_fn_a() -> f64 { 1.0 }\n         fn test_fn_b<T: Empty>(x: T) -> T { x }\n-        fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}\n+        fn test_fn_c(_: int, _: f64, _: int, _: int, _: int) {}\n \n         let _ = test_fn_a.clone();\n         let _ = test_fn_b::<int>.clone();"}, {"sha": "763ca843c11e97035262e4e3a9b5568a5ad9a2f9", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -29,7 +29,7 @@\n #![allow(dead_code, missing_doc)]\n \n use fmt;\n-use intrinsics;\n+#[cfg(not(test))] use intrinsics;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]"}, {"sha": "2464dfc9b5e3270848a6bcb61e1aab558d8dc55a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -828,12 +828,6 @@ impl<'a, T: Show> Show for &'a mut [T] {\n     }\n }\n \n-impl<T: Show> Show for ~[T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_show(&self.as_slice(), f)\n-    }\n-}\n-\n impl Show for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")"}, {"sha": "d61416a68e0d0298b4d210314fd6f37790799a63", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -100,7 +100,9 @@ pub trait TyVisitor {\n \n     fn visit_char(&mut self) -> bool;\n \n+    #[cfg(stage0)]\n     fn visit_estr_box(&mut self) -> bool;\n+    #[cfg(stage0)]\n     fn visit_estr_uniq(&mut self) -> bool;\n     fn visit_estr_slice(&mut self) -> bool;\n     fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n@@ -110,7 +112,9 @@ pub trait TyVisitor {\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n \n+    #[cfg(stage0)]\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    #[cfg(stage0)]\n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,"}, {"sha": "bb11ec5502e83ce991a7b00aa874fe3f899c71ec", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -35,7 +35,7 @@ into a `loop`, for example, the `for` loop in this example is essentially\n translated to the `loop` below.\n \n ```rust\n-let values = ~[1, 2, 3];\n+let values = vec![1, 2, 3];\n \n // \"Syntactical sugar\" taking advantage of an iterator\n for &x in values.iter() {\n@@ -378,7 +378,7 @@ pub trait Iterator<A> {\n     ///     }\n     ///     sum\n     /// }\n-    /// let x = ~[1,2,3,7,8,9];\n+    /// let x = vec![1,2,3,7,8,9];\n     /// assert_eq!(process(x.move_iter()), 1006);\n     /// ```\n     #[inline]\n@@ -2425,7 +2425,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_peekable() {\n-        let xs = box [0u, 1, 2, 3, 4, 5];\n+        let xs = vec![0u, 1, 2, 3, 4, 5];\n         let mut it = xs.iter().map(|&x|x).peekable();\n         assert_eq!(it.peek().unwrap(), &0);\n         assert_eq!(it.next().unwrap(), 0);\n@@ -2809,7 +2809,7 @@ mod tests {\n     #[test]\n     fn test_double_ended_chain() {\n         let xs = [1, 2, 3, 4, 5];\n-        let ys = box [7, 9, 11];\n+        let ys = [7, 9, 11];\n         let mut it = xs.iter().chain(ys.iter()).rev();\n         assert_eq!(it.next().unwrap(), &11)\n         assert_eq!(it.next().unwrap(), &9)\n@@ -2826,7 +2826,7 @@ mod tests {\n     fn test_rposition() {\n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = box [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert_eq!(v.iter().rposition(f), Some(3u));\n         assert!(v.iter().rposition(g).is_none());\n@@ -2887,7 +2887,7 @@ mod tests {\n     #[test]\n     fn test_random_access_chain() {\n         let xs = [1, 2, 3, 4, 5];\n-        let ys = box [7, 9, 11];\n+        let ys = [7, 9, 11];\n         let mut it = xs.iter().chain(ys.iter());\n         assert_eq!(it.idx(0).unwrap(), &1);\n         assert_eq!(it.idx(5).unwrap(), &7);\n@@ -3131,7 +3131,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_MinMaxResult() {\n+    fn test_min_max_result() {\n         let r: MinMaxResult<int> = NoElements;\n         assert_eq!(r.into_option(), None)\n "}, {"sha": "5c7b588a9c9a529ae44083cefc5298f2249dba73", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -130,11 +130,6 @@ pub mod str;\n pub mod tuple;\n pub mod fmt;\n \n-// FIXME: this module should not exist. Once owned allocations are no longer a\n-//        language type, this module can move outside to the owned allocation\n-//        crate.\n-mod should_not_exist;\n-\n #[doc(hidden)]\n mod core {\n     pub use failure;"}, {"sha": "a71727c3f8ee2b87ee754d1d61927afd181a8419", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -660,7 +660,7 @@ mod tests {\n             }\n         }\n \n-        fn R(i: Rc<RefCell<int>>) -> R {\n+        fn r(i: Rc<RefCell<int>>) -> R {\n             R {\n                 i: i\n             }\n@@ -673,7 +673,7 @@ mod tests {\n \n         let i = Rc::new(RefCell::new(0));\n         {\n-            let x = R(realclone(&i));\n+            let x = r(realclone(&i));\n             let opt = Some(x);\n             let _y = opt.unwrap();\n         }"}, {"sha": "c37c66f9862174ffe3f4fd29289cbc4f93fe2906", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -503,7 +503,8 @@ impl<T> PartialOrd for *mut T {\n }\n \n #[cfg(test)]\n-pub mod ptr_tests {\n+#[allow(deprecated, experimental)]\n+pub mod test {\n     use super::*;\n     use prelude::*;\n \n@@ -512,6 +513,8 @@ pub mod ptr_tests {\n     use libc;\n     use realstd::str;\n     use realstd::str::Str;\n+    use realstd::vec::Vec;\n+    use realstd::collections::Collection;\n     use slice::{ImmutableVector, MutableVector};\n \n     #[test]\n@@ -534,20 +537,24 @@ pub mod ptr_tests {\n             assert_eq!(p.fst, 50);\n             assert_eq!(p.snd, 60);\n \n-            let v0 = box [32000u16, 32001u16, 32002u16];\n-            let mut v1 = box [0u16, 0u16, 0u16];\n+            let v0 = vec![32000u16, 32001u16, 32002u16];\n+            let mut v1 = vec![0u16, 0u16, 0u16];\n \n             copy_memory(v1.as_mut_ptr().offset(1),\n                         v0.as_ptr().offset(1), 1);\n-            assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n+            assert!((*v1.get(0) == 0u16 &&\n+                     *v1.get(1) == 32001u16 &&\n+                     *v1.get(2) == 0u16));\n             copy_memory(v1.as_mut_ptr(),\n                         v0.as_ptr().offset(2), 1);\n-            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                     v1[2] == 0u16));\n+            assert!((*v1.get(0) == 32002u16 &&\n+                     *v1.get(1) == 32001u16 &&\n+                     *v1.get(2) == 0u16));\n             copy_memory(v1.as_mut_ptr().offset(2),\n                         v0.as_ptr(), 1u);\n-            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                     v1[2] == 32000u16));\n+            assert!((*v1.get(0) == 32002u16 &&\n+                     *v1.get(1) == 32001u16 &&\n+                     *v1.get(2) == 32000u16));\n         }\n     }\n \n@@ -569,7 +576,7 @@ pub mod ptr_tests {\n         \"hello\".with_c_str(|p0| {\n             \"there\".with_c_str(|p1| {\n                 \"thing\".with_c_str(|p2| {\n-                    let v = box [p0, p1, p2, null()];\n+                    let v = vec![p0, p1, p2, null()];\n                     unsafe {\n                         assert_eq!(buf_len(v.as_ptr()), 3u);\n                     }\n@@ -617,7 +624,7 @@ pub mod ptr_tests {\n     #[test]\n     fn test_ptr_addition() {\n         unsafe {\n-            let xs = box [5, ..16];\n+            let xs = Vec::from_elem(16, 5);\n             let mut ptr = xs.as_ptr();\n             let end = ptr.offset(16);\n \n@@ -626,7 +633,7 @@ pub mod ptr_tests {\n                 ptr = ptr.offset(1);\n             }\n \n-            let mut xs_mut = xs.clone();\n+            let mut xs_mut = xs;\n             let mut m_ptr = xs_mut.as_mut_ptr();\n             let m_end = m_ptr.offset(16);\n \n@@ -635,14 +642,14 @@ pub mod ptr_tests {\n                 m_ptr = m_ptr.offset(1);\n             }\n \n-            assert_eq!(xs_mut, box [10, ..16]);\n+            assert!(xs_mut == Vec::from_elem(16, 10));\n         }\n     }\n \n     #[test]\n     fn test_ptr_subtraction() {\n         unsafe {\n-            let xs = box [0,1,2,3,4,5,6,7,8,9];\n+            let xs = vec![0,1,2,3,4,5,6,7,8,9];\n             let mut idx = 9i8;\n             let ptr = xs.as_ptr();\n \n@@ -651,7 +658,7 @@ pub mod ptr_tests {\n                 idx = idx - 1i8;\n             }\n \n-            let mut xs_mut = xs.clone();\n+            let mut xs_mut = xs;\n             let m_start = xs_mut.as_mut_ptr();\n             let mut m_ptr = m_start.offset(9);\n \n@@ -660,7 +667,7 @@ pub mod ptr_tests {\n                 m_ptr = m_ptr.offset(-1);\n             }\n \n-            assert_eq!(xs_mut, box [0,2,4,6,8,10,12,14,16,18]);\n+            assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n         }\n     }\n \n@@ -670,10 +677,10 @@ pub mod ptr_tests {\n             let one = \"oneOne\".to_c_str();\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n-            let arr = box [\n+            let arr = vec![\n                 one.with_ref(|buf| buf),\n                 two.with_ref(|buf| buf),\n-                three.with_ref(|buf| buf),\n+                three.with_ref(|buf| buf)\n             ];\n             let expected_arr = [\n                 one, two, three\n@@ -700,12 +707,12 @@ pub mod ptr_tests {\n             let one = \"oneOne\".to_c_str();\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n-            let arr = box [\n+            let arr = vec![\n                 one.with_ref(|buf| buf),\n                 two.with_ref(|buf| buf),\n                 three.with_ref(|buf| buf),\n                 // fake a null terminator\n-                null(),\n+                null()\n             ];\n             let expected_arr = [\n                 one, two, three"}, {"sha": "0a2a756c6b1c24739813d3dfdfb3d087617b6547", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -29,16 +29,6 @@ pub struct Box<T> {\n     pub data: T,\n }\n \n-/// The representation of a Rust vector\n-pub struct Vec<T> {\n-    pub fill: uint,\n-    pub alloc: uint,\n-    pub data: T,\n-}\n-\n-/// The representation of a Rust string\n-pub type String = Vec<u8>;\n-\n /// The representation of a Rust slice\n pub struct Slice<T> {\n     pub data: *T,\n@@ -79,7 +69,6 @@ pub trait Repr<T> {\n \n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n-impl<T> Repr<*Vec<T>> for ~[T] {}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "d579d04489240abed234aaa410fc6d8f2948bc4e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -266,38 +266,19 @@ pub mod traits {\n         }\n     }\n \n-    impl<T:PartialEq> PartialEq for ~[T] {\n-        #[inline]\n-        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n-        #[inline]\n-        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-    }\n-\n     impl<'a,T:Eq> Eq for &'a [T] {}\n \n-    impl<T:Eq> Eq for ~[T] {}\n-\n     impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'a,T:PartialEq, V: Vector<T>> Equiv<V> for ~[T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n     impl<'a,T:Ord> Ord for &'a [T] {\n         fn cmp(&self, other: & &'a [T]) -> Ordering {\n             order::cmp(self.iter(), other.iter())\n         }\n     }\n \n-    impl<T: Ord> Ord for ~[T] {\n-        #[inline]\n-        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n     impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n         fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n@@ -315,17 +296,6 @@ pub mod traits {\n             order::gt(self.iter(), other.iter())\n         }\n     }\n-\n-    impl<T: PartialOrd> PartialOrd for ~[T] {\n-        #[inline]\n-        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n-        #[inline]\n-        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n-        #[inline]\n-        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n-        #[inline]\n-        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n-    }\n }\n \n #[cfg(test)]\n@@ -342,11 +312,6 @@ impl<'a,T> Vector<T> for &'a [T] {\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n \n-impl<T> Vector<T> for ~[T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n-}\n-\n impl<'a, T> Collection for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n@@ -355,14 +320,6 @@ impl<'a, T> Collection for &'a [T] {\n     }\n }\n \n-impl<T> Collection for ~[T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.as_slice().len()\n-    }\n-}\n-\n /// Extension methods for vectors\n pub trait ImmutableVector<'a, T> {\n     /**\n@@ -927,7 +884,7 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = ~[\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n+    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n     ///\n     /// unsafe {\n     ///     // `\"baz\".to_string()` is deallocated.\n@@ -1455,7 +1412,3 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n impl<'a, T> Default for &'a [T] {\n     fn default() -> &'a [T] { &[] }\n }\n-\n-impl<T> Default for ~[T] {\n-    fn default() -> ~[T] { ~[] }\n-}"}, {"sha": "3a12aec39a18718c8537268e86b578afcb12fc59", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -192,15 +192,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_estr_box(&mut self) -> bool {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_estr_uniq(&mut self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n+        false\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n@@ -247,15 +246,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n+    #[cfg(stage0)]\n     fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n         true\n     }\n \n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n+    #[cfg(stage0)]\n+    fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n+        false\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {"}, {"sha": "86b71eb5b8d692610bd0b8048ac881ccd0040509", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -203,10 +203,6 @@ impl<'a> ReprVisitor<'a> {\n         true\n     }\n \n-    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n-        self.write_vec_range(&v.data, v.fill, inner)\n-    }\n-\n     fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n         try!(self, match ch {\n             '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n@@ -271,15 +267,14 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n+    #[cfg(stage0)]\n     fn visit_estr_box(&mut self) -> bool {\n-        true\n+        false\n     }\n \n+    #[cfg(stage0)]\n     fn visit_estr_uniq(&mut self) -> bool {\n-        self.get::<~str>(|this, s| {\n-            try!(this, this.writer.write(['~' as u8]));\n-            this.write_escaped_slice(*s)\n-        })\n+        false\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n@@ -323,19 +318,14 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            try!(this, this.writer.write(['@' as u8]));\n-            this.write_mut_qualifier(mtbl);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n-        })\n+    #[cfg(stage0)]\n+    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n+        true\n     }\n \n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Vec<()>>(|this, b| {\n-            try!(this, this.writer.write(\"box \".as_bytes()));\n-            this.write_unboxed_vec_repr(mtbl, *b, inner)\n-        })\n+    #[cfg(stage0)]\n+    fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n+        true\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {"}, {"sha": "955f697dce3bee0547853baa6f029a6853f4b205", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -26,7 +26,6 @@ Simple [DEFLATE][def]-based compression. This is a wrapper around the\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n #![feature(phase)]\n-#![deny(deprecated_owned_vector)]\n \n #[cfg(test, stage0)] #[phase(syntax, link)] extern crate log;\n #[cfg(test, not(stage0))] #[phase(plugin, link)] extern crate log;\n@@ -114,7 +113,6 @@ mod tests {\n     use std::rand::Rng;\n \n     #[test]\n-    #[allow(deprecated_owned_vector)]\n     fn test_flate_round_trip() {\n         let mut r = rand::task_rng();\n         let mut words = vec!();"}, {"sha": "3949bde3d52f7a6992575e5afc914ca31bf5bfa0", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -47,7 +47,6 @@ fn main() {\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n \n-#![deny(deprecated_owned_vector)]\n #![feature(plugin_registrar, managed_boxes)]\n \n extern crate syntax;"}, {"sha": "db6d940a7200e2a3d4022d54dfc2918f4b7692f8", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -88,7 +88,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(globs, phase)]\n #![deny(missing_doc)]\n-#![deny(deprecated_owned_vector)]\n \n #[cfg(test)] extern crate debug;\n #[cfg(test, stage0)] #[phase(syntax, link)] extern crate log;"}, {"sha": "a2c2706b4c2f779585d55b1af8b1ecc1742431d2", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -31,7 +31,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![deny(deprecated_owned_vector)]\n \n use std::cell::Cell;\n use std::{cmp, os, path};"}, {"sha": "a34791f470eaf9473a1a8dc0dc0a92e7948c4489", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -26,17 +26,13 @@ use std::slice;\n // of the contents of `Vec<T>`, since we anticipate that to be a\n // frequent way to dynamically construct a vector.\n \n-/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `~[T]`, `&'a [T]`.\n+/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `&'a [T]`.\n ///\n /// Some clients will have a pre-allocated vector ready to hand off in\n /// a slice; others will want to create the set on the fly and hand\n-/// off ownership, via either `Growable` or `FixedLen` depending on\n-/// which kind of vector they have constructed.  (The `FixedLen`\n-/// variant is provided for interoperability with `std::slice` methods\n-/// that return `~[T]`.)\n+/// off ownership, via `Growable`.\n pub enum MaybeOwnedVector<'a,T> {\n     Growable(Vec<T>),\n-    FixedLen(~[T]),\n     Borrowed(&'a [T]),\n }\n \n@@ -51,11 +47,6 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n }\n \n-impl<'a,T> IntoMaybeOwnedVector<'a,T> for ~[T] {\n-    #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { FixedLen(self) }\n-}\n-\n impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Borrowed(self) }\n@@ -65,7 +56,6 @@ impl<'a,T> MaybeOwnedVector<'a,T> {\n     pub fn iter(&'a self) -> slice::Items<'a,T> {\n         match self {\n             &Growable(ref v) => v.iter(),\n-            &FixedLen(ref v) => v.iter(),\n             &Borrowed(ref v) => v.iter(),\n         }\n     }\n@@ -84,7 +74,6 @@ impl<'b,T> slice::Vector<T> for MaybeOwnedVector<'b,T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match self {\n             &Growable(ref v) => v.as_slice(),\n-            &FixedLen(ref v) => v.as_slice(),\n             &Borrowed(ref v) => v.as_slice(),\n         }\n     }\n@@ -106,15 +95,14 @@ impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n \n impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n     /// Returns a copy of `self`.\n-    fn to_owned(&self) -> ~[T] {\n+    fn to_owned(&self) -> Vec<T> {\n         self.as_slice().to_owned()\n     }\n \n     /// Convert `self` into an owned slice, not making a copy if possible.\n-    fn into_owned(self) -> ~[T] {\n+    fn into_owned(self) -> Vec<T> {\n         match self {\n             Growable(v) => v.as_slice().to_owned(),\n-            FixedLen(v) => v,\n             Borrowed(v) => v.to_owned(),\n         }\n     }\n@@ -125,7 +113,6 @@ impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n     pub fn into_vec(self) -> Vec<T> {\n         match self {\n             Growable(v) => v,\n-            FixedLen(v) => Vec::from_slice(v.as_slice()),\n             Borrowed(v) => Vec::from_slice(v),\n         }\n     }"}, {"sha": "e6915385a42d58f0d48bd7c934a15e490b15facf", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -191,9 +191,9 @@ type Registers = [uint, ..34];\n type Registers = [uint, ..22];\n \n #[cfg(windows, target_arch = \"x86_64\")]\n-fn new_regs() -> Box<Registers> { box [0, .. 34] }\n+fn new_regs() -> Box<Registers> { box() ([0, .. 34]) }\n #[cfg(not(windows), target_arch = \"x86_64\")]\n-fn new_regs() -> Box<Registers> { box {let v = [0, .. 22]; v} }\n+fn new_regs() -> Box<Registers> { box() ([0, .. 22]) }\n \n #[cfg(target_arch = \"x86_64\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,"}, {"sha": "e8de2b9bd9335cc99621b3d45cf147ac2cced253", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -209,7 +209,6 @@\n // NB this does *not* include globs, please keep it that way.\n #![feature(macro_rules, phase)]\n #![allow(visible_private_types)]\n-#![deny(deprecated_owned_vector)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n #[cfg(test)] extern crate rustuv;"}, {"sha": "b181b0ca8c977ae13e80c25a106de44d17d102ec", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -43,8 +43,6 @@ fn main() {\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n-\n-#![deny(deprecated_owned_vector)]\n #![feature(plugin_registrar, managed_boxes)]\n \n extern crate syntax;"}, {"sha": "2ecfef35308832b7d960e5e7a1bef52f81d889e7", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -115,7 +115,7 @@ if logging is disabled, none of the components of the log will be executed.\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(macro_rules)]\n-#![deny(missing_doc, deprecated_owned_vector)]\n+#![deny(missing_doc)]\n \n use std::fmt;\n use std::io::LineBufferedWriter;"}, {"sha": "27ccc528c940db36a84550f2f66257ea1b1bd8a4", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -53,8 +53,6 @@\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![deny(deprecated_owned_vector)]\n-\n extern crate rand;\n \n pub use bigint::{BigInt, BigUint};"}, {"sha": "61b133c4e68abef23ecb275231bb1d1f1cc0863d", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -364,7 +364,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(macro_rules, phase)]\n-#![deny(missing_doc, deprecated_owned_vector)]\n+#![deny(missing_doc)]\n \n #[cfg(test)]\n extern crate stdtest = \"test\";"}, {"sha": "b6205d8d54e6799c474195fb8b2733eb39dd8c78", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -37,7 +37,7 @@ pub mod config;\n \n pub fn main_args(args: &[String]) -> int {\n     let owned_args = args.to_owned();\n-    monitor(proc() run_compiler(owned_args));\n+    monitor(proc() run_compiler(owned_args.as_slice()));\n     0\n }\n "}, {"sha": "bc5fad7f9343a871ea2d0f7b2f03db230c6b8a91", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -418,10 +418,10 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.walk_expr(&*cond, in_out, loop_scopes);\n \n                 let mut then_bits = in_out.to_owned();\n-                self.walk_block(&*then, then_bits, loop_scopes);\n+                self.walk_block(&*then, then_bits.as_mut_slice(), loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, then_bits, in_out);\n+                join_bits(&self.dfcx.oper, then_bits.as_slice(), in_out);\n             }\n \n             ast::ExprWhile(cond, blk) => {\n@@ -444,8 +444,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(&*blk, body_bits, loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits);\n+                self.walk_block(&*blk, body_bits.as_mut_slice(), loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits.as_slice());\n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n@@ -468,8 +468,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     loop_id: expr.id,\n                     break_bits: Vec::from_slice(in_out)\n                 });\n-                self.walk_block(&**blk, body_bits, loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits);\n+                self.walk_block(&**blk, body_bits.as_mut_slice(), loop_scopes);\n+                self.add_to_entry_set(expr.id, body_bits.as_slice());\n \n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n@@ -499,16 +499,17 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n                 for arm in arms.iter() {\n                     // in_out reflects the discr and all guards to date\n-                    self.walk_opt_expr(arm.guard, guards, loop_scopes);\n+                    self.walk_opt_expr(arm.guard, guards.as_mut_slice(),\n+                                       loop_scopes);\n \n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n                     let mut body = guards.to_owned();\n                     self.walk_pat_alternatives(arm.pats.as_slice(),\n-                                               body,\n+                                               body.as_mut_slice(),\n                                                loop_scopes);\n-                    self.walk_expr(&*arm.body, body, loop_scopes);\n-                    join_bits(&self.dfcx.oper, body, in_out);\n+                    self.walk_expr(&*arm.body, body.as_mut_slice(), loop_scopes);\n+                    join_bits(&self.dfcx.oper, body.as_slice(), in_out);\n                 }\n             }\n \n@@ -578,7 +579,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                 self.walk_expr(&**l, in_out, loop_scopes);\n                 let temp = in_out.to_owned();\n                 self.walk_expr(&**r, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, temp, in_out);\n+                join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n             }\n \n             ast::ExprIndex(l, r) |\n@@ -739,8 +740,8 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n         let initial_state = in_out.to_owned();\n         for &pat in pats.iter() {\n             let mut temp = initial_state.clone();\n-            self.walk_pat(pat, temp, loop_scopes);\n-            join_bits(&self.dfcx.oper, temp, in_out);\n+            self.walk_pat(pat, temp.as_mut_slice(), loop_scopes);\n+            join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n         }\n     }\n "}, {"sha": "389a73c357b7d473d685ecce39d6be7b5c85de61", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -121,8 +121,6 @@ pub enum Lint {\n     UnusedMustUse,\n     UnusedResult,\n \n-    DeprecatedOwnedVector,\n-\n     Warnings,\n \n     RawPointerDeriving,\n@@ -433,13 +431,6 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: Allow,\n     }),\n \n-    (\"deprecated_owned_vector\",\n-     LintSpec {\n-        lint: DeprecatedOwnedVector,\n-        desc: \"use of a `~[T]` vector\",\n-        default: Allow,\n-    }),\n-\n     (\"raw_pointer_deriving\",\n      LintSpec {\n         lint: RawPointerDeriving,\n@@ -1229,20 +1220,6 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n     }\n }\n \n-fn check_deprecated_owned_vector(cx: &Context, e: &ast::Expr) {\n-    let t = ty::expr_ty(cx.tcx, e);\n-    match ty::get(t).sty {\n-        ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_vec(_, None) => {\n-                cx.span_lint(DeprecatedOwnedVector, e.span,\n-                             \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n-            }\n-            _ => {}\n-        },\n-        _ => {}\n-    }\n-}\n-\n fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     fn is_camel_case(ident: ast::Ident) -> bool {\n         let ident = token::get_ident(ident);\n@@ -1855,7 +1832,6 @@ impl<'a> Visitor<()> for Context<'a> {\n \n         check_type_limits(self, e);\n         check_unused_casts(self, e);\n-        check_deprecated_owned_vector(self, e);\n \n         visit::walk_expr(self, e, ());\n     }"}, {"sha": "1a7f0cdfc507ef7db918eab273073ec346a81776", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -24,13 +24,13 @@ modify/read the slot specified by the key.\n \n ```rust\n local_data_key!(key_int: int)\n-local_data_key!(key_vector: ~[int])\n+local_data_key!(key_vector: Vec<int>)\n \n key_int.replace(Some(3));\n assert_eq!(*key_int.get().unwrap(), 3);\n \n-key_vector.replace(Some(~[4]));\n-assert_eq!(*key_vector.get().unwrap(), ~[4]);\n+key_vector.replace(Some(vec![4]));\n+assert_eq!(*key_vector.get().unwrap(), vec![4]);\n ```\n \n */"}, {"sha": "2ad69dad8d2c9c75d44526ae227a2655d71226e7", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -35,7 +35,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n-#![deny(deprecated_owned_vector)]\n \n use std::char;\n use std::cmp;"}, {"sha": "a5c2042c979eecc60f214633872be06b35cfec9e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 89, "deletions": 91, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -81,7 +81,7 @@ fn main() {\n ```\n \n Two wrapper functions are provided to encode a Encodable object\n-into a string (String) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+into a string (String) or buffer (vec![u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n \n ```rust\n use serialize::json;\n@@ -2225,10 +2225,6 @@ impl<'a, A:ToJson> ToJson for &'a [A] {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for ~[A] {\n-    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n-}\n-\n impl<A:ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n@@ -3048,15 +3044,16 @@ mod tests {\n         let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n \n-    fn assert_stream_equal(src: &str, expected: ~[(JsonEvent, ~[StackElement])]) {\n+    fn assert_stream_equal(src: &str,\n+                           expected: Vec<(JsonEvent, Vec<StackElement>)>) {\n         let mut parser = Parser::new(src.chars());\n         let mut i = 0;\n         loop {\n             let evt = match parser.next() {\n                 Some(e) => e,\n                 None => { break; }\n             };\n-            let (ref expected_evt, ref expected_stack) = expected[i];\n+            let (ref expected_evt, ref expected_stack) = *expected.get(i);\n             if !parser.stack().is_equal_to(expected_stack.as_slice()) {\n                 fail!(\"Parser stack is not equal to {}\", expected_stack);\n             }\n@@ -3065,26 +3062,27 @@ mod tests {\n         }\n     }\n     #[test]\n+    #[ignore(cfg(target_word_size = \"32\"))] // FIXME(#14064)\n     fn test_streaming_parser() {\n         assert_stream_equal(\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n-            ~[\n-                (ObjectStart,             ~[]),\n-                  (StringValue(\"bar\".to_string()),   ~[Key(\"foo\")]),\n-                  (ListStart,             ~[Key(\"array\")]),\n-                    (NumberValue(0.0),    ~[Key(\"array\"), Index(0)]),\n-                    (NumberValue(1.0),    ~[Key(\"array\"), Index(1)]),\n-                    (NumberValue(2.0),    ~[Key(\"array\"), Index(2)]),\n-                    (NumberValue(3.0),    ~[Key(\"array\"), Index(3)]),\n-                    (NumberValue(4.0),    ~[Key(\"array\"), Index(4)]),\n-                    (NumberValue(5.0),    ~[Key(\"array\"), Index(5)]),\n-                  (ListEnd,               ~[Key(\"array\")]),\n-                  (ListStart,             ~[Key(\"idents\")]),\n-                    (NullValue,           ~[Key(\"idents\"), Index(0)]),\n-                    (BooleanValue(true),  ~[Key(\"idents\"), Index(1)]),\n-                    (BooleanValue(false), ~[Key(\"idents\"), Index(2)]),\n-                  (ListEnd,               ~[Key(\"idents\")]),\n-                (ObjectEnd,               ~[]),\n+            vec![\n+                (ObjectStart,             vec![]),\n+                  (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n+                  (ListStart,             vec![Key(\"array\")]),\n+                    (NumberValue(0.0),    vec![Key(\"array\"), Index(0)]),\n+                    (NumberValue(1.0),    vec![Key(\"array\"), Index(1)]),\n+                    (NumberValue(2.0),    vec![Key(\"array\"), Index(2)]),\n+                    (NumberValue(3.0),    vec![Key(\"array\"), Index(3)]),\n+                    (NumberValue(4.0),    vec![Key(\"array\"), Index(4)]),\n+                    (NumberValue(5.0),    vec![Key(\"array\"), Index(5)]),\n+                  (ListEnd,               vec![Key(\"array\")]),\n+                  (ListStart,             vec![Key(\"idents\")]),\n+                    (NullValue,           vec![Key(\"idents\"), Index(0)]),\n+                    (BooleanValue(true),  vec![Key(\"idents\"), Index(1)]),\n+                    (BooleanValue(false), vec![Key(\"idents\"), Index(2)]),\n+                  (ListEnd,               vec![Key(\"idents\")]),\n+                (ObjectEnd,               vec![]),\n             ]\n         );\n     }\n@@ -3115,34 +3113,34 @@ mod tests {\n \n         assert_stream_equal(\n             \"{}\",\n-            box [(ObjectStart, box []), (ObjectEnd, box [])]\n+            vec![(ObjectStart, vec![]), (ObjectEnd, vec![])]\n         );\n         assert_stream_equal(\n             \"{\\\"a\\\": 3}\",\n-            box [\n-                (ObjectStart,        box []),\n-                  (NumberValue(3.0), box [Key(\"a\")]),\n-                (ObjectEnd,          box []),\n+            vec![\n+                (ObjectStart,        vec![]),\n+                  (NumberValue(3.0), vec![Key(\"a\")]),\n+                (ObjectEnd,          vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-            box [\n-                (ObjectStart,           box []),\n-                  (NullValue,           box [Key(\"a\")]),\n-                  (BooleanValue(true),  box [Key(\"b\")]),\n-                (ObjectEnd,             box []),\n+            vec![\n+                (ObjectStart,           vec![]),\n+                  (NullValue,           vec![Key(\"a\")]),\n+                  (BooleanValue(true),  vec![Key(\"b\")]),\n+                (ObjectEnd,             vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-            box [\n-                (ObjectStart,           box []),\n-                  (NumberValue(1.0),    box [Key(\"a\")]),\n-                  (ListStart,           box [Key(\"b\")]),\n-                    (BooleanValue(true),box [Key(\"b\"), Index(0)]),\n-                  (ListEnd,             box [Key(\"b\")]),\n-                (ObjectEnd,             box []),\n+            vec![\n+                (ObjectStart,           vec![]),\n+                  (NumberValue(1.0),    vec![Key(\"a\")]),\n+                  (ListStart,           vec![Key(\"b\")]),\n+                    (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n+                  (ListEnd,             vec![Key(\"b\")]),\n+                (ObjectEnd,             vec![]),\n             ]\n         );\n         assert_stream_equal(\n@@ -3154,19 +3152,19 @@ mod tests {\n                     { \"c\": {\"d\": null} }\n                 ]\n             }\"#,\n-            ~[\n-                (ObjectStart,                   ~[]),\n-                  (NumberValue(1.0),            ~[Key(\"a\")]),\n-                  (ListStart,                   ~[Key(\"b\")]),\n-                    (BooleanValue(true),        ~[Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  ~[Key(\"b\"), Index(1)]),\n-                    (ObjectStart,               ~[Key(\"b\"), Index(2)]),\n-                      (ObjectStart,             ~[Key(\"b\"), Index(2), Key(\"c\")]),\n-                        (NullValue,             ~[Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n-                      (ObjectEnd,               ~[Key(\"b\"), Index(2), Key(\"c\")]),\n-                    (ObjectEnd,                 ~[Key(\"b\"), Index(2)]),\n-                  (ListEnd,                     ~[Key(\"b\")]),\n-                (ObjectEnd,                     ~[]),\n+            vec![\n+                (ObjectStart,                   vec![]),\n+                  (NumberValue(1.0),            vec![Key(\"a\")]),\n+                  (ListStart,                   vec![Key(\"b\")]),\n+                    (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n+                    (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n+                    (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n+                      (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n+                        (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n+                      (ObjectEnd,               vec![Key(\"b\"), Index(2), Key(\"c\")]),\n+                    (ObjectEnd,                 vec![Key(\"b\"), Index(2)]),\n+                  (ListEnd,                     vec![Key(\"b\")]),\n+                (ObjectEnd,                     vec![]),\n             ]\n         );\n     }\n@@ -3175,70 +3173,70 @@ mod tests {\n     fn test_read_list_streaming() {\n         assert_stream_equal(\n             \"[]\",\n-            box [\n-                (ListStart, box []),\n-                (ListEnd,   box []),\n+            vec![\n+                (ListStart, vec![]),\n+                (ListEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ ]\",\n-            box [\n-                (ListStart, box []),\n-                (ListEnd,   box []),\n+            vec![\n+                (ListStart, vec![]),\n+                (ListEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[true]\",\n-            box [\n-                (ListStart,              box []),\n-                    (BooleanValue(true), box [Index(0)]),\n-                (ListEnd,                box []),\n+            vec![\n+                (ListStart,              vec![]),\n+                    (BooleanValue(true), vec![Index(0)]),\n+                (ListEnd,                vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ false ]\",\n-            box [\n-                (ListStart,               box []),\n-                    (BooleanValue(false), box [Index(0)]),\n-                (ListEnd,                 box []),\n+            vec![\n+                (ListStart,               vec![]),\n+                    (BooleanValue(false), vec![Index(0)]),\n+                (ListEnd,                 vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[null]\",\n-            box [\n-                (ListStart,     box []),\n-                    (NullValue, box [Index(0)]),\n-                (ListEnd,       box []),\n+            vec![\n+                (ListStart,     vec![]),\n+                    (NullValue, vec![Index(0)]),\n+                (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[3, 1]\",\n-            box [\n-                (ListStart,     box []),\n-                    (NumberValue(3.0), box [Index(0)]),\n-                    (NumberValue(1.0), box [Index(1)]),\n-                (ListEnd,       box []),\n+            vec![\n+                (ListStart,     vec![]),\n+                    (NumberValue(3.0), vec![Index(0)]),\n+                    (NumberValue(1.0), vec![Index(1)]),\n+                (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n-            box [\n-                (ListStart,     box []),\n-                    (NumberValue(3.0), box [Index(0)]),\n-                    (NumberValue(2.0), box [Index(1)]),\n-                (ListEnd,       box []),\n+            vec![\n+                (ListStart,     vec![]),\n+                    (NumberValue(3.0), vec![Index(0)]),\n+                    (NumberValue(2.0), vec![Index(1)]),\n+                (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n-            box [\n-                (ListStart,                 box []),\n-                    (NumberValue(2.0),      box [Index(0)]),\n-                    (ListStart,             box [Index(1)]),\n-                        (NumberValue(4.0),  box [Index(1), Index(0)]),\n-                        (NumberValue(1.0),  box [Index(1), Index(1)]),\n-                    (ListEnd,               box [Index(1)]),\n-                (ListEnd,                   box []),\n+            vec![\n+                (ListStart,                 vec![]),\n+                    (NumberValue(2.0),      vec![Index(0)]),\n+                    (ListStart,             vec![Index(1)]),\n+                        (NumberValue(4.0),  vec![Index(1), Index(0)]),\n+                        (NumberValue(1.0),  vec![Index(1), Index(1)]),\n+                    (ListEnd,               vec![Index(1)]),\n+                (ListEnd,                   vec![]),\n             ]\n         );\n \n@@ -3368,7 +3366,7 @@ mod tests {\n         assert_eq!((1, 2, 3).to_json(), list3);\n         assert_eq!([1, 2].to_json(), list2);\n         assert_eq!((&[1, 2, 3]).to_json(), list3);\n-        assert_eq!((~[1, 2]).to_json(), list2);\n+        assert_eq!((vec![1, 2]).to_json(), list2);\n         assert_eq!(vec!(1, 2, 3).to_json(), list3);\n         let mut tree_map = TreeMap::new();\n         tree_map.insert(\"a\".to_string(), 1);"}, {"sha": "40092a477b3967257b645a986e25d7246da0d1cf", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -425,32 +425,6 @@ impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a [T] {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n-    fn decode(d: &mut D) -> Result<~[T], E> {\n-        use std::vec::FromVec;\n-\n-        d.read_seq(|d, len| {\n-            let mut v: Vec<T> = Vec::with_capacity(len);\n-            for i in range(0, len) {\n-                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            let k: ~[T] = FromVec::from_vec(v);\n-            Ok(k)\n-        })\n-    }\n-}\n-\n impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {"}, {"sha": "2730d90f05fc121b6acccad4eb3bd89d466bf468", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -278,18 +278,6 @@ pub trait OwnedAsciiCast {\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n-impl OwnedAsciiCast for ~[u8] {\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        self.as_slice().is_ascii()\n-    }\n-\n-    #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        mem::transmute(Vec::from_slice(self.as_slice()))\n-    }\n-}\n-\n impl OwnedAsciiCast for String {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -353,14 +341,6 @@ impl<'a> AsciiStr for &'a [Ascii] {\n     }\n }\n \n-impl IntoStr for ~[Ascii] {\n-    #[inline]\n-    fn into_str(self) -> String {\n-        let vector: Vec<Ascii> = self.as_slice().iter().map(|x| *x).collect();\n-        vector.into_str()\n-    }\n-}\n-\n impl IntoStr for Vec<Ascii> {\n     #[inline]\n     fn into_str(self) -> String {\n@@ -592,8 +572,8 @@ mod tests {\n         let test = &[40u8, 32u8, 59u8];\n         assert_eq!(test.to_ascii(), v2ascii!([40, 32, 59]));\n         assert_eq!(\"( ;\".to_ascii(), v2ascii!([40, 32, 59]));\n-        let v = box [40u8, 32u8, 59u8];\n-        assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = vec![40u8, 32u8, 59u8];\n+        assert_eq!(v.as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n         assert_eq!(\"( ;\".to_string().as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n \n         assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_string());\n@@ -623,7 +603,7 @@ mod tests {\n     #[test]\n     fn test_owned_ascii_vec() {\n         assert_eq!((\"( ;\".to_string()).into_ascii(), vec2ascii![40, 32, 59]);\n-        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n+        assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n     }\n \n     #[test]"}, {"sha": "c03fbf302d75419a4ab2f5676d8904640c7817f7", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -15,9 +15,9 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use super::{Reader, Writer, IoResult};\n-use str::StrSlice;\n use slice::{bytes, MutableVector, ImmutableVector};\n+use str::StrSlice;\n+use super::{Reader, Writer, IoResult};\n use vec::Vec;\n \n /// Allows reading from a rx.\n@@ -162,14 +162,14 @@ mod test {\n         assert_eq!(Ok(2), reader.read(buf));\n         assert_eq!(&[7,8,6], buf.as_slice());\n \n-        match reader.read(buf) {\n+        match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n         assert_eq!(&[7,8,6], buf.as_slice());\n \n         // Ensure it continues to fail in the same way.\n-        match reader.read(buf) {\n+        match reader.read(buf.as_mut_slice()) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }"}, {"sha": "84a1253e5b4ae50a60fa1de3a4a17be09991f465", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -447,10 +447,10 @@ mod test {\n     #[test]\n     fn test_read_f32() {\n         //big-endian floating-point 8.1250\n-        let buf = box [0x41, 0x02, 0x00, 0x00];\n+        let buf = vec![0x41, 0x02, 0x00, 0x00];\n \n         let mut writer = MemWriter::new();\n-        writer.write(buf).unwrap();\n+        writer.write(buf.as_slice()).unwrap();\n \n         let mut reader = MemReader::new(writer.unwrap());\n         let f = reader.read_be_f32().unwrap();"}, {"sha": "c29c82ab2e9b443085be829f7fa7e378d081db9f", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -52,6 +52,9 @@ fs::unlink(&path);\n use c_str::ToCStr;\n use clone::Clone;\n use collections::Collection;\n+use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n+use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n use io;\n use iter::Iterator;\n use kinds::Send;\n@@ -60,14 +63,10 @@ use option::{Some, None, Option};\n use owned::Box;\n use path::{Path, GenericPath};\n use path;\n-use result::{Ok, Err};\n-use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n+use result::{Err, Ok};\n+use rt::rtio::LocalIo;\n use rt::rtio;\n-use slice::{OwnedVector, ImmutableVector};\n-use super::UnstableFileStat;\n-use super::{FileMode, FileAccess, FileStat, IoResult, FilePermission};\n-use super::{Reader, Writer, Seek, Append, SeekCur, SeekEnd, SeekSet};\n-use super::{SeekStyle, Read, Write, ReadWrite, Open, IoError, Truncate};\n+use slice::ImmutableVector;\n use vec::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n@@ -82,7 +81,7 @@ use vec::Vec;\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n pub struct File {\n-    fd: Box<RtioFileStream:Send>,\n+    fd: Box<rtio::RtioFileStream:Send>,\n     path: Path,\n     last_nread: int,\n }\n@@ -846,7 +845,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n).to_owned()).unwrap().to_owned()\n+                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_owned()\n             };\n             assert_eq!(read_str, message.to_owned());\n         }"}, {"sha": "71a967bb8dc5f41037fc64910f756fa1bb274e70", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -450,8 +450,8 @@ mod test {\n \n     #[test]\n     fn test_buf_reader() {\n-        let in_buf = box [0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = BufReader::new(in_buf);\n+        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = BufReader::new(in_buf.as_slice());\n         let mut buf = [];\n         assert_eq!(reader.read(buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n@@ -466,7 +466,7 @@ mod test {\n         assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n-        let mut reader = BufReader::new(in_buf);\n+        let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());"}, {"sha": "a626d1f3a6c08660b413f289e1d662d32a6350f7", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -856,8 +856,8 @@ mod tests {\n     })\n \n     iotest!(fn test_add_to_env() {\n-        let new_env = box [(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        let prog = env_cmd().env(new_env).spawn().unwrap();\n+        let new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n+        let prog = env_cmd().env(new_env.as_slice()).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n "}, {"sha": "83a01feee9017865f0c13878ca2282b28f805be2", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -300,24 +300,24 @@ mod test {\n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n-        let buf = box [0, 0, 0];\n-        s.write(buf).unwrap();\n+        let buf = vec![0, 0, 0];\n+        s.write(buf.as_slice()).unwrap();\n         s.flush().unwrap();\n     }\n \n     #[test]\n     fn test_zero_reader() {\n         let mut s = ZeroReader;\n-        let mut buf = box [1, 2, 3];\n-        assert_eq!(s.read(buf), Ok(3));\n-        assert_eq!(box [0, 0, 0], buf);\n+        let mut buf = vec![1, 2, 3];\n+        assert_eq!(s.read(buf.as_mut_slice()), Ok(3));\n+        assert_eq!(vec![0, 0, 0], buf);\n     }\n \n     #[test]\n     fn test_null_reader() {\n         let mut r = NullReader;\n-        let mut buf = box [0];\n-        assert!(r.read(buf).is_err());\n+        let mut buf = vec![0];\n+        assert!(r.read(buf.as_mut_slice()).is_err());\n     }\n \n     #[test]"}, {"sha": "22418cff957c5c254d1a0ca5361041987b7eeea4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -42,7 +42,7 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{Vector, ImmutableVector, MutableVector, OwnedVector};\n+use slice::{Vector, ImmutableVector, MutableVector};\n use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n@@ -536,7 +536,7 @@ pub fn self_exe_name() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n-            let mib = box [CTL_KERN as c_int,\n+            let mib = vec![CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n             let mut sz: libc::size_t = 0;"}, {"sha": "7d15893af241e865136b1194dca2536d8cff462a", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -63,8 +63,6 @@ println!(\"path exists: {}\", path.exists());\n \n */\n \n-#![deny(deprecated_owned_vector)]\n-\n use collections::Collection;\n use c_str::CString;\n use clone::Clone;\n@@ -527,13 +525,6 @@ impl<'a> BytesContainer for &'a [u8] {\n     }\n }\n \n-impl BytesContainer for ~[u8] {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_slice()\n-    }\n-}\n-\n impl BytesContainer for Vec<u8> {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {"}, {"sha": "494428de3a5c48aadaf85dc7563208bac908cae4", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -22,7 +22,7 @@ use option::{Option, None, Some};\n use str::Str;\n use str;\n use slice::{CloneableVector, Splits, Vector, VectorVector,\n-            ImmutableEqVector, OwnedVector, ImmutableVector};\n+            ImmutableEqVector, ImmutableVector};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -282,7 +282,6 @@ impl GenericPath for Path {\n         }\n     }\n \n-    #[allow(deprecated_owned_vector)]\n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         if self.is_absolute() != base.is_absolute() {\n             if self.is_absolute() {"}, {"sha": "e3209c5c186477d5ee310f5f9b6a3c9e2744457f", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -21,7 +21,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n-use slice::{Vector, OwnedVector, ImmutableVector};\n+use slice::{Vector, ImmutableVector};\n use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n use string::String;\n use vec::Vec;"}, {"sha": "6fb08b6ef7556fe5906de31f4207b023ea2619d0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -83,7 +83,7 @@\n #[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableOrdVector};\n #[doc(no_inline)] pub use slice::{ImmutableVector, MutableVector};\n #[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableOrdVector};\n-#[doc(no_inline)] pub use slice::{Vector, VectorVector, OwnedVector};\n+#[doc(no_inline)] pub use slice::{Vector, VectorVector};\n #[doc(no_inline)] pub use slice::MutableVectorAllocating;\n #[doc(no_inline)] pub use string::String;\n #[doc(no_inline)] pub use vec::Vec;"}, {"sha": "fe5d8fc068c919b50d18baa8bf92545cd3bc49fe", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -71,7 +71,6 @@ impl<R: Reader> Rng for ReaderRng<R> {\n }\n \n #[cfg(test)]\n-#[allow(deprecated_owned_vector)]\n mod test {\n     use prelude::*;\n \n@@ -83,24 +82,23 @@ mod test {\n     #[test]\n     fn test_reader_rng_u64() {\n         // transmute from the target to avoid endianness concerns.\n-        let v = box [1u64, 2u64, 3u64];\n-        let bytes: ~[u8] = unsafe {mem::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n+        let v = vec![0u8, 0, 0, 0, 0, 0, 0, 1,\n+                     0  , 0, 0, 0, 0, 0, 0, 2,\n+                     0,   0, 0, 0, 0, 0, 0, 3];\n+        let mut rng = ReaderRng::new(MemReader::new(v));\n \n-        assert_eq!(rng.next_u64(), 1);\n-        assert_eq!(rng.next_u64(), 2);\n-        assert_eq!(rng.next_u64(), 3);\n+        assert_eq!(rng.next_u64(), mem::to_be64(1));\n+        assert_eq!(rng.next_u64(), mem::to_be64(2));\n+        assert_eq!(rng.next_u64(), mem::to_be64(3));\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n-        // transmute from the target to avoid endianness concerns.\n-        let v = box [1u32, 2u32, 3u32];\n-        let bytes: ~[u8] = unsafe {mem::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n+        let v = vec![0u8, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3];\n+        let mut rng = ReaderRng::new(MemReader::new(v));\n \n-        assert_eq!(rng.next_u32(), 1);\n-        assert_eq!(rng.next_u32(), 2);\n-        assert_eq!(rng.next_u32(), 3);\n+        assert_eq!(rng.next_u32(), mem::to_be32(1));\n+        assert_eq!(rng.next_u32(), mem::to_be32(2));\n+        assert_eq!(rng.next_u32(), mem::to_be32(3));\n     }\n     #[test]\n     fn test_reader_rng_fill_bytes() {"}, {"sha": "9a1c0151e5411b1b55ee851a48cf5a556fb3c126", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -37,8 +37,8 @@ impl<T: fmt::Show> ToStr for T {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::*;\n     use super::*;\n-    use str::StrAllocating;\n \n     #[test]\n     fn test_simple_types() {\n@@ -54,11 +54,11 @@ mod tests {\n \n     #[test]\n     fn test_vectors() {\n-        let x: ~[int] = box [];\n+        let x: Vec<int> = vec![];\n         assert_eq!(x.to_str(), \"[]\".to_string());\n-        assert_eq!((box [1]).to_str(), \"[1]\".to_string());\n-        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n-        assert!((box [box [], box [1], box [1, 1]]).to_str() ==\n+        assert_eq!((vec![1]).to_str(), \"[1]\".to_string());\n+        assert_eq!((vec![1, 2, 3]).to_str(), \"[1, 2, 3]\".to_string());\n+        assert!((vec![vec![], vec![1], vec![1, 1]]).to_str() ==\n                \"[[], [1], [1, 1]]\".to_string());\n     }\n }"}, {"sha": "66ca10b196c6c4363a6890d9140241a0a7b78f52", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -26,7 +26,7 @@\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(phase, globs, macro_rules)]\n-#![deny(deprecated_owned_vector)]\n+\n #![deny(missing_doc)]\n #![no_std]\n "}, {"sha": "e280c244929836d86080a9752978bd05ff61fee8", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -30,6 +30,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteOwnedType,\n     ObsoleteOwnedExpr,\n     ObsoleteOwnedPattern,\n+    ObsoleteOwnedVector,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -63,6 +64,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`~` notation for owned pointer patterns\",\n                 \"use the `box` operator instead of `~`\"\n             ),\n+            ObsoleteOwnedVector => (\n+                \"`~[T]` is no longer a type\",\n+                \"use the `Vec` type instead\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "4d9b112cb5c3a191e552ff3479e0d7fbefe9b60d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -1315,11 +1315,8 @@ impl<'a> Parser<'a> {\n             // OWNED POINTER\n             self.bump();\n             match self.token {\n-                token::IDENT(ref ident, _)\n-                        if \"str\" == token::get_ident(*ident).get() => {\n-                    // This is OK (for now).\n-                }\n-                token::LBRACKET => {}   // Also OK.\n+                token::LBRACKET =>\n+                    self.obsolete(self.last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n             };\n             TyUniq(self.parse_ty(false))\n@@ -2342,7 +2339,10 @@ impl<'a> Parser<'a> {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-vec\n             ex = match e.node {\n-              ExprVec(..) | ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n+              ExprVec(..) | ExprRepeat(..) => {\n+                  self.obsolete(self.last_span, ObsoleteOwnedVector);\n+                  ExprVstore(e, ExprVstoreUniq)\n+              }\n               ExprLit(lit) if lit_is_str(lit) => {\n                   self.obsolete(self.last_span, ObsoleteOwnedExpr);\n                   ExprVstore(e, ExprVstoreUniq)\n@@ -2375,6 +2375,7 @@ impl<'a> Parser<'a> {\n             // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n                 ExprVec(..) | ExprRepeat(..) => {\n+                    self.obsolete(self.last_span, ObsoleteOwnedVector);\n                     ExprVstore(subexpression, ExprVstoreUniq)\n                 }\n                 ExprLit(lit) if lit_is_str(lit) => {"}, {"sha": "d0101e993c49d191ad10ccb11a423e6702cb1366", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -33,7 +33,6 @@\n        html_root_url = \"http://doc.rust-lang.org/\")]\n \n #![feature(asm, macro_rules, phase)]\n-#![deny(deprecated_owned_vector)]\n \n extern crate getopts;\n extern crate regex;\n@@ -72,7 +71,7 @@ pub mod test {\n              MetricChange, Improvement, Regression, LikelyNoise,\n              StaticTestFn, StaticTestName, DynTestName, DynTestFn,\n              run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn, test_main_static_x};\n+             parse_opts, StaticBenchFn};\n }\n \n pub mod stats;\n@@ -263,14 +262,6 @@ pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n     test_main(args, owned_tests)\n }\n \n-pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n-    test_main_static(args.iter()\n-                         .map(|x| x.to_string())\n-                         .collect::<Vec<_>>()\n-                         .as_slice(),\n-                     tests)\n-}\n-\n pub enum ColorConfig {\n     AutoColor,\n     AlwaysColor,"}, {"sha": "aa0e9b46fa7c336cc34856455a66225f43010f52", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -167,7 +167,6 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n impl<'a,T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n \n     // FIXME #11059 handle NaN, inf and overflow\n-    #[allow(deprecated_owned_vector)]\n     fn sum(self) -> T {\n         let mut partials = vec![];\n \n@@ -1027,7 +1026,6 @@ mod tests {\n \n     #[test]\n     fn test_boxplot_nonpositive() {\n-        #[allow(deprecated_owned_vector)]\n         fn t(s: &Summary<f64>, expected: String) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();"}, {"sha": "63523cd3a6f6a877482e2da76f4d5743e3f515fa", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -20,7 +20,6 @@\n        html_root_url = \"http://doc.rust-lang.org/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(phase)]\n-#![deny(deprecated_owned_vector)]\n \n #[cfg(test)] extern crate debug;\n "}, {"sha": "19b9d5638d0d8f3f034586958591b6322ebacd26", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -75,7 +75,7 @@ fn main() {\n     let clen = seq.len();\n \n     let mut seqlen = Future::spawn(proc() {\n-        let substs = ~[\n+        let substs = vec![\n             (regex!(\"B\"), \"(c|g|t)\"),\n             (regex!(\"D\"), \"(a|g|t)\"),\n             (regex!(\"H\"), \"(a|c|t)\"),\n@@ -95,7 +95,7 @@ fn main() {\n         seq.len()\n     });\n \n-    let variants = ~[\n+    let variants = vec![\n         regex!(\"agggtaaa|tttaccct\"),\n         regex!(\"[cgt]gggtaaa|tttaccc[acg]\"),\n         regex!(\"a[act]ggtaaa|tttacc[agt]t\"),"}, {"sha": "3cd582ca0b8c3a9bad17071194031bd10ca34b64", "filename": "src/test/compile-fail/borrowck-use-in-index-lvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n fn test() {\n-    let w: ~[int];\n+    let w: &mut [int];\n     w[5] = 0; //~ ERROR use of possibly uninitialized variable: `w`\n-              //~^ ERROR cannot assign to immutable vec content `w[..]`\n \n-    let mut w: ~[int];\n+    let mut w: &mut [int];\n     w[5] = 0; //~ ERROR use of possibly uninitialized variable: `w`\n }\n "}, {"sha": "7457a1020cee1c31c7fdf01bfaa6663fdb5497c9", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -11,8 +11,6 @@\n #![deny(unreachable_code)]\n #![allow(unused_variable)]\n #![allow(dead_code)]\n-#![allow(deprecated_owned_vector)]\n-\n \n fn fail_len(v: Vec<int> ) -> uint {\n     let mut i = 3;"}, {"sha": "537f3c9f48a99ea0a384e9408c7556c13fa25991", "filename": "src/test/compile-fail/lint-deprecated-owned-vector.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9260d41d6e37653bf71b08a041be0310098716a/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-deprecated-owned-vector.rs?ref=f9260d41d6e37653bf71b08a041be0310098716a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(deprecated_owned_vector)]\n-\n-fn main() {\n-    ~[1]; //~ ERROR use of deprecated `~[]`\n-    //~^ ERROR use of deprecated `~[]`\n-}"}, {"sha": "26cae1aa708112331822d8e9aef3649bf733d1b3", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -11,7 +11,6 @@\n #![feature(managed_boxes)]\n #![forbid(heap_memory)]\n #![allow(dead_code)]\n-#![allow(deprecated_owned_vector)]\n \n \n struct Foo {"}, {"sha": "4334d2f63ea59c41e94263c90b12700daf9330d6", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -11,7 +11,6 @@\n #![feature(globs)]\n #![deny(unused_imports)]\n #![allow(dead_code)]\n-#![allow(deprecated_owned_vector)]\n \n use cal = bar::c::cc;\n "}, {"sha": "d5f34669a25e2355b415b366485fa2fce3ea2cb6", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -13,7 +13,6 @@\n #![allow(dead_assignment)]\n #![allow(unused_variable)]\n #![allow(dead_code)]\n-#![allow(deprecated_owned_vector)]\n #![deny(unused_mut)]\n \n "}, {"sha": "8ae3f1fdd0d74bc76efe6ba3a745d1885edb2771", "filename": "src/test/compile-fail/lint-unused-unsafe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-unsafe.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -12,7 +12,6 @@\n \n #![allow(dead_code)]\n #![deny(unused_unsafe)]\n-#![allow(deprecated_owned_vector)]\n \n \n mod foo {"}, {"sha": "15544468ae992a7ecdc4cbbce137c92ee54bbfbc", "filename": "src/test/run-pass/empty-allocation-non-null.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -13,7 +13,4 @@ pub fn main() {\n \n     struct Foo;\n     assert!(Some(box Foo).is_some());\n-\n-    let xs: ~[()] = ~[];\n-    assert!(Some(xs).is_some());\n }"}, {"sha": "7078518bebcf9598f2fe53691945b62cedb5f4d6", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -13,7 +13,6 @@\n #![feature(macro_rules, managed_boxes)]\n #![deny(warnings)]\n #![allow(unused_must_use)]\n-#![allow(deprecated_owned_vector)]\n \n extern crate debug;\n "}, {"sha": "cd5903ad4e3b5f6d2ab949ee7787d3e597f1d87f", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -45,7 +45,7 @@ pub fn main() {\n     p.borrow_mut().y += 3;\n     assert_eq!(*p.borrow(), Point {x: 3, y: 5});\n \n-    let v = Rc::new(RefCell::new(~[1, 2, 3]));\n+    let v = Rc::new(RefCell::new([1, 2, 3]));\n     v.borrow_mut()[0] = 3;\n     v.borrow_mut()[1] += 3;\n     assert_eq!((v.borrow()[0], v.borrow()[1], v.borrow()[2]), (3, 5, 3));"}, {"sha": "b471d13901e093a4878c370ad2df856ca81ab7b0", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=ceaeb667b327cff7ad286255d68cb5a8ba8a4d7c", "patch": "@@ -62,8 +62,6 @@ impl TyVisitor for MyVisitor {\n \n     fn visit_char(&mut self) -> bool { true }\n \n-    fn visit_estr_box(&mut self) -> bool { true }\n-    fn visit_estr_uniq(&mut self) -> bool { true }\n     fn visit_estr_slice(&mut self) -> bool { true }\n     fn visit_estr_fixed(&mut self,\n                         _sz: uint, _sz2: uint,\n@@ -74,13 +72,6 @@ impl TyVisitor for MyVisitor {\n     fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.types.push(\"[\".to_string());\n-        unsafe { visit_tydesc(inner, &mut *self as &mut TyVisitor); }\n-        self.types.push(\"]\".to_string());\n-        true\n-    }\n     fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }"}]}