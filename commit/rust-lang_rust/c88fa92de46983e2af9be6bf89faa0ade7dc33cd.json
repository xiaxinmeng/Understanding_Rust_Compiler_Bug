{"sha": "c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OGZhOTJkZTQ2OTgzZTJhZjliZTZiZjg5ZmFhMGFkZTdkYzMzY2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-06-04T21:39:55Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-06-04T21:44:24Z"}, "message": "rustc: Generate extension annotations from ext_ctxt instead of parser", "tree": {"sha": "50f023a788c698c6152ec16a7b1cb0b3f88a088d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50f023a788c698c6152ec16a7b1cb0b3f88a088d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "html_url": "https://github.com/rust-lang/rust/commit/c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c88fa92de46983e2af9be6bf89faa0ade7dc33cd/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6f1dc58d3f6c068f095ce588cc7ba7fc625ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6f1dc58d3f6c068f095ce588cc7ba7fc625ed5", "html_url": "https://github.com/rust-lang/rust/commit/1d6f1dc58d3f6c068f095ce588cc7ba7fc625ed5"}], "stats": {"total": 132, "additions": 67, "deletions": 65}, "files": [{"sha": "a99ef94e07f832d7611828f7e02cf714a707fcd5", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c88fa92de46983e2af9be6bf89faa0ade7dc33cd/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88fa92de46983e2af9be6bf89faa0ade7dc33cd/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "patch": "@@ -15,7 +15,7 @@ import ext::*;\n \n export expand_syntax_ext;\n \n-// FIXME: Need to thread parser through here to handle errors correctly\n+\n fn expand_syntax_ext(&ext_ctxt cx,\n                      &parser::parser p,\n                      common::span sp,\n@@ -29,20 +29,20 @@ fn expand_syntax_ext(&ext_ctxt cx,\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t[str] rather than just an maybe-empty string.\n \n-    auto var = expr_to_str(cx, p, args.(0));\n+    auto var = expr_to_str(cx, args.(0));\n     alt (generic_os::getenv(var)) {\n         case (option::none) {\n-            ret make_new_str(p, sp, \"\");\n+            ret make_new_str(cx, sp, \"\");\n         }\n         case (option::some(?s)) {\n-            ret make_new_str(p, sp, s);\n+            ret make_new_str(cx, sp, s);\n         }\n     }\n }\n \n // FIXME: duplicate code copied from extfmt:\n \n-fn expr_to_str(&ext_ctxt cx, parser::parser p,\n+fn expr_to_str(&ext_ctxt cx,\n                @ast::expr expr) -> str {\n     alt (expr.node) {\n         case (ast::expr_lit(?l, _)) {\n@@ -61,16 +61,16 @@ fn expr_to_str(&ext_ctxt cx, parser::parser p,\n     }\n }\n \n-fn make_new_lit(parser::parser p, common::span sp, ast::lit_ lit)\n+fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit)\n     -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n-    auto expr = ast::expr_lit(sp_lit, p.get_ann());\n+    auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n     ret @rec(node=expr, span=sp);\n }\n \n-fn make_new_str(parser::parser p, common::span sp, str s) -> @ast::expr {\n+fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n     auto lit = ast::lit_str(s);\n-    ret make_new_lit(p, sp, lit);\n+    ret make_new_lit(cx, sp, lit);\n }\n \n //"}, {"sha": "c2f7cd793087a2435b828a3bd96d49f9b82fb2de", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c88fa92de46983e2af9be6bf89faa0ade7dc33cd/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88fa92de46983e2af9be6bf89faa0ade7dc33cd/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=c88fa92de46983e2af9be6bf89faa0ade7dc33cd", "patch": "@@ -65,59 +65,60 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                   vec[piece] pieces, vec[@ast::expr] args) -> @ast::expr {\n \n-    fn make_new_lit(parser p, common::span sp, ast::lit_ lit) -> @ast::expr {\n+    fn make_new_lit(&ext_ctxt cx,\n+                    common::span sp, ast::lit_ lit) -> @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n-        auto expr = ast::expr_lit(sp_lit, p.get_ann());\n+        auto expr = ast::expr_lit(sp_lit, cx.next_ann());\n         ret @rec(node=expr, span=sp);\n     }\n \n-    fn make_new_str(parser p, common::span sp, str s) -> @ast::expr {\n+    fn make_new_str(&ext_ctxt cx, common::span sp, str s) -> @ast::expr {\n         auto lit = ast::lit_str(s);\n-        ret make_new_lit(p, sp, lit);\n+        ret make_new_lit(cx, sp, lit);\n     }\n \n-    fn make_new_int(parser p, common::span sp, int i) -> @ast::expr {\n+    fn make_new_int(&ext_ctxt cx, common::span sp, int i) -> @ast::expr {\n         auto lit = ast::lit_int(i);\n-        ret make_new_lit(p, sp, lit);\n+        ret make_new_lit(cx, sp, lit);\n     }\n \n-    fn make_new_uint(parser p, common::span sp, uint u) -> @ast::expr {\n+    fn make_new_uint(&ext_ctxt cx, common::span sp, uint u) -> @ast::expr {\n         auto lit = ast::lit_uint(u);\n-        ret make_new_lit(p, sp, lit);\n+        ret make_new_lit(cx, sp, lit);\n     }\n \n-    fn make_add_expr(parser p, common::span sp,\n+    fn make_add_expr(&ext_ctxt cx, common::span sp,\n                      @ast::expr lhs, @ast::expr rhs) -> @ast::expr {\n-        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, p.get_ann());\n+        auto binexpr = ast::expr_binary(ast::add, lhs, rhs, cx.next_ann());\n         ret @rec(node=binexpr, span=sp);\n     }\n \n-    fn make_path_expr(parser p, common::span sp, vec[ast::ident] idents)\n+    fn make_path_expr(&ext_ctxt cx, common::span sp, vec[ast::ident] idents)\n             -> @ast::expr {\n         let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n-        auto pathexpr = ast::expr_path(sp_path, p.get_ann());\n+        auto pathexpr = ast::expr_path(sp_path, cx.next_ann());\n         auto sp_pathexpr = @rec(node=pathexpr, span=sp);\n         ret sp_pathexpr;\n     }\n \n-    fn make_vec_expr(parser p, common::span sp, vec[@ast::expr] exprs)\n+    fn make_vec_expr(&ext_ctxt cx, common::span sp, vec[@ast::expr] exprs)\n             -> @ast::expr {\n-        auto vecexpr = ast::expr_vec(exprs, ast::imm, p.get_ann());\n+        auto vecexpr = ast::expr_vec(exprs, ast::imm, cx.next_ann());\n         auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n         ret sp_vecexpr;\n     }\n \n-    fn make_call(parser p, common::span sp, vec[ast::ident] fn_path,\n+    fn make_call(&ext_ctxt cx, common::span sp, vec[ast::ident] fn_path,\n                  vec[@ast::expr] args) -> @ast::expr {\n-        auto pathexpr = make_path_expr(p, sp, fn_path);\n-        auto callexpr = ast::expr_call(pathexpr, args, p.get_ann());\n+        auto pathexpr = make_path_expr(cx, sp, fn_path);\n+        auto callexpr = ast::expr_call(pathexpr, args, cx.next_ann());\n         auto sp_callexpr = @rec(node=callexpr, span=sp);\n         ret sp_callexpr;\n     }\n \n-    fn make_rec_expr(parser p, common::span sp,\n+    fn make_rec_expr(&ext_ctxt cx, common::span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n         let vec[ast::field] astfields = [];\n         for (tup(ast::ident, @ast::expr) field in fields) {\n@@ -131,7 +132,7 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n \n         auto recexpr = ast::expr_rec(astfields,\n                                     option::none[@ast::expr],\n-                                    p.get_ann());\n+                                    cx.next_ann());\n         auto sp_recexpr = @rec(node=recexpr, span=sp);\n         ret sp_recexpr;\n     }\n@@ -142,17 +143,18 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n         ret [\"std\", \"extfmt\", \"rt\", ident];\n     }\n \n-    fn make_rt_path_expr(parser p, common::span sp, str ident) -> @ast::expr {\n+    fn make_rt_path_expr(&ext_ctxt cx,\n+                         common::span sp, str ident) -> @ast::expr {\n         auto path = make_path_vec(ident);\n-        ret make_path_expr(p, sp, path);\n+        ret make_path_expr(cx, sp, path);\n     }\n \n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n     fn make_rt_conv_expr(&ext_ctxt cx,\n-                         parser p, common::span sp, &conv cnv) -> @ast::expr {\n+                         common::span sp, &conv cnv) -> @ast::expr {\n \n-        fn make_flags(parser p, common::span sp, vec[flag] flags)\n+        fn make_flags(&ext_ctxt cx, common::span sp, vec[flag] flags)\n                 -> @ast::expr {\n             let vec[@ast::expr] flagexprs = [];\n             for (flag f in flags) {\n@@ -174,38 +176,38 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                         fstr = \"flag_alternate\";\n                     }\n                 }\n-                flagexprs += [make_rt_path_expr(p, sp, fstr)];\n+                flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n \n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n             if (vec::len[@ast::expr](flagexprs) == 0u) {\n-                flagexprs += [make_rt_path_expr(p, sp, \"flag_none\")];\n+                flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n \n-            ret make_vec_expr(p, sp, flagexprs);\n+            ret make_vec_expr(cx, sp, flagexprs);\n         }\n \n         fn make_count(&ext_ctxt cx,\n-                      parser p, common::span sp, &count cnt) -> @ast::expr {\n+                      common::span sp, &count cnt) -> @ast::expr {\n             alt (cnt) {\n                 case (count_implied) {\n-                    ret make_rt_path_expr(p, sp, \"count_implied\");\n+                    ret make_rt_path_expr(cx, sp, \"count_implied\");\n                 }\n                 case (count_is(?c)) {\n-                    auto count_lit = make_new_int(p, sp, c);\n+                    auto count_lit = make_new_int(cx, sp, c);\n                     auto count_is_path = make_path_vec(\"count_is\");\n                     auto count_is_args = [count_lit];\n-                    ret make_call(p, sp, count_is_path, count_is_args);\n+                    ret make_call(cx, sp, count_is_path, count_is_args);\n                 }\n                 case (_) {\n                     cx.span_unimpl(sp, \"unimplemented #fmt conversion\");\n                 }\n             }\n         }\n \n-        fn make_ty(parser p, common::span sp, &ty t) -> @ast::expr {\n+        fn make_ty(&ext_ctxt cx, common::span sp, &ty t) -> @ast::expr {\n             auto rt_type;\n             alt (t) {\n                 case (ty_hex(?c)) {\n@@ -229,43 +231,43 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                 }\n             }\n \n-            ret make_rt_path_expr(p, sp, rt_type);\n+            ret make_rt_path_expr(cx, sp, rt_type);\n         }\n \n-        fn make_conv_rec(parser p,\n+        fn make_conv_rec(&ext_ctxt cx,\n                          common::span sp,\n                          @ast::expr flags_expr,\n                          @ast::expr width_expr,\n                          @ast::expr precision_expr,\n                          @ast::expr ty_expr) -> @ast::expr {\n-            ret make_rec_expr(p, sp, [tup(\"flags\", flags_expr),\n+            ret make_rec_expr(cx, sp, [tup(\"flags\", flags_expr),\n                                          tup(\"width\", width_expr),\n                                          tup(\"precision\", precision_expr),\n                                          tup(\"ty\", ty_expr)]);\n         }\n \n-        auto rt_conv_flags = make_flags(p, sp, cnv.flags);\n-        auto rt_conv_width = make_count(cx, p, sp, cnv.width);\n-        auto rt_conv_precision = make_count(cx, p, sp, cnv.precision);\n-        auto rt_conv_ty = make_ty(p, sp, cnv.ty);\n-        ret make_conv_rec(p,\n+        auto rt_conv_flags = make_flags(cx, sp, cnv.flags);\n+        auto rt_conv_width = make_count(cx, sp, cnv.width);\n+        auto rt_conv_precision = make_count(cx, sp, cnv.precision);\n+        auto rt_conv_ty = make_ty(cx, sp, cnv.ty);\n+        ret make_conv_rec(cx,\n                           sp,\n                           rt_conv_flags,\n                           rt_conv_width,\n                           rt_conv_precision,\n                           rt_conv_ty);\n     }\n \n-    fn make_conv_call(&ext_ctxt cx, parser p, common::span sp, str conv_type,\n+    fn make_conv_call(&ext_ctxt cx, common::span sp, str conv_type,\n                       &conv cnv, @ast::expr arg) -> @ast::expr {\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n-        auto cnv_expr = make_rt_conv_expr(cx, p, sp, cnv);\n+        auto cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         auto args = [cnv_expr, arg];\n-        ret make_call(p, arg.span, path, args);\n+        ret make_call(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(&ext_ctxt cx, parser p, common::span sp,\n+    fn make_new_conv(&ext_ctxt cx, common::span sp,\n                      conv cnv, @ast::expr arg) -> @ast::expr {\n \n         // FIXME: Extract all this validation into extfmt::ct\n@@ -343,32 +345,32 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n \n         alt (cnv.ty) {\n             case (ty_str) {\n-                ret make_conv_call(cx, p, arg.span, \"str\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"str\", cnv, arg);\n             }\n             case (ty_int(?sign)) {\n                 alt (sign) {\n                     case (signed) {\n-                        ret make_conv_call(cx, p, arg.span, \"int\", cnv, arg);\n+                        ret make_conv_call(cx, arg.span, \"int\", cnv, arg);\n                     }\n                     case (unsigned) {\n-                        ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n+                        ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n                     }\n                 }\n             }\n             case (ty_bool) {\n-                ret make_conv_call(cx, p, arg.span, \"bool\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"bool\", cnv, arg);\n             }\n             case (ty_char) {\n-                ret make_conv_call(cx, p, arg.span, \"char\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"char\", cnv, arg);\n             }\n             case (ty_hex(_)) {\n-                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n             }\n             case (ty_bits) {\n-                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n             }\n             case (ty_octal) {\n-                ret make_conv_call(cx, p, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n             }\n             case (_) {\n                 cx.span_unimpl(sp, unsupported);\n@@ -470,14 +472,14 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n \n     auto fmt_sp = args.(0).span;\n     auto n = 0u;\n-    auto tmp_expr = make_new_str(p, sp, \"\");\n+    auto tmp_expr = make_new_str(cx, sp, \"\");\n     auto nargs = vec::len[@ast::expr](args);\n \n     for (piece pc in pieces) {\n         alt (pc) {\n             case (piece_string(?s)) {\n-                auto s_expr = make_new_str(p, fmt_sp, s);\n-                tmp_expr = make_add_expr(p, fmt_sp, tmp_expr, s_expr);\n+                auto s_expr = make_new_str(cx, fmt_sp, s);\n+                tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, s_expr);\n             }\n             case (piece_conv(?conv)) {\n                 n += 1u;\n@@ -492,8 +494,8 @@ fn pieces_to_expr(&ext_ctxt cx, parser p, common::span sp,\n                 //log_conv(conv);\n \n                 auto arg_expr = args.(n);\n-                auto c_expr = make_new_conv(cx, p, fmt_sp, conv, arg_expr);\n-                tmp_expr = make_add_expr(p, fmt_sp, tmp_expr, c_expr);\n+                auto c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n+                tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, c_expr);\n             }\n         }\n     }"}]}