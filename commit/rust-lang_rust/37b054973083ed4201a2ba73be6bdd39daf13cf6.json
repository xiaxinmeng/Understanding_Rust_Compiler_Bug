{"sha": "37b054973083ed4201a2ba73be6bdd39daf13cf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YjA1NDk3MzA4M2VkNDIwMWEyYmE3M2JlNmJkZDM5ZGFmMTNjZjY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-20T07:54:42Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-20T07:56:46Z"}, "message": "Add new syntax for patterns that match the head constructor only\n\nAdds a new kind of pattern C(*) where C is a constructor that may\nhave any number of fields. This pattern matches any value\nconstructed with C, without binding names for any of the fields.\n\nCloses #1701.", "tree": {"sha": "842be52963bf339cb1eead62d0fc5935ba22f90f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/842be52963bf339cb1eead62d0fc5935ba22f90f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37b054973083ed4201a2ba73be6bdd39daf13cf6", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37b054973083ed4201a2ba73be6bdd39daf13cf6", "html_url": "https://github.com/rust-lang/rust/commit/37b054973083ed4201a2ba73be6bdd39daf13cf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37b054973083ed4201a2ba73be6bdd39daf13cf6/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "087b12ac297ac9462013b01ccc69097bdf92900c", "url": "https://api.github.com/repos/rust-lang/rust/commits/087b12ac297ac9462013b01ccc69097bdf92900c", "html_url": "https://github.com/rust-lang/rust/commit/087b12ac297ac9462013b01ccc69097bdf92900c"}], "stats": {"total": 149, "additions": 105, "deletions": 44}, "files": [{"sha": "c44de4ed14677569f03d782247aebeff29450bac", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -148,7 +148,8 @@ enum pat_ {\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n     pat_ident(@path, option<@pat>),\n-    pat_enum(@path, [@pat]),\n+    pat_enum(@path, option<[@pat]>), // \"none\" means a * pattern where\n+                                  // we don't bind the fields to names\n     pat_rec([field_pat], bool),\n     pat_tup([@pat]),\n     pat_box(@pat),"}, {"sha": "6a361e73b93b701b3b8842a84d492e4e3fed8eb7", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -779,7 +779,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n                 if vec::is_empty(pats) {\n                     ast::pat_ident(cx.path(v_span, [v_name]), none)\n                 } else {\n-                    ast::pat_enum(cx.path(v_span, [v_name]), pats)\n+                    ast::pat_enum(cx.path(v_span, [v_name]), some(pats))\n                 }\n             },\n "}, {"sha": "237b45408d990b0723f3bb970f4f29f70aef59f7", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -348,7 +348,8 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           }\n           pat_lit(e) { pat_lit(fld.fold_expr(e)) }\n           pat_enum(pth, pats) {\n-            pat_enum(fld.fold_path(pth), vec::map(pats, fld.fold_pat))\n+              pat_enum(fld.fold_path(pth), option::map(pats)\n+                       {|pats| vec::map(pats, fld.fold_pat)})\n           }\n           pat_rec(fields, etc) {\n             let mut fs = [];"}, {"sha": "4131d3eca96a253d5e780a9aaaf19dbfd66dffaa", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -1417,24 +1417,38 @@ fn parse_pat(p: parser) -> @ast::pat {\n         } else {\n             let enum_path = parse_path_and_ty_param_substs(p, true);\n             hi = enum_path.span.hi;\n-            let mut args: [@ast::pat];\n+            let mut args: [@ast::pat] = [];\n+            let mut star_pat = false;\n             alt p.token {\n               token::LPAREN {\n-                let a =\n-                    parse_seq(token::LPAREN, token::RPAREN,\n-                              seq_sep(token::COMMA), parse_pat, p);\n-                args = a.node;\n-                hi = a.span.hi;\n+                alt p.look_ahead(1u) {\n+                  token::BINOP(token::STAR) {\n+                    // This is a \"top constructor only\" pat\n+                    p.bump(); p.bump();\n+                    star_pat = true;\n+                    expect(p, token::RPAREN);\n+                  }\n+                  _ {\n+                   let a =\n+                       parse_seq(token::LPAREN, token::RPAREN,\n+                                seq_sep(token::COMMA), parse_pat, p);\n+                    args = a.node;\n+                    hi = a.span.hi;\n+                  }\n+                }\n               }\n-              _ { args = []; }\n+              _ { }\n             }\n             // at this point, we're not sure whether it's a enum or a bind\n-            if vec::len(args) == 0u &&\n+            if star_pat {\n+                 pat = ast::pat_enum(enum_path, none);\n+            }\n+            else if vec::is_empty(args) &&\n                vec::len(enum_path.node.idents) == 1u {\n                 pat = ast::pat_ident(enum_path, none);\n             }\n             else {\n-                pat = ast::pat_enum(enum_path, args);\n+                pat = ast::pat_enum(enum_path, some(args));\n             }\n         }\n       }"}, {"sha": "2eec0ac87978e36231393a86a4470af076314309", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -1248,16 +1248,21 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         print_path(s, path, true);\n         alt sub {\n           some(p) { word(s.s, \"@\"); print_pat(s, p); }\n-          _ {}\n+          none {}\n         }\n       }\n-      ast::pat_enum(path, args) {\n+      ast::pat_enum(path, args_) {\n         print_path(s, path, true);\n-        if vec::len(args) > 0u {\n-            popen(s);\n-            commasep(s, inconsistent, args, print_pat);\n-            pclose(s);\n-        } else { }\n+        alt args_ {\n+          none { word(s.s, \"(*)\"); }\n+          some(args) {\n+            if vec::len(args) > 0u {\n+              popen(s);\n+              commasep(s, inconsistent, args, print_pat);\n+              pclose(s);\n+            } else { }\n+          }\n+        }\n       }\n       ast::pat_rec(fields, etc) {\n         word(s.s, \"{\");"}, {"sha": "e55d291aa533b0585020527174ac1c832aacae85", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -220,7 +220,8 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_enum(path, children) {\n         visit_path(path, e, v);\n-        for children.each {|child| v.visit_pat(child, e, v); }\n+        option::iter(children) {|children|\n+                for children.each {|child| v.visit_pat(child, e, v); }}\n       }\n       pat_rec(fields, _) {\n         for fields.each {|f| v.visit_pat(f.pat, e, v); }\n@@ -231,7 +232,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n       }\n       pat_ident(path, inner) {\n           visit_path(path, e, v);\n-          option::iter(inner, {|subpat| v.visit_pat(subpat, e, v)});\n+          option::iter(inner) {|subpat| v.visit_pat(subpat, e, v)};\n       }\n       pat_lit(ex) { v.visit_expr(ex, e, v); }\n       pat_range(e1, e2) { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }"}, {"sha": "f48a38e6a89ea2955f7cc17fc073ce9cc4513ac7", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -600,11 +600,11 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n           if !pat_util::pat_is_variant(tcx.def_map, pat) {\n             set += [{id: pat.id, name: path_to_ident(nm), mutbl: mutbl,\n                         span: pat.span}];\n-            alt sub { some(p) { walk(tcx, mutbl, p, set); } _ {} }\n+            option::iter(sub) {|p| walk(tcx, mutbl, p, set); };\n           }\n           ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n-          ast::pat_ident(_, _) {}\n-          ast::pat_enum(_, ps) | ast::pat_tup(ps) {\n+          ast::pat_ident(_, _) | ast::pat_enum(_, none) {}\n+          ast::pat_enum(_, some(ps)) | ast::pat_tup(ps) {\n             for ps.each {|p| walk(tcx, mutbl, p, set); }\n           }\n           ast::pat_rec(fs, _) {"}, {"sha": "62b8350bf30160060f242a446e37b98e07ecd526", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -3,6 +3,7 @@ import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat};\n import middle::const_eval::{compare_lit_exprs, lit_expr_eq};\n import syntax::codemap::span;\n+import syntax::print::pprust::pat_to_str;\n import pat_util::*;\n import syntax::visit;\n import driver::session::session;\n@@ -166,13 +167,22 @@ fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n           def_variant(_, id) {\n             let variant_idx =\n                 option::get(vec::position(*variants, {|v| v.id == id}));\n+            let arg_len = variants[variant_idx].args.len();\n             columns_by_variant[variant_idx].seen = true;\n             alt pat.node {\n-              pat_enum(_, args) {\n+              pat_enum(_, some(args)) {\n                 vec::iteri(args) {|i, p|\n                     columns_by_variant[variant_idx].cols[i] += [p];\n                 }\n               }\n+              pat_enum(_, none) {\n+                  /* (*) pattern -- we fill in n '_' patterns, if the variant\n+                   has n args */\n+                let wild_pat = @{id: tcx.sess.next_node_id(),\n+                                   node: pat_wild, span: pat.span};\n+                uint::range(0u, arg_len) {|i|\n+                    columns_by_variant[variant_idx].cols[i] += [wild_pat]};\n+              }\n               _ {}\n             }\n           }\n@@ -225,9 +235,12 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n       }\n       pat_enum(va, suba) {\n         alt b.node {\n-          pat_enum(vb, subb) {\n+          pat_enum(vb, some(subb)) {\n             tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n-                patterns_supersede(tcx, suba, subb)\n+                alt suba { none { true }\n+                           some(subaa) {\n+                               patterns_supersede(tcx, subaa, subb)\n+                           }}\n           }\n           _ { false }\n         }\n@@ -310,10 +323,11 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n         for elts.each {|elt| if is_refutable(tcx, elt) { ret true; } }\n         false\n       }\n-      pat_enum(_, args) {\n-        for args.each {|p| if is_refutable(tcx, p) { ret true; } }\n+      pat_enum(_, some(args)) {\n+        for args.each {|p| if is_refutable(tcx, p) { ret true; } };\n         false\n       }\n+      pat_enum(_,_) { false }\n     }\n }\n "}, {"sha": "4ecfd343ce97d50afa4fa009ead0dc9564632aed", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -56,9 +56,10 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     alt pat.node {\n       pat_ident(pth, some(p)) { walk_pat(p, it); }\n       pat_rec(fields, _) { for fields.each {|f| walk_pat(f.pat, it); } }\n-      pat_enum(_, s) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n+      pat_enum(_, some(s)) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n       pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n-      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, none) {}\n+      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _)\n+        | pat_enum(_, _) {}\n     }\n }\n "}, {"sha": "fa3ac25c796aa53a5a8b2662c1d64db8fc9f3b6d", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -163,7 +163,8 @@ fn enter_opt(tcx: ty::ctxt, m: match, opt: opt, col: uint,\n     enter_match(tcx.def_map, m, col, val) {|p|\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n-            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some(subpats) }\n+            if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+              some(option::get_or_default(subpats, [])) }\n             else { none }\n           }\n           ast::pat_ident(_, none) if pat_is_variant(tcx.def_map, p) {\n@@ -700,16 +701,15 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let mut i = 0;\n-        for vec::each(args.vals) {|argval|\n+        option::iter(sub) {|sub| for vec::each(args.vals) {|argval|\n             bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n-        }\n+        }}\n       }\n       ast::pat_rec(fields, _) {\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n         for vec::each(fields) {|f|\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n-            // how to get rid of this check?\n             let fldptr = GEPi(bcx, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }"}, {"sha": "18997266d81b84da6530952d1f524fa174c95650", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -2046,7 +2046,7 @@ fn universally_quantify_before_call(fcx: @fn_ctxt,\n }\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n-                     subpats: [@ast::pat], expected: ty::t) {\n+                     subpats: option<[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -2075,8 +2075,9 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                     tcx, v_def_ids.enm, v_def_ids.var);\n             vinfo.args.map { |t| ty::subst(tcx, expected_substs, t) }\n         };\n-\n-        let subpats_len = subpats.len(), arg_len = arg_types.len();\n+        let arg_len = arg_types.len(), subpats_len = alt subpats {\n+            none { arg_len }\n+            some(ps) { ps.len() }};\n         if arg_len > 0u {\n             // N-ary variant.\n             if arg_len != subpats_len {\n@@ -2089,9 +2090,11 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n-            vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n-                check_pat(pcx, subpat, arg_ty);\n-            }\n+            option::iter(subpats) {|pats|\n+                vec::iter2(pats, arg_types) {|subpat, arg_ty|\n+                  check_pat(pcx, subpat, arg_ty);\n+                }\n+            };\n         } else if subpats_len > 0u {\n             tcx.sess.span_fatal\n                 (pat.span, #fmt[\"this pattern has %u field%s, \\\n@@ -2159,8 +2162,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ {}\n         }\n       }\n-      ast::pat_ident(path, _) {\n-        check_pat_variant(pcx, pat, path, [], expected);\n+      ast::pat_ident(path, c) {\n+        check_pat_variant(pcx, pat, path, some([]), expected);\n       }\n       ast::pat_enum(path, subpats) {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n@@ -3885,7 +3888,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     }) {\n         ccx.tcx.sess.span_err(sp, \"illegal recursive enum type. \\\n                                    wrap the inner value in a box to \\\n-                                   make it represenable\");\n+                                   make it representable\");\n     }\n \n     // Check that it is possible to instantiate this enum:"}, {"sha": "b3b364c80901eacca4b200ad7f2e6ce4944bd02a", "filename": "src/test/run-pass/issue-1701.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b054973083ed4201a2ba73be6bdd39daf13cf6/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=37b054973083ed4201a2ba73be6bdd39daf13cf6", "patch": "@@ -0,0 +1,21 @@\n+enum pattern { tabby, tortoiseshell, calico }\n+enum breed { beagle, rottweiler, pug }\n+type name = str;\n+enum ear_kind { lop, upright }\n+enum animal { cat(pattern), dog(breed), rabbit(name, ear_kind), tiger }\n+\n+fn noise(a: animal) -> option<str> {\n+    alt a {\n+      cat(*)    { some(\"meow\") }\n+      dog(*)    { some(\"woof\") }\n+      rabbit(*) { none }\n+      tiger(*)  { some(\"roar\") }\n+    }\n+}\n+\n+fn main() {\n+    assert noise(cat(tabby)) == some(\"meow\");\n+    assert noise(dog(pug)) == some(\"woof\");\n+    assert noise(rabbit(\"Hilbert\", upright)) == none;\n+    assert noise(tiger) == some(\"roar\");\n+}\n\\ No newline at end of file"}]}