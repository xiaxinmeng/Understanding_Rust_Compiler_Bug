{"sha": "dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZGYzZDYyYzFiZDMwZTg5NmQ1NDM3NGY0OWVkODBhMWExMzQ4ZTU=", "commit": {"author": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-03-30T03:06:42Z"}, "committer": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-03-30T03:06:42Z"}, "message": "Plumb obligations through librustc/infer", "tree": {"sha": "6a650561615eaa50a9465040e4d98ea4e3db3d06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a650561615eaa50a9465040e4d98ea4e3db3d06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "html_url": "https://github.com/rust-lang/rust/commit/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/comments", "author": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "committer": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce", "html_url": "https://github.com/rust-lang/rust/commit/0c07a3cc599b0a88c35b5c1bd3fc92fa6925e4ce"}], "stats": {"total": 381, "additions": 274, "deletions": 107}, "files": [{"sha": "6df8f076f32e8155820ce774db7b1c47d21ad624", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -37,7 +37,7 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::{InferCtxt};\n+use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n@@ -46,6 +46,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,6 +57,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n+    pub obligations: PredicateObligations<'tcx>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "5540046c9e36345f4a082f8ebbb6ec72c5aa2a88", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{EqTo};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n         Equate { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {"}, {"sha": "37717c2b6bc99dab3541b2106b9720b358773552", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n         Glb { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {"}, {"sha": "32b2fe911e86dda8375c4d552faeaf019b1859e2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n         Lub { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {"}, {"sha": "6e97cdef3d7ca4a5bdc81cbab62ce0495f51dc97", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 59, "deletions": 35, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -27,13 +27,13 @@ use middle::region::CodeExtent;\n use ty::subst;\n use ty::subst::Substs;\n use ty::subst::Subst;\n-use traits::{self, ProjectionMode};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n@@ -63,6 +63,12 @@ pub mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+pub struct InferOk<'tcx, T> {\n+    pub value: T,\n+    pub obligations: PredicateObligations<'tcx>,\n+}\n+pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n+\n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n@@ -391,16 +397,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           origin: TypeOrigin,\n                           a: Ty<'tcx>,\n                           b: Ty<'tcx>)\n-                          -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_subty({:?} <: {:?})\", a, b);\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n-pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                              a: Ty<'tcx>,\n-                              b: Ty<'tcx>)\n-                              -> UnitResult<'tcx> {\n+pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+    -> UnitResult<'tcx>\n+{\n     debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n@@ -412,7 +417,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n }\n \n pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> UnitResult<'tcx>\n+    -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -432,7 +437,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: TypeOrigin,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n-                         -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n     cx.eq_types(a_is_expected, origin, a, b)\n@@ -443,7 +448,7 @@ pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   origin: TypeOrigin,\n                                   a: ty::TraitRef<'tcx>,\n                                   b: ty::TraitRef<'tcx>)\n-                                  -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n     cx.eq_trait_refs(a_is_expected, origin, a, b)\n@@ -454,7 +459,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                         origin: TypeOrigin,\n                                         a: ty::PolyTraitRef<'tcx>,\n                                         b: ty::PolyTraitRef<'tcx>)\n-                                        -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n     cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n@@ -465,7 +470,7 @@ pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                     origin: TypeOrigin,\n                                     a: &ty::ImplHeader<'tcx>,\n                                     b: &ty::ImplHeader<'tcx>)\n-                                    -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n     match (a.trait_ref, b.trait_ref) {\n@@ -661,39 +666,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> CombineFields<'a, 'tcx> {\n-        CombineFields {infcx: self,\n-                       a_is_expected: a_is_expected,\n-                       trace: trace,\n-                       cause: None}\n+        -> CombineFields<'a, 'tcx>\n+    {\n+        CombineFields {\n+            infcx: self,\n+            a_is_expected: a_is_expected,\n+            trace: trace,\n+            cause: None,\n+            obligations: PredicateObligations::new(),\n+        }\n     }\n \n     pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).equate().relate(a, b)\n+        let mut equate = self.combine_fields(a_is_expected, trace).equate();\n+        let result = equate.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: equate.obligations() })\n     }\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).sub().relate(a, b)\n+        let mut sub = self.combine_fields(a_is_expected, trace).sub();\n+        let result = sub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: sub.obligations() })\n     }\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).lub().relate(a, b)\n+        let mut lub = self.combine_fields(a_is_expected, trace).lub();\n+        let result = lub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: lub.obligations() })\n     }\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).glb().relate(a, b)\n+        let mut glb = self.combine_fields(a_is_expected, trace).glb();\n+        let result = glb.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: glb.obligations() })\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -829,12 +846,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      origin: TypeOrigin,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-                     -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b)\n+                .map(|InferOk { obligations, .. }| InferOk { value: (), obligations: obligations })\n         })\n     }\n \n@@ -843,11 +861,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     origin: TypeOrigin,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n-                    -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b)\n+                .map(|InferOk { obligations, .. }| InferOk { value: (), obligations: obligations })\n         })\n     }\n \n@@ -856,7 +875,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           origin: TypeOrigin,\n                           a: ty::TraitRef<'tcx>,\n                           b: ty::TraitRef<'tcx>)\n-                          -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} <: {:?})\",\n                a,\n@@ -866,7 +885,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b)\n+                .map(|InferOk { obligations, .. }| InferOk { value: (), obligations: obligations })\n         })\n     }\n \n@@ -875,7 +895,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n-                               -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n                a,\n@@ -885,7 +905,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b)\n+                .map(|InferOk { obligations, .. }| InferOk { value: (), obligations: obligations })\n         })\n     }\n \n@@ -928,20 +949,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n-                              -> UnitResult<'tcx> {\n+        -> InferResult<'tcx, ()>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let () = mk_eqty(self, false, origin, a, b)?;\n+            let InferOk { obligations, .. } = mk_eqty(self, false, origin, a, b)?;\n             self.leak_check(&skol_map, snapshot)\n+                .map(|_| InferOk { value: (), obligations: obligations })\n         })\n     }\n \n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n-                                     -> UnitResult<'tcx> {\n+        -> UnitResult<'tcx>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);"}, {"sha": "ece8c0c696af83ad35acc7646a447bda1f118204", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -27,6 +28,10 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n     pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n         Sub { fields: f }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {"}, {"sha": "68173bc9ea513cc81601333effde3b234a8041a4", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use infer::InferCtxt;\n+use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n use std::iter;\n@@ -526,7 +526,11 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(()) => Ok(Some(Vec::new())),\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#????) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    Ok(Some(Vec::new()))\n+                },\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n         }"}, {"sha": "85fe457c75e8cfd7a16fd39428ff44d9b82ea5b1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -24,7 +24,7 @@ use super::VtableImplData;\n use super::util;\n \n use middle::def_id::DefId;\n-use infer::{self, TypeOrigin};\n+use infer::{self, InferOk, TypeOrigin};\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -232,7 +232,11 @@ fn project_and_unify_type<'cx,'tcx>(\n     let infcx = selcx.infcx();\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n-        Ok(()) => Ok(Some(obligations)),\n+        Ok(InferOk { obligations: inferred_obligations, .. }) => {\n+            // FIXME(#????) propagate obligations\n+            assert!(inferred_obligations.is_empty());\n+            Ok(Some(obligations))\n+        },\n         Err(err) => Err(MismatchedProjectionTypes { err: err }),\n     }\n }\n@@ -278,7 +282,10 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n             let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n-                Ok(()) => { }\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#????) propagate obligations\n+                    assert!(obligations.is_empty());\n+                }\n                 Err(_) => { /* ignore errors */ }\n             }\n         }\n@@ -829,7 +836,10 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n                                               data_poly_trait_ref,\n-                                              obligation_poly_trait_ref).is_ok()\n+                                              obligation_poly_trait_ref)\n+                        // FIXME(#????) propagate obligations\n+                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+                        .is_ok()\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n@@ -1082,7 +1092,10 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n                               origin,\n                               obligation.predicate.trait_ref.clone(),\n                               projection.projection_ty.trait_ref.clone()) {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#????) propagate obligations\n+            assert!(obligations.is_empty());\n+        }\n         Err(e) => {\n             selcx.tcx().sess.span_bug(\n                 obligation.cause.span,"}, {"sha": "013c75bf8d2bbc3eefcd46abe79a804193ff80ad", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::def_id::DefId;\n use infer;\n-use infer::{InferCtxt, TypeFreshener, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n use ty::subst::{Subst, Substs, TypeSpace};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n@@ -484,7 +484,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n-                    Ok(()) => EvaluatedToOk,\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#????) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        EvaluatedToOk\n+                    },\n                     Err(_) => EvaluatedToErr\n                 }\n             }\n@@ -1185,7 +1189,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              origin,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n-            Ok(()) => { }\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#????) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n             Err(_) => { return false; }\n         }\n \n@@ -2494,13 +2501,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n \n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             expected_trait_ref.clone(),\n-                                             obligation_trait_ref.clone()) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       expected_trait_ref.clone(),\n+                                       obligation_trait_ref.clone())\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n@@ -2531,9 +2538,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_trait, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#????) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2596,9 +2605,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, a, b).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, a, b)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#????) propagate obligations\n+                assert!(obligations.is_empty());\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2654,9 +2665,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_struct, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#????) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(util::predicate_for_trait_def(tcx,\n@@ -2742,13 +2755,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_obligation_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        if let Err(e) = self.infcx.eq_trait_refs(false,\n-                                                 origin,\n-                                                 impl_trait_ref.value.clone(),\n-                                                 skol_obligation_trait_ref) {\n-            debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-            return Err(());\n-        }\n+        let InferOk { obligations, .. } =\n+            self.infcx.eq_trait_refs(false,\n+                                     origin,\n+                                     impl_trait_ref.value.clone(),\n+                                     skol_obligation_trait_ref)\n+            .map_err(|e| {\n+                debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n+                ()\n+            })?;\n+        // FIXME(#????) propagate obligations\n+        assert!(obligations.is_empty());\n \n         if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2811,13 +2828,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                poly_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             poly_trait_ref,\n-                                             obligation.predicate.to_poly_trait_ref()) {\n-            Ok(()) => Ok(()),\n-            Err(_) => Err(()),\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       poly_trait_ref,\n+                                       obligation.predicate.to_poly_trait_ref())\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|_| ())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "00569d50cbb9c4dff75e497d4d65829530c68b21", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -24,8 +24,8 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::relate::{TypeRelation, RelateResult};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::ty::relate::TypeRelation;\n+use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n@@ -355,17 +355,17 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.sub(true, trace, t1, t2)\n     }\n \n-    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.lub(true, trace, t1, t2)\n     }\n \n-    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.glb(true, trace, t1, t2)\n     }\n@@ -374,7 +374,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(&t1, &t2) {\n-            Ok(_) => {}\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+            }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n             }\n@@ -395,7 +398,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub(&t1, &t2) {\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n@@ -411,7 +417,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_glb);\n \n                 // sanity check for good measure:"}, {"sha": "3f85a3e1d461827ff1334afe8662bc117e458872", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -12,7 +12,7 @@\n #![allow(unreachable_code)]\n \n use rustc::dep_graph::DepNode;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -338,13 +338,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     {\n         infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                         sup, sub)\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n         infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                        a, b)\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn tcx(&self) -> &'a TyCtxt<'tcx> {"}, {"sha": "dcbfa2bb79b6c04ac4652533bdbd8b74cb6d40eb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def::{self, Def};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use rustc::ty::subst::Substs;\n@@ -532,7 +532,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         let result = if is_if_let_fallback {\n-            fcx.infcx().eq_types(true, origin, arm_ty, result_ty).map(|_| arm_ty)\n+            fcx.infcx().eq_types(true, origin, arm_ty, result_ty)\n+                .map(|InferOk { obligations, .. }| {\n+                    // FIXME(#????) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    arm_ty\n+                })\n         } else if i == 0 {\n             // Special-case the first arm, as it has no \"previous expressions\".\n             coercion::try(fcx, &arm.body, coerce_first)"}, {"sha": "a4d8e2ae049381eab60a75422b2081a8191fd2c5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use rustc::infer::{Coercion, TypeOrigin, TypeTrace};\n+use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n use rustc::traits::{predicate_for_trait_def, report_selection_error};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -118,8 +118,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n                 infcx.lub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#????) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             } else {\n                 infcx.sub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#????) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             }\n         })\n     }\n@@ -656,12 +666,22 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)?;\n+            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)\n+                .map(|InferOk { value, obligations }| {\n+                    // FIXME(#????) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    value\n+                })?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#????) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 }).map(|s| fcx.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n@@ -725,6 +745,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         if !noop {\n             return fcx.infcx().commit_if_ok(|_| {\n                 fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#????) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             });\n         }\n     }\n@@ -737,6 +762,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n             } else {\n                 fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#????) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             }\n         }"}, {"sha": "5f49b0335d929cde9c21fdf7ca280a0d8ce453ab", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n@@ -475,7 +475,10 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n     });\n \n     match err {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#????) propagate obligations\n+            assert!(obligations.is_empty())\n+        }\n         Err(terr) => {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,"}, {"sha": "75f6b11a229314d95bd0a59561e1bcc76d0b0ca4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -11,7 +11,7 @@\n \n use check::{coercion, FnCtxt};\n use rustc::ty::Ty;\n-use rustc::infer::TypeOrigin;\n+use rustc::infer::{InferOk, TypeOrigin};\n \n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -21,16 +21,28 @@ use rustc_front::hir;\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                          expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().sub_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().sub_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#????) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().eq_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().eq_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#????) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n "}, {"sha": "44dbcd051e201275fccf20ca00ceffa27a0edd34", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -20,8 +20,7 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer;\n-use rustc::infer::{InferCtxt, TypeOrigin};\n+use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use rustc_front::hir;\n@@ -1135,6 +1134,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n         self.infcx().sub_types(false, TypeOrigin::Misc(DUMMY_SP), sub, sup)\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {"}, {"sha": "625e59c6e3c631c6d9a87028db6a6bf9d933b9af", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -88,8 +88,7 @@ use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n-use rustc::infer;\n-use rustc::infer::{TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferOk, TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n@@ -1629,6 +1628,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sup: Ty<'tcx>)\n                     -> Result<(), TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_eqty(&self,\n@@ -1638,6 +1639,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    sup: Ty<'tcx>)\n                    -> Result<(), TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#????) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_subr(&self,\n@@ -1916,7 +1919,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     match infer::mk_eqty(self.infcx(), false,\n                                                          TypeOrigin::Misc(default.origin_span),\n                                                          ty, default.ty) {\n-                                        Ok(()) => {}\n+                                        Ok(InferOk { obligations, .. }) => {\n+                                            // FIXME(#????) propagate obligations\n+                                            assert!(obligations.is_empty())\n+                                        },\n                                         Err(_) => {\n                                             conflicts.push((*ty, default));\n                                         }\n@@ -2009,7 +2015,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             match infer::mk_eqty(self.infcx(), false,\n                                                  TypeOrigin::Misc(default.origin_span),\n                                                  ty, default.ty) {\n-                                Ok(()) => {}\n+                                // FIXME(#????) propagate obligations\n+                                Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n                                 Err(_) => {\n                                     result = Some(default);\n                                 }\n@@ -2776,8 +2783,10 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n-                if let Err(e) = ures {\n-                    return Err(e);\n+                match ures {\n+                    // FIXME(#????) propagate obligations\n+                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Err(e) => return Err(e),\n                 }\n \n                 // Record all the argument types, with the substitutions\n@@ -2905,13 +2914,23 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.infcx().commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n                     fcx.infcx().lub(true, trace, &then_ty, &else_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#????) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             };\n             (origin, then_ty, else_ty, result)\n         } else {\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n-             fcx.infcx().eq_types(true, origin, unit, then_ty).map(|_| unit))\n+             fcx.infcx().eq_types(true, origin, unit, then_ty)\n+                 .map(|InferOk { obligations, .. }| {\n+                     // FIXME(#????) propagate obligations\n+                     assert!(obligations.is_empty());\n+                     unit\n+                 }))\n         };\n \n         let if_ty = match result {"}, {"sha": "515a898699e0c4e67392fa8ba136a040fefa526e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcdf3d62c1bd30e896d54374f49ed80a1a1348e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=dcdf3d62c1bd30e896d54374f49ed80a1a1348e5", "patch": "@@ -92,7 +92,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferCtxt, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, InferCtxt, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n use middle::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1846,7 +1846,11 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), ty, outlives.0) {\n-                    Ok(()) => { Ok(outlives.1) }\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#????) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        Ok(outlives.1)\n+                    }\n                     Err(_) => { Err(()) }\n                 }\n             });"}]}