{"sha": "0c720f6e6bb5269f18732273cb26ee1a1416fc22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNzIwZjZlNmJiNTI2OWYxODczMjI3M2NiMjZlZTFhMTQxNmZjMjI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-23T07:03:58Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-23T07:03:58Z"}, "message": "Split terminator evaluation into a new module.", "tree": {"sha": "d89ab69b1fbb73852956ff13077bd46ffb6efd7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d89ab69b1fbb73852956ff13077bd46ffb6efd7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c720f6e6bb5269f18732273cb26ee1a1416fc22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c720f6e6bb5269f18732273cb26ee1a1416fc22", "html_url": "https://github.com/rust-lang/rust/commit/0c720f6e6bb5269f18732273cb26ee1a1416fc22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c720f6e6bb5269f18732273cb26ee1a1416fc22/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d80cf91ef2b9e17218299906def9f02750abd050", "url": "https://api.github.com/repos/rust-lang/rust/commits/d80cf91ef2b9e17218299906def9f02750abd050", "html_url": "https://github.com/rust-lang/rust/commit/d80cf91ef2b9e17218299906def9f02750abd050"}], "stats": {"total": 1307, "additions": 665, "deletions": 642}, "files": [{"sha": "7b65d5f645742e8eedf00831e25d6096f349729c", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 40, "deletions": 642, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/0c720f6e6bb5269f18732273cb26ee1a1416fc22/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c720f6e6bb5269f18732273cb26ee1a1416fc22/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=0c720f6e6bb5269f18732273cb26ee1a1416fc22", "patch": "@@ -2,28 +2,27 @@ use rustc::middle::const_val;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n-use rustc::traits::{self, ProjectionMode};\n-use rustc::ty::fold::TypeFoldable;\n+use rustc::traits::ProjectionMode;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n-use std::{iter, mem};\n+use std::iter;\n use syntax::ast;\n-use syntax::attr;\n-use syntax::codemap::{self, DUMMY_SP, Span};\n+use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer, FunctionDefinition};\n+use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n use std::collections::HashMap;\n \n mod step;\n+mod terminator;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -218,87 +217,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n-    }\n-\n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n-        // Do the initial selection for the obligation. This yields the shallow result we are\n-        // looking for -- that is, what specific impl.\n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-            let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-                trait_ref.to_poly_trait_predicate(),\n-            );\n-            let selection = selcx.select(&obligation).unwrap().unwrap();\n-\n-            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n-            // This is because they can inform the inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n-        })\n-    }\n-\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method(\n-        &self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n-        let method_item = self.tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(substs);\n-                let substs = self.tcx.mk_substs(impl_substs);\n-                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n-\n-                (mth.method.def_id, mth.substs)\n-            }\n-\n-            traits::VtableClosure(vtable_closure) =>\n-                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n-\n-            traits::VtableFnPointer(_fn_ty) => {\n-                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                unimplemented!()\n-                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-\n-                // let method_ty = def_ty(tcx, def_id, substs);\n-                // let fn_ptr_ty = match method_ty.sty {\n-                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                //     _ => unreachable!(\"expected fn item type, found {}\",\n-                //                       method_ty)\n-                // };\n-                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-            }\n-\n-            traits::VtableObject(ref _data) => {\n-                unimplemented!()\n-                // Callee {\n-                //     data: Virtual(traits::get_vtable_index_of_object_method(\n-                //                   tcx, data, def_id)),\n-                //                   ty: def_ty(tcx, def_id, substs)\n-                // }\n-            }\n-            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n-    }\n-\n     fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n         use rustc_trans::back::symbol_names::def_id_to_string;\n         match self.tcx.map.as_local_node_id(def_id) {\n@@ -384,297 +306,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // TODO(solson): Deallocate local variables.\n     }\n \n-    fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n-            -> EvalResult<'tcx, ()> {\n-        use rustc::mir::repr::TerminatorKind::*;\n-        match terminator.kind {\n-            Return => self.pop_stack_frame(),\n-\n-            Goto { target } => {\n-                self.frame_mut().block = target;\n-            },\n-\n-            If { ref cond, targets: (then_target, else_target) } => {\n-                let cond_ptr = self.eval_operand(cond)?;\n-                let cond_val = self.memory.read_bool(cond_ptr)?;\n-                self.frame_mut().block = if cond_val { then_target } else { else_target };\n-            }\n-\n-            SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n-                let discr_ty = self.lvalue_ty(discr);\n-                let discr_size = self\n-                    .type_layout(discr_ty)\n-                    .size(&self.tcx.data_layout)\n-                    .bytes() as usize;\n-                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n-                if let ty::TyChar = discr_ty.sty {\n-                    if ::std::char::from_u32(discr_val as u32).is_none() {\n-                        return Err(EvalError::InvalidChar(discr_val as u32));\n-                    }\n-                }\n-\n-                // Branch to the `otherwise` case by default, if no match is found.\n-                let mut target_block = targets[targets.len() - 1];\n-\n-                for (index, val_const) in values.iter().enumerate() {\n-                    let ptr = self.const_to_ptr(val_const)?;\n-                    let val = self.memory.read_uint(ptr, discr_size)?;\n-                    if discr_val == val {\n-                        target_block = targets[index];\n-                        break;\n-                    }\n-                }\n-\n-                self.frame_mut().block = target_block;\n-            }\n-\n-            Switch { ref discr, ref targets, adt_def } => {\n-                let adt_ptr = self.eval_lvalue(discr)?.to_ptr();\n-                let adt_ty = self.lvalue_ty(discr);\n-                let discr_val = self.read_discriminant_value(adt_ptr, adt_ty)?;\n-                let matching = adt_def.variants.iter()\n-                    .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n-\n-                match matching {\n-                    Some(i) => {\n-                        self.frame_mut().block = targets[i];\n-                    },\n-                    None => return Err(EvalError::InvalidDiscriminant),\n-                }\n-            }\n-\n-            Call { ref func, ref args, ref destination, .. } => {\n-                let mut return_ptr = None;\n-                if let Some((ref lv, target)) = *destination {\n-                    self.frame_mut().block = target;\n-                    return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n-                }\n-\n-                let func_ty = self.operand_ty(func);\n-                match func_ty.sty {\n-                    ty::TyFnPtr(bare_fn_ty) => {\n-                        let ptr = self.eval_operand(func)?;\n-                        assert_eq!(ptr.offset, 0);\n-                        let fn_ptr = self.memory.read_ptr(ptr)?;\n-                        let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n-                        if fn_ty != bare_fn_ty {\n-                            return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n-                        }\n-                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n-                                          terminator.source_info.span)?\n-                    },\n-                    ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n-                                          terminator.source_info.span)?\n-                    }\n-\n-                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n-                }\n-            }\n-\n-            Drop { ref location, target, .. } => {\n-                let ptr = self.eval_lvalue(location)?.to_ptr();\n-                let ty = self.lvalue_ty(location);\n-                self.drop(ptr, ty)?;\n-                self.frame_mut().block = target;\n-            }\n-\n-            Assert { ref cond, expected, ref msg, target, .. } => {\n-                let cond_ptr = self.eval_operand(cond)?;\n-                if expected == self.memory.read_bool(cond_ptr)? {\n-                    self.frame_mut().block = target;\n-                } else {\n-                    return match *msg {\n-                        mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand(len).expect(\"can't eval len\");\n-                            let len = self.memory.read_usize(len).expect(\"can't read len\");\n-                            let index = self.eval_operand(index).expect(\"can't eval index\");\n-                            let index = self.memory.read_usize(index).expect(\"can't read index\");\n-                            Err(EvalError::ArrayIndexOutOfBounds(terminator.source_info.span, len, index))\n-                        },\n-                        mir::AssertMessage::Math(ref err) => Err(EvalError::Math(terminator.source_info.span, err.clone())),\n-                    }\n-                }\n-            },\n-\n-            DropAndReplace { .. } => unimplemented!(),\n-            Resume => unimplemented!(),\n-            Unreachable => unimplemented!(),\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn eval_fn_call(\n-        &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        fn_ty: &'tcx BareFnTy,\n-        return_ptr: Option<Pointer>,\n-        args: &[mir::Operand<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, ()> {\n-        use syntax::abi::Abi;\n-        match fn_ty.abi {\n-            Abi::RustIntrinsic => {\n-                let name = self.tcx.item_name(def_id).as_str();\n-                match fn_ty.sig.0.output {\n-                    ty::FnConverging(ty) => {\n-                        let layout = self.type_layout(ty);\n-                        let ret = return_ptr.unwrap();\n-                        self.call_intrinsic(&name, substs, args, ret, layout)\n-                    }\n-                    ty::FnDiverging => unimplemented!(),\n-                }\n-            }\n-\n-            Abi::C => {\n-                match fn_ty.sig.0.output {\n-                    ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty);\n-                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n-                    }\n-                    ty::FnDiverging => unimplemented!(),\n-                }\n-            }\n-\n-            Abi::Rust | Abi::RustCall => {\n-                // TODO(solson): Adjust the first argument when calling a Fn or\n-                // FnMut closure via FnOnce::call_once.\n-\n-                // Only trait methods can have a Self parameter.\n-                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n-                    self.trait_method(def_id, substs)\n-                } else {\n-                    (def_id, substs)\n-                };\n-\n-                let mut arg_srcs = Vec::new();\n-                for arg in args {\n-                    let src = self.eval_operand(arg)?;\n-                    let src_ty = self.operand_ty(arg);\n-                    arg_srcs.push((src, src_ty));\n-                }\n-\n-                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n-                    arg_srcs.pop();\n-                    let last_arg = args.last().unwrap();\n-                    let last = self.eval_operand(last_arg)?;\n-                    let last_ty = self.operand_ty(last_arg);\n-                    let last_layout = self.type_layout(last_ty);\n-                    match (&last_ty.sty, last_layout) {\n-                        (&ty::TyTuple(fields),\n-                         &Layout::Univariant { ref variant, .. }) => {\n-                            let offsets = iter::once(0)\n-                                .chain(variant.offset_after_field.iter()\n-                                    .map(|s| s.bytes()));\n-                            for (offset, ty) in offsets.zip(fields) {\n-                                let src = last.offset(offset as isize);\n-                                arg_srcs.push((src, ty));\n-                            }\n-                        }\n-                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-                    }\n-                }\n-\n-                let mir = self.load_mir(resolved_def_id);\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n-\n-                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n-                    let dest = self.frame().locals[i];\n-                    self.move_(src, dest, src_ty)?;\n-                }\n-\n-                Ok(())\n-            }\n-\n-            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n-        }\n-    }\n-\n-    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n-        if !self.type_needs_drop(ty) {\n-            debug!(\"no need to drop {:?}\", ty);\n-            return Ok(());\n-        }\n-        trace!(\"-need to drop {:?}\", ty);\n-\n-        // TODO(solson): Call user-defined Drop::drop impls.\n-\n-        match ty.sty {\n-            ty::TyBox(contents_ty) => {\n-                match self.memory.read_ptr(ptr) {\n-                    Ok(contents_ptr) => {\n-                        self.drop(contents_ptr, contents_ty)?;\n-                        trace!(\"-deallocating box\");\n-                        self.memory.deallocate(contents_ptr)?;\n-                    }\n-                    Err(EvalError::ReadBytesAsPointer) => {\n-                        let size = self.memory.pointer_size;\n-                        let possible_drop_fill = self.memory.read_bytes(ptr, size)?;\n-                        if possible_drop_fill.iter().all(|&b| b == mem::POST_DROP_U8) {\n-                            return Ok(());\n-                        } else {\n-                            return Err(EvalError::ReadBytesAsPointer);\n-                        }\n-                    }\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            // TODO(solson): Implement drop for other relevant types (e.g. aggregates).\n-            _ => {}\n-        }\n-\n-        // Filling drop.\n-        // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n-        let size = self.type_size(ty);\n-        self.memory.drop_fill(ptr, size)?;\n-\n-        Ok(())\n-    }\n-\n-    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n-        use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty);\n-\n-        let discr_val = match *adt_layout {\n-            General { discr, .. } | CEnum { discr, .. } => {\n-                let discr_size = discr.size().bytes();\n-                self.memory.read_uint(adt_ptr, discr_size as usize)?\n-            }\n-\n-            RawNullablePointer { nndiscr, .. } => {\n-                self.read_nonnull_discriminant_value(adt_ptr, nndiscr)?\n-            }\n-\n-            StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes() as isize);\n-                self.read_nonnull_discriminant_value(nonnull, nndiscr)?\n-            }\n-\n-            // The discriminant_value intrinsic returns 0 for non-sum types.\n-            Array { .. } | FatPointer { .. } | Scalar { .. } | Univariant { .. } |\n-            Vector { .. } => 0,\n-        };\n-\n-        Ok(discr_val)\n-    }\n-\n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<'tcx, u64> {\n-        let not_null = match self.memory.read_usize(ptr) {\n-            Ok(0) => false,\n-            Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n-            Err(e) => return Err(e),\n-        };\n-        assert!(nndiscr == 0 || nndiscr == 1);\n-        Ok(if not_null { nndiscr } else { 1 - nndiscr })\n-    }\n-\n-    /// applies the binary operation `op` to the two operands and writes a tuple of the result\n-    /// and a boolean signifying the potential overflow to the destination\n+    /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n+    /// and a boolean signifying the potential overflow to the destination.\n     fn intrinsic_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n@@ -716,199 +349,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(overflow)\n     }\n \n-    fn call_intrinsic(\n-        &mut self,\n-        name: &str,\n-        substs: &'tcx Substs<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n-        dest_layout: &'tcx Layout,\n-    ) -> EvalResult<'tcx, ()> {\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args_ptrs = args_res?;\n-\n-        let pointer_size = self.memory.pointer_size;\n-\n-        match name {\n-            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n-            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n-            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n-\n-            // FIXME: turn into an assertion to catch wrong `assume` that would cause UB in llvm\n-            \"assume\" => {}\n-\n-            \"copy_nonoverlapping\" => {\n-                let elem_ty = *substs.types.get(subst::FnSpace, 0);\n-                let elem_size = self.type_size(elem_ty);\n-                let src = self.memory.read_ptr(args_ptrs[0])?;\n-                let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                let count = self.memory.read_isize(args_ptrs[2])?;\n-                self.memory.copy(src, dest, count as usize * elem_size)?;\n-            }\n-\n-            \"discriminant_value\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, 8)?;\n-            }\n-\n-            \"forget\" => {\n-                let arg_ty = *substs.types.get(subst::FnSpace, 0);\n-                let arg_size = self.type_size(arg_ty);\n-                self.memory.drop_fill(args_ptrs[0], arg_size)?;\n-            }\n-\n-            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n-\n-            \"min_align_of\" => {\n-                // FIXME: use correct value\n-                self.memory.write_int(dest, 1, pointer_size)?;\n-            }\n-\n-            \"move_val_init\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n-                self.move_(args_ptrs[1], ptr, ty)?;\n-            }\n-\n-            \"offset\" => {\n-                let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args_ptrs[0];\n-                let offset = self.memory.read_isize(args_ptrs[1])?;\n-\n-                match self.memory.read_ptr(ptr_arg) {\n-                    Ok(ptr) => {\n-                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                        self.memory.write_ptr(dest, result_ptr)?;\n-                    }\n-                    Err(EvalError::ReadBytesAsPointer) => {\n-                        let addr = self.memory.read_isize(ptr_arg)?;\n-                        let result_addr = addr + offset * pointee_size as i64;\n-                        self.memory.write_isize(dest, result_addr)?;\n-                    }\n-                    Err(e) => return Err(e),\n-                }\n-            }\n-\n-            \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n-            }\n-            \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n-            }\n-            \"overflowing_add\" => {\n-                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, pointer_size)?;\n-            }\n-\n-            \"size_of_val\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, pointer_size)?;\n-                } else {\n-                    match ty.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size as isize;\n-                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n-                        }\n-\n-                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n-                    }\n-                }\n-            }\n-\n-            \"transmute\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                self.move_(args_ptrs[0], dest, ty)?;\n-            }\n-            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n-\n-            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        args: &[mir::Operand<'tcx>],\n-        dest: Pointer,\n-        dest_size: usize,\n-    ) -> EvalResult<'tcx, ()> {\n-        let name = self.tcx.item_name(def_id);\n-        let attrs = self.tcx.get_attrs(def_id);\n-        let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n-            Some(ln) => ln.clone(),\n-            None => name.as_str(),\n-        };\n-\n-        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        match &link_name[..] {\n-            \"__rust_allocate\" => {\n-                let size = self.memory.read_usize(args[0])?;\n-                let ptr = self.memory.allocate(size as usize);\n-                self.memory.write_ptr(dest, ptr)?;\n-            }\n-\n-            \"__rust_reallocate\" => {\n-                let ptr = self.memory.read_ptr(args[0])?;\n-                let size = self.memory.read_usize(args[2])?;\n-                self.memory.reallocate(ptr, size as usize)?;\n-                self.memory.write_ptr(dest, ptr)?;\n-            }\n-\n-            \"memcmp\" => {\n-                let left = self.memory.read_ptr(args[0])?;\n-                let right = self.memory.read_ptr(args[1])?;\n-                let n = self.memory.read_usize(args[2])? as usize;\n-\n-                let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n-\n-                    use std::cmp::Ordering::*;\n-                    match left_bytes.cmp(right_bytes) {\n-                        Less => -1,\n-                        Equal => 0,\n-                        Greater => 1,\n-                    }\n-                };\n-\n-                self.memory.write_int(dest, result, dest_size)?;\n-            }\n-\n-            _ => {\n-                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n-            }\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-\n     fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n         dest: Pointer,\n@@ -1468,80 +908,6 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct ImplMethod<'tcx> {\n-    pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub is_provided: bool,\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impl_def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-    name: ast::Name,\n-) -> ImplMethod<'tcx> {\n-    assert!(!substs.types.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n-        Some(node_item) => {\n-            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs: substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}\n-\n-// TODO(solson): Upstream these methods into rustc::ty::layout.\n-\n-trait IntegerExt {\n-    fn size(self) -> Size;\n-}\n-\n-impl IntegerExt for layout::Integer {\n-    fn size(self) -> Size {\n-        use rustc::ty::layout::Integer::*;\n-        match self {\n-            I1 | I8 => Size::from_bits(8),\n-            I16 => Size::from_bits(16),\n-            I32 => Size::from_bits(32),\n-            I64 => Size::from_bits(64),\n-        }\n-    }\n-}\n-\n-trait StructExt {\n-    fn field_offset(&self, index: usize) -> Size;\n-}\n-\n-impl StructExt for layout::Struct {\n-    fn field_offset(&self, index: usize) -> Size {\n-        if index == 0 {\n-            Size::from_bytes(0)\n-        } else {\n-            self.offset_after_field[index - 1]\n-        }\n-    }\n-}\n-\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n@@ -1603,3 +969,35 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n     }\n     err.emit();\n }\n+\n+// TODO(solson): Upstream these methods into rustc::ty::layout.\n+\n+trait IntegerExt {\n+    fn size(self) -> Size;\n+}\n+\n+impl IntegerExt for layout::Integer {\n+    fn size(self) -> Size {\n+        use rustc::ty::layout::Integer::*;\n+        match self {\n+            I1 | I8 => Size::from_bits(8),\n+            I16 => Size::from_bits(16),\n+            I32 => Size::from_bits(32),\n+            I64 => Size::from_bits(64),\n+        }\n+    }\n+}\n+\n+trait StructExt {\n+    fn field_offset(&self, index: usize) -> Size;\n+}\n+\n+impl StructExt for layout::Struct {\n+    fn field_offset(&self, index: usize) -> Size {\n+        if index == 0 {\n+            Size::from_bytes(0)\n+        } else {\n+            self.offset_after_field[index - 1]\n+        }\n+    }\n+}"}, {"sha": "3d7bef825b9006999191a8f6c68b8fcbd62b9785", "filename": "src/interpreter/terminator.rs", "status": "added", "additions": 625, "deletions": 0, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/0c720f6e6bb5269f18732273cb26ee1a1416fc22/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c720f6e6bb5269f18732273cb26ee1a1416fc22/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=0c720f6e6bb5269f18732273cb26ee1a1416fc22", "patch": "@@ -0,0 +1,625 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::repr as mir;\n+use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::layout::Layout;\n+use rustc::ty::subst::{self, Substs};\n+use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n+use std::rc::Rc;\n+use std::{iter, mem};\n+use syntax::{ast, attr};\n+use syntax::codemap::{DUMMY_SP, Span};\n+\n+use super::{EvalContext, IntegerExt};\n+use error::{EvalError, EvalResult};\n+use memory::{Pointer, FunctionDefinition};\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn eval_terminator(\n+        &mut self,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        use rustc::mir::repr::TerminatorKind::*;\n+        match terminator.kind {\n+            Return => self.pop_stack_frame(),\n+\n+            Goto { target } => {\n+                self.frame_mut().block = target;\n+            },\n+\n+            If { ref cond, targets: (then_target, else_target) } => {\n+                let cond_ptr = self.eval_operand(cond)?;\n+                let cond_val = self.memory.read_bool(cond_ptr)?;\n+                self.frame_mut().block = if cond_val { then_target } else { else_target };\n+            }\n+\n+            SwitchInt { ref discr, ref values, ref targets, .. } => {\n+                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n+                let discr_ty = self.lvalue_ty(discr);\n+                let discr_size = self\n+                    .type_layout(discr_ty)\n+                    .size(&self.tcx.data_layout)\n+                    .bytes() as usize;\n+                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n+                if let ty::TyChar = discr_ty.sty {\n+                    if ::std::char::from_u32(discr_val as u32).is_none() {\n+                        return Err(EvalError::InvalidChar(discr_val as u32));\n+                    }\n+                }\n+\n+                // Branch to the `otherwise` case by default, if no match is found.\n+                let mut target_block = targets[targets.len() - 1];\n+\n+                for (index, val_const) in values.iter().enumerate() {\n+                    let ptr = self.const_to_ptr(val_const)?;\n+                    let val = self.memory.read_uint(ptr, discr_size)?;\n+                    if discr_val == val {\n+                        target_block = targets[index];\n+                        break;\n+                    }\n+                }\n+\n+                self.frame_mut().block = target_block;\n+            }\n+\n+            Switch { ref discr, ref targets, adt_def } => {\n+                let adt_ptr = self.eval_lvalue(discr)?.to_ptr();\n+                let adt_ty = self.lvalue_ty(discr);\n+                let discr_val = self.read_discriminant_value(adt_ptr, adt_ty)?;\n+                let matching = adt_def.variants.iter()\n+                    .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n+\n+                match matching {\n+                    Some(i) => {\n+                        self.frame_mut().block = targets[i];\n+                    },\n+                    None => return Err(EvalError::InvalidDiscriminant),\n+                }\n+            }\n+\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let mut return_ptr = None;\n+                if let Some((ref lv, target)) = *destination {\n+                    self.frame_mut().block = target;\n+                    return_ptr = Some(self.eval_lvalue(lv)?.to_ptr());\n+                }\n+\n+                let func_ty = self.operand_ty(func);\n+                match func_ty.sty {\n+                    ty::TyFnPtr(bare_fn_ty) => {\n+                        let ptr = self.eval_operand(func)?;\n+                        assert_eq!(ptr.offset, 0);\n+                        let fn_ptr = self.memory.read_ptr(ptr)?;\n+                        let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        if fn_ty != bare_fn_ty {\n+                            return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n+                        }\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n+                    },\n+                    ty::TyFnDef(def_id, substs, fn_ty) => {\n+                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n+                    }\n+\n+                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n+                }\n+            }\n+\n+            Drop { ref location, target, .. } => {\n+                let ptr = self.eval_lvalue(location)?.to_ptr();\n+                let ty = self.lvalue_ty(location);\n+                self.drop(ptr, ty)?;\n+                self.frame_mut().block = target;\n+            }\n+\n+            Assert { ref cond, expected, ref msg, target, .. } => {\n+                let cond_ptr = self.eval_operand(cond)?;\n+                if expected == self.memory.read_bool(cond_ptr)? {\n+                    self.frame_mut().block = target;\n+                } else {\n+                    return match *msg {\n+                        mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                            let len = self.eval_operand(len).expect(\"can't eval len\");\n+                            let len = self.memory.read_usize(len).expect(\"can't read len\");\n+                            let index = self.eval_operand(index).expect(\"can't eval index\");\n+                            let index = self.memory.read_usize(index).expect(\"can't read index\");\n+                            Err(EvalError::ArrayIndexOutOfBounds(terminator.source_info.span, len, index))\n+                        },\n+                        mir::AssertMessage::Math(ref err) => Err(EvalError::Math(terminator.source_info.span, err.clone())),\n+                    }\n+                }\n+            },\n+\n+            DropAndReplace { .. } => unimplemented!(),\n+            Resume => unimplemented!(),\n+            Unreachable => unimplemented!(),\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn eval_fn_call(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        fn_ty: &'tcx BareFnTy,\n+        return_ptr: Option<Pointer>,\n+        args: &[mir::Operand<'tcx>],\n+        span: Span,\n+    ) -> EvalResult<'tcx, ()> {\n+        use syntax::abi::Abi;\n+        match fn_ty.abi {\n+            Abi::RustIntrinsic => {\n+                let name = self.tcx.item_name(def_id).as_str();\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let layout = self.type_layout(ty);\n+                        let ret = return_ptr.unwrap();\n+                        self.call_intrinsic(&name, substs, args, ret, layout)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::C => {\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty);\n+                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::Rust | Abi::RustCall => {\n+                // TODO(solson): Adjust the first argument when calling a Fn or\n+                // FnMut closure via FnOnce::call_once.\n+\n+                // Only trait methods can have a Self parameter.\n+                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n+                    self.trait_method(def_id, substs)\n+                } else {\n+                    (def_id, substs)\n+                };\n+\n+                let mut arg_srcs = Vec::new();\n+                for arg in args {\n+                    let src = self.eval_operand(arg)?;\n+                    let src_ty = self.operand_ty(arg);\n+                    arg_srcs.push((src, src_ty));\n+                }\n+\n+                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n+                    arg_srcs.pop();\n+                    let last_arg = args.last().unwrap();\n+                    let last = self.eval_operand(last_arg)?;\n+                    let last_ty = self.operand_ty(last_arg);\n+                    let last_layout = self.type_layout(last_ty);\n+                    match (&last_ty.sty, last_layout) {\n+                        (&ty::TyTuple(fields),\n+                         &Layout::Univariant { ref variant, .. }) => {\n+                            let offsets = iter::once(0)\n+                                .chain(variant.offset_after_field.iter()\n+                                    .map(|s| s.bytes()));\n+                            for (offset, ty) in offsets.zip(fields) {\n+                                let src = last.offset(offset as isize);\n+                                arg_srcs.push((src, ty));\n+                            }\n+                        }\n+                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n+                    }\n+                }\n+\n+                let mir = self.load_mir(resolved_def_id);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+\n+                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                    let dest = self.frame().locals[i];\n+                    self.move_(src, dest, src_ty)?;\n+                }\n+\n+                Ok(())\n+            }\n+\n+            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        }\n+    }\n+\n+    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n+        use rustc::ty::layout::Layout::*;\n+        let adt_layout = self.type_layout(adt_ty);\n+\n+        let discr_val = match *adt_layout {\n+            General { discr, .. } | CEnum { discr, .. } => {\n+                let discr_size = discr.size().bytes();\n+                self.memory.read_uint(adt_ptr, discr_size as usize)?\n+            }\n+\n+            RawNullablePointer { nndiscr, .. } => {\n+                self.read_nonnull_discriminant_value(adt_ptr, nndiscr)?\n+            }\n+\n+            StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+                let offset = self.nonnull_offset(adt_ty, nndiscr, discrfield)?;\n+                let nonnull = adt_ptr.offset(offset.bytes() as isize);\n+                self.read_nonnull_discriminant_value(nonnull, nndiscr)?\n+            }\n+\n+            // The discriminant_value intrinsic returns 0 for non-sum types.\n+            Array { .. } | FatPointer { .. } | Scalar { .. } | Univariant { .. } |\n+            Vector { .. } => 0,\n+        };\n+\n+        Ok(discr_val)\n+    }\n+\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64) -> EvalResult<'tcx, u64> {\n+        let not_null = match self.memory.read_usize(ptr) {\n+            Ok(0) => false,\n+            Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n+            Err(e) => return Err(e),\n+        };\n+        assert!(nndiscr == 0 || nndiscr == 1);\n+        Ok(if not_null { nndiscr } else { 1 - nndiscr })\n+    }\n+\n+    fn call_intrinsic(\n+        &mut self,\n+        name: &str,\n+        substs: &'tcx Substs<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Pointer,\n+        dest_layout: &'tcx Layout,\n+    ) -> EvalResult<'tcx, ()> {\n+        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args_ptrs = args_res?;\n+\n+        let pointer_size = self.memory.pointer_size;\n+\n+        match name {\n+            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n+            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n+            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n+\n+            // FIXME: turn into an assertion to catch wrong `assume` that would cause UB in llvm\n+            \"assume\" => {}\n+\n+            \"copy_nonoverlapping\" => {\n+                let elem_ty = *substs.types.get(subst::FnSpace, 0);\n+                let elem_size = self.type_size(elem_ty);\n+                let src = self.memory.read_ptr(args_ptrs[0])?;\n+                let dest = self.memory.read_ptr(args_ptrs[1])?;\n+                let count = self.memory.read_isize(args_ptrs[2])?;\n+                self.memory.copy(src, dest, count as usize * elem_size)?;\n+            }\n+\n+            \"discriminant_value\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n+                self.memory.write_uint(dest, discr_val, 8)?;\n+            }\n+\n+            \"forget\" => {\n+                let arg_ty = *substs.types.get(subst::FnSpace, 0);\n+                let arg_size = self.type_size(arg_ty);\n+                self.memory.drop_fill(args_ptrs[0], arg_size)?;\n+            }\n+\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n+\n+            \"min_align_of\" => {\n+                // FIXME: use correct value\n+                self.memory.write_int(dest, 1, pointer_size)?;\n+            }\n+\n+            \"move_val_init\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], ptr, ty)?;\n+            }\n+\n+            \"offset\" => {\n+                let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n+                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let ptr_arg = args_ptrs[0];\n+                let offset = self.memory.read_isize(args_ptrs[1])?;\n+\n+                match self.memory.read_ptr(ptr_arg) {\n+                    Ok(ptr) => {\n+                        let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                        self.memory.write_ptr(dest, result_ptr)?;\n+                    }\n+                    Err(EvalError::ReadBytesAsPointer) => {\n+                        let addr = self.memory.read_isize(ptr_arg)?;\n+                        let result_addr = addr + offset * pointee_size as i64;\n+                        self.memory.write_isize(dest, result_addr)?;\n+                    }\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            \"overflowing_sub\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_mul\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_add\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                let size = self.type_size(ty) as u64;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n+            }\n+\n+            \"size_of_val\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                if self.type_is_sized(ty) {\n+                    let size = self.type_size(ty) as u64;\n+                    self.memory.write_uint(dest, size, pointer_size)?;\n+                } else {\n+                    match ty.sty {\n+                        ty::TySlice(_) | ty::TyStr => {\n+                            let elem_ty = ty.sequence_element_type(self.tcx);\n+                            let elem_size = self.type_size(elem_ty) as u64;\n+                            let ptr_size = self.memory.pointer_size as isize;\n+                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n+                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n+                        }\n+\n+                        _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n+                    }\n+                }\n+            }\n+\n+            \"transmute\" => {\n+                let ty = *substs.types.get(subst::FnSpace, 0);\n+                self.move_(args_ptrs[0], dest, ty)?;\n+            }\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n+\n+            name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        Ok(())\n+    }\n+\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Pointer,\n+        dest_size: usize,\n+    ) -> EvalResult<'tcx, ()> {\n+        let name = self.tcx.item_name(def_id);\n+        let attrs = self.tcx.get_attrs(def_id);\n+        let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n+            Some(ln) => ln.clone(),\n+            None => name.as_str(),\n+        };\n+\n+        let args_res: EvalResult<Vec<Pointer>> = args.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        if link_name.starts_with(\"pthread_\") {\n+            warn!(\"ignoring C ABI call: {}\", link_name);\n+            return Ok(());\n+        }\n+\n+        match &link_name[..] {\n+            \"__rust_allocate\" => {\n+                let size = self.memory.read_usize(args[0])?;\n+                let ptr = self.memory.allocate(size as usize);\n+                self.memory.write_ptr(dest, ptr)?;\n+            }\n+\n+            \"__rust_reallocate\" => {\n+                let ptr = self.memory.read_ptr(args[0])?;\n+                let size = self.memory.read_usize(args[2])?;\n+                self.memory.reallocate(ptr, size as usize)?;\n+                self.memory.write_ptr(dest, ptr)?;\n+            }\n+\n+            \"memcmp\" => {\n+                let left = self.memory.read_ptr(args[0])?;\n+                let right = self.memory.read_ptr(args[1])?;\n+                let n = self.memory.read_usize(args[2])? as usize;\n+\n+                let result = {\n+                    let left_bytes = self.memory.read_bytes(left, n)?;\n+                    let right_bytes = self.memory.read_bytes(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                self.memory.write_int(dest, result, dest_size)?;\n+            }\n+\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        Ok(())\n+    }\n+\n+    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+        // Do the initial selection for the obligation. This yields the shallow result we are\n+        // looking for -- that is, what specific impl.\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+            let obligation = traits::Obligation::new(\n+                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                trait_ref.to_poly_trait_predicate(),\n+            );\n+            let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+            // This is because they can inform the inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n+        })\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    fn trait_method(\n+        &self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> (DefId, &'tcx Substs<'tcx>) {\n+        let method_item = self.tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n+        match self.fulfill_obligation(trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = self.tcx.item_name(def_id);\n+                // Create a concatenated set of substitutions which includes those from the impl\n+                // and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(substs);\n+                let substs = self.tcx.mk_substs(impl_substs);\n+                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n+\n+                (mth.method.def_id, mth.substs)\n+            }\n+\n+            traits::VtableClosure(vtable_closure) =>\n+                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n+\n+            traits::VtableFnPointer(_fn_ty) => {\n+                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                unimplemented!()\n+                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                // let method_ty = def_ty(tcx, def_id, substs);\n+                // let fn_ptr_ty = match method_ty.sty {\n+                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                //     _ => unreachable!(\"expected fn item type, found {}\",\n+                //                       method_ty)\n+                // };\n+                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+\n+            traits::VtableObject(ref _data) => {\n+                unimplemented!()\n+                // Callee {\n+                //     data: Virtual(traits::get_vtable_index_of_object_method(\n+                //                   tcx, data, def_id)),\n+                //                   ty: def_ty(tcx, def_id, substs)\n+                // }\n+            }\n+            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n+        }\n+    }\n+\n+    pub(super) fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+    }\n+\n+    fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n+        if !self.type_needs_drop(ty) {\n+            debug!(\"no need to drop {:?}\", ty);\n+            return Ok(());\n+        }\n+        trace!(\"-need to drop {:?}\", ty);\n+\n+        // TODO(solson): Call user-defined Drop::drop impls.\n+\n+        match ty.sty {\n+            ty::TyBox(contents_ty) => {\n+                match self.memory.read_ptr(ptr) {\n+                    Ok(contents_ptr) => {\n+                        self.drop(contents_ptr, contents_ty)?;\n+                        trace!(\"-deallocating box\");\n+                        self.memory.deallocate(contents_ptr)?;\n+                    }\n+                    Err(EvalError::ReadBytesAsPointer) => {\n+                        let size = self.memory.pointer_size;\n+                        let possible_drop_fill = self.memory.read_bytes(ptr, size)?;\n+                        if possible_drop_fill.iter().all(|&b| b == mem::POST_DROP_U8) {\n+                            return Ok(());\n+                        } else {\n+                            return Err(EvalError::ReadBytesAsPointer);\n+                        }\n+                    }\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            // TODO(solson): Implement drop for other relevant types (e.g. aggregates).\n+            _ => {}\n+        }\n+\n+        // Filling drop.\n+        // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n+        let size = self.type_size(ty);\n+        self.memory.drop_fill(ptr, size)?;\n+\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ImplMethod<'tcx> {\n+    method: Rc<ty::Method<'tcx>>,\n+    substs: &'tcx Substs<'tcx>,\n+    is_provided: bool,\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+fn get_impl_method<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impl_def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+    name: ast::Name,\n+) -> ImplMethod<'tcx> {\n+    assert!(!substs.types.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                let substs = traits::translate_substs(&infcx, impl_def_id,\n+                                                      substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            ImplMethod {\n+                method: node_item.item,\n+                substs: substs,\n+                is_provided: node_item.node.is_from_trait(),\n+            }\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n+        }\n+    }\n+}"}]}