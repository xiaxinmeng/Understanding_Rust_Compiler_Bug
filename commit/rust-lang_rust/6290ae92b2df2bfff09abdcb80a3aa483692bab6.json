{"sha": "6290ae92b2df2bfff09abdcb80a3aa483692bab6", "node_id": "C_kwDOAAsO6NoAKDYyOTBhZTkyYjJkZjJiZmZmMDlhYmRjYjgwYTNhYTQ4MzY5MmJhYjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-27T21:48:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-27T21:48:10Z"}, "message": "Auto merge of #108487 - cjgillot:no-typeck-mir, r=oli-obk\n\nAvoid invoking typeck from borrowck\n\nThis PR attempts to reduce direct dependencies between typeck and MIR-related queries. The goal is to have all the information transit either through THIR or through dedicated queries that avoid depending on the whole `TypeckResults`.\n\nIn a first commit, we store the type information that MIR building requires into THIR. This avoids edges between mir_built and typeck.\n\nIn the second and third commit, we wrap informations around closures (upvars, kind origin and user-provided signature) to avoid borrowck depending on typeck information.\n\nThere should be a single remaining borrowck -> typeck edge in the good path, due to inline consts.", "tree": {"sha": "8e49fd876e7847ee39461e51a00d197e4b1c5c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e49fd876e7847ee39461e51a00d197e4b1c5c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6290ae92b2df2bfff09abdcb80a3aa483692bab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6290ae92b2df2bfff09abdcb80a3aa483692bab6", "html_url": "https://github.com/rust-lang/rust/commit/6290ae92b2df2bfff09abdcb80a3aa483692bab6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6290ae92b2df2bfff09abdcb80a3aa483692bab6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7281249a19a9755e9d889ee251ec323629caadab", "url": "https://api.github.com/repos/rust-lang/rust/commits/7281249a19a9755e9d889ee251ec323629caadab", "html_url": "https://github.com/rust-lang/rust/commit/7281249a19a9755e9d889ee251ec323629caadab"}, {"sha": "cb51d2da7a590d230e8eae8e580ed8e8dee72bd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb51d2da7a590d230e8eae8e580ed8e8dee72bd6", "html_url": "https://github.com/rust-lang/rust/commit/cb51d2da7a590d230e8eae8e580ed8e8dee72bd6"}], "stats": {"total": 430, "additions": 223, "deletions": 207}, "files": [{"sha": "cb97699d7d2ec49ffe2078da991fa6c6da481b0c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -236,10 +236,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck(id.expect_local());\n-                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-\n-                    tables.closure_kind_origins().get(hir_id).is_none()\n+                    self.infcx.tcx.closure_kind_origin(id.expect_local()).is_none()\n                 }\n                 _ => true,\n             };\n@@ -1670,27 +1667,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            let fn_hir_id = self.mir_hir_id();\n             err.span_label(\n                 drop_span,\n                 format!(\n                     \"...but `{}` will be dropped here, when the {} returns\",\n                     name,\n                     self.infcx\n                         .tcx\n-                        .hir()\n-                        .opt_name(fn_hir_id)\n+                        .opt_item_name(self.mir_def_id().to_def_id())\n                         .map(|name| format!(\"function `{}`\", name))\n                         .unwrap_or_else(|| {\n-                            match &self\n-                                .infcx\n-                                .tcx\n-                                .typeck(self.mir_def_id())\n-                                .node_type(fn_hir_id)\n-                                .kind()\n-                            {\n-                                ty::Closure(..) => \"enclosing closure\",\n-                                ty::Generator(..) => \"enclosing generator\",\n+                            match &self.infcx.tcx.def_kind(self.mir_def_id()) {\n+                                DefKind::Closure => \"enclosing closure\",\n+                                DefKind::Generator => \"enclosing generator\",\n                                 kind => bug!(\"expected closure or generator, found {:?}\", kind),\n                             }\n                             .to_string()"}, {"sha": "a99fd594a07a77441386e4246f48d3cf1579a95d", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -115,11 +115,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n-                        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                        if let Some((span, hir_place)) =\n-                            self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                        {\n+                        if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                             diag.span_note(\n                                 *span,\n                                 &format!(\n@@ -139,11 +135,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n-                let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                if let Some((span, hir_place)) =\n-                    self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                {\n+                if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                     diag.span_note(\n                         *span,\n                         &format!(\n@@ -373,14 +365,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     //\n                     // We know the field exists so it's safe to call operator[] and `unwrap` here.\n                     let def_id = def_id.expect_local();\n-                    let var_id = self\n-                        .infcx\n-                        .tcx\n-                        .typeck(def_id)\n-                        .closure_min_captures_flattened(def_id)\n-                        .nth(field.index())\n-                        .unwrap()\n-                        .get_root_variable();\n+                    let var_id =\n+                        self.infcx.tcx.closure_captures(def_id)[field.index()].get_root_variable();\n \n                     Some(self.infcx.tcx.hir().name(var_id).to_string())\n                 }\n@@ -987,7 +973,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = expr {\n             for (captured_place, place) in\n-                self.infcx.tcx.typeck(def_id).closure_min_captures_flattened(def_id).zip(places)\n+                self.infcx.tcx.closure_captures(def_id).iter().zip(places)\n             {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)"}, {"sha": "328ac880dd4519d7e777bb7c13200cad0d03ba6d", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -901,10 +901,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n     ) {\n         let tables = tcx.typeck(closure_local_def_id);\n-        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n-        if let Some((span, closure_kind_origin)) =\n-            &tables.closure_kind_origins().get(closure_hir_id)\n-        {\n+        if let Some((span, closure_kind_origin)) = tcx.closure_kind_origin(closure_local_def_id) {\n             let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;"}, {"sha": "0f591460e9d195348790afb76929f76fa446aa2d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -202,14 +202,14 @@ fn do_mir_borrowck<'tcx>(\n     let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(e) = tables.tainted_by_errors {\n+    if let Some(e) = input_body.tainted_by_errors {\n         infcx.set_tainted_by_errors(e);\n         errors.set_tainted_by_errors(e);\n     }\n-    let upvars: Vec<_> = tables\n-        .closure_min_captures_flattened(def.did)\n-        .map(|captured_place| {\n+    let upvars: Vec<_> = tcx\n+        .closure_captures(def.did)\n+        .iter()\n+        .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,"}, {"sha": "717020ea5b89428bd196a56c6db01ac5f90af738", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -26,11 +26,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n             return;\n         }\n-        let Some(user_provided_poly_sig) =\n-            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n-        else {\n-            return;\n-        };\n+        let user_provided_poly_sig = self.tcx().closure_user_provided_sig(mir_def_id);\n \n         // Instantiate the canonicalized variables from user-provided signature\n         // (e.g., the `_` in the code above) with fresh variables."}, {"sha": "15d7613a812deed5d74d9ae928f1216381aa4523", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -18,7 +18,7 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{BodyOwnerKind, HirId};\n+use rustc_hir::BodyOwnerKind;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -231,9 +231,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(mir_def.did);\n-        UniversalRegionsBuilder { infcx, mir_def, mir_hir_id, param_env }.build()\n+        UniversalRegionsBuilder { infcx, mir_def, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -390,7 +388,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n-    mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -560,12 +557,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         match tcx.hir().body_owner_kind(self.mir_def.did) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-                    tcx.type_of(typeck_root_def_id).subst_identity()\n-                } else {\n-                    let tables = tcx.typeck(self.mir_def.did);\n-                    tables.node_type(self.mir_hir_id)\n-                };\n+                let defining_ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n \n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n@@ -594,7 +586,18 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n                     DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n                 } else {\n-                    let ty = tcx.typeck(self.mir_def.did).node_type(self.mir_hir_id);\n+                    // FIXME this line creates a dependency between borrowck and typeck.\n+                    //\n+                    // This is required for `AscribeUserType` canonical query, which will call\n+                    // `type_of(inline_const_def_id)`. That `type_of` would inject erased lifetimes\n+                    // into borrowck, which is ICE #78174.\n+                    //\n+                    // As a workaround, inline consts have an additional generic param (`ty`\n+                    // below), so that `type_of(inline_const_def_id).substs(substs)` uses the\n+                    // proper type with NLL infer vars.\n+                    let ty = tcx\n+                        .typeck(self.mir_def.did)\n+                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def.did));\n                     let substs = InlineConstSubsts::new(\n                         tcx,\n                         InlineConstSubstsParts { parent_substs: identity_substs, ty },"}, {"sha": "f7881c5096021d6f710afcac1634e41d29284ef6", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -240,10 +240,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME this should be more descriptive i.e. CapturePlace instead of CapturedVar\n                 // https://github.com/rust-lang/project-rfc-2229/issues/46\n                 if let Some(local_def_id) = def_id.as_local() {\n-                    let tables = self.ecx.tcx.typeck(local_def_id);\n-                    if let Some(captured_place) =\n-                        tables.closure_min_captures_flattened(local_def_id).nth(field)\n-                    {\n+                    let captures = self.ecx.tcx.closure_captures(local_def_id);\n+                    if let Some(captured_place) = captures.get(field) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         let var_hir_id = captured_place.get_root_variable();"}, {"sha": "3e27a78135e499653faa97ecf16ca8789fec6777", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -526,10 +526,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n+            let var_ident = self.tcx.hir().ident(var_hir_id);\n \n             let Some(min_cap_list) = root_var_min_capture_list.get_mut(&var_hir_id) else {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let min_cap_list = vec![ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: capture_info,\n                     mutability,\n@@ -628,6 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !ancestor_found {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n                 let captured_place = ty::CapturedPlace {\n+                    var_ident,\n                     place,\n                     info: updated_capture_info,\n                     mutability,"}, {"sha": "62e44b6298baa16522755d5eaa0fe9900cf62c1a", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -116,6 +116,7 @@ macro_rules! arena_types {\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n+            [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n         ]);\n     )\n }"}, {"sha": "4b5bacac8149c8b591512fb31d9febf1b824e63e", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -902,6 +902,11 @@ impl<'hir> Map<'hir> {\n         self.opt_ident(id).map(|ident| ident.span)\n     }\n \n+    #[inline]\n+    pub fn ident(self, id: HirId) -> Ident {\n+        self.opt_ident(id).unwrap()\n+    }\n+\n     #[inline]\n     pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         self.opt_ident(id).map(|ident| ident.name)"}, {"sha": "8fe5586723d00c6426cdd7c9ea797c935f27d049", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -475,14 +475,10 @@ rustc_queries! {\n         }\n     }\n \n-    query symbols_for_closure_captures(\n-        key: (LocalDefId, LocalDefId)\n-    ) -> &'tcx Vec<rustc_span::Symbol> {\n-        arena_cache\n+    query closure_typeinfo(key: LocalDefId) -> ty::ClosureTypeInfo<'tcx> {\n         desc {\n-            |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n-            tcx.def_path_str(key.1.to_def_id()),\n-            tcx.def_path_str(key.0.to_def_id())\n+            |tcx| \"finding symbols for captures of closure `{}`\",\n+            tcx.def_path_str(key.to_def_id())\n         }\n     }\n "}, {"sha": "2b3601bec7bb373eba0ea3ea752dd19c9f2581e8", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::AllocId;\n use rustc_middle::mir::{self, BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp};\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtDef, Ty, UpvarSubsts};\n+use rustc_middle::ty::{self, AdtDef, FnSig, Ty, UpvarSubsts};\n use rustc_middle::ty::{CanonicalUserType, CanonicalUserTypeAnnotation};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -32,7 +32,12 @@ use std::ops::Index;\n pub mod visit;\n \n macro_rules! thir_with_elements {\n-    ($($name:ident: $id:ty => $value:ty => $format:literal,)*) => {\n+    (\n+        $($field_name:ident: $field_ty:ty,)*\n+\n+    @elements:\n+        $($name:ident: $id:ty => $value:ty => $format:literal,)*\n+    ) => {\n         $(\n             newtype_index! {\n                 #[derive(HashStable)]\n@@ -46,14 +51,20 @@ macro_rules! thir_with_elements {\n         /// This can be indexed directly by any THIR index (e.g. [`ExprId`]).\n         #[derive(Debug, HashStable, Clone)]\n         pub struct Thir<'tcx> {\n+            $(\n+                pub $field_name: $field_ty,\n+            )*\n             $(\n                 pub $name: IndexVec<$id, $value>,\n             )*\n         }\n \n         impl<'tcx> Thir<'tcx> {\n-            pub fn new() -> Thir<'tcx> {\n+            pub fn new($($field_name: $field_ty,)*) -> Thir<'tcx> {\n                 Thir {\n+                    $(\n+                        $field_name,\n+                    )*\n                     $(\n                         $name: IndexVec::new(),\n                     )*\n@@ -75,13 +86,22 @@ macro_rules! thir_with_elements {\n pub const UPVAR_ENV_PARAM: ParamId = ParamId::from_u32(0);\n \n thir_with_elements! {\n+    body_type: BodyTy<'tcx>,\n+\n+@elements:\n     arms: ArmId => Arm<'tcx> => \"a{}\",\n     blocks: BlockId => Block => \"b{}\",\n     exprs: ExprId => Expr<'tcx> => \"e{}\",\n     stmts: StmtId => Stmt<'tcx> => \"s{}\",\n     params: ParamId => Param<'tcx> => \"p{}\",\n }\n \n+#[derive(Debug, HashStable, Clone)]\n+pub enum BodyTy<'tcx> {\n+    Const(Ty<'tcx>),\n+    Fn(FnSig<'tcx>),\n+}\n+\n /// Description of a type-checked function parameter.\n #[derive(Clone, Debug, HashStable)]\n pub struct Param<'tcx> {"}, {"sha": "dc2bd54b7fe484687eb6e23d9d4038d63a8d21fa", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -5,10 +5,10 @@ use crate::{mir, ty};\n \n use std::fmt::Write;\n \n-use hir::LangItem;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::{self as hir, LangItem};\n+use rustc_span::symbol::Ident;\n use rustc_span::{Span, Symbol};\n \n use super::{Ty, TyCtxt};\n@@ -129,6 +129,9 @@ impl<'tcx> ClosureKind {\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct CapturedPlace<'tcx> {\n+    /// Name and span where the binding happens.\n+    pub var_ident: Ident,\n+\n     /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n \n@@ -148,12 +151,8 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n \n     /// Returns a symbol of the captured upvar, which looks like `name__field1__field2`.\n-    fn to_symbol(&self, tcx: TyCtxt<'tcx>) -> Symbol {\n-        let hir_id = match self.place.base {\n-            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-            base => bug!(\"Expected an upvar, found {:?}\", base),\n-        };\n-        let mut symbol = tcx.hir().name(hir_id).as_str().to_string();\n+    pub fn to_symbol(&self) -> Symbol {\n+        let mut symbol = self.var_ident.to_string();\n \n         let mut ty = self.place.base_ty;\n         for proj in self.place.projections.iter() {\n@@ -169,11 +168,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n                         .unwrap();\n                     }\n                     ty => {\n-                        span_bug!(\n-                            self.get_capture_kind_span(tcx),\n-                            \"Unexpected type {:?} for `Field` projection\",\n-                            ty\n-                        )\n+                        bug!(\"Unexpected type {:?} for `Field` projection\", ty)\n                     }\n                 },\n \n@@ -238,10 +233,39 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n }\n \n-fn symbols_for_closure_captures(tcx: TyCtxt<'_>, def_id: (LocalDefId, LocalDefId)) -> Vec<Symbol> {\n-    let typeck_results = tcx.typeck(def_id.0);\n-    let captures = typeck_results.closure_min_captures_flattened(def_id.1);\n-    captures.into_iter().map(|captured_place| captured_place.to_symbol(tcx)).collect()\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct ClosureTypeInfo<'tcx> {\n+    user_provided_sig: ty::CanonicalPolyFnSig<'tcx>,\n+    captures: &'tcx [&'tcx ty::CapturedPlace<'tcx>],\n+    kind_origin: Option<&'tcx (Span, HirPlace<'tcx>)>,\n+}\n+\n+fn closure_typeinfo<'tcx>(tcx: TyCtxt<'tcx>, def: LocalDefId) -> ClosureTypeInfo<'tcx> {\n+    debug_assert!(tcx.is_closure(def.to_def_id()));\n+    let typeck_results = tcx.typeck(def);\n+    let user_provided_sig = typeck_results.user_provided_sigs[&def];\n+    let captures = typeck_results.closure_min_captures_flattened(def);\n+    let captures = tcx.arena.alloc_from_iter(captures);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n+    let kind_origin = typeck_results.closure_kind_origins().get(hir_id);\n+    ClosureTypeInfo { user_provided_sig, captures, kind_origin }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn closure_kind_origin(self, def_id: LocalDefId) -> Option<&'tcx (Span, HirPlace<'tcx>)> {\n+        self.closure_typeinfo(def_id).kind_origin\n+    }\n+\n+    pub fn closure_user_provided_sig(self, def_id: LocalDefId) -> ty::CanonicalPolyFnSig<'tcx> {\n+        self.closure_typeinfo(def_id).user_provided_sig\n+    }\n+\n+    pub fn closure_captures(self, def_id: LocalDefId) -> &'tcx [&'tcx ty::CapturedPlace<'tcx>] {\n+        if !self.is_closure(def_id.to_def_id()) {\n+            return &[];\n+        };\n+        self.closure_typeinfo(def_id).captures\n+    }\n }\n \n /// Return true if the `proj_possible_ancestor` represents an ancestor path\n@@ -434,5 +458,5 @@ impl BorrowKind {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { symbols_for_closure_captures, ..*providers }\n+    *providers = ty::query::Providers { closure_typeinfo, ..*providers }\n }"}, {"sha": "fc5757564a74ba5475085b0c60812809c34d5bfb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -73,7 +73,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n pub use self::closure::{\n     is_ancestor_or_same_capture, place_to_string_for_capture, BorrowKind, CaptureInfo,\n-    CapturedPlace, ClosureKind, MinCaptureInformationMap, MinCaptureList,\n+    CapturedPlace, ClosureKind, ClosureTypeInfo, MinCaptureInformationMap, MinCaptureList,\n     RootVariableMinCaptureList, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap, UpvarPath,\n     CAPTURE_STRUCT_LOCAL,\n };"}, {"sha": "ef643531bb288658368f3d94da959f67a5509126", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -263,6 +263,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::UniverseIndex,\n     crate::ty::Variance,\n     ::rustc_span::Span,\n+    ::rustc_span::symbol::Ident,\n     ::rustc_errors::ErrorGuaranteed,\n     Field,\n     interpret::Scalar,"}, {"sha": "586958247fcdca9303873bb0df2f4cd08a02d92d", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -569,7 +569,7 @@ impl<'a, V> LocalTableInContext<'a, V> {\n         self.data.contains_key(&id.local_id)\n     }\n \n-    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+    pub fn get(&self, id: hir::HirId) -> Option<&'a V> {\n         validate_hir_id_for_typeck_results(self.hir_owner, id);\n         self.data.get(&id.local_id)\n     }"}, {"sha": "b3f9d82829f1306b7d97c727609356272d831165", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 79, "deletions": 107, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::*;\n use rustc_middle::thir::{\n     self, BindingMode, Expr, ExprId, LintLevel, LocalVarId, Param, ParamId, PatKind, Thir,\n };\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_span::Symbol;\n@@ -47,8 +47,6 @@ pub(crate) fn mir_built(\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n-    let body_owner_kind = tcx.hir().body_owner_kind(def.did);\n-\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     // We can't use `ensure()` for `thir_abstract_const` as it doesn't compute the query\n     // if inputs are green. This can cause ICEs when calling `thir_abstract_const` after\n@@ -65,16 +63,15 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     }\n \n     let body = match tcx.thir_body(def) {\n-        Err(error_reported) => construct_error(tcx, def.did, body_owner_kind, error_reported),\n+        Err(error_reported) => construct_error(tcx, def.did, error_reported),\n         Ok((thir, expr)) => {\n             // We ran all queries that depended on THIR at the beginning\n             // of `mir_build`, so now we can steal it\n             let thir = thir.steal();\n \n-            if body_owner_kind.is_fn_or_closure() {\n-                construct_fn(tcx, def, &thir, expr)\n-            } else {\n-                construct_const(tcx, def, &thir, expr)\n+            match thir.body_type {\n+                thir::BodyTy::Fn(fn_sig) => construct_fn(tcx, def, &thir, expr, fn_sig),\n+                thir::BodyTy::Const(ty) => construct_const(tcx, def, &thir, expr, ty),\n             }\n         }\n     };\n@@ -158,13 +155,13 @@ struct BlockContext(Vec<BlockFrame>);\n struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: InferCtxt<'tcx>,\n-    typeck_results: &'tcx TypeckResults<'tcx>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n \n     thir: &'a Thir<'tcx>,\n     cfg: CFG<'tcx>,\n \n+    def: ty::WithOptConstParam<LocalDefId>,\n     def_id: DefId,\n     hir_id: hir::HirId,\n     parent_module: DefId,\n@@ -434,6 +431,7 @@ fn construct_fn<'tcx>(\n     fn_def: ty::WithOptConstParam<LocalDefId>,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n+    fn_sig: ty::FnSig<'tcx>,\n ) -> Body<'tcx> {\n     let span = tcx.def_span(fn_def.did);\n     let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n@@ -453,11 +451,6 @@ fn construct_fn<'tcx>(\n         .output\n         .span();\n \n-    // fetch the fully liberated fn signature (that is, all bound\n-    // types/lifetimes replaced)\n-    let typeck_results = tcx.typeck_opt_const_arg(fn_def);\n-    let fn_sig = typeck_results.liberated_fn_sigs()[fn_id];\n-\n     let safety = match fn_sig.unsafety {\n         hir::Unsafety::Normal => Safety::Safe,\n         hir::Unsafety::Unsafe => Safety::FnUnsafe,\n@@ -529,13 +522,7 @@ fn construct_fn<'tcx>(\n         let return_block =\n             unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n                 Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                    builder.args_and_body(\n-                        START_BLOCK,\n-                        fn_def.did,\n-                        arguments,\n-                        arg_scope,\n-                        &thir[expr],\n-                    )\n+                    builder.args_and_body(START_BLOCK, arguments, arg_scope, &thir[expr])\n                 }))\n             }));\n         let source_info = builder.source_info(fn_end);\n@@ -563,6 +550,7 @@ fn construct_const<'a, 'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n     thir: &'a Thir<'tcx>,\n     expr: ExprId,\n+    const_ty: Ty<'tcx>,\n ) -> Body<'tcx> {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n \n@@ -586,20 +574,6 @@ fn construct_const<'a, 'tcx>(\n         _ => span_bug!(tcx.def_span(def.did), \"can't build MIR for {:?}\", def.did),\n     };\n \n-    // Get the revealed type of this const. This is *not* the adjusted\n-    // type of its body, which may be a subtype of this type. For\n-    // example:\n-    //\n-    // fn foo(_: &()) {}\n-    // static X: fn(&'static ()) = foo;\n-    //\n-    // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n-    // is not the same as the type of X. We need the type of the return\n-    // place to be the type of the constant because NLL typeck will\n-    // equate them.\n-    let typeck_results = tcx.typeck_opt_const_arg(def);\n-    let const_ty = typeck_results.node_type(hir_id);\n-\n     let infcx = tcx.infer_ctxt().build();\n     let mut builder = Builder::new(\n         thir,\n@@ -629,15 +603,11 @@ fn construct_const<'a, 'tcx>(\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error(\n-    tcx: TyCtxt<'_>,\n-    def: LocalDefId,\n-    body_owner_kind: hir::BodyOwnerKind,\n-    err: ErrorGuaranteed,\n-) -> Body<'_> {\n+fn construct_error(tcx: TyCtxt<'_>, def: LocalDefId, err: ErrorGuaranteed) -> Body<'_> {\n     let span = tcx.def_span(def);\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let generator_kind = tcx.generator_kind(def);\n+    let body_owner_kind = tcx.hir().body_owner_kind(def);\n \n     let ty = tcx.ty_error(err);\n     let num_params = match body_owner_kind {\n@@ -728,9 +698,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             thir,\n             tcx,\n             infcx,\n-            typeck_results: tcx.typeck_opt_const_arg(def),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             param_env,\n+            def,\n             def_id: def.did.to_def_id(),\n             hir_id,\n             parent_module: tcx.parent_module(hir_id).to_def_id(),\n@@ -780,14 +750,78 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.generator_kind,\n-            self.typeck_results.tainted_by_errors,\n+            None,\n         )\n     }\n \n+    fn insert_upvar_arg(&mut self) {\n+        let Some(closure_arg) = self.local_decls.get(ty::CAPTURE_STRUCT_LOCAL) else { return };\n+\n+        let mut closure_ty = closure_arg.ty;\n+        let mut closure_env_projs = vec![];\n+        if let ty::Ref(_, ty, _) = closure_ty.kind() {\n+            closure_env_projs.push(ProjectionElem::Deref);\n+            closure_ty = *ty;\n+        }\n+\n+        let upvar_substs = match closure_ty.kind() {\n+            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+            _ => return,\n+        };\n+\n+        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n+        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n+        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+        // the given closure and use the necessary information to create upvar\n+        // debuginfo and to fill `self.upvars`.\n+        let capture_tys = upvar_substs.upvar_tys();\n+\n+        let tcx = self.tcx;\n+        self.upvars = tcx\n+            .closure_captures(self.def.did)\n+            .iter()\n+            .zip(capture_tys)\n+            .enumerate()\n+            .map(|(i, (captured_place, ty))| {\n+                let name = captured_place.to_symbol();\n+\n+                let capture = captured_place.info.capture_kind;\n+                let var_id = match captured_place.place.base {\n+                    HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                    _ => bug!(\"Expected an upvar\"),\n+                };\n+\n+                let mutability = captured_place.mutability;\n+\n+                let mut projs = closure_env_projs.clone();\n+                projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                match capture {\n+                    ty::UpvarCapture::ByValue => {}\n+                    ty::UpvarCapture::ByRef(..) => {\n+                        projs.push(ProjectionElem::Deref);\n+                    }\n+                };\n+\n+                let use_place = Place {\n+                    local: ty::CAPTURE_STRUCT_LOCAL,\n+                    projection: tcx.mk_place_elems(&projs),\n+                };\n+                self.var_debug_info.push(VarDebugInfo {\n+                    name,\n+                    source_info: SourceInfo::outermost(captured_place.var_ident.span),\n+                    value: VarDebugInfoContents::Place(use_place),\n+                });\n+\n+                let capture = Capture { captured_place, use_place, mutability };\n+                (var_id, capture)\n+            })\n+            .collect();\n+    }\n+\n     fn args_and_body(\n         &mut self,\n         mut block: BasicBlock,\n-        fn_def_id: LocalDefId,\n         arguments: &IndexVec<ParamId, Param<'tcx>>,\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,\n@@ -809,69 +843,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.tcx;\n-        let tcx_hir = tcx.hir();\n-        let hir_typeck_results = self.typeck_results;\n-\n-        // In analyze_closure() in upvar.rs we gathered a list of upvars used by an\n-        // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n-        // with the closure's DefId. Here, we run through that vec of UpvarIds for\n-        // the given closure and use the necessary information to create upvar\n-        // debuginfo and to fill `self.upvars`.\n-        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n-            let mut closure_env_projs = vec![];\n-            let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n-            if let ty::Ref(_, ty, _) = closure_ty.kind() {\n-                closure_env_projs.push(ProjectionElem::Deref);\n-                closure_ty = *ty;\n-            }\n-            let upvar_substs = match closure_ty.kind() {\n-                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-                _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n-            };\n-            let def_id = self.def_id.as_local().unwrap();\n-            let capture_syms = tcx.symbols_for_closure_captures((def_id, fn_def_id));\n-            let capture_tys = upvar_substs.upvar_tys();\n-            let captures_with_tys = hir_typeck_results\n-                .closure_min_captures_flattened(fn_def_id)\n-                .zip(capture_tys.zip(capture_syms));\n-\n-            self.upvars = captures_with_tys\n-                .enumerate()\n-                .map(|(i, (captured_place, (ty, sym)))| {\n-                    let capture = captured_place.info.capture_kind;\n-                    let var_id = match captured_place.place.base {\n-                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-                        _ => bug!(\"Expected an upvar\"),\n-                    };\n-\n-                    let mutability = captured_place.mutability;\n-\n-                    let mut projs = closure_env_projs.clone();\n-                    projs.push(ProjectionElem::Field(Field::new(i), ty));\n-                    match capture {\n-                        ty::UpvarCapture::ByValue => {}\n-                        ty::UpvarCapture::ByRef(..) => {\n-                            projs.push(ProjectionElem::Deref);\n-                        }\n-                    };\n-\n-                    let use_place = Place {\n-                        local: ty::CAPTURE_STRUCT_LOCAL,\n-                        projection: tcx.mk_place_elems(&projs),\n-                    };\n-                    self.var_debug_info.push(VarDebugInfo {\n-                        name: *sym,\n-                        source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n-                        value: VarDebugInfoContents::Place(use_place),\n-                    });\n-\n-                    let capture = Capture { captured_place, use_place, mutability };\n-                    (var_id, capture)\n-                })\n-                .collect();\n-        }\n+        self.insert_upvar_arg();\n \n         let mut scope = None;\n         // Bind the argument patterns"}, {"sha": "d510a5fc76fcf5934cdbe0d220959a6d3b0e3f92", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -541,8 +541,9 @@ impl<'tcx> Cx<'tcx> {\n                 let def_id = def_id.expect_local();\n \n                 let upvars = self\n-                    .typeck_results\n-                    .closure_min_captures_flattened(def_id)\n+                    .tcx\n+                    .closure_captures(def_id)\n+                    .iter()\n                     .zip(substs.upvar_tys())\n                     .map(|(captured_place, ty)| {\n                         let upvars = self.capture_upvar(expr, captured_place, ty);"}, {"sha": "070544446e3488549b322e3c51637673da3de4aa", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -82,17 +82,38 @@ impl<'tcx> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n         let did = def.did;\n         let hir = tcx.hir();\n+        let hir_id = hir.local_def_id_to_hir_id(did);\n+\n+        let body_type = if hir.body_owner_kind(did).is_fn_or_closure() {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            BodyTy::Fn(typeck_results.liberated_fn_sigs()[hir_id])\n+        } else {\n+            // Get the revealed type of this const. This is *not* the adjusted\n+            // type of its body, which may be a subtype of this type. For\n+            // example:\n+            //\n+            // fn foo(_: &()) {}\n+            // static X: fn(&'static ()) = foo;\n+            //\n+            // The adjusted type of the body of X is `for<'a> fn(&'a ())` which\n+            // is not the same as the type of X. We need the type of the return\n+            // place to be the type of the constant because NLL typeck will\n+            // equate them.\n+            BodyTy::Const(typeck_results.node_type(hir_id))\n+        };\n+\n         Cx {\n             tcx,\n-            thir: Thir::new(),\n+            thir: Thir::new(body_type),\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n             rvalue_scopes: &typeck_results.rvalue_scopes,\n             body_owner: did.to_def_id(),\n             adjustment_span: None,\n             apply_adjustments: hir\n-                .attrs(hir.local_def_id_to_hir_id(did))\n+                .attrs(hir_id)\n                 .iter()\n                 .all(|attr| attr.name_or_empty() != rustc_span::sym::custom_mir),\n         }"}, {"sha": "c31e6a218ce4d2ae408bade89b16552eb16cb4ff", "filename": "tests/ui/thir-print/thir-flat.stdout", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6290ae92b2df2bfff09abdcb80a3aa483692bab6/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6290ae92b2df2bfff09abdcb80a3aa483692bab6/tests%2Fui%2Fthir-print%2Fthir-flat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthir-print%2Fthir-flat.stdout?ref=6290ae92b2df2bfff09abdcb80a3aa483692bab6", "patch": "@@ -1,5 +1,8 @@\n DefId(0:3 ~ thir_flat[45a6]::main):\n Thir {\n+    body_type: Fn(\n+        ([]; c_variadic: false)->(),\n+    ),\n     arms: [],\n     blocks: [\n         Block {"}]}