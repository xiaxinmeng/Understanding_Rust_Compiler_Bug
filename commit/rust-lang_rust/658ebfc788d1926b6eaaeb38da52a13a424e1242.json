{"sha": "658ebfc788d1926b6eaaeb38da52a13a424e1242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OGViZmM3ODhkMTkyNmI2ZWFhZWIzOGRhNTJhMTNhNDI0ZTEyNDI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-16T13:40:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: give Layout::CEnum a discriminant field like Layout::General.", "tree": {"sha": "b124461e30b5fcc06fe250b884864edc4788d56c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b124461e30b5fcc06fe250b884864edc4788d56c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/658ebfc788d1926b6eaaeb38da52a13a424e1242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/658ebfc788d1926b6eaaeb38da52a13a424e1242", "html_url": "https://github.com/rust-lang/rust/commit/658ebfc788d1926b6eaaeb38da52a13a424e1242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/658ebfc788d1926b6eaaeb38da52a13a424e1242/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d318b9c27b46b8d59a21c9015a6847ce1964394c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d318b9c27b46b8d59a21c9015a6847ce1964394c", "html_url": "https://github.com/rust-lang/rust/commit/d318b9c27b46b8d59a21c9015a6847ce1964394c"}], "stats": {"total": 110, "additions": 55, "deletions": 55}, "files": [{"sha": "18c3a2707877339ed06b5b11678c3f591b21eba6", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/658ebfc788d1926b6eaaeb38da52a13a424e1242/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658ebfc788d1926b6eaaeb38da52a13a424e1242/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=658ebfc788d1926b6eaaeb38da52a13a424e1242", "patch": "@@ -1203,8 +1203,7 @@ impl<'a, 'tcx> Layout {\n         let success = |layout| {\n             let layout = tcx.intern_layout(layout);\n             let fields = match *layout {\n-                Scalar(_) |\n-                CEnum { .. } => {\n+                Scalar(_) => {\n                     FieldPlacement::union(0)\n                 }\n \n@@ -1241,6 +1240,7 @@ impl<'a, 'tcx> Layout {\n                     FieldPlacement::union(def.struct_variant().fields.len())\n                 }\n \n+                CEnum { .. } |\n                 General { .. } => FieldPlacement::union(1),\n \n                 NullablePointer { ref discr_offset, .. } => {\n@@ -2356,6 +2356,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                     match self.variant_index {\n                         None => match *self.layout {\n                             // Discriminant field for enums (where applicable).\n+                            CEnum { discr, .. } |\n                             General { discr, .. } |\n                             NullablePointer { discr, .. } => {\n                                 return [discr.to_ty(tcx)][i];"}, {"sha": "883751d25a069ea77d22c249ad44fa976bb0881e", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/658ebfc788d1926b6eaaeb38da52a13a424e1242/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658ebfc788d1926b6eaaeb38da52a13a424e1242/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=658ebfc788d1926b6eaaeb38da52a13a424e1242", "patch": "@@ -235,7 +235,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         // Discriminant field of enums.\n         match *l {\n-            layout::General { .. } |\n             layout::NullablePointer { .. } if l.variant_index.is_none() => {\n                 let ty = ccx.llvm_type_of(field.ty);\n                 let size = field.size(ccx).bytes();\n@@ -350,60 +349,66 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         }\n     }\n \n-    /// Helper for cases where the discriminant is simply loaded.\n-    fn load_discr(self, bcx: &Builder, discr: layout::Primitive, min: u64, max: u64) -> ValueRef {\n-        if let layout::Int(ity, _) = discr {\n-            let bits = ity.size().bits();\n-            assert!(bits <= 64);\n-            let bits = bits as usize;\n-            let mask = !0u64 >> (64 - bits);\n-            // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n-            // However, that is fine here (it would still represent the full range),\n-            if max.wrapping_add(1) & mask == min & mask {\n-                // i.e., if the range is everything.  The lo==hi case would be\n-                // rejected by the LLVM verifier (it would mean either an\n-                // empty set, which is impossible, or the entire range of the\n-                // type, which is pointless).\n-            } else {\n-                // llvm::ConstantRange can deal with ranges that wrap around,\n-                // so an overflow on (max + 1) is fine.\n-                return bcx.load_range_assert(self.llval, min, max.wrapping_add(1),\n-                                             /* signed: */ llvm::True,\n-                                             self.alignment.non_abi());\n-            }\n-        }\n-        bcx.load(self.llval, self.alignment.non_abi())\n-    }\n-\n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n \n         let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n-        let (val, discr) = match *l {\n+        match *l {\n             layout::Univariant { .. } |\n             layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n-            layout::CEnum { discr, min, max, .. } => {\n-                (self.load_discr(bcx, discr, min, max), discr)\n+            _ => {}\n+        }\n+\n+        let discr = self.project_field(bcx, 0);\n+        let discr_layout = bcx.ccx.layout_of(discr.ty.to_ty(bcx.tcx()));\n+        let discr_scalar = match discr_layout.abi {\n+            layout::Abi::Scalar(discr) => discr,\n+            _ => bug!(\"discriminant not scalar: {:#?}\", discr_layout)\n+        };\n+        let (min, max) = match *l {\n+            layout::CEnum { min, max, .. } => (min, max),\n+            layout::General { ref variants, .. } => (0, variants.len() as u64 - 1),\n+            _ => (0, u64::max_value()),\n+        };\n+        let max_next = max.wrapping_add(1);\n+        let bits = discr_scalar.size(bcx.ccx).bits();\n+        assert!(bits <= 64);\n+        let mask = !0u64 >> (64 - bits);\n+        let lldiscr = match discr_scalar {\n+            // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n+            // However, that is fine here (it would still represent the full range),\n+            layout::Int(..) if max_next & mask != min & mask => {\n+                // llvm::ConstantRange can deal with ranges that wrap around,\n+                // so an overflow on (max + 1) is fine.\n+                bcx.load_range_assert(discr.llval, min, max_next,\n+                                      /* signed: */ llvm::True,\n+                                      discr.alignment.non_abi())\n             }\n-            layout::General { discr, ref variants, .. } => {\n-                let ptr = self.project_field(bcx, 0);\n-                (ptr.load_discr(bcx, discr, 0, variants.len() as u64 - 1), discr)\n+            _ => {\n+                // i.e., if the range is everything.  The lo==hi case would be\n+                // rejected by the LLVM verifier (it would mean either an\n+                // empty set, which is impossible, or the entire range of the\n+                // type, which is pointless).\n+                bcx.load(discr.llval, discr.alignment.non_abi())\n+            }\n+        };\n+        match *l {\n+            layout::CEnum { .. } |\n+            layout::General { .. } => {\n+                let signed = match discr_scalar {\n+                    layout::Int(_, signed) => signed,\n+                    _ => false\n+                };\n+                bcx.intcast(lldiscr, cast_to, signed)\n             }\n             layout::NullablePointer { nndiscr, .. } => {\n-                let ptr = self.project_field(bcx, 0);\n-                let lldiscr = bcx.load(ptr.llval, ptr.alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                (bcx.icmp(cmp, lldiscr, C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())))),\n-                 layout::Int(layout::I1, false))\n-            },\n+                let zero = C_null(bcx.ccx.llvm_type_of(discr_layout.ty));\n+                bcx.intcast(bcx.icmp(cmp, lldiscr, zero), cast_to, false)\n+            }\n             _ => bug!(\"{} is not an enum\", l.ty)\n-        };\n-        let signed = match discr {\n-            layout::Int(_, signed) => signed,\n-            _ => false\n-        };\n-        bcx.intcast(val, cast_to, signed)\n+        }\n     }\n \n     /// Set the discriminant for a new value of the given case of the given\n@@ -414,20 +419,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n         match *l {\n-            layout::CEnum { .. } => {\n-                bcx.store(C_int(bcx.ccx.llvm_type_of(self.ty.to_ty(bcx.tcx())), to as i64),\n-                    self.llval, self.alignment.non_abi());\n-            }\n+            layout::CEnum { .. } |\n             layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n-            layout::Univariant { .. }\n-            | layout::UntaggedUnion { .. }\n-            | layout::Vector { .. } => {\n-                assert_eq!(to, 0);\n-            }\n             layout::NullablePointer { nndiscr, .. } => {\n                 if to != nndiscr {\n                     let use_memset = match l.abi {\n@@ -451,7 +448,9 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                     }\n                 }\n             }\n-            _ => bug!(\"Cannot handle {} represented as {:#?}\", l.ty, l)\n+            _ => {\n+                assert_eq!(to, 0);\n+            }\n         }\n     }\n "}]}