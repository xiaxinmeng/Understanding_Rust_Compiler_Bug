{"sha": "78147452b8c589edfae72ab6a17e71c25adc9f8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MTQ3NDUyYjhjNTg5ZWRmYWU3MmFiNmExN2U3MWMyNWFkYzlmOGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-20T20:38:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-20T20:38:54Z"}, "message": "rustc: Remove trans_raw_malloc, as it's only called from one place", "tree": {"sha": "e2befd7918305346546f7e1d91a43b8952ef8464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2befd7918305346546f7e1d91a43b8952ef8464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78147452b8c589edfae72ab6a17e71c25adc9f8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78147452b8c589edfae72ab6a17e71c25adc9f8f", "html_url": "https://github.com/rust-lang/rust/commit/78147452b8c589edfae72ab6a17e71c25adc9f8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78147452b8c589edfae72ab6a17e71c25adc9f8f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d882f8ee2f8e617595d3b44fbe609542dae29bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d882f8ee2f8e617595d3b44fbe609542dae29bcd", "html_url": "https://github.com/rust-lang/rust/commit/d882f8ee2f8e617595d3b44fbe609542dae29bcd"}], "stats": {"total": 27, "additions": 10, "deletions": 17}, "files": [{"sha": "c30a70fd256eb578d3ea719d1cd7273943bd10fc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/78147452b8c589edfae72ab6a17e71c25adc9f8f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78147452b8c589edfae72ab6a17e71c25adc9f8f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=78147452b8c589edfae72ab6a17e71c25adc9f8f", "patch": "@@ -799,19 +799,6 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: ast::def_id,\n     ret rslt(rs.bcx, val);\n }\n \n-// trans_raw_malloc: expects a type indicating which pointer type we want and\n-// a size indicating how much space we want malloc'd.\n-fn trans_raw_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef) ->\n-   result {\n-    // FIXME: need a table to collect tydesc globals.\n-\n-    let tydesc = C_null(T_ptr(bcx_ccx(cx).tydesc_type));\n-    let rval =\n-        Call(cx, bcx_ccx(cx).upcalls.malloc,\n-             [cx.fcx.lltaskptr, llsize, tydesc]);\n-    ret rslt(cx, PointerCast(cx, rval, llptr_ty));\n-}\n-\n // trans_shared_malloc: expects a type indicating which pointer type we want\n // and a size indicating how much space we want malloc'd.\n fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n@@ -829,6 +816,8 @@ fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n // enough space for something of that type, along with space for a reference\n // count; in other words, it allocates a box for something of that type.\n fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n+    let bcx = cx;\n+\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n \n@@ -839,9 +828,10 @@ fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n \n     // The mk_int here is the space being\n     // reserved for the refcount.\n-    let boxed_body = ty::mk_tup(bcx_tcx(cx), [ty::mk_int(bcx_tcx(cx)), t]);\n-    let box_ptr = ty::mk_imm_box(bcx_tcx(cx), t);\n-    let sz = size_of(cx, boxed_body);\n+    let boxed_body = ty::mk_tup(bcx_tcx(bcx), [ty::mk_int(bcx_tcx(cx)), t]);\n+    let box_ptr = ty::mk_imm_box(bcx_tcx(bcx), t);\n+    let r = size_of(cx, boxed_body);\n+    let llsz = r.val; bcx = r.bcx;\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n@@ -851,7 +841,10 @@ fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n     let sp = cx.sp;\n     check (type_has_static_size(ccx, box_ptr));\n     let llty = type_of(ccx, sp, box_ptr);\n-    ret trans_raw_malloc(sz.bcx, llty, sz.val);\n+\n+    let tydesc = C_null(T_ptr(ccx.tydesc_type));\n+    let rval = Call(cx, ccx.upcalls.malloc, [cx.fcx.lltaskptr, llsz, tydesc]);\n+    ret rslt(cx, PointerCast(cx, rval, llty));\n }\n \n // trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,"}]}