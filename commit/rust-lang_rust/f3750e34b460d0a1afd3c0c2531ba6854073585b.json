{"sha": "f3750e34b460d0a1afd3c0c2531ba6854073585b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNzUwZTM0YjQ2MGQwYTFhZmQzYzBjMjUzMWJhNjg1NDA3MzU4NWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T03:37:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-30T03:37:37Z"}, "message": "Rollup merge of #63093 - Aaron1011:fix/existential-closure, r=cramertj\n\nProperly check the defining scope of existential types\n\nFixes #52632\n\nExistential types (soon to be 'impl trait' aliases) can either be\ndelcared at a top-level crate/module scope, or within another item such\nas an fn. Previously, we were handling the second case incorrectly when\nrecursively searching for defining usages - we would check children of\nthe item, but not the item itself. This lead to us missing closures\nthat consituted a defining use of the existential type, as their opaque\ntype instantiations are stored in the TypeckTables of their parent\nfunction.\n\nThis commit ensures that we explicitly visit the defining item itself,\nnot just its children.", "tree": {"sha": "761bd3f9019326de4ea054986c0a570a956f5f3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761bd3f9019326de4ea054986c0a570a956f5f3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3750e34b460d0a1afd3c0c2531ba6854073585b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdP7uBCRBK7hj4Ov3rIwAAdHIIAADp5jQ/bh2yfOtsC9j1tjUL\nsN3wGQGE4oDVZ4GHFuK/HoHrox8f3DgUyCm6WibOHMB7maajMJj0nHGfNeMs/SHe\nLgKvOJDW/Sv3oB55fe+vURJs6vkAz0bNW9HJXAkAKLv4hoGqCKZmfVtidfvaIrnm\nE8qlNJ4IIxCdiaWgL/5eT/1iib+kd7hBEfPT0T8kjcYihhSJ7D9ScU0Jw0MWTEN/\nN4IbouW/u7rYY98YPJ143FfrIkrJuFY3C7hY4Lqu/B8ZZgSSRG8jh8s8ARQEzQtX\n6aIbUA4nhVPdaMKmKvsSCLcx3zXbqfYJAR8GRHahKPnUaNrLd3miM5wbM0dcUPc=\n=9hCj\n-----END PGP SIGNATURE-----\n", "payload": "tree 761bd3f9019326de4ea054986c0a570a956f5f3e\nparent 44130681eba7330789f4e0c941e57118ee976d07\nparent 3e98c3acf5c598ae577428fa8fbf1c29e270739b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564457857 +0200\ncommitter GitHub <noreply@github.com> 1564457857 +0200\n\nRollup merge of #63093 - Aaron1011:fix/existential-closure, r=cramertj\n\nProperly check the defining scope of existential types\n\nFixes #52632\n\nExistential types (soon to be 'impl trait' aliases) can either be\ndelcared at a top-level crate/module scope, or within another item such\nas an fn. Previously, we were handling the second case incorrectly when\nrecursively searching for defining usages - we would check children of\nthe item, but not the item itself. This lead to us missing closures\nthat consituted a defining use of the existential type, as their opaque\ntype instantiations are stored in the TypeckTables of their parent\nfunction.\n\nThis commit ensures that we explicitly visit the defining item itself,\nnot just its children.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3750e34b460d0a1afd3c0c2531ba6854073585b", "html_url": "https://github.com/rust-lang/rust/commit/f3750e34b460d0a1afd3c0c2531ba6854073585b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3750e34b460d0a1afd3c0c2531ba6854073585b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44130681eba7330789f4e0c941e57118ee976d07", "url": "https://api.github.com/repos/rust-lang/rust/commits/44130681eba7330789f4e0c941e57118ee976d07", "html_url": "https://github.com/rust-lang/rust/commit/44130681eba7330789f4e0c941e57118ee976d07"}, {"sha": "3e98c3acf5c598ae577428fa8fbf1c29e270739b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e98c3acf5c598ae577428fa8fbf1c29e270739b", "html_url": "https://github.com/rust-lang/rust/commit/3e98c3acf5c598ae577428fa8fbf1c29e270739b"}], "stats": {"total": 70, "additions": 61, "deletions": 9}, "files": [{"sha": "73a76ebcb74f412e95b6212a7f00ec9e2f32181e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=f3750e34b460d0a1afd3c0c2531ba6854073585b", "patch": "@@ -1189,11 +1189,7 @@ pub fn may_define_existential_type(\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    trace!(\n-        \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n-        tcx.hir().get(hir_id),\n-        tcx.hir().get(opaque_hir_id)\n-    );\n+\n \n     // Named existential types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n@@ -1202,5 +1198,12 @@ pub fn may_define_existential_type(\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // Syntactically, we are allowed to define the concrete type if:\n-    hir_id == scope\n+    let res = hir_id == scope;\n+    trace!(\n+        \"may_define_existential_type(def={:?}, opaque_node={:?}) = {}\",\n+        tcx.hir().get(hir_id),\n+        tcx.hir().get(opaque_hir_id),\n+        res\n+    );\n+    res\n }"}, {"sha": "395e266ae46aab57677899dc51d93ad87472fe10", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f3750e34b460d0a1afd3c0c2531ba6854073585b", "patch": "@@ -1664,6 +1664,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1672,6 +1673,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1680,6 +1682,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n@@ -1703,9 +1706,23 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     } else {\n         debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n-            Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     existential type Blah: Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(ref it) => locator.visit_item(it),\n+            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n+            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n             other => bug!(\n                 \"{:?} is not a valid scope for an existential type item\",\n                 other"}, {"sha": "b2bbc1f1549985e135fe1a6713fba5806edd97a7", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs?ref=f3750e34b460d0a1afd3c0c2531ba6854073585b", "patch": "@@ -0,0 +1,12 @@\n+// Checks to ensure that we properly detect when a closure constrains an existential type\n+#![feature(existential_type)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    existential type Existential: Debug;\n+    fn _unused() -> Existential { String::new() }\n+    //~^ ERROR: concrete type differs from previous defining existential type use\n+    let null = || -> Existential { 0 };\n+    println!(\"{:?}\", null());\n+}"}, {"sha": "424d65a193c92de7c77729ce454df3ab4ca3c5c9", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3750e34b460d0a1afd3c0c2531ba6854073585b/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr?ref=f3750e34b460d0a1afd3c0c2531ba6854073585b", "patch": "@@ -0,0 +1,20 @@\n+error: concrete type differs from previous defining existential type use\n+  --> $DIR/issue-52843-closure-constrain.rs:8:5\n+   |\n+LL |     fn _unused() -> Existential { String::new() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n+   |\n+note: previous use here\n+  --> $DIR/issue-52843-closure-constrain.rs:6:1\n+   |\n+LL | / fn main() {\n+LL | |     existential type Existential: Debug;\n+LL | |     fn _unused() -> Existential { String::new() }\n+LL | |\n+LL | |     let null = || -> Existential { 0 };\n+LL | |     println!(\"{:?}\", null());\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}