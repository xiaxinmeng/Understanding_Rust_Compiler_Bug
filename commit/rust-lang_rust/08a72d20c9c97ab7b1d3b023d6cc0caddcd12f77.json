{"sha": "08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YTcyZDIwYzljOTdhYjdiMWQzYjAyM2Q2Y2MwY2FkZGNkMTJmNzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-21T16:50:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-28T16:05:45Z"}, "message": "Add a testing mechanism and a simple spike test", "tree": {"sha": "e1cc694b31d5946372440ea3f7ac8cb059103e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1cc694b31d5946372440ea3f7ac8cb059103e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "html_url": "https://github.com/rust-lang/rust/commit/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d4b8edd319d0f0d76024504cdfc74f89a001b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d4b8edd319d0f0d76024504cdfc74f89a001b1", "html_url": "https://github.com/rust-lang/rust/commit/58d4b8edd319d0f0d76024504cdfc74f89a001b1"}], "stats": {"total": 360, "additions": 360, "deletions": 0}, "files": [{"sha": "e0532e7476f511545d0bf7ac2ae98ac307d4548c", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass is only used for UNIT TESTS related to incremental\n+//! compilation. It tests whether a particular `.o` file will be re-used\n+//! from a previous compilation or whether it must be regenerated.\n+//!\n+//! The user adds annotations to the crate of the following form:\n+//!\n+//! ```\n+//! #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n+//! #![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+//! ```\n+//!\n+//! The first indicates (in the cfg `rpass2`) that `spike.o` will be\n+//! reused, the second that `spike-x.o` will be recreated. If these\n+//! annotations are inaccurate, errors are reported.\n+//!\n+//! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n+//! the HIR doesn't change as a result of the annotations, which might\n+//! perturb the reuse results.\n+\n+use rustc::ty::TyCtxt;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::InternedString;\n+\n+use {ModuleSource, ModuleTranslation};\n+\n+const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+const MODULE: &'static str = \"module\";\n+const CFG: &'static str = \"cfg\";\n+\n+#[derive(Debug, PartialEq)]\n+enum Disposition { Reused, Translated }\n+\n+pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       modules: &[ModuleTranslation]) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n+    let ams = AssertModuleSource { tcx: tcx, modules: modules };\n+    for attr in &tcx.map.krate().attrs {\n+        ams.check_attr(attr);\n+    }\n+}\n+\n+struct AssertModuleSource<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    modules: &'a [ModuleTranslation],\n+}\n+\n+impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n+    fn check_attr(&self, attr: &ast::Attribute) {\n+        let disposition = if attr.check_name(PARTITION_REUSED) {\n+            Disposition::Reused\n+        } else if attr.check_name(PARTITION_TRANSLATED) {\n+            Disposition::Translated\n+        } else {\n+            return;\n+        };\n+\n+        if !self.check_config(attr) {\n+            debug!(\"check_attr: config does not match, ignoring attr\");\n+            return;\n+        }\n+\n+        let mname = self.field(attr, MODULE);\n+        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = match mtrans {\n+            Some(m) => m,\n+            None => {\n+                debug!(\"module name `{}` not found amongst:\", mname);\n+                for mtrans in self.modules {\n+                    debug!(\"module named `{}` with disposition {:?}\",\n+                           mtrans.name,\n+                           self.disposition(mtrans));\n+                }\n+\n+                self.tcx.sess.span_err(\n+                    attr.span,\n+                    &format!(\"no module named `{}`\", mname));\n+                return;\n+            }\n+        };\n+\n+        let mtrans_disposition = self.disposition(mtrans);\n+        if disposition != mtrans_disposition {\n+            self.tcx.sess.span_err(\n+                attr.span,\n+                &format!(\"expected module named `{}` to be {:?} but is {:?}\",\n+                         mname,\n+                         disposition,\n+                         mtrans_disposition));\n+        }\n+    }\n+\n+    fn disposition(&self, mtrans: &ModuleTranslation) -> Disposition {\n+        match mtrans.source {\n+            ModuleSource::Preexisting(_) => Disposition::Reused,\n+            ModuleSource::Translated(_) => Disposition::Translated,\n+        }\n+    }\n+\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(name) {\n+                if let Some(value) = item.value_str() {\n+                    return value;\n+                } else {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"associated value expected for `{}`\", name));\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_fatal(\n+            attr.span,\n+            &format!(\"no field `{}`\", name));\n+    }\n+\n+    /// Scan for a `cfg=\"foo\"` attribute and check whether we have a\n+    /// cfg flag called `foo`.\n+    fn check_config(&self, attr: &ast::Attribute) -> bool {\n+        let config = &self.tcx.map.krate().config;\n+        let value = self.field(attr, CFG);\n+        debug!(\"check_config(config={:?}, value={:?})\", config, value);\n+        if config.iter().any(|c| c.check_name(&value[..])) {\n+            debug!(\"check_config: matched\");\n+            return true;\n+        }\n+        debug!(\"check_config: no match found\");\n+        return false;\n+    }\n+\n+}"}, {"sha": "69a884431359d1a4679027f5e665a1bc4c93bf63", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -30,6 +30,7 @@ use super::ModuleLlvm;\n use super::ModuleSource;\n use super::ModuleTranslation;\n \n+use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n@@ -2558,6 +2559,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         })\n         .collect();\n \n+    assert_module_sources::assert_module_sources(tcx, &modules);\n+\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.no_trans {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);"}, {"sha": "67475081caec7413669014d0261c866e58ac153a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -88,6 +88,7 @@ mod macros;\n mod abi;\n mod adt;\n mod asm;\n+mod assert_module_sources;\n mod attributes;\n mod base;\n mod basic_block;"}, {"sha": "f80f25a2e776d7c1521233542715417c33ed004b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -481,6 +481,16 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n+    (\"rustc_partition_reused\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                  \"this attribute \\\n+                                                   is just used for rustc unit tests \\\n+                                                   and will never be stable\",\n+                                                  cfg_fn!(rustc_attrs))),\n+    (\"rustc_partition_translated\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                      \"this attribute \\\n+                                                       is just used for rustc unit tests \\\n+                                                       and will never be stable\",\n+                                                      cfg_fn!(rustc_attrs))),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n                                              \"internal rustc attributes will never be stable\",\n                                              cfg_fn!(rustc_attrs))),"}, {"sha": "e84906d12d0ced3d2aaf802c9fc1c1ed8b3f37f3", "filename": "src/test/incremental/spike-neg1.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg1.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A variant of the first \"spike\" test that serves to test the\n+// `rustc_partition_reused` and `rustc_partition_translated` tests.\n+// Here we change and say that the `x` module will be reused (when in\n+// fact it will not), and then indicate that the test itself\n+// should-fail (because an error will be reported, and hence the\n+// revision rpass2 will not compile, despite being named rpass).\n+\n+// revisions:rpass1 rpass2\n+// should-fail\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike_neg1\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spike_neg1-x\", cfg=\"rpass2\")] // this is wrong!\n+#![rustc_partition_reused(module=\"spike_neg1-y\", cfg=\"rpass2\")]\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "40f4b4f0c44ce1067001f1d2536e0c4010de9f42", "filename": "src/test/incremental/spike-neg2.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg2.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A variant of the first \"spike\" test that serves to test the\n+// `rustc_partition_reused` and `rustc_partition_translated` tests.\n+// Here we change and say that the `y` module will be translated (when\n+// in fact it will not), and then indicate that the test itself\n+// should-fail (because an error will be reported, and hence the\n+// revision rpass2 will not compile, despite being named rpass).\n+\n+// revisions:rpass1 rpass2\n+// should-fail\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike_neg2\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike_neg2-x\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike_neg2-y\", cfg=\"rpass2\")] // this is wrong!\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "68af20d41915159dcc778d9e028c50e1589567e5", "filename": "src/test/incremental/spike.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77/src%2Ftest%2Fincremental%2Fspike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike.rs?ref=08a72d20c9c97ab7b1d3b023d6cc0caddcd12f77", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A first \"spike\" for incremental compilation: here, we change the\n+// content of the `make` function, and we find that we can reuse the\n+// `y` module entirely (but not the `x` module).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spike-y\", cfg=\"rpass2\")]\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}]}