{"sha": "9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "node_id": "C_kwDOAAsO6NoAKDlmMWY0Mjg5N2QwZTBhZTU4MGYyZTQ5YTFiNDZmYWQyN2I2MDk5MGU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-01T19:57:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-01T19:57:42Z"}, "message": "Rollup merge of #88502 - ibraheemdev:slice-take, r=dtolnay\n\nAdd slice take methods\n\nRevival of #62282\n\nThis PR adds the following slice methods:\n\n- `take`\n- `take_mut`\n- `take_first`\n- `take_first_mut`\n- `take_last`\n- `take_last_mut`\n\nr? `@LukasKalbertodt`", "tree": {"sha": "987e69fb9fd4f9570c72400cfb3acf9cd0cfda10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/987e69fb9fd4f9570c72400cfb3acf9cd0cfda10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhp9O3CRBK7hj4Ov3rIwAA07YIAFW55JO8WjGa/8Sf/JAV4Oe9\nuLzVSABzH+wXiWnohiTgcfYm5+R63py3MO/2d5RL262FKBxZvYQ0rh4Zs3cAW5Ip\n2DPUBMBD63Q1EQKTf4wOZICfSpAkjXdYCh+18hLpFbrqFpy+yg1ork7NOJyfB1nB\ncWNgtUPm37tCOrtarG7ctji5v0sgiwCiY0PbLNYbLWOZ4FClPPO20gI+SSFAEUBg\nDX6t8Y5jAaILo9zRTnRiAb4TBpHq+InGaJMuBhCAHuDMXaZoEgTt41Cj1r2w0N6Q\nCWCJEUeVyOoYWejn4vBACY/KODHDu0FaHd4sl03+mNsLUENSwzicXJ4kndi2nLk=\n=Tvn8\n-----END PGP SIGNATURE-----\n", "payload": "tree 987e69fb9fd4f9570c72400cfb3acf9cd0cfda10\nparent f04a2f4b8e89eac1119061ea2055d33c97e618b4\nparent 8db85a3c78bae764ea069aed9db7cf8012d13a48\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638388662 +0100\ncommitter GitHub <noreply@github.com> 1638388662 +0100\n\nRollup merge of #88502 - ibraheemdev:slice-take, r=dtolnay\n\nAdd slice take methods\n\nRevival of #62282\n\nThis PR adds the following slice methods:\n\n- `take`\n- `take_mut`\n- `take_first`\n- `take_first_mut`\n- `take_last`\n- `take_last_mut`\n\nr? `@LukasKalbertodt`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "html_url": "https://github.com/rust-lang/rust/commit/9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f04a2f4b8e89eac1119061ea2055d33c97e618b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04a2f4b8e89eac1119061ea2055d33c97e618b4", "html_url": "https://github.com/rust-lang/rust/commit/f04a2f4b8e89eac1119061ea2055d33c97e618b4"}, {"sha": "8db85a3c78bae764ea069aed9db7cf8012d13a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/8db85a3c78bae764ea069aed9db7cf8012d13a48", "html_url": "https://github.com/rust-lang/rust/commit/8db85a3c78bae764ea069aed9db7cf8012d13a48"}], "stats": {"total": 395, "additions": 394, "deletions": 1}, "files": [{"sha": "6c8660313708d7ca053d213029b569e9722e58df", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "patch": "@@ -181,6 +181,9 @@ pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+pub use self::range::OneSidedRange;\n+\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub use self::try_trait::{FromResidual, Try};\n "}, {"sha": "1136722067874250be22bfba32ef44aa126a213b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "patch": "@@ -971,3 +971,21 @@ impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n         Included(self.end)\n     }\n }\n+\n+/// `OneSidedRange` is implemented for built-in range types that are unbounded\n+/// on one side. For example, `a..`, `..b` and `..=c` implement `OneSidedRange`,\n+/// but `..`, `d..e`, and `f..=g` do not.\n+///\n+/// Types that implement `OneSidedRange<T>` must return `Bound::Unbounded`\n+/// from one of `RangeBounds::start_bound` or `RangeBounds::end_bound`.\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+pub trait OneSidedRange<T: ?Sized>: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeTo<T> where Self: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeFrom<T> where Self: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeToInclusive<T> where Self: RangeBounds<T> {}"}, {"sha": "a3f59d307595485aeeb6e0c0df7db95899c0032c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 263, "deletions": 1, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "patch": "@@ -10,7 +10,7 @@ use crate::cmp::Ordering::{self, Greater, Less};\n use crate::marker::Copy;\n use crate::mem;\n use crate::num::NonZeroUsize;\n-use crate::ops::{FnMut, Range, RangeBounds};\n+use crate::ops::{Bound, FnMut, OneSidedRange, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr;\n@@ -82,6 +82,29 @@ pub use index::range;\n #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n pub use ascii::EscapeAscii;\n \n+/// Calculates the direction and split point of a one-sided range.\n+///\n+/// This is a helper function for `take` and `take_mut` that returns\n+/// the direction of the split (front or back) as well as the index at\n+/// which to split. Returns `None` if the split index would overflow.\n+#[inline]\n+fn split_point_of(range: impl OneSidedRange<usize>) -> Option<(Direction, usize)> {\n+    use Bound::*;\n+\n+    Some(match (range.start_bound(), range.end_bound()) {\n+        (Unbounded, Excluded(i)) => (Direction::Front, *i),\n+        (Unbounded, Included(i)) => (Direction::Front, i.checked_add(1)?),\n+        (Excluded(i), Unbounded) => (Direction::Back, i.checked_add(1)?),\n+        (Included(i), Unbounded) => (Direction::Back, *i),\n+        _ => unreachable!(),\n+    })\n+}\n+\n+enum Direction {\n+    Front,\n+    Back,\n+}\n+\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -3517,6 +3540,245 @@ impl<T> [T] {\n     {\n         self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\n     }\n+\n+    /// Removes the subslice corresponding to the given range\n+    /// and returns a reference to it.\n+    ///\n+    /// Returns `None` and does not modify the slice if the given\n+    /// range is out of bounds.\n+    ///\n+    /// Note that this method only accepts one-sided ranges such as\n+    /// `2..` or `..6`, but not `2..6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Taking the first three elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    /// let mut first_three = slice.take(..3).unwrap();\n+    ///\n+    /// assert_eq!(slice, &['d']);\n+    /// assert_eq!(first_three, &['a', 'b', 'c']);\n+    /// ```\n+    ///\n+    /// Taking the last two elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    /// let mut tail = slice.take(2..).unwrap();\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(tail, &['c', 'd']);\n+    /// ```\n+    ///\n+    /// Getting `None` when `range` is out of bounds:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    ///\n+    /// assert_eq!(None, slice.take(5..));\n+    /// assert_eq!(None, slice.take(..5));\n+    /// assert_eq!(None, slice.take(..=4));\n+    /// let expected: &[char] = &['a', 'b', 'c', 'd'];\n+    /// assert_eq!(Some(expected), slice.take(..4));\n+    /// ```\n+    #[inline]\n+    #[must_use = \"method does not modify the slice if the range is out of bounds\"]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take<'a, R: OneSidedRange<usize>>(self: &mut &'a Self, range: R) -> Option<&'a Self> {\n+        let (direction, split_index) = split_point_of(range)?;\n+        if split_index > self.len() {\n+            return None;\n+        }\n+        let (front, back) = self.split_at(split_index);\n+        match direction {\n+            Direction::Front => {\n+                *self = back;\n+                Some(front)\n+            }\n+            Direction::Back => {\n+                *self = front;\n+                Some(back)\n+            }\n+        }\n+    }\n+\n+    /// Removes the subslice corresponding to the given range\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// Returns `None` and does not modify the slice if the given\n+    /// range is out of bounds.\n+    ///\n+    /// Note that this method only accepts one-sided ranges such as\n+    /// `2..` or `..6`, but not `2..6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Taking the first three elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// let mut first_three = slice.take_mut(..3).unwrap();\n+    ///\n+    /// assert_eq!(slice, &mut ['d']);\n+    /// assert_eq!(first_three, &mut ['a', 'b', 'c']);\n+    /// ```\n+    ///\n+    /// Taking the last two elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// let mut tail = slice.take_mut(2..).unwrap();\n+    ///\n+    /// assert_eq!(slice, &mut ['a', 'b']);\n+    /// assert_eq!(tail, &mut ['c', 'd']);\n+    /// ```\n+    ///\n+    /// Getting `None` when `range` is out of bounds:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    ///\n+    /// assert_eq!(None, slice.take_mut(5..));\n+    /// assert_eq!(None, slice.take_mut(..5));\n+    /// assert_eq!(None, slice.take_mut(..=4));\n+    /// let expected: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// assert_eq!(Some(expected), slice.take_mut(..4));\n+    /// ```\n+    #[inline]\n+    #[must_use = \"method does not modify the slice if the range is out of bounds\"]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_mut<'a, R: OneSidedRange<usize>>(\n+        self: &mut &'a mut Self,\n+        range: R,\n+    ) -> Option<&'a mut Self> {\n+        let (direction, split_index) = split_point_of(range)?;\n+        if split_index > self.len() {\n+            return None;\n+        }\n+        let (front, back) = mem::take(self).split_at_mut(split_index);\n+        match direction {\n+            Direction::Front => {\n+                *self = back;\n+                Some(front)\n+            }\n+            Direction::Back => {\n+                *self = front;\n+                Some(back)\n+            }\n+        }\n+    }\n+\n+    /// Removes the first element of the slice and returns a reference\n+    /// to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c'];\n+    /// let first = slice.take_first().unwrap();\n+    ///\n+    /// assert_eq!(slice, &['b', 'c']);\n+    /// assert_eq!(first, &'a');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_first<'a>(self: &mut &'a Self) -> Option<&'a T> {\n+        let (first, rem) = self.split_first()?;\n+        *self = rem;\n+        Some(first)\n+    }\n+\n+    /// Removes the first element of the slice and returns a mutable\n+    /// reference to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c'];\n+    /// let first = slice.take_first_mut().unwrap();\n+    /// *first = 'd';\n+    ///\n+    /// assert_eq!(slice, &['b', 'c']);\n+    /// assert_eq!(first, &'d');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_first_mut<'a>(self: &mut &'a mut Self) -> Option<&'a mut T> {\n+        let (first, rem) = mem::take(self).split_first_mut()?;\n+        *self = rem;\n+        Some(first)\n+    }\n+\n+    /// Removes the last element of the slice and returns a reference\n+    /// to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c'];\n+    /// let last = slice.take_last().unwrap();\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(last, &'c');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_last<'a>(self: &mut &'a Self) -> Option<&'a T> {\n+        let (last, rem) = self.split_last()?;\n+        *self = rem;\n+        Some(last)\n+    }\n+\n+    /// Removes the last element of the slice and returns a mutable\n+    /// reference to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c'];\n+    /// let last = slice.take_last_mut().unwrap();\n+    /// *last = 'd';\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(last, &'d');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_last_mut<'a>(self: &mut &'a mut Self) -> Option<&'a mut T> {\n+        let (last, rem) = mem::take(self).split_last_mut()?;\n+        *self = rem;\n+        Some(last)\n+    }\n }\n \n trait CloneFromSpec<T> {"}, {"sha": "414995e8f7a7422914e516534b3ce36dbe907e37", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "patch": "@@ -36,6 +36,7 @@\n #![feature(pattern)]\n #![feature(sort_internals)]\n #![feature(slice_partition_at_index)]\n+#![feature(slice_take)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_array_assume_init)]\n #![feature(maybe_uninit_extra)]"}, {"sha": "7ba01caeefd7ceef26ef462739d07fb1b91d0fbc", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1f42897d0e0ae580f2e49a1b46fad27b60990e/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=9f1f42897d0e0ae580f2e49a1b46fad27b60990e", "patch": "@@ -2234,3 +2234,112 @@ fn slice_split_array_mut_out_of_bounds() {\n \n     v.split_array_mut::<7>();\n }\n+\n+macro_rules! take_tests {\n+    (slice: &[], $($tts:tt)*) => {\n+        take_tests!(ty: &[()], slice: &[], $($tts)*);\n+    };\n+    (slice: &mut [], $($tts:tt)*) => {\n+        take_tests!(ty: &mut [()], slice: &mut [], $($tts)*);\n+    };\n+    (slice: &$slice:expr, $($tts:tt)*) => {\n+        take_tests!(ty: &[_], slice: &$slice, $($tts)*);\n+    };\n+    (slice: &mut $slice:expr, $($tts:tt)*) => {\n+        take_tests!(ty: &mut [_], slice: &mut $slice, $($tts)*);\n+    };\n+    (ty: $ty:ty, slice: $slice:expr, method: $method:ident, $(($test_name:ident, ($($args:expr),*), $output:expr, $remaining:expr),)*) => {\n+        $(\n+            #[test]\n+            fn $test_name() {\n+                let mut slice: $ty = $slice;\n+                assert_eq!($output, slice.$method($($args)*));\n+                let remaining: $ty = $remaining;\n+                assert_eq!(remaining, slice);\n+            }\n+        )*\n+    };\n+}\n+\n+take_tests! {\n+    slice: &[0, 1, 2, 3], method: take,\n+    (take_in_bounds_range_to, (..1), Some(&[0] as _), &[1, 2, 3]),\n+    (take_in_bounds_range_to_inclusive, (..=0), Some(&[0] as _), &[1, 2, 3]),\n+    (take_in_bounds_range_from, (2..), Some(&[2, 3] as _), &[0, 1]),\n+    (take_oob_range_to, (..5), None, &[0, 1, 2, 3]),\n+    (take_oob_range_to_inclusive, (..=4), None, &[0, 1, 2, 3]),\n+    (take_oob_range_from, (5..), None, &[0, 1, 2, 3]),\n+}\n+\n+take_tests! {\n+    slice: &mut [0, 1, 2, 3], method: take_mut,\n+    (take_mut_in_bounds_range_to, (..1), Some(&mut [0] as _), &mut [1, 2, 3]),\n+    (take_mut_in_bounds_range_to_inclusive, (..=0), Some(&mut [0] as _), &mut [1, 2, 3]),\n+    (take_mut_in_bounds_range_from, (2..), Some(&mut [2, 3] as _), &mut [0, 1]),\n+    (take_mut_oob_range_to, (..5), None, &mut [0, 1, 2, 3]),\n+    (take_mut_oob_range_to_inclusive, (..=4), None, &mut [0, 1, 2, 3]),\n+    (take_mut_oob_range_from, (5..), None, &mut [0, 1, 2, 3]),\n+}\n+\n+take_tests! {\n+    slice: &[1, 2], method: take_first,\n+    (take_first_nonempty, (), Some(&1), &[2]),\n+}\n+\n+take_tests! {\n+    slice: &mut [1, 2], method: take_first_mut,\n+    (take_first_mut_nonempty, (), Some(&mut 1), &mut [2]),\n+}\n+\n+take_tests! {\n+    slice: &[1, 2], method: take_last,\n+    (take_last_nonempty, (), Some(&2), &[1]),\n+}\n+\n+take_tests! {\n+    slice: &mut [1, 2], method: take_last_mut,\n+    (take_last_mut_nonempty, (), Some(&mut 2), &mut [1]),\n+}\n+\n+take_tests! {\n+    slice: &[], method: take_first,\n+    (take_first_empty, (), None, &[]),\n+}\n+\n+take_tests! {\n+    slice: &mut [], method: take_first_mut,\n+    (take_first_mut_empty, (), None, &mut []),\n+}\n+\n+take_tests! {\n+    slice: &[], method: take_last,\n+    (take_last_empty, (), None, &[]),\n+}\n+\n+take_tests! {\n+    slice: &mut [], method: take_last_mut,\n+    (take_last_mut_empty, (), None, &mut []),\n+}\n+\n+const EMPTY_MAX: &'static [()] = &[(); usize::MAX];\n+\n+// can't be a constant due to const mutability rules\n+macro_rules! empty_max_mut {\n+    () => {\n+        &mut [(); usize::MAX] as _\n+    };\n+}\n+\n+take_tests! {\n+    slice: &[(); usize::MAX], method: take,\n+    (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n+    (take_oob_max_range_to_inclusive, (..=usize::MAX), None, EMPTY_MAX),\n+    (take_in_bounds_max_range_from, (usize::MAX..), Some(&[] as _), EMPTY_MAX),\n+}\n+\n+take_tests! {\n+    slice: &mut [(); usize::MAX], method: take_mut,\n+    (take_mut_in_bounds_max_range_to, (..usize::MAX), Some(empty_max_mut!()), &mut [(); 0]),\n+    (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n+    (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n+}"}]}