{"sha": "9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjBiYWI5ZGVlNmU2NTBjZTZmOWUwMWYwZTNlYjIyY2EzMDI3OTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:38Z"}, "message": "Rollup merge of #23867 - nikomatsakis:issue-23086-take-3, r=pnkfelix\n\nThis PR implements rust-lang/rfcs#1023. In the process it fixes #23086 and #23516. A few impls in libcore had to be updated, but the impact is generally pretty minimal. Most of the fallout is in the tests that probed the limits of today's coherence.\r\n\r\nI tested and we were able to build the most popular crates along with iron (modulo errors around errors being sendable).\r\n\r\nFixes #23918.", "tree": {"sha": "7563298341e5828d924b91686298b9bdfc2172e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7563298341e5828d924b91686298b9bdfc2172e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "html_url": "https://github.com/rust-lang/rust/commit/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abd747cd153c1ef3648831916017fb692200387d", "url": "https://api.github.com/repos/rust-lang/rust/commits/abd747cd153c1ef3648831916017fb692200387d", "html_url": "https://github.com/rust-lang/rust/commit/abd747cd153c1ef3648831916017fb692200387d"}, {"sha": "15b58fedcacba7d10a9f7d460a83da645a09ad3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b58fedcacba7d10a9f7d460a83da645a09ad3e", "html_url": "https://github.com/rust-lang/rust/commit/15b58fedcacba7d10a9f7d460a83da645a09ad3e"}], "stats": {"total": 1035, "additions": 808, "deletions": 227}, "files": [{"sha": "c4541e34cdb359189778c55b280456062bd1eaa1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -86,6 +86,7 @@ pub static HEAP: () = ();\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[fundamental]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n@@ -277,13 +278,6 @@ impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Box<Any> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"Box<Any>\")\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;"}, {"sha": "fc44ac4eac628b2eba405276caedb542f5d49bff", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -55,17 +55,17 @@ fn test_show() {\n     let b = Box::new(Test) as Box<Any>;\n     let a_str = format!(\"{:?}\", a);\n     let b_str = format!(\"{:?}\", b);\n-    assert_eq!(a_str, \"Box<Any>\");\n-    assert_eq!(b_str, \"Box<Any>\");\n+    assert_eq!(a_str, \"Any\");\n+    assert_eq!(b_str, \"Any\");\n \n     static EIGHT: usize = 8;\n     static TEST: Test = Test;\n     let a = &EIGHT as &Any;\n     let b = &TEST as &Any;\n     let s = format!(\"{:?}\", a);\n-    assert_eq!(s, \"&Any\");\n+    assert_eq!(s, \"Any\");\n     let s = format!(\"{:?}\", b);\n-    assert_eq!(s, \"&Any\");\n+    assert_eq!(s, \"Any\");\n }\n \n #[test]"}, {"sha": "a8be63d637359beff197d7947b43a037023d8b15", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -71,6 +71,8 @@\n #![feature(no_std)]\n #![no_std]\n #![feature(allocator)]\n+#![feature(custom_attribute)]\n+#![feature(fundamental)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]"}, {"sha": "320fdd50b3510bd41df790ca167bb72857839f85", "filename": "src/libcore/any.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -71,6 +71,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use fmt;\n use marker::Send;\n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -105,6 +106,13 @@ impl<T> Any for T\n // Extension methods for Any trait objects.\n ///////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Any {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Any\")\n+    }\n+}\n+\n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3f8bbeb1feb88eb35126a9f16b3efd061141d240", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -12,7 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use any;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::Iterator;\n@@ -997,11 +996,6 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Debug for &'a (any::Any+'a) {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {"}, {"sha": "3a9af50fefbc78c29f2453144563bfb506c1dc86", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -70,8 +70,10 @@\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n #![feature(optin_builtin_traits)]\n+#![feature(fundamental)]\n #![feature(concat_idents)]\n #![feature(reflect)]\n+#![feature(custom_attribute)]\n \n #[macro_use]\n mod macros;"}, {"sha": "97bde9fc96eec1bce25789b066c9f9329bc0799f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -49,6 +49,7 @@ impl !Send for Managed { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n+#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized : MarkerTrait {\n     // Empty.\n }"}, {"sha": "399aec9afd440b542bd6270b1a3de0b4f5ff5a30", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -1117,6 +1117,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait Fn<Args> : FnMut<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -1126,6 +1127,7 @@ pub trait Fn<Args> : FnMut<Args> {\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -1135,6 +1137,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[lang=\"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     type Output;"}, {"sha": "862ced78c082c5056322e6ec8db9e6f4c2777e9f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -34,8 +34,7 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n-use syntax::ast_map::{PathElem, PathElems};\n-use syntax::ast_map;\n+use syntax::ast_map::{self, LinkedPath, PathElem, PathElems};\n use syntax::ast_util::*;\n use syntax::ast_util;\n use syntax::attr;\n@@ -1513,7 +1512,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         &krate.module,\n                         &[],\n                         ast::CRATE_NODE_ID,\n-                        [].iter().cloned().chain(None),\n+                        [].iter().cloned().chain(LinkedPath::empty()),\n                         syntax::parse::token::special_idents::invalid,\n                         ast::Public);\n \n@@ -1874,7 +1873,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, rbml_w, 0, [].iter().cloned().chain(None));\n+    encode_reexports(ecx, rbml_w, 0, [].iter().cloned().chain(LinkedPath::empty()));\n \n     rbml_w.end_tag();\n     rbml_w.end_tag();"}, {"sha": "411be28b89695162d75d435751b793d64ec6788b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 150, "deletions": 53, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -17,15 +17,17 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n-use middle::subst::{Subst, TypeSpace};\n+use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n \n+#[derive(Copy)]\n+struct ParamIsLocal(bool);\n+\n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n                          impl1_def_id: ast::DefId,\n@@ -56,10 +58,16 @@ fn overlap(selcx: &mut SelectionContext,\n            a_def_id.repr(selcx.tcx()),\n            b_def_id.repr(selcx.tcx()));\n \n-    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n-    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                a_def_id,\n+                                                                util::free_substs_for_impl);\n+\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                b_def_id,\n+                                                                util::fresh_type_vars_for_impl);\n \n     debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+\n     debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n \n     // Does `a <: b` hold? If not, no overlap.\n@@ -74,28 +82,68 @@ fn overlap(selcx: &mut SelectionContext,\n     debug!(\"overlap: subtraitref check succeeded\");\n \n     // Are any of the obligations unsatisfiable? If so, no overlap.\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n     let opt_failing_obligation =\n         a_obligations.iter()\n                      .chain(b_obligations.iter())\n+                     .map(|o| infcx.resolve_type_vars_if_possible(o))\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(selcx.tcx()));\n-        return false;\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(tcx));\n+        return false\n     }\n \n     true\n }\n \n+pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n+{\n+    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr(tcx));\n+\n+    // if the orphan rules pass, that means that no ancestor crate can\n+    // impl this, so it's up to us.\n+    if orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(false)).is_ok() {\n+        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+        return true;\n+    }\n+\n+    // if the trait is not marked fundamental, then it's always possible that\n+    // an ancestor crate will impl this in the future, if they haven't\n+    // already\n+    if\n+        trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n+        !ty::has_attr(tcx, trait_ref.def_id, \"fundamental\")\n+    {\n+        debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n+        return false;\n+    }\n+\n+    // find out when some downstream (or cousin) crate could impl this\n+    // trait-ref, presuming that all the parameters were instantiated\n+    // with downstream types. If not, then it could only be\n+    // implemented by an upstream crate, which means that the impl\n+    // must be visible to us, and -- since the trait is fundamental\n+    // -- we can test.\n+    orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(true)).is_err()\n+}\n+\n+type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n+                                span: Span,\n+                                impl_def_id: ast::DefId)\n+                                -> Substs<'tcx>;\n+\n /// Instantiate fresh variables for all bound parameters of the impl\n /// and return the impl trait ref with those variables substituted.\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: ast::DefId)\n+                                     impl_def_id: ast::DefId,\n+                                     substs_fn: SubstsFn)\n                                      -> (Rc<ty::TraitRef<'tcx>>,\n                                          Vec<PredicateObligation<'tcx>>)\n {\n     let impl_substs =\n-        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+        &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n     let impl_trait_ref =\n         ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n     let impl_trait_ref =\n@@ -134,12 +182,12 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n+    debug!(\"orphan_check({})\", impl_def_id.repr(tcx));\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n@@ -148,34 +196,106 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return Ok(());\n     }\n \n+    orphan_check_trait_ref(tcx, &trait_ref, ParamIsLocal(false))\n+}\n+\n+fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                trait_ref: &ty::TraitRef<'tcx>,\n+                                param_is_local: ParamIsLocal)\n+                                -> Result<(), OrphanCheckErr<'tcx>>\n+{\n+    debug!(\"orphan_check_trait_ref(trait_ref={}, param_is_local={})\",\n+           trait_ref.repr(tcx), param_is_local.0);\n+\n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     let input_tys = Some(trait_ref.self_ty());\n     let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace).iter());\n-    let mut input_tys = input_tys;\n \n     // Find the first input type that either references a type parameter OR\n     // some local type.\n-    match input_tys.find(|&&input_ty| references_local_or_type_parameter(tcx, input_ty)) {\n-        Some(&input_ty) => {\n-            // Within this first type, check that all type parameters are covered by a local\n-            // type constructor. Note that if there is no local type constructor, then any\n-            // type parameter at all will be an error.\n-            let covered_params = type_parameters_covered_by_ty(tcx, input_ty);\n-            let all_params = type_parameters_reachable_from_ty(input_ty);\n-            for &param in all_params.difference(&covered_params) {\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n+    for input_ty in input_tys {\n+        if ty_is_local(tcx, input_ty, param_is_local) {\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n+\n+            // First local input type. Check that there are no\n+            // uncovered type parameters.\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, param_is_local);\n+            for uncovered_ty in uncovered_tys {\n+                if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                    return Err(OrphanCheckErr::UncoveredTy(param));\n+                }\n             }\n+\n+            // OK, found local type, all prior types upheld invariant.\n+            return Ok(());\n         }\n-        None => {\n-            return Err(OrphanCheckErr::NoLocalInputType);\n+\n+        // Otherwise, enforce invariant that there are no type\n+        // parameters reachable.\n+        if !param_is_local.0 {\n+            if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n+                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                return Err(OrphanCheckErr::UncoveredTy(param));\n+            }\n         }\n     }\n \n-    return Ok(());\n+    // If we exit above loop, never found a local type.\n+    debug!(\"orphan_check_trait_ref: no local type\");\n+    return Err(OrphanCheckErr::NoLocalInputType);\n+}\n+\n+fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       param_is_local: ParamIsLocal)\n+                       -> Vec<Ty<'tcx>>\n+{\n+    if ty_is_local_constructor(tcx, ty, param_is_local) {\n+        vec![]\n+    } else if fundamental_ty(tcx, ty) {\n+        ty.walk_shallow()\n+          .flat_map(|t| uncovered_tys(tcx, t, param_is_local).into_iter())\n+          .collect()\n+    } else {\n+        vec![ty]\n+    }\n }\n \n-fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        // FIXME(#20590) straighten story about projection types\n+        ty::ty_projection(..) | ty::ty_param(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, param_is_local: ParamIsLocal) -> bool\n+{\n+    ty_is_local_constructor(tcx, ty, param_is_local) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, param_is_local))\n+}\n+\n+fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n+{\n+    match ty.sty {\n+        ty::ty_uniq(..) | ty::ty_rptr(..) =>\n+            true,\n+        ty::ty_enum(def_id, _) | ty::ty_struct(def_id, _) =>\n+            ty::has_attr(tcx, def_id, \"fundamental\"),\n+        ty::ty_trait(ref data) =>\n+            ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n+        _ =>\n+            false\n+    }\n+}\n+\n+fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 param_is_local: ParamIsLocal)\n+                                 -> bool\n+{\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n     match ty.sty {\n@@ -190,11 +310,15 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_tup(..) |\n-        ty::ty_param(..) |\n+        ty::ty_infer(..) |\n         ty::ty_projection(..) => {\n             false\n         }\n \n+        ty::ty_param(..) => {\n+            param_is_local.0\n+        }\n+\n         ty::ty_enum(def_id, _) |\n         ty::ty_struct(def_id, _) => {\n             def_id.krate == ast::LOCAL_CRATE\n@@ -210,7 +334,6 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_closure(..) |\n-        ty::ty_infer(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n@@ -219,30 +342,4 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                       ty: Ty<'tcx>)\n-                                       -> HashSet<Ty<'tcx>>\n-{\n-    if ty_is_local_constructor(tcx, ty) {\n-        type_parameters_reachable_from_ty(ty)\n-    } else {\n-        ty.walk_children().flat_map(|t| type_parameters_covered_by_ty(tcx, t).into_iter()).collect()\n-    }\n-}\n-\n-/// All type parameters reachable from `ty`\n-fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<Ty<'tcx>> {\n-    ty.walk().filter(|&t| is_type_parameter(t)).collect()\n-}\n-\n-fn references_local_or_type_parameter<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.walk().any(|ty| is_type_parameter(ty) || ty_is_local_constructor(tcx, ty))\n-}\n \n-fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        // FIXME(#20590) straighten story about projection types\n-        ty::ty_projection(..) | ty::ty_param(..) => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "cb9d90744a4464b0a665b7b28a50ce3c6949ecc5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -17,6 +17,7 @@ use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n+use super::coherence;\n use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n@@ -81,7 +82,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n+    previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n #[derive(Clone)]\n@@ -245,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n-        let stack = self.push_stack(None, obligation);\n+        let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n             None => {\n                 self.consider_unification_despite_ambiguity(obligation);\n@@ -327,7 +328,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        self.evaluate_predicate_recursively(None, obligation).may_apply()\n+        self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+            .may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively<'o>(&mut self,\n@@ -346,7 +348,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligation {\n             Ok(obligation) => {\n-                self.evaluate_predicate_recursively(Some(previous_stack), &obligation)\n+                self.evaluate_predicate_recursively(previous_stack.list(), &obligation)\n             }\n             Err(ErrorReported) => {\n                 EvaluatedToOk\n@@ -355,7 +357,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n-                                                stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                                stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult<'tcx>\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n@@ -372,7 +374,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n-                                          previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                          previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n@@ -423,14 +425,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                            obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n \n-        let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n+        let stack = self.push_stack(previous_stack, obligation);\n \n         let result = self.evaluate_stack(&stack);\n \n@@ -538,7 +540,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                        obligation.recursion_depth + 1,\n                                                        skol_map,\n                                                        snapshot);\n-                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                    self.winnow_selection(TraitObligationStackList::empty(),\n+                                          VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n                     false\n@@ -607,6 +610,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(Some(ErrorCandidate));\n         }\n \n+        if !self.is_knowable(stack) {\n+            debug!(\"intercrate not knowable\");\n+            return Ok(None);\n+        }\n+\n         let candidate_set = try!(self.assemble_candidates(stack));\n \n         if candidate_set.ambiguous {\n@@ -707,6 +715,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n+    fn is_knowable<'o>(&mut self,\n+                       stack: &TraitObligationStack<'o, 'tcx>)\n+                       -> bool\n+    {\n+        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+\n+        if !self.intercrate {\n+            return true;\n+        }\n+\n+        let obligation = &stack.obligation;\n+        let predicate = self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        // ok to skip binder because of the nature of the\n+        // trait-ref-is-knowable check, which does not care about\n+        // bound regions\n+        let trait_ref = &predicate.skip_binder().trait_ref;\n+\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+    }\n+\n     fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n@@ -1026,7 +1055,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx().probe(move |_| {\n             match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(Some(stack), obligations.iter())\n+                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => {\n                     EvaluatedToErr(Unimplemented)\n@@ -1310,7 +1339,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => self.winnow_selection(Some(stack), selection),\n+                Ok(selection) => self.winnow_selection(stack.list(),\n+                                                       selection),\n                 Err(error) => EvaluatedToErr(error),\n             }\n         });\n@@ -1320,7 +1350,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn winnow_selection<'o>(&mut self,\n-                            stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                            stack: TraitObligationStackList<'o,'tcx>,\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n@@ -2303,9 +2333,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation.cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation.cause.span,\n+                                                         impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n@@ -2423,9 +2453,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // Create fresh type variables for each type parameter declared\n         // on the impl etc.\n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation_cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation_cause.span,\n+                                                         impl_def_id);\n \n         // Find the self type for the impl.\n         let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n@@ -2476,7 +2506,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Miscellany\n \n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s TraitObligationStack<'s, 'tcx>>,\n+                            previous_stack: TraitObligationStackList<'s, 'tcx>,\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n@@ -2486,7 +2516,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         TraitObligationStack {\n             obligation: obligation,\n             fresh_trait_ref: fresh_trait_ref,\n-            previous: previous_stack.map(|p| p), // FIXME variance\n+            previous: previous_stack,\n         }\n     }\n \n@@ -2639,17 +2669,36 @@ impl<'tcx> SelectionCache<'tcx> {\n     }\n }\n \n-impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n-    fn iter(&self) -> Option<&TraitObligationStack<'o, 'tcx>> {\n-        Some(self)\n+impl<'o,'tcx> TraitObligationStack<'o,'tcx> {\n+    fn list(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList::with(self)\n+    }\n+\n+    fn iter(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        self.list()\n     }\n }\n \n-impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n+#[derive(Copy, Clone)]\n+struct TraitObligationStackList<'o,'tcx:'o> {\n+    head: Option<&'o TraitObligationStack<'o,'tcx>>\n+}\n+\n+impl<'o,'tcx> TraitObligationStackList<'o,'tcx> {\n+    fn empty() -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: None }\n+    }\n+\n+    fn with(r: &'o TraitObligationStack<'o,'tcx>) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: Some(r) }\n+    }\n+}\n+\n+impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     type Item = &'o TraitObligationStack<'o,'tcx>;\n \n-    fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n-        match *self {\n+    fn next(&mut self) -> Option<&'o TraitObligationStack<'o,'tcx>> {\n+        match self.head {\n             Some(o) => {\n                 *self = o.previous;\n                 Some(o)\n@@ -2659,7 +2708,7 @@ impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n     }\n }\n \n-impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n+impl<'o,'tcx> Repr<'tcx> for TraitObligationStack<'o,'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"TraitObligationStack({})\",\n                 self.obligation.repr(tcx))"}, {"sha": "297cea13207e57a99a5f9871db3e36b9e8a752dd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::region;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n@@ -285,7 +286,6 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     }\n }\n \n-\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////\n@@ -294,16 +294,44 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       span: Span,\n-                                       impl_def_id: ast::DefId)\n-                                       -> Substs<'tcx>\n+pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          impl_def_id: ast::DefId)\n+                                          -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n+// determine the `self` type, using fresh variables for all variables\n+// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n+// would return ($0, $1) where $0 and $1 are freshly instantiated type\n+// variables.\n+pub fn free_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      _span: Span,\n+                                      impl_def_id: ast::DefId)\n+                                      -> Substs<'tcx>\n+{\n+    let tcx = infcx.tcx;\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+\n+    let some_types = impl_generics.types.map(|def| {\n+        ty::mk_param_from_def(tcx, def)\n+    });\n+\n+    let some_regions = impl_generics.regions.map(|def| {\n+        // FIXME. This destruction scope information is pretty darn\n+        // bogus; after all, the impl might not even be in this crate!\n+        // But given what we do in coherence, it is harmless enough\n+        // for now I think. -nmatsakis\n+        let extent = region::DestructionScopeData::new(ast::DUMMY_NODE_ID);\n+        ty::free_region_from_def(extent, def)\n+    });\n+\n+    Substs::new(some_types, some_regions)\n+}\n+\n impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)"}, {"sha": "0814ec2c84e7085f62573c1d6b9235ed6a9f9867", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -58,7 +58,7 @@ use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use middle::ty_walk::TypeWalker;\n+use middle::ty_walk::{self, TypeWalker};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n@@ -89,7 +89,8 @@ use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::{ast, ast_map};\n+use syntax::ast;\n+use syntax::ast_map::{self, LinkedPath};\n \n pub type Disr = u64;\n \n@@ -3167,21 +3168,11 @@ impl<'tcx> TyS<'tcx> {\n         TypeWalker::new(self)\n     }\n \n-    /// Iterator that walks types reachable from `self`, in\n-    /// depth-first order. Note that this is a shallow walk. For\n-    /// example:\n-    ///\n-    /// ```notrust\n-    /// isize => { }\n-    /// Foo<Bar<isize>> => { Bar<isize>, isize }\n-    /// [isize] => { isize }\n-    /// ```\n-    pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n-        // Walks type reachable from `self` but not `self\n-        let mut walker = self.walk();\n-        let r = walker.next();\n-        assert_eq!(r, Some(self));\n-        walker\n+    /// Iterator that walks the immediate children of `self`.  Hence\n+    /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n+    /// (but not `i32`, like `walk`).\n+    pub fn walk_shallow(&'tcx self) -> IntoIter<Ty<'tcx>> {\n+        ty_walk::walk_shallow(self)\n     }\n \n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n@@ -5484,7 +5475,7 @@ pub fn with_path<T, F>(cx: &ctxt, id: ast::DefId, f: F) -> T where\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n-        f(csearch::get_item_path(cx, id).iter().cloned().chain(None))\n+        f(csearch::get_item_path(cx, id).iter().cloned().chain(LinkedPath::empty()))\n     }\n }\n "}, {"sha": "ec09d6dcc1ee2c05e35f121c7b4d1e5e7af6f942", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -12,6 +12,7 @@\n \n use middle::ty::{self, Ty};\n use std::iter::Iterator;\n+use std::vec::IntoIter;\n \n pub struct TypeWalker<'tcx> {\n     stack: Vec<Ty<'tcx>>,\n@@ -23,60 +24,6 @@ impl<'tcx> TypeWalker<'tcx> {\n         TypeWalker { stack: vec!(ty), last_subtree: 1, }\n     }\n \n-    fn push_subtypes(&mut self, parent_ty: Ty<'tcx>) {\n-        match parent_ty.sty {\n-            ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-            ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n-            }\n-            ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n-                self.stack.push(ty);\n-            }\n-            ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-                self.stack.push(mt.ty);\n-            }\n-            ty::ty_projection(ref data) => {\n-                self.push_reversed(data.trait_ref.substs.types.as_slice());\n-            }\n-            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                self.push_reversed(principal.substs().types.as_slice());\n-                self.push_reversed(&bounds.projection_bounds.iter().map(|pred| {\n-                    pred.0.ty\n-                }).collect::<Vec<_>>());\n-            }\n-            ty::ty_enum(_, ref substs) |\n-            ty::ty_struct(_, ref substs) |\n-            ty::ty_closure(_, ref substs) => {\n-                self.push_reversed(substs.types.as_slice());\n-            }\n-            ty::ty_tup(ref ts) => {\n-                self.push_reversed(ts);\n-            }\n-            ty::ty_bare_fn(_, ref ft) => {\n-                self.push_sig_subtypes(&ft.sig);\n-            }\n-        }\n-    }\n-\n-    fn push_sig_subtypes(&mut self, sig: &ty::PolyFnSig<'tcx>) {\n-        match sig.0.output {\n-            ty::FnConverging(output) => { self.stack.push(output); }\n-            ty::FnDiverging => { }\n-        }\n-        self.push_reversed(&sig.0.inputs);\n-    }\n-\n-    fn push_reversed(&mut self, tys: &[Ty<'tcx>]) {\n-        // We push slices on the stack in reverse order so as to\n-        // maintain a pre-order traversal. As of the time of this\n-        // writing, the fact that the traversal is pre-order is not\n-        // known to be significant to any code, but it seems like the\n-        // natural order one would expect (basically, the order of the\n-        // types as they are written).\n-        for &ty in tys.iter().rev() {\n-            self.stack.push(ty);\n-        }\n-    }\n-\n     /// Skips the subtree of types corresponding to the last type\n     /// returned by `next()`.\n     ///\n@@ -105,10 +52,70 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();\n-                self.push_subtypes(ty);\n+                push_subtypes(&mut self.stack, ty);\n                 debug!(\"next: stack={:?}\", self.stack);\n                 Some(ty)\n             }\n         }\n     }\n }\n+\n+pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n+    let mut stack = vec![];\n+    push_subtypes(&mut stack, ty);\n+    stack.into_iter()\n+}\n+\n+fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n+    match parent_ty.sty {\n+        ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+        ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n+        }\n+        ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n+            stack.push(ty);\n+        }\n+        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n+            stack.push(mt.ty);\n+        }\n+        ty::ty_projection(ref data) => {\n+            push_reversed(stack, data.trait_ref.substs.types.as_slice());\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+            push_reversed(stack, principal.substs().types.as_slice());\n+            push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n+                pred.0.ty\n+            }).collect::<Vec<_>>());\n+        }\n+        ty::ty_enum(_, ref substs) |\n+        ty::ty_struct(_, ref substs) |\n+        ty::ty_closure(_, ref substs) => {\n+            push_reversed(stack, substs.types.as_slice());\n+        }\n+        ty::ty_tup(ref ts) => {\n+            push_reversed(stack, ts);\n+        }\n+        ty::ty_bare_fn(_, ref ft) => {\n+            push_sig_subtypes(stack, &ft.sig);\n+        }\n+    }\n+}\n+\n+fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n+    match sig.0.output {\n+        ty::FnConverging(output) => { stack.push(output); }\n+        ty::FnDiverging => { }\n+    }\n+    push_reversed(stack, &sig.0.inputs);\n+}\n+\n+fn push_reversed<'tcx>(stack: &mut Vec<Ty<'tcx>>, tys: &[Ty<'tcx>]) {\n+    // We push slices on the stack in reverse order so as to\n+    // maintain a pre-order traversal. As of the time of this\n+    // writing, the fact that the traversal is pre-order is not\n+    // known to be significant to any code, but it seems like the\n+    // natural order one would expect (basically, the order of the\n+    // types as they are written).\n+    for &ty in tys.iter().rev() {\n+        stack.push(ty);\n+    }\n+}"}, {"sha": "4405a9d75ee62afeda9fc7696b57c454be9b50ac", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -384,13 +384,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => {\n-            if cx.sess.verbose() {\n-                param_ty.repr(cx)\n-            } else {\n-                param_ty.user_string(cx)\n-            }\n-        }\n+        ty_param(ref param_ty) => param_ty.user_string(cx),\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             parameterized(cx, &base, substs, did, &[],"}, {"sha": "2b5cb7076f463c8e4da518d5a5dcf17f32e9fd06", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -53,18 +53,29 @@ impl fmt::Display for PathElem {\n }\n \n #[derive(Clone)]\n-struct LinkedPathNode<'a> {\n+pub struct LinkedPathNode<'a> {\n     node: PathElem,\n     next: LinkedPath<'a>,\n }\n \n-type LinkedPath<'a> = Option<&'a LinkedPathNode<'a>>;\n+#[derive(Copy, Clone)]\n+pub struct LinkedPath<'a>(Option<&'a LinkedPathNode<'a>>);\n+\n+impl<'a> LinkedPath<'a> {\n+    pub fn empty() -> LinkedPath<'a> {\n+        LinkedPath(None)\n+    }\n+\n+    pub fn from(node: &'a LinkedPathNode) -> LinkedPath<'a> {\n+        LinkedPath(Some(node))\n+    }\n+}\n \n impl<'a> Iterator for LinkedPath<'a> {\n     type Item = PathElem;\n \n     fn next(&mut self) -> Option<PathElem> {\n-        match *self {\n+        match self.0 {\n             Some(node) => {\n                 *self = node.next;\n                 Some(node.node)\n@@ -384,7 +395,7 @@ impl<'ast> Map<'ast> {\n     pub fn with_path<T, F>(&self, id: NodeId, f: F) -> T where\n         F: FnOnce(PathElems) -> T,\n     {\n-        self.with_path_next(id, None, f)\n+        self.with_path_next(id, LinkedPath::empty(), f)\n     }\n \n     pub fn path_to_string(&self, id: NodeId) -> String {\n@@ -422,7 +433,7 @@ impl<'ast> Map<'ast> {\n                 _ => f([].iter().cloned().chain(next))\n             }\n         } else {\n-            self.with_path_next(parent, Some(&LinkedPathNode {\n+            self.with_path_next(parent, LinkedPath::from(&LinkedPathNode {\n                 node: self.get_path_elem(id),\n                 next: next\n             }), f)"}, {"sha": "113827a3b402f2bb4f2353d3895705627037ad61", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -91,6 +91,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"start\", \"1.0.0\", Active),\n     (\"main\", \"1.0.0\", Active),\n \n+    (\"fundamental\", \"1.0.0\", Active),\n+\n     // Deprecate after snapshot\n     // SNAP 5520801\n     (\"unsafe_destructor\", \"1.0.0\", Active),\n@@ -237,6 +239,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"allow_internal_unstable\", Gated(\"allow_internal_unstable\",\n                                       EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),\n \n+    (\"fundamental\", Gated(\"fundamental\",\n+                          \"the `#[fundamental]` attribute \\\n+                           is an experimental feature\")),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted),\n "}, {"sha": "a1e1b48c2c4e98a6987a7e8c15839641f8856c7a", "filename": "src/test/auxiliary/coherence_copy_like_lib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![feature(fundamental)]\n+\n+use std::marker::MarkerTrait;\n+\n+pub trait MyCopy : MarkerTrait { }\n+impl MyCopy for i32 { }\n+\n+pub struct MyStruct<T>(T);\n+\n+#[fundamental]\n+pub struct MyFundamentalStruct<T>(T);"}, {"sha": "530bbf57d9104f8acec3e13aaa92bd277968b9e5", "filename": "src/test/compile-fail/coherence-cow-1.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -10,16 +10,19 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's ok for T to appear first in the self-type, as long\n-// as it's covered somewhere.\n-\n // pretty-expanded FIXME #23616\n \n+// Test that the `Pair` type reports an error if it contains type\n+// parameters, even when they are covered by local types. This test\n+// was originally intended to test the opposite, but the rules changed\n+// with RFC 1023 and this became illegal.\n+\n extern crate coherence_lib as lib;\n use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n impl<T> Remote for Pair<T,Cover<T>> { }\n+//~^ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-cow-1.rs"}, {"sha": "52abceab98b69c9873e29dc4201e37ae1c98c524", "filename": "src/test/compile-fail/coherence-cow-2.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -10,8 +10,10 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's ok for T to appear second in the self-type, as long\n-// as it's covered somewhere.\n+// Test that the `Pair` type reports an error if it contains type\n+// parameters, even when they are covered by local types. This test\n+// was originally intended to test the opposite, but the rules changed\n+// with RFC 1023 and this became illegal.\n \n // pretty-expanded FIXME #23616\n \n@@ -20,6 +22,6 @@ use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n-impl<T> Remote for Pair<Cover<T>,T> { }\n+impl<T> Remote for Pair<Cover<T>,T> { } //~ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-cow-2.rs"}, {"sha": "cd32e797ae9bf0a8d237c6b067fc5a82ffd1ce2b", "filename": "src/test/compile-fail/coherence-cow-no-cover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -10,14 +10,14 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's not ok for U to appear uncovered\n+// Test that it's not ok for T to appear uncovered\n \n extern crate coherence_lib as lib;\n use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n impl<T,U> Remote for Pair<Cover<T>,U> { }\n-//~^ ERROR type parameter `U` must be used as the type parameter for some local type\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "b99b2e1205b9bfd26c3f93f1fc5af331a8a1dafc", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -23,17 +23,24 @@ impl !Sync for NotSync {}\n \n impl Copy for TestE {}\n impl Copy for MyType {}\n+\n+impl Copy for &'static mut MyType {}\n+//~^ ERROR E0206\n+\n impl Copy for (MyType, MyType) {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n impl Copy for &'static NotSync {}\n //~^ ERROR E0206\n \n impl Copy for [MyType] {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n fn main() {\n }"}, {"sha": "f130a9353516f527462a79183cb49b4436ad7257", "filename": "src/test/compile-fail/coherence-impls-send.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -24,17 +24,17 @@ impl !Sync for NotSync {}\n unsafe impl Send for TestE {}\n unsafe impl Send for MyType {}\n unsafe impl Send for (MyType, MyType) {}\n-//~^ ERROR E0321\n+//~^ ERROR E0117\n \n unsafe impl Send for &'static NotSync {}\n //~^ ERROR E0321\n \n unsafe impl Send for [MyType] {}\n-//~^ ERROR E0321\n+//~^ ERROR E0117\n \n unsafe impl Send for &'static [NotSync] {}\n-//~^ ERROR E0321\n-//~| ERROR conflicting implementations\n+//~^ ERROR E0117\n+//~| ERROR E0119\n \n fn main() {\n }"}, {"sha": "2ac4bb0492b1f6f4df24a1454829c785aaf66e0f", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -22,12 +22,17 @@ struct NotSync;\n impl !Sync for NotSync {}\n \n impl Sized for TestE {} //~ ERROR E0322\n+\n impl Sized for MyType {} //~ ERROR E0322\n-impl Sized for (MyType, MyType) {} //~ ERROR E0322\n+\n+impl Sized for (MyType, MyType) {} //~ ERROR E0117\n+\n impl Sized for &'static NotSync {} //~ ERROR E0322\n-impl Sized for [MyType] {} //~ ERROR E0322\n+\n+impl Sized for [MyType] {} //~ ERROR E0117\n //~^ ERROR E0277\n-impl Sized for &'static [NotSync] {} //~ ERROR E0322\n+\n+impl Sized for &'static [NotSync] {} //~ ERROR E0117\n \n fn main() {\n }"}, {"sha": "d7f060a3bfe73dfb87be02c0858c64ef255a8e51", "filename": "src/test/compile-fail/coherence-overlap-issue-23516.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `Box<U>: !Sugar` to be ambiguous, even\n+// though we see no impl of `Sugar` for `Box`. Therefore, an overlap\n+// error is reported for the following pair of impls (#23516).\n+\n+pub trait Sugar { fn dummy(&self) { } }\n+pub trait Sweet { fn dummy(&self) { } }\n+impl<T:Sugar> Sweet for T { } //~ ERROR E0119\n+impl<U:Sugar> Sweet for Box<U> { }\n+fn main() { }"}, {"sha": "5f0b56af2c22637b279877731b7d404b24b906e9", "filename": "src/test/compile-fail/coherence-vec-local-2.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a local, generic type appearing within a\n+// *non-fundamental* remote type like `Vec` is not considered local.\n+\n // aux-build:coherence_lib.rs\n \n // pretty-expanded FIXME #23616\n@@ -17,6 +20,6 @@ use lib::Remote;\n \n struct Local<T>(T);\n \n-impl<T> Remote for Vec<Local<T>> { }\n+impl<T> Remote for Vec<Local<T>> { } //~ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-local-2.rs"}, {"sha": "c354caac2b5c261714f3f62c5d381b6d2c060d8c", "filename": "src/test/compile-fail/coherence-vec-local.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a local type (with no type parameters) appearing within a\n+// *non-fundamental* remote type like `Vec` is not considered local.\n+\n // aux-build:coherence_lib.rs\n \n // pretty-expanded FIXME #23616\n@@ -17,6 +20,6 @@ use lib::Remote;\n \n struct Local;\n \n-impl Remote for Vec<Local> { }\n+impl Remote for Vec<Local> { } //~ ERROR E0117\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-local-1.rs"}, {"sha": "f13175ce8e2a4e1ce3fbfb66f00b6d202b75b5f5", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+\n+// `MyFundamentalStruct` is declared fundamental, so we can test that\n+//\n+//    MyFundamentalStruct<MyTrait>: !MyTrait\n+//\n+// Huzzah.\n+impl MyTrait for lib::MyFundamentalStruct<MyType> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "ae3d242af705ea9b7b5a1a9ba3fa8cbb7c891c79", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_ref.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+\n+// `MyFundamentalStruct` is declared fundamental, so we can test that\n+//\n+//    MyFundamentalStruct<&MyTrait>: !MyTrait\n+//\n+// Huzzah.\n+impl<'a> MyTrait for lib::MyFundamentalStruct<&'a MyType> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c4e95e772356a8f471b59632b41914ccf459ed98", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// Tuples are not fundamental.\n+impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "f768a475ee820701332512b21ed921a36fd433e0", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// `MyStruct` is not declared fundamental, therefore this would\n+// require that\n+//\n+//     MyStruct<MyType>: !MyTrait\n+//\n+// which we cannot approve.\n+impl MyTrait for lib::MyStruct<MyType> { }\n+\n+fn main() { }"}, {"sha": "0c78fffd2dfab2ca1a7094eb6fcf21508143f2ef", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// Tuples are not fundamental, therefore this would require that\n+//\n+//     (MyType,): !MyTrait\n+//\n+// which we cannot approve.\n+impl MyTrait for (MyType,) { }\n+\n+fn main() { }"}, {"sha": "551577b6b4e08c8c820e827f0884b0c4925c16d4", "filename": "src/test/compile-fail/coherence_local.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+impl lib::MyCopy for MyType { }\n+impl<'a> lib::MyCopy for &'a MyType { }\n+impl<'a> lib::MyCopy for &'a Box<MyType> { }\n+impl lib::MyCopy for Box<MyType> { }\n+impl lib::MyCopy for lib::MyFundamentalStruct<MyType> { }\n+impl lib::MyCopy for lib::MyFundamentalStruct<Box<MyType>> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "01f4c1cd8a5c9f311786dfd95be76214e572da04", "filename": "src/test/compile-fail/coherence_local_err_struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+// MyStruct is not fundamental.\n+impl lib::MyCopy for lib::MyStruct<MyType> { } //~ ERROR E0117\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "590f68cee59ef3fb9898f5e1a6822559344cf39e", "filename": "src/test/compile-fail/coherence_local_err_tuple.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+// Tuples are not fundamental, so this is not a local impl.\n+impl lib::MyCopy for (MyType,) { } //~ ERROR E0117\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "f6e1aab59766a1e7d0b1884516cf37c7cb21f889", "filename": "src/test/compile-fail/coherence_local_ref.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// naturally, legal\n+impl lib::MyCopy for MyType { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "b1febae76803608b861d36212c623c964e92400e", "filename": "src/test/compile-fail/typeck-default-trait-impl-cross-crate-coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -20,15 +20,15 @@ extern crate typeck_default_trait_impl_cross_crate_coherence_lib as lib;\n use lib::DefaultedTrait;\n \n struct A;\n-impl DefaultedTrait for (A,) { } //~ ERROR E0321\n+impl DefaultedTrait for (A,) { } //~ ERROR E0117\n \n struct B;\n-impl !DefaultedTrait for (B,) { } //~ ERROR E0321\n+impl !DefaultedTrait for (B,) { } //~ ERROR E0117\n \n struct C;\n struct D<T>(T);\n impl DefaultedTrait for Box<C> { } //~ ERROR E0321\n-impl DefaultedTrait for lib::Something<C> { } //~ ERROR E0321\n+impl DefaultedTrait for lib::Something<C> { } //~ ERROR E0117\n impl DefaultedTrait for D<C> { } // OK\n \n fn main() { }"}, {"sha": "db9893613ad111816a167af5bb6b6c98949cc004", "filename": "src/test/run-pass/coherence_copy_like.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+impl MyTrait for MyType { }\n+impl<'a> MyTrait for &'a MyType { }\n+impl MyTrait for Box<MyType> { }\n+impl<'a> MyTrait for &'a Box<MyType> { }\n+\n+fn main() { }"}, {"sha": "2ceff22adb9eb4da6e5d204d9b00c8c6711056e1", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we pick which version of `Foo` to run based on whether\n-// the type we (ultimately) inferred for `x` is copyable or not.\n-//\n-// In this case, the two versions are both impls of same trait, and\n-// hence we we can resolve method even without knowing yet which\n-// version will run (note that the `push` occurs after the call to\n-// `foo()`).\n+// Test that when we write `x.foo()`, we do nothave to know the\n+// complete type of `x` in order to type-check the method call. In\n+// this case, we know that `x: Vec<_1>`, but we don't know what type\n+// `_1` is (because the call to `push` comes later). To pick between\n+// the impls, we would have to know `_1`, since we have to know\n+// whether `_1: MyCopy` or `_1 == Box<i32>`.  However (and this is the\n+// point of the test), we don't have to pick between the two impls --\n+// it is enough to know that `foo` comes from the `Foo` trait. We can\n+// translate the call as `Foo::foo(&x)` and let the specific impl get\n+// chosen later.\n \n // pretty-expanded FIXME #23616\n \n@@ -25,25 +28,29 @@ trait Foo {\n     fn foo(&self) -> isize;\n }\n \n-impl<T:Copy> Foo for Vec<T> {\n+trait MyCopy { fn foo(&self) { } }\n+impl MyCopy for i32 { }\n+\n+impl<T:MyCopy> Foo for Vec<T> {\n     fn foo(&self) -> isize {1}\n }\n \n-impl<T> Foo for Vec<Box<T>> {\n+impl Foo for Vec<Box<i32>> {\n     fn foo(&self) -> isize {2}\n }\n \n fn call_foo_copy() -> isize {\n     let mut x = Vec::new();\n     let y = x.foo();\n-    x.push(0_usize);\n+    x.push(0_i32);\n     y\n }\n \n fn call_foo_other() -> isize {\n-    let mut x: Vec<Box<_>> = Vec::new();\n+    let mut x: Vec<_> = Vec::new();\n     let y = x.foo();\n-    x.push(box 0);\n+    let z: Box<i32> = box 0;\n+    x.push(z);\n     y\n }\n "}, {"sha": "0190b7b7b9628370a408733e302da67757825e24", "filename": "src/test/run-pass/traits-conditional-dispatch.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs?ref=9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "patch": "@@ -17,16 +17,24 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n+use std::marker::MarkerTrait;\n+\n trait Get {\n     fn get(&self) -> Self;\n }\n \n-impl<T:Copy> Get for T {\n-    fn get(&self) -> T { *self }\n+trait MyCopy : MarkerTrait { fn copy(&self) -> Self; }\n+impl MyCopy for u16 { fn copy(&self) -> Self { *self } }\n+impl MyCopy for u32 { fn copy(&self) -> Self { *self } }\n+impl MyCopy for i32 { fn copy(&self) -> Self { *self } }\n+impl<T:Copy> MyCopy for Option<T> { fn copy(&self) -> Self { *self } }\n+\n+impl<T:MyCopy> Get for T {\n+    fn get(&self) -> T { self.copy() }\n }\n \n-impl<T:Get> Get for Box<T> {\n-    fn get(&self) -> Box<T> { box get_it(&**self) }\n+impl Get for Box<i32> {\n+    fn get(&self) -> Box<i32> { box get_it(&**self) }\n }\n \n fn get_it<T:Get>(t: &T) -> T {"}]}