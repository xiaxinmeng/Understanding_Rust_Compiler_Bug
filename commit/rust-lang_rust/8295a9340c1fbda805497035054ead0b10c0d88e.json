{"sha": "8295a9340c1fbda805497035054ead0b10c0d88e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOTVhOTM0MGMxZmJkYTgwNTQ5NzAzNTA1NGVhZDBiMTBjMGQ4OGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-08T10:11:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T10:11:19Z"}, "message": "Merge #4329\n\n4329: Look for `cargo`, `rustc`, and `rustup` in standard installation path r=matklad a=cdisselkoen\n\nDiscussed in #3118.  This is approximately a 90% fix for the issue described there.\r\n\r\nThis PR creates a new crate `ra_env` with a function `get_path_for_executable()`; see docs there.  `get_path_for_executable()` improves and generalizes the function `cargo_binary()` which was previously duplicated in the `ra_project_model` and `ra_flycheck` crates.  (Both of those crates now depend on the new `ra_env` crate.)  The new function checks (e.g.) `$CARGO` and `$PATH`, but also falls back on `~/.cargo/bin` manually before erroring out.  This should allow most users to not have to worry about setting the `$CARGO` or `$PATH` variables for VSCode, which can be difficult e.g. on macOS as discussed in #3118.\r\n\r\nI've attempted to replace all calls to `cargo`, `rustc`, and `rustup` in rust-analyzer with appropriate invocations of `get_path_for_executable()`; I don't think I've missed any in Rust code, but there is at least one invocation in TypeScript code which I haven't fixed.  (I'm not sure whether it's affected by the same problem or not.) https://github.com/rust-analyzer/rust-analyzer/blob/a4778ddb7a00f552a8e653bbf56ae9fd69cfe1d3/editors/code/src/cargo.ts#L79\r\n\r\nI'm sure this PR could be improved a bunch, so I'm happy to take feedback/suggestions on how to solve this problem better, or just bikeshedding variable/function/crate names etc.\r\n\r\ncc @Veetaha \r\n\r\nFixes #3118.\n\nCo-authored-by: Craig Disselkoen <craigdissel@gmail.com>\nCo-authored-by: veetaha <veetaha2@gmail.com>", "tree": {"sha": "ccab3f149b9633ae95570d78fa5d6b8d3b3392e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccab3f149b9633ae95570d78fa5d6b8d3b3392e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8295a9340c1fbda805497035054ead0b10c0d88e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetTBHCRBK7hj4Ov3rIwAAdHIIACXPzxZh3MyQcPFzBIoZEoFP\nglzkY74tcCpPu+SNguLnkNPq3MwfjwjKJJ73SU/QwRuPPmP52LKwUhdStXuk/ZYu\nktR9LEn2hZv6T1+ioI4y490k+FNPf7Us6Nq95S7UhpL3eU3h38aZ0iWAIw1796/V\n3bwNgyGjd3tz5SDGvu9uhuFIhT6top8M6vdOwWlmSOGMhwoi+5WBMrXbKEid/gz/\nigdVgoCaajaZC5zIFDHkw295TwibGB+ZG/ewT5N/blsB1DP6ga6zTYDGW2NqQP4J\n+be4bTHEjLXzKTHq1Vt7U1lQ1YoV4tj6IHL5CI0QerzGCwREo0nJ8SeJgQdcGWo=\n=V8Eh\n-----END PGP SIGNATURE-----\n", "payload": "tree ccab3f149b9633ae95570d78fa5d6b8d3b3392e6\nparent 363c1f2f493d206f2cc10c348a02f3efadd8c77a\nparent 3077eae2a61f97c28c0d4e3456f6ab873126e5b8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588932679 +0000\ncommitter GitHub <noreply@github.com> 1588932679 +0000\n\nMerge #4329\n\n4329: Look for `cargo`, `rustc`, and `rustup` in standard installation path r=matklad a=cdisselkoen\n\nDiscussed in #3118.  This is approximately a 90% fix for the issue described there.\r\n\r\nThis PR creates a new crate `ra_env` with a function `get_path_for_executable()`; see docs there.  `get_path_for_executable()` improves and generalizes the function `cargo_binary()` which was previously duplicated in the `ra_project_model` and `ra_flycheck` crates.  (Both of those crates now depend on the new `ra_env` crate.)  The new function checks (e.g.) `$CARGO` and `$PATH`, but also falls back on `~/.cargo/bin` manually before erroring out.  This should allow most users to not have to worry about setting the `$CARGO` or `$PATH` variables for VSCode, which can be difficult e.g. on macOS as discussed in #3118.\r\n\r\nI've attempted to replace all calls to `cargo`, `rustc`, and `rustup` in rust-analyzer with appropriate invocations of `get_path_for_executable()`; I don't think I've missed any in Rust code, but there is at least one invocation in TypeScript code which I haven't fixed.  (I'm not sure whether it's affected by the same problem or not.) https://github.com/rust-analyzer/rust-analyzer/blob/a4778ddb7a00f552a8e653bbf56ae9fd69cfe1d3/editors/code/src/cargo.ts#L79\r\n\r\nI'm sure this PR could be improved a bunch, so I'm happy to take feedback/suggestions on how to solve this problem better, or just bikeshedding variable/function/crate names etc.\r\n\r\ncc @Veetaha \r\n\r\nFixes #3118.\n\nCo-authored-by: Craig Disselkoen <craigdissel@gmail.com>\nCo-authored-by: veetaha <veetaha2@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8295a9340c1fbda805497035054ead0b10c0d88e", "html_url": "https://github.com/rust-lang/rust/commit/8295a9340c1fbda805497035054ead0b10c0d88e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8295a9340c1fbda805497035054ead0b10c0d88e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "363c1f2f493d206f2cc10c348a02f3efadd8c77a", "url": "https://api.github.com/repos/rust-lang/rust/commits/363c1f2f493d206f2cc10c348a02f3efadd8c77a", "html_url": "https://github.com/rust-lang/rust/commit/363c1f2f493d206f2cc10c348a02f3efadd8c77a"}, {"sha": "3077eae2a61f97c28c0d4e3456f6ab873126e5b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3077eae2a61f97c28c0d4e3456f6ab873126e5b8", "html_url": "https://github.com/rust-lang/rust/commit/3077eae2a61f97c28c0d4e3456f6ab873126e5b8"}], "stats": {"total": 246, "additions": 183, "deletions": 63}, "files": [{"sha": "36cff6402f5395578b2f5f87f1b3e19a5e814954", "filename": "Cargo.lock", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -464,6 +464,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"home\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -948,6 +957,14 @@ dependencies = [\n  \"test_utils\",\n ]\n \n+[[package]]\n+name = \"ra_env\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"home\",\n+]\n+\n [[package]]\n name = \"ra_flycheck\"\n version = \"0.1.0\"\n@@ -958,6 +975,7 @@ dependencies = [\n  \"jod-thread\",\n  \"log\",\n  \"lsp-types\",\n+ \"ra_env\",\n  \"serde_json\",\n ]\n \n@@ -1162,6 +1180,7 @@ dependencies = [\n  \"ra_arena\",\n  \"ra_cfg\",\n  \"ra_db\",\n+ \"ra_env\",\n  \"ra_proc_macro\",\n  \"rustc-hash\",\n  \"serde\","}, {"sha": "f0a401be536191dd0a641c8de816b0f037196c43", "filename": "crates/ra_env/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_env%2FCargo.toml?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_env\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+\n+[dependencies]\n+anyhow = \"1.0.26\"\n+home = \"0.5.3\""}, {"sha": "413da19827e67a1944a00b6b86346362148c619e", "filename": "crates/ra_env/src/lib.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_env%2Fsrc%2Flib.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -0,0 +1,66 @@\n+//! This crate contains a single public function\n+//! [`get_path_for_executable`](fn.get_path_for_executable.html).\n+//! See docs there for more information.\n+\n+use anyhow::{bail, Result};\n+use std::env;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+/// Return a `PathBuf` to use for the given executable.\n+///\n+/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n+/// gives a valid Cargo executable; or it may return a full path to a valid\n+/// Cargo.\n+pub fn get_path_for_executable(executable_name: impl AsRef<str>) -> Result<PathBuf> {\n+    // The current implementation checks three places for an executable to use:\n+    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n+    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n+    // 2) `<executable_name>`\n+    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` is on the $PATH\n+    // 3) `~/.cargo/bin/<executable_name>`\n+    //      example: for cargo, this tries ~/.cargo/bin/cargo\n+    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n+    let executable_name = executable_name.as_ref();\n+    let env_var = executable_name.to_ascii_uppercase();\n+    if let Ok(path) = env::var(&env_var) {\n+        if is_valid_executable(&path) {\n+            Ok(path.into())\n+        } else {\n+            bail!(\n+                \"`{}` environment variable points to something that's not a valid executable\",\n+                env_var\n+            )\n+        }\n+    } else {\n+        if is_valid_executable(executable_name) {\n+            return Ok(executable_name.into());\n+        }\n+        if let Some(mut path) = ::home::home_dir() {\n+            path.push(\".cargo\");\n+            path.push(\"bin\");\n+            path.push(executable_name);\n+            if is_valid_executable(&path) {\n+                return Ok(path);\n+            }\n+        }\n+        // This error message may also be caused by $PATH or $CARGO/$RUSTC/etc not being set correctly\n+        // for VSCode, even if they are set correctly in a terminal.\n+        // On macOS in particular, launching VSCode from terminal with `code <dirname>` causes VSCode\n+        // to inherit environment variables including $PATH, $CARGO, $RUSTC, etc from that terminal;\n+        // but launching VSCode from Dock does not inherit environment variables from a terminal.\n+        // For more discussion, see #3118.\n+        bail!(\n+            \"Failed to find `{}` executable. Make sure `{}` is in `$PATH`, or set `${}` to point to a valid executable.\",\n+            executable_name, executable_name, env_var\n+        )\n+    }\n+}\n+\n+/// Does the given `Path` point to a usable executable?\n+///\n+/// (assumes the executable takes a `--version` switch and writes to stdout,\n+/// which is true for `cargo`, `rustc`, and `rustup`)\n+fn is_valid_executable(p: impl AsRef<Path>) -> bool {\n+    Command::new(p.as_ref()).arg(\"--version\").output().is_ok()\n+}"}, {"sha": "d0f7fb2dcf2b74c743776236cca1372bc150f015", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -14,6 +14,7 @@ log = \"0.4.8\"\n cargo_metadata = \"0.9.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n+ra_env = { path = \"../ra_env\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "d8b727b0eadc4a02c80cfd54a67c2abc776a375a", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -4,7 +4,6 @@\n mod conv;\n \n use std::{\n-    env,\n     io::{self, BufRead, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n@@ -17,6 +16,7 @@ use lsp_types::{\n     CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n     WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n+use ra_env::get_path_for_executable;\n \n use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n@@ -216,7 +216,7 @@ impl FlycheckThread {\n \n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n-                let mut cmd = Command::new(cargo_binary());\n+                let mut cmd = Command::new(get_path_for_executable(\"cargo\").unwrap());\n                 cmd.arg(command);\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n                 cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n@@ -337,7 +337,3 @@ fn run_cargo(\n \n     Ok(())\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "62647846898cc0eae909356ce9ea49231bc85f24", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -14,8 +14,9 @@ rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.9.1\"\n \n ra_arena = { path = \"../ra_arena\" }\n-ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n+ra_db = { path = \"../ra_db\" }\n+ra_env = { path = \"../ra_env\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n \n serde = { version = \"1.0.106\", features = [\"derive\"] }"}, {"sha": "eb9f33ee89e39d81183c01fb840d331e57a91263", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -1,7 +1,6 @@\n //! FIXME: write short doc here\n \n use std::{\n-    env,\n     ffi::OsStr,\n     ops,\n     path::{Path, PathBuf},\n@@ -12,6 +11,7 @@ use anyhow::{Context, Result};\n use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n+use ra_env::get_path_for_executable;\n use rustc_hash::FxHashMap;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n@@ -146,12 +146,8 @@ impl CargoWorkspace {\n         cargo_toml: &Path,\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n-        let _ = Command::new(cargo_binary())\n-            .arg(\"--version\")\n-            .output()\n-            .context(\"failed to run `cargo --version`, is `cargo` in PATH?\")?;\n-\n         let mut meta = MetadataCommand::new();\n+        meta.cargo_path(get_path_for_executable(\"cargo\")?);\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -293,7 +289,7 @@ pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(cargo_binary());\n+    let mut cmd = Command::new(get_path_for_executable(\"cargo\")?);\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");\n@@ -347,7 +343,3 @@ fn is_dylib(path: &Path) -> bool {\n         Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n     }\n }\n-\n-fn cargo_binary() -> String {\n-    env::var(\"CARGO\").unwrap_or_else(|_| \"cargo\".to_string())\n-}"}, {"sha": "88a6ffb2a0dfcdfac27a04b746767a216929980a", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -14,6 +14,7 @@ use std::{\n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n+use ra_env::get_path_for_executable;\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n@@ -569,7 +570,7 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n \n     match (|| -> Result<String> {\n         // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n-        let mut cmd = Command::new(\"rustc\");\n+        let mut cmd = Command::new(get_path_for_executable(\"rustc\")?);\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n             cmd.args(&[\"--target\", target.as_str()]);"}, {"sha": "11c26ad89111464ee1e42eea2a4a1f496f9d413c", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -8,6 +8,7 @@ use std::{\n };\n \n use ra_arena::{Arena, Idx};\n+use ra_env::get_path_for_executable;\n \n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n@@ -88,9 +89,14 @@ fn create_command_text(program: &str, args: &[&str]) -> String {\n     format!(\"{} {}\", program, args.join(\" \"))\n }\n \n-fn run_command_in_cargo_dir(cargo_toml: &Path, program: &str, args: &[&str]) -> Result<Output> {\n+fn run_command_in_cargo_dir(\n+    cargo_toml: impl AsRef<Path>,\n+    program: impl AsRef<Path>,\n+    args: &[&str],\n+) -> Result<Output> {\n+    let program = program.as_ref().as_os_str().to_str().expect(\"Invalid Unicode in path\");\n     let output = Command::new(program)\n-        .current_dir(cargo_toml.parent().unwrap())\n+        .current_dir(cargo_toml.as_ref().parent().unwrap())\n         .args(args)\n         .output()\n         .context(format!(\"{} failed\", create_command_text(program, args)))?;\n@@ -114,13 +120,15 @@ fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, \"rustc\", &[\"--print\", \"sysroot\"])?;\n+    let rustc = get_path_for_executable(\"rustc\")?;\n+    let rustc_output = run_command_in_cargo_dir(cargo_toml, &rustc, &[\"--print\", \"sysroot\"])?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n-        run_command_in_cargo_dir(cargo_toml, \"rustup\", &[\"component\", \"add\", \"rust-src\"])?;\n+        let rustup = get_path_for_executable(\"rustup\")?;\n+        run_command_in_cargo_dir(cargo_toml, &rustup, &[\"component\", \"add\", \"rust-src\"])?;\n     }\n     if !src_path.exists() {\n         bail!("}, {"sha": "2a2c2e0e1bb8fc7ebc7824e7490221c43e188c08", "filename": "editors/code/src/cargo.ts", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fcargo.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fcargo.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcargo.ts?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -1,6 +1,9 @@\n import * as cp from 'child_process';\n+import * as os from 'os';\n+import * as path from 'path';\n import * as readline from 'readline';\n import { OutputChannel } from 'vscode';\n+import { isValidExecutable } from './util';\n \n interface CompilationArtifact {\n     fileName: string;\n@@ -10,17 +13,9 @@ interface CompilationArtifact {\n }\n \n export class Cargo {\n-    rootFolder: string;\n-    env?: Record<string, string>;\n-    output: OutputChannel;\n-\n-    public constructor(cargoTomlFolder: string, output: OutputChannel, env: Record<string, string> | undefined = undefined) {\n-        this.rootFolder = cargoTomlFolder;\n-        this.output = output;\n-        this.env = env;\n-    }\n+    constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n \n-    public async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n+    private async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n         const artifacts: CompilationArtifact[] = [];\n \n         try {\n@@ -37,27 +32,22 @@ export class Cargo {\n                                 isTest: message.profile.test\n                             });\n                         }\n-                    }\n-                    else if (message.reason === 'compiler-message') {\n+                    } else if (message.reason === 'compiler-message') {\n                         this.output.append(message.message.rendered);\n                     }\n                 },\n-                stderr => {\n-                    this.output.append(stderr);\n-                }\n+                stderr => this.output.append(stderr),\n             );\n-        }\n-        catch (err) {\n+        } catch (err) {\n             this.output.show(true);\n             throw new Error(`Cargo invocation has failed: ${err}`);\n         }\n \n         return artifacts;\n     }\n \n-    public async executableFromArgs(args: string[]): Promise<string> {\n-        const cargoArgs = [...args]; // to remain  args unchanged\n-        cargoArgs.push(\"--message-format=json\");\n+    async executableFromArgs(args: readonly string[]): Promise<string> {\n+        const cargoArgs = [...args, \"--message-format=json\"];\n \n         const artifacts = await this.artifactsFromArgs(cargoArgs);\n \n@@ -70,24 +60,27 @@ export class Cargo {\n         return artifacts[0].fileName;\n     }\n \n-    runCargo(\n+    private runCargo(\n         cargoArgs: string[],\n         onStdoutJson: (obj: any) => void,\n         onStderrString: (data: string) => void\n     ): Promise<number> {\n-        return new Promise<number>((resolve, reject) => {\n-            const cargo = cp.spawn('cargo', cargoArgs, {\n+        return new Promise((resolve, reject) => {\n+            let cargoPath;\n+            try {\n+                cargoPath = getCargoPathOrFail();\n+            } catch (err) {\n+                return reject(err);\n+            }\n+\n+            const cargo = cp.spawn(cargoPath, cargoArgs, {\n                 stdio: ['ignore', 'pipe', 'pipe'],\n-                cwd: this.rootFolder,\n-                env: this.env,\n+                cwd: this.rootFolder\n             });\n \n-            cargo.on('error', err => {\n-                reject(new Error(`could not launch cargo: ${err}`));\n-            });\n-            cargo.stderr.on('data', chunk => {\n-                onStderrString(chunk.toString());\n-            });\n+            cargo.on('error', err => reject(new Error(`could not launch cargo: ${err}`)));\n+\n+            cargo.stderr.on('data', chunk => onStderrString(chunk.toString()));\n \n             const rl = readline.createInterface({ input: cargo.stdout });\n             rl.on('line', line => {\n@@ -103,4 +96,28 @@ export class Cargo {\n             });\n         });\n     }\n-}\n\\ No newline at end of file\n+}\n+\n+// Mirrors `ra_env::get_path_for_executable` implementation\n+function getCargoPathOrFail(): string {\n+    const envVar = process.env.CARGO;\n+    const executableName = \"cargo\";\n+\n+    if (envVar) {\n+        if (isValidExecutable(envVar)) return envVar;\n+\n+        throw new Error(`\\`${envVar}\\` environment variable points to something that's not a valid executable`);\n+    }\n+\n+    if (isValidExecutable(executableName)) return executableName;\n+\n+    const standardLocation = path.join(os.homedir(), '.cargo', 'bin', executableName);\n+\n+    if (isValidExecutable(standardLocation)) return standardLocation;\n+\n+    throw new Error(\n+        `Failed to find \\`${executableName}\\` executable. ` +\n+        `Make sure \\`${executableName}\\` is in \\`$PATH\\`, ` +\n+        `or set \\`${envVar}\\` to point to a valid executable.`\n+    );\n+}"}, {"sha": "2ed150e25f25705e79666b979a5bb43adaa9b8a5", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -119,8 +119,11 @@ export function debugSingle(ctx: Ctx): Cmd {\n         }\n \n         if (!debugEngine) {\n-            vscode.window.showErrorMessage(`Install [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=${lldbId})`\n-                + ` or [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=${cpptoolsId}) extension for debugging.`);\n+            vscode.window.showErrorMessage(\n+                `Install [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=${lldbId}) ` +\n+                `or [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=${cpptoolsId}) ` +\n+                `extension for debugging.`\n+            );\n             return;\n         }\n "}, {"sha": "9b020d0019a3b49fb5fd18e51d51e8ef8b04fb71", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -8,10 +8,9 @@ import { activateInlayHints } from './inlay_hints';\n import { activateStatusDisplay } from './status_display';\n import { Ctx } from './ctx';\n import { Config, NIGHTLY_TAG } from './config';\n-import { log, assert } from './util';\n+import { log, assert, isValidExecutable } from './util';\n import { PersistentState } from './persistent_state';\n import { fetchRelease, download } from './net';\n-import { spawnSync } from 'child_process';\n import { activateTaskProvider } from './tasks';\n \n let ctx: Ctx | undefined;\n@@ -179,10 +178,7 @@ async function bootstrapServer(config: Config, state: PersistentState): Promise<\n \n     log.debug(\"Using server binary at\", path);\n \n-    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n-    log.debug(\"Checked binary availability via --version\", res);\n-    log.debug(res, \"--version output:\", res.output);\n-    if (res.status !== 0) {\n+    if (!isValidExecutable(path)) {\n         throw new Error(`Failed to execute ${path} --version`);\n     }\n "}, {"sha": "127a9e9112499ab357df4b483cb205cea40f83fe", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -1,6 +1,7 @@\n import * as lc from \"vscode-languageclient\";\n import * as vscode from \"vscode\";\n import { strict as nativeAssert } from \"assert\";\n+import { spawnSync } from \"child_process\";\n \n export function assert(condition: boolean, explanation: string): asserts condition {\n     try {\n@@ -82,3 +83,13 @@ export function isRustDocument(document: vscode.TextDocument): document is RustD\n export function isRustEditor(editor: vscode.TextEditor): editor is RustEditor {\n     return isRustDocument(editor.document);\n }\n+\n+export function isValidExecutable(path: string): boolean {\n+    log.debug(\"Checking availability of a binary at\", path);\n+\n+    const res = spawnSync(path, [\"--version\"], { encoding: 'utf8' });\n+\n+    log.debug(res, \"--version output:\", res.output);\n+\n+    return res.status === 0;\n+}"}]}