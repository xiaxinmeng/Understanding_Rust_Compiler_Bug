{"sha": "690495de035ccaf743b2715dd1e88b1266878026", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDQ5NWRlMDM1Y2NhZjc0M2IyNzE1ZGQxZTg4YjEyNjY4NzgwMjY=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-07-10T21:46:20Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-07-14T21:37:29Z"}, "message": "term: Add new function .attr() to toggle terminal attributes\n\nAlso add .supports_attr() to test for attribute support without writing\nanything to output.\n\nUpdate .reset() to use sgr0 instead of op.", "tree": {"sha": "588375527c061aecff6c3fb711de30f4f17f525b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/588375527c061aecff6c3fb711de30f4f17f525b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/690495de035ccaf743b2715dd1e88b1266878026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/690495de035ccaf743b2715dd1e88b1266878026", "html_url": "https://github.com/rust-lang/rust/commit/690495de035ccaf743b2715dd1e88b1266878026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/690495de035ccaf743b2715dd1e88b1266878026/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d8a0fdb7dafa5dfca003f5418119f0aaaac1484", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8a0fdb7dafa5dfca003f5418119f0aaaac1484", "html_url": "https://github.com/rust-lang/rust/commit/7d8a0fdb7dafa5dfca003f5418119f0aaaac1484"}], "stats": {"total": 113, "additions": 108, "deletions": 5}, "files": [{"sha": "1cfb4f4afa6277b6df7b3b64b4c570fe070b720a", "filename": "src/libextra/term.rs", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/690495de035ccaf743b2715dd1e88b1266878026/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/690495de035ccaf743b2715dd1e88b1266878026/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=690495de035ccaf743b2715dd1e88b1266878026", "patch": "@@ -45,6 +45,54 @@ pub mod color {\n     pub static BRIGHT_WHITE:   Color = 15u16;\n }\n \n+pub mod attr {\n+    /// Terminal attributes for use with term.attr().\n+    /// Most attributes can only be turned on and must be turned off with term.reset().\n+    /// The ones that can be turned off explicitly take a boolean value.\n+    /// Color is also represented as an attribute for convenience.\n+    pub enum Attr {\n+        /// Bold (or possibly bright) mode\n+        Bold,\n+        /// Dim mode, also called faint or half-bright. Often not supported\n+        Dim,\n+        /// Italics mode. Often not supported\n+        Italic(bool),\n+        /// Underline mode\n+        Underline(bool),\n+        /// Blink mode\n+        Blink,\n+        /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n+        Standout(bool),\n+        /// Reverse mode, inverts the foreground and background colors\n+        Reverse,\n+        /// Secure mode, also called invis mode. Hides the printed text\n+        Secure,\n+        /// Convenience attribute to set the foreground color\n+        ForegroundColor(super::color::Color),\n+        /// Convenience attribute to set the background color\n+        BackgroundColor(super::color::Color)\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+priv fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+    match attr {\n+        attr::Bold               => \"bold\",\n+        attr::Dim                => \"dim\",\n+        attr::Italic(true)       => \"sitm\",\n+        attr::Italic(false)      => \"ritm\",\n+        attr::Underline(true)    => \"smul\",\n+        attr::Underline(false)   => \"rmul\",\n+        attr::Blink              => \"blink\",\n+        attr::Standout(true)     => \"smso\",\n+        attr::Standout(false)    => \"rmso\",\n+        attr::Reverse            => \"rev\",\n+        attr::Secure             => \"invis\",\n+        attr::ForegroundColor(_) => \"setaf\",\n+        attr::BackgroundColor(_) => \"setab\"\n+    }\n+}\n+\n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n     num_colors: u16,\n@@ -124,17 +172,64 @@ impl Terminal {\n         }\n         false\n     }\n+\n+    /// Sets the given terminal attribute, if supported.\n+    /// Returns true if the attribute was supported, false otherwise.\n+    pub fn attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(c) => self.fg(c),\n+            attr::BackgroundColor(c) => self.bg(c),\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                let parm = self.ti.strings.find_equiv(&cap);\n+                if parm.is_some() {\n+                    let s = expand(*parm.unwrap(), [], &mut Variables::new());\n+                    if s.is_ok() {\n+                        self.out.write(s.unwrap());\n+                        return true\n+                    } else {\n+                        warn!(\"%s\", s.unwrap_err());\n+                    }\n+                }\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Returns whether the given terminal attribute is supported.\n+    pub fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n+                self.num_colors > 0\n+            }\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                self.ti.strings.find_equiv(&cap).is_some()\n+            }\n+        }\n+    }\n+\n+    /// Resets all terminal attributes and color to the default.\n     pub fn reset(&self) {\n-        let mut vars = Variables::new();\n-        let s = do self.ti.strings.find_equiv(&(\"op\"))\n-                       .map_consume_default(Err(~\"can't find terminfo capability `op`\")) |op| {\n-                           expand(copy *op, [], &mut vars)\n-                       };\n+        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n+        if cap.is_none() {\n+            // are there any terminals that have color/attrs and not sgr0?\n+            // Try falling back to sgr, then op\n+            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n+            if cap.is_none() {\n+                cap = self.ti.strings.find_equiv(&(\"op\"));\n+            }\n+        }\n+        let s = do cap.map_consume_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+            expand(*op, [], &mut Variables::new())\n+        };\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {\n             warn!(\"%s\", s.unwrap_err());\n         } else {\n+            // if we support attributes but not color, it would be nice to still warn!()\n+            // but it's not worth testing all known attributes just for this.\n             debug!(\"%s\", s.unwrap_err());\n         }\n     }\n@@ -160,6 +255,14 @@ impl Terminal {\n         false\n     }\n \n+    pub fn attr(&self, _attr: attr::Attr) -> bool {\n+        false\n+    }\n+\n+    pub fn supports_attr(&self, _attr: attr::Attr) -> bool {\n+        false\n+    }\n+\n     pub fn reset(&self) {\n     }\n }"}]}