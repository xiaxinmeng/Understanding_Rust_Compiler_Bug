{"sha": "5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZDRlYjZkZDZkOGM3MzMwNzdhNmFlZWE1ZDJjYzA4MTJkZWQwOTY=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-05-22T20:28:30Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-05-22T20:28:30Z"}, "message": "Add preliminary implementation of extract struct from enum variant", "tree": {"sha": "dffc23552eb6e77c50966fa155ed8a56b418c5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffc23552eb6e77c50966fa155ed8a56b418c5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "html_url": "https://github.com/rust-lang/rust/commit/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4daca9f02ec46be1beef79e9ed647a3a24e2434", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4daca9f02ec46be1beef79e9ed647a3a24e2434", "html_url": "https://github.com/rust-lang/rust/commit/d4daca9f02ec46be1beef79e9ed647a3a24e2434"}], "stats": {"total": 404, "additions": 403, "deletions": 1}, "files": [{"sha": "c604298ec1e36bdd46184f61984a9ed280918750", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "patch": "@@ -921,6 +921,7 @@ dependencies = [\n  \"ra_db\",\n  \"ra_fmt\",\n  \"ra_hir\",\n+ \"ra_hir_expand\",\n  \"ra_ide_db\",\n  \"ra_prof\",\n  \"ra_syntax\","}, {"sha": "f3481bdeb1a296c76229daf76d6ded91acef2f6c", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "patch": "@@ -20,5 +20,6 @@ ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n ra_db = { path = \"../ra_db\" }\n ra_ide_db = { path = \"../ra_ide_db\" }\n+hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "6291c68def184ee56523410d6d19ff991047c099", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "patch": "@@ -2,7 +2,7 @@\n \n use algo::find_covering_element;\n use hir::Semantics;\n-use ra_db::{FileId, FileRange};\n+use ra_db::{FileId, FileRange, FilePosition};\n use ra_fmt::{leading_indent, reindent};\n use ra_ide_db::{\n     source_change::{SourceChange, SourceFileEdit},\n@@ -19,6 +19,7 @@ use crate::{\n     assist_config::{AssistConfig, SnippetCap},\n     Assist, AssistId, GroupLabel, ResolvedAssist,\n };\n+use rustc_hash::FxHashMap;\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n@@ -138,6 +139,16 @@ impl Assists {\n         let label = Assist::new(id, label.into(), None, target);\n         self.add_impl(label, f)\n     }\n+    pub(crate) fn add_in_multiple_files(\n+        &mut self,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistDirector),\n+    ) -> Option<()> {\n+        let label = Assist::new(id, label.into(), None, target);\n+        self.add_impl_multiple_files(label, f)\n+    }\n     pub(crate) fn add_group(\n         &mut self,\n         group: &GroupLabel,\n@@ -162,6 +173,27 @@ impl Assists {\n         Some(())\n     }\n \n+    fn add_impl_multiple_files(&mut self, label: Assist, f: impl FnOnce(&mut AssistDirector)) -> Option<()> {\n+        let change_label = label.label.clone();\n+        if !self.resolve {\n+            return None\n+        }\n+        let mut director = AssistDirector::new(change_label.clone());\n+        f(&mut director);\n+        let changes = director.finish();\n+        let file_edits: Vec<SourceFileEdit> = changes.into_iter()\n+            .map(|mut change| change.source_file_edits.pop().unwrap()).collect();\n+\n+        let source_change = SourceChange {\n+            source_file_edits: file_edits,\n+            file_system_edits: vec![],\n+            is_snippet: false,\n+        };\n+\n+        self.buf.push((label, Some(source_change)));\n+        Some(())\n+    }\n+\n     fn finish(mut self) -> Vec<(Assist, Option<SourceChange>)> {\n         self.buf.sort_by_key(|(label, _edit)| label.target.len());\n         self.buf\n@@ -255,3 +287,31 @@ impl AssistBuilder {\n         res\n     }\n }\n+\n+pub(crate) struct AssistDirector {\n+    source_changes: Vec<SourceChange>,\n+    builders: FxHashMap<FileId, AssistBuilder>,\n+    change_label: String \n+} \n+\n+impl AssistDirector {\n+    fn new(change_label: String) -> AssistDirector {\n+        AssistDirector {\n+            source_changes: vec![],\n+            builders: FxHashMap::default(),\n+            change_label\n+        }\n+    }\n+\n+    pub(crate) fn perform(&mut self, file_id: FileId, f: impl FnOnce(&mut AssistBuilder)) {\n+        let mut builder = self.builders.entry(file_id).or_insert(AssistBuilder::new(file_id));\n+        f(&mut builder);\n+    }\n+\n+    fn finish(mut self) -> Vec<SourceChange> {\n+        for (file_id, builder) in self.builders.into_iter().collect::<Vec<(FileId, AssistBuilder)>>() {\n+            self.source_changes.push(builder.finish());    \n+        }\n+        self.source_changes\n+    }\n+}"}, {"sha": "6e19a6febba294b09d38788f77ec433ddc66e8f6", "filename": "crates/ra_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "patch": "@@ -0,0 +1,338 @@\n+use hir_expand::name::AsName;\n+use ra_ide_db::{\n+    defs::Definition, imports_locator::ImportsLocator, search::Reference, RootDatabase,\n+};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, AstNode, NameOwner},\n+    SourceFile, SyntaxNode, TextRange, TextSize,\n+};\n+use stdx::format_to;\n+\n+use crate::{\n+    assist_context::{AssistBuilder, AssistDirector},\n+    utils::insert_use_statement,\n+    AssistContext, AssistId, Assists,\n+};\n+use ast::{ArgListOwner, VisibilityOwner};\n+use hir::{EnumVariant, Module, ModuleDef};\n+use ra_fmt::leading_indent;\n+use rustc_hash::FxHashSet;\n+use ra_db::FileId;\n+\n+// Assist extract_struct_from_enum\n+//\n+// Extracts a from struct from enum variant\n+//\n+// ```\n+// enum A { <|>One(u32, u32) }\n+// ```\n+// ->\n+// ```\n+// struct One(pub u32, pub u32);\n+//\n+// enum A { One(One) }\"\n+// ```\n+pub(crate) fn extract_struct_from_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let field_list = match variant.kind() {\n+        ast::StructKind::Tuple(field_list) => field_list,\n+        _ => return None,\n+    };\n+    let variant_name = variant.name()?.to_string();\n+    let enum_ast = variant.parent_enum();\n+    let enum_name = enum_ast.name().unwrap().to_string();\n+    let visibility = enum_ast.visibility();\n+    let variant_hir = ctx.sema.to_def(&variant)?;\n+\n+    if existing_struct_def(ctx.db, &variant_name, &variant_hir) {\n+        return None;\n+    }\n+\n+    let target = variant.syntax().text_range();\n+    return acc.add_in_multiple_files(\n+        AssistId(\"extract_struct_from_enum_variant\"),\n+        \"Extract struct from enum variant\",\n+        target,\n+        |edit| {\n+            let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n+            let res = definition.find_usages(&ctx.db, None);\n+            let module_def = mod_def_for_target_module(ctx, &enum_name);\n+            let start_offset = variant.parent_enum().syntax().text_range().start();\n+            let mut seen_files_map: FxHashSet<Module> = FxHashSet::default();\n+            seen_files_map.insert(module_def.module(ctx.db).unwrap());\n+            for reference in res {\n+                let source_file = ctx.sema.parse(reference.file_range.file_id);\n+                update_reference(\n+                    ctx,\n+                    edit,\n+                    reference,\n+                    &source_file,\n+                    &module_def,\n+                    &mut seen_files_map,\n+                );\n+            }\n+            extract_struct_def(\n+                edit,\n+                enum_ast.syntax(),\n+                &variant_name,\n+                &field_list.to_string(),\n+                start_offset,\n+                ctx.frange.file_id,\n+                &visibility,\n+            );\n+            let list_range = field_list.syntax().text_range();\n+            update_variant(edit, &variant_name, ctx.frange.file_id, list_range);\n+        },\n+    );\n+}\n+\n+fn existing_struct_def(db: &RootDatabase, variant_name: &str, variant: &EnumVariant) -> bool {\n+    let module_defs = variant.parent_enum(db).module(db).scope(db, None);\n+    for (name, _) in module_defs {\n+        if name.to_string() == variant_name.to_string() {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn mod_def_for_target_module(ctx: &AssistContext, enum_name: &str) -> ModuleDef {\n+    ImportsLocator::new(ctx.db).find_imports(enum_name).first().unwrap().left().unwrap()\n+}\n+\n+fn insert_use_import(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    path: &ast::PathExpr,\n+    module: &Module,\n+    module_def: &ModuleDef,\n+    path_segment: ast::NameRef,\n+) -> Option<()> {\n+    let db = ctx.db;\n+    let mod_path = module.find_use_path(db, module_def.clone());\n+    if let Some(mut mod_path) = mod_path {\n+        mod_path.segments.pop();\n+        mod_path.segments.push(path_segment.as_name());\n+        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+    }\n+    Some(())\n+}\n+\n+fn extract_struct_def(\n+    edit: &mut AssistDirector,\n+    enum_ast: &SyntaxNode,\n+    variant_name: &str,\n+    variant_list: &str,\n+    start_offset: TextSize,\n+    file_id: FileId,\n+    visibility: &Option<ast::Visibility>,\n+) -> Option<()> {\n+    let visibility_string = if let Some(visibility) = visibility {\n+        format!(\"{} \", visibility.to_string())\n+    } else {\n+        \"\".to_string()\n+    };\n+    let mut buf = String::new();\n+    let indent = if let Some(indent) = leading_indent(enum_ast) {\n+        indent.to_string()\n+    } else {\n+        \"\".to_string()\n+    };\n+\n+    format_to!(\n+        buf,\n+        r#\"{}struct {}{};\n+\n+{}\"#,\n+        visibility_string,\n+        variant_name,\n+        list_with_visibility(variant_list),\n+        indent\n+    );\n+    edit.perform(file_id, |builder| {\n+        builder.insert(start_offset, buf);\n+    });\n+    Some(())\n+}\n+\n+fn update_variant(\n+    edit: &mut AssistDirector,\n+    variant_name: &str,\n+    file_id: FileId,\n+    list_range: TextRange,\n+) -> Option<()> {\n+    let inside_variant_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    edit.perform(file_id, |builder| {\n+        builder.set_file(file_id);\n+        builder.replace(inside_variant_range, variant_name);\n+    });\n+    Some(())\n+}\n+\n+fn update_reference(\n+    ctx: &AssistContext,\n+    edit: &mut AssistDirector,\n+    reference: Reference,\n+    source_file: &SourceFile,\n+    module_def: &ModuleDef,\n+    seen_files_map: &mut FxHashSet<Module>,\n+) -> Option<()> {\n+    let path_expr: ast::PathExpr = find_node_at_offset::<ast::PathExpr>(\n+        source_file.syntax(),\n+        reference.file_range.range.start(),\n+    )?;\n+    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+    let list = call.arg_list()?;\n+    let segment = path_expr.path()?.segment()?;\n+    let list_range = list.syntax().text_range();\n+    let inside_list_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    edit.perform(reference.file_range.file_id, |builder| {\n+        let module = ctx.sema.scope(&path_expr.syntax()).module().unwrap();\n+        if !seen_files_map.contains(&module) {\n+            if insert_use_import(\n+                ctx,\n+                builder,\n+                &path_expr,\n+                &module,\n+                module_def,\n+                segment.name_ref().unwrap(),\n+            )\n+            .is_some()\n+            {\n+                seen_files_map.insert(module);\n+            }\n+        }\n+        builder.replace(inside_list_range, format!(\"{}{}\", segment, list));\n+    });\n+    Some(())\n+}\n+\n+fn list_with_visibility(list: &str) -> String {\n+    list.split(',')\n+        .map(|part| {\n+            let index = if part.chars().next().unwrap() == '(' { 1usize } else { 0 };\n+            let mut mod_part = part.trim().to_string();\n+            mod_part.insert_str(index, \"pub \");\n+            mod_part\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\", \")\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use crate::{utils::FamousDefs, tests::{check_assist, check_assist_not_applicable}};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_extract_struct_several_fields() {\n+        check_assist(\n+            extract_struct_from_enum,\n+            \"enum A { <|>One(u32, u32) }\",\n+            r#\"struct One(pub u32, pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_one_field() {\n+        check_assist(\n+            extract_struct_from_enum,\n+            \"enum A { <|>One(u32) }\",\n+            r#\"struct One(pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_pub_visibility() {\n+        check_assist(\n+            extract_struct_from_enum,\n+            \"pub enum A { <|>One(u32, u32) }\",\n+            r#\"pub struct One(pub u32, pub u32);\n+\n+pub enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_with_complex_imports() {\n+        check_assist(\n+            extract_struct_from_enum,\n+            r#\"mod my_mod {\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(1, 1);\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(1, 1);\n+        }\n+\n+        pub enum MyEnum {\n+            <|>MyField(u8, u8),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(1, 1);\n+}\"#,\n+            r#\"use my_mod::my_other_mod::MyField;\n+\n+mod my_mod {\n+    use my_other_mod::MyField;\n+\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(MyField(1, 1));\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(MyField(1, 1));\n+        }\n+\n+        pub struct MyField(pub u8, pub u8);\n+\n+        pub enum MyEnum {\n+            MyField(MyField),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(MyField(1, 1));\n+}\"#,\n+        );\n+    }\n+\n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(extract_struct_from_enum, &fixture)\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_for_element_with_no_fields() {\n+        check_not_applicable(\"enum A { <|>One }\");\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_if_struct_exists() {\n+        check_not_applicable(\n+            r#\"struct One;\n+        enum A { <|>One(u8) }\"#,\n+        );\n+    }\n+}"}, {"sha": "9933f7a50546b60600401effba77c2fbc9f2a1ec", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=5cd4eb6dd6d8c733077a6aeea5d2cc0812ded096", "patch": "@@ -115,6 +115,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod extract_struct_from_enum_variant;\n     mod fill_match_arms;\n     mod fix_visibility;\n     mod flip_binexpr;\n@@ -154,6 +155,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            extract_struct_from_enum_variant::extract_struct_from_enum,\n             fill_match_arms::fill_match_arms,\n             fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,"}]}