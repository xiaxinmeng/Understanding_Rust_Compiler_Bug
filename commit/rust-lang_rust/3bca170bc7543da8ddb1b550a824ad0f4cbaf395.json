{"sha": "3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2ExNzBiYzc1NDNkYThkZGIxYjU1MGE4MjRhZDBmNGNiYWYzOTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-26T03:54:31Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-31T00:26:06Z"}, "message": "introduce, but do not use, `free_region_relation` computation\n\nThis duplicates, effectively, existing code in the universal regions\ncomputation.", "tree": {"sha": "6754df9a0b28f461263514e4f8f8e90488107bc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6754df9a0b28f461263514e4f8f8e90488107bc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "html_url": "https://github.com/rust-lang/rust/commit/3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54628c8ea844956f3f4f416b82067c634eb09f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/54628c8ea844956f3f4f416b82067c634eb09f7b", "html_url": "https://github.com/rust-lang/rust/commit/54628c8ea844956f3f4f416b82067c634eb09f7b"}], "stats": {"total": 247, "additions": 243, "deletions": 4}, "files": [{"sha": "c236fbc4f72133760559f89c4b2ddbcc90b7c4c6", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "patch": "@@ -104,6 +104,8 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         None\n     };\n \n+    let universal_regions = Rc::new(universal_regions);\n+\n     let elements = &Rc::new(RegionValueElements::new(mir));\n \n     // Run the MIR type-checker."}, {"sha": "9785a544a4dca02b7847dde3881e78b08977083a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "patch": "@@ -206,15 +206,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// of constraints produced by the MIR type check.\n     pub(crate) fn new(\n         var_infos: VarInfos,\n-        universal_regions: UniversalRegions<'tcx>,\n+        universal_regions: Rc<UniversalRegions<'tcx>>,\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n-        let universal_regions = Rc::new(universal_regions);\n-\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .into_iter()"}, {"sha": "3cf3ae1d166e813ca78a3b54673cdea277637123", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "patch": "@@ -0,0 +1,225 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::type_check::constraint_conversion;\n+use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n+use rustc::traits::query::type_op::{self, TypeOp};\n+use rustc::ty::{self, RegionVid, Ty};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use std::rc::Rc;\n+use syntax::ast;\n+\n+#[derive(Debug)]\n+crate struct UniversalRegionRelations<'tcx> {\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n+\n+    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n+    /// be true. These encode relationships like `T: 'a` that are\n+    /// added via implicit bounds.\n+    ///\n+    /// Each region here is guaranteed to be a key in the `indices`\n+    /// map.  We use the \"original\" regions (i.e., the keys from the\n+    /// map, and not the values) because the code in\n+    /// `process_registered_region_obligations` has some special-cased\n+    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+    /// our special inference variable there, we would mess that up.\n+    crate region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    /// Stores the outlives relations that are known to hold from the\n+    /// implied bounds, in-scope where clauses, and that sort of\n+    /// thing.\n+    outlives: TransitiveRelation<RegionVid>,\n+\n+    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n+    /// and we store that here. This is useful when figuring out how\n+    /// to express some local region in terms of external regions our\n+    /// caller will understand.\n+    inverse_outlives: TransitiveRelation<RegionVid>,\n+}\n+\n+impl UniversalRegionRelations<'tcx> {\n+    crate fn create(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        location_table: &LocationTable,\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        universal_regions: &Rc<UniversalRegions<'tcx>>,\n+        constraints: &mut MirTypeckRegionConstraints<'tcx>,\n+        all_facts: &mut Option<AllFacts>,\n+    ) -> Self {\n+        let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+        UniversalRegionRelationsBuilder {\n+            infcx,\n+            mir_def_id,\n+            mir_node_id,\n+            param_env,\n+            implicit_region_bound,\n+            constraints,\n+            location_table,\n+            all_facts,\n+            universal_regions: universal_regions.clone(),\n+            relations: UniversalRegionRelations {\n+                universal_regions: universal_regions.clone(),\n+                region_bound_pairs: Vec::new(),\n+                outlives: TransitiveRelation::new(),\n+                inverse_outlives: TransitiveRelation::new(),\n+            },\n+        }.create()\n+    }\n+\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`. Invoked by the\n+    /// builder below.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\n+            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n+            fr_a, fr_b\n+        );\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+}\n+\n+struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n+    infcx: &'this InferCtxt<'this, 'gcx, 'tcx>,\n+    mir_def_id: DefId,\n+    mir_node_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    location_table: &'this LocationTable,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n+    relations: UniversalRegionRelations<'tcx>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n+    all_facts: &'this mut Option<AllFacts>,\n+}\n+\n+impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n+    crate fn create(mut self) -> UniversalRegionRelations<'tcx> {\n+        let unnormalized_input_output_tys = self\n+            .universal_regions\n+            .unnormalized_input_tys\n+            .iter()\n+            .cloned()\n+            .chain(Some(self.universal_regions.unnormalized_output_ty));\n+\n+        // For each of the input/output types:\n+        // - Normalize the type. This will create some region\n+        //   constraints, which we buffer up because we are\n+        //   not ready to process them yet.\n+        // - Then compute the implied bounds. This will adjust\n+        //   the `relations.region_bound_pairs` and so forth.\n+        // - After this is done, we'll process the constraints, once\n+        //   the `relations` is built.\n+        let constraint_sets: Vec<_> = unnormalized_input_output_tys\n+            .flat_map(|ty| {\n+                debug!(\"build: input_or_output={:?}\", ty);\n+                let (ty, constraints) = self\n+                    .param_env\n+                    .and(type_op::normalize::Normalize::new(ty))\n+                    .fully_perform(self.infcx)\n+                    .unwrap_or_else(|_| bug!(\"failed to normalize {:?}\", ty));\n+                self.add_implied_bounds(ty);\n+                constraints\n+            })\n+            .collect();\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        let param_env = self.param_env;\n+        self.add_outlives_bounds(outlives_bounds::explicit_outlives_bounds(param_env));\n+\n+        // Finally:\n+        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n+        // - `'static: 'r` for every region `'r`\n+        // - `'r: 'fn_body` for every (other) universally quantified\n+        //   region `'r`, all of which are provided by our caller\n+        let fr_static = self.universal_regions.fr_static;\n+        let fr_fn_body = self.universal_regions.fr_fn_body;\n+        for fr in self.universal_regions.universal_regions() {\n+            debug!(\n+                \"build: relating free region {:?} to itself and to 'static\",\n+                fr\n+            );\n+            self.relations.relate_universal_regions(fr, fr);\n+            self.relations.relate_universal_regions(fr_static, fr);\n+            self.relations.relate_universal_regions(fr, fr_fn_body);\n+        }\n+\n+        for data in constraint_sets {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx.tcx,\n+                &self.universal_regions,\n+                &self.location_table,\n+                &self.relations.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n+                Locations::All,\n+                &mut self.constraints.outlives_constraints,\n+                &mut self.constraints.type_tests,\n+                &mut self.all_facts,\n+            ).convert_all(&data);\n+        }\n+\n+        self.relations\n+    }\n+\n+    /// Update the type of a single local, which should represent\n+    /// either the return type of the MIR or one of its arguments. At\n+    /// the same time, compute and add any implied bounds that come\n+    /// from this local.\n+    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) {\n+        debug!(\"add_implied_bounds(ty={:?})\", ty);\n+        let span = self.infcx.tcx.def_span(self.mir_def_id);\n+        let bounds = self\n+            .infcx\n+            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        self.add_outlives_bounds(bounds);\n+    }\n+\n+    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n+    /// the outlives relation as well as the region-bound pairs\n+    /// listing.\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n+    where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n+\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n+                    let r1 = self.universal_regions.to_region_vid(r1);\n+                    let r2 = self.universal_regions.to_region_vid(r2);\n+                    self.relations.relate_universal_regions(r2, r1);\n+                }\n+\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.relations\n+                        .region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.relations\n+                        .region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "be14819b64895a68632c5cc8a6d6f485da432cbe", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "patch": "@@ -71,6 +71,7 @@ macro_rules! span_mirbug_and_err {\n }\n \n mod constraint_conversion;\n+mod free_region_relations;\n mod input_output;\n mod liveness;\n mod relate_tys;\n@@ -110,7 +111,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n     mir_def_id: DefId,\n-    universal_regions: &UniversalRegions<'tcx>,\n+    universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n@@ -127,6 +128,17 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         type_tests: Vec::default(),\n     };\n \n+    let _urr = free_region_relations::UniversalRegionRelations::create(\n+        infcx,\n+        mir_def_id,\n+        param_env,\n+        location_table,\n+        Some(implicit_region_bound),\n+        universal_regions,\n+        &mut constraints,\n+        all_facts,\n+    );\n+\n     {\n         let mut borrowck_context = BorrowCheckContext {\n             universal_regions,"}, {"sha": "3f32d307409edb35c8ce34f672c80ea4700e26f1", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bca170bc7543da8ddb1b550a824ad0f4cbaf395/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=3bca170bc7543da8ddb1b550a824ad0f4cbaf395", "patch": "@@ -14,6 +14,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n */\n \n+#![feature(infer_outlives_requirements)]\n+#![feature(in_band_lifetimes)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(from_ref)]"}]}