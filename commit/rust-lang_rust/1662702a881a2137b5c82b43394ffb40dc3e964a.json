{"sha": "1662702a881a2137b5c82b43394ffb40dc3e964a", "node_id": "C_kwDOAAsO6NoAKDE2NjI3MDJhODgxYTIxMzdiNWM4MmI0MzM5NGZmYjQwZGMzZTk2NGE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-14T16:37:30Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-14T16:37:30Z"}, "message": "Work around new asm! usage in measureme\n\nThis is necessary to fix rustc bootstraps", "tree": {"sha": "84471b9194cba797d243195fcf3f4ae5b4987040", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84471b9194cba797d243195fcf3f4ae5b4987040"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1662702a881a2137b5c82b43394ffb40dc3e964a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1662702a881a2137b5c82b43394ffb40dc3e964a", "html_url": "https://github.com/rust-lang/rust/commit/1662702a881a2137b5c82b43394ffb40dc3e964a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1662702a881a2137b5c82b43394ffb40dc3e964a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/523f0db7dbfdc9d8d5644accaf536902cbf62a4a", "html_url": "https://github.com/rust-lang/rust/commit/523f0db7dbfdc9d8d5644accaf536902cbf62a4a"}], "stats": {"total": 156, "additions": 119, "deletions": 37}, "files": [{"sha": "9221abb822572061ccae9b0710c56371bbfc86bb", "filename": "src/inline_asm.rs", "status": "modified", "additions": 119, "deletions": 37, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/1662702a881a2137b5c82b43394ffb40dc3e964a/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1662702a881a2137b5c82b43394ffb40dc3e964a/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=1662702a881a2137b5c82b43394ffb40dc3e964a", "patch": "@@ -20,10 +20,14 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     // FIXME add .eh_frame unwind info directives\n \n     if !template.is_empty() {\n+        // Used by panic_abort\n         if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n             fx.bcx.ins().trap(TrapCode::User(1));\n             return;\n-        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        }\n+\n+        // Used by stdarch\n+        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -47,51 +51,46 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let ebx_place = match operands[0] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n+                InlineAsmOperand::Out {\n+                    reg:\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                            X86InlineAsmRegClass::reg\n-                        ))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                            X86InlineAsmRegClass::reg,\n+                        )),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let edx_place = match operands[3] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n \n@@ -104,14 +103,97 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             let destination_block = fx.get_block(destination.unwrap());\n             fx.bcx.ins().jump(destination_block, &[]);\n             return;\n-        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        }\n+\n+        // Used by compiler-builtins\n+        if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n             // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n             crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n             return;\n         } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n             crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n             return;\n         }\n+\n+        // Used by measureme\n+        if template[0] == InlineAsmTemplatePiece::String(\"xor %eax, %eax\".to_string())\n+            && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\"mov %rbx, \".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[7] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n+            && matches!(\n+                template[8],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[9] == InlineAsmTemplatePiece::String(\", %rbx\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"rdpmc\".to_string()) {\n+            // Return zero dummy values for all performance counters\n+            match operands[0] {\n+                InlineAsmOperand::In {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    value: _,\n+                } => {}\n+                _ => unreachable!(),\n+            };\n+            let lo = match operands[1] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+            let hi = match operands[2] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+\n+            let u32_layout = fx.layout_of(fx.tcx.types.u32);\n+            let zero = fx.bcx.ins().iconst(types::I32, 0);\n+            lo.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+            hi.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"lock xadd \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 1, modifier: None, span: _ }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\", (\".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: None, span: _ }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\")\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        }\n     }\n \n     let mut inputs = Vec::new();"}]}