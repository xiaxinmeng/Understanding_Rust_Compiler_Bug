{"sha": "09e591c12fcfef0533c113eca7dab59cd770e521", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZTU5MWMxMmZjZmVmMDUzM2MxMTNlY2E3ZGFiNTljZDc3MGU1MjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T19:46:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:06Z"}, "message": "rustc: Use interior vectors for tag type parameters", "tree": {"sha": "101c57d7aa00ac9ea9ecd286ba225c72821df6db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/101c57d7aa00ac9ea9ecd286ba225c72821df6db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09e591c12fcfef0533c113eca7dab59cd770e521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09e591c12fcfef0533c113eca7dab59cd770e521", "html_url": "https://github.com/rust-lang/rust/commit/09e591c12fcfef0533c113eca7dab59cd770e521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09e591c12fcfef0533c113eca7dab59cd770e521/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c4411ac5eb9b96fa8fac490103d95d39980cfd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c4411ac5eb9b96fa8fac490103d95d39980cfd8", "html_url": "https://github.com/rust-lang/rust/commit/9c4411ac5eb9b96fa8fac490103d95d39980cfd8"}], "stats": {"total": 311, "additions": 188, "deletions": 123}, "files": [{"sha": "052af38c151bcc7d27cdf0b7862620383691fcc5", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=09e591c12fcfef0533c113eca7dab59cd770e521", "patch": "@@ -169,8 +169,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('t') {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n-            let vec[ty::t] params = [];\n-            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n+            let ty::t[] params = ~[];\n+            while (peek(st) as char != ']') { params += ~[parse_ty(st, sd)]; }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tag(st.tcx, def, params);\n         }"}, {"sha": "2abba3e6c21f8a5c35381c86057cae07bc83e054", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 65, "deletions": 35, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=09e591c12fcfef0533c113eca7dab59cd770e521", "patch": "@@ -879,7 +879,11 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_res(_, ?sub, ?tps)) {\n-            auto sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t typ in tps) { tps_ivec += ~[typ]; }\n+\n+            auto sub1 = ty::substitute_type_params(cx.tcx, tps_ivec, sub);\n             ret T_struct([T_i32(), type_of_inner(cx, sp, sub1)]);\n         }\n         case (ty::ty_var(_)) {\n@@ -1240,7 +1244,12 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n                                                     ty::mk_nil(ccx.tcx))]);\n             }\n             case (ty::ty_res(_, ?sub, ?tps)) {\n-                auto sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n+                // FIXME: Remove this vec->ivec conversion.\n+                auto tps_ivec = ~[];\n+                for (ty::t typ in tps) { tps_ivec += ~[typ]; }\n+\n+                auto sub1 = ty::substitute_type_params(ccx.tcx, tps_ivec,\n+                                                       sub);\n                 ret ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx),\n                                               simplify_type(ccx, sub1)]);\n             }\n@@ -1259,36 +1268,35 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n                                  \"static_size_of_tag()\");\n     }\n     if (cx.tag_sizes.contains_key(t)) { ret cx.tag_sizes.get(t); }\n-    auto tid;\n-    let vec[ty::t] subtys;\n     alt (ty::struct(cx.tcx, t)) {\n-        case (ty::ty_tag(?tid_, ?subtys_)) { tid = tid_; subtys = subtys_; }\n+        case (ty::ty_tag(?tid, ?subtys)) {\n+            // Compute max(variant sizes).\n+\n+            auto max_size = 0u;\n+            auto variants = ty::tag_variants(cx.tcx, tid);\n+            for (ty::variant_info variant in variants) {\n+                // TODO: Remove this vec->ivec conversion.\n+                auto args = ~[];\n+                for (ty::t typ in variant.args) { args += ~[typ]; }\n+\n+                auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, args));\n+                // Perform any type parameter substitutions.\n+\n+                tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+                // Here we possibly do a recursive call.\n+\n+                auto this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n+                if (max_size < this_size) { max_size = this_size; }\n+            }\n+            cx.tag_sizes.insert(t, max_size);\n+            ret max_size;\n+        }\n         case (_) {\n             cx.tcx.sess.span_fatal(sp,\n                                  \"non-tag passed to \" +\n                                      \"static_size_of_tag()\");\n         }\n     }\n-    // Compute max(variant sizes).\n-\n-    auto max_size = 0u;\n-    auto variants = ty::tag_variants(cx.tcx, tid);\n-    for (ty::variant_info variant in variants) {\n-        // TODO: Remove this vec->ivec conversion.\n-        auto args = ~[];\n-        for (ty::t typ in variant.args) { args += ~[typ]; }\n-\n-        auto tup_ty = simplify_type(cx, ty::mk_imm_tup(cx.tcx, args));\n-        // Perform any type parameter substitutions.\n-\n-        tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n-        // Here we possibly do a recursive call.\n-\n-        auto this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n-        if (max_size < this_size) { max_size = this_size; }\n-    }\n-    cx.tag_sizes.insert(t, max_size);\n-    ret max_size;\n }\n \n fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n@@ -1516,7 +1524,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t, ValueRef base, &vec[int] ixs) ->\n // appropriate. @llblobptr is the data part of a tag value; its actual type is\n // meaningless, as it will be cast away.\n fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast::def_id tag_id,\n-           &ast::def_id variant_id, &vec[ty::t] ty_substs, int ix) -> result {\n+           &ast::def_id variant_id, &ty::t[] ty_substs, int ix) -> result {\n     auto variant =\n         ty::tag_variant_with_id(cx.fcx.lcx.ccx.tcx, tag_id, variant_id);\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n@@ -2138,8 +2146,12 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n \n fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n                   ty::t inner_t, &vec[ty::t] tps) -> result {\n+    // FIXME: Remove this vec->ivec conversion.\n+    auto tps_ivec = ~[];\n+    for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n     auto ccx = cx.fcx.lcx.ccx;\n-    auto inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n+    auto inner_t_s = ty::substitute_type_params(ccx.tcx, tps_ivec, inner_t);\n     auto tup_ty = ty::mk_imm_tup(ccx.tcx, ~[ty::mk_int(ccx.tcx), inner_t_s]);\n     auto drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2645,7 +2657,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n     }\n \n     fn iter_variant(@block_ctxt cx, ValueRef a_tup, ValueRef b_tup,\n-                    &ty::variant_info variant, &vec[ty::t] tps,\n+                    &ty::variant_info variant, &ty::t[] tps,\n                     &ast::def_id tid, &val_pair_and_ty_fn f) -> result {\n         if (vec::len[ty::t](variant.args) == 0u) {\n             ret rslt(cx, C_nil());\n@@ -2707,8 +2719,12 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             }\n         }\n         case (ty::ty_res(_, ?inner, ?tps)) {\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n             auto inner1 = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n-                                                     tps, inner);\n+                                                     tps_ivec, inner);\n             r = GEP_tup_like(r.bcx, t, av, [0, 1]);\n             auto llfld_a = r.val;\n             r = GEP_tup_like(r.bcx, t, bv, [0, 1]);\n@@ -4137,8 +4153,12 @@ fn autoderef_lval(&@block_ctxt cx, ValueRef v, &ty::t t, bool is_lval)\n                 } else { v1 = body; }\n             }\n             case (ty::ty_res(?did, ?inner, ?tps)) {\n+                // FIXME: Remove this vec->ivec conversion.\n+                auto tps_ivec = ~[];\n+                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n                 if (is_lval) { v1 = cx.build.Load(v1); }\n-                t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n+                t1 = ty::substitute_type_params(ccx.tcx, tps_ivec, inner);\n                 v1 = cx.build.GEP(v1, [C_int(0), C_int(1)]);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n@@ -4712,14 +4732,19 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                         matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n                 }\n             }\n+\n             auto ty_params = ty::node_id_to_type_params\n                 (cx.fcx.lcx.ccx.tcx, pat.id);\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in ty_params) { tps_ivec += ~[tp]; }\n+\n             if (vec::len(subpats) > 0u) {\n                 auto i = 0;\n                 for (@ast::pat subpat in subpats) {\n                     auto rslt =\n                         GEP_tag(matched_cx, llblobptr, vdef._0, vdef._1,\n-                                ty_params, i);\n+                                tps_ivec, i);\n                     auto llsubvalptr = rslt.val;\n                     matched_cx = rslt.bcx;\n                     auto llsubval =\n@@ -4773,14 +4798,19 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                     (llval, T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n                 llblobptr = cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n             }\n+\n             auto ty_param_substs =\n                 ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, pat.id);\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in ty_param_substs) { tps_ivec += ~[tp]; }\n+\n             auto this_cx = cx;\n             auto i = 0;\n             for (@ast::pat subpat in subpats) {\n                 auto rslt =\n-                    GEP_tag(this_cx, llblobptr, vdef._0, vdef._1,\n-                            ty_param_substs, i);\n+                    GEP_tag(this_cx, llblobptr, vdef._0, vdef._1, tps_ivec,\n+                            i);\n                 this_cx = rslt.bcx;\n                 auto subpat_res =\n                     trans_pat_binding(this_cx, subpat, rslt.val, true);\n@@ -8478,10 +8508,10 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n                               ty::ret_ty_of_fn(cx.ccx.tcx, variant.node.id),\n                               fn_args, ty_params);\n-    let vec[ty::t] ty_param_substs = [];\n+    let ty::t[] ty_param_substs = ~[];\n     i = 0u;\n     for (ast::ty_param tp in ty_params) {\n-        ty_param_substs += [ty::mk_param(cx.ccx.tcx, i)];\n+        ty_param_substs += ~[ty::mk_param(cx.ccx.tcx, i)];\n         i += 1u;\n     }\n     auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);"}, {"sha": "5ab7aafce98a6818a5a49b575aef1f04e71e2eed", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=09e591c12fcfef0533c113eca7dab59cd770e521", "patch": "@@ -257,7 +257,7 @@ tag sty {\n     ty_char;\n     ty_str;\n     ty_istr;\n-    ty_tag(def_id, vec[t]);\n+    ty_tag(def_id, t[]);\n     ty_box(mt);\n     ty_vec(mt);\n     ty_ivec(mt);\n@@ -557,7 +557,7 @@ fn mk_str(&ctxt cx) -> t { ret idx_str; }\n \n fn mk_istr(&ctxt cx) -> t { ret idx_istr; }\n \n-fn mk_tag(&ctxt cx, &ast::def_id did, &vec[t] tys) -> t {\n+fn mk_tag(&ctxt cx, &ast::def_id did, &t[] tys) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n@@ -753,9 +753,9 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_chan(cx, fold_ty(cx, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n-            let vec[t] new_subtys = [];\n+            let t[] new_subtys = ~[];\n             for (t subty in subtys) {\n-                new_subtys += [fold_ty(cx, fld, subty)];\n+                new_subtys += ~[fold_ty(cx, fld, subty)];\n             }\n             ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n@@ -1052,8 +1052,12 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n             }\n         }\n         case (ty_res(?did, ?inner, ?tps)) {\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n             result = type_has_pointers\n-                (cx, substitute_type_params(cx, tps, inner));\n+                (cx, substitute_type_params(cx, tps_ivec, inner));\n         }\n         case (_) { result = true; }\n     }\n@@ -1086,7 +1090,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         case (ty_istr) { ret false; }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < vec::len[t](subtys)) {\n+            while (i < ivec::len[t](subtys)) {\n                 if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -1240,8 +1244,12 @@ fn type_owns_heap_mem(&ctxt cx, &t ty) -> bool {\n             }\n         }\n         case (ty_res(_, ?inner, ?tps)) {\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n             result = type_owns_heap_mem\n-                (cx, substitute_type_params(cx, tps, inner));\n+                (cx, substitute_type_params(cx, tps_ivec, inner));\n         }\n \n         case (ty_ptr(_)) { result = false; }\n@@ -1272,7 +1280,11 @@ fn type_autoderef(&ctxt cx, &ty::t t) -> ty::t {\n         alt (struct(cx, t1)) {\n             case (ty::ty_box(?mt)) { t1 = mt.ty; }\n             case (ty::ty_res(_, ?inner, ?tps)) {\n-                t1 = substitute_type_params(cx, tps, inner);\n+                // FIXME: Remove this vec->ivec conversion.\n+                auto tps_ivec = ~[];\n+                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n+                t1 = substitute_type_params(cx, tps_ivec, inner);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = tag_variants(cx, did);\n@@ -1514,8 +1526,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n             alt (b) {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n-                    auto len = vec::len[t](tys_a);\n-                    if (len != vec::len[t](tys_b)) { ret false; }\n+                    auto len = ivec::len[t](tys_a);\n+                    if (len != ivec::len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1755,7 +1767,13 @@ fn ty_param_substs_opt_and_ty_to_monotype(&ctxt cx,\n    t {\n     alt (tpot._0) {\n         case (none) { ret tpot._1; }\n-        case (some(?tps)) { ret substitute_type_params(cx, tps, tpot._1); }\n+        case (some(?tps)) {\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n+            ret substitute_type_params(cx, tps_ivec, tpot._1);\n+        }\n     }\n }\n \n@@ -2328,18 +2346,16 @@ mod unify {\n                         // TODO: factor this cruft out, see the TODO in the\n                         // ty::ty_tup case\n \n-                        let vec[t] result_tps = [];\n+                        let t[] result_tps = ~[];\n                         auto i = 0u;\n-                        auto expected_len = vec::len[t](expected_tps);\n+                        auto expected_len = ivec::len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n                             auto result =\n                                 unify_step(cx, expected_tp, actual_tp);\n                             alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    vec::push[t](result_tps, rty);\n-                                }\n+                                case (ures_ok(?rty)) { result_tps += ~[rty]; }\n                                 case (_) { ret result; }\n                             }\n                             i += 1u;\n@@ -2769,14 +2785,13 @@ fn bind_params_in_type(&span sp, &ctxt cx, fn() -> int  next_ty_var, t typ,\n \n // Replaces type parameters in the given type using the given list of\n // substitions.\n-fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n+fn substitute_type_params(&ctxt cx, &ty::t[] substs, t typ) -> t {\n     if (!type_contains_params(cx, typ)) { ret typ; }\n-    fn substituter(ctxt cx, vec[ty::t] substs, uint idx) -> t {\n+    fn substituter(ctxt cx, @ty::t[] substs, uint idx) -> t {\n         // FIXME: bounds check can fail\n-\n         ret substs.(idx);\n     }\n-    ret fold_ty(cx, fm_param(bind substituter(cx, substs, _)), typ);\n+    ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _)), typ);\n }\n \n fn def_has_ty_params(&ast::def def) -> bool {"}, {"sha": "825bdf007d8e8925f0ea00dfda8721050ecc3862", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 82, "deletions": 63, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=09e591c12fcfef0533c113eca7dab59cd770e521", "patch": "@@ -265,11 +265,11 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n-        let vec[ty::t] param_bindings = [];\n+        let ty::t[] param_bindings = ~[];\n         for (@ast::ty ast_ty in args) {\n-            param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n+            param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n-        if (vec::len(param_bindings) !=\n+        if (ivec::len(param_bindings) !=\n                 ty::count_ty_params(tcx, params_opt_and_ty._1)) {\n             tcx.sess.span_fatal(sp,\n                               \"Wrong number of type arguments for a\" +\n@@ -647,8 +647,13 @@ mod collect {\n                 // Create a new generic polytype.\n \n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n+\n                 let vec[ty::t] subtys = mk_ty_params(cx, ty_param_count);\n-                auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n+                // FIXME: Remove this vec->ivec conversion.\n+                auto tps_ivec = ~[];\n+                for (ty::t tp in subtys) { tps_ivec += ~[tp]; }\n+\n+                auto t = ty::mk_tag(cx.tcx, local_def(it.id), tps_ivec);\n                 auto tpt = tup(ty_param_count, t);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n@@ -690,9 +695,13 @@ mod collect {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n \n+            // FIXME: Remove this vec->ivec conversion.\n+            auto tps_ivec = ~[];\n+            for (ty::t tp in ty_param_tys) { tps_ivec += ~[tp]; }\n+\n             auto result_ty;\n             if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n-                result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n+                result_ty = ty::mk_tag(cx.tcx, tag_id, tps_ivec);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -703,7 +712,7 @@ mod collect {\n                     auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n                     args += ~[rec(mode=ty::mo_alias(false), ty=arg_ty)];\n                 }\n-                auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n+                auto tag_t = ty::mk_tag(cx.tcx, tag_id, tps_ivec);\n                 // FIXME: this will be different for constrained types\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n                                       ast::return, []);\n@@ -859,7 +868,11 @@ fn do_autoderef(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n         alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { t1 = inner.ty; }\n             case (ty::ty_res(_, ?inner, ?tps)) {\n-                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n+                // FIXME: Remove this vec->ivec conversion.\n+                auto tps_ivec = ~[];\n+                for (ty::t tp in tps) { tps_ivec += ~[tp]; }\n+\n+                t1 = ty::substitute_type_params(fcx.ccx.tcx, tps_ivec, inner);\n             }\n             case (ty::ty_tag(?did, ?tps)) {\n                 auto variants = ty::tag_variants(fcx.ccx.tcx, did);\n@@ -989,7 +1002,7 @@ fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n \n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n-                     &vec[ty::t] tag_ty_params) -> vec[ty::t] {\n+                     &ty::t[] tag_ty_params) -> vec[ty::t] {\n     let vec[ty::t] result = [];\n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (ty::struct(ccx.tcx, tpt._1)) {\n@@ -1278,74 +1291,80 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n             auto path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n             // Take the tag type params out of `expected`.\n \n-            auto expected_tps;\n             alt (structure_of(fcx, pat.span, expected)) {\n-                case (ty::ty_tag(_, ?tps)) { expected_tps = tps; }\n-                case (_) {\n-                    // FIXME: Switch expected and actual in this message? I\n-                    // can never tell.\n+              case (ty::ty_tag(_, ?expected_tps)) {\n+                // Unify with the expected tag type.\n+\n+                auto ctor_ty =\n+                    ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n+                                                               path_tpot);\n+\n+                // FIXME: Remove this ivec->vec conversion.\n+                auto tps_vec = [];\n+                for (ty::t tp in expected_tps) { tps_vec += [tp]; }\n+\n+                auto path_tpt =\n+                    demand::full(fcx, pat.span, expected, ctor_ty, tps_vec,\n+                                 NO_AUTODEREF);\n+                path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n+                // Get the number of arguments in this tag variant.\n+\n+                auto arg_types =\n+                    variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n+                                      expected_tps);\n+                auto subpats_len = vec::len[@ast::pat](subpats);\n+                if (vec::len[ty::t](arg_types) > 0u) {\n+                    // N-ary variant.\n+\n+                    auto arg_len = vec::len[ty::t](arg_types);\n+                    if (arg_len != subpats_len) {\n+                        // TODO: note definition of tag variant\n+                        // TODO (issue #448): Wrap a #fmt string over multiple\n+                        // lines...\n+                        auto s = #fmt(\"this pattern has %u field%s, but the \\\n+                                       corresponding variant has %u field%s\",\n+                                      subpats_len,\n+                                      if (subpats_len == 1u) {\n+                                          \"\"\n+                                      } else { \"s\" }, arg_len,\n+                                      if (arg_len == 1u) {\n+                                          \"\"\n+                                      } else { \"s\" });\n+                        fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n+                    }\n+                    // TODO: vec::iter2\n \n-                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                              #fmt(\"mismatched types: \\\n-                                                    expected tag, found %s\",\n-                                                   ty_to_str(fcx.ccx.tcx,\n-                                                             expected)));\n-                }\n-            }\n-            // Unify with the expected tag type.\n-\n-            auto ctor_ty =\n-                ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n-                                                           path_tpot);\n-            auto path_tpt =\n-                demand::full(fcx, pat.span, expected, ctor_ty, expected_tps,\n-                             NO_AUTODEREF);\n-            path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n-            // Get the number of arguments in this tag variant.\n-\n-            auto arg_types =\n-                variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n-                                  expected_tps);\n-            auto subpats_len = vec::len[@ast::pat](subpats);\n-            if (vec::len[ty::t](arg_types) > 0u) {\n-                // N-ary variant.\n-\n-                auto arg_len = vec::len[ty::t](arg_types);\n-                if (arg_len != subpats_len) {\n+                    auto i = 0u;\n+                    for (@ast::pat subpat in subpats) {\n+                        check_pat(fcx, subpat, arg_types.(i));\n+                        i += 1u;\n+                    }\n+                } else if (subpats_len > 0u) {\n                     // TODO: note definition of tag variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n-                    auto s = #fmt(\"this pattern has %u field%s, but the \\\n-                                   corresponding variant has %u field%s\",\n-                                  subpats_len,\n-                                  if (subpats_len == 1u) {\n-                                      \"\"\n-                                  } else { \"s\" }, arg_len,\n-                                  if (arg_len == 1u) {\n-                                      \"\"\n-                                  } else { \"s\" });\n-                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n-                }\n-                // TODO: vec::iter2\n-\n-                auto i = 0u;\n-                for (@ast::pat subpat in subpats) {\n-                    check_pat(fcx, subpat, arg_types.(i));\n-                    i += 1u;\n-                }\n-            } else if (subpats_len > 0u) {\n-                // TODO: note definition of tag variant\n-                // TODO (issue #448): Wrap a #fmt string over multiple\n-                // lines...\n \n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                           #fmt(\"this pattern has %u field%s, \\\n                                                 but the corresponding \\\n                                                 variant has no fields\",\n                                                subpats_len,\n                                                if (subpats_len == 1u) {\n                                                    \"\"\n                                                } else { \"s\" }));\n+                }\n+                write::ty_fixup(fcx, pat.id, path_tpot);\n+              }\n+              case (_) {\n+                // FIXME: Switch expected and actual in this message? I\n+                // can never tell.\n+\n+                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                                            #fmt(\"mismatched types: \\\n+                                                  expected tag, found %s\",\n+                                                 ty_to_str(fcx.ccx.tcx,\n+                                                           expected)));\n+              }\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n         }"}, {"sha": "58ed9b6157c97720d573111c5f250c477d41e513", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e591c12fcfef0533c113eca7dab59cd770e521/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=09e591c12fcfef0533c113eca7dab59cd770e521", "patch": "@@ -1,4 +1,5 @@\n import std::io;\n+import std::ivec;\n import std::vec;\n import std::str;\n import std::int;\n@@ -118,9 +119,9 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             // The user should never see this if the cname is set properly!\n \n             s += \"<tag#\" + int::str(id._0) + \":\" + int::str(id._1) + \">\";\n-            if (vec::len[t](tps) > 0u) {\n-                auto f = bind ty_to_str(cx, _);\n-                auto strs = vec::map[t, str](f, tps);\n+            if (ivec::len[t](tps) > 0u) {\n+                let vec[str] strs = [];\n+                for (t typ in tps) { strs += [ty_to_str(cx, typ)]; }\n                 s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n         }"}]}