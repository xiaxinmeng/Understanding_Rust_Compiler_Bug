{"sha": "2c1b269960baf1a878e2aad3db2dcbdd4c743d8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMWIyNjk5NjBiYWYxYTg3OGUyYWFkM2RiMmRjYmRkNGM3NDNkOGI=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-17T21:51:40Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-17T22:17:46Z"}, "message": "Implemented enough of deep_copy that we can pass scalars and channels to tasks. Closes #507.", "tree": {"sha": "53daed0f1df7776fa82990a7191dbef0b6e5d488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53daed0f1df7776fa82990a7191dbef0b6e5d488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b", "html_url": "https://github.com/rust-lang/rust/commit/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b/comments", "author": null, "committer": null, "parents": [{"sha": "81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "html_url": "https://github.com/rust-lang/rust/commit/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59"}], "stats": {"total": 74, "additions": 39, "deletions": 35}, "files": [{"sha": "57880dd281560b9477d165daae3e074332990733", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1b269960baf1a878e2aad3db2dcbdd4c743d8b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2c1b269960baf1a878e2aad3db2dcbdd4c743d8b", "patch": "@@ -2429,7 +2429,8 @@ type val_pair_and_ty_fn =\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(&@block_ctxt cx, ValueRef v, &ty::t t, val_and_ty_fn f)\n    -> result {\n-    fn adaptor_fn(val_and_ty_fn f, &@block_ctxt cx, ValueRef av, ValueRef bv,                  ty::t t) -> result {\n+    fn adaptor_fn(val_and_ty_fn f, &@block_ctxt cx, ValueRef av, ValueRef bv,\n+                  ty::t t) -> result {\n         ret f(cx, av, t);\n     }\n     ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n@@ -6078,11 +6079,6 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     auto chan_raw_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n                        [bcx.fcx.lltaskptr, prt_val]);\n-    ret chan_raw_to_val(bcx, e, ann, chan_raw_val);\n-}\n-\n-fn chan_raw_to_val(&@block_ctxt bcx, &@ast::expr e,  &ast::ann ann,\n-                   ValueRef chan_raw_val) -> result {\n     auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n@@ -6142,7 +6138,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n         auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         auto arg = trans_expr(bcx, e);\n \n-        arg = deep_copy(arg.bcx, arg.val, e_ty);\n+        arg = deep_copy(arg.bcx, arg.val, e_ty, new_task);\n \n         bcx = arg.bcx;\n \n@@ -6239,43 +6235,51 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n // tasks, and for sending things through channels. There are probably some\n // uniqueness optimizations and things we can do here for tasks in the same\n // domain.\n-fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task) \n+    -> result \n+{\n+    // TODO: make sure all paths add any reference counting that they need to.\n+\n+    // TODO: Teach deep copy to understand everything else it needs to.\n+\n     auto tcx = bcx.fcx.lcx.ccx.tcx;\n     if(ty::type_is_scalar(tcx, t)) {\n         ret res(bcx, v);\n     }\n-    /*\n-      else if(ty::type_is_chan(tcx, t)) {\n-      // If this is a channel, we need to clone it.\n-      log_err \"Generating clone call for channel argument.\";\n-      \n-      log_err #fmt(\"ty(clone_chan) = %s\", \n-      val_str(bcx.fcx.lcx.ccx.tn,\n-      bcx.fcx.lcx.ccx.upcalls.clone_chan));\n-      \n-      log_err #fmt(\"ty(lltaskptr) = %s\", \n-      val_str(bcx.fcx.lcx.ccx.tn, \n-      bcx.fcx.lltaskptr));\n-      \n-      log_err #fmt(\"ty(new_task) = %s\", \n-      val_str(bcx.fcx.lcx.ccx.tn, \n-      new_task));\n+    else if(ty::type_is_chan(tcx, t)) {\n+        // If this is a channel, we need to clone it.\n+        /*\n+        log_err \"Generating clone call for channel argument.\";\n       \n-      log_err #fmt(\"ty(chan) = %s\", \n-      val_str(bcx.fcx.lcx.ccx.tn, \n-      arg.val));\n+        log_err #fmt(\"ty(clone_chan) = %s\", \n+                     val_str(bcx.fcx.lcx.ccx.tn,\n+                             bcx.fcx.lcx.ccx.upcalls.clone_chan));\n       \n-      auto chan_ptr = bcx.build.PointerCast(arg.val, T_opaque_chan_ptr());\n+        log_err #fmt(\"ty(lltaskptr) = %s\", \n+                     val_str(bcx.fcx.lcx.ccx.tn, \n+                             bcx.fcx.lltaskptr));\n       \n-      auto chan_raw_val = \n-      bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n-      [bcx.fcx.lltaskptr, new_task, chan_ptr]);\n+        log_err #fmt(\"ty(target_task) = %s\", \n+                     val_str(bcx.fcx.lcx.ccx.tn, \n+                             target_task));\n       \n-      arg = chan_raw_to_val(bcx, e, ann, chan_raw_val);\n+        log_err #fmt(\"ty(chan) = %s\", \n+                     val_str(bcx.fcx.lcx.ccx.tn, \n+                             v));\n+        */\n+\n+        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n       \n-      log_err \"Done\";\n-      } \n-    */\n+        auto chan_raw_val = \n+            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n+                           [bcx.fcx.lltaskptr, target_task, chan_ptr]);\n+\n+        // Cast back to the type the context was expecting.\n+        auto chan_val = bcx.build.PointerCast(chan_raw_val, \n+                                              val_ty(v));\n+\n+        ret res(bcx, chan_val);\n+    } \n     else if(ty::type_is_structural(tcx, t)) {\n         fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n             auto tcx = bcx.fcx.lcx.ccx.tcx;"}]}