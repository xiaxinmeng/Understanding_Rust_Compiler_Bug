{"sha": "c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MzlhNzhkYzRhOWJlNGU1ZGIwMjY1Y2Y4ZTczYmUyOGNlOTIyZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-04T16:21:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-04T16:21:47Z"}, "message": "auto merge of #5205 : thestinger/rust/radix, r=graydon\n\nThis is an implementation of a map and set for integer keys. It's an ordered container (by byte order, which is sorted order for integers and byte strings when done in the right direction) with O(1) worst-case lookup, removal and insertion. There's no rebalancing or rehashing so it's actually O(1) without amortizing any costs.\r\n\r\nThe fanout can be adjusted in multiples of 2 from 2-ary through 256-ary, but it's hardcoded at 16-ary because there isn't a way to expose that in the type system yet. To keep things simple, it also only allows `uint` keys, but later I'll expand it to all the built-in integer types and byte arrays.\r\n\r\nThere's quite a bit of room for performance improvement, along with the boost that will come with dropping the headers on `Owned` `~` and getting rid of the overhead from the stack switches to the allocator. It currently does suffix compression for a single node and then splits into two n-ary trie nodes, which could be replaced with an array for at least 4-8 suffixes before splitting it. There's also the option of doing path compression, which may be a good or a bad idea and depends a lot on the data stored.\r\n\r\nI want to share the test suite with the other maps so that's why I haven't duplicated all of the existing integer key tests in this file. I'll send in another pull request to deal with that.\r\n\r\nCurrent benchmark numbers against the other map types:\r\n\r\n    TreeMap:\r\n     Sequential integers:\r\n      insert: 0.798295\r\n      search: 0.188931\r\n      remove: 0.435923\r\n     Random integers:\r\n      insert: 1.557661\r\n      search: 0.758325\r\n      remove: 1.720527\r\n\r\n    LinearMap:\r\n     Sequential integers:\r\n      insert: 0.272338\r\n      search: 0.141179\r\n      remove: 0.190273\r\n     Random integers:\r\n      insert: 0.293588\r\n      search: 0.162677\r\n      remove: 0.206142\r\n\r\n    TrieMap:\r\n     Sequential integers:\r\n      insert: 0.0901\r\n      search: 0.012223\r\n      remove: 0.084139\r\n     Random integers:\r\n      insert: 0.392719\r\n      search: 0.261632\r\n      remove: 0.470401\r\n\r\n@graydon is using an earlier version of this for the garbage collection implementation, so that's why I added this to libcore. I left out the `next` and `prev` methods *for now* because I just wanted the essentials first.", "tree": {"sha": "f22ed3e6def026597e34b62efc9eaf5b91a7f12b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f22ed3e6def026597e34b62efc9eaf5b91a7f12b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "html_url": "https://github.com/rust-lang/rust/commit/c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c639a78dc4a9be4e5db0265cf8e73be28ce922f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edcebac1ccdbc353fe3bc68892137584258ff1ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/edcebac1ccdbc353fe3bc68892137584258ff1ee", "html_url": "https://github.com/rust-lang/rust/commit/edcebac1ccdbc353fe3bc68892137584258ff1ee"}, {"sha": "a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "html_url": "https://github.com/rust-lang/rust/commit/a4d22635e1453d77e90c4335f5c2e1f62e3185eb"}], "stats": {"total": 370, "additions": 370, "deletions": 0}, "files": [{"sha": "010e3f8655bb641131c0000adf30284f58770d78", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c639a78dc4a9be4e5db0265cf8e73be28ce922f6/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c639a78dc4a9be4e5db0265cf8e73be28ce922f6/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "patch": "@@ -144,6 +144,7 @@ pub mod dlist;\n pub mod dlist_iter;\n pub mod hashmap;\n pub mod cell;\n+pub mod trie;\n \n \n /* Tasks and communication */"}, {"sha": "c8faccf28f25540ec0b22c39ec66219b10a809b4", "filename": "src/libcore/trie.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/c639a78dc4a9be4e5db0265cf8e73be28ce922f6/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c639a78dc4a9be4e5db0265cf8e73be28ce922f6/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=c639a78dc4a9be4e5db0265cf8e73be28ce922f6", "patch": "@@ -0,0 +1,369 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A radix trie for storing integers in sorted order\n+\n+use prelude::*;\n+\n+// FIXME: #3469: need to manually update TrieNode when SHIFT changes\n+const SHIFT: uint = 4;\n+const SIZE: uint = 1 << SHIFT;\n+const MASK: uint = SIZE - 1;\n+\n+enum Child<T> {\n+    Internal(~TrieNode<T>),\n+    External(uint, T),\n+    Nothing\n+}\n+\n+pub struct TrieMap<T> {\n+    priv root: TrieNode<T>,\n+    priv length: uint\n+}\n+\n+impl<T> BaseIter<(uint, &T)> for TrieMap<T> {\n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        self.root.each(f)\n+    }\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl<T> ReverseIter<(uint, &T)> for TrieMap<T> {\n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        self.root.each_reverse(f)\n+    }\n+}\n+\n+impl<T> Container for TrieMap<T> {\n+    /// Return the number of elements in the map\n+    #[inline(always)]\n+    pure fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements\n+    #[inline(always)]\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<T: Copy> Mutable for TrieMap<T> {\n+    /// Clear the map, removing all values.\n+    #[inline(always)]\n+    fn clear(&mut self) {\n+        self.root = TrieNode::new();\n+        self.length = 0;\n+    }\n+}\n+\n+impl<T: Copy> Map<uint, T> for TrieMap<T> {\n+    /// Return true if the map contains a value for the specified key\n+    #[inline(always)]\n+    pure fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Visit all keys in order\n+    #[inline(always)]\n+    pure fn each_key(&self, f: fn(&uint) -> bool) {\n+        self.each(|&(k, _)| f(&k))\n+    }\n+\n+    /// Visit all values in order\n+    #[inline(always)]\n+    pure fn each_value(&self, f: fn(&T) -> bool) { self.each(|&(_, v)| f(v)) }\n+\n+    /// Return the value corresponding to the key in the map\n+    #[inline(hint)]\n+    pure fn find(&self, key: &uint) -> Option<&self/T> {\n+        let mut node: &self/TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        loop {\n+            match node.children[chunk(*key, idx)] {\n+              Internal(ref x) => node = &**x,\n+              External(stored, ref value) => {\n+                if stored == *key {\n+                    return Some(value)\n+                } else {\n+                    return None\n+                }\n+              }\n+              Nothing => return None\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    #[inline(always)]\n+    fn insert(&mut self, key: uint, value: T) -> bool {\n+        let ret = insert(&mut self.root.count,\n+                         &mut self.root.children[chunk(key, 0)],\n+                         key, value, 1);\n+        if ret { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    #[inline(always)]\n+    fn remove(&mut self, key: &uint) -> bool {\n+        let ret = remove(&mut self.root.count,\n+                         &mut self.root.children[chunk(*key, 0)],\n+                         *key, 1);\n+        if ret { self.length -= 1 }\n+        ret\n+    }\n+}\n+\n+impl<T: Copy> TrieMap<T> {\n+    #[inline(always)]\n+    static pure fn new() -> TrieMap<T> {\n+        TrieMap{root: TrieNode::new(), length: 0}\n+    }\n+}\n+\n+impl<T> TrieMap<T> {\n+    /// Visit all keys in reverse order\n+    #[inline(always)]\n+    pure fn each_key_reverse(&self, f: fn(&uint) -> bool) {\n+        self.each_reverse(|&(k, _)| f(&k))\n+    }\n+\n+    /// Visit all values in reverse order\n+    #[inline(always)]\n+    pure fn each_value_reverse(&self, f: fn(&T) -> bool) {\n+        self.each_reverse(|&(_, v)| f(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+        self.root.mutate_values(f)\n+    }\n+}\n+\n+pub struct TrieSet {\n+    priv map: TrieMap<()>\n+}\n+\n+impl BaseIter<uint> for TrieSet {\n+    /// Visit all values in order\n+    pure fn each(&self, f: fn(&uint) -> bool) { self.map.each_key(f) }\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl ReverseIter<uint> for TrieSet {\n+    /// Visit all values in reverse order\n+    pure fn each_reverse(&self, f: fn(&uint) -> bool) {\n+        self.map.each_key_reverse(f)\n+    }\n+}\n+\n+impl Container for TrieSet {\n+    /// Return the number of elements in the set\n+    #[inline(always)]\n+    pure fn len(&self) -> uint { self.map.len() }\n+\n+    /// Return true if the set contains no elements\n+    #[inline(always)]\n+    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+}\n+\n+impl Mutable for TrieSet {\n+    /// Clear the set, removing all values.\n+    #[inline(always)]\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl TrieSet {\n+    /// Return true if the set contains a value\n+    #[inline(always)]\n+    pure fn contains(&self, value: &uint) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    #[inline(always)]\n+    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    #[inline(always)]\n+    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n+}\n+\n+struct TrieNode<T> {\n+    count: uint,\n+    children: [Child<T> * 16] // FIXME: #3469: can't use the SIZE constant yet\n+}\n+\n+impl<T: Copy> TrieNode<T> {\n+    #[inline(always)]\n+    static pure fn new() -> TrieNode<T> {\n+        TrieNode{count: 0, children: [Nothing, ..SIZE]}\n+    }\n+}\n+\n+impl<T> TrieNode<T> {\n+    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        for uint::range(0, self.children.len()) |idx| {\n+            match self.children[idx] {\n+                Internal(ref x) => x.each(f),\n+                External(k, ref v) => if !f(&(k, v)) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+\n+    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        for uint::range_rev(self.children.len(), 0) |idx| {\n+            match self.children[idx - 1] {\n+                Internal(ref x) => x.each(f),\n+                External(k, ref v) => if !f(&(k, v)) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+\n+    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+        for vec::each_mut(self.children) |child| {\n+            match *child {\n+                Internal(ref mut x) => x.mutate_values(f),\n+                External(k, ref mut v) => if !f(k, v) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+}\n+\n+// if this was done via a trait, the key could be generic\n+#[inline(always)]\n+pure fn chunk(n: uint, idx: uint) -> uint {\n+    let real_idx = uint::bytes - 1 - idx;\n+    (n >> (SHIFT * real_idx)) & MASK\n+}\n+\n+fn insert<T: Copy>(count: &mut uint, child: &mut Child<T>, key: uint,\n+                   value: T, idx: uint) -> bool {\n+    match *child {\n+      External(stored_key, stored_value) => {\n+          if stored_key == key {\n+              false // already in the trie\n+          } else {\n+              // conflict - split the node\n+              let mut new = ~TrieNode::new();\n+              insert(&mut new.count,\n+                     &mut new.children[chunk(stored_key, idx)],\n+                     stored_key, stored_value, idx + 1);\n+              insert(&mut new.count, &mut new.children[chunk(key, idx)], key,\n+                     value, idx + 1);\n+              *child = Internal(new);\n+              true\n+          }\n+      }\n+      Internal(ref mut x) => {\n+        insert(&mut x.count, &mut x.children[chunk(key, idx)], key, value,\n+               idx + 1)\n+      }\n+      Nothing => {\n+        *count += 1;\n+        *child = External(key, value);\n+        true\n+      }\n+    }\n+}\n+\n+fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n+             idx: uint) -> bool {\n+    let (ret, this) = match *child {\n+      External(stored, _) => {\n+          if stored == key { (true, true) } else { (false, false) }\n+      }\n+      Internal(ref mut x) => {\n+          let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n+                           key, idx + 1);\n+          (ret, x.count == 0)\n+      }\n+      Nothing => (false, false)\n+    };\n+\n+    if this {\n+        *child = Nothing;\n+        *count -= 1;\n+    }\n+    ret\n+}\n+\n+#[cfg(test)]\n+pub fn check_integrity<T>(trie: &TrieNode<T>) {\n+    assert trie.count != 0;\n+\n+    let mut sum = 0;\n+\n+    for trie.children.each |x| {\n+        match *x {\n+          Nothing => (),\n+          Internal(ref y) => {\n+              check_integrity(&**y);\n+              sum += 1\n+          }\n+          External(_, _) => { sum += 1 }\n+        }\n+    }\n+\n+    assert sum == trie.count;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use uint;\n+\n+    #[test]\n+    fn test_step() {\n+        let mut trie = TrieMap::new();\n+        let n = 300;\n+\n+        for uint::range_step(1, n, 2) |x| {\n+            assert trie.insert(x, x + 1);\n+            assert trie.contains_key(&x);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(0, n, 2) |x| {\n+            assert !trie.contains_key(&x);\n+            assert trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range(0, n) |x| {\n+            assert trie.contains_key(&x);\n+            assert !trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(1, n, 2) |x| {\n+            assert trie.remove(&x);\n+            assert !trie.contains_key(&x);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(0, n, 2) |x| {\n+            assert trie.contains_key(&x);\n+            assert !trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+    }\n+}"}]}