{"sha": "3075c1f65e08e0b52dcf872588358daffef8b47c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNzVjMWY2NWUwOGUwYjUyZGNmODcyNTg4MzU4ZGFmZmVmOGI0N2M=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-01-02T01:33:37Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-01-04T22:34:30Z"}, "message": "Document custom derive.\n\nThese are some bare-bones documentation for custom derive, needed\nto stabilize \"macros 1.1\",\nhttps://github.com/rust-lang/rust/issues/35900\n\nThe book chapter is based off of a blog post by @cbreeden,\nhttps://cbreeden.github.io/Macros11/\n\nNormally, we have a policy of not mentioning external crates in\ndocumentation. However, given that syn/quote are basically neccesary\nfor properly using macros 1.1, I feel that not including them here\nwould make the documentation very bad. So the rules should be bent\nin this instance.", "tree": {"sha": "a758e97393d42ab3bd91b030dc16cce398adf56f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a758e97393d42ab3bd91b030dc16cce398adf56f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3075c1f65e08e0b52dcf872588358daffef8b47c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3075c1f65e08e0b52dcf872588358daffef8b47c", "html_url": "https://github.com/rust-lang/rust/commit/3075c1f65e08e0b52dcf872588358daffef8b47c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3075c1f65e08e0b52dcf872588358daffef8b47c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b14a3b50782a3f680ab3bc75dde813333cb708", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b14a3b50782a3f680ab3bc75dde813333cb708", "html_url": "https://github.com/rust-lang/rust/commit/95b14a3b50782a3f680ab3bc75dde813333cb708"}], "stats": {"total": 270, "additions": 258, "deletions": 12}, "files": [{"sha": "babbafa078f4a7b52c223da7e658c5ba6bd5276d", "filename": "src/doc/book/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Fbook%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Fbook%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2FSUMMARY.md?ref=3075c1f65e08e0b52dcf872588358daffef8b47c", "patch": "@@ -52,6 +52,7 @@\n     * [Borrow and AsRef](borrow-and-asref.md)\n     * [Release Channels](release-channels.md)\n     * [Using Rust without the standard library](using-rust-without-the-standard-library.md)\n+    * [Procedural Macros (and custom derive)](procedural-macros.md)\n * [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)"}, {"sha": "37d3d20c06d966391a0f9241dc1bfe2953365113", "filename": "src/doc/book/procedural-macros.md", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Fbook%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Fbook%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fprocedural-macros.md?ref=3075c1f65e08e0b52dcf872588358daffef8b47c", "patch": "@@ -0,0 +1,213 @@\n+% Procedural Macros (and custom Derive)\n+\n+As you've seen throughout the rest of the book, Rust provides a mechanism\n+called \"derive\" that lets you implement traits easily. For example,\n+\n+```rust\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+```\n+\n+is a lot simpler than\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+use std::fmt;\n+\n+impl fmt::Debug for Point {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n+    }\n+}\n+```\n+\n+Rust includes several traits that you can derive, but it also lets you define\n+your own. We can accomplish this task through a feature of Rust called\n+\"procedural macros.\" Eventually, procedural macros will allow for all sorts of\n+advanced metaprogramming in Rust, but today, they're only for custom derive.\n+\n+Let's build a very simple trait, and derive it with custom derive.\n+\n+## Hello World\n+\n+So the first thing we need to do is start a new crate for our project.\n+\n+```bash\n+$ cargo new --bin hello-world\n+```\n+\n+All we want is to be able to call `hello_world()` on a derived type. Something\n+like this:\n+\n+```rust,ignore\n+#[derive(HelloWorld)]\n+struct Pancakes;\n+\n+fn main() {\n+    Pancakes::hello_world();\n+}\n+```\n+\n+With some kind of nice output, like `Hello, World! My name is Pancakes.`. \n+\n+Let's go ahead and write up what we think our macro will look like from a user\n+perspective. In `src/main.rs` we write:\n+\n+```rust,ignore\n+#[macro_use]\n+extern crate hello_world_derive;\n+\n+trait HelloWorld {\n+    fn hello_world();\n+}\n+\n+#[derive(HelloWorld)]\n+struct FrenchToast;\n+\n+#[derive(HelloWorld)]\n+struct Waffles;\n+\n+fn main() {\n+    FrenchToast::hello_world();\n+    Waffles::hello_world();\n+}\n+```\n+\n+Great. So now we just need to actually write the procedural macro. At the\n+moment, procedural macros need to be in their own crate. Eventually, this\n+restriction may be lifted, but for now, it's required. As such, there's a\n+convention; for a crate named `foo`, a custom derive procedural macro is called\n+`foo-derive`. Let's start a new crate called `hello-world-derive` inside our\n+`hello-world` project.\n+\n+```bash\n+$ cargo new hello-world-derive\n+```\n+\n+To make sure that our `hello-world` crate is able to find this new crate we've\n+created, we'll add it to our toml:\n+\n+```toml\n+[dependencies]\n+hello-world-derive = { path = \"hello-world-derive\" }\n+```\n+\n+As for our the source of our `hello-world-derive` crate, here's an example:\n+\n+```rust,ignore\n+extern crate proc_macro;\n+extern crate syn;\n+#[macro_use]\n+extern crate quote;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(HelloWorld)]\n+pub fn hello_world(input: TokenStream) -> TokenStream {\n+    // Construct a string representation of the type definition\n+    let s = input.to_string();\n+    \n+    // Parse the string representation\n+    let ast = syn::parse_macro_input(&s).unwrap();\n+\n+    // Build the impl\n+    let gen = impl_hello_world(&ast);\n+    \n+    // Return the generated impl\n+    gen.parse().unwrap()\n+}\n+```\n+\n+So there is a lot going on here. We have introduced two new crates: [`syn`] and\n+[`quote`]. As you may have noticed, `input: TokenSteam` is immediately converted\n+to a `String`. This `String` is a string representation of the Rust code for which\n+we are deriving `HelloWorld` for. At the moment, the only thing you can do with a\n+`TokenStream` is convert it to a string. A richer API will exist in the future.\n+\n+So what we really need is to be able to _parse_ Rust code into something\n+usable. This is where `syn` comes to play. `syn` is a crate for parsing Rust\n+code. The other crate we've introduced is `quote`. It's essentially the dual of\n+`syn` as it will make generating Rust code really easy. We could write this\n+stuff on our own, but it's much simpler to use these libraries. Writing a full\n+parser for Rust code is no simple task.\n+\n+[`syn`]: https://crates.io/crates/syn\n+[`quote`]: https://crates.io/crates/quote\n+\n+The comments seem to give us a pretty good idea of our overall strategy. We\n+are going to take a `String` of the Rust code for the type we are deriving, parse\n+it using `syn`, construct the implementation of `hello_world` (using `quote`),\n+then pass it back to Rust compiler.\n+\n+One last note: you'll see some `unwrap()`s there. If you want to provide an\n+error for a procedural macro, then you should `panic!` with the error message.\n+In this case, we're keeping it as simple as possible.\n+\n+Great, so let's write `impl_hello_world(&ast)`.\n+\n+```rust,ignore\n+fn impl_hello_world(ast: &syn::MacroInput) -> quote::Tokens {\n+    let name = &ast.ident;\n+    quote! {\n+        impl HelloWorld for #name {\n+            fn hello_world() {\n+                println!(\"Hello, World! My name is {}\", stringify!(#name));\n+            }\n+        }\n+    }\n+}\n+```\n+\n+So this is where quotes comes in. The `ast` argument is a struct that gives us\n+a representation of our type (which can be either a `struct` or an `enum`).\n+Check out the [docs](https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html),\n+there is some useful information there. We are able to get the name of the\n+type using `ast.ident`. The `quote!` macro let's us write up the Rust code\n+that we wish to return and convert it into `Tokens`. `quote!` let's us use some\n+really cool templating mechanics; we simply write `#name` and `quote!` will\n+replace it with the variable named `name`. You can even do some repetition\n+similar to regular macros work. You should check out the\n+[docs](https://docs.rs/quote) for a good introduction.\n+\n+So I think that's it. Oh, well, we do need to add dependencies for `syn` and\n+`quote` in the `cargo.toml` for `hello-world-derive`.\n+\n+```toml\n+[dependencies]\n+syn = \"0.10.5\"\n+quote = \"0.3.10\"\n+```\n+\n+That should be it. Let's try to compile `hello-world`.\n+\n+```bash\n+error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n+ --> hello-world-derive/src/lib.rs:8:3\n+  |\n+8 | #[proc_macro_derive(HelloWorld)]\n+  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+Oh, so it appears that we need to declare that our `hello-world-derive` crate is\n+a `proc-macro` crate type. How do we do this? Like this:\n+\n+```toml\n+[lib]\n+proc-macro = true\n+```\n+\n+Ok so now, let's compile `hello-world`. Executing `cargo run` now yields:\n+\n+```bash\n+Hello, World! My name is FrenchToast\n+Hello, World! My name is Waffles\n+```\n+\n+We've done it!"}, {"sha": "4112b328f612ee380416aebe5763036126ea7efa", "filename": "src/doc/reference.md", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3075c1f65e08e0b52dcf872588358daffef8b47c", "patch": "@@ -555,26 +555,24 @@ mod a {\n # fn main() {}\n ```\n \n-# Syntax extensions\n+# Macros\n \n A number of minor features of Rust are not central enough to have their own\n syntax, and yet are not implementable as functions. Instead, they are given\n names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n-Users of `rustc` can define new syntax extensions in two ways:\n-\n-* [Compiler plugins][plugin] can include arbitrary Rust code that\n-  manipulates syntax trees at compile time. Note that the interface\n-  for compiler plugins is considered highly unstable.\n+Users of `rustc` can define new macros in two ways:\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n+* [Procedural Macros][procedural macros] can be used to implement custom derive.\n+\n+And one unstable way: [compiler plugins][plugin].\n \n ## Macros\n \n `macro_rules` allows users to define syntax extension in a declarative way.  We\n-call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n-from the \"procedural macros\" defined in [compiler plugins][plugin].\n+call such extensions \"macros by example\" or simply \"macros\".\n \n Currently, macros can expand to expressions, statements, items, or patterns.\n \n@@ -652,6 +650,28 @@ Rust syntax is restricted in two ways:\n \n [RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n \n+## Procedrual Macros\n+\n+\"Procedrual macros\" are the second way to implement a macro. For now, the only\n+thing they can be used for is to implement derive on your own types. See\n+[the book][procedural macros] for a tutorial.\n+\n+Procedural macros involve a few different parts of the language and its\n+standard libraries. First is the `proc_macro` crate, included with Rust,\n+that defines an interface for building a procedrual macro. The \n+`#[proc_macro_derive(Foo)]` attribute is used to mark the the deriving\n+function. This function must have the type signature:\n+\n+```rust,ignore\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Hello)]\n+pub fn hello_world(input: TokenStream) -> TokenStream\n+```\n+\n+Finally, procedural macros must be in their own crate, with the `proc-macro`\n+crate type.\n+\n # Crates and source files\n \n Although Rust, like any other language, can be implemented by an interpreter as\n@@ -2319,6 +2339,9 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n }\n ```\n \n+You can implement `derive` for your own type through [procedural\n+macros](#procedural-macros).\n+\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not\n@@ -4122,6 +4145,16 @@ be ignored in favor of only building the artifacts specified by command line.\n   in dynamic libraries. This form of output is used to produce statically linked\n   executables as well as `staticlib` outputs.\n \n+* `--crate-type=proc-macro`, `#[crate_type = \"proc-macro\"]` - The output\n+  produced is not specified, but if a `-L` path is provided to it then the\n+  compiler will recognize the output artifacts as a macro and it can be loaded\n+  for a program. If a crate is compiled with the `proc-macro` crate type it\n+  will forbid exporting any items in the crate other than those functions\n+  tagged `#[proc_macro_derive]` and those functions must also be placed at the\n+  crate root. Finally, the compiler will automatically set the\n+  `cfg(proc_macro)` annotation whenever any crate type of a compilation is the\n+  `proc-macro` crate type.\n+\n Note that these outputs are stackable in the sense that if multiple are\n specified, then the compiler will produce each form of output at once without\n having to recompile. However, this only applies for outputs specified by the\n@@ -4299,3 +4332,4 @@ that have since been removed):\n \n [ffi]: book/ffi.html\n [plugin]: book/compiler-plugins.html\n+[procedural macros]: book/procedural-macros.html"}, {"sha": "22b365fa64f0eba966998432a5a045370d47872d", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3075c1f65e08e0b52dcf872588358daffef8b47c/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=3075c1f65e08e0b52dcf872588358daffef8b47c", "patch": "@@ -15,15 +15,13 @@\n //! Currently the primary use of this crate is to provide the ability to define\n //! new custom derive modes through `#[proc_macro_derive]`.\n //!\n-//! Added recently as part of [RFC 1681] this crate is stable as of Rust 1.15.0.\n-//!\n-//! [RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n-//!\n //! Note that this crate is intentionally very bare-bones currently. The main\n //! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n //! implementations, indicating that it can only go to and come from a string.\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n+//!\n+//! See [the book](../../book/procedural-macros.html) for more.\n \n #![crate_name = \"proc_macro\"]\n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]"}]}