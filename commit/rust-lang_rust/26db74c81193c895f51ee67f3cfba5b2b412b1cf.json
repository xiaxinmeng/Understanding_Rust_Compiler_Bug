{"sha": "26db74c81193c895f51ee67f3cfba5b2b412b1cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZGI3NGM4MTE5M2M4OTVmNTFlZTY3ZjNjZmJhNWIyYjQxMmIxY2Y=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-16T01:14:58Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-16T01:14:58Z"}, "message": "rustc: Box the vectors returned from ty::tag_variants", "tree": {"sha": "4d59028d98b4146e24e03de1c68a77b8d7a33d07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d59028d98b4146e24e03de1c68a77b8d7a33d07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26db74c81193c895f51ee67f3cfba5b2b412b1cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26db74c81193c895f51ee67f3cfba5b2b412b1cf", "html_url": "https://github.com/rust-lang/rust/commit/26db74c81193c895f51ee67f3cfba5b2b412b1cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26db74c81193c895f51ee67f3cfba5b2b412b1cf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1b3e3ea1093b1d62b5ac607c140a119fd8a94dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b3e3ea1093b1d62b5ac607c140a119fd8a94dd", "html_url": "https://github.com/rust-lang/rust/commit/a1b3e3ea1093b1d62b5ac607c140a119fd8a94dd"}], "stats": {"total": 76, "additions": 39, "deletions": 37}, "files": [{"sha": "4d02d4df9227345281ee3180d9fee27c4812f097", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -149,7 +149,7 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       }\n       pat_tag(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n+        if vec::len(*ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n         false\n       }"}, {"sha": "2154b36085de3f605ed0813c3e16b55450f2129f", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -128,7 +128,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n       ty::ty_tag(did, tps) {\n         let variants = ty::tag_variants(cx, did);\n-        for variant in variants {\n+        for variant in *variants {\n             for aty in variant.args {\n                 let arg_ty = ty::substitute_type_params(cx, tps, aty);\n                 if type_is_gc_relevant(cx, arg_ty) { ret true; }"}, {"sha": "1c12566f9f15095f25e6fb5f476c1f426961edbf", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -32,7 +32,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n               }\n               ty::ty_tag(did, tps) {\n                 let variants = ty::tag_variants(tcx, did);\n-                if vec::len(variants) != 1u ||\n+                if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n                     break;\n                 }"}, {"sha": "bd8d254137fff1fca85261e4641518fc6b512114", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -106,7 +106,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // just T.\n     let ranges = [];\n     let variants = ty::tag_variants(ccx.tcx, tag_id);\n-    for variant: ty::variant_info in variants {\n+    for variant: ty::variant_info in *variants {\n         let bounded = true;\n         let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n         for elem_t: ty::t in variant.args {\n@@ -134,7 +134,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n \n     // Initialize the candidate set to contain all variants.\n     let candidates = [mutable];\n-    for variant in variants { candidates += [mutable true]; }\n+    for variant in *variants { candidates += [mutable true]; }\n \n     // Do a pairwise comparison among all variants still in the candidate set.\n     // Throw out any variant that we know has size and alignment at least as\n@@ -214,7 +214,7 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     // Add space for the tag if applicable.\n     // FIXME (issue #792): This is wrong. If the tag starts with an 8 byte\n     // aligned quantity, we don't align it.\n-    if vec::len(variants) > 1u {\n+    if vec::len(*variants) > 1u {\n         let variant_t = T_tag_variant(ccx);\n         max_size += trans::llsize_of_real(ccx, variant_t) as u16;\n         let align = trans::llalign_of_real(ccx, variant_t) as u8;\n@@ -228,11 +228,11 @@ tag tag_kind { tk_unit; tk_enum; tk_complex; }\n \n fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n-    if vec::len(variants) == 0u { ret tk_complex; }\n-    for v: ty::variant_info in variants {\n+    if vec::len(*variants) == 0u { ret tk_complex; }\n+    for v: ty::variant_info in *variants {\n         if vec::len(v.args) > 0u { ret tk_complex; }\n     }\n-    if vec::len(variants) == 1u { ret tk_unit; }\n+    if vec::len(*variants) == 1u { ret tk_unit; }\n     ret tk_enum;\n }\n \n@@ -452,7 +452,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         let item_tyt = ty::lookup_item_type(ccx.tcx, did);\n         let ty_param_count = vec::len(item_tyt.kinds);\n \n-        for v: ty::variant_info in variants {\n+        for v: ty::variant_info in *variants {\n             offsets += [vec::len(data) as u16];\n \n             let variant_shape = shape_of_variant(ccx, v, ty_param_count);\n@@ -476,7 +476,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         let did = did_; // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n         add_u16(header, header_sz + info_sz);\n-        info_sz += 2u16 * ((vec::len(variants) as u16) + 2u16) + 3u16;\n+        info_sz += 2u16 * ((vec::len(*variants) as u16) + 2u16) + 3u16;\n     }\n \n     // Construct the info tables, which contain offsets to the shape of each\n@@ -488,7 +488,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n-        add_u16(info, vec::len(variants) as u16);\n+        add_u16(info, vec::len(*variants) as u16);\n \n         // Construct the largest-variants table.\n         add_u16(info,\n@@ -500,7 +500,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         // Determine whether the tag has dynamic size.\n         let dynamic = false;\n-        for variant: ty::variant_info in variants {\n+        for variant: ty::variant_info in *variants {\n             for typ: ty::t in variant.args {\n                 if ty::type_has_dynamic_size(ccx.tcx, typ) { dynamic = true; }\n             }\n@@ -516,7 +516,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         info += [size_align.align];\n \n         // Now write in the offset of each variant.\n-        for v: ty::variant_info in variants {\n+        for v: ty::variant_info in *variants {\n             add_u16(info, header_sz + info_sz + offsets[i]);\n             i += 1u;\n         }"}, {"sha": "e9f769b4ec5d8e4341fc8d4aae4603e5f8d8001c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -211,7 +211,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n \n fn type_of_tag(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-    let degen = vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    let degen = vec::len(*ty::tag_variants(cx.tcx, did)) == 1u;\n     if check type_has_static_size(cx, t) {\n         let size = static_size_of_tag(cx, sp, t);\n         if !degen { T_tag(cx, size) }\n@@ -511,7 +511,7 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n \n         let max_size = 0u;\n         let variants = ty::tag_variants(cx.tcx, tid);\n-        for variant: ty::variant_info in variants {\n+        for variant: ty::variant_info in *variants {\n             let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n \n@@ -592,7 +592,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         let max_size: ValueRef = alloca(bcx, ccx.int_type);\n         Store(bcx, C_int(ccx, 0), max_size);\n         let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n-        for variant: ty::variant_info in variants {\n+        for variant: ty::variant_info in *variants {\n             // Perform type substitution on the raw argument types.\n \n             let raw_tys: [ty::t] = variant.args;\n@@ -609,7 +609,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n         }\n         let max_size_val = Load(bcx, max_size);\n         let total_size =\n-            if vec::len(variants) != 1u {\n+            if vec::len(*variants) != 1u {\n                 Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n@@ -1693,7 +1693,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n-        let n_variants = vec::len(variants);\n+        let n_variants = vec::len(*variants);\n \n         // Cast the tags to types we can GEP into.\n         if n_variants == 1u {\n@@ -1715,7 +1715,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n         let i = 0u;\n-        for variant: ty::variant_info in variants {\n+        for variant: ty::variant_info in *variants {\n             let variant_cx =\n                 new_sub_block_ctxt(cx,\n                                    \"tag-iter-variant-\" +\n@@ -2340,7 +2340,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n-            if vec::len(variants) != 1u ||\n+            if vec::len(*variants) != 1u ||\n                    vec::len(variants[0].args) != 1u {\n                 break;\n             }\n@@ -2714,7 +2714,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let bcx = alloc_result.bcx;\n             let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n             let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n-            let d = if vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n+            let d = if vec::len(*ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n                 let lldiscrim = Load(bcx, lldiscrim_gv);\n                 lldiscrim"}, {"sha": "5c45ec7fc59f7e5f1996e77b053b69fde5407a8b", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -65,7 +65,7 @@ fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n     let i = 0u;\n-    for v: ty::variant_info in variants {\n+    for v: ty::variant_info in *variants {\n         if vdef.var == v.id { ret var(i, vdef); }\n         i += 1u;\n     }\n@@ -265,7 +265,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     let args = [];\n     let size =\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n-    if size > 0u && vec::len(variants) != 1u {\n+    if size > 0u && vec::len(*variants) != 1u {\n         let tagptr =\n             PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx));\n         blobptr = GEPi(bcx, tagptr, [0, 1]);\n@@ -470,7 +470,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     if vec::len(opts) > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n-            if vec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n+            if vec::len(*ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n                 kind = single;\n             } else {\n                 let tagptr ="}, {"sha": "57ef16ded610fc1bdda5272fcf000a72d8a6b205", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -962,7 +962,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       }\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n-        for variant in variants {\n+        for variant in *variants {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n@@ -1031,7 +1031,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let lowest = ast::kind_sendable;\n-        for variant in tag_variants(cx, did) {\n+        for variant in *tag_variants(cx, did) {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n@@ -1063,7 +1063,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     if test(sty) { ret true; }\n     alt sty {\n       ty_tag(did, tps) {\n-        for variant in tag_variants(cx, did) {\n+        for variant in *tag_variants(cx, did) {\n             for aty in variant.args {\n                 let sty = substitute_type_params(cx, tps, aty);\n                 if type_structurally_contains(cx, sty, test) { ret true; }\n@@ -1187,7 +1187,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n-        for variant: variant_info in variants {\n+        for variant: variant_info in *variants {\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n@@ -1247,7 +1247,7 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n           }\n           ty_tag(did, tps) {\n             let variants = tag_variants(cx, did);\n-            if vec::len(variants) != 1u || vec::len(variants[0].args) != 1u {\n+            if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 break;\n             }\n             t1 = substitute_type_params(cx, tps, variants[0].args[0]);\n@@ -2723,11 +2723,13 @@ fn def_has_ty_params(def: ast::def) -> bool {\n // Tag information\n type variant_info = {args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n \n-fn tag_variants(cx: ctxt, id: ast::def_id) -> [variant_info] {\n-    if ast::local_crate != id.crate { ret csearch::get_tag_variants(cx, id); }\n+fn tag_variants(cx: ctxt, id: ast::def_id) -> @mutable [variant_info] {\n+    if ast::local_crate != id.crate {\n+        ret @mutable csearch::get_tag_variants(cx, id);\n+    }\n     assert (id.node >= 0);\n     alt smallintmap::find(*cx.tag_var_cache, id.node as uint) {\n-      option::some(variants) { ret *variants; }\n+      option::some(variants) { ret variants; }\n       _ { /* fallthrough */ }\n     }\n     let item =\n@@ -2755,7 +2757,7 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> [variant_info] {\n                       id: ast_util::local_def(did)}];\n             }\n             smallintmap::insert(*cx.tag_var_cache, id.node as uint, result);\n-            ret *result;\n+            ret result;\n           }\n         }\n       }\n@@ -2768,7 +2770,7 @@ fn tag_variant_with_id(cx: ctxt, tag_id: ast::def_id, variant_id: ast::def_id)\n    -> variant_info {\n     let variants = tag_variants(cx, tag_id);\n     let i = 0u;\n-    while i < vec::len::<variant_info>(variants) {\n+    while i < vec::len::<variant_info>(*variants) {\n         let variant = variants[i];\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;"}, {"sha": "e4d1674fd86fb57c2039164573f1f2437a564066", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26db74c81193c895f51ee67f3cfba5b2b412b1cf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=26db74c81193c895f51ee67f3cfba5b2b412b1cf", "patch": "@@ -817,7 +817,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(fcx.ccx.tcx, did);\n-            if vec::len(variants) != 1u || vec::len(variants[0].args) != 1u {\n+            if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 ret t1;\n             }\n             t1 =\n@@ -1693,7 +1693,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n               ty::ty_tag(id, tps) {\n                 let variants = ty::tag_variants(tcx, id);\n-                if vec::len(variants) != 1u ||\n+                if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n                     tcx.sess.span_fatal(expr.span,\n                                         \"can only dereference tags \" +"}]}