{"sha": "f9b1176eefb84686c76dde1b53a47ee0eb765d89", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YjExNzZlZWZiODQ2ODZjNzZkZGUxYjUzYTQ3ZWUwZWI3NjVkODk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-09T13:29:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-14T04:06:50Z"}, "message": "rustc_resolve: fix special-case for one-segment import paths.", "tree": {"sha": "6ca9d6d36cca31c593307028bfcbdf9834402b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca9d6d36cca31c593307028bfcbdf9834402b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9b1176eefb84686c76dde1b53a47ee0eb765d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b1176eefb84686c76dde1b53a47ee0eb765d89", "html_url": "https://github.com/rust-lang/rust/commit/f9b1176eefb84686c76dde1b53a47ee0eb765d89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9b1176eefb84686c76dde1b53a47ee0eb765d89/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd47831bf04175aad44d94c580a3d08f432dc23a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd47831bf04175aad44d94c580a3d08f432dc23a", "html_url": "https://github.com/rust-lang/rust/commit/cd47831bf04175aad44d94c580a3d08f432dc23a"}], "stats": {"total": 671, "additions": 433, "deletions": 238}, "files": [{"sha": "a10bb3e25df656208f111dd80cdf57e72f62ad5a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -1139,32 +1139,4 @@ impl<'a> CrateLoader<'a> {\n \n         cnum\n     }\n-\n-    pub fn process_use_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-        id: ast::NodeId,\n-        definitions: &Definitions,\n-    ) -> CrateNum {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).0;\n-\n-        let def_id = definitions.opt_local_def_id(id).unwrap();\n-        let path_len = definitions.def_path(def_id.index).data.len();\n-\n-        self.update_extern_crate(\n-            cnum,\n-            ExternCrate {\n-                src: ExternCrateSource::Use,\n-                span,\n-                path_len,\n-                direct: true,\n-            },\n-            &mut FxHashSet(),\n-        );\n-\n-        cnum\n-    }\n }"}, {"sha": "06bc41548b959d4e59ef1f2ab4af1d28382b2d43", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -17,7 +17,7 @@ use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n-use {PerNS, Resolver, ResolverArenas};\n+use {ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -175,7 +175,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n-                        source.name = crate_name;\n+                        // HACK(eddyb) unclear how good this is, but keeping `$crate`\n+                        // in `source` breaks `src/test/compile-fail/import-crate-var.rs`,\n+                        // while the current crate doesn't have a valid `crate_name`.\n+                        if crate_name != keywords::Invalid.name() {\n+                            source.name = crate_name;\n+                        }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n                         }\n@@ -187,6 +192,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n \n+                if ident.name == keywords::Crate.name() {\n+                    self.session.span_err(ident.span,\n+                        \"crate root imports need to be explicitly named: \\\n+                         `use crate as name;`\");\n+                }\n+\n                 let subclass = SingleImport {\n                     target: ident,\n                     source,\n@@ -299,7 +310,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id: item.id,\n                     id: item.id,\n                     parent,\n-                    imported_module: Cell::new(Some(module)),\n+                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate(orig_name),\n                     root_span: item.span,\n                     span: item.span,\n@@ -701,7 +712,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             root_id: item.id,\n             id: item.id,\n             parent: graph_root,\n-            imported_module: Cell::new(Some(module)),\n+            imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             root_span: span,\n             span,\n@@ -721,7 +732,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, span);\n+                let result = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    MacroNS,\n+                    false,\n+                    span,\n+                );\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);"}, {"sha": "992ea12ffa2b14c44dde94f4fdfc303ac356d791", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 146, "deletions": 74, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -953,9 +953,20 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum ModuleOrUniformRoot<'a> {\n+    /// Regular module.\n+    Module(Module<'a>),\n+\n+    /// The `{{root}}` (`CrateRoot` aka \"global\") / `extern` initial segment\n+    /// in which external crates resolve, and also `crate` (only in `{{root}}`,\n+    /// but *not* `extern`), in the Rust 2018 edition.\n+    UniformRoot(Name),\n+}\n+\n #[derive(Clone, Debug)]\n enum PathResult<'a> {\n-    Module(Module<'a>),\n+    Module(ModuleOrUniformRoot<'a>),\n     NonModule(PathResolution),\n     Indeterminate,\n     Failed(Span, String, bool /* is the error from the last segment? */),\n@@ -1583,11 +1594,13 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        match self.resolve_path(&path, Some(namespace), true, span, CrateLint::No) {\n-            PathResult::Module(module) => *def = module.def().unwrap(),\n+        match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(\n+                None,\n                 &path,\n                 None,\n                 true,\n@@ -1599,6 +1612,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 }\n                 _ => {}\n             },\n+            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -1881,7 +1895,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             };\n \n             let item = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, record_used, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                record_used,\n+                path_span,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -1906,7 +1925,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, record_used, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                record_used,\n+                path_span,\n             );\n             self.current_module = orig_current_module;\n \n@@ -1954,8 +1978,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n-                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n-                                                                        false, false, path_span) {\n+                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(prelude),\n+                    ident,\n+                    ns,\n+                    false,\n+                    false,\n+                    path_span,\n+                ) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n@@ -2013,16 +2043,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn resolve_ident_in_module(&mut self,\n-                               module: Module<'a>,\n+                               module: ModuleOrUniformRoot<'a>,\n                                mut ident: Ident,\n                                ns: Namespace,\n                                record_used: bool,\n                                span: Span)\n                                -> Result<&'a NameBinding<'a>, Determinacy> {\n         ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let Some(def) = ident.span.adjust(module.expansion) {\n-            self.current_module = self.macro_def_scope(def);\n+        if let ModuleOrUniformRoot::Module(module) = module {\n+            if let Some(def) = ident.span.adjust(module.expansion) {\n+                self.current_module = self.macro_def_scope(def);\n+            }\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n             module, ident, ns, false, record_used, span,\n@@ -2410,13 +2442,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n-                if let PathResult::Module(module) = self.resolve_path(\n-                    &path,\n-                    None,\n-                    false,\n-                    span,\n-                    CrateLint::SimplePath(trait_ref.ref_id),\n-                ) {\n+                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n+                    self.resolve_path(\n+                        None,\n+                        &path,\n+                        None,\n+                        false,\n+                        span,\n+                        CrateLint::SimplePath(trait_ref.ref_id),\n+                    )\n+                {\n                     new_val = Some((module, trait_ref.clone()));\n                 }\n             }\n@@ -2533,7 +2568,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, span).is_err() {\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                span,\n+            ).is_err() {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n                 resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n             }\n@@ -2908,9 +2949,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS),\n+                    let mod_prefix = match this.resolve_path(None, mod_path, Some(TypeNS),\n                                                              false, span, CrateLint::No) {\n-                        PathResult::Module(module) => module.def(),\n+                        PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                            module.def(),\n                         _ => None,\n                     }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n@@ -3319,14 +3361,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         let result = match self.resolve_path(\n+            None,\n             &path,\n             Some(ns),\n             true,\n             span,\n             crate_lint,\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n-            PathResult::Module(module) if !module.is_normal() => {\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n             }\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n@@ -3341,18 +3384,21 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            PathResult::Module(..) | PathResult::Failed(..)\n+            PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n+            PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].name) => {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n-            PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(span, msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n+            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Failed(..) => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n@@ -3362,14 +3408,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(\n+                    None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n                     false,\n                     span,\n                     CrateLint::No,\n                 ) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n-                    PathResult::Module(module) => module.def().unwrap(),\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n@@ -3384,13 +3432,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn resolve_path(\n         &mut self,\n+        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        let mut module = None;\n+        let mut module = base_module;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n@@ -3412,49 +3461,48 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n                 let mut ctxt = ident.span.ctxt().modern();\n-                module = Some(self.resolve_self(&mut ctxt, self.current_module));\n+                module = Some(ModuleOrUniformRoot::Module(\n+                    self.resolve_self(&mut ctxt, self.current_module)));\n                 continue\n             } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n                 let mut ctxt = ident.span.ctxt().modern();\n-                let self_module = match i {\n-                    0 => self.resolve_self(&mut ctxt, self.current_module),\n-                    _ => module.unwrap(),\n+                let self_module_parent = match i {\n+                    0 => self.resolve_self(&mut ctxt, self.current_module).parent,\n+                    _ => match module {\n+                        Some(ModuleOrUniformRoot::Module(module)) => module.parent,\n+                        _ => None,\n+                    },\n                 };\n-                if let Some(parent) = self_module.parent {\n-                    module = Some(self.resolve_self(&mut ctxt, parent));\n+                if let Some(parent) = self_module_parent {\n+                    module = Some(ModuleOrUniformRoot::Module(\n+                        self.resolve_self(&mut ctxt, parent)));\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n-            } else if i == 0 && ns == TypeNS && name == keywords::Extern.name() {\n-                continue;\n             }\n             allow_super = false;\n \n             if ns == TypeNS {\n+                if i == 0 {\n+                    if name == keywords::Extern.name() ||\n+                       name == keywords::CrateRoot.name() &&\n+                       self.session.features_untracked().extern_absolute_paths &&\n+                       self.session.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::UniformRoot(name));\n+                        continue;\n+                    }\n+                }\n                 if (i == 0 && name == keywords::CrateRoot.name()) ||\n                    (i == 0 && name == keywords::Crate.name()) ||\n                    (i == 0 && name == keywords::DollarCrate.name()) ||\n                    (i == 1 && name == keywords::Crate.name() &&\n                               path[0].name == keywords::CrateRoot.name()) {\n                     // `::a::b`, `crate::a::b`, `::crate::a::b` or `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident));\n+                    module = Some(ModuleOrUniformRoot::Module(\n+                        self.resolve_crate_root(ident)));\n                     continue\n-                } else if i == 1 && !ident.is_path_segment_keyword() {\n-                    let prev_name = path[0].name;\n-                    if prev_name == keywords::Extern.name() ||\n-                       prev_name == keywords::CrateRoot.name() &&\n-                       self.session.features_untracked().extern_absolute_paths &&\n-                       self.session.rust_2018() {\n-                        // `::extern_crate::a::b`\n-                        let crate_id = self.crate_loader.process_path_extern(name, ident.span);\n-                        let crate_root =\n-                            self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                        self.populate_module_if_necessary(crate_root);\n-                        module = Some(crate_root);\n-                        continue\n-                    }\n                 }\n             }\n \n@@ -3513,7 +3561,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let def = binding.def();\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n-                        module = Some(next_module);\n+                        module = Some(ModuleOrUniformRoot::Module(next_module));\n                     } else if def == Def::ToolMod && i + 1 != path.len() {\n                         let def = Def::NonMacroAttr(NonMacroAttrKind::Tool);\n                         return PathResult::NonModule(PathResolution::new(def));\n@@ -3537,14 +3585,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n                 Err(Determined) => {\n-                    if let Some(module) = module {\n+                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n                             return PathResult::NonModule(PathResolution::with_unresolved_segments(\n                                 module.def().unwrap(), path.len() - i\n                             ));\n                         }\n                     }\n-                    let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n+                    let module_def = match module {\n+                        Some(ModuleOrUniformRoot::Module(module)) => module.def(),\n+                        _ => None,\n+                    };\n+                    let msg = if module_def == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_import_candidates(name, TypeNS, is_mod);\n@@ -3568,7 +3620,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n \n-        PathResult::Module(module.unwrap_or(self.graph_root))\n+        PathResult::Module(module.unwrap_or_else(|| {\n+            span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n+        }))\n+\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -3578,6 +3633,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n+        // In the 2018 edition this lint is a hard error, so nothing to do\n+        if self.session.rust_2018() {\n+            return\n+        }\n+\n+        // In the 2015 edition there's no use in emitting lints unless the\n+        // crate's already enabled the feature that we're going to suggest\n+        if !self.session.features_untracked().crate_in_paths {\n+            return\n+        }\n+\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n             CrateLint::SimplePath(id) => (id, path_span),\n@@ -3620,24 +3686,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        self.lint_path_starts_with_module(diag_id, diag_span);\n-    }\n-\n-    fn lint_path_starts_with_module(&self, id: NodeId, span: Span) {\n-        // In the 2018 edition this lint is a hard error, so nothing to do\n-        if self.session.rust_2018() {\n-            return\n-        }\n-        // In the 2015 edition there's no use in emitting lints unless the\n-        // crate's already enabled the feature that we're going to suggest\n-        if !self.session.features_untracked().crate_in_paths {\n-            return\n-        }\n         let diag = lint::builtin::BuiltinLintDiagnostics\n-            ::AbsPathWithModule(span);\n+            ::AbsPathWithModule(diag_span);\n         self.session.buffer_lint_with_diagnostic(\n             lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            id, span,\n+            diag_id, diag_span,\n             \"absolute paths must start with `self`, `super`, \\\n             `crate`, or an external crate name in the 2018 edition\",\n             diag);\n@@ -3782,8 +3835,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) =\n-                    self.resolve_ident_in_module(module, ident, ns, false, module.span) {\n+            if let Ok(binding) = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    false,\n+                    module.span,\n+                ) {\n                 let def = binding.def();\n                 if filter_fn(def) {\n                     return Some(if self.has_self.contains(&def.def_id()) {\n@@ -3855,9 +3913,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n+            if let PathResult::Module(module) = self.resolve_path(None, mod_path, Some(TypeNS),\n                                                                   false, span, CrateLint::No) {\n-                add_module_candidates(module, &mut names);\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names);\n+                }\n             }\n         }\n \n@@ -4096,7 +4156,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, module.span).is_ok() {\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                module.span,\n+            ).is_ok() {\n                 let def_id = module.def_id().unwrap();\n                 found_traits.push(TraitCandidate { def_id: def_id, import_id: None });\n             }\n@@ -4144,8 +4210,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n                 continue\n             }\n-            if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n-                   .is_ok() {\n+            if self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                false,\n+                module.span,\n+            ).is_ok() {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);"}, {"sha": "44d0c888c5dd248bc63b80dd3a397e7731db9b75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -10,6 +10,7 @@\n \n use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use ModuleOrUniformRoot;\n use Namespace::{self, TypeNS, MacroNS};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n@@ -538,7 +539,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), false, span, CrateLint::No) {\n+            let res = self.resolve_path(None, &path, Some(MacroNS), false, span, CrateLint::No);\n+            let def = match res {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -655,7 +657,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted(\n-                            module, ident, ns, true, record_used, path_span,\n+                        ModuleOrUniformRoot::Module(module),\n+                        ident,\n+                        ns,\n+                        true,\n+                        record_used,\n+                        path_span,\n                     );\n                     self.current_module = orig_current_module;\n                     binding.map(MacroBinding::Modern)\n@@ -715,9 +722,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     let mut result = Err(Determinacy::Determined);\n                     if use_prelude {\n                         if let Some(prelude) = self.prelude {\n-                            if let Ok(binding) =\n-                                    self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n-                                                                          false, false, path_span) {\n+                            if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n+                                ModuleOrUniformRoot::Module(prelude),\n+                                ident,\n+                                ns,\n+                                false,\n+                                false,\n+                                path_span,\n+                            ) {\n                                 result = Ok(MacroBinding::Global(binding));\n                             }\n                         }\n@@ -893,7 +905,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(&path, Some(MacroNS), true, span, CrateLint::No) {\n+            match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "58f7532adaf500484cc77765e23eddd62cef270b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 124, "deletions": 112, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, CrateLint, Module, PerNS};\n+use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n@@ -85,7 +85,8 @@ pub struct ImportDirective<'a> {\n \n     pub parent: Module<'a>,\n     pub module_path: Vec<Ident>,\n-    pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    /// The resolution of `module_path`.\n+    pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub expansion: Mark,\n@@ -133,13 +134,38 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n     pub fn resolve_ident_in_module_unadjusted(&mut self,\n-                                              module: Module<'a>,\n+                                              module: ModuleOrUniformRoot<'a>,\n                                               ident: Ident,\n                                               ns: Namespace,\n                                               restricted_shadowing: bool,\n                                               record_used: bool,\n                                               path_span: Span)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+        let module = match module {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::UniformRoot(root) => {\n+                let crate_root = if\n+                    root != keywords::Extern.name() &&\n+                    (\n+                        ident.name == keywords::Crate.name() ||\n+                        ident.name == keywords::DollarCrate.name()\n+                    )\n+                {\n+                    self.resolve_crate_root(ident)\n+                } else if !ident.is_path_segment_keyword() {\n+                    let crate_id =\n+                        self.crate_loader.process_path_extern(ident.name, ident.span);\n+                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                } else {\n+                    return Err(Determined);\n+                };\n+                self.populate_module_if_necessary(crate_root);\n+                let binding = (crate_root, ty::Visibility::Public,\n+                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                return Ok(binding);\n+            }\n+        };\n+\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n@@ -260,15 +286,24 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !self.is_accessible(glob_import.vis.get()) {\n                 continue\n             }\n-            let module = unwrap_or!(glob_import.imported_module.get(), return Err(Undetermined));\n+            let module = match glob_import.imported_module.get() {\n+                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n+                None => return Err(Undetermined),\n+            };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n             };\n             let result = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, false, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                false,\n+                path_span,\n             );\n             self.current_module = orig_current_module;\n             match result {\n@@ -576,8 +611,14 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path[..], None, false,\n-                                           directive.span, directive.crate_lint());\n+            let result = self.resolve_path(\n+                Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n+                &directive.module_path[..],\n+                None,\n+                false,\n+                directive.span,\n+                directive.crate_lint(),\n+            );\n             directive.vis.set(vis);\n \n             match result {\n@@ -644,77 +685,9 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n         self.current_module = directive.parent;\n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let mut warn_if_binding_comes_from_local_crate = false;\n-\n-        // FIXME: Last path segment is treated specially in import resolution, so extern crate\n-        // mode for absolute paths needs some special support for single-segment imports.\n-        if module_path.len() == 1 && (module_path[0].name == keywords::CrateRoot.name() ||\n-                                      module_path[0].name == keywords::Extern.name()) {\n-            let is_extern = module_path[0].name == keywords::Extern.name() ||\n-                            (self.session.features_untracked().extern_absolute_paths &&\n-                             self.session.rust_2018());\n-            match directive.subclass {\n-                GlobImport { .. } if is_extern => {\n-                    return Some((directive.span,\n-                                 \"cannot glob-import all possible crates\".to_string()));\n-                }\n-                GlobImport { .. } if self.session.features_untracked().extern_absolute_paths => {\n-                    self.lint_path_starts_with_module(\n-                        directive.root_id,\n-                        directive.root_span,\n-                    );\n-                }\n-                SingleImport { source, target, .. } => {\n-                    let crate_root = if source.name == keywords::Crate.name() &&\n-                                        module_path[0].name != keywords::Extern.name() {\n-                        if target.name == keywords::Crate.name() {\n-                            return Some((directive.span,\n-                                         \"crate root imports need to be explicitly named: \\\n-                                          `use crate as name;`\".to_string()));\n-                        } else {\n-                            Some(self.resolve_crate_root(source))\n-                        }\n-                    } else if is_extern && !source.is_path_segment_keyword() {\n-                        let crate_id =\n-                            self.resolver.crate_loader.process_use_extern(\n-                                source.name,\n-                                directive.span,\n-                                directive.id,\n-                                &self.resolver.definitions,\n-                            );\n-                        let crate_root =\n-                            self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                        self.populate_module_if_necessary(crate_root);\n-                        Some(crate_root)\n-                    } else {\n-                        warn_if_binding_comes_from_local_crate = true;\n-                        None\n-                    };\n-\n-                    if let Some(crate_root) = crate_root {\n-                        let binding = (crate_root, ty::Visibility::Public, directive.span,\n-                                       directive.expansion).to_name_binding(self.arenas);\n-                        let binding = self.arenas.alloc_name_binding(NameBinding {\n-                            kind: NameBindingKind::Import {\n-                                binding,\n-                                directive,\n-                                used: Cell::new(false),\n-                            },\n-                            vis: directive.vis.get(),\n-                            span: directive.span,\n-                            expansion: directive.expansion,\n-                        });\n-                        let _ = self.try_define(directive.parent, target, TypeNS, binding);\n-                        let import = self.import_map.entry(directive.id).or_default();\n-                        import[TypeNS] = Some(PathResolution::new(binding.def()));\n-                        return None;\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n \n         let module_result = self.resolve_path(\n+            Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n             &module_path,\n             None,\n             true,\n@@ -734,7 +707,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if !self_path.is_empty() && !is_special(self_path[0]) &&\n                    !(self_path.len() > 1 && is_special(self_path[1])) {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, false,\n+                    self_result = Some(self.resolve_path(None, &self_path, None, false,\n                                                          span, CrateLint::No));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n@@ -748,12 +721,27 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let (ident, result, type_ns_only) = match directive.subclass {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n-            GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n-                // Importing a module into itself is not allowed.\n-                return Some((directive.span,\n-                             \"Cannot glob-import a module into itself.\".to_string()));\n-            }\n             GlobImport { is_prelude, ref max_vis } => {\n+                if module_path.len() <= 1 {\n+                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                    // 2 segments, so the `resolve_path` above won't trigger it.\n+                    let mut full_path = module_path.clone();\n+                    full_path.push(keywords::Invalid.ident());\n+                    self.lint_if_path_starts_with_module(\n+                        directive.crate_lint(),\n+                        &full_path,\n+                        directive.span,\n+                        None,\n+                    );\n+                }\n+\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    if module.def_id() == directive.parent.def_id() {\n+                        // Importing a module into itself is not allowed.\n+                        return Some((directive.span,\n+                            \"Cannot glob-import a module into itself.\".to_string()));\n+                    }\n+                }\n                 if !is_prelude &&\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n                    !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n@@ -770,8 +758,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n                 if this.record_use(ident, ns, binding, directive.span) {\n-                    this.resolution(module, ident, ns).borrow_mut().binding =\n-                        Some(this.dummy_binding);\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        this.resolution(module, ident, ns).borrow_mut().binding =\n+                            Some(this.dummy_binding);\n+                    }\n                 }\n             }\n         });\n@@ -786,8 +776,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             });\n \n             return if all_ns_failed {\n-                let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                let resolutions = match module {\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::UniformRoot(_) => None,\n+                };\n+                let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n+                let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(name_binding), .. } => {\n@@ -813,11 +808,24 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                         None => \"\".to_owned(),\n                     };\n-                let module_str = module_to_string(module);\n-                let msg = if let Some(module_str) = module_str {\n-                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n-                } else {\n-                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                let msg = match module {\n+                    ModuleOrUniformRoot::Module(module) => {\n+                        let module_str = module_to_string(module);\n+                        if let Some(module_str) = module_str {\n+                            format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n+                        } else {\n+                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                        }\n+                    }\n+                    ModuleOrUniformRoot::UniformRoot(_) => {\n+                        if !ident.is_path_segment_keyword() {\n+                            format!(\"no `{}` external crate{}\", ident, lev_suggestion)\n+                        } else {\n+                            // HACK(eddyb) this shows up for `self` & `super`, which\n+                            // should work instead - for now keep the same error message.\n+                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                        }\n+                    }\n                 };\n                 Some((span, msg))\n             } else {\n@@ -868,26 +876,20 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        if warn_if_binding_comes_from_local_crate {\n-            let mut warned = false;\n+        if module_path.len() <= 1 {\n+            // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+            // 2 segments, so the `resolve_path` above won't trigger it.\n+            let mut full_path = module_path.clone();\n+            full_path.push(ident);\n             self.per_ns(|this, ns| {\n-                let binding = match result[ns].get().ok() {\n-                    Some(b) => b,\n-                    None => return\n-                };\n-                if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n-                    if let ImportDirectiveSubclass::ExternCrate(..) = d.subclass {\n-                        return\n-                    }\n-                }\n-                if warned {\n-                    return\n+                if let Ok(binding) = result[ns].get() {\n+                    this.lint_if_path_starts_with_module(\n+                        directive.crate_lint(),\n+                        &full_path,\n+                        directive.span,\n+                        Some(binding),\n+                    );\n                 }\n-                warned = true;\n-                this.lint_path_starts_with_module(\n-                    directive.root_id,\n-                    directive.root_span,\n-                );\n             });\n         }\n \n@@ -904,7 +906,15 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     }\n \n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n-        let module = directive.imported_module.get().unwrap();\n+        let module = match directive.imported_module.get().unwrap() {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::UniformRoot(_) => {\n+                self.session.span_err(directive.span,\n+                    \"cannot glob-import all possible crates\");\n+                return;\n+            }\n+        };\n+\n         self.populate_module_if_necessary(module);\n \n         if let Some(Def::Trait(_)) = module.def() {\n@@ -1026,8 +1036,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             };\n                             let mut err = self.session.struct_span_err(binding.span, &msg);\n \n-                            let imported_module = directive.imported_module.get()\n-                                .expect(\"module should exist\");\n+                            let imported_module = match directive.imported_module.get() {\n+                                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                                _ => bug!(\"module should exist\"),\n+                            };\n                             let resolutions = imported_module.parent.expect(\"parent should exist\")\n                                 .resolutions.borrow();\n                             let enum_path_segment_index = directive.module_path.len() - 1;"}, {"sha": "b66946affadb3a4d00099ab6da35822b24c3db55", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -101,7 +101,7 @@ impl Path {\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n         if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n-            if ident.is_path_segment_keyword() && ident.name != keywords::Crate.name() {\n+            if ident.is_path_segment_keyword() {\n                 return None;\n             }\n         }"}, {"sha": "4a667f020ad343081e6af632ea6d335755f9fa99", "filename": "src/test/compile-fail/dollar-crate-is-keyword.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -10,7 +10,11 @@\n \n macro_rules! m {\n     () => {\n-        struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+        // Avoid having more than one `$crate`-named item in the same module,\n+        // as even though they error, they still parse as `$crate` and conflict.\n+        mod foo {\n+            struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+        }\n \n         use $crate; // OK\n                     //~^ WARN `$crate` may not be imported"}, {"sha": "b09883d9adeeae254c6f30590f4bba48e7ec695d", "filename": "src/test/compile-fail/import-crate-var.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n // aux-build:import_crate_var.rs\n-// error-pattern: `$crate` may not be imported\n-// error-pattern: `use $crate;` was erroneously allowed and will become a hard error\n-// error-pattern: compilation successful\n \n #![feature(rustc_attrs)]\n \n #[macro_use] extern crate import_crate_var;\n \n #[rustc_error]\n-fn main() {\n+fn main() { //~ ERROR compilation successful\n     m!();\n+    //~^ WARN `$crate` may not be imported\n+    //~| NOTE `use $crate;` was erroneously allowed and will become a hard error\n }"}, {"sha": "3e44585395788110784e8d3864fd1b77ebe5a00f", "filename": "src/test/compile-fail/keyword-extern-as-identifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -11,5 +11,5 @@\n #![feature(extern_in_paths)]\n \n fn main() {\n-    let extern = 0; //~ ERROR expected unit struct/variant or constant, found module `extern`\n+    let extern = 0; //~ ERROR cannot find unit struct/variant or constant `extern` in this scope\n }"}, {"sha": "69fc4b4f7f8fcb1dc41e82caf0132b888ac8421a", "filename": "src/test/compile-fail/rfc-2126-extern-absolute-paths/single-segment.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -11,10 +11,8 @@\n // aux-build:xcrate.rs\n // edition:2018\n \n-use crate; //~ ERROR unresolved import `crate`\n-           //~^ NOTE crate root imports need to be explicitly named: `use crate as name;`\n-use *; //~ ERROR unresolved import `*`\n-       //~^ NOTE cannot glob-import all possible crates\n+use crate; //~ ERROR crate root imports need to be explicitly named: `use crate as name;`\n+use *; //~ ERROR cannot glob-import all possible crates\n \n fn main() {\n     let s = ::xcrate; //~ ERROR expected value, found module `xcrate`"}, {"sha": "017844a0252e274218fd12275d665839b59d5993", "filename": "src/test/compile-fail/rfc-2126-extern-in-paths/single-segment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -14,8 +14,7 @@\n \n use extern; //~ ERROR unresolved import `extern`\n             //~^ NOTE no `extern` in the root\n-use extern::*; //~ ERROR unresolved import `extern::*`\n-               //~^ NOTE cannot glob-import all possible crates\n+use extern::*; //~ ERROR cannot glob-import all possible crates\n \n fn main() {\n     let s = extern::xcrate; //~ ERROR expected value, found module `extern::xcrate`"}, {"sha": "bf8dee0863a1bc51c502a06a59b9419ba9ff9b56", "filename": "src/test/run-pass/issue-52140/auxiliary/some_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn hello() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "6fae6adc44248502e69a83141e78c1c739e711ae", "filename": "src/test/run-pass/issue-52140/main.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:some_crate.rs\n+// edition:2018\n+\n+mod foo {\n+    pub use some_crate;\n+}\n+\n+fn main() {\n+    ::some_crate::hello();\n+    foo::some_crate::hello();\n+}"}, {"sha": "bf8dee0863a1bc51c502a06a59b9419ba9ff9b56", "filename": "src/test/run-pass/issue-52141/auxiliary/some_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn hello() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "8f3fc9f96989452119d0d397304e5a44d1a02010", "filename": "src/test/run-pass/issue-52141/main.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:some_crate.rs\n+// edition:2018\n+\n+use some_crate as some_name;\n+\n+mod foo {\n+    pub use crate::some_name::*;\n+}\n+\n+fn main() {\n+    ::some_crate::hello();\n+    some_name::hello();\n+    foo::hello();\n+}"}, {"sha": "48d53a2cbac0aa0c9df4d791792ed35890a753ed", "filename": "src/test/run-pass/issue-52705/auxiliary/png.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct DecodingError;"}, {"sha": "101f67e3e7b98dfa278b5be1bb3f5fd26e93f1e2", "filename": "src/test/run-pass/issue-52705/main.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b1176eefb84686c76dde1b53a47ee0eb765d89/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs?ref=f9b1176eefb84686c76dde1b53a47ee0eb765d89", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:png.rs\n+// edition:2018\n+\n+mod png {\n+    use png as png_ext;\n+\n+    fn foo() -> png_ext::DecodingError { unimplemented!() }\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}]}