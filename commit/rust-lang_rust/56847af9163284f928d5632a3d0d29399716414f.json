{"sha": "56847af9163284f928d5632a3d0d29399716414f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ODQ3YWY5MTYzMjg0ZjkyOGQ1NjMyYTNkMGQyOTM5OTcxNjQxNGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-17T13:51:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "port the match code to use `CoerceMany`\n\n`match { }` now (correctly?) indicates divergence, which results in more\nunreachable warnings. We also avoid fallback to `!` if there is just one\narm (see new test: `match-unresolved-one-arm.rs`).", "tree": {"sha": "c24655c7585a84a0e9f09db0d3552b11af72ed0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c24655c7585a84a0e9f09db0d3552b11af72ed0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56847af9163284f928d5632a3d0d29399716414f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56847af9163284f928d5632a3d0d29399716414f", "html_url": "https://github.com/rust-lang/rust/commit/56847af9163284f928d5632a3d0d29399716414f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56847af9163284f928d5632a3d0d29399716414f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dad314040764122fc78a7f8b70ffa9ef77bde3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dad314040764122fc78a7f8b70ffa9ef77bde3c5", "html_url": "https://github.com/rust-lang/rust/commit/dad314040764122fc78a7f8b70ffa9ef77bde3c5"}], "stats": {"total": 146, "additions": 95, "deletions": 51}, "files": [{"sha": "f0d2598a0fb2af5eaf1d85f49573282b0db7099e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/56847af9163284f928d5632a3d0d29399716414f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56847af9163284f928d5632a3d0d29399716414f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=56847af9163284f928d5632a3d0d29399716414f", "patch": "@@ -16,6 +16,7 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation, Diverges};\n+use check::coercion::CoerceMany;\n use util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n@@ -414,6 +415,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type(discrim, discrim_ty);\n         };\n+\n+        // If the discriminant diverges, the match is pointless (e.g.,\n+        // `match (return) { }`).\n+        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+\n+        // If there are no arms, that is a diverging match; a special case.\n+        if arms.is_empty() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+            return tcx.types.never;\n+        }\n+\n+        // Otherwise, we have to union together the types that the\n+        // arms produce and so forth.\n+\n         let discrim_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -426,6 +441,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&p, discrim_ty);\n                 all_pats_diverge &= self.diverges.get();\n             }\n+\n             // As discussed with @eddyb, this is for disabling unreachable_code\n             // warnings on patterns (they're now subsumed by unreachable_patterns\n             // warnings).\n@@ -444,20 +460,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // on any empty type and is therefore unreachable; should the flow\n         // of execution reach it, we will panic, so bottom is an appropriate\n         // type in that case)\n-        let expected = expected.adjust_for_branches(self);\n-        let mut result_ty = self.next_diverging_ty_var(\n-            TypeVariableOrigin::DivergingBlockExpr(expr.span));\n         let mut all_arms_diverge = Diverges::WarnedAlways;\n-        let coerce_first = match expected {\n-            // We don't coerce to `()` so that if the match expression is a\n-            // statement it's branches can have any consistent type. That allows\n-            // us to give better error messages (pointing to a usually better\n-            // arm for inconsistent arms or to the whole match when a `()` type\n-            // is required).\n-            Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => {\n-                ety\n-            }\n-            _ => result_ty\n+\n+        let expected = expected.adjust_for_branches(self);\n+\n+        let mut coercion = {\n+            let coerce_first = match expected {\n+                // We don't coerce to `()` so that if the match expression is a\n+                // statement it's branches can have any consistent type. That allows\n+                // us to give better error messages (pointing to a usually better\n+                // arm for inconsistent arms or to the whole match when a `()` type\n+                // is required).\n+                Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n+                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n+            };\n+            CoerceMany::new(coerce_first)\n         };\n \n         for (i, (arm, pats_diverge)) in arms.iter().zip(all_arm_pats_diverge).enumerate() {\n@@ -470,11 +487,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            if result_ty.references_error() || arm_ty.references_error() {\n-                result_ty = tcx.types.err;\n-                continue;\n-            }\n-\n             // Handle the fallback arm of a desugared if-let like a missing else.\n             let is_if_let_fallback = match match_src {\n                 hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n@@ -483,47 +495,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => false\n             };\n \n-            let cause = if is_if_let_fallback {\n-                self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse)\n+            if is_if_let_fallback {\n+                let cause = self.cause(expr.span, ObligationCauseCode::IfExpressionWithNoElse);\n+                assert!(arm_ty.is_nil());\n+                coercion.coerce_forced_unit(self, &cause);\n             } else {\n-                self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n+                let cause = self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n                     arm_span: arm.body.span,\n                     source: match_src\n-                })\n-            };\n-\n-            let result = if is_if_let_fallback {\n-                self.eq_types(true, &cause, arm_ty, result_ty)\n-                    .map(|infer_ok| {\n-                        self.register_infer_ok_obligations(infer_ok);\n-                        arm_ty\n-                    })\n-            } else if i == 0 {\n-                // Special-case the first arm, as it has no \"previous expressions\".\n-                self.try_coerce(&arm.body, arm_ty, coerce_first)\n-            } else {\n-                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(&cause, prev_arms, result_ty, &arm.body, arm_ty)\n-            };\n-\n-            result_ty = match result {\n-                Ok(ty) => ty,\n-                Err(e) => {\n-                    let (expected, found) = if is_if_let_fallback {\n-                        (arm_ty, result_ty)\n-                    } else {\n-                        (result_ty, arm_ty)\n-                    };\n-                    self.report_mismatched_types(&cause, expected, found, e).emit();\n-                    self.tcx.types.err\n-                }\n-            };\n+                });\n+                coercion.coerce(self, &cause, &arm.body, arm_ty);\n+            }\n         }\n \n         // We won't diverge unless the discriminant or all arms diverge.\n         self.diverges.set(discrim_diverges | all_arms_diverge);\n \n-        result_ty\n+        coercion.complete(self)\n     }\n \n     fn check_pat_struct(&self,"}, {"sha": "d5baec675e44f2116ee1707c94315c7ba11ba2c7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56847af9163284f928d5632a3d0d29399716414f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56847af9163284f928d5632a3d0d29399716414f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=56847af9163284f928d5632a3d0d29399716414f", "patch": "@@ -36,6 +36,7 @@ pub trait ParserObsoleteMethods {\n impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     #[allow(unused_variables)]\n+    #[allow(unreachable_code)]\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc, error) = match kind {\n             // Nothing here at the moment"}, {"sha": "db08f5e5e66a38fac2700e36f053bdd92384604c", "filename": "src/test/compile-fail/match-no-arms-unreachable-after.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-no-arms-unreachable-after.rs?ref=56847af9163284f928d5632a3d0d29399716414f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![deny(unreachable_code)]\n+\n+enum Void { }\n+\n+fn foo(v: Void) {\n+    match v { }\n+    let x = 2; //~ ERROR unreachable\n+}\n+\n+fn main() {\n+}"}, {"sha": "aae0f3135d8f5a2505b391ada3c8c8bb0deb4d63", "filename": "src/test/compile-fail/match-unreachable-warning-with-diverging-discrim.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-unreachable-warning-with-diverging-discrim.rs?ref=56847af9163284f928d5632a3d0d29399716414f", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_parens)]\n+#![deny(unreachable_code)]\n+\n+fn main() {\n+    match (return) { } //~ ERROR unreachable expression\n+}"}, {"sha": "ea0f8db99e893b57229d80be8f729e35a04142ba", "filename": "src/test/compile-fail/match-unresolved-one-arm.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56847af9163284f928d5632a3d0d29399716414f/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-unresolved-one-arm.rs?ref=56847af9163284f928d5632a3d0d29399716414f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T>() -> T { panic!(\"Rocks for my pillow\") }\n+\n+fn main() {\n+    let x = match () { //~ ERROR type annotations needed\n+        () => foo() // T here should be unresolved\n+    };\n+}"}]}