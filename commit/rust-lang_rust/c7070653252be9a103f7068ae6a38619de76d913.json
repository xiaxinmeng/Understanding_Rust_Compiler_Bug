{"sha": "c7070653252be9a103f7068ae6a38619de76d913", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MDcwNjUzMjUyYmU5YTEwM2Y3MDY4YWU2YTM4NjE5ZGU3NmQ5MTM=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-02T01:58:01Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-17T04:22:05Z"}, "message": "MD5: Create an implementation of MD5.", "tree": {"sha": "84542272e15aeddb4da5c166b7a0b2b21a8a568f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84542272e15aeddb4da5c166b7a0b2b21a8a568f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7070653252be9a103f7068ae6a38619de76d913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7070653252be9a103f7068ae6a38619de76d913", "html_url": "https://github.com/rust-lang/rust/commit/c7070653252be9a103f7068ae6a38619de76d913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7070653252be9a103f7068ae6a38619de76d913/comments", "author": null, "committer": null, "parents": [{"sha": "a37f2844e0acc8c87e4550ebd031bfd1d3dc6c57", "url": "https://api.github.com/repos/rust-lang/rust/commits/a37f2844e0acc8c87e4550ebd031bfd1d3dc6c57", "html_url": "https://github.com/rust-lang/rust/commit/a37f2844e0acc8c87e4550ebd031bfd1d3dc6c57"}], "stats": {"total": 331, "additions": 331, "deletions": 0}, "files": [{"sha": "8e8b752da80754fa47d50d9cf5fe9961deeabc68", "filename": "src/libextra/crypto/md5.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/c7070653252be9a103f7068ae6a38619de76d913/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7070653252be9a103f7068ae6a38619de76d913/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=c7070653252be9a103f7068ae6a38619de76d913", "patch": "@@ -0,0 +1,329 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::uint;\n+\n+use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};\n+use digest::Digest;\n+\n+\n+// A structure that represents that state of a digest computation for the MD5 digest function\n+struct Md5State {\n+    s0: u32,\n+    s1: u32,\n+    s2: u32,\n+    s3: u32\n+}\n+\n+impl Md5State {\n+    fn new() -> Md5State {\n+        return Md5State {\n+            s0: 0x67452301,\n+            s1: 0xefcdab89,\n+            s2: 0x98badcfe,\n+            s3: 0x10325476\n+        };\n+    }\n+\n+    fn reset(&mut self) {\n+        self.s0 = 0x67452301;\n+        self.s1 = 0xefcdab89;\n+        self.s2 = 0x98badcfe;\n+        self.s3 = 0x10325476;\n+    }\n+\n+    fn process_block(&mut self, input: &[u8]) {\n+        fn f(u: u32, v: u32, w: u32) -> u32 {\n+            return (u & v) | (!u & w);\n+        }\n+\n+        fn g(u: u32, v: u32, w: u32) -> u32 {\n+            return (u & w) | (v & !w);\n+        }\n+\n+        fn h(u: u32, v: u32, w: u32) -> u32 {\n+            return u ^ v ^ w;\n+        }\n+\n+        fn i(u: u32, v: u32, w: u32) -> u32 {\n+            return v ^ (u | !w);\n+        }\n+\n+        fn rotate_left(x: u32, n: u32) -> u32 {\n+            return (x << n) | (x >> (32 - n));\n+        }\n+\n+        fn op_f(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + f(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_g(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + g(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_h(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + h(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_i(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + i(x, y, z) + m, s) + x;\n+        }\n+\n+        let mut a = self.s0;\n+        let mut b = self.s1;\n+        let mut c = self.s2;\n+        let mut d = self.s3;\n+\n+        let mut data = [0u32, ..16];\n+\n+        read_u32v_le(data, input);\n+\n+        // round 1\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_f(a, b, c, d, data[i] + C1[i], 7);\n+            d = op_f(d, a, b, c, data[i + 1] + C1[i + 1], 12);\n+            c = op_f(c, d, a, b, data[i + 2] + C1[i + 2], 17);\n+            b = op_f(b, c, d, a, data[i + 3] + C1[i + 3], 22);\n+            true\n+        };\n+\n+        // round 2\n+        let mut t = 1;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_g(a, b, c, d, data[t & 0x0f] + C2[i], 5);\n+            d = op_g(d, a, b, c, data[(t + 5) & 0x0f] + C2[i + 1], 9);\n+            c = op_g(c, d, a, b, data[(t + 10) & 0x0f] + C2[i + 2], 14);\n+            b = op_g(b, c, d, a, data[(t + 15) & 0x0f] + C2[i + 3], 20);\n+            t += 20;\n+            true\n+        };\n+\n+        // round 3\n+        t = 5;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_h(a, b, c, d, data[t & 0x0f] + C3[i], 4);\n+            d = op_h(d, a, b, c, data[(t + 3) & 0x0f] + C3[i + 1], 11);\n+            c = op_h(c, d, a, b, data[(t + 6) & 0x0f] + C3[i + 2], 16);\n+            b = op_h(b, c, d, a, data[(t + 9) & 0x0f] + C3[i + 3], 23);\n+            t += 12;\n+            true\n+        };\n+\n+        // round 4\n+        t = 0;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_i(a, b, c, d, data[t & 0x0f] + C4[i], 6);\n+            d = op_i(d, a, b, c, data[(t + 7) & 0x0f] + C4[i + 1], 10);\n+            c = op_i(c, d, a, b, data[(t + 14) & 0x0f] + C4[i + 2], 15);\n+            b = op_i(b, c, d, a, data[(t + 21) & 0x0f] + C4[i + 3], 21);\n+            t += 28;\n+            true\n+        };\n+\n+        self.s0 += a;\n+        self.s1 += b;\n+        self.s2 += c;\n+        self.s3 += d;\n+    }\n+}\n+\n+// Round 1 constants\n+static C1: [u32, ..16] = [\n+    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n+    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821\n+];\n+\n+// Round 2 constants\n+static C2: [u32, ..16] = [\n+    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n+    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a\n+];\n+\n+// Round 3 constants\n+static C3: [u32, ..16] = [\n+    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n+    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665\n+];\n+\n+// Round 4 constants\n+static C4: [u32, ..16] = [\n+    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n+    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n+];\n+\n+\n+/// The MD5 Digest algorithm\n+struct Md5 {\n+    priv length_bytes: u64,\n+    priv buffer: FixedBuffer64,\n+    priv state: Md5State,\n+    priv finished: bool,\n+}\n+\n+impl Md5 {\n+    /// Construct a new instance of the MD5 Digest.\n+    pub fn new() -> Md5 {\n+        return Md5 {\n+            length_bytes: 0,\n+            buffer: FixedBuffer64::new(),\n+            state: Md5State::new(),\n+            finished: false\n+        }\n+    }\n+}\n+\n+impl Digest for Md5 {\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished);\n+        // Unlike Sha1 and Sha2, the length value in MD5 is defined as the length of the message mod\n+        // 2^64 - ie: integer overflow is OK.\n+        self.length_bytes += input.len() as u64;\n+        self.buffer.input(input, |d: &[u8]| { self.state.process_block(d); });\n+    }\n+\n+    fn reset(&mut self) {\n+        self.length_bytes = 0;\n+        self.buffer.reset();\n+        self.state.reset();\n+        self.finished = false;\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        if !self.finished {\n+            self.buffer.standard_padding(8, |d: &[u8]| { self.state.process_block(d); });\n+            write_u32_le(self.buffer.next(4), (self.length_bytes << 3) as u32);\n+            write_u32_le(self.buffer.next(4), (self.length_bytes >> 29) as u32);\n+            self.state.process_block(self.buffer.full_buffer());\n+            self.finished = true;\n+        }\n+\n+        write_u32_le(out.mut_slice(0, 4), self.state.s0);\n+        write_u32_le(out.mut_slice(4, 8), self.state.s1);\n+        write_u32_le(out.mut_slice(8, 12), self.state.s2);\n+        write_u32_le(out.mut_slice(12, 16), self.state.s3);\n+    }\n+\n+    fn output_bits(&self) -> uint { 128 }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use cryptoutil::test::test_digest_1million_random;\n+    use digest::Digest;\n+    use md5::Md5;\n+\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for t in tests.iter() {\n+            sh.input_str(t.input);\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for t in tests.iter() {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_md5() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"d41d8cd98f00b204e9800998ecf8427e\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"9e107d9d372bb6826bd81d3542a419d6\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"e4d909c290d0fb1ca068ffaddf22cbd0\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = Md5::new();\n+\n+        test_hash(&mut sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_1million_random_md5() {\n+        let mut sh = Md5::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"7707d6ae4e027c70eea2a935c2296f21\");\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+\n+    use md5::Md5;\n+\n+\n+    #[bench]\n+    pub fn md5_10(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn md5_1k(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn md5_64k(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"}, {"sha": "e6fa3adf26f5f13b5b72c6a56ee1259235a09dd4", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7070653252be9a103f7068ae6a38619de76d913/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7070653252be9a103f7068ae6a38619de76d913/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=c7070653252be9a103f7068ae6a38619de76d913", "patch": "@@ -71,6 +71,8 @@ pub mod treemap;\n mod cryptoutil;\n #[path=\"crypto/digest.rs\"]\n pub mod digest;\n+#[path=\"crypto/md5.rs\"]\n+pub mod md5;\n #[path=\"crypto/sha1.rs\"]\n pub mod sha1;\n #[path=\"crypto/sha2.rs\"]"}]}