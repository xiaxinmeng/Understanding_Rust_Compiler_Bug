{"sha": "b11b706545ec986b0416a14383170c60004644a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMWI3MDY1NDVlYzk4NmIwNDE2YTE0MzgzMTcwYzYwMDA0NjQ0YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-03T21:07:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-03T21:07:45Z"}, "message": "auto merge of #18575 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "dca9b3f476907c8c6addc7ec1afb01c789c6d330", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dca9b3f476907c8c6addc7ec1afb01c789c6d330"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b11b706545ec986b0416a14383170c60004644a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b11b706545ec986b0416a14383170c60004644a5", "html_url": "https://github.com/rust-lang/rust/commit/b11b706545ec986b0416a14383170c60004644a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b11b706545ec986b0416a14383170c60004644a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b81c0ebb45d36198fa8a78dcdcb8144e4bb06c", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b81c0ebb45d36198fa8a78dcdcb8144e4bb06c", "html_url": "https://github.com/rust-lang/rust/commit/01b81c0ebb45d36198fa8a78dcdcb8144e4bb06c"}, {"sha": "dce0be03d94360d100825c134892e78c39858ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce0be03d94360d100825c134892e78c39858ef8", "html_url": "https://github.com/rust-lang/rust/commit/dce0be03d94360d100825c134892e78c39858ef8"}], "stats": {"total": 4494, "additions": 2641, "deletions": 1853}, "files": [{"sha": "4128ae9538b6a9a1543a20a84f9f6f0016f8791d", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -287,7 +287,7 @@ The benchmarking runner offers two ways to avoid this. Either, the\n closure that the `iter` method receives can return an arbitrary value\n which forces the optimizer to consider the result used and ensures it\n cannot remove the computation entirely. This could be done for the\n-example above by adjusting the `bh.iter` call to\n+example above by adjusting the `b.iter` call to\n \n ~~~\n # struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;"}, {"sha": "a197115da90a0ec5f81b1c8d91f56bc7c0ce88f9", "filename": "src/doc/intro.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -494,14 +494,14 @@ non-deterministic aspect:\n $ cargo run\n    Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n      Running `target/hello_world`\n-numbers[1] is 2\n-numbers[0] is 1\n-numbers[2] is 3\n+numbers[1] is 3\n+numbers[0] is 2\n+numbers[2] is 4\n $ cargo run\n      Running `target/hello_world`\n-numbers[2] is 3\n-numbers[1] is 2\n-numbers[0] is 1\n+numbers[2] is 4\n+numbers[1] is 3\n+numbers[0] is 2\n ```\n \n Each time, we get a slightly different output, because each thread works in a"}, {"sha": "6f165b679a3ec4b5f30e9373c4ca7d4daf314afb", "filename": "src/doc/reference.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -400,11 +400,11 @@ An _integer literal_ has one of four forms:\n * A _decimal literal_ starts with a *decimal digit* and continues with any\n   mixture of *decimal digits* and _underscores_.\n * A _hex literal_ starts with the character sequence `U+0030` `U+0078`\n-  (`0x`) and continues as any mixture hex digits and underscores.\n+  (`0x`) and continues as any mixture of hex digits and underscores.\n * An _octal literal_ starts with the character sequence `U+0030` `U+006F`\n-  (`0o`) and continues as any mixture octal digits and underscores.\n+  (`0o`) and continues as any mixture of octal digits and underscores.\n * A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n-  (`0b`) and continues as any mixture binary digits and underscores.\n+  (`0b`) and continues as any mixture of binary digits and underscores.\n \n An integer literal may be followed (immediately, without any spaces) by an\n _integer suffix_, which changes the type of the literal. There are two kinds of\n@@ -944,10 +944,10 @@ An example of `use` declarations:\n ```\n use std::iter::range_step;\n use std::option::{Some, None};\n-use std::collections::hashmap::{mod, HashMap};\n+use std::collections::hash_map::{mod, HashMap};\n \n-# fn foo<T>(_: T){}\n-# fn bar(map: HashMap<String, uint>, set: hashmap::HashSet<String>){}\n+fn foo<T>(_: T){}\n+fn bar(map1: HashMap<String, uint>, map2: hash_map::HashMap<String, uint>){}\n \n fn main() {\n     // Equivalent to 'std::iter::range_step(0u, 10u, 2u);'\n@@ -957,10 +957,10 @@ fn main() {\n     // std::option::None]);'\n     foo(vec![Some(1.0f64), None]);\n \n-    // Both `hash` and `HashMap` are in scope.\n-    let map = HashMap::new();\n-    let set = hashmap::HashSet::new();\n-    bar(map, set);\n+    // Both `hash_map` and `HashMap` are in scope.\n+    let map1 = HashMap::new();\n+    let map2 = hash_map::HashMap::new();\n+    bar(map1, map2);\n }\n ```\n \n@@ -2100,15 +2100,15 @@ plugins](guide-plugin.html#lint-plugins) can provide additional lint checks.\n ```{.ignore}\n mod m1 {\n     // Missing documentation is ignored here\n-    #[allow(missing_doc)]\n+    #[allow(missing_docs)]\n     pub fn undocumented_one() -> int { 1 }\n \n     // Missing documentation signals a warning here\n-    #[warn(missing_doc)]\n+    #[warn(missing_docs)]\n     pub fn undocumented_too() -> int { 2 }\n \n     // Missing documentation signals an error here\n-    #[deny(missing_doc)]\n+    #[deny(missing_docs)]\n     pub fn undocumented_end() -> int { 3 }\n }\n ```\n@@ -2117,16 +2117,16 @@ This example shows how one can use `allow` and `warn` to toggle a particular\n check on and off.\n \n ```{.ignore}\n-#[warn(missing_doc)]\n+#[warn(missing_docs)]\n mod m2{\n-    #[allow(missing_doc)]\n+    #[allow(missing_docs)]\n     mod nested {\n         // Missing documentation is ignored here\n         pub fn undocumented_one() -> int { 1 }\n \n         // Missing documentation signals a warning here,\n         // despite the allow above.\n-        #[warn(missing_doc)]\n+        #[warn(missing_docs)]\n         pub fn undocumented_two() -> int { 2 }\n     }\n \n@@ -2139,10 +2139,10 @@ This example shows how one can use `forbid` to disallow uses of `allow` for\n that lint check.\n \n ```{.ignore}\n-#[forbid(missing_doc)]\n+#[forbid(missing_docs)]\n mod m3 {\n     // Attempting to toggle warning signals an error here\n-    #[allow(missing_doc)]\n+    #[allow(missing_docs)]\n     /// Returns 2.\n     pub fn undocumented_too() -> int { 2 }\n }\n@@ -4096,7 +4096,7 @@ cause transitions between the states. The lifecycle states of a task are:\n \n * running\n * blocked\n-* panicked \n+* panicked\n * dead\n \n A task begins its lifecycle &mdash; once it has been spawned &mdash; in the"}, {"sha": "9656d17721e47ca704def34156eb85f95d7ba69b", "filename": "src/doc/rust.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -62,6 +62,10 @@ body {\n     font-size: 18px;\n     color: #333;\n     line-height: 1.428571429;\n+\n+    -webkit-font-feature-settings: \"kern\", \"liga\";\n+    -moz-font-feature-settings: \"kern\", \"liga\";\n+    font-feature-settings: \"kern\", \"liga\";\n }\n @media (min-width: 768px) {\n     body {"}, {"sha": "4cb64b781af749deac5526642e755f8c4659d132", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -34,7 +34,7 @@\n \n // NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n-#![allow(missing_doc, non_uppercase_statics, non_snake_case)]\n+#![allow(missing_docs, non_uppercase_statics, non_snake_case)]\n '''\n \n # Mapping taken from Table 12 from:"}, {"sha": "8481111ae91a3cecdbf95801a482e23a3dccf05e", "filename": "src/libcollections/binary_heap.rs", "status": "renamed", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -19,14 +19,14 @@\n //!\n //! This is a larger example which implements [Dijkstra's algorithm][dijkstra]\n //! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n-//! It showcases how to use the `PriorityQueue` with custom types.\n+//! It showcases how to use the `BinaryHeap` with custom types.\n //!\n //! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n //! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n //! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n //!\n //! ```\n-//! use std::collections::PriorityQueue;\n+//! use std::collections::BinaryHeap;\n //! use std::uint;\n //!\n //! #[deriving(Eq, PartialEq)]\n@@ -68,7 +68,7 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = PriorityQueue::new();\n+//!     let mut pq = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n@@ -166,52 +166,52 @@ use vec::Vec;\n ///\n /// This will be a max-heap.\n #[deriving(Clone)]\n-pub struct PriorityQueue<T> {\n+pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }\n \n-impl<T: Ord> Default for PriorityQueue<T> {\n+impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n-    fn default() -> PriorityQueue<T> { PriorityQueue::new() }\n+    fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n }\n \n-impl<T: Ord> PriorityQueue<T> {\n-    /// Creates an empty `PriorityQueue` as a max-heap.\n+impl<T: Ord> BinaryHeap<T> {\n+    /// Creates an empty `BinaryHeap` as a max-heap.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// use std::collections::BinaryHeap;\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n-    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n+    pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n \n-    /// Creates an empty `PriorityQueue` with a specific capacity.\n+    /// Creates an empty `BinaryHeap` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n-    /// so that the `PriorityQueue` does not have to be reallocated\n+    /// so that the `BinaryHeap` does not have to be reallocated\n     /// until it contains at least that many values.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(10u);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n-    pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n-        PriorityQueue { data: Vec::with_capacity(capacity) }\n+    pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n+        BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Creates a `PriorityQueue` from a vector. This is sometimes called\n+    /// Creates a `BinaryHeap` from a vector. This is sometimes called\n     /// `heapifying` the vector.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq = PriorityQueue::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n-    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n-        let mut q = PriorityQueue{data: xs,};\n+    pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n+        let mut q = BinaryHeap{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {\n             n -= 1;\n@@ -226,8 +226,8 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n-    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4]);\n+    /// use std::collections::BinaryHeap;\n+    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in pq.iter() {\n@@ -243,9 +243,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// assert_eq!(pq.top(), None);\n     ///\n     /// pq.push(1i);\n@@ -263,36 +263,36 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(100u);\n+    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserves capacity for exactly `n` elements in the `PriorityQueue`.\n+    /// Reserves capacity for exactly `n` elements in the `BinaryHeap`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve_exact(100u);\n     /// assert!(pq.capacity() == 100u);\n     /// ```\n     pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n \n-    /// Reserves capacity for at least `n` elements in the `PriorityQueue`.\n+    /// Reserves capacity for at least `n` elements in the `BinaryHeap`.\n     /// Do nothing if the capacity is already sufficient.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n@@ -306,9 +306,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::from_vec(vec![1i, 3]);\n+    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n     /// assert_eq!(pq.pop(), Some(3i));\n     /// assert_eq!(pq.pop(), Some(1i));\n@@ -332,9 +332,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// pq.push(3i);\n     /// pq.push(5i);\n     /// pq.push(1i);\n@@ -354,9 +354,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     /// pq.push(1i);\n     /// pq.push(5i);\n     ///\n@@ -380,9 +380,9 @@ impl<T: Ord> PriorityQueue<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::new();\n+    /// let mut pq = BinaryHeap::new();\n     ///\n     /// assert_eq!(pq.replace(1i), None);\n     /// assert_eq!(pq.replace(3i), Some(1i));\n@@ -400,33 +400,33 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    /// Consumes the `PriorityQueue` and returns the underlying vector\n+    /// Consumes the `BinaryHeap` and returns the underlying vector\n     /// in arbitrary order.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// let vec = pq.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n-    pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n+    pub fn into_vec(self) -> Vec<T> { let BinaryHeap{data: v} = self; v }\n \n-    /// Consumes the `PriorityQueue` and returns a vector in sorted\n+    /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::PriorityQueue;\n+    /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = PriorityQueue::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n     /// pq.push(6);\n     /// pq.push(3);\n     ///\n@@ -504,7 +504,7 @@ impl<T: Ord> PriorityQueue<T> {\n     pub fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-/// `PriorityQueue` iterator.\n+/// `BinaryHeap` iterator.\n pub struct Items <'a, T:'a> {\n     iter: slice::Items<'a, T>,\n }\n@@ -517,14 +517,14 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T: Ord> FromIterator<T> for PriorityQueue<T> {\n-    fn from_iter<Iter: Iterator<T>>(mut iter: Iter) -> PriorityQueue<T> {\n+impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n+    fn from_iter<Iter: Iterator<T>>(mut iter: Iter) -> BinaryHeap<T> {\n         let vec: Vec<T> = iter.collect();\n-        PriorityQueue::from_vec(vec)\n+        BinaryHeap::from_vec(vec)\n     }\n }\n \n-impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n+impl<T: Ord> Extendable<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n@@ -541,14 +541,14 @@ impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n mod tests {\n     use std::prelude::*;\n \n-    use priority_queue::PriorityQueue;\n+    use super::BinaryHeap;\n     use vec::Vec;\n \n     #[test]\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = PriorityQueue::from_vec(data);\n+        let pq = BinaryHeap::from_vec(data);\n         let mut i = 0;\n         for el in pq.iter() {\n             assert_eq!(*el, iterout[i]);\n@@ -561,7 +561,7 @@ mod tests {\n         let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n         let mut sorted = data.clone();\n         sorted.sort();\n-        let mut heap = PriorityQueue::from_vec(data);\n+        let mut heap = BinaryHeap::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n             assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n@@ -570,7 +570,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = PriorityQueue::from_vec(vec!(2i, 4, 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(2i, 4, 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == 9);\n         heap.push(11);\n@@ -592,7 +592,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = PriorityQueue::from_vec(vec!(box 2i, box 4, box 9));\n+        let mut heap = BinaryHeap::from_vec(vec!(box 2i, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top().unwrap() == box 9);\n         heap.push(box 11);\n@@ -614,7 +614,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -628,7 +628,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = PriorityQueue::from_vec(vec!(5i, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec!(5i, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -641,7 +641,7 @@ mod tests {\n     }\n \n     fn check_to_vec(mut data: Vec<int>) {\n-        let heap = PriorityQueue::from_vec(data.clone());\n+        let heap = BinaryHeap::from_vec(data.clone());\n         let mut v = heap.clone().into_vec();\n         v.sort();\n         data.sort();\n@@ -669,27 +669,27 @@ mod tests {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n     fn test_empty_top() {\n-        let empty: PriorityQueue<int> = PriorityQueue::new();\n+        let empty: BinaryHeap<int> = BinaryHeap::new();\n         assert!(empty.top().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        let mut heap: BinaryHeap<int> = BinaryHeap::new();\n         heap.replace(5).is_none();\n     }\n \n     #[test]\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop().unwrap(), x);", "previous_filename": "src/libcollections/priority_queue.rs"}, {"sha": "b7085c96aed154f276abf9a1b7817b7d548c7621", "filename": "src/libcollections/bit.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for maintenance),\n+// they should be in separate files/modules, with BitvSet only using Bitv's public API.\n+\n //! Collections implemented with bit vectors.\n //!\n //! # Example\n@@ -1654,7 +1657,7 @@ mod tests {\n     use std::rand::Rng;\n     use test::Bencher;\n \n-    use bitv::{Bitv, BitvSet, from_fn, from_bytes};\n+    use super::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;\n ", "previous_filename": "src/libcollections/bitv.rs"}, {"sha": "e3dfabfa29549d53499e678f7d5aaf133ef590e1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -23,7 +23,7 @@ use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n \n-use ringbuf::RingBuf;\n+use ring_buf::RingBuf;\n \n /// A map based on a B-Tree.\n ///"}, {"sha": "282128099da0a3d2021140f43839bcbb17356fd4", "filename": "src/libcollections/btree/mod.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -8,27 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::map::BTreeMap;\n-pub use self::map::Entries;\n-pub use self::map::MutEntries;\n-pub use self::map::MoveEntries;\n-pub use self::map::Keys;\n-pub use self::map::Values;\n-pub use self::map::Entry;\n-pub use self::map::Occupied;\n-pub use self::map::Vacant;\n-pub use self::map::OccupiedEntry;\n-pub use self::map::VacantEntry;\n-\n-pub use self::set::BTreeSet;\n-pub use self::set::Items;\n-pub use self::set::MoveItems;\n-pub use self::set::DifferenceItems;\n-pub use self::set::UnionItems;\n-pub use self::set::SymDifferenceItems;\n-pub use self::set::IntersectionItems;\n-\n-\n mod node;\n-mod map;\n-mod set;\n+pub mod map;\n+pub mod set;"}, {"sha": "27752207b9797d93ce92e15498c6a93f40a128cb", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -13,7 +13,7 @@\n \n use core::prelude::*;\n \n-use super::{BTreeMap, Keys, MoveEntries};\n+use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n use core::default::Default;\n use core::{iter, fmt};"}, {"sha": "bcae4fe68c9b87bd3ee514e72ed06fbbf71392b7", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -155,7 +155,7 @@ mod test {\n     use std::prelude::*;\n     use std::mem;\n \n-    use enum_set::{EnumSet, CLike};\n+    use super::{EnumSet, CLike};\n \n     #[deriving(PartialEq, Show)]\n     #[repr(uint)]"}, {"sha": "5ec8a85fb0fb771e227e5a8249859bb986aa5120", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -37,34 +37,72 @@ extern crate alloc;\n #[cfg(test)] #[phase(plugin, link)] extern crate std;\n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-pub use bitv::{Bitv, BitvSet};\n-pub use btree::{BTreeMap, BTreeSet};\n+\n+pub use binary_heap::BinaryHeap;\n+pub use bitv::Bitv;\n+pub use bitv_set::BitvSet;\n+pub use btree_map::BTreeMap;\n+pub use btree_set::BTreeSet;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n-pub use priority_queue::PriorityQueue;\n-pub use ringbuf::RingBuf;\n-pub use smallintmap::SmallIntMap;\n+pub use ring_buf::RingBuf;\n pub use string::String;\n-pub use treemap::{TreeMap, TreeSet};\n-pub use trie::{TrieMap, TrieSet};\n+pub use tree_map::TreeMap;\n+pub use tree_set::TreeSet;\n+pub use trie_map::TrieMap;\n+pub use trie_set::TrieSet;\n pub use vec::Vec;\n+pub use vec_map::VecMap;\n \n mod macros;\n \n-pub mod bitv;\n-pub mod btree;\n+pub mod binary_heap;\n+mod bit;\n+mod btree;\n pub mod dlist;\n pub mod enum_set;\n-pub mod priority_queue;\n-pub mod ringbuf;\n-pub mod smallintmap;\n-pub mod treemap;\n-pub mod trie;\n+pub mod ring_buf;\n+mod tree;\n+mod trie;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n pub mod hash;\n+pub mod vec_map;\n+\n+pub mod bitv {\n+    pub use bit::{Bitv, Bits, from_fn, from_bytes};\n+}\n+\n+pub mod bitv_set {\n+    pub use bit::{BitvSet, BitPositions, TwoBitPositions};\n+}\n+\n+pub mod tree_map {\n+    pub use tree::map::*;\n+}\n+\n+pub mod tree_set {\n+    pub use tree::set::*;\n+}\n+\n+pub mod trie_map {\n+    pub use trie::map::*;\n+}\n+\n+pub mod trie_set {\n+    pub use trie::set::*;\n+}\n+\n+pub mod btree_map {\n+    pub use btree::map::*;\n+}\n+\n+pub mod btree_set {\n+    pub use btree::set::*;\n+}\n+\n \n #[cfg(test)] mod bench;\n "}, {"sha": "3c4c3fce61d774835fb0b482c1763ca4fe6b9699", "filename": "src/libcollections/ring_buf.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "previous_filename": "src/libcollections/ringbuf.rs"}, {"sha": "62182575c6d165ffa7c8a7fb621166dbd012f0a2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -62,7 +62,7 @@ use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n use core::prelude::{range};\n \n use hash;\n-use ringbuf::RingBuf;\n+use ring_buf::RingBuf;\n use string::String;\n use unicode;\n use vec::Vec;"}, {"sha": "9742bddb1f6594f0c971dbe22c2d1049d5778d25", "filename": "src/libcollections/tree/map.rs", "status": "renamed", "additions": 21, "deletions": 970, "changes": 991, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -8,37 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Maps are collections of unique keys with corresponding values, and sets are\n-//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n-//! `std::container` define the basic interface.\n-//!\n-//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n-//!\n-//! `TreeMap`s are ordered.\n-//!\n-//! ## Example\n-//!\n-//! ```{rust}\n-//! use std::collections::TreeSet;\n-//!\n-//! let mut tree_set = TreeSet::new();\n-//!\n-//! tree_set.insert(2i);\n-//! tree_set.insert(1i);\n-//! tree_set.insert(3i);\n-//!\n-//! for i in tree_set.iter() {\n-//!    println!(\"{}\", i) // prints 1, then 2, then 3\n-//! }\n-//! ```\n-\n use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n-use core::iter::Peekable;\n use core::iter;\n use core::mem::{replace, swap};\n use core::ptr;\n@@ -378,7 +353,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Gets a lazy iterator that consumes the treemap.\n+    /// Gets a lazy iterator that consumes the TreeMap.\n     ///\n     /// # Example\n     ///\n@@ -592,7 +567,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use collections::treemap::TreeMap;\n+    /// use std::collections::TreeMap;\n     ///\n     /// fn get_headers() -> TreeMap<String, String> {\n     ///     let mut result = TreeMap::new();\n@@ -621,7 +596,9 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut t = collections::treemap::TreeMap::new();\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut t = TreeMap::new();\n     /// t.insert(\"Content-Type\", \"application/xml\");\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n@@ -1075,616 +1052,6 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n \n }\n \n-impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a T> {\n-        self.iter.next().map(|(value, _)| value)\n-    }\n-}\n-\n-/// An implementation of the `Set` trait on top of the `TreeMap` container. The\n-/// only requirement is that the type of the elements contained ascribes to the\n-/// `Ord` trait.\n-///\n-/// ## Example\n-///\n-/// ```{rust}\n-/// use std::collections::TreeSet;\n-///\n-/// let mut set = TreeSet::new();\n-///\n-/// set.insert(2i);\n-/// set.insert(1i);\n-/// set.insert(3i);\n-///\n-/// for i in set.iter() {\n-///    println!(\"{}\", i) // prints 1, then 2, then 3\n-/// }\n-///\n-/// set.remove(&3);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"set does not contain a 3 anymore\");\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n-/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n-///\n-/// ```\n-/// use std::collections::TreeSet;\n-///\n-/// // We need `Eq` and `PartialEq`, these can be derived.\n-/// #[deriving(Eq, PartialEq)]\n-/// struct Troll<'a> {\n-///     name: &'a str,\n-///     level: uint,\n-/// }\n-///\n-/// // Implement `Ord` and sort trolls by level.\n-/// impl<'a> Ord for Troll<'a> {\n-///     fn cmp(&self, other: &Troll) -> Ordering {\n-///         // If we swap `self` and `other`, we get descending ordering.\n-///         self.level.cmp(&other.level)\n-///     }\n-/// }\n-///\n-/// // `PartialOrd` needs to be implemented as well.\n-/// impl<'a> PartialOrd for Troll<'a> {\n-///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n-///         Some(self.cmp(other))\n-///     }\n-/// }\n-///\n-/// let mut trolls = TreeSet::new();\n-///\n-/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n-/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n-/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n-/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n-///\n-/// println!(\"You are facing {} trolls!\", trolls.len());\n-///\n-/// // Print the trolls, ordered by level with smallest level first\n-/// for x in trolls.iter() {\n-///     println!(\"level {}: {}!\", x.level, x.name);\n-/// }\n-///\n-/// // Kill all trolls\n-/// trolls.clear();\n-/// assert_eq!(trolls.len(), 0);\n-/// ```\n-#[deriving(Clone)]\n-pub struct TreeSet<T> {\n-    map: TreeMap<T, ()>\n-}\n-\n-impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n-    #[inline]\n-    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n-}\n-\n-impl<T: Eq + Ord> Eq for TreeSet<T> {}\n-\n-impl<T: Ord> PartialOrd for TreeSet<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n-        self.map.partial_cmp(&other.map)\n-    }\n-}\n-\n-impl<T: Ord> Ord for TreeSet<T> {\n-    #[inline]\n-    fn cmp(&self, other: &TreeSet<T>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-impl<T: Ord + Show> Show for TreeSet<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", *x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-impl<T: Ord> Default for TreeSet<T> {\n-    #[inline]\n-    fn default() -> TreeSet<T> { TreeSet::new() }\n-}\n-\n-impl<T: Ord> TreeSet<T> {\n-    /// Creates an empty `TreeSet`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    /// ```\n-    #[inline]\n-    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Gets a lazy iterator over the values in the set, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in ascending order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets a lazy iterator over the values in the set, in descending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Will print in descending order.\n-    /// for x in set.rev_iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n-        RevSetItems{iter: self.map.rev_iter()}\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out of the\n-    /// set in ascending order. The set cannot be used after calling this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n-    ///\n-    /// // Not possible with a regular `.iter()`\n-    /// let v: Vec<int> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n-    /// ```\n-    #[inline]\n-    pub fn into_iter(self) -> MoveSetItems<T> {\n-        self.map.into_iter().map(|(value, _)| value)\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n-    /// If all elements in the set are less than `v` empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n-    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.lower_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.lower_bound(v)}\n-    }\n-\n-    /// Gets a lazy iterator pointing to the first value greater than `v`.\n-    /// If all elements in the set are less than or equal to `v` an\n-    /// empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n-    /// assert_eq!(set.upper_bound(&10).next(), None);\n-    /// ```\n-    #[inline]\n-    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n-        SetItems{iter: self.map.upper_bound(v)}\n-    }\n-\n-    /// Visits the values representing the difference, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1 then 2\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n-        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the symmetric difference, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 4, 5 in ascending order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> SymDifferenceItems<'a, T> {\n-        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the intersection, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in ascending order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n-        -> IntersectionItems<'a, T> {\n-        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Visits the values representing the union, in ascending order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4, 5 in ascending order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n-    /// ```\n-    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n-        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1i);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1i);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let mut v = TreeSet::new();\n-    /// v.insert(1i);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, value: &T) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        self.intersection(other).next().is_none()\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n-\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n-\n-            b = y.next();\n-        }\n-        true\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeSet;\n-    ///\n-    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TreeSet<int> = TreeSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let mut set = BTreeSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let mut set = BTreeSet::new();\n-    ///\n-    /// set.insert(2i);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-/// A lazy forward iterator over a set.\n-pub struct SetItems<'a, T:'a> {\n-    iter: Entries<'a, T, ()>\n-}\n-\n-/// A lazy backward iterator over a set.\n-pub struct RevSetItems<'a, T:'a> {\n-    iter: RevEntries<'a, T, ()>\n-}\n-\n-/// A lazy forward iterator over a set that consumes the set while iterating.\n-pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n-\n-/// A lazy iterator producing elements in the set difference (in-order).\n-pub struct DifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set symmetric difference (in-order).\n-pub struct SymDifferenceItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set intersection (in-order).\n-pub struct IntersectionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// A lazy iterator producing elements in the set union (in-order).\n-pub struct UnionItems<'a, T:'a> {\n-    a: Peekable<&'a T, SetItems<'a, T>>,\n-    b: Peekable<&'a T, SetItems<'a, T>>,\n-}\n-\n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n-                        short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n-                Greater => return self.b.next(),\n-            }\n-        }\n-    }\n-}\n \n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -1908,30 +1275,6 @@ impl<S: Writer, K: Ord + Hash<S>, V: Hash<S>> Hash<S> for TreeMap<K, V> {\n     }\n }\n \n-impl<T: Ord> FromIterator<T> for TreeSet<T> {\n-    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n-        let mut set = TreeSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl<T: Ord> Extendable<T> for TreeSet<T> {\n-    #[inline]\n-    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n-impl<S: Writer, T: Ord + Hash<S>> Hash<S> for TreeSet<T> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n \n #[cfg(test)]\n mod test_treemap {\n@@ -2448,6 +1791,22 @@ mod test_treemap {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_swap() {\n+        let mut m = TreeMap::new();\n+        assert_eq!(m.swap(1u, 2i), None);\n+        assert_eq!(m.swap(1u, 3i), Some(2));\n+        assert_eq!(m.swap(1u, 4i), Some(3));\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = TreeMap::new();\n+        m.insert(1u, 2i);\n+        assert_eq!(m.pop(&1), Some(2));\n+        assert_eq!(m.pop(&1), None);\n+    }\n }\n \n #[cfg(test)]\n@@ -2557,311 +1916,3 @@ mod bench {\n     }\n }\n \n-#[cfg(test)]\n-mod test_set {\n-    use std::prelude::*;\n-    use std::hash;\n-\n-    use super::{TreeMap, TreeSet};\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut s = TreeSet::new();\n-        s.clear();\n-        assert!(s.insert(5i));\n-        assert!(s.insert(12));\n-        assert!(s.insert(19));\n-        s.clear();\n-        assert!(!s.contains(&5));\n-        assert!(!s.contains(&12));\n-        assert!(!s.contains(&19));\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = TreeSet::new();\n-        let mut ys = TreeSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5i));\n-        assert!(ys.insert(11i));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = TreeSet::new();\n-        assert!(a.insert(0i));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = TreeSet::new();\n-        assert!(b.insert(0i));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterator() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 0;\n-        for x in m.iter() {\n-            assert_eq!(*x, n);\n-            n += 1\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rev_iter() {\n-        let mut m = TreeSet::new();\n-\n-        assert!(m.insert(3i));\n-        assert!(m.insert(0));\n-        assert!(m.insert(4));\n-        assert!(m.insert(2));\n-        assert!(m.insert(1));\n-\n-        let mut n = 4;\n-        for x in m.rev_iter() {\n-            assert_eq!(*x, n);\n-            n -= 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let s: TreeSet<int> = range(0i, 5).collect();\n-\n-        let mut n = 0;\n-        for x in s.into_iter() {\n-            assert_eq!(x, n);\n-            n += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter_size_hint() {\n-        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n-\n-        let mut it = s.into_iter();\n-\n-        assert_eq!(it.size_hint(), (2, Some(2)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert!(it.next() != None);\n-\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_clone_eq() {\n-      let mut m = TreeSet::new();\n-\n-      m.insert(1i);\n-      m.insert(2);\n-\n-      assert!(m.clone() == m);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-      let mut x = TreeSet::new();\n-      let mut y = TreeSet::new();\n-\n-      x.insert(1i);\n-      x.insert(2);\n-      x.insert(3);\n-\n-      y.insert(3i);\n-      y.insert(2);\n-      y.insert(1);\n-\n-      assert!(hash::hash(&x) == hash::hash(&y));\n-    }\n-\n-    fn check(a: &[int],\n-             b: &[int],\n-             expected: &[int],\n-             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n-        let mut set_a = TreeSet::new();\n-        let mut set_b = TreeSet::new();\n-\n-        for x in a.iter() { assert!(set_a.insert(*x)) }\n-        for y in b.iter() { assert!(set_b.insert(*y)) }\n-\n-        let mut i = 0;\n-        f(&set_a, &set_b, |x| {\n-            assert_eq!(*x, expected[i]);\n-            i += 1;\n-            true\n-        });\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n-        }\n-\n-        check_intersection([], [], []);\n-        check_intersection([1, 2, 3], [], []);\n-        check_intersection([], [1, 2, 3], []);\n-        check_intersection([2], [1, 2, 3], [2]);\n-        check_intersection([1, 2, 3], [2], [2]);\n-        check_intersection([11, 1, 3, 77, 103, 5, -5],\n-                           [2, 11, 77, -9, -42, 5, 3],\n-                           [3, 5, 11, 77]);\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n-        }\n-\n-        check_difference([], [], []);\n-        check_difference([1, 12], [], [1, 12]);\n-        check_difference([], [1, 2, 3, 9], []);\n-        check_difference([1, 3, 5, 9, 11],\n-                         [3, 9],\n-                         [1, 5, 11]);\n-        check_difference([-5, 11, 22, 33, 40, 42],\n-                         [-12, -5, 14, 23, 34, 38, 39, 50],\n-                         [11, 22, 33, 40, 42]);\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n-        }\n-\n-        check_symmetric_difference([], [], []);\n-        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n-        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n-        check_symmetric_difference([1, 3, 5, 9, 11],\n-                                   [-2, 3, 9, 14, 22],\n-                                   [-2, 1, 5, 11, 14, 22]);\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        fn check_union(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n-            check(a, b, expected, |x, y, f| x.union(y).all(f))\n-        }\n-\n-        check_union([], [], []);\n-        check_union([1, 2, 3], [2], [1, 2, 3]);\n-        check_union([2], [1, 2, 3], [1, 2, 3]);\n-        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n-                    [-2, 1, 5, 9, 13, 19],\n-                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n-    }\n-\n-    #[test]\n-    fn test_zip() {\n-        let mut x = TreeSet::new();\n-        x.insert(5u);\n-        x.insert(12u);\n-        x.insert(11u);\n-\n-        let mut y = TreeSet::new();\n-        y.insert(\"foo\");\n-        y.insert(\"bar\");\n-\n-        let x = x;\n-        let y = y;\n-        let mut z = x.iter().zip(y.iter());\n-\n-        // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n-\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert!(result.is_none());\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut m = TreeMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = TreeMap::new();\n-        m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set: TreeSet<int> = TreeSet::new();\n-        let empty: TreeSet<int> = TreeSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n-    }\n-}", "previous_filename": "src/libcollections/treemap.rs"}, {"sha": "ac8279c92feeb8f3f73cef427ff69b2eba3a17e3", "filename": "src/libcollections/tree/mod.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines the `TreeMap` and `TreeSet` types. Their keys must implement `Ord`.\n+//!\n+//! `TreeMap`s are ordered.\n+//!\n+//! ## Example\n+//!\n+//! ```{rust}\n+//! use std::collections::TreeSet;\n+//!\n+//! let mut tree_set = TreeSet::new();\n+//!\n+//! tree_set.insert(2i);\n+//! tree_set.insert(1i);\n+//! tree_set.insert(3i);\n+//!\n+//! for i in tree_set.iter() {\n+//!    println!(\"{}\", i) // prints 1, then 2, then 3\n+//! }\n+//! ```\n+\n+pub mod map;\n+pub mod set;\n\\ No newline at end of file"}, {"sha": "d24a8234b20b8d3a53b76dd28237cf7e557fc418", "filename": "src/libcollections/tree/set.rs", "status": "added", "additions": 950, "deletions": 0, "changes": 950, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,950 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::default::Default;\n+use core::fmt;\n+use core::fmt::Show;\n+use core::iter::Peekable;\n+use core::iter;\n+use std::hash::{Writer, Hash};\n+\n+use tree_map::{TreeMap, Entries, RevEntries, MoveEntries};\n+\n+/// An implementation of the `Set` trait on top of the `TreeMap` container. The\n+/// only requirement is that the type of the elements contained ascribes to the\n+/// `Ord` trait.\n+///\n+/// ## Example\n+///\n+/// ```{rust}\n+/// use std::collections::TreeSet;\n+///\n+/// let mut set = TreeSet::new();\n+///\n+/// set.insert(2i);\n+/// set.insert(1i);\n+/// set.insert(3i);\n+///\n+/// for i in set.iter() {\n+///    println!(\"{}\", i) // prints 1, then 2, then 3\n+/// }\n+///\n+/// set.remove(&3);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"set does not contain a 3 anymore\");\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeSet;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descending ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// let mut trolls = TreeSet::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for x in trolls.iter() {\n+///     println!(\"level {}: {}!\", x.level, x.name);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n+/// ```\n+#[deriving(Clone)]\n+pub struct TreeSet<T> {\n+    map: TreeMap<T, ()>\n+}\n+\n+impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n+    #[inline]\n+    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n+}\n+\n+impl<T: Eq + Ord> Eq for TreeSet<T> {}\n+\n+impl<T: Ord> PartialOrd for TreeSet<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n+        self.map.partial_cmp(&other.map)\n+    }\n+}\n+\n+impl<T: Ord> Ord for TreeSet<T> {\n+    #[inline]\n+    fn cmp(&self, other: &TreeSet<T>) -> Ordering {\n+        iter::order::cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+impl<T: Ord + Show> Show for TreeSet<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl<T: Ord> Default for TreeSet<T> {\n+    #[inline]\n+    fn default() -> TreeSet<T> { TreeSet::new() }\n+}\n+\n+impl<T: Ord> TreeSet<T> {\n+    /// Creates an empty `TreeSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    /// ```\n+    #[inline]\n+    pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Gets a lazy iterator over the values in the set, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in ascending order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.iter()}\n+    }\n+\n+    /// Gets a lazy iterator over the values in the set, in descending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in descending order.\n+    /// for x in set.rev_iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n+        RevSetItems{iter: self.map.rev_iter()}\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each value out of the\n+    /// set in ascending order. The set cannot be used after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let v: Vec<int> = set.into_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+    /// ```\n+    #[inline]\n+    pub fn into_iter(self) -> MoveSetItems<T> {\n+        self.map.into_iter().map(|(value, _)| value)\n+    }\n+\n+    /// Gets a lazy iterator pointing to the first value not less than `v` (greater or equal).\n+    /// If all elements in the set are less than `v` empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n+    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.lower_bound(&10).next(), None);\n+    /// ```\n+    #[inline]\n+    pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.lower_bound(v)}\n+    }\n+\n+    /// Gets a lazy iterator pointing to the first value greater than `v`.\n+    /// If all elements in the set are less than or equal to `v` an\n+    /// empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&10).next(), None);\n+    /// ```\n+    #[inline]\n+    pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n+        SetItems{iter: self.map.upper_bound(v)}\n+    }\n+\n+    /// Visits the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n+        DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> SymDifferenceItems<'a, T> {\n+        SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> IntersectionItems<'a, T> {\n+        IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Visits the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n+        UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n+    }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1i);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1i);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let mut v = TreeSet::new();\n+    /// v.insert(1i);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let set: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &T) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+        self.intersection(other).next().is_none()\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sup: TreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+        let mut x = self.iter();\n+        let mut y = other.iter();\n+        let mut a = x.next();\n+        let mut b = y.next();\n+        while a.is_some() {\n+            if b.is_none() {\n+                return false;\n+            }\n+\n+            let a1 = a.unwrap();\n+            let b1 = b.unwrap();\n+\n+            match b1.cmp(a1) {\n+                Less => (),\n+                Greater => return false,\n+                Equal => a = x.next(),\n+            }\n+\n+            b = y.next();\n+        }\n+        true\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let sub: TreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2i), true);\n+    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(2i);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+/// A lazy forward iterator over a set.\n+pub struct SetItems<'a, T:'a> {\n+    iter: Entries<'a, T, ()>\n+}\n+\n+/// A lazy backward iterator over a set.\n+pub struct RevSetItems<'a, T:'a> {\n+    iter: RevEntries<'a, T, ()>\n+}\n+\n+/// A lazy forward iterator over a set that consumes the set while iterating.\n+pub type MoveSetItems<T> = iter::Map<'static, (T, ()), T, MoveEntries<T, ()>>;\n+\n+/// A lazy iterator producing elements in the set difference (in-order).\n+pub struct DifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set symmetric difference (in-order).\n+pub struct SymDifferenceItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set intersection (in-order).\n+pub struct IntersectionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// A lazy iterator producing elements in the set union (in-order).\n+pub struct UnionItems<'a, T:'a> {\n+    a: Peekable<&'a T, SetItems<'a, T>>,\n+    b: Peekable<&'a T, SetItems<'a, T>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n+                        short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n+}\n+\n+\n+impl<'a, T> Iterator<&'a T> for SetItems<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next().map(|(value, _)| value)\n+    }\n+}\n+\n+impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next().map(|(value, _)| value)\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for DifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for SymDifferenceItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for IntersectionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T: Ord> Iterator<&'a T> for UnionItems<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Ord> FromIterator<T> for TreeSet<T> {\n+    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> TreeSet<T> {\n+        let mut set = TreeSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T: Ord> Extendable<T> for TreeSet<T> {\n+    #[inline]\n+    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n+        for elem in iter {\n+            self.insert(elem);\n+        }\n+    }\n+}\n+\n+impl<S: Writer, T: Ord + Hash<S>> Hash<S> for TreeSet<T> {\n+    fn hash(&self, state: &mut S) {\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use std::hash;\n+\n+    use super::TreeSet;\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut s = TreeSet::new();\n+        s.clear();\n+        assert!(s.insert(5i));\n+        assert!(s.insert(12));\n+        assert!(s.insert(19));\n+        s.clear();\n+        assert!(!s.contains(&5));\n+        assert!(!s.contains(&12));\n+        assert!(!s.contains(&19));\n+        assert!(s.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = TreeSet::new();\n+        let mut ys = TreeSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5i));\n+        assert!(ys.insert(11i));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = TreeSet::new();\n+        assert!(a.insert(0i));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = TreeSet::new();\n+        assert!(b.insert(0i));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut m = TreeSet::new();\n+\n+        assert!(m.insert(3i));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n+\n+        let mut n = 0;\n+        for x in m.iter() {\n+            assert_eq!(*x, n);\n+            n += 1\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rev_iter() {\n+        let mut m = TreeSet::new();\n+\n+        assert!(m.insert(3i));\n+        assert!(m.insert(0));\n+        assert!(m.insert(4));\n+        assert!(m.insert(2));\n+        assert!(m.insert(1));\n+\n+        let mut n = 4;\n+        for x in m.rev_iter() {\n+            assert_eq!(*x, n);\n+            n -= 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let s: TreeSet<int> = range(0i, 5).collect();\n+\n+        let mut n = 0;\n+        for x in s.into_iter() {\n+            assert_eq!(x, n);\n+            n += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter_size_hint() {\n+        let s: TreeSet<int> = vec!(0i, 1).into_iter().collect();\n+\n+        let mut it = s.into_iter();\n+\n+        assert_eq!(it.size_hint(), (2, Some(2)));\n+        assert!(it.next() != None);\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert!(it.next() != None);\n+\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_clone_eq() {\n+      let mut m = TreeSet::new();\n+\n+      m.insert(1i);\n+      m.insert(2);\n+\n+      assert!(m.clone() == m);\n+    }\n+\n+    #[test]\n+    fn test_hash() {\n+      let mut x = TreeSet::new();\n+      let mut y = TreeSet::new();\n+\n+      x.insert(1i);\n+      x.insert(2);\n+      x.insert(3);\n+\n+      y.insert(3i);\n+      y.insert(2);\n+      y.insert(1);\n+\n+      assert!(hash::hash(&x) == hash::hash(&y));\n+    }\n+\n+    fn check(a: &[int],\n+             b: &[int],\n+             expected: &[int],\n+             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n+        let mut set_a = TreeSet::new();\n+        let mut set_b = TreeSet::new();\n+\n+        for x in a.iter() { assert!(set_a.insert(*x)) }\n+        for y in b.iter() { assert!(set_b.insert(*y)) }\n+\n+        let mut i = 0;\n+        f(&set_a, &set_b, |x| {\n+            assert_eq!(*x, expected[i]);\n+            i += 1;\n+            true\n+        });\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n+        }\n+\n+        check_intersection([], [], []);\n+        check_intersection([1, 2, 3], [], []);\n+        check_intersection([], [1, 2, 3], []);\n+        check_intersection([2], [1, 2, 3], [2]);\n+        check_intersection([1, 2, 3], [2], [2]);\n+        check_intersection([11, 1, 3, 77, 103, 5, -5],\n+                           [2, 11, 77, -9, -42, 5, 3],\n+                           [3, 5, 11, 77]);\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.difference(y).all(f))\n+        }\n+\n+        check_difference([], [], []);\n+        check_difference([1, 12], [], [1, 12]);\n+        check_difference([], [1, 2, 3, 9], []);\n+        check_difference([1, 3, 5, 9, 11],\n+                         [3, 9],\n+                         [1, 5, 11]);\n+        check_difference([-5, 11, 22, 33, 40, 42],\n+                         [-12, -5, 14, 23, 34, 38, 39, 50],\n+                         [11, 22, 33, 40, 42]);\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        fn check_symmetric_difference(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n+        }\n+\n+        check_symmetric_difference([], [], []);\n+        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n+        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n+        check_symmetric_difference([1, 3, 5, 9, 11],\n+                                   [-2, 3, 9, 14, 22],\n+                                   [-2, 1, 5, 11, 14, 22]);\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        fn check_union(a: &[int], b: &[int],\n+                                      expected: &[int]) {\n+            check(a, b, expected, |x, y, f| x.union(y).all(f))\n+        }\n+\n+        check_union([], [], []);\n+        check_union([1, 2, 3], [2], [1, 2, 3]);\n+        check_union([2], [1, 2, 3], [1, 2, 3]);\n+        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n+                    [-2, 1, 5, 9, 13, 19],\n+                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+    }\n+\n+    #[test]\n+    fn test_zip() {\n+        let mut x = TreeSet::new();\n+        x.insert(5u);\n+        x.insert(12u);\n+        x.insert(11u);\n+\n+        let mut y = TreeSet::new();\n+        y.insert(\"foo\");\n+        y.insert(\"bar\");\n+\n+        let x = x;\n+        let y = y;\n+        let mut z = x.iter().zip(y.iter());\n+\n+        // FIXME: #5801: this needs a type hint to compile...\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n+\n+        let result: Option<(&uint, & &'static str)> = z.next();\n+        assert!(result.is_none());\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set: TreeSet<int> = TreeSet::new();\n+        let empty: TreeSet<int> = TreeSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+}"}, {"sha": "27486de6f1993e0e771329c71edb19ad93e5fe48", "filename": "src/libcollections/trie/map.rs", "status": "renamed", "additions": 2, "deletions": 441, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -654,335 +654,6 @@ impl<T> IndexMut<uint, T> for TrieMap<T> {\n     }\n }\n \n-/// A set implemented as a radix trie.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::TrieSet;\n-///\n-/// let mut set = TrieSet::new();\n-/// set.insert(6);\n-/// set.insert(28);\n-/// set.insert(6);\n-///\n-/// assert_eq!(set.len(), 2);\n-///\n-/// if !set.contains(&3) {\n-///     println!(\"3 is not in the set\");\n-/// }\n-///\n-/// // Print contents in order\n-/// for x in set.iter() {\n-///     println!(\"{}\", x);\n-/// }\n-///\n-/// set.remove(&6);\n-/// assert_eq!(set.len(), 1);\n-///\n-/// set.clear();\n-/// assert!(set.is_empty());\n-/// ```\n-#[deriving(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct TrieSet {\n-    map: TrieMap<()>\n-}\n-\n-impl Show for TrieSet {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-impl Default for TrieSet {\n-    #[inline]\n-    fn default() -> TrieSet { TrieSet::new() }\n-}\n-\n-impl TrieSet {\n-    /// Creates an empty TrieSet.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    /// let mut set = TrieSet::new();\n-    /// ```\n-    #[inline]\n-    pub fn new() -> TrieSet {\n-        TrieSet{map: TrieMap::new()}\n-    }\n-\n-    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n-    /// Returns `true` if `f` returns `true` for all elements.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n-    ///\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n-    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n-    ///\n-    /// // Stop when we reach 3\n-    /// let mut vec = Vec::new();\n-    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n-    /// assert_eq!(vec, vec![5, 4, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n-        self.map.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Gets an iterator over the values in the set, in sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    /// set.insert(3);\n-    /// set.insert(2);\n-    /// set.insert(1);\n-    /// set.insert(2);\n-    ///\n-    /// // Print 1, 2, 3\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n-        SetItems{iter: self.map.iter()}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that is not less than `val`.\n-    /// If all values in the set are less than `val` an empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n-    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n-    /// assert_eq!(set.lower_bound(10).next(), None);\n-    /// ```\n-    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.lower_bound(val)}\n-    }\n-\n-    /// Gets an iterator pointing to the first value that key is greater than `val`.\n-    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n-    /// assert_eq!(set.upper_bound(10).next(), None);\n-    /// ```\n-    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n-        SetItems{iter: self.map.upper_bound(val)}\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn len(&self) -> uint { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut v = TrieSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, value: &uint) -> bool {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[inline]\n-    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| !other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[inline]\n-    pub fn is_subset(&self, other: &TrieSet) -> bool {\n-        self.iter().all(|v| other.contains(&v))\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: TrieSet = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[inline]\n-    pub fn is_superset(&self, other: &TrieSet) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2), true);\n-    /// assert_eq!(set.insert(2), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ())\n-    }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieSet;\n-    ///\n-    /// let mut set = TrieSet::new();\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value)\n-    }\n-}\n-\n-impl FromIterator<uint> for TrieSet {\n-    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet {\n-        let mut set = TrieSet::new();\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-impl Extendable<uint> for TrieSet {\n-    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) {\n-        for elem in iter {\n-            self.insert(elem);\n-        }\n-    }\n-}\n-\n struct TrieNode<T> {\n     count: uint,\n     children: [Child<T>, ..SIZE]\n@@ -1255,23 +926,8 @@ macro_rules! iterator_impl {\n iterator_impl! { Entries, iter = iter, mutability = }\n iterator_impl! { MutEntries, iter = iter_mut, mutability = mut }\n \n-/// A forward iterator over a set.\n-pub struct SetItems<'a> {\n-    iter: Entries<'a, ()>\n-}\n-\n-impl<'a> Iterator<uint> for SetItems<'a> {\n-    fn next(&mut self) -> Option<uint> {\n-        self.iter.next().map(|(key, _)| key)\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n #[cfg(test)]\n-mod test_map {\n+mod test {\n     use std::prelude::*;\n     use std::iter::range_step;\n     use std::uint;\n@@ -1687,7 +1343,7 @@ mod test_map {\n }\n \n #[cfg(test)]\n-mod bench_map {\n+mod bench {\n     use std::prelude::*;\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n@@ -1802,98 +1458,3 @@ mod bench_map {\n             })\n     }\n }\n-\n-#[cfg(test)]\n-mod test_set {\n-    use std::prelude::*;\n-    use std::uint;\n-\n-    use super::TrieSet;\n-\n-    #[test]\n-    fn test_sane_chunk() {\n-        let x = 1;\n-        let y = 1 << (uint::BITS - 1);\n-\n-        let mut trie = TrieSet::new();\n-\n-        assert!(trie.insert(x));\n-        assert!(trie.insert(y));\n-\n-        assert_eq!(trie.len(), 2);\n-\n-        let expected = [x, y];\n-\n-        for (i, x) in trie.iter().enumerate() {\n-            assert_eq!(expected[i], x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n-\n-        let set: TrieSet = xs.iter().map(|&x| x).collect();\n-\n-        for x in xs.iter() {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = TrieSet::new();\n-        let empty = TrieSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{}\", set);\n-\n-        assert!(set_str == \"{1, 2}\".to_string());\n-        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut a = TrieSet::new();\n-\n-        a.insert(1);\n-        a.insert(2);\n-        a.insert(3);\n-\n-        assert!(a.clone() == a);\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u));\n-        assert!(a < b);\n-        assert!(a.insert(3u));\n-        assert!(!(a < b) && b < a);\n-        assert!(b.insert(1));\n-        assert!(b < a);\n-        assert!(a.insert(0));\n-        assert!(a < b);\n-        assert!(a.insert(6));\n-        assert!(a < b && !(b < a));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = TrieSet::new();\n-        let mut b = TrieSet::new();\n-\n-        assert!(a <= b && a >= b);\n-        assert!(a.insert(1u));\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        assert!(b.insert(2u));\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-}", "previous_filename": "src/libcollections/trie.rs"}, {"sha": "f0f8f00a6a0db8608717287a7a1e8b6031ffd402", "filename": "src/libcollections/trie/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Maps are collections of unique keys with corresponding values, and sets are\n+//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n+//! `std::container` define the basic interface.\n+//!\n+//! This crate defines `TrieMap` and `TrieSet`, which require `uint` keys.\n+//!\n+//! `TrieMap` is ordered.\n+\n+pub mod map;\n+pub mod set;\n\\ No newline at end of file"}, {"sha": "ddddd279b0467b157fc159acacbbe5344cd40ba0", "filename": "src/libcollections/trie/set.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,457 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::default::Default;\n+use core::fmt;\n+use core::fmt::Show;\n+use std::hash::Hash;\n+\n+use trie_map::{TrieMap, Entries};\n+\n+/// A set implemented as a radix trie.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::TrieSet;\n+///\n+/// let mut set = TrieSet::new();\n+/// set.insert(6);\n+/// set.insert(28);\n+/// set.insert(6);\n+///\n+/// assert_eq!(set.len(), 2);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"3 is not in the set\");\n+/// }\n+///\n+/// // Print contents in order\n+/// for x in set.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// set.remove(&6);\n+/// assert_eq!(set.len(), 1);\n+///\n+/// set.clear();\n+/// assert!(set.is_empty());\n+/// ```\n+#[deriving(Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct TrieSet {\n+    map: TrieMap<()>\n+}\n+\n+impl Show for TrieSet {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl Default for TrieSet {\n+    #[inline]\n+    fn default() -> TrieSet { TrieSet::new() }\n+}\n+\n+impl TrieSet {\n+    /// Creates an empty TrieSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    /// let mut set = TrieSet::new();\n+    /// ```\n+    #[inline]\n+    pub fn new() -> TrieSet {\n+        TrieSet{map: TrieMap::new()}\n+    }\n+\n+    /// Visits all values in reverse order. Aborts traversal when `f` returns `false`.\n+    /// Returns `true` if `f` returns `true` for all elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(true, set.each_reverse(|&x| { vec.push(x); true }));\n+    /// assert_eq!(vec, vec![5, 4, 3, 2, 1]);\n+    ///\n+    /// // Stop when we reach 3\n+    /// let mut vec = Vec::new();\n+    /// assert_eq!(false, set.each_reverse(|&x| { vec.push(x); x != 3 }));\n+    /// assert_eq!(vec, vec![5, 4, 3]);\n+    /// ```\n+    #[inline]\n+    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n+        self.map.each_reverse(|k, _| f(k))\n+    }\n+\n+    /// Gets an iterator over the values in the set, in sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    /// set.insert(3);\n+    /// set.insert(2);\n+    /// set.insert(1);\n+    /// set.insert(2);\n+    ///\n+    /// // Print 1, 2, 3\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn iter<'a>(&'a self) -> SetItems<'a> {\n+        SetItems{iter: self.map.iter()}\n+    }\n+\n+    /// Gets an iterator pointing to the first value that is not less than `val`.\n+    /// If all values in the set are less than `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.lower_bound(4).next(), Some(4));\n+    /// assert_eq!(set.lower_bound(5).next(), Some(6));\n+    /// assert_eq!(set.lower_bound(10).next(), None);\n+    /// ```\n+    pub fn lower_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.lower_bound(val)}\n+    }\n+\n+    /// Gets an iterator pointing to the first value that key is greater than `val`.\n+    /// If all values in the set are less than or equal to `val` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.upper_bound(4).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(5).next(), Some(6));\n+    /// assert_eq!(set.upper_bound(10).next(), None);\n+    /// ```\n+    pub fn upper_bound<'a>(&'a self, val: uint) -> SetItems<'a> {\n+        SetItems{iter: self.map.upper_bound(val)}\n+    }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn len(&self) -> uint { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut v = TrieSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let set: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[inline]\n+    pub fn contains(&self, value: &uint) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let a: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut b: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| !other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sup: TrieSet = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    #[inline]\n+    pub fn is_subset(&self, other: &TrieSet) -> bool {\n+        self.iter().all(|v| other.contains(&v))\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let sub: TrieSet = [1, 2].iter().map(|&x| x).collect();\n+    /// let mut set: TrieSet = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    #[inline]\n+    pub fn is_superset(&self, other: &TrieSet) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[inline]\n+    pub fn insert(&mut self, value: uint) -> bool {\n+        self.map.insert(value, ())\n+    }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TrieSet;\n+    ///\n+    /// let mut set = TrieSet::new();\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[inline]\n+    pub fn remove(&mut self, value: &uint) -> bool {\n+        self.map.remove(value)\n+    }\n+}\n+\n+impl FromIterator<uint> for TrieSet {\n+    fn from_iter<Iter: Iterator<uint>>(iter: Iter) -> TrieSet {\n+        let mut set = TrieSet::new();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl Extendable<uint> for TrieSet {\n+    fn extend<Iter: Iterator<uint>>(&mut self, mut iter: Iter) {\n+        for elem in iter {\n+            self.insert(elem);\n+        }\n+    }\n+}\n+\n+/// A forward iterator over a set.\n+pub struct SetItems<'a> {\n+    iter: Entries<'a, ()>\n+}\n+\n+impl<'a> Iterator<uint> for SetItems<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        self.iter.next().map(|(key, _)| key)\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::prelude::*;\n+    use std::uint;\n+\n+    use super::TrieSet;\n+\n+    #[test]\n+    fn test_sane_chunk() {\n+        let x = 1;\n+        let y = 1 << (uint::BITS - 1);\n+\n+        let mut trie = TrieSet::new();\n+\n+        assert!(trie.insert(x));\n+        assert!(trie.insert(y));\n+\n+        assert_eq!(trie.len(), 2);\n+\n+        let expected = [x, y];\n+\n+        for (i, x) in trie.iter().enumerate() {\n+            assert_eq!(expected[i], x);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = vec![9u, 8, 7, 6, 5, 4, 3, 2, 1];\n+\n+        let set: TrieSet = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set = TrieSet::new();\n+        let empty = TrieSet::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+\n+    #[test]\n+    fn test_clone() {\n+        let mut a = TrieSet::new();\n+\n+        a.insert(1);\n+        a.insert(2);\n+        a.insert(3);\n+\n+        assert!(a.clone() == a);\n+    }\n+\n+    #[test]\n+    fn test_lt() {\n+        let mut a = TrieSet::new();\n+        let mut b = TrieSet::new();\n+\n+        assert!(!(a < b) && !(b < a));\n+        assert!(b.insert(2u));\n+        assert!(a < b);\n+        assert!(a.insert(3u));\n+        assert!(!(a < b) && b < a);\n+        assert!(b.insert(1));\n+        assert!(b < a);\n+        assert!(a.insert(0));\n+        assert!(a < b);\n+        assert!(a.insert(6));\n+        assert!(a < b && !(b < a));\n+    }\n+\n+    #[test]\n+    fn test_ord() {\n+        let mut a = TrieSet::new();\n+        let mut b = TrieSet::new();\n+\n+        assert!(a <= b && a >= b);\n+        assert!(a.insert(1u));\n+        assert!(a > b && a >= b);\n+        assert!(b < a && b <= a);\n+        assert!(b.insert(2u));\n+        assert!(b > a && b >= a);\n+        assert!(a < b && a <= b);\n+    }\n+}"}, {"sha": "c0bc785126c70aaa788802001cf14e3bb56b7b9b", "filename": "src/libcollections/vec_map.rs", "status": "renamed", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -31,9 +31,9 @@ use hash::Hash;\n /// # Example\n ///\n /// ```\n-/// use std::collections::SmallIntMap;\n+/// use std::collections::VecMap;\n ///\n-/// let mut months = SmallIntMap::new();\n+/// let mut months = VecMap::new();\n /// months.insert(1, \"Jan\");\n /// months.insert(2, \"Feb\");\n /// months.insert(3, \"Mar\");\n@@ -60,58 +60,58 @@ use hash::Hash;\n /// assert!(months.is_empty());\n /// ```\n #[deriving(PartialEq, Eq)]\n-pub struct SmallIntMap<T> {\n+pub struct VecMap<T> {\n     v: Vec<Option<T>>,\n }\n \n-impl<V> Default for SmallIntMap<V> {\n+impl<V> Default for VecMap<V> {\n     #[inline]\n-    fn default() -> SmallIntMap<V> { SmallIntMap::new() }\n+    fn default() -> VecMap<V> { VecMap::new() }\n }\n \n-impl<V:Clone> Clone for SmallIntMap<V> {\n+impl<V:Clone> Clone for VecMap<V> {\n     #[inline]\n-    fn clone(&self) -> SmallIntMap<V> {\n-        SmallIntMap { v: self.v.clone() }\n+    fn clone(&self) -> VecMap<V> {\n+        VecMap { v: self.v.clone() }\n     }\n \n     #[inline]\n-    fn clone_from(&mut self, source: &SmallIntMap<V>) {\n+    fn clone_from(&mut self, source: &VecMap<V>) {\n         self.v.reserve(source.v.len());\n         for (i, w) in self.v.iter_mut().enumerate() {\n             *w = source.v[i].clone();\n         }\n     }\n }\n \n-impl <S: hash::Writer, T: Hash<S>> Hash<S> for SmallIntMap<T> {\n+impl <S: hash::Writer, T: Hash<S>> Hash<S> for VecMap<T> {\n     fn hash(&self, state: &mut S) {\n         self.v.hash(state)\n     }\n }\n \n-impl<V> SmallIntMap<V> {\n-    /// Creates an empty `SmallIntMap`.\n+impl<V> VecMap<V> {\n+    /// Creates an empty `VecMap`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n-    /// let mut map: SmallIntMap<&str> = SmallIntMap::new();\n+    /// use std::collections::VecMap;\n+    /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n-    pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }\n+    pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n \n-    /// Creates an empty `SmallIntMap` with space for at least `capacity`\n+    /// Creates an empty `VecMap` with space for at least `capacity`\n     /// elements before resizing.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n-    /// let mut map: SmallIntMap<&str> = SmallIntMap::with_capacity(10);\n+    /// use std::collections::VecMap;\n+    /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n-    pub fn with_capacity(capacity: uint) -> SmallIntMap<V> {\n-        SmallIntMap { v: Vec::with_capacity(capacity) }\n+    pub fn with_capacity(capacity: uint) -> VecMap<V> {\n+        VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order by the keys.\n@@ -132,9 +132,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n@@ -159,9 +159,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n     /// map.insert(3, \"c\");\n@@ -183,15 +183,15 @@ impl<V> SmallIntMap<V> {\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order by\n-    /// the keys, emptying (but not consuming) the original `SmallIntMap`.\n+    /// the keys, emptying (but not consuming) the original `VecMap`.\n     /// The iterator's element type is `(uint, &'r V)`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n@@ -216,9 +216,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// assert_eq!(a.len(), 0);\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n@@ -232,9 +232,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// assert!(a.is_empty());\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n@@ -248,9 +248,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut a = SmallIntMap::new();\n+    /// let mut a = VecMap::new();\n     /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n@@ -262,9 +262,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.find(&1), Some(&\"a\"));\n     /// assert_eq!(map.find(&2), None);\n@@ -285,9 +285,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n@@ -302,9 +302,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// match map.find_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n@@ -330,9 +330,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.insert(2, \"value\"), true);\n     /// assert_eq!(map.insert(2, \"value2\"), false);\n     /// assert_eq!(map[2], \"value2\");\n@@ -353,9 +353,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.remove(&1), false);\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), true);\n@@ -370,9 +370,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// assert_eq!(map.swap(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n@@ -395,9 +395,9 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.pop(&1), Some(\"a\"));\n     /// assert_eq!(map.pop(&1), None);\n@@ -410,7 +410,7 @@ impl<V> SmallIntMap<V> {\n     }\n }\n \n-impl<V:Clone> SmallIntMap<V> {\n+impl<V:Clone> VecMap<V> {\n     /// Updates a value in the map. If the key already exists in the map,\n     /// modifies the value with `ff` taking `oldval, newval`.\n     /// Otherwise, sets the value to `newval`.\n@@ -419,9 +419,9 @@ impl<V:Clone> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update(1, vec![1i, 2], |mut old, new| { old.extend(new.into_iter()); old }));\n@@ -443,9 +443,9 @@ impl<V:Clone> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::SmallIntMap;\n+    /// use std::collections::VecMap;\n     ///\n-    /// let mut map = SmallIntMap::new();\n+    /// let mut map = VecMap::new();\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update_with_key(7, 10, |key, old, new| (old + new) % key));\n@@ -468,21 +468,21 @@ impl<V:Clone> SmallIntMap<V> {\n     }\n }\n \n-impl<V: PartialOrd> PartialOrd for SmallIntMap<V> {\n+impl<V: PartialOrd> PartialOrd for VecMap<V> {\n     #[inline]\n-    fn partial_cmp(&self, other: &SmallIntMap<V>) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n-impl<V: Ord> Ord for SmallIntMap<V> {\n+impl<V: Ord> Ord for VecMap<V> {\n     #[inline]\n-    fn cmp(&self, other: &SmallIntMap<V>) -> Ordering {\n+    fn cmp(&self, other: &VecMap<V>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n-impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n+impl<V: fmt::Show> fmt::Show for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"{{\"));\n \n@@ -495,30 +495,30 @@ impl<V: fmt::Show> fmt::Show for SmallIntMap<V> {\n     }\n }\n \n-impl<V> FromIterator<(uint, V)> for SmallIntMap<V> {\n-    fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> SmallIntMap<V> {\n-        let mut map = SmallIntMap::new();\n+impl<V> FromIterator<(uint, V)> for VecMap<V> {\n+    fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> VecMap<V> {\n+        let mut map = VecMap::new();\n         map.extend(iter);\n         map\n     }\n }\n \n-impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n+impl<V> Extendable<(uint, V)> for VecMap<V> {\n     fn extend<Iter: Iterator<(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<V> Index<uint, V> for SmallIntMap<V> {\n+impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n         self.find(i).expect(\"key not present\")\n     }\n }\n \n-impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n+impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n         self.find_mut(i).expect(\"key not present\")\n@@ -612,11 +612,11 @@ mod test_map {\n     use vec::Vec;\n     use hash;\n \n-    use super::SmallIntMap;\n+    use super::VecMap;\n \n     #[test]\n     fn test_find_mut() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         assert!(m.insert(1, 12i));\n         assert!(m.insert(2, 8));\n         assert!(m.insert(5, 14));\n@@ -629,7 +629,7 @@ mod test_map {\n \n     #[test]\n     fn test_len() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n         assert!(map.insert(5, 20i));\n@@ -645,7 +645,7 @@ mod test_map {\n \n     #[test]\n     fn test_clear() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         assert!(map.insert(5, 20i));\n         assert!(map.insert(11, 12));\n         assert!(map.insert(14, 22));\n@@ -658,7 +658,7 @@ mod test_map {\n \n     #[test]\n     fn test_insert_with_key() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n \n         // given a new key, initialize it with this new count,\n         // given an existing key, add more to its count\n@@ -688,23 +688,23 @@ mod test_map {\n \n     #[test]\n     fn test_swap() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         assert_eq!(m.swap(1, 2i), None);\n         assert_eq!(m.swap(1, 3i), Some(2));\n         assert_eq!(m.swap(1, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         m.insert(1, 2i);\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n \n     #[test]\n     fn test_keys() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n@@ -717,7 +717,7 @@ mod test_map {\n \n     #[test]\n     fn test_values() {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n@@ -730,7 +730,7 @@ mod test_map {\n \n     #[test]\n     fn test_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -755,7 +755,7 @@ mod test_map {\n \n     #[test]\n     fn test_iterator_size_hints() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -771,7 +771,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -794,7 +794,7 @@ mod test_map {\n \n     #[test]\n     fn test_rev_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -813,7 +813,7 @@ mod test_map {\n \n     #[test]\n     fn test_mut_rev_iterator() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n \n         assert!(m.insert(0, 1i));\n         assert!(m.insert(1, 2));\n@@ -836,7 +836,7 @@ mod test_map {\n \n     #[test]\n     fn test_move_iter() {\n-        let mut m = SmallIntMap::new();\n+        let mut m = VecMap::new();\n         m.insert(1, box 2i);\n         let mut called = false;\n         for (k, v) in m.into_iter() {\n@@ -851,8 +851,8 @@ mod test_map {\n \n     #[test]\n     fn test_show() {\n-        let mut map = SmallIntMap::new();\n-        let empty = SmallIntMap::<int>::new();\n+        let mut map = VecMap::new();\n+        let empty = VecMap::<int>::new();\n \n         map.insert(1, 2i);\n         map.insert(3, 4i);\n@@ -865,7 +865,7 @@ mod test_map {\n \n     #[test]\n     fn test_clone() {\n-        let mut a = SmallIntMap::new();\n+        let mut a = VecMap::new();\n \n         a.insert(1, 'x');\n         a.insert(4, 'y');\n@@ -876,8 +876,8 @@ mod test_map {\n \n     #[test]\n     fn test_eq() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(a == b);\n         assert!(a.insert(0, 5i));\n@@ -894,8 +894,8 @@ mod test_map {\n \n     #[test]\n     fn test_lt() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n         assert!(b.insert(2u, 5i));\n@@ -912,8 +912,8 @@ mod test_map {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = SmallIntMap::new();\n-        let mut b = SmallIntMap::new();\n+        let mut a = VecMap::new();\n+        let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n         assert!(a.insert(1u, 1i));\n@@ -926,8 +926,8 @@ mod test_map {\n \n     #[test]\n     fn test_hash() {\n-        let mut x = SmallIntMap::new();\n-        let mut y = SmallIntMap::new();\n+        let mut x = VecMap::new();\n+        let mut y = VecMap::new();\n \n         assert!(hash::hash(&x) == hash::hash(&y));\n         x.insert(1, 'a');\n@@ -945,7 +945,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs: Vec<(uint, char)> = vec![(1u, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n \n-        let map: SmallIntMap<char> = xs.iter().map(|&x| x).collect();\n+        let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n@@ -954,7 +954,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+        let mut map: VecMap<int> = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -966,7 +966,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+        let mut map: VecMap<int> = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -980,20 +980,20 @@ mod test_map {\n mod bench {\n     extern crate test;\n     use self::test::Bencher;\n-    use super::SmallIntMap;\n+    use super::VecMap;\n     use bench::{insert_rand_n, insert_seq_n, find_rand_n, find_seq_n};\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1002,15 +1002,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1019,15 +1019,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.find(&i); });\n@@ -1036,15 +1036,15 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.find(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : SmallIntMap<uint> = SmallIntMap::new();\n+        let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.find(&i); });", "previous_filename": "src/libcollections/smallintmap.rs"}, {"sha": "ddfbfa7850202ec28a3314c5dbcb3f342c1b47cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 132, "deletions": 4, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -250,8 +250,8 @@ pub trait UpperExp for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-// FIXME #11938 - UFCS would make us able call the above methods\n-// directly Show::show(x, fmt).\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n macro_rules! uniform_fn_call_workaround {\n     ($( $name: ident, $trait_: ident; )*) => {\n         $(\n@@ -262,6 +262,8 @@ macro_rules! uniform_fn_call_workaround {\n             )*\n     }\n }\n+// NOTE(stage0): Remove macro after next snapshot\n+#[cfg(stage0)]\n uniform_fn_call_workaround! {\n     secret_show, Show;\n     secret_bool, Bool;\n@@ -568,36 +570,65 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n \n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n     argument(secret_string, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(String::fmt, s)\n+}\n+\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for plural), then it invokes this method.\n+// NOTE(stage0): remove function after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)] #[inline]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     argument(secret_unsigned, s)\n }\n \n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[doc(hidden)] #[inline]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(Unsigned::fmt, s)\n+}\n+\n // Implementations of the core formatting traits\n \n impl<'a, Sized? T: Show> Show for &'a T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(*self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a, Sized? T: Show> Show for &'a mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { secret_show(&**self, f) }\n+    fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n impl<'a> Show for &'a Show+'a {\n     fn fmt(&self, f: &mut Formatter) -> Result { (*self).fmt(f) }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Bool for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_string(&(if *self {\"true\"} else {\"false\"}), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Bool for bool {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+    }\n+}\n+\n impl<T: str::Str> String for T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self.as_slice())\n@@ -610,6 +641,8 @@ impl String for str {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::Char;\n@@ -621,28 +654,80 @@ impl Char for char {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl Char for char {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        use char::Char;\n+\n+        let mut utf8 = [0u8, ..4];\n+        let amt = self.encode_utf8(utf8).unwrap_or(0);\n+        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        String::fmt(s, f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        LowerHex::fmt(&(*self as uint), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(*self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Pointer for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*self as *const T), f)\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a, T> Pointer for &'a mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(&**self as *const T), f)\n+    }\n+}\n+\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n@@ -712,26 +797,69 @@ floating!(f64)\n \n // Implementation of Show for various core types\n \n+// NOTE(stage0): remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl Show for $ty {\n         fn fmt(&self, f: &mut Formatter) -> Result {\n             (concat_idents!(secret_, $other)(self, f))\n         }\n     }\n })\n+\n+// NOTE(stage0): remove these macros after a snapshot\n+#[cfg(stage0)]\n delegate!(str to string)\n+#[cfg(stage0)]\n delegate!(bool to bool)\n+#[cfg(stage0)]\n delegate!(char to char)\n+#[cfg(stage0)]\n delegate!(f32 to float)\n+#[cfg(stage0)]\n delegate!(f64 to float)\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl Show for $ty {\n+        fn fmt(&self, f: &mut Formatter) -> Result {\n+            $other::fmt(self, f)\n+        }\n+    }\n+})\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(str to String)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(bool to Bool)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(char to Char)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f32 to Float)\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+delegate!(f64 to Float)\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *const T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> Show for *mut T {\n+    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n+}\n+\n macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n \n macro_rules! tuple ("}, {"sha": "a8a91283a112800dd5f6c7d0804a6885a790ae0e", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -145,19 +145,19 @@ pub struct Opt {\n     pub aliases: Vec<Opt>,\n }\n \n-/// One group of options, e.g., both -h and --help, along with\n+/// One group of options, e.g., both `-h` and `--help`, along with\n /// their shared description and properties.\n #[deriving(Clone, PartialEq, Eq)]\n pub struct OptGroup {\n-    /// Short Name of the `OptGroup`\n+    /// Short name of the option, e.g. `h` for a `-h` option\n     pub short_name: String,\n-    /// Long Name of the `OptGroup`\n+    /// Long name of the option, e.g. `help` for a `--help` option\n     pub long_name: String,\n-    /// Hint\n+    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n     pub hint: String,\n-    /// Description\n+    /// Description for usage help text\n     pub desc: String,\n-    /// Whether it has an argument\n+    /// Whether option has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n     pub occur: Occur\n@@ -393,6 +393,12 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n }\n \n /// Create a long option that is required and takes an argument.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n+/// * `hint` - Hint that is used in place of the argument in the usage help,\n+///   e.g. `\"FILE\"` for a `-o FILE` option\n pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n@@ -407,6 +413,12 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n }\n \n /// Create a long option that is optional and takes an argument.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n+/// * `hint` - Hint that is used in place of the argument in the usage help,\n+///   e.g. `\"FILE\"` for a `-o FILE` option\n pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n@@ -421,6 +433,10 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n }\n \n /// Create a long option that is optional and does not take an argument.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n@@ -436,6 +452,10 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n \n /// Create a long option that can occur more than once and does not\n /// take an argument.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n@@ -450,6 +470,12 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n }\n \n /// Create a long option that is optional and takes an optional argument.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n+/// * `hint` - Hint that is used in place of the argument in the usage help,\n+///   e.g. `\"FILE\"` for a `-o FILE` option\n pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n@@ -465,6 +491,12 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n \n /// Create a long option that is optional, takes an argument, and may occur\n /// multiple times.\n+///\n+/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n+/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n+/// * `desc` - Description for usage help\n+/// * `hint` - Hint that is used in place of the argument in the usage help,\n+///   e.g. `\"FILE\"` for a `-o FILE` option\n pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);"}, {"sha": "10c40a32da666f922702039a600ced41e7d5526c", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -20,6 +20,7 @@ use back::write;\n use back::target_strs;\n use back::{arm, x86, x86_64, mips, mipsel};\n use lint;\n+use metadata::cstore;\n \n use syntax::abi;\n use syntax::ast;\n@@ -31,7 +32,7 @@ use syntax::parse;\n use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};\n@@ -78,6 +79,7 @@ pub struct Options {\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n     pub addl_lib_search_paths: RefCell<Vec<Path>>,\n+    pub libs: Vec<(String, cstore::NativeLibaryKind)>,\n     pub maybe_sysroot: Option<Path>,\n     pub target_triple: String,\n     // User-specified cfg meta items. The compiler itself will add additional\n@@ -130,6 +132,7 @@ pub fn basic_options() -> Options {\n         externs: HashMap::new(),\n         crate_name: None,\n         alt_std_name: None,\n+        libs: Vec::new(),\n     }\n }\n \n@@ -575,6 +578,10 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n         optflag(\"h\", \"help\", \"Display this message\"),\n         optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n         optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n+        optmulti(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+                             library NAME. The optional KIND can be one of,\n+                             static, dylib, or framework. If omitted, dylib is\n+                             assumed.\", \"NAME[:KIND]\"),\n         optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n                  \"[bin|lib|rlib|dylib|staticlib]\"),\n@@ -767,6 +774,23 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Path::new(s.as_slice())\n     }).collect();\n \n+    let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n+        let mut parts = s.as_slice().rsplitn(1, ':');\n+        let kind = parts.next().unwrap();\n+        let (name, kind) = match (parts.next(), kind) {\n+            (None, name) |\n+            (Some(name), \"dylib\") => (name, cstore::NativeUnknown),\n+            (Some(name), \"framework\") => (name, cstore::NativeFramework),\n+            (Some(name), \"static\") => (name, cstore::NativeStatic),\n+            (_, s) => {\n+                early_error(format!(\"unknown library kind `{}`, expected \\\n+                                     one of dylib, framework, or static\",\n+                                    s).as_slice());\n+            }\n+        };\n+        (name.to_string(), kind)\n+    }).collect();\n+\n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n@@ -843,7 +867,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         color: color,\n         externs: externs,\n         crate_name: crate_name,\n-        alt_std_name: None\n+        alt_std_name: None,\n+        libs: libs,\n     }\n }\n "}, {"sha": "e52e1396b238fa1cc6521a9bb544ef011b38484e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -37,7 +37,7 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::slice;\n use std::{int, i8, i16, i32, i64, uint, u8, u16, u32, u64, f32, f64};\n use syntax::abi;"}, {"sha": "797bc5814fc566310ce79c921914172e7c4e4d93", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -24,7 +24,7 @@ use plugin::load::PluginMetadata;\n \n use std::rc::Rc;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n@@ -52,7 +52,11 @@ pub fn read_crates(sess: &Session,\n     visit_crate(&e, krate);\n     visit::walk_crate(&mut e, krate);\n     dump_crates(&sess.cstore);\n-    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore)\n+    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore);\n+\n+    for &(ref name, kind) in sess.opts.libs.iter() {\n+        register_native_lib(sess, None, name.clone(), kind);\n+    }\n }\n \n impl<'a, 'v> visit::Visitor<'v> for Env<'a> {\n@@ -233,15 +237,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             Some(k) => {\n                                 if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n-                                } else if (e.sess.targ_cfg.os == abi::OsMacos ||\n-                                           e.sess.targ_cfg.os == abi::OsiOS) &&\n-                                          k.equiv(&(\"framework\")) {\n-                                    cstore::NativeFramework\n                                 } else if k.equiv(&(\"framework\")) {\n-                                    e.sess.span_err(m.span,\n-                                        \"native frameworks are only available \\\n-                                         on OSX targets\");\n-                                    cstore::NativeUnknown\n+                                    cstore::NativeFramework\n                                 } else {\n                                     e.sess.span_err(m.span,\n                                         format!(\"unknown kind: `{}`\",\n@@ -263,15 +260,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                 InternedString::new(\"foo\")\n                             }\n                         };\n-                        if n.get().is_empty() {\n-                            e.sess.span_err(m.span,\n-                                            \"#[link(name = \\\"\\\")] given with \\\n-                                             empty name\");\n-                        } else {\n-                            e.sess\n-                             .cstore\n-                             .add_used_library(n.get().to_string(), kind);\n-                        }\n+                        register_native_lib(e.sess, Some(m.span),\n+                                            n.get().to_string(), kind);\n                     }\n                     None => {}\n                 }\n@@ -281,6 +271,32 @@ fn visit_item(e: &Env, i: &ast::Item) {\n     }\n }\n \n+fn register_native_lib(sess: &Session, span: Option<Span>, name: String,\n+                       kind: cstore::NativeLibaryKind) {\n+    if name.as_slice().is_empty() {\n+        match span {\n+            Some(span) => {\n+                sess.span_err(span, \"#[link(name = \\\"\\\")] given with \\\n+                                     empty name\");\n+            }\n+            None => {\n+                sess.err(\"empty library name given via `-l`\");\n+            }\n+        }\n+        return\n+    }\n+    let is_osx = sess.targ_cfg.os == abi::OsMacos ||\n+                 sess.targ_cfg.os == abi::OsiOS;\n+    if kind == cstore::NativeFramework && !is_osx {\n+        let msg = \"native frameworks are only available on OSX targets\";\n+        match span {\n+            Some(span) => sess.span_err(span, msg),\n+            None => sess.err(msg),\n+        }\n+    }\n+    sess.cstore.add_used_library(name, kind);\n+}\n+\n fn existing_match(e: &Env, name: &str,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let mut ret = None;"}, {"sha": "ff78491c2ad9dd4951a684c8c53293b23f726cd7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n use syntax::diagnostic::expect;\n use syntax::parse::token;\n \n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n \n pub struct MethodInfo {\n     pub name: ast::Name,"}, {"sha": "e8c5f6f4910e063c5e8f2ce45ec19f2ff23d4214", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -50,7 +50,7 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[deriving(PartialEq, FromPrimitive)]\n+#[deriving(PartialEq, FromPrimitive, Clone)]\n pub enum NativeLibaryKind {\n     NativeStatic,    // native static library (.a archive)\n     NativeFramework, // OSX-specific"}, {"sha": "20171ecfd99f73686cb628ee038b51a22ec59755", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -34,7 +34,7 @@ use std::hash::Hash;\n use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n use std::io;\n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use std::u64;\n use rbml::reader;"}, {"sha": "7b67def405176df5a4725af7cc64e31b9b4ba2d7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -237,7 +237,7 @@ use std::slice;\n use std::string;\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use flate;\n use time;\n "}, {"sha": "988f7d46f5f95c10a9253ebbef10061fbc559611", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -441,19 +441,13 @@ impl tr for def::Def {\n     fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n           def::DefFn(did, is_ctor) => def::DefFn(did.tr(dcx), is_ctor),\n-          def::DefStaticMethod(did, wrapped_did2) => {\n-            def::DefStaticMethod(did.tr(dcx),\n-                                   match wrapped_did2 {\n-                                    def::FromTrait(did2) => {\n-                                        def::FromTrait(did2.tr(dcx))\n-                                    }\n-                                    def::FromImpl(did2) => {\n-                                        def::FromImpl(did2.tr(dcx))\n-                                    }\n-                                   })\n+          def::DefStaticMethod(did, p) => {\n+            def::DefStaticMethod(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n           }\n           def::DefMethod(did0, did1, p) => {\n-            def::DefMethod(did0.tr(dcx), did1.map(|did1| did1.tr(dcx)), p)\n+            def::DefMethod(did0.tr(dcx),\n+                           did1.map(|did1| did1.tr(dcx)),\n+                           p.map(|did2| did2.tr(dcx)))\n           }\n           def::DefSelfTy(nid) => { def::DefSelfTy(dcx.tr_id(nid)) }\n           def::DefMod(did) => { def::DefMod(did.tr(dcx)) }"}, {"sha": "ce91bd1b1538889e7eefc883689136816f5a60a6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -28,7 +28,7 @@ use syntax::visit;\n use syntax::{ast, ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n-use std::collections::hashmap::Vacant;\n+use std::collections::hash_map::Vacant;\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "ec09706f97e80b66b4bd0f0db388951a24df91bc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -51,7 +51,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n-    ignore_paths: bool\n+    ignore_non_const_paths: bool\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             tcx: tcx,\n             live_symbols: box HashSet::new(),\n             struct_has_extern_repr: false,\n-            ignore_paths: false\n+            ignore_non_const_paths: false\n         }\n     }\n \n@@ -76,6 +76,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().find(id).map(|def| {\n             match def {\n+                &def::DefConst(_) => {\n+                    self.check_def_id(def.def_id())\n+                }\n+                _ if self.ignore_non_const_paths => (),\n                 &def::DefPrimTy(_) => (),\n                 &def::DefVariant(enum_id, variant_id, _) => {\n                     self.check_def_id(enum_id);\n@@ -283,21 +287,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n             _ if pat_util::pat_is_const(def_map, pat) => {\n-                // it might be the only use of a static:\n+                // it might be the only use of a const\n                 self.lookup_and_handle_definition(&pat.id)\n             }\n             _ => ()\n         }\n \n-        self.ignore_paths = true;\n+        self.ignore_non_const_paths = true;\n         visit::walk_pat(self, pat);\n-        self.ignore_paths = false;\n+        self.ignore_non_const_paths = false;\n     }\n \n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        if !self.ignore_paths {\n-            self.lookup_and_handle_definition(&id);\n-        }\n+        self.lookup_and_handle_definition(&id);\n         visit::walk_path(self, path);\n     }\n "}, {"sha": "160bb2238e7dbd64850c0e8fd6621d88843d55c3", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -55,6 +55,15 @@ pub enum MethodProvenance {\n     FromImpl(ast::DefId),\n }\n \n+impl MethodProvenance {\n+    pub fn map(self, f: |ast::DefId| -> ast::DefId) -> MethodProvenance {\n+        match self {\n+            FromTrait(did) => FromTrait(f(did)),\n+            FromImpl(did) => FromImpl(f(did))\n+        }\n+    }\n+}\n+\n impl Def {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {"}, {"sha": "a2bea790c9f46ac796ad6a960b763f174c961d11", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -58,7 +58,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::cell::{Cell, RefCell};\n use std::mem::replace;\n use std::rc::{Rc, Weak};"}, {"sha": "eb58c99e559253ef14e4681fe81ec282652ca75e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -29,7 +29,7 @@ use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -1104,18 +1104,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          * Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n          * This is generally true if either:\n          * - candidate i and candidate j are equivalent; or,\n-         * - candidate i is a where clause bound and candidate j is a concrete impl,\n+         * - candidate i is a conrete impl and candidate j is a where clause bound,\n          *   and the concrete impl is applicable to the types in the where clause bound.\n          *\n-         * The last case basically occurs with blanket impls like\n-         * `impl<T> Foo for T`.  In that case, a bound like `T:Foo` is\n-         * kind of an \"false\" ambiguity -- both are applicable to any\n-         * type, but in fact coherence requires that the bound will\n-         * always be resolved to the impl anyway.\n+         * The last case refers to cases where there are blanket impls (often conditional\n+         * blanket impls) as well as a where clause. This can come down to one of two cases:\n+         *\n+         * - The impl is truly unconditional (it has no where clauses\n+         *   of its own), in which case the where clause is\n+         *   unnecessary, because coherence requires that we would\n+         *   pick that particular impl anyhow (at least so long as we\n+         *   don't have specialization).\n+         *\n+         * - The impl is conditional, in which case we may not have winnowed it out\n+         *   because we don't know if the conditions apply, but the where clause is basically\n+         *   telling us taht there is some impl, though not necessarily the one we see.\n+         *\n+         * In both cases we prefer to take the where clause, which is\n+         * essentially harmless.  See issue #18453 for more details of\n+         * a case where doing the opposite caused us harm.\n          */\n \n         match (candidate_i, candidate_j) {\n-            (&ParamCandidate(ref vt), &ImplCandidate(impl_def_id)) => {\n+            (&ImplCandidate(impl_def_id), &ParamCandidate(ref vt)) => {\n                 debug!(\"Considering whether to drop param {} in favor of impl {}\",\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));"}, {"sha": "decd238627c20b554fce4794b9ccc6037447df5e", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -623,7 +623,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n     match f.sig.output {\n         ty::FnConverging(output_type) => {\n-            if type_is_zero_size(ccx, output_type) || fcx.llretslotptr.get().is_some() {\n+            if return_type_is_void(ccx, output_type) || fcx.llretslotptr.get().is_some() {\n                 RetVoid(bcx);\n             } else {\n                 Ret(bcx, retval);"}, {"sha": "8b5e82ecf90120ee28b7f7cc58d6e18b369a379c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -502,7 +502,11 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n-        self.tcx().method_map.borrow().find(&method_call).map(|method| method.ty)\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .find(&method_call)\n+            .map(|method| monomorphize_type(self, method.ty))\n     }\n \n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {"}, {"sha": "a0ba2996334b9a62a4c59493cbd89a0afbc49670", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -745,18 +745,6 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Translate index expression.\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n-            // Overloaded. Evaluate `trans_overloaded_op`, which will\n-            // invoke the user's index() method, which basically yields\n-            // a `&T` pointer.  We can then proceed down the normal\n-            // path (below) to dereference that `&T`.\n-            let val =\n-                unpack_result!(bcx,\n-                               trans_overloaded_op(bcx,\n-                                                   index_expr,\n-                                                   method_call,\n-                                                   base_datum,\n-                                                   vec![(ix_datum, idx.id)],\n-                                                   None));\n             let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n             let elt_ty = match ty::deref(ref_ty, true) {\n                 None => {\n@@ -766,7 +754,25 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 Some(elt_tm) => elt_tm.ty,\n             };\n-            Datum::new(val, elt_ty, LvalueExpr)\n+\n+            // Overloaded. Evaluate `trans_overloaded_op`, which will\n+            // invoke the user's index() method, which basically yields\n+            // a `&T` pointer.  We can then proceed down the normal\n+            // path (below) to dereference that `&T`.\n+            let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_index_elt\");\n+            unpack_result!(bcx,\n+                           trans_overloaded_op(bcx,\n+                                               index_expr,\n+                                               method_call,\n+                                               base_datum,\n+                                               vec![(ix_datum, idx.id)],\n+                                               Some(SaveIn(scratch.val))));\n+            let datum = scratch.to_expr_datum();\n+            if ty::type_is_sized(bcx.tcx(), elt_ty) {\n+                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n+            } else {\n+                Datum::new(datum.val, ty::mk_open(bcx.tcx(), elt_ty), LvalueExpr)\n+            }\n         }\n         None => {\n             let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx,"}, {"sha": "4c088e42243e190d18067c6dfab0e7b3860984f0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -43,7 +43,7 @@ use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use arena::TypedArena;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};"}, {"sha": "dba1fe966f14783905cb68dd358408eb780b4652", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -998,14 +998,14 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n-                                    ast_ty.span, \"expected constant expr for vector length\");\n+                                    ast_ty.span, \"expected constant expr for array length\");\n                             }\n                         }\n                     }\n                     Err(ref r) => {\n                         tcx.sess.span_fatal(\n                             ast_ty.span,\n-                            format!(\"expected constant expr for vector \\\n+                            format!(\"expected constant expr for array \\\n                                      length: {}\",\n                                     *r).as_slice());\n                     }"}, {"sha": "a686a5e72a0a7cafcbca071db595c5ba8ebc091c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -19,7 +19,7 @@ use middle::typeck::require_same_types;\n \n use std::cmp;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::{Span, Spanned};"}, {"sha": "c280474a076a0b28614a3a562aa87c96a2145cce", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -118,7 +118,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::abi;"}, {"sha": "acc3cf0307b9655fcc1baf0e4b810299b46459b9", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -142,7 +142,7 @@ use syntax::visit::Visitor;\n \n use std::cell::{RefCell};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Vacant, Occupied};\n+use std::collections::hash_map::{Vacant, Occupied};\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS"}, {"sha": "91e9c18853c804b0f44288721bcaf9103c2cc323", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -18,7 +18,7 @@ use middle::ty_fold::{TypeFolder, TypeFoldable};\n use syntax::ast;\n \n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types."}, {"sha": "87b0aed4ac49c68bb4a8faf26dbd37eb0fb45f06", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -187,7 +187,11 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n                                    receiver through a trait object\", method_name))\n             }\n \n-            ty::StaticExplicitSelfCategory |\n+            ty::StaticExplicitSelfCategory => {\n+                // Static methods are always object-safe since they\n+                // can't be called through a trait object\n+                return msgs\n+            }\n             ty::ByReferenceExplicitSelfCategory(..) |\n             ty::ByBoxExplicitSelfCategory => {}\n         }"}, {"sha": "6e5e8d72839eb0959aeef3a75ccc445279bd25e8", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -44,23 +44,23 @@ use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n-use std::collections::hashmap;\n+use std::collections::hash_map;\n \n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     skolemization_count: uint,\n-    skolemization_map: hashmap::HashMap<ty::InferTy, ty::t>,\n+    skolemization_map: hash_map::HashMap<ty::InferTy, ty::t>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n         TypeSkolemizer {\n             infcx: infcx,\n             skolemization_count: 0,\n-            skolemization_map: hashmap::HashMap::new(),\n+            skolemization_map: hash_map::HashMap::new(),\n         }\n     }\n \n@@ -76,8 +76,8 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n         }\n \n         match self.skolemization_map.entry(key) {\n-            hashmap::Occupied(entry) => *entry.get(),\n-            hashmap::Vacant(entry) => {\n+            hash_map::Occupied(entry) => *entry.get(),\n+            hash_map::Vacant(entry) => {\n                 let index = self.skolemization_count;\n                 self.skolemization_count += 1;\n                 let t = ty::mk_infer(self.infcx.tcx, skolemizer(index));"}, {"sha": "9af2b22adea455c1392769e395a9db701e347c88", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -34,7 +34,7 @@\n //! both occur before the crate is rendered.\n \n use std::collections::{HashMap, HashSet};\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::fmt;\n use std::io::fs::PathExtensions;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};"}, {"sha": "ac1b1b3a0bb7a673d52495743d8f86fd55188b44", "filename": "src/librustdoc/html/static/SourceSerifPro-Bold.woff", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-Bold.woff", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-Bold.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-Bold.woff?ref=b11b706545ec986b0416a14383170c60004644a5"}, {"sha": "7cc34798f9904f90ebe6bb15a8d96d6cd13f7251", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -69,6 +69,10 @@ body {\n     margin: 0;\n     position: relative;\n     padding: 10px 15px 20px 15px;\n+\n+    -webkit-font-feature-settings: \"kern\", \"liga\";\n+    -moz-font-feature-settings: \"kern\", \"liga\";\n+    font-feature-settings: \"kern\", \"liga\";\n }\n \n h1 {\n@@ -101,7 +105,7 @@ h3.impl, h3.method, h4.method {\n h3.impl, h3.method {\n     margin-top: 15px;\n }\n-h1, h2, h3, h4, section.sidebar, a.source, .search-input, .content table a, .collapse-toggle {\n+h1, h2, h3, h4, section.sidebar, a.source, .search-input, .content table :not(code)>a, .collapse-toggle {\n     font-family: \"Fira Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n }\n \n@@ -177,7 +181,7 @@ nav.sub {\n     color: #333;\n }\n \n-.location a:first-child { font-weight: bold; }\n+.location a:first-child { font-weight: 500; }\n \n .block {\n     padding: 0 10px;\n@@ -494,7 +498,7 @@ pre.rust { position: relative; }\n }\n \n .collapse-toggle {\n-    font-weight: 100;\n+    font-weight: 300;\n     position: absolute;\n     left: 13px;\n     color: #999;\n@@ -523,7 +527,6 @@ pre.rust { position: relative; }\n \n .toggle-label {\n     color: #999;\n-    font-style: italic;\n }\n \n "}, {"sha": "bd3c618a5ed46149b2075c7ed319ddc38a24b3b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -31,7 +31,7 @@ extern crate time;\n use std::io;\n use std::io::{File, MemWriter};\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n "}, {"sha": "7129f14720911f8cbaa2b0f588b305349558fa23", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -41,7 +41,7 @@ assert_eq!(*key_vector.get().unwrap(), vec![4]);\n use core::prelude::*;\n \n use alloc::heap;\n-use collections::treemap::TreeMap;\n+use collections::TreeMap;\n use core::cmp;\n use core::kinds::marker;\n use core::mem;"}, {"sha": "62b93336a34bdce65776167fba79510a3b17f806", "filename": "src/libstd/collections/hash/bench.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -18,7 +18,7 @@ use iter::{range_inclusive};\n \n #[bench]\n fn new_drop(b : &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     b.iter(|| {\n         let m : HashMap<int, int> = HashMap::new();\n@@ -28,7 +28,7 @@ fn new_drop(b : &mut Bencher) {\n \n #[bench]\n fn new_insert_drop(b : &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     b.iter(|| {\n         let mut m = HashMap::new();\n@@ -39,7 +39,7 @@ fn new_insert_drop(b : &mut Bencher) {\n \n #[bench]\n fn grow_by_insertion(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -57,7 +57,7 @@ fn grow_by_insertion(b: &mut Bencher) {\n \n #[bench]\n fn find_existing(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -74,7 +74,7 @@ fn find_existing(b: &mut Bencher) {\n \n #[bench]\n fn find_nonexisting(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -91,7 +91,7 @@ fn find_nonexisting(b: &mut Bencher) {\n \n #[bench]\n fn hashmap_as_queue(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n \n@@ -110,7 +110,7 @@ fn hashmap_as_queue(b: &mut Bencher) {\n \n #[bench]\n fn find_pop_insert(b: &mut Bencher) {\n-    use super::HashMap;\n+    use super::map::HashMap;\n \n     let mut m = HashMap::new();\n ", "previous_filename": "src/libstd/collections/hashmap/bench.rs"}, {"sha": "596e483c2f6d3b2555404ab686a9f965c98beea6", "filename": "src/libstd/collections/hash/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "previous_filename": "src/libstd/collections/hashmap/map.rs"}, {"sha": "ee3fc1e6ac3621b5bb7499e66ec8019a72007fef", "filename": "src/libstd/collections/hash/mod.rs", "status": "renamed", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -10,24 +10,7 @@\n \n //! Unordered containers, implemented as hash-tables\n \n-pub use self::map::HashMap;\n-pub use self::map::Entries;\n-pub use self::map::MutEntries;\n-pub use self::map::MoveEntries;\n-pub use self::map::Entry;\n-pub use self::map::Occupied;\n-pub use self::map::Vacant;\n-pub use self::map::OccupiedEntry;\n-pub use self::map::VacantEntry;\n-pub use self::map::Keys;\n-pub use self::map::Values;\n-pub use self::map::INITIAL_CAPACITY;\n-pub use self::set::HashSet;\n-pub use self::set::SetItems;\n-pub use self::set::SetMoveItems;\n-pub use self::set::SetAlgebraItems;\n-\n mod bench;\n-mod map;\n-mod set;\n+pub mod map;\n+pub mod set;\n mod table;", "previous_filename": "src/libstd/collections/hashmap/mod.rs"}, {"sha": "823bd49d7a6632488e8c285c2d6284248c8a4eb6", "filename": "src/libstd/collections/hash/set.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -22,7 +22,7 @@ use iter;\n use option::{Some, None};\n use result::{Ok, Err};\n \n-use super::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n+use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n \n \n // Future Optimization (FIXME!)", "previous_filename": "src/libstd/collections/hashmap/set.rs"}, {"sha": "4d73029b7b06b50e3101c238d521d35c81bb0e27", "filename": "src/libstd/collections/hash/table.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "previous_filename": "src/libstd/collections/hashmap/table.rs"}, {"sha": "13486d4b8f84d55d5e8299e341cb40174e6777df", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -24,9 +24,9 @@\n //! Rust's collections can be grouped into four major categories:\n //!\n //! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n-//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `SmallIntMap`, `LruCache`\n+//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `VecMap`, `LruCache`\n //! * Sets: `HashSet`, `BTreeSet`, `TreeSet`, `TrieSet`, `BitVSet`, `EnumSet`\n-//! * Misc: `PriorityQueue`\n+//! * Misc: `BinaryHeap`\n //!\n //! # When Should You Use Which Collection?\n //!\n@@ -74,7 +74,7 @@\n //! * You want a `HashMap`, but with many potentially large `uint` keys.\n //! * You want a `BTreeMap`, but with potentially large `uint` keys.\n //!\n-//! ### Use a `SmallIntMap` when:\n+//! ### Use a `VecMap` when:\n //! * You want a `HashMap` but with known to be small `uint` keys.\n //! * You want a `BTreeMap`, but with known to be small `uint` keys.\n //!\n@@ -88,12 +88,12 @@\n //! * You want a bitvector.\n //!\n //! ### Use a `BitVSet` when:\n-//! * You want a `SmallIntSet`.\n+//! * You want a `VecSet`.\n //!\n //! ### Use an `EnumSet` when:\n //! * You want a C-like enum, stored in a single `uint`.\n //!\n-//! ### Use a `PriorityQueue` when:\n+//! ### Use a `BinaryHeap` when:\n //! * You want to store a bunch of elements, but only ever want to process the \"biggest\"\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n@@ -266,7 +266,7 @@\n //! #### Counting the number of times each character in a string occurs\n //!\n //! ```\n-//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n //!\n //! let mut count = BTreeMap::new();\n //! let message = \"she sells sea shells by the sea shore\";\n@@ -293,7 +293,7 @@\n //! #### Tracking the inebriation of customers at a bar\n //!\n //! ```\n-//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//! use std::collections::btree_map::{BTreeMap, Occupied, Vacant};\n //!\n //! // A client of the bar. They have an id and a blood alcohol level.\n //! struct Person { id: u32, blood_alcohol: f32 };\n@@ -328,14 +328,27 @@\n \n #![experimental]\n \n-pub use core_collections::{Bitv, BitvSet, BTreeMap, BTreeSet, DList, EnumSet};\n-pub use core_collections::{PriorityQueue, RingBuf, SmallIntMap};\n-pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet};\n-pub use core_collections::{bitv, btree, dlist, enum_set};\n-pub use core_collections::{priority_queue, ringbuf, smallintmap, treemap, trie};\n+pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n+pub use core_collections::{DList, EnumSet, RingBuf};\n+pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet, VecMap};\n \n-pub use self::hashmap::{HashMap, HashSet};\n+pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set, dlist, enum_set};\n+pub use core_collections::{ring_buf, tree_map, tree_set, trie_map, trie_set, vec_map};\n+\n+pub use self::hash_map::HashMap;\n+pub use self::hash_set::HashSet;\n pub use self::lru_cache::LruCache;\n \n-pub mod hashmap;\n+mod hash;\n+\n+pub mod hash_map {\n+    //! A hashmap\n+    pub use super::hash::map::*;\n+}\n+\n+pub mod hash_set {\n+    //! A hashset\n+    pub use super::hash::set::*;\n+}\n+\n pub mod lru_cache;"}, {"sha": "cb151dd9c0abfa6b16bde7228a84c054504ade54", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -424,14 +424,20 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n pub use core::fmt::{argument, argumentstr, argumentuint};\n+// NOTE(stage0): remove these imports after a snapshot\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_show, secret_string, secret_unsigned};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_signed, secret_lower_hex, secret_upper_hex};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_bool, secret_char, secret_octal, secret_binary};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n+#[cfg(stage0)]\n #[doc(hidden)]\n pub use core::fmt::{secret_pointer};\n "}, {"sha": "152b89b86e7a60f512f725ce1d856e6f25a4e8c2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -675,26 +675,23 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n \n /// Extract the string literal from the first token of `tts`. If this\n /// is not a string literal, emit an error and return None.\n-pub fn get_single_str_from_tts(cx: &ExtCtxt,\n+pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                sp: Span,\n                                tts: &[ast::TokenTree],\n                                name: &str)\n                                -> Option<String> {\n-    if tts.len() != 1 {\n-        cx.span_err(sp, format!(\"{} takes 1 argument.\", name).as_slice());\n-    } else {\n-        match tts[0] {\n-            ast::TtToken(_, token::LitStr(ident)) => return Some(parse::str_lit(ident.as_str())),\n-            ast::TtToken(_, token::LitStrRaw(ident, _)) => {\n-                return Some(parse::raw_str_lit(ident.as_str()))\n-            }\n-            _ => {\n-                cx.span_err(sp,\n-                            format!(\"{} requires a string.\", name).as_slice())\n-            }\n-        }\n+    let mut p = cx.new_parser_from_tts(tts);\n+    if p.token == token::Eof {\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name).as_slice());\n+        return None\n     }\n-    None\n+    let ret = cx.expander().fold_expr(p.parse_expr());\n+    if p.token != token::Eof {\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name).as_slice());\n+    }\n+    expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n+        s.get().to_string()\n+    })\n }\n \n /// Extract comma-separated expressions from `tts`. If there is a"}, {"sha": "486ce910e2b6f9e6d40dd66af4888666573d60b1", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -663,28 +663,28 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn format_arg(ecx: &ExtCtxt, sp: Span,\n                   ty: &ArgumentType, arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n-        let (krate, fmt_fn) = match *ty {\n+        let trait_ = match *ty {\n             Known(ref tyname) => {\n                 match tyname.as_slice() {\n-                    \"\"  => (\"std\", \"secret_show\"),\n-                    \"b\" => (\"std\", \"secret_bool\"),\n-                    \"c\" => (\"std\", \"secret_char\"),\n-                    \"d\" | \"i\" => (\"std\", \"secret_signed\"),\n-                    \"e\" => (\"std\", \"secret_lower_exp\"),\n-                    \"E\" => (\"std\", \"secret_upper_exp\"),\n-                    \"f\" => (\"std\", \"secret_float\"),\n-                    \"o\" => (\"std\", \"secret_octal\"),\n-                    \"p\" => (\"std\", \"secret_pointer\"),\n-                    \"s\" => (\"std\", \"secret_string\"),\n-                    \"t\" => (\"std\", \"secret_binary\"),\n-                    \"u\" => (\"std\", \"secret_unsigned\"),\n-                    \"x\" => (\"std\", \"secret_lower_hex\"),\n-                    \"X\" => (\"std\", \"secret_upper_hex\"),\n+                    \"\"  => \"Show\",\n+                    \"b\" => \"Bool\",\n+                    \"c\" => \"Char\",\n+                    \"d\" | \"i\" => \"Signed\",\n+                    \"e\" => \"LowerExp\",\n+                    \"E\" => \"UpperExp\",\n+                    \"f\" => \"Float\",\n+                    \"o\" => \"Octal\",\n+                    \"p\" => \"Pointer\",\n+                    \"s\" => \"String\",\n+                    \"t\" => \"Binary\",\n+                    \"u\" => \"Unsigned\",\n+                    \"x\" => \"LowerHex\",\n+                    \"X\" => \"UpperHex\",\n                     _ => {\n                         ecx.span_err(sp,\n                                      format!(\"unknown format trait `{}`\",\n                                              *tyname).as_slice());\n-                        (\"std\", \"dummy\")\n+                        \"Dummy\"\n                     }\n                 }\n             }\n@@ -697,9 +697,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n \n         let format_fn = ecx.path_global(sp, vec![\n-                ecx.ident_of(krate),\n+                ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),\n-                ecx.ident_of(fmt_fn)]);\n+                ecx.ident_of(trait_),\n+                ecx.ident_of(\"fmt\")]);\n         ecx.expr_call_global(sp, vec![\n                 ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),"}, {"sha": "bebe16286c97acdc89e8cf18ad879af8bd2d958d", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -20,7 +20,7 @@ use ast::{Ident, Mrk, Name, SyntaxContext};\n use std::cell::RefCell;\n use std::rc::Rc;\n use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map::{Occupied, Vacant};\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having"}, {"sha": "f19230844099856fba89ce5454d953cf59185331", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -9,14 +9,16 @@\n // except according to those terms.\n \n use ast;\n-use codemap;\n use codemap::{Pos, Span};\n+use codemap;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse;\n use parse::token;\n+use parse;\n use print::pprust;\n+use ptr::P;\n+use util::small_vector::SmallVector;\n \n use std::io::File;\n use std::rc::Rc;\n@@ -82,14 +84,14 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n /// include! : parse the given file as an expr\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n-pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                      -> Box<base::MacResult+'static> {\n+pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                           -> Box<base::MacResult+'cx> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut p =\n+    let p =\n         parse::new_sub_parser_from_file(cx.parse_sess(),\n                                         cx.cfg(),\n                                         &res_rel_file(cx,\n@@ -98,7 +100,28 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                         true,\n                                         None,\n                                         sp);\n-    base::MacExpr::new(p.parse_expr())\n+\n+    struct ExpandResult<'a> {\n+        p: parse::parser::Parser<'a>,\n+    }\n+    impl<'a> base::MacResult for ExpandResult<'a> {\n+        fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> {\n+            Some(self.p.parse_expr())\n+        }\n+        fn make_items(mut self: Box<ExpandResult<'a>>)\n+                      -> Option<SmallVector<P<ast::Item>>> {\n+            let mut ret = SmallVector::zero();\n+            loop {\n+                match self.p.parse_item_with_outer_attributes() {\n+                    Some(item) => ret.push(item),\n+                    None => break\n+                }\n+            }\n+            Some(ret)\n+        }\n+    }\n+\n+    box ExpandResult { p: p }\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "54eaa3086588ec1d25690723b8d1d03daadb16d6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -57,7 +57,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"default_type_params\", Active),\n     (\"quote\", Active),\n     (\"linkage\", Active),\n-    (\"struct_inherit\", Active),\n+    (\"struct_inherit\", Removed),\n     (\"overloaded_calls\", Active),\n     (\"unboxed_closure_sugar\", Active),\n "}, {"sha": "9a67ee8836baecfb30d2cca5f6ade9442ec261ae", "filename": "src/libterm/win.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -71,8 +71,7 @@ fn color_to_bits(color: color::Color) -> u16 {\n }\n \n fn bits_to_color(bits: u16) -> color::Color {\n-    let bits = bits & 0x7;\n-    let color = match bits {\n+    let color = match bits & 0x7 {\n         0 => color::BLACK,\n         0x1 => color::BLUE,\n         0x2 => color::GREEN,\n@@ -84,11 +83,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n         _ => unreachable!()\n     };\n \n-    if bits >= 8 {\n-        color | 0x8\n-    } else {\n-        color\n-    }\n+    color | (bits & 0x8) // copy the hi-intensity bit\n }\n \n impl<T: Writer+Send> WinConsole<T> {"}, {"sha": "8c184ccbe43a89a09ccfb1a28bd91336f45e7cd9", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(missing_docs)]\n \n-use std::collections::hashmap;\n-use std::collections::hashmap::{Occupied, Vacant};\n+use std::collections::hash_map;\n+use std::collections::hash_map::{Occupied, Vacant};\n use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n@@ -440,8 +440,8 @@ pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n-    let mut map: hashmap::HashMap<U,uint> = hashmap::HashMap::new();\n+pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hash_map::HashMap<U, uint> {\n+    let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n         match map.entry(elem) {\n             Occupied(mut entry) => { *entry.get_mut() += 1; },"}, {"sha": "af3bc20378c393119dbafdc6c88dd2b3c9dce4fc", "filename": "src/test/auxiliary/issue-18501.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fissue-18501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fissue-18501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-18501.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+struct Foo;\n+\n+trait Tr {\n+    fn tr(&self);\n+}\n+\n+impl Tr for Foo {\n+    fn tr(&self) {}\n+}\n+\n+fn take_method<T>(f: fn(&T), t: &T) {}\n+\n+#[inline]\n+pub fn pass_method() {\n+    take_method(Tr::tr, &Foo);\n+}"}, {"sha": "2a5e07a32855efb26d999dd83a50ea67b2d1173b", "filename": "src/test/auxiliary/issue-18514.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fissue-18514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fissue-18514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-18514.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+pub trait Tr {\n+    fn tr(&self);\n+}\n+\n+pub struct St<V>(pub Vec<V>);\n+\n+impl<V> Tr for St<V> {\n+    fn tr(&self) {\n+        match self {\n+            &St(ref v) => {\n+                v.iter();\n+            }\n+        }\n+    }\n+}"}, {"sha": "aea3c749930b6e5ce2da338042a3f6e9a3907fcd", "filename": "src/test/auxiliary/macro-include-items-expr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fmacro-include-items-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fmacro-include-items-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro-include-items-expr.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test: this is not a test\n+\n+1"}, {"sha": "da72aaef80591c494533ea2107acbbcd6a99ba4a", "filename": "src/test/auxiliary/macro-include-items-item.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fmacro-include-items-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fauxiliary%2Fmacro-include-items-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro-include-items-item.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test: this is not a test\n+\n+fn foo() { bar() }"}, {"sha": "8151f2718e35cc1d84cad91b178a90d395d9435a", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -14,7 +14,7 @@ extern crate collections;\n extern crate rand;\n extern crate time;\n \n-use std::collections::bitv::BitvSet;\n+use std::collections::BitvSet;\n use std::collections::TreeSet;\n use std::hash::Hash;\n use std::collections::HashSet;"}, {"sha": "cdcb88d87c6446918c520ce50acf646c4f659804", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -13,17 +13,17 @@\n extern crate collections;\n extern crate time;\n \n-use std::collections::SmallIntMap;\n+use std::collections::VecMap;\n use std::os;\n use std::uint;\n \n-fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n+fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n     for i in range(min, max) {\n         map.insert(i, i + 22u);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n+fn check_sequential(min: uint, max: uint, map: &VecMap<uint>) {\n     for i in range(min, max) {\n         assert_eq!(map[i], i + 22u);\n     }\n@@ -45,7 +45,7 @@ fn main() {\n     let mut appendf = 0.0;\n \n     for _ in range(0u, rep) {\n-        let mut map = SmallIntMap::new();\n+        let mut map = VecMap::new();\n         let start = time::precise_time_s();\n         append_sequential(0u, max, &mut map);\n         let mid = time::precise_time_s();"}, {"sha": "542562b69e6a7ae763922524516d479da48e6b03", "filename": "src/test/compile-fail/dst-index.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that overloaded index expressions with DST result types\n+// can't be used as rvalues\n+\n+use std::ops::Index;\n+use std::fmt::Show;\n+\n+struct S;\n+\n+impl Index<uint, str> for S {\n+    fn index<'a>(&'a self, _: &uint) -> &'a str {\n+        \"hello\"\n+    }\n+}\n+\n+struct T;\n+\n+impl Index<uint, Show + 'static> for T {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Show + 'static {\n+        static x: uint = 42;\n+        &x\n+    }\n+}\n+\n+fn main() {\n+    S[0];\n+    //~^ ERROR E0161\n+    T[0];\n+    //~^ ERROR cannot move out of dereference\n+    //~^^ ERROR E0161\n+}"}, {"sha": "6371a5c711d6b9209a1589861b1599f7b7b6e9ef", "filename": "src/test/compile-fail/extoption_env-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextoption_env-not-string-literal.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() { option_env!(10); } //~ ERROR: requires a string\n+fn main() { option_env!(10); } //~ ERROR: argument must be a string literal"}, {"sha": "bd2a3eba0b5b8ff6ef0e50c65723db80ea7db0cf", "filename": "src/test/compile-fail/manual-link-bad-form.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-l :static\n+// error-pattern: empty library name given via `-l`\n+\n+fn main() {\n+}\n+\n+"}, {"sha": "4614440ddafd58f15673a190e599e32a045e182a", "filename": "src/test/compile-fail/manual-link-bad-kind.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-l foo:bar\n+// error-pattern: unknown library kind `bar`, expected one of dylib, framework, or static\n+\n+fn main() {\n+}\n+"}, {"sha": "96cc35049ee40e309fb4ea4e7a083b0dc1680142", "filename": "src/test/compile-fail/manual-link-framework.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-framework.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fmanual-link-framework.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmanual-link-framework.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-macos\n+// ignore-ios\n+// compile-flags:-l foo:framework\n+// error-pattern: native frameworks are only available on OSX targets\n+\n+fn main() {\n+}"}, {"sha": "91551941c0656012a6f4b616d21216c068fe65f0", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -13,6 +13,6 @@\n fn main() {\n     fn bar(n: int) {\n         let _x: [int, ..n];\n-        //~^ ERROR expected constant expr for vector length: non-constant path in constant expr\n+        //~^ ERROR expected constant expr for array length: non-constant path in constant expr\n     }\n }"}, {"sha": "c86f8a38f63c409f32eeb4885a17da54050f398e", "filename": "src/test/run-fail/hashmap-capacity-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:capacity overflow\n \n-use std::collections::hashmap::HashMap;\n+use std::collections::hash_map::HashMap;\n use std::uint;\n use std::mem::size_of;\n "}, {"sha": "d2a02adc9d4a458bfc6d5327203342248c8e0331", "filename": "src/test/run-make/manual-link/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmanual-link%2FMakefile?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all: $(TMPDIR)/libbar.a\n+\t$(RUSTC) foo.rs -lbar:static\n+\t$(RUSTC) main.rs\n+\t$(call RUN,main)\n+"}, {"sha": "e42599986781fe984a2c1427a3373cf439a34f60", "filename": "src/test/run-make/manual-link/bar.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmanual-link%2Fbar.c?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1 @@\n+void bar() {}"}, {"sha": "e42599986781fe984a2c1427a3373cf439a34f60", "filename": "src/test/run-make/manual-link/foo.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.c?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1 @@\n+void bar() {}"}, {"sha": "d67a4057afbfca793a8d9602690225cc364774e5", "filename": "src/test/run-make/manual-link/foo.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmanual-link%2Ffoo.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+extern {\n+    fn bar();\n+}\n+\n+pub fn foo() {\n+    unsafe { bar(); }\n+}"}, {"sha": "756a47f386ae3a0fa133feaa50e7ec2340e5a6e0", "filename": "src/test/run-make/manual-link/main.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-make%2Fmanual-link%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmanual-link%2Fmain.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;\n+\n+fn main() {\n+    foo::foo();\n+}"}, {"sha": "44006a0039abd31df57562d47f9e9e283f849a38", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -17,7 +17,7 @@ extern crate time;\n // These tests used to be separate files, but I wanted to refactor all\n // the common code.\n \n-use std::hashmap::{HashMap, HashSet};\n+use std::collections::{HashMap, HashSet};\n \n use rbml::reader as EBReader;\n use rbml::writer as EBWriter;"}, {"sha": "266f9bcba5f92545ca9619cdeee6d4c3b808428a", "filename": "src/test/run-pass/dst-index.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that overloaded index expressions with DST result types\n+// work and don't ICE.\n+\n+use std::ops::Index;\n+use std::fmt::Show;\n+\n+struct S;\n+\n+impl Index<uint, str> for S {\n+    fn index<'a>(&'a self, _: &uint) -> &'a str {\n+        \"hello\"\n+    }\n+}\n+\n+struct T;\n+\n+impl Index<uint, Show + 'static> for T {\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Show + 'static {\n+        static x: uint = 42;\n+        &x\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(&S[0], \"hello\");\n+    assert_eq!(format!(\"{}\", &T[0]).as_slice(), \"42\");\n+}"}, {"sha": "1717075885d7a1bfd2449762e9d68b41bd1e208b", "filename": "src/test/run-pass/issue-10853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-10853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-10853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10853.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(missing_doc)]\n+#![deny(missing_docs)]\n #![doc=\"module\"]\n \n #[doc=\"struct\"]"}, {"sha": "70217868a54b834e3ae21a01f9f6ee9b4ee1ccaa", "filename": "src/test/run-pass/issue-18464.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18464.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+#![deny(dead_code)]\n+\n+const LOW_RANGE: char = '0';\n+const HIGH_RANGE: char = '9';\n+\n+fn main() {\n+    match '5' {\n+        LOW_RANGE...HIGH_RANGE => (),\n+        _ => ()\n+    };\n+}"}, {"sha": "ce026942948ca82c96597b997a8022bcc1414692", "filename": "src/test/run-pass/issue-18501.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18501.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we don't ICE when inlining a function from another\n+// crate that uses a trait method as a value due to incorrectly\n+// translating the def ID of the trait during AST decoding.\n+\n+// aux-build:issue-18501.rs\n+extern crate \"issue-18501\" as issue;\n+\n+fn main() {\n+    issue::pass_method();\n+}"}, {"sha": "c75abd62deba6721bcd7c0f851044cae09ef2137", "filename": "src/test/run-pass/issue-18514.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18514.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we don't ICE when translating a generic impl method from\n+// an extern crate that contains a match expression on a local\n+// variable lvalue where one of the match case bodies contains an\n+// expression that autoderefs through an overloaded generic deref\n+// impl.\n+\n+// aux-build:issue-18514.rs\n+extern crate \"issue-18514\" as ice;\n+use ice::{Tr, St};\n+\n+fn main() {\n+    let st: St<()> = St(vec![]);\n+    st.tr();\n+}"}, {"sha": "90e20e30d109a17fb3beb635790a34c293f6ac8b", "filename": "src/test/run-pass/issue-18539.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18539.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fissue-18539.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18539.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that coercing bare fn's that return a zero sized type to\n+// a closure doesn't cause an LLVM ERROR\n+\n+struct Foo;\n+\n+fn uint_to_foo(_: uint) -> Foo {\n+    Foo\n+}\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    range(0u, 10).map(uint_to_foo);\n+}"}, {"sha": "0e7e6e247f5ab705fd2dd5abc2e5c2954d514869", "filename": "src/test/run-pass/macro-include-items.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+fn bar() {}\n+\n+include!(concat!(\"\", \"\", \"../auxiliary/\", \"macro-include-items-item.rs\"))\n+\n+fn main() {\n+    foo();\n+    assert_eq!(include!(concat!(\"\", \"../auxiliary/\", \"macro-include-items-expr.rs\")), 1u);\n+}"}, {"sha": "929cb9e7f17594631f5df6f52ea18d62cc1e256c", "filename": "src/test/run-pass/trait-object-safety.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-safety.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that object-safe methods are identified as such.  Also\n+// acts as a regression test for #18490\n+\n+trait Tr {\n+    // Static methods are always safe regardless of other rules\n+    fn new() -> Self;\n+}\n+\n+struct St;\n+\n+impl Tr for St {\n+    fn new() -> St { St }\n+}\n+\n+fn main() {\n+    &St as &Tr;\n+}"}, {"sha": "772310d47335f0fcce37d795806cba825001a899", "filename": "src/test/run-pass/trait-where-clause-vs-impl.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-where-clause-vs-impl.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when there is a conditional (but blanket) impl and a\n+// where clause, we don't get confused in trait resolution.\n+//\n+// Issue #18453.\n+\n+use std::rc::Rc;\n+\n+pub trait Foo<M> {\n+    fn foo(&mut self, msg: M);\n+}\n+\n+pub trait Bar<M> {\n+    fn dummy(&self) -> M;\n+}\n+\n+impl<M, F: Bar<M>> Foo<M> for F {\n+    fn foo(&mut self, msg: M) {\n+    }\n+}\n+\n+pub struct Both<M, F> {\n+    inner: Rc<(M, F)>,\n+}\n+\n+impl<M, F: Foo<M>> Clone for Both<M, F> {\n+    fn clone(&self) -> Both<M, F> {\n+        Both { inner: self.inner.clone() }\n+    }\n+}\n+\n+fn repro1<M, F: Foo<M>>(_both: Both<M, F>) {\n+}\n+\n+fn repro2<M, F: Foo<M>>(msg: M, foo: F) {\n+    let both = Both { inner: Rc::new((msg, foo)) };\n+    repro1(both.clone()); // <--- This clone causes problem\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "449b3099dfa4dd2e2973e25ee63062845e406218", "filename": "src/test/run-pass/while-let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b11b706545ec986b0416a14383170c60004644a5/src%2Ftest%2Frun-pass%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-let.rs?ref=b11b706545ec986b0416a14383170c60004644a5", "patch": "@@ -10,10 +10,10 @@\n \n #![feature(while_let)]\n \n-use std::collections::PriorityQueue;\n+use std::collections::BinaryHeap;\n \n-fn make_pq() -> PriorityQueue<int> {\n-    PriorityQueue::from_vec(vec![1i,2,3])\n+fn make_pq() -> BinaryHeap<int> {\n+    BinaryHeap::from_vec(vec![1i,2,3])\n }\n \n pub fn main() {"}]}