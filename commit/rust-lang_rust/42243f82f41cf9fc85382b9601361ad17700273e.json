{"sha": "42243f82f41cf9fc85382b9601361ad17700273e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMjQzZjgyZjQxY2Y5ZmM4NTM4MmI5NjAxMzYxYWQxNzcwMDI3M2U=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-08-01T19:46:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-01T19:46:23Z"}, "message": "Rollup merge of #52799 - Mark-Simulacrum:attr-id-bitvecs, r=michaelwoerister\n\nUse BitVector for global sets of AttrId", "tree": {"sha": "2d5c03ab5ca09dbfc8702376bf002d46e6d0d7d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d5c03ab5ca09dbfc8702376bf002d46e6d0d7d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42243f82f41cf9fc85382b9601361ad17700273e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbYg4QCRBK7hj4Ov3rIwAAdHIIAKLu05Vq0SciVTsytYnwjw3P\nGqGpdVp4ILvmBQosbRUwttEKxR2KH2fE/sOtb8TICBCT+QPETBhHmX09l7YoO8Cm\nUtMu2XfuGBYzJDUDZPiVi+/SRAZYVPbOgBj8cdtfQgd/SegiYgA4Mc2+p3ZcGF8I\nK6VNbglwEmczZPWi+GNPAb00BEM0rGtM8kL32bCubkv+7COHkVR+kR01IMK92YV9\n8mm7JnF/4rdGk0S5DSC+WcW2WVXkLEQt4+eUk/ovxp0SBsdfxAP/1LRdiKuC5qO6\nr7FVhoFfVKvxLLcauhMlEbw8K2xvrV2OOHdQBnNUeJ9GikeqpEPV19CtUXwwUJU=\n=RVN0\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d5c03ab5ca09dbfc8702376bf002d46e6d0d7d5\nparent 334da29e9841a2bc6fbea0991d6e984ec669a20f\nparent 9bc4fbb10a1517c2ac5a4c9b0ae3ac6559c90a0d\nauthor Pietro Albini <pietro@pietroalbini.org> 1533152783 +0200\ncommitter GitHub <noreply@github.com> 1533152783 +0200\n\nRollup merge of #52799 - Mark-Simulacrum:attr-id-bitvecs, r=michaelwoerister\n\nUse BitVector for global sets of AttrId\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42243f82f41cf9fc85382b9601361ad17700273e", "html_url": "https://github.com/rust-lang/rust/commit/42243f82f41cf9fc85382b9601361ad17700273e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42243f82f41cf9fc85382b9601361ad17700273e/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "334da29e9841a2bc6fbea0991d6e984ec669a20f", "url": "https://api.github.com/repos/rust-lang/rust/commits/334da29e9841a2bc6fbea0991d6e984ec669a20f", "html_url": "https://github.com/rust-lang/rust/commit/334da29e9841a2bc6fbea0991d6e984ec669a20f"}, {"sha": "9bc4fbb10a1517c2ac5a4c9b0ae3ac6559c90a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc4fbb10a1517c2ac5a4c9b0ae3ac6559c90a0d", "html_url": "https://github.com/rust-lang/rust/commit/9bc4fbb10a1517c2ac5a4c9b0ae3ac6559c90a0d"}], "stats": {"total": 266, "additions": 137, "deletions": 129}, "files": [{"sha": "c178a9063c9acd09fa1131c52e44831ed6e6ed33", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n \n use super::*;\n \n@@ -32,7 +32,7 @@ use super::*;\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector<BasicBlock>,\n+    visited: BitArray<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n }\n \n@@ -42,7 +42,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n \n         Preorder {\n             mir,\n-            visited: BitVector::new(mir.basic_blocks().len()),\n+            visited: BitArray::new(mir.basic_blocks().len()),\n             worklist,\n         }\n     }\n@@ -104,15 +104,15 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector<BasicBlock>,\n+    visited: BitArray<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir,\n-            visited: BitVector::new(mir.basic_blocks().len()),\n+            visited: BitArray::new(mir.basic_blocks().len()),\n             visit_stack: Vec::new()\n         };\n "}, {"sha": "35184ca6a2559cc3c3f2527db555a3addb414fc3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -45,7 +45,7 @@ use middle::lang_items;\n use mir::interpret::{GlobalId};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use std::iter;\n use std::cmp;\n use std::fmt;\n@@ -3056,7 +3056,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitVector::new(substs_a.types().count());\n+                let mut ty_params = BitArray::new(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {"}, {"sha": "a76f1d50fa7bf89551717ec1eb9164b44837c1f8", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -21,7 +21,7 @@ use libc::c_uint;\n \n use syntax_pos::Pos;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n@@ -64,7 +64,7 @@ pub fn create_mir_scopes(\n     };\n \n     // Find all the scopes with variables defined in them.\n-    let mut has_variables = BitVector::new(mir.source_scopes.len());\n+    let mut has_variables = BitArray::new(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n         has_variables.insert(decl.visibility_scope);\n@@ -81,7 +81,7 @@ pub fn create_mir_scopes(\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n                   mir: &Mir,\n-                  has_variables: &BitVector<SourceScope>,\n+                  has_variables: &BitArray<SourceScope>,\n                   debug_context: &FunctionDebugContextData<'ll>,\n                   scope: SourceScope,\n                   scopes: &mut IndexVec<SourceScope, MirDebugScope<'ll>>) {"}, {"sha": "993138aee1cec90e9560c9a5859baec62c96f3bf", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -11,7 +11,7 @@\n //! An analysis to determine which locals require allocas and\n //! which do not.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n+pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitArray<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -54,7 +54,7 @@ pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n     fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitVector<mir::Local>,\n+    non_ssa_locals: BitArray<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n@@ -67,7 +67,7 @@ impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n             fx,\n             dominators: fx.mir.dominators(),\n-            non_ssa_locals: BitVector::new(fx.mir.local_decls.len()),\n+            non_ssa_locals: BitArray::new(fx.mir.local_decls.len()),\n             first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n "}, {"sha": "a099cb5c64b211fcf1087717dfe5325db1e15099", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -31,7 +31,7 @@ use syntax::symbol::keywords;\n \n use std::iter;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n pub use self::constant::codegen_static_initializer;\n@@ -323,7 +323,7 @@ pub fn codegen_mir(\n     debuginfo::start_emitting_source_locations(&fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitVector::new(mir.basic_blocks().len());\n+    let mut visited = BitArray::new(mir.basic_blocks().len());\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in rpo {\n@@ -417,7 +417,7 @@ fn arg_local_refs(\n     bx: &Builder<'a, 'll, 'tcx>,\n     fx: &FunctionCx<'a, 'll, 'tcx>,\n     scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope<'ll>>,\n-    memory_locals: &BitVector<mir::Local>,\n+    memory_locals: &BitArray<mir::Local>,\n ) -> Vec<LocalRef<'ll, 'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();"}, {"sha": "6e8a45d034250e2d4f7b195aa45c11d564c1561d", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 73, "deletions": 55, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -9,24 +9,74 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n-use std::iter::FromIterator;\n use std::marker::PhantomData;\n \n type Word = u128;\n const WORD_BITS: usize = 128;\n \n-/// A very simple BitVector type.\n+/// A very simple BitArray type.\n+///\n+/// It does not support resizing after creation; use `BitVector` for that.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector<C: Idx> {\n+pub struct BitArray<C: Idx> {\n     data: Vec<Word>,\n     marker: PhantomData<C>,\n }\n \n+#[derive(Clone, Debug, PartialEq)]\n+pub struct BitVector<C: Idx> {\n+    data: BitArray<C>,\n+}\n+\n impl<C: Idx> BitVector<C> {\n+    pub fn grow(&mut self, num_bits: C) {\n+        self.data.grow(num_bits)\n+    }\n+\n+    pub fn new() -> BitVector<C> {\n+        BitVector {\n+            data: BitArray::new(0),\n+        }\n+    }\n+\n+    pub fn with_capacity(bits: usize) -> BitVector<C> {\n+        BitVector {\n+            data: BitArray::new(bits),\n+        }\n+    }\n+\n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn insert(&mut self, bit: C) -> bool {\n+        self.grow(bit);\n+        self.data.insert(bit)\n+    }\n+\n     #[inline]\n-    pub fn new(num_bits: usize) -> BitVector<C> {\n+    pub fn contains(&self, bit: C) -> bool {\n+        let (word, mask) = word_mask(bit);\n+        if let Some(word) = self.data.data.get(word) {\n+            (word & mask) != 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<C: Idx> BitArray<C> {\n+    // Do not make this method public, instead switch your use case to BitVector.\n+    #[inline]\n+    fn grow(&mut self, num_bits: C) {\n         let num_words = words(num_bits);\n-        BitVector {\n+        if self.data.len() <= num_words {\n+            self.data.resize(num_words + 1, 0)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn new(num_bits: usize) -> BitArray<C> {\n+        let num_words = words(num_bits);\n+        BitArray {\n             data: vec![0; num_words],\n             marker: PhantomData,\n         }\n@@ -54,7 +104,7 @@ impl<C: Idx> BitVector<C> {\n     ///\n     /// The two vectors must have the same length.\n     #[inline]\n-    pub fn contains_all(&self, other: &BitVector<C>) -> bool {\n+    pub fn contains_all(&self, other: &BitArray<C>) -> bool {\n         assert_eq!(self.data.len(), other.data.len());\n         self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n     }\n@@ -94,7 +144,7 @@ impl<C: Idx> BitVector<C> {\n     }\n \n     #[inline]\n-    pub fn merge(&mut self, all: &BitVector<C>) -> bool {\n+    pub fn merge(&mut self, all: &BitArray<C>) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n@@ -107,18 +157,10 @@ impl<C: Idx> BitVector<C> {\n         changed\n     }\n \n-    #[inline]\n-    pub fn grow(&mut self, num_bits: C) {\n-        let num_words = words(num_bits);\n-        if self.data.len() < num_words {\n-            self.data.resize(num_words, 0)\n-        }\n-    }\n-\n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitVectorIter<'a, C> {\n-        BitVectorIter {\n+    pub fn iter<'a>(&'a self) -> BitIter<'a, C> {\n+        BitIter {\n             iter: self.data.iter(),\n             current: 0,\n             idx: 0,\n@@ -127,14 +169,14 @@ impl<C: Idx> BitVector<C> {\n     }\n }\n \n-pub struct BitVectorIter<'a, C: Idx> {\n+pub struct BitIter<'a, C: Idx> {\n     iter: ::std::slice::Iter<'a, Word>,\n     current: Word,\n     idx: usize,\n     marker: PhantomData<C>\n }\n \n-impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n+impl<'a, C: Idx> Iterator for BitIter<'a, C> {\n     type Item = C;\n     fn next(&mut self) -> Option<C> {\n         while self.current == 0 {\n@@ -163,30 +205,6 @@ impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n     }\n }\n \n-impl<C: Idx> FromIterator<bool> for BitVector<C> {\n-    fn from_iter<I>(iter: I) -> BitVector<C>\n-    where\n-        I: IntoIterator<Item = bool>,\n-    {\n-        let iter = iter.into_iter();\n-        let (len, _) = iter.size_hint();\n-        // Make the minimum length for the bitvector WORD_BITS bits since that's\n-        // the smallest non-zero size anyway.\n-        let len = if len < WORD_BITS { WORD_BITS } else { len };\n-        let mut bv = BitVector::new(len);\n-        for (idx, val) in iter.enumerate() {\n-            if idx > len {\n-                bv.grow(C::new(idx));\n-            }\n-            if val {\n-                bv.insert(C::new(idx));\n-            }\n-        }\n-\n-        bv\n-    }\n-}\n-\n /// A \"bit matrix\" is basically a matrix of booleans represented as\n /// one gigantic bitvector. In other words, it is as if you have\n /// `rows` bitvectors, each of length `columns`.\n@@ -288,9 +306,9 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: R) -> BitVectorIter<'a, C> {\n+    pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n         let (start, end) = self.range(row);\n-        BitVectorIter {\n+        BitIter {\n             iter: self.vector[start..end].iter(),\n             current: 0,\n             idx: 0,\n@@ -308,7 +326,7 @@ where\n     C: Idx,\n {\n     columns: usize,\n-    vector: IndexVec<R, BitVector<C>>,\n+    vector: IndexVec<R, BitArray<C>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -323,7 +341,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     fn ensure_row(&mut self, row: R) {\n         let columns = self.columns;\n         self.vector\n-            .ensure_contains_elem(row, || BitVector::new(columns));\n+            .ensure_contains_elem(row, || BitArray::new(columns));\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n@@ -361,7 +379,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &BitVector<C>) -> bool {\n+    pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n         self.ensure_row(into);\n         self.vector[into].merge(from)\n     }\n@@ -388,11 +406,11 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector<C>)> + 'a {\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitArray<C>)> + 'a {\n         self.vector.iter_enumerated()\n     }\n \n-    pub fn row(&self, row: R) -> Option<&BitVector<C>> {\n+    pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n         self.vector.get(row)\n     }\n }\n@@ -412,7 +430,7 @@ fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n \n #[test]\n fn bitvec_iter_works() {\n-    let mut bitvec: BitVector<usize> = BitVector::new(100);\n+    let mut bitvec: BitArray<usize> = BitArray::new(100);\n     bitvec.insert(1);\n     bitvec.insert(10);\n     bitvec.insert(19);\n@@ -430,7 +448,7 @@ fn bitvec_iter_works() {\n \n #[test]\n fn bitvec_iter_works_2() {\n-    let mut bitvec: BitVector<usize> = BitVector::new(319);\n+    let mut bitvec: BitArray<usize> = BitArray::new(319);\n     bitvec.insert(0);\n     bitvec.insert(127);\n     bitvec.insert(191);\n@@ -441,8 +459,8 @@ fn bitvec_iter_works_2() {\n \n #[test]\n fn union_two_vecs() {\n-    let mut vec1: BitVector<usize> = BitVector::new(65);\n-    let mut vec2: BitVector<usize> = BitVector::new(65);\n+    let mut vec1: BitArray<usize> = BitArray::new(65);\n+    let mut vec2: BitArray<usize> = BitArray::new(65);\n     assert!(vec1.insert(3));\n     assert!(!vec1.insert(3));\n     assert!(vec2.insert(5));\n@@ -458,7 +476,7 @@ fn union_two_vecs() {\n \n #[test]\n fn grow() {\n-    let mut vec1: BitVector<usize> = BitVector::new(65);\n+    let mut vec1: BitVector<usize> = BitVector::with_capacity(65);\n     for index in 0..65 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));"}, {"sha": "cf9403db658f4fa9fcb5a6dcb4cec900de1b5b76", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -30,7 +30,7 @@\n //! the field `next_edge`). Each of those fields is an array that should\n //! be indexed by the direction (see the type `Direction`).\n \n-use bitvec::BitVector;\n+use bitvec::BitArray;\n use std::fmt::Debug;\n use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n@@ -266,7 +266,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         direction: Direction,\n         entry_node: NodeIndex,\n     ) -> Vec<NodeIndex> {\n-        let mut visited = BitVector::new(self.len_nodes());\n+        let mut visited = BitArray::new(self.len_nodes());\n         let mut stack = vec![];\n         let mut result = Vec::with_capacity(self.len_nodes());\n         let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n@@ -348,7 +348,7 @@ where\n {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitVector<usize>,\n+    visited: BitArray<usize>,\n     direction: Direction,\n }\n \n@@ -358,7 +358,7 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n         start_node: NodeIndex,\n         direction: Direction,\n     ) -> Self {\n-        let mut visited = BitVector::new(graph.len_nodes());\n+        let mut visited = BitArray::new(graph.len_nodes());\n         visited.insert(start_node.node_id());\n         DepthFirstTraversal {\n             graph,"}, {"sha": "6b6ec749bcbe6efd1124d6f529264564a4aab661", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -18,7 +18,7 @@ use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::scope::{CachedBlock, DropKind};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::hir;\n@@ -496,7 +496,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitVector<usize>,\n+        variants: BitArray<usize>,\n     },\n \n     // test the branches of enum"}, {"sha": "7106e02284da3888cd219b61d17fe23ce5076bb6", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -19,7 +19,7 @@ use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n                         adt_def: adt_def.clone(),\n-                        variants: BitVector::new(adt_def.variants.len()),\n+                        variants: BitArray::new(adt_def.variants.len()),\n                     },\n                 }\n             }\n@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitVector<usize>)\n+                                        variants: &mut BitArray<usize>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {"}, {"sha": "6283ee9cfe648ed9f60ac54bad1df188722ba6c8", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> InliningMap<'tcx> {\n         InliningMap {\n             index: FxHashMap(),\n             targets: Vec::new(),\n-            inlines: BitVector::new(1024),\n+            inlines: BitVector::with_capacity(1024),\n         }\n     }\n "}, {"sha": "85115427edae9dc00d0cfd7bf8e4f90f3ad79eb5", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -14,7 +14,7 @@ use rustc::hir;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Traverse the MIR manually so we can account for the effects of\n         // inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n-        let mut visited = BitVector::new(callee_mir.basic_blocks().len());\n+        let mut visited = BitArray::new(callee_mir.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) { continue; }\n             let blk = &callee_mir.basic_blocks()[bb];"}, {"sha": "208679d2aa08adf3aa50a4c66c13b475c27ed8ea", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -14,7 +14,7 @@\n //! The Qualif flags below can be used to also provide better\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::FxHashSet;\n@@ -116,7 +116,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     local_qualif: IndexVec<Local, Option<Qualif>>,\n     qualif: Qualif,\n-    const_fn_arg_vars: BitVector<Local>,\n+    const_fn_arg_vars: BitArray<Local>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env,\n             local_qualif,\n             qualif: Qualif::empty(),\n-            const_fn_arg_vars: BitVector::new(mir.local_decls.len()),\n+            const_fn_arg_vars: BitArray::new(mir.local_decls.len()),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -284,7 +284,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n         let mir = self.mir;\n \n-        let mut seen_blocks = BitVector::new(mir.basic_blocks().len());\n+        let mut seen_blocks = BitArray::new(mir.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());"}, {"sha": "04a7a81eb126fc7f6e492ec6887e613fc678818c", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n \n@@ -45,7 +45,7 @@ impl RemoveNoopLandingPads {\n         &self,\n         bb: BasicBlock,\n         mir: &Mir,\n-        nop_landing_pads: &BitVector<BasicBlock>,\n+        nop_landing_pads: &BitArray<BasicBlock>,\n     ) -> bool {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n@@ -111,7 +111,7 @@ impl RemoveNoopLandingPads {\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitVector::new(mir.basic_blocks().len());\n+        let mut nop_landing_pads = BitArray::new(mir.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B."}, {"sha": "6e8471c672934e127bac884eeefcc7066bd9d584", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -37,7 +37,7 @@\n //! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n //! return.\n \n-use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::bitvec::BitArray;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n@@ -249,7 +249,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n }\n \n pub fn remove_dead_blocks(mir: &mut Mir) {\n-    let mut seen = BitVector::new(mir.basic_blocks().len());\n+    let mut seen = BitArray::new(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());\n     }\n@@ -285,7 +285,7 @@ impl MirPass for SimplifyLocals {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n+        let mut marker = DeclMarker { locals: BitArray::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n         marker.locals.insert(RETURN_PLACE);\n@@ -310,7 +310,7 @@ impl MirPass for SimplifyLocals {\n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n fn make_local_map<'tcx, V>(\n     vec: &mut IndexVec<Local, V>,\n-    mask: BitVector<Local>,\n+    mask: BitArray<Local>,\n ) -> IndexVec<Local, Option<Local>> {\n     let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n     let mut used = Local::new(0);\n@@ -326,7 +326,7 @@ fn make_local_map<'tcx, V>(\n }\n \n struct DeclMarker {\n-    pub locals: BitVector<Local>,\n+    pub locals: BitArray<Local>,\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {"}, {"sha": "28c1e4324de7a3070c90f2c4cce5a694dc3ce2e8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -23,6 +23,7 @@ use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n use rustc_data_structures::indexed_vec;\n+use rustc_data_structures::indexed_vec::Idx;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n@@ -1910,9 +1911,18 @@ pub enum AttrStyle {\n     Inner,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialOrd, Ord, Copy)]\n pub struct AttrId(pub usize);\n \n+impl Idx for AttrId {\n+    fn new(idx: usize) -> Self {\n+        AttrId(idx)\n+    }\n+    fn index(self) -> usize {\n+        self.0\n+    }\n+}\n+\n /// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "7fbc5d4c41a50929331da18fe4a386efb7c49cb5", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -41,51 +41,27 @@ use std::iter;\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let mut slot = globals.used_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        if slot.len() <= idx {\n-            slot.resize(idx + 1, 0);\n-        }\n-        slot[idx] |= 1 << shift;\n+        globals.used_attrs.lock().insert(attr.id);\n     });\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let slot = globals.used_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        slot.get(idx).map(|bits| bits & (1 << shift) != 0)\n-            .unwrap_or(false)\n+        globals.used_attrs.lock().contains(attr.id)\n     })\n }\n \n pub fn mark_known(attr: &Attribute) {\n     debug!(\"Marking {:?} as known.\", attr);\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let mut slot = globals.known_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        if slot.len() <= idx {\n-            slot.resize(idx + 1, 0);\n-        }\n-        slot[idx] |= 1 << shift;\n+        globals.known_attrs.lock().insert(attr.id);\n     });\n }\n \n pub fn is_known(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.id;\n     GLOBALS.with(|globals| {\n-        let slot = globals.known_attrs.lock();\n-        let idx = (id / 64) as usize;\n-        let shift = id % 64;\n-        slot.get(idx).map(|bits| bits & (1 << shift) != 0)\n-            .unwrap_or(false)\n+        globals.known_attrs.lock().contains(attr.id)\n     })\n }\n "}, {"sha": "0c105865e0c2e13e3c916d8c1a7f0b9af7d55d8f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42243f82f41cf9fc85382b9601361ad17700273e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=42243f82f41cf9fc85382b9601361ad17700273e", "patch": "@@ -43,6 +43,8 @@ extern crate rustc_target;\n extern crate serialize as rustc_serialize; // used by deriving\n \n use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::bitvec::BitVector;\n+use ast::AttrId;\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n@@ -75,16 +77,18 @@ macro_rules! unwrap_or {\n }\n \n pub struct Globals {\n-    used_attrs: Lock<Vec<u64>>,\n-    known_attrs: Lock<Vec<u64>>,\n+    used_attrs: Lock<BitVector<AttrId>>,\n+    known_attrs: Lock<BitVector<AttrId>>,\n     syntax_pos_globals: syntax_pos::Globals,\n }\n \n impl Globals {\n     fn new() -> Globals {\n         Globals {\n-            used_attrs: Lock::new(Vec::new()),\n-            known_attrs: Lock::new(Vec::new()),\n+            // We have no idea how many attributes their will be, so just\n+            // initiate the vectors with 0 bits. We'll grow them as necessary.\n+            used_attrs: Lock::new(BitVector::new()),\n+            known_attrs: Lock::new(BitVector::new()),\n             syntax_pos_globals: syntax_pos::Globals::new(),\n         }\n     }"}]}