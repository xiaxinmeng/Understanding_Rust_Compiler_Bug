{"sha": "28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZDczYTNlZTNlMmMzMmYyNzY4ZDFjYmM5YjQyY2I2MzQ3MmU5ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T06:39:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-23T06:39:15Z"}, "message": "Auto merge of #80099 - jyn514:visibility-on-demand, r=GuillaumeGomez\n\nRemove `DefPath` from `Visibility` and calculate it on demand\n\nDepends on #80090 and should not be merged before. Helps with https://github.com/rust-lang/rust/issues/79103 and https://github.com/rust-lang/rust/issues/76382.\n\ncc https://github.com/rust-lang/rust/pull/80014#issuecomment-746810284 - `@nnethercote` I figured it out! It was simpler than I expected :)\n\nThis brings the size of `clean::Visibility` down from 40 bytes to 8.\n\nNote that this does *not* remove `clean::Visibility`, even though it's now basically the same as `ty::Visibility`, because the `Invsible` variant means something different from `Inherited` and I thought it would be be confusing to merge the two. See the new comments on `impl Clean for ty::Visibility` for details.", "tree": {"sha": "6f1892c2f049651ca45ca611588a2c8defa4855f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f1892c2f049651ca45ca611588a2c8defa4855f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "html_url": "https://github.com/rust-lang/rust/commit/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18b745e9bf3e11ed658b0fc4eb7ddaa8e2178b39", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b745e9bf3e11ed658b0fc4eb7ddaa8e2178b39", "html_url": "https://github.com/rust-lang/rust/commit/18b745e9bf3e11ed658b0fc4eb7ddaa8e2178b39"}, {"sha": "a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976", "html_url": "https://github.com/rust-lang/rust/commit/a2fb4b95ddda1c2d622c809e63aa5e158cfb9976"}], "stats": {"total": 130, "additions": 70, "deletions": 60}, "files": [{"sha": "de53ce8d95c12bbb3f2adac86e871bba82ae2ea7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "patch": "@@ -1777,25 +1777,28 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n             hir::VisibilityKind::Crate(_) => {\n                 let krate = DefId::local(CRATE_DEF_INDEX);\n-                Visibility::Restricted(krate, cx.tcx.def_path(krate))\n+                Visibility::Restricted(krate)\n             }\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_res(cx, path.res);\n-                Visibility::Restricted(did, cx.tcx.def_path(did))\n+                Visibility::Restricted(did)\n             }\n         }\n     }\n }\n \n impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+    fn clean(&self, _cx: &DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n+            // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n+            // while rustdoc really does mean inherited. That means that for enum variants, such as\n+            // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n+            // This is the main reason `impl Clean for hir::Visibility` still exists; various parts of clean\n+            // override `tcx.visibility` explicitly to make sure this distinction is captured.\n             ty::Visibility::Invisible => Visibility::Inherited,\n-            ty::Visibility::Restricted(module) => {\n-                Visibility::Restricted(module, cx.tcx.def_path(module))\n-            }\n+            ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n         }\n     }\n }\n@@ -2296,14 +2299,14 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\",\n-                    vis.print_with_space(),\n+                    vis.print_with_space(cx.tcx),\n                     name,\n                     matchers.iter().map(|span| span.to_src(cx)).collect::<String>(),\n                 )\n             } else {\n                 format!(\n                     \"{}macro {} {{\\n{}}}\",\n-                    vis.print_with_space(),\n+                    vis.print_with_space(cx.tcx),\n                     name,\n                     matchers\n                         .iter()"}, {"sha": "9b2003911a70309cfc63c6369851c79f91acbd9d", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "patch": "@@ -1573,11 +1573,11 @@ impl From<hir::PrimTy> for PrimitiveType {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n crate enum Visibility {\n     Public,\n     Inherited,\n-    Restricted(DefId, rustc_hir::definitions::DefPath),\n+    Restricted(DefId),\n }\n \n impl Visibility {"}, {"sha": "7b0b219570b983586b9ae4b58108c310a14ab15b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "patch": "@@ -11,6 +11,7 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n@@ -1084,18 +1085,18 @@ impl Function<'_> {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n+    crate fn print_with_space<'tcx>(self, tcx: TyCtxt<'tcx>) -> impl fmt::Display + 'tcx {\n         use rustc_span::symbol::kw;\n \n-        display_fn(move |f| match *self {\n+        display_fn(move |f| match self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            // If this is `pub(crate)`, `path` will be empty.\n-            clean::Visibility::Restricted(did, _) if did.index == CRATE_DEF_INDEX => {\n+            clean::Visibility::Restricted(did) if did.index == CRATE_DEF_INDEX => {\n                 write!(f, \"pub(crate) \")\n             }\n-            clean::Visibility::Restricted(did, ref path) => {\n+            clean::Visibility::Restricted(did) => {\n                 f.write_str(\"pub(\")?;\n+                let path = tcx.def_path(did);\n                 debug!(\"path={:?}\", path);\n                 let first_name =\n                     path.data[0].data.get_opt_name().expect(\"modules are always named\");"}, {"sha": "97e7c38ecb8c50853e64a2639f7ffd7d5be2d44b", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "patch": "@@ -2157,14 +2157,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(),\n+                        myitem.visibility.print_with_space(cx.tcx()),\n                         anchor(myitem.def_id, &*src.as_str()),\n                         name\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(),\n+                        myitem.visibility.print_with_space(cx.tcx()),\n                         anchor(myitem.def_id, &*name.as_str())\n                     ),\n                 }\n@@ -2175,7 +2175,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(),\n+                    myitem.visibility.print_with_space(cx.tcx()),\n                     import.print()\n                 );\n             }\n@@ -2392,7 +2392,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(),\n     );\n@@ -2426,7 +2426,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print()\n@@ -2437,7 +2437,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n@@ -2452,7 +2452,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(),\n+        vis = it.visibility.print_with_space(cx.tcx()),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n@@ -2578,7 +2578,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(),\n+            it.visibility.print_with_space(cx.tcx()),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -2598,21 +2598,21 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             // FIXME: we should be using a derived_id for the Anchors here\n             write!(w, \"{{\\n\");\n             for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n             }\n             if !types.is_empty() && !consts.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n             }\n             if !consts.is_empty() && !required.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n             for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 write!(w, \";\\n\");\n \n                 if pos < required.len() - 1 {\n@@ -2623,7 +2623,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                 w.write_str(\"\\n\");\n             }\n             for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n                 match m.kind {\n                     clean::MethodItem(ref inner, _)\n                         if !inner.generics.where_predicates.is_empty() =>\n@@ -2672,7 +2672,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         write!(w, \"<h3 id=\\\"{id}\\\" class=\\\"method\\\"><code>\", id = id,);\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t, cx.tcx());\n         write_srclink(cx, m, w, cache);\n@@ -2890,12 +2890,13 @@ fn assoc_const(\n     _default: Option<&String>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         naive_assoc_href(it, link),\n         it.name.as_ref().unwrap(),\n         ty.print()\n@@ -2983,6 +2984,7 @@ fn render_assoc_item(\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n     parent: ItemType,\n+    cx: &Context<'_>,\n ) {\n     fn method(\n         w: &mut Buffer,\n@@ -2992,6 +2994,7 @@ fn render_assoc_item(\n         d: &clean::FnDecl,\n         link: AssocItemLink<'_>,\n         parent: ItemType,\n+        cx: &Context<'_>,\n     ) {\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n@@ -3012,7 +3015,7 @@ fn render_assoc_item(\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            meth.visibility.print_with_space(),\n+            meth.visibility.print_with_space(cx.tcx()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3034,7 +3037,7 @@ fn render_assoc_item(\n             \"{}{}{}{}{}{}{}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{spotlight}{where_clause}\",\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            meth.visibility.print_with_space(),\n+            meth.visibility.print_with_space(cx.tcx()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3050,9 +3053,11 @@ fn render_assoc_item(\n     }\n     match item.kind {\n         clean::StrippedItem(..) => {}\n-        clean::TyMethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n+        clean::TyMethodItem(ref m) => {\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx)\n+        }\n         clean::MethodItem(ref m, _) => {\n-            method(w, item, m.header, &m.generics, &m.decl, link, parent)\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent, cx)\n         }\n         clean::AssocConstItem(ref ty, ref default) => assoc_const(\n             w,\n@@ -3061,6 +3066,7 @@ fn render_assoc_item(\n             default.as_ref(),\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            cx,\n         ),\n         clean::AssocTypeItem(ref bounds, ref default) => assoc_type(\n             w,\n@@ -3084,7 +3090,7 @@ fn item_struct(\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust struct\\\">\");\n         render_attributes(w, it, true);\n-        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true);\n+        render_struct(w, it, Some(&s.generics), s.struct_type, &s.fields, \"\", true, cx);\n         write!(w, \"</pre>\")\n     });\n \n@@ -3134,7 +3140,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust union\\\">\");\n         render_attributes(w, it, true);\n-        render_union(w, it, Some(&s.generics), &s.fields, \"\", true);\n+        render_union(w, it, Some(&s.generics), &s.fields, \"\", true, cx);\n         write!(w, \"</pre>\")\n     });\n \n@@ -3183,7 +3189,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(),\n+            it.visibility.print_with_space(cx.tcx()),\n             it.name.as_ref().unwrap(),\n             e.generics.print(),\n             WhereClause { gens: &e.generics, indent: 0, end_newline: true }\n@@ -3209,7 +3215,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                             write!(w, \")\");\n                         }\n                         clean::VariantKind::Struct(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false);\n+                            render_struct(w, v, None, s.struct_type, &s.fields, \"    \", false, cx);\n                         }\n                     },\n                     _ => unreachable!(),\n@@ -3353,11 +3359,12 @@ fn render_struct(\n     fields: &[clean::Item],\n     tab: &str,\n     structhead: bool,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3377,7 +3384,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(),\n+                        field.visibility.print_with_space(cx.tcx()),\n                         field.name.as_ref().unwrap(),\n                         ty.print()\n                     );\n@@ -3406,7 +3413,7 @@ fn render_struct(\n                 match field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", field.visibility.print_with_space(), ty.print())\n+                        write!(w, \"{}{}\", field.visibility.print_with_space(cx.tcx()), ty.print())\n                     }\n                     _ => unreachable!(),\n                 }\n@@ -3434,11 +3441,12 @@ fn render_union(\n     fields: &[clean::Item],\n     tab: &str,\n     structhead: bool,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3453,7 +3461,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(),\n+                field.visibility.print_with_space(cx.tcx()),\n                 field.name.as_ref().unwrap(),\n                 ty.print(),\n                 tab\n@@ -3845,7 +3853,7 @@ fn render_impl(\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                     write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, extra_class);\n                     write!(w, \"<code>\");\n-                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n+                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl, cx);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(\n                         w,\n@@ -3867,7 +3875,7 @@ fn render_impl(\n             clean::AssocConstItem(ref ty, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n-                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n+                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\", cx);\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(\n                     w,\n@@ -4092,7 +4100,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache:\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(),\n+        it.visibility.print_with_space(cx.tcx()),\n         it.name.as_ref().unwrap(),\n     );\n "}, {"sha": "3b7ac624ccd7b3e8c82cdf4ca86721259774d3cb", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=28d73a3ee3e2c32f2768d1cbc9b42cb63472e9e9", "patch": "@@ -26,7 +26,7 @@ impl JsonRenderer<'_> {\n                 crate_id: def_id.krate.as_u32(),\n                 name: name.map(|sym| sym.to_string()),\n                 source: self.convert_span(source),\n-                visibility: visibility.into(),\n+                visibility: self.convert_visibility(visibility),\n                 docs: attrs.collapsed_doc_value().unwrap_or_default(),\n                 links: attrs\n                     .links\n@@ -66,31 +66,29 @@ impl JsonRenderer<'_> {\n             _ => None,\n         }\n     }\n-}\n-\n-impl From<rustc_attr::Deprecation> for Deprecation {\n-    fn from(deprecation: rustc_attr::Deprecation) -> Self {\n-        #[rustfmt::skip]\n-        let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n-        Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n-    }\n-}\n \n-impl From<clean::Visibility> for Visibility {\n-    fn from(v: clean::Visibility) -> Self {\n+    fn convert_visibility(&self, v: clean::Visibility) -> Visibility {\n         use clean::Visibility::*;\n         match v {\n             Public => Visibility::Public,\n             Inherited => Visibility::Default,\n-            Restricted(did, _) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n-            Restricted(did, path) => Visibility::Restricted {\n+            Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n+            Restricted(did) => Visibility::Restricted {\n                 parent: did.into(),\n-                path: path.to_string_no_crate_verbose(),\n+                path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n     }\n }\n \n+impl From<rustc_attr::Deprecation> for Deprecation {\n+    fn from(deprecation: rustc_attr::Deprecation) -> Self {\n+        #[rustfmt::skip]\n+        let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n+        Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n+    }\n+}\n+\n impl From<clean::GenericArgs> for GenericArgs {\n     fn from(args: clean::GenericArgs) -> Self {\n         use clean::GenericArgs::*;"}]}