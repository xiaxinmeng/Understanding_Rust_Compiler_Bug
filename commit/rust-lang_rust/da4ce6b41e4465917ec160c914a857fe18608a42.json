{"sha": "da4ce6b41e4465917ec160c914a857fe18608a42", "node_id": "C_kwDOAAsO6NoAKGRhNGNlNmI0MWU0NDY1OTE3ZWMxNjBjOTE0YTg1N2ZlMTg2MDhhNDI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-06T17:57:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-10T05:35:14Z"}, "message": "Skip doc link resolution for some crate types and non-exported items", "tree": {"sha": "d076ef1c6e593d1f0097dcf29dec78028d13720c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d076ef1c6e593d1f0097dcf29dec78028d13720c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da4ce6b41e4465917ec160c914a857fe18608a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da4ce6b41e4465917ec160c914a857fe18608a42", "html_url": "https://github.com/rust-lang/rust/commit/da4ce6b41e4465917ec160c914a857fe18608a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da4ce6b41e4465917ec160c914a857fe18608a42/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0866272a2f3e8c4211b76bc314fb7b878ed823", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0866272a2f3e8c4211b76bc314fb7b878ed823", "html_url": "https://github.com/rust-lang/rust/commit/3b0866272a2f3e8c4211b76bc314fb7b878ed823"}], "stats": {"total": 125, "additions": 106, "deletions": 19}, "files": [{"sha": "ca2a99971c3167b2a674f6e750c36949440cdf5b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=da4ce6b41e4465917ec160c914a857fe18608a42", "patch": "@@ -24,13 +24,13 @@ use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_lifetime::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n-use rustc_session::config::CrateType;\n+use rustc_session::config::{CrateType, ResolveDocLinks};\n use rustc_session::lint;\n+use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};\n use smallvec::{smallvec, SmallVec};\n \n-use rustc_span::source_map::{respan, Spanned};\n use std::assert_matches::debug_assert_matches;\n use std::borrow::Cow;\n use std::collections::{hash_map::Entry, BTreeSet};\n@@ -494,6 +494,30 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n+/// At this point for most items we can answer whether that item is exported or not,\n+/// but some items like impls require type information to determine exported-ness, so we make a\n+/// conservative estimate for them (e.g. based on nominal visibility).\n+#[derive(Clone, Copy)]\n+enum MaybeExported<'a> {\n+    Ok(NodeId),\n+    Impl(Option<DefId>),\n+    ImplItem(Result<DefId, &'a Visibility>),\n+}\n+\n+impl MaybeExported<'_> {\n+    fn eval(self, r: &Resolver<'_>) -> bool {\n+        let def_id = match self {\n+            MaybeExported::Ok(node_id) => Some(r.local_def_id(node_id)),\n+            MaybeExported::Impl(Some(trait_def_id)) | MaybeExported::ImplItem(Ok(trait_def_id)) => {\n+                trait_def_id.as_local()\n+            }\n+            MaybeExported::Impl(None) => return true,\n+            MaybeExported::ImplItem(Err(vis)) => return vis.kind.is_pub(),\n+        };\n+        def_id.map_or(true, |def_id| r.effective_visibilities.is_exported(def_id))\n+    }\n+}\n+\n #[derive(Default)]\n struct DiagnosticMetadata<'ast> {\n     /// The current trait's associated items' ident, used for diagnostic suggestions.\n@@ -774,7 +798,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         );\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n-        self.resolve_doc_links(&foreign_item.attrs);\n+        self.resolve_doc_links(&foreign_item.attrs, MaybeExported::Ok(foreign_item.id));\n         match foreign_item.kind {\n             ForeignItemKind::TyAlias(box TyAlias { ref generics, .. }) => {\n                 self.with_generic_param_rib(\n@@ -1165,12 +1189,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n \n     fn visit_variant(&mut self, v: &'ast Variant) {\n-        self.resolve_doc_links(&v.attrs);\n+        self.resolve_doc_links(&v.attrs, MaybeExported::Ok(v.id));\n         visit::walk_variant(self, v)\n     }\n \n     fn visit_field_def(&mut self, f: &'ast FieldDef) {\n-        self.resolve_doc_links(&f.attrs);\n+        self.resolve_doc_links(&f.attrs, MaybeExported::Ok(f.id));\n         visit::walk_field_def(self, f)\n     }\n }\n@@ -2201,8 +2225,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_item(&mut self, item: &'ast Item) {\n         let mod_inner_docs =\n             matches!(item.kind, ItemKind::Mod(..)) && rustdoc::inner_docs(&item.attrs);\n-        if !mod_inner_docs {\n-            self.resolve_doc_links(&item.attrs);\n+        if !mod_inner_docs && !matches!(item.kind, ItemKind::Impl(..)) {\n+            self.resolve_doc_links(&item.attrs, MaybeExported::Ok(item.id));\n         }\n \n         let name = item.ident.name;\n@@ -2249,7 +2273,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 ..\n             }) => {\n                 self.diagnostic_metadata.current_impl_items = Some(impl_items);\n-                self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n+                self.resolve_implementation(\n+                    &item.attrs,\n+                    generics,\n+                    of_trait,\n+                    &self_ty,\n+                    item.id,\n+                    impl_items,\n+                );\n                 self.diagnostic_metadata.current_impl_items = None;\n             }\n \n@@ -2297,7 +2328,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ItemKind::Mod(..) => {\n                 self.with_scope(item.id, |this| {\n                     if mod_inner_docs {\n-                        this.resolve_doc_links(&item.attrs);\n+                        this.resolve_doc_links(&item.attrs, MaybeExported::Ok(item.id));\n                     }\n                     let old_macro_rules = this.parent_scope.macro_rules;\n                     visit::walk_item(this, item);\n@@ -2583,7 +2614,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n         for item in trait_items {\n-            self.resolve_doc_links(&item.attrs);\n+            self.resolve_doc_links(&item.attrs, MaybeExported::Ok(item.id));\n             match &item.kind {\n                 AssocItemKind::Const(_, ty, default) => {\n                     self.visit_ty(ty);\n@@ -2671,6 +2702,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn resolve_implementation(\n         &mut self,\n+        attrs: &[ast::Attribute],\n         generics: &'ast Generics,\n         opt_trait_reference: &'ast Option<TraitRef>,\n         self_type: &'ast Ty,\n@@ -2701,6 +2733,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                 opt_trait_reference.as_ref(),\n                                 self_type,\n                                 |this, trait_id| {\n+                                    this.resolve_doc_links(attrs, MaybeExported::Impl(trait_id));\n+\n                                     let item_def_id = this.r.local_def_id(item_id);\n \n                                     // Register the trait definitions from here.\n@@ -2734,7 +2768,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                 debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                                 let mut seen_trait_items = Default::default();\n                                                 for item in impl_items {\n-                                                    this.resolve_impl_item(&**item, &mut seen_trait_items);\n+                                                    this.resolve_impl_item(&**item, &mut seen_trait_items, trait_id);\n                                                 }\n                                             });\n                                         });\n@@ -2752,9 +2786,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         item: &'ast AssocItem,\n         seen_trait_items: &mut FxHashMap<DefId, Span>,\n+        trait_id: Option<DefId>,\n     ) {\n         use crate::ResolutionError::*;\n-        self.resolve_doc_links(&item.attrs);\n+        self.resolve_doc_links(&item.attrs, MaybeExported::ImplItem(trait_id.ok_or(&item.vis)));\n         match &item.kind {\n             AssocItemKind::Const(_, ty, default) => {\n                 debug!(\"resolve_implementation AssocItemKind::Const\");\n@@ -4183,7 +4218,23 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         res\n     }\n \n-    fn resolve_doc_links(&mut self, attrs: &[Attribute]) {\n+    fn resolve_doc_links(&mut self, attrs: &[Attribute], maybe_exported: MaybeExported<'_>) {\n+        match self.r.session.opts.resolve_doc_links {\n+            ResolveDocLinks::None => return,\n+            ResolveDocLinks::ExportedMetadata\n+                if !self.r.session.crate_types().iter().copied().any(CrateType::has_metadata)\n+                    || !maybe_exported.eval(self.r) =>\n+            {\n+                return;\n+            }\n+            ResolveDocLinks::Exported if !maybe_exported.eval(self.r) => {\n+                return;\n+            }\n+            ResolveDocLinks::ExportedMetadata\n+            | ResolveDocLinks::Exported\n+            | ResolveDocLinks::All => {}\n+        }\n+\n         if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n             return;\n         }\n@@ -4283,7 +4334,7 @@ impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n         visit::walk_crate(&mut LifetimeCountVisitor { r: self }, krate);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n-        late_resolution_visitor.resolve_doc_links(&krate.attrs);\n+        late_resolution_visitor.resolve_doc_links(&krate.attrs, MaybeExported::Ok(CRATE_NODE_ID));\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {\n             self.lint_buffer.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");"}, {"sha": "e8bc19f88e3e354424605eb25510161c1d62facb", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=da4ce6b41e4465917ec160c914a857fe18608a42", "patch": "@@ -419,6 +419,18 @@ pub enum TrimmedDefPaths {\n     GoodPath,\n }\n \n+#[derive(Clone, Hash)]\n+pub enum ResolveDocLinks {\n+    /// Do not resolve doc links.\n+    None,\n+    /// Resolve doc links on exported items only for crate types that have metadata.\n+    ExportedMetadata,\n+    /// Resolve doc links on exported items.\n+    Exported,\n+    /// Resolve doc links on all items.\n+    All,\n+}\n+\n /// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n /// *Do not* switch `BTreeMap` out for an unsorted container type! That would break\n /// dependency tracking for command-line arguments. Also only hash keys, since tracking\n@@ -788,6 +800,7 @@ impl Default for Options {\n             unstable_features: UnstableFeatures::Disallow,\n             debug_assertions: true,\n             actually_rustdoc: false,\n+            resolve_doc_links: ResolveDocLinks::None,\n             trimmed_def_paths: TrimmedDefPaths::default(),\n             cli_forced_codegen_units: None,\n             cli_forced_local_thinlto_off: false,\n@@ -883,6 +896,15 @@ pub enum CrateType {\n     ProcMacro,\n }\n \n+impl CrateType {\n+    pub fn has_metadata(self) -> bool {\n+        match self {\n+            CrateType::Rlib | CrateType::Dylib | CrateType::ProcMacro => true,\n+            CrateType::Executable | CrateType::Cdylib | CrateType::Staticlib => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum Passes {\n     Some(Vec<String>),\n@@ -2562,6 +2584,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         libs,\n         debug_assertions,\n         actually_rustdoc: false,\n+        resolve_doc_links: ResolveDocLinks::ExportedMetadata,\n         trimmed_def_paths: TrimmedDefPaths::default(),\n         cli_forced_codegen_units: codegen_units,\n         cli_forced_local_thinlto_off: disable_local_thinlto,\n@@ -2825,8 +2848,9 @@ pub(crate) mod dep_tracking {\n     use super::{\n         BranchProtection, CFGuard, CFProtection, CrateType, DebugInfo, ErrorOutputType,\n         InstrumentCoverage, InstrumentXRay, LdImpl, LinkerPluginLto, LocationDetail, LtoCli,\n-        OomStrategy, OptLevel, OutputType, OutputTypes, Passes, SourceFileHashAlgorithm,\n-        SplitDwarfKind, SwitchWithOptPath, SymbolManglingVersion, TraitSolver, TrimmedDefPaths,\n+        OomStrategy, OptLevel, OutputType, OutputTypes, Passes, ResolveDocLinks,\n+        SourceFileHashAlgorithm, SplitDwarfKind, SwitchWithOptPath, SymbolManglingVersion,\n+        TraitSolver, TrimmedDefPaths,\n     };\n     use crate::lint;\n     use crate::options::WasiExecModel;\n@@ -2913,6 +2937,7 @@ pub(crate) mod dep_tracking {\n         TargetTriple,\n         Edition,\n         LinkerPluginLto,\n+        ResolveDocLinks,\n         SplitDebuginfo,\n         SplitDwarfKind,\n         StackProtector,"}, {"sha": "2305ac19a331fb14a8917262056f3b166334987e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4ce6b41e4465917ec160c914a857fe18608a42/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=da4ce6b41e4465917ec160c914a857fe18608a42", "patch": "@@ -169,6 +169,8 @@ top_level_options!(\n         /// is currently just a hack and will be removed eventually, so please\n         /// try to not rely on this too much.\n         actually_rustdoc: bool [TRACKED],\n+        /// Whether name resolver should resolve documentation links.\n+        resolve_doc_links: ResolveDocLinks [TRACKED],\n \n         /// Control path trimming.\n         trimmed_def_paths: TrimmedDefPaths [TRACKED],"}, {"sha": "d85749cadbd76e00106da3f22a2d0ff62ef80778", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da4ce6b41e4465917ec160c914a857fe18608a42/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4ce6b41e4465917ec160c914a857fe18608a42/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=da4ce6b41e4465917ec160c914a857fe18608a42", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{HirId, Path};\n use rustc_interface::interface;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n-use rustc_session::config::{self, CrateType, ErrorOutputType};\n+use rustc_session::config::{self, CrateType, ErrorOutputType, ResolveDocLinks};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -200,6 +200,7 @@ pub(crate) fn create_config(\n         scrape_examples_options,\n         ..\n     }: RustdocOptions,\n+    RenderOptions { document_private, .. }: &RenderOptions,\n ) -> rustc_interface::Config {\n     // Add the doc cfg into the doc build.\n     cfgs.push(\"doc\".to_string());\n@@ -227,6 +228,13 @@ pub(crate) fn create_config(\n \n     let crate_types =\n         if proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };\n+    let resolve_doc_links = if *document_private {\n+        ResolveDocLinks::All\n+    } else {\n+        // Should be `ResolveDocLinks::Exported` in theory, but for some reason rustdoc\n+        // still tries to request resolutions for links on private items.\n+        ResolveDocLinks::All\n+    };\n     let test = scrape_examples_options.map(|opts| opts.scrape_tests).unwrap_or(false);\n     // plays with error output here!\n     let sessopts = config::Options {\n@@ -240,6 +248,7 @@ pub(crate) fn create_config(\n         target_triple: target,\n         unstable_features: UnstableFeatures::from_environment(crate_name.as_deref()),\n         actually_rustdoc: true,\n+        resolve_doc_links,\n         unstable_opts,\n         error_format,\n         diagnostic_width,"}, {"sha": "b22c12fa81054ff4be8b2715cd7fe650f21bc410", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da4ce6b41e4465917ec160c914a857fe18608a42/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da4ce6b41e4465917ec160c914a857fe18608a42/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=da4ce6b41e4465917ec160c914a857fe18608a42", "patch": "@@ -742,7 +742,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n         (false, true) => {\n             let input = options.input.clone();\n             let edition = options.edition;\n-            let config = core::create_config(options);\n+            let config = core::create_config(options, &render_options);\n \n             // `markdown::render` can invoke `doctest::make_test`, which\n             // requires session globals and a thread pool, so we use\n@@ -775,7 +775,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n     let scrape_examples_options = options.scrape_examples_options.clone();\n     let bin_crate = options.bin_crate;\n \n-    let config = core::create_config(options);\n+    let config = core::create_config(options, &render_options);\n \n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();"}]}