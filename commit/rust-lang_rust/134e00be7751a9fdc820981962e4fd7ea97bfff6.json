{"sha": "134e00be7751a9fdc820981962e4fd7ea97bfff6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNGUwMGJlNzc1MWE5ZmRjODIwOTgxOTYyZTRmZDdlYTk3YmZmZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-09T19:01:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-09T19:01:37Z"}, "message": "Auto merge of #21876 - nick29581:driver-args, r=huonw\n\nThis allows people to write tools which are drop-in replacements for rustc by implementing `CompilerCalls` and three lines of code, rather than having to copy+paste a bunch of args parsing code.\r\n\r\nr? @alexcrichton", "tree": {"sha": "84ef58cd6e5aeddb28618679b562181486f664a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84ef58cd6e5aeddb28618679b562181486f664a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134e00be7751a9fdc820981962e4fd7ea97bfff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134e00be7751a9fdc820981962e4fd7ea97bfff6", "html_url": "https://github.com/rust-lang/rust/commit/134e00be7751a9fdc820981962e4fd7ea97bfff6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134e00be7751a9fdc820981962e4fd7ea97bfff6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba9e1fa52627404a1e5b90f745f96a872a0c564", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba9e1fa52627404a1e5b90f745f96a872a0c564", "html_url": "https://github.com/rust-lang/rust/commit/0ba9e1fa52627404a1e5b90f745f96a872a0c564"}, {"sha": "f0e1e09dd90ee7ac9360f6c97d6b49ded8d9a7f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e1e09dd90ee7ac9360f6c97d6b49ded8d9a7f2", "html_url": "https://github.com/rust-lang/rust/commit/f0e1e09dd90ee7ac9360f6c97d6b49ded8d9a7f2"}], "stats": {"total": 611, "additions": 431, "deletions": 180}, "files": [{"sha": "cd664b7388cd877c9bdb7e0e500ccef519963c8d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -33,9 +33,10 @@ use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n \n+use getopts;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use getopts;\n+use std::env;\n use std::fmt;\n \n use llvm;\n@@ -821,7 +822,6 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n }\n \n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n-\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n         .unwrap_or_else(|e| early_error(&e[]));\n@@ -1041,7 +1041,22 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         crate_name: crate_name,\n         alt_std_name: None,\n         libs: libs,\n-        unstable_features: UnstableFeatures::Disallow\n+        unstable_features: get_unstable_features_setting(),\n+    }\n+}\n+\n+pub fn get_unstable_features_setting() -> UnstableFeatures {\n+    // Whether this is a feature-staged build, i.e. on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // The secret key needed to get through the rustc build itself by\n+    // subverting the unstable features lints\n+    let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n+    // The matching key to the above, only known by the build system\n+    let bootstrap_provided_key = env::var_string(\"RUSTC_BOOTSTRAP_KEY\").ok();\n+    match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n+        (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n+        (true, _, _) => UnstableFeatures::Disallow,\n+        (false, _, _) => UnstableFeatures::Default\n     }\n }\n "}, {"sha": "d82c160fdee9b543fc65d58fa75960c7631daf86", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -27,6 +27,7 @@ use rustc_trans::back::write;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n+use super::Compilation;\n \n use serialize::json;\n \n@@ -55,7 +56,7 @@ pub fn compile_input(sess: Session,\n             let state = $make_state;\n             (control.$point.callback)(state);\n         }\n-        if control.$point.stop {\n+        if control.$point.stop == Compilation::Stop {\n             return;\n         }\n     })}\n@@ -206,14 +207,14 @@ impl<'a> CompileController<'a> {\n }\n \n pub struct PhaseController<'a> {\n-    pub stop: bool,\n+    pub stop: Compilation,\n     pub callback: Box<Fn(CompileState) -> () + 'a>,\n }\n \n impl<'a> PhaseController<'a> {\n     pub fn basic() -> PhaseController<'a> {\n         PhaseController {\n-            stop: false,\n+            stop: Compilation::Continue,\n             callback: box |_| {},\n         }\n     }"}, {"sha": "0c936698e6d9aaaf71501d7948706b172f7e9394", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 323, "deletions": 170, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -60,12 +60,13 @@ extern crate \"rustc_llvm\" as llvm;\n pub use syntax::diagnostic;\n \n use driver::CompileController;\n+use pretty::{PpMode, UserIdentifiedItem};\n \n use rustc_resolve as resolve;\n use rustc_trans::back::link;\n use rustc_trans::save;\n use rustc::session::{config, Session, build_session};\n-use rustc::session::config::{Input, PrintRequest, UnstableFeatures};\n+use rustc::session::config::{Input, PrintRequest};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n@@ -92,172 +93,373 @@ pub mod test;\n pub mod driver;\n pub mod pretty;\n \n+\n+static BUG_REPORT_URL: &'static str =\n+    \"http://doc.rust-lang.org/complement-bugreport.html\";\n+\n+\n pub fn run(args: Vec<String>) -> int {\n-    monitor(move || run_compiler(&args));\n+    monitor(move || run_compiler(&args, &mut RustcDefaultCalls));\n     0\n }\n \n-static BUG_REPORT_URL: &'static str =\n-    \"http://doc.rust-lang.org/complement-bugreport.html\";\n+// Parse args and run the compiler. This is the primary entry point for rustc.\n+// See comments on CompilerCalls below for details about the callbacks argument.\n+pub fn run_compiler<'a>(args: &[String],\n+                        callbacks: &mut CompilerCalls<'a>) {\n+    macro_rules! do_or_return {($expr: expr) => {\n+        match $expr {\n+            Compilation::Stop => return,\n+            Compilation::Continue => {}\n+        }\n+    }}\n \n-fn run_compiler(args: &[String]) {\n     let matches = match handle_options(args.to_vec()) {\n         Some(matches) => matches,\n         None => return\n     };\n \n     let descriptions = diagnostics_registry();\n-    match matches.opt_str(\"explain\") {\n-        Some(ref code) => {\n-            match descriptions.find_description(&code[]) {\n-                Some(ref description) => {\n-                    println!(\"{}\", description);\n-                }\n-                None => {\n-                    early_error(&format!(\"no extended information for {}\", code)[]);\n-                }\n-            }\n-            return;\n-        },\n-        None => ()\n-    }\n+\n+    do_or_return!(callbacks.early_callback(&matches, &descriptions));\n \n     let sopts = config::build_session_options(&matches);\n-    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n-    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n-    let (input, input_file_path) = match matches.free.len() {\n-        0 => {\n-            if sopts.describe_lints {\n-                let mut ls = lint::LintStore::new();\n-                ls.register_builtin(None);\n-                describe_lints(&ls, false);\n-                return;\n-            }\n-            let sess = build_session(sopts, None, descriptions);\n-            if print_crate_info(&sess, None, &odir, &ofile) {\n-                return;\n-            }\n-            early_error(\"no input filename given\");\n-        }\n-        1 => {\n-            let ifile = &matches.free[0][];\n-            if ifile == \"-\" {\n-                let contents = old_io::stdin().read_to_end().unwrap();\n-                let src = String::from_utf8(contents).unwrap();\n-                (Input::Str(src), None)\n-            } else {\n-                (Input::File(Path::new(ifile)), Some(Path::new(ifile)))\n-            }\n+\n+    let (odir, ofile) = make_output(&matches);\n+    let (input, input_file_path) = match make_input(&matches.free[]) {\n+        Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n+        None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n+            Some((input, input_file_path)) => (input, input_file_path),\n+            None => return\n         }\n-        _ => early_error(\"multiple input filenames provided\")\n     };\n \n-    let mut sopts = sopts;\n-    sopts.unstable_features = get_unstable_features_setting();\n-\n     let mut sess = build_session(sopts, input_file_path, descriptions);\n-\n-    let cfg = config::build_configuration(&sess);\n-    if print_crate_info(&sess, Some(&input), &odir, &ofile) {\n-        return\n+    if sess.unstable_options() {\n+        sess.opts.show_span = matches.opt_str(\"show-span\");\n     }\n+    let cfg = config::build_configuration(&sess);\n \n-    let pretty = if sess.opts.debugging_opts.unstable_options {\n-        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-            // stable pretty-print variants only\n-            pretty::parse_pretty(&sess, &a, false)\n-        })\n-    } else {\n-        None\n-    };\n-    let pretty = if pretty.is_none() &&\n-        sess.unstable_options() {\n-            matches.opt_str(\"xpretty\").map(|a| {\n-                // extended with unstable pretty-print variants\n-                pretty::parse_pretty(&sess, &a, true)\n-            })\n-        } else {\n-            pretty\n-        };\n+    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile));\n \n-    match pretty.into_iter().next() {\n+    // It is somewhat unfortunate that this is hardwired in - this is forced by\n+    // the fact that pretty_print_input requires the session by value.\n+    let pretty = callbacks.parse_pretty(&sess, &matches);\n+    match pretty {\n         Some((ppm, opt_uii)) => {\n             pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n         None => {/* continue */ }\n     }\n \n-    if sess.unstable_options() {\n-        sess.opts.show_span = matches.opt_str(\"show-span\");\n-    }\n+    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n+    let control = callbacks.build_controller(&sess);\n+    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins), control);\n+}\n \n-    let r = matches.opt_strs(\"Z\");\n-    if r.contains(&(\"ls\".to_string())) {\n-        match input {\n-            Input::File(ref ifile) => {\n-                let mut stdout = old_io::stdout();\n-                list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n-            }\n-            Input::Str(_) => {\n-                early_error(\"cannot list metadata for stdin\");\n-            }\n+// Extract output directory and file from matches.\n+fn make_output(matches: &getopts::Matches) -> (Option<Path>, Option<Path>) {\n+    let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n+    let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n+    (odir, ofile)\n+}\n+\n+// Extract input (string or file and optional path) from matches.\n+fn make_input(free_matches: &[String]) -> Option<(Input, Option<Path>)> {\n+    if free_matches.len() == 1 {\n+        let ifile = &free_matches[0][];\n+        if ifile == \"-\" {\n+            let contents = old_io::stdin().read_to_end().unwrap();\n+            let src = String::from_utf8(contents).unwrap();\n+            Some((Input::Str(src), None))\n+        } else {\n+            Some((Input::File(Path::new(ifile)), Some(Path::new(ifile))))\n         }\n-        return;\n+    } else {\n+        None\n     }\n+}\n \n-    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n-    let control = build_controller(&sess);\n-    driver::compile_input(sess, cfg, &input, &odir, &ofile, Some(plugins), control);\n+// Whether to stop or continue compilation.\n+#[derive(Copy, Debug, Eq, PartialEq)]\n+pub enum Compilation {\n+    Stop,\n+    Continue,\n }\n \n-fn build_controller<'a>(sess: &Session) -> CompileController<'a> {\n-    let mut control = CompileController::basic();\n+impl Compilation {\n+    pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n+        match self {\n+            Compilation::Stop => Compilation::Stop,\n+            Compilation::Continue => next()\n+        }\n+    }\n+}\n \n-    if sess.opts.parse_only ||\n-       sess.opts.show_span.is_some() ||\n-       sess.opts.debugging_opts.ast_json_noexpand {\n-        control.after_parse.stop = true;\n+// A trait for customising the compilation process. Offers a number of hooks for\n+// executing custom code or customising input.\n+pub trait CompilerCalls<'a> {\n+    // Hook for a callback early in the process of handling arguments. This will\n+    // be called straight after options have been parsed but before anything\n+    // else (e.g., selecting input and output).\n+    fn early_callback(&mut self,\n+                      &getopts::Matches,\n+                      &diagnostics::registry::Registry)\n+                      -> Compilation;\n+\n+    // Hook for a callback late in the process of handling arguments. This will\n+    // be called just before actual compilation starts (and before build_controller\n+    // is called), after all arguments etc. have been completely handled.\n+    fn late_callback(&mut self,\n+                     &getopts::Matches,\n+                     &Session,\n+                     &Input,\n+                     &Option<Path>,\n+                     &Option<Path>)\n+                     -> Compilation;\n+\n+    // Called after we extract the input from the arguments. Gives the implementer\n+    // an opportunity to change the inputs or to add some custom input handling.\n+    // The default behaviour is to simply pass through the inputs.\n+    fn some_input(&mut self, input: Input, input_path: Option<Path>) -> (Input, Option<Path>) {\n+        (input, input_path)\n     }\n \n-    if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n-        control.after_write_deps.stop = true;\n+    // Called after we extract the input from the arguments if there is no valid\n+    // input. Gives the implementer an opportunity to supply alternate input (by\n+    // returning a Some value) or to add custom behaviour for this error such as\n+    // emitting error messages. Returning None will cause compilation to stop\n+    // at this point.\n+    fn no_input(&mut self,\n+                &getopts::Matches,\n+                &config::Options,\n+                &Option<Path>,\n+                &Option<Path>,\n+                &diagnostics::registry::Registry)\n+                -> Option<(Input, Option<Path>)>;\n+\n+    // Parse pretty printing information from the arguments. The implementer can\n+    // choose to ignore this (the default will return None) which will skip pretty\n+    // printing. If you do want to pretty print, it is recommended to use the\n+    // implementation of this method from RustcDefaultCalls.\n+    // FIXME, this is a terrible bit of API. Parsing of pretty printing stuff\n+    // should be done as part of the framework and the implementor should customise\n+    // handling of it. However, that is not possible atm because pretty printing\n+    // essentially goes off and takes another path through the compiler which\n+    // means the session is either moved or not depending on what parse_pretty\n+    // returns (we could fix this by cloning, but it's another hack). The proper\n+    // solution is to handle pretty printing as if it were a compiler extension,\n+    // extending CompileController to make this work (see for example the treatment\n+    // of save-analysis in RustcDefaultCalls::build_controller).\n+    fn parse_pretty(&mut self,\n+                    _sess: &Session,\n+                    _matches: &getopts::Matches)\n+                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+        None\n     }\n \n-    if sess.opts.no_trans {\n-        control.after_analysis.stop = true;\n+    // Create a CompilController struct for controlling the behaviour of compilation.\n+    fn build_controller(&mut self, &Session) -> CompileController<'a>;\n+}\n+\n+// CompilerCalls instance for a regular rustc build.\n+#[derive(Copy)]\n+pub struct RustcDefaultCalls;\n+\n+impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n+    fn early_callback(&mut self,\n+                      matches: &getopts::Matches,\n+                      descriptions: &diagnostics::registry::Registry)\n+                      -> Compilation {\n+        match matches.opt_str(\"explain\") {\n+            Some(ref code) => {\n+                match descriptions.find_description(&code[]) {\n+                    Some(ref description) => {\n+                        println!(\"{}\", description);\n+                    }\n+                    None => {\n+                        early_error(&format!(\"no extended information for {}\", code)[]);\n+                    }\n+                }\n+                return Compilation::Stop;\n+            },\n+            None => ()\n+        }\n+\n+        return Compilation::Continue;\n     }\n \n-    if !sess.opts.output_types.iter().any(|&i| i == config::OutputTypeExe) {\n-        control.after_llvm.stop = true;\n+    fn no_input(&mut self,\n+                matches: &getopts::Matches,\n+                sopts: &config::Options,\n+                odir: &Option<Path>,\n+                ofile: &Option<Path>,\n+                descriptions: &diagnostics::registry::Registry)\n+                -> Option<(Input, Option<Path>)> {\n+        match matches.free.len() {\n+            0 => {\n+                if sopts.describe_lints {\n+                    let mut ls = lint::LintStore::new();\n+                    ls.register_builtin(None);\n+                    describe_lints(&ls, false);\n+                    return None;\n+                }\n+                let sess = build_session(sopts.clone(), None, descriptions.clone());\n+                let should_stop = RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n+                if should_stop == Compilation::Stop {\n+                    return None;\n+                }\n+                early_error(\"no input filename given\");\n+            }\n+            1 => panic!(\"make_input should have provided valid inputs\"),\n+            _ => early_error(\"multiple input filenames provided\")\n+        }\n+\n+        None\n     }\n \n-    if sess.opts.debugging_opts.save_analysis {\n-        control.after_analysis.callback = box |state| {\n-            time(state.session.time_passes(), \"save analysis\", state.krate.unwrap(), |krate|\n-                 save::process_crate(state.session,\n-                                     krate,\n-                                     state.analysis.unwrap(),\n-                                     state.out_dir));\n+    fn parse_pretty(&mut self,\n+                    sess: &Session,\n+                    matches: &getopts::Matches)\n+                    -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+        let pretty = if sess.opts.debugging_opts.unstable_options {\n+            matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+                // stable pretty-print variants only\n+                pretty::parse_pretty(sess, &a, false)\n+            })\n+        } else {\n+            None\n         };\n-        control.make_glob_map = resolve::MakeGlobMap::Yes;\n+        if pretty.is_none() && sess.unstable_options() {\n+            matches.opt_str(\"xpretty\").map(|a| {\n+                // extended with unstable pretty-print variants\n+                pretty::parse_pretty(sess, &a, true)\n+            })\n+        } else {\n+            pretty\n+        }\n+    }\n+\n+    fn late_callback(&mut self,\n+                     matches: &getopts::Matches,\n+                     sess: &Session,\n+                     input: &Input,\n+                     odir: &Option<Path>,\n+                     ofile: &Option<Path>)\n+                     -> Compilation {\n+        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile).and_then(\n+            || RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n-    control\n+    fn build_controller(&mut self, sess: &Session) -> CompileController<'a> {\n+        let mut control = CompileController::basic();\n+\n+        if sess.opts.parse_only ||\n+           sess.opts.show_span.is_some() ||\n+           sess.opts.debugging_opts.ast_json_noexpand {\n+            control.after_parse.stop = Compilation::Stop;\n+        }\n+\n+        if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n+            control.after_write_deps.stop = Compilation::Stop;\n+        }\n+\n+        if sess.opts.no_trans {\n+            control.after_analysis.stop = Compilation::Stop;\n+        }\n+\n+        if !sess.opts.output_types.iter().any(|&i| i == config::OutputTypeExe) {\n+            control.after_llvm.stop = Compilation::Stop;\n+        }\n+\n+        if sess.opts.debugging_opts.save_analysis {\n+            control.after_analysis.callback = box |state| {\n+                time(state.session.time_passes(), \"save analysis\", state.krate.unwrap(), |krate|\n+                     save::process_crate(state.session,\n+                                         krate,\n+                                         state.analysis.unwrap(),\n+                                         state.out_dir));\n+            };\n+            control.make_glob_map = resolve::MakeGlobMap::Yes;\n+        }\n+\n+        control\n+    }\n }\n \n-pub fn get_unstable_features_setting() -> UnstableFeatures {\n-    // Whether this is a feature-staged build, i.e. on the beta or stable channel\n-    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n-    // The secret key needed to get through the rustc build itself by\n-    // subverting the unstable features lints\n-    let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n-    // The matching key to the above, only known by the build system\n-    let bootstrap_provided_key = env::var_string(\"RUSTC_BOOTSTRAP_KEY\").ok();\n-    match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n-        (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n-        (true, _, _) => UnstableFeatures::Disallow,\n-        (false, _, _) => UnstableFeatures::Default\n+impl RustcDefaultCalls {\n+    pub fn list_metadata(sess: &Session,\n+                         matches: &getopts::Matches,\n+                         input: &Input)\n+                         -> Compilation {\n+        let r = matches.opt_strs(\"Z\");\n+        if r.contains(&(\"ls\".to_string())) {\n+            match input {\n+                &Input::File(ref ifile) => {\n+                    let mut stdout = old_io::stdout();\n+                    let path = &(*ifile);\n+                    metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx,\n+                                                         path,\n+                                                         &mut stdout).unwrap();\n+                }\n+                &Input::Str(_) => {\n+                    early_error(\"cannot list metadata for stdin\");\n+                }\n+            }\n+            return Compilation::Stop;\n+        }\n+\n+        return Compilation::Continue;\n+    }\n+\n+\n+    fn print_crate_info(sess: &Session,\n+                        input: Option<&Input>,\n+                        odir: &Option<Path>,\n+                        ofile: &Option<Path>)\n+                        -> Compilation {\n+        if sess.opts.prints.len() == 0 {\n+            return Compilation::Continue;\n+        }\n+\n+        let attrs = input.map(|input| parse_crate_attrs(sess, input));\n+        for req in &sess.opts.prints {\n+            match *req {\n+                PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n+                PrintRequest::FileNames |\n+                PrintRequest::CrateName => {\n+                    let input = match input {\n+                        Some(input) => input,\n+                        None => early_error(\"no input file provided\"),\n+                    };\n+                    let attrs = attrs.as_ref().unwrap();\n+                    let t_outputs = driver::build_output_filenames(input,\n+                                                                   odir,\n+                                                                   ofile,\n+                                                                   attrs,\n+                                                                   sess);\n+                    let id = link::find_crate_name(Some(sess),\n+                                                   attrs,\n+                                                   input);\n+                    if *req == PrintRequest::CrateName {\n+                        println!(\"{}\", id);\n+                        continue\n+                    }\n+                    let crate_types = driver::collect_crate_types(sess, attrs);\n+                    let metadata = driver::collect_crate_metadata(sess, attrs);\n+                    *sess.crate_metadata.borrow_mut() = metadata;\n+                    for &style in &crate_types {\n+                        let fname = link::filename_for_input(sess,\n+                                                             style,\n+                                                             &id,\n+                                                             &t_outputs.with_extension(\"\"));\n+                        println!(\"{}\", fname.filename_display());\n+                    }\n+                }\n+            }\n+        }\n+        return Compilation::Stop;\n     }\n }\n \n@@ -535,50 +737,6 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn print_crate_info(sess: &Session,\n-                    input: Option<&Input>,\n-                    odir: &Option<Path>,\n-                    ofile: &Option<Path>)\n-                    -> bool {\n-    if sess.opts.prints.len() == 0 { return false }\n-\n-    let attrs = input.map(|input| parse_crate_attrs(sess, input));\n-    for req in &sess.opts.prints {\n-        match *req {\n-            PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n-            PrintRequest::FileNames |\n-            PrintRequest::CrateName => {\n-                let input = match input {\n-                    Some(input) => input,\n-                    None => early_error(\"no input file provided\"),\n-                };\n-                let attrs = attrs.as_ref().unwrap();\n-                let t_outputs = driver::build_output_filenames(input,\n-                                                               odir,\n-                                                               ofile,\n-                                                               attrs,\n-                                                               sess);\n-                let id = link::find_crate_name(Some(sess), attrs,\n-                                               input);\n-                if *req == PrintRequest::CrateName {\n-                    println!(\"{}\", id);\n-                    continue\n-                }\n-                let crate_types = driver::collect_crate_types(sess, attrs);\n-                let metadata = driver::collect_crate_metadata(sess, attrs);\n-                *sess.crate_metadata.borrow_mut() = metadata;\n-                for &style in &crate_types {\n-                    let fname = link::filename_for_input(sess, style,\n-                                                         &id,\n-                                                         &t_outputs.with_extension(\"\"));\n-                    println!(\"{}\", fname.filename_display());\n-                }\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n fn parse_crate_attrs(sess: &Session, input: &Input) ->\n                      Vec<ast::Attribute> {\n     let result = match *input {\n@@ -598,11 +756,6 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n     result.into_iter().collect()\n }\n \n-pub fn list_metadata(sess: &Session, path: &Path,\n-                     out: &mut old_io::Writer) -> old_io::IoResult<()> {\n-    metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx, path, out)\n-}\n-\n /// Run a procedure which will detect panics in the compiler and print nicer\n /// error messages rather than just failing the test.\n ///"}, {"sha": "e43c3a6da3ac70893479bb7bbcb86698eae4b32e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -21,9 +21,9 @@ use std::thunk::Thunk;\n use std::collections::{HashSet, HashMap};\n use testing;\n use rustc::session::{self, config};\n+use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc_driver::get_unstable_features_setting;\n-use rustc_driver::driver;\n+use rustc_driver::{driver, Compilation};\n use syntax::ast;\n use syntax::codemap::{CodeMap, dummy_spanned};\n use syntax::diagnostic;\n@@ -178,7 +178,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n     if no_run {\n-        control.after_analysis.stop = true;\n+        control.after_analysis.stop = Compilation::Stop;\n     }\n     driver::compile_input(sess, cfg, &input, &out, &None, None, control);\n "}, {"sha": "62d48189c43475149b013f223bb2079af97e0199", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -10,6 +10,7 @@\n \n use std::collections::HashMap;\n \n+#[derive(Clone)]\n pub struct Registry {\n     descriptions: HashMap<&'static str, &'static str>\n }"}, {"sha": "9e164522d77a60db51fd8c6e693eecb7587b36a2", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e00be7751a9fdc820981962e4fd7ea97bfff6/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=134e00be7751a9fdc820981962e4fd7ea97bfff6", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the CompilerCalls interface to the compiler works.\n+\n+// ignore-android\n+\n+#![feature(rustc_private)]\n+#![feature(core)]\n+\n+extern crate getopts;\n+extern crate rustc;\n+extern crate rustc_driver;\n+extern crate syntax;\n+\n+use rustc::session::Session;\n+use rustc::session::config::{self, Input};\n+use rustc_driver::{driver, CompilerCalls, Compilation};\n+use syntax::diagnostics;\n+\n+\n+struct TestCalls {\n+    count: u32\n+}\n+\n+impl<'a> CompilerCalls<'a> for TestCalls {\n+    fn early_callback(&mut self,\n+                      _: &getopts::Matches,\n+                      _: &diagnostics::registry::Registry)\n+                      -> Compilation {\n+        self.count *= 2;\n+        Compilation::Continue\n+    }\n+\n+    fn late_callback(&mut self,\n+                     _: &getopts::Matches,\n+                     _: &Session,\n+                     _: &Input,\n+                     _: &Option<Path>,\n+                     _: &Option<Path>)\n+                     -> Compilation {\n+        self.count *= 3;\n+        Compilation::Stop\n+    }\n+\n+    fn some_input(&mut self, input: Input, input_path: Option<Path>) -> (Input, Option<Path>) {\n+        self.count *= 5;\n+        (input, input_path)\n+    }\n+\n+    fn no_input(&mut self,\n+                _: &getopts::Matches,\n+                _: &config::Options,\n+                _: &Option<Path>,\n+                _: &Option<Path>,\n+                _: &diagnostics::registry::Registry)\n+                -> Option<(Input, Option<Path>)> {\n+        panic!(\"This shouldn't happen\");\n+    }\n+\n+    fn build_controller(&mut self, _: &Session) -> driver::CompileController<'a> {\n+        panic!(\"This shouldn't be called\");\n+    }\n+}\n+\n+\n+fn main() {\n+    let mut tc = TestCalls { count: 1 };\n+    // we should never get use this filename, but lets make sure they are valid args.\n+    let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n+    rustc_driver::run_compiler(args.as_slice(), &mut tc);\n+    assert!(tc.count == 30);\n+}\n+"}]}