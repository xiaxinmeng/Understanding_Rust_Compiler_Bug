{"sha": "5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MTdkODBjZDdkYzgzYTg3MjI4YTE3ZTJjMDRkYWI4ZjUzZjA2ZDM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-26T09:20:10Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-26T09:20:10Z"}, "message": "Pass stuff to take_ty, free_ty, and drop_ty by address, even when immediate\n\nThe glue-calling will spill the values again anyway. This should\nprevent a lot of load/spill junk in the output. It is also necessary\nto be able to have unique vecs be immediate values (take must know the\nactual address to be able to duplicate).", "tree": {"sha": "28f0494809435420b748169f16f8d43ac591da75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28f0494809435420b748169f16f8d43ac591da75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "html_url": "https://github.com/rust-lang/rust/commit/5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5917d80cd7dc83a87228a17e2c04dab8f53f06d3/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0db13956f4f106c4bf5a9210c7df439b34506a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0db13956f4f106c4bf5a9210c7df439b34506a4", "html_url": "https://github.com/rust-lang/rust/commit/b0db13956f4f106c4bf5a9210c7df439b34506a4"}], "stats": {"total": 68, "additions": 29, "deletions": 39}, "files": [{"sha": "974698e390dac8f258a637ec4d07e2d4b48f510c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5917d80cd7dc83a87228a17e2c04dab8f53f06d3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5917d80cd7dc83a87228a17e2c04dab8f53f06d3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "patch": "@@ -1312,7 +1312,7 @@ fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n         bcx = incr_refcnt_of_boxed(cx, bld::Load(cx, v)).bcx;\n     } else if ty::type_is_structural(bcx_tcx(cx), t) {\n         bcx = duplicate_heap_parts_if_necessary(cx, v, t).bcx;\n-        bcx = iter_structural_ty(bcx, v, t, bind take_ty(_, _, _)).bcx;\n+        bcx = iter_structural_ty(bcx, v, t, take_ty).bcx;\n     } else { bcx = cx; }\n \n     build_return(bcx);\n@@ -1349,8 +1349,7 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n             let body =\n                 bld::GEP(cx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n             let body_ty = body_mt.ty;\n-            let body_val = load_if_immediate(cx, body, body_ty);\n-            let rs = drop_ty(cx, body_val, body_ty);\n+            let rs = drop_ty(cx, body, body_ty);\n             if !bcx_ccx(cx).sess.get_opts().do_gc {\n                 trans_non_gc_free(rs.bcx, v)\n             } else { rslt(cx, C_nil()) }\n@@ -1469,7 +1468,7 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n           _ {\n             if ty::type_has_pointers(ccx.tcx, t) &&\n                    ty::type_is_structural(ccx.tcx, t) {\n-                iter_structural_ty(cx, v0, t, bind drop_ty(_, _, _))\n+                iter_structural_ty(cx, v0, t, drop_ty)\n             } else { rslt(cx, C_nil()) }\n           }\n         };\n@@ -1518,7 +1517,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     let val_cast = bld::BitCast(cx, val.val, val_llty);\n     bld::FastCall(cx, dtor_addr, args + [val_cast]);\n \n-    cx = drop_slot(cx, val.val, inner_t_s).bcx;\n+    cx = drop_ty(cx, val.val, inner_t_s).bcx;\n     bld::Store(cx, C_int(0), drop_flag.val);\n     bld::Br(cx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n@@ -1549,7 +1548,7 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n     let zero_test = bld::ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n     bld::CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n     let free_res =\n-        free_ty(free_cx, load_if_immediate(free_cx, full_alias, t), t);\n+        free_ty(free_cx, full_alias, t);\n     bld::Br(free_res.bcx, next_cx.llbb);\n     let t_else = T_nil();\n     let v_else = C_nil();\n@@ -1728,7 +1727,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n         let null_test = bld::IsNull(cx, box_ptr);\n         bld::CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        let r = f(inner_cx, box_ptr, tbox);\n+        let r = f(inner_cx, box_cell, tbox);\n         bld::Br(r.bcx, next_cx.llbb);\n         ret rslt(next_cx, C_nil());\n     }\n@@ -1772,9 +1771,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         bld::CondBr(loop_header_cx, not_yet_at_end, loop_body_cx.llbb,\n                                     next_cx.llbb);\n \n-        rs =\n-            f(loop_body_cx,\n-              load_if_immediate(loop_body_cx, dest_elem, unit_ty), unit_ty);\n+        rs = f(loop_body_cx, dest_elem, unit_ty);\n \n         loop_body_cx = rs.bcx;\n \n@@ -1805,8 +1802,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n-                let llfld_a = load_if_immediate(cx, llfldp_a, ty_subst);\n-                rslt = f(cx, llfld_a, ty_subst);\n+                rslt = f(cx, llfldp_a, ty_subst);\n                 cx = rslt.bcx;\n                 j += 1;\n             }\n@@ -1822,9 +1818,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         for fld: ty::field in fields {\n             r = GEP_tup_like(r.bcx, t, av, [0, i]);\n             let llfld_a = r.val;\n-            r =\n-                f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n-                  fld.mt.ty);\n+            r = f(r.bcx, llfld_a, fld.mt.ty);\n             i += 1;\n         }\n       }\n@@ -1833,7 +1827,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         for arg in args {\n             r = GEP_tup_like(r.bcx, t, av, [0, i]);\n             let llfld_a = r.val;\n-            r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, arg), arg);\n+            r = f(r.bcx, llfld_a, arg);\n             i += 1;\n         }\n       }\n@@ -1844,7 +1838,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n         r = GEP_tup_like(r.bcx, tup_t, av, [0, 1]);\n         let llfld_a = r.val;\n-        r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner1), inner1);\n+        r = f(r.bcx, llfld_a, inner1);\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n@@ -1864,7 +1858,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n         let bcx = cx;\n-        bcx = f(bcx, lldiscrim_a, ty::mk_int(bcx_tcx(cx))).bcx;\n+        bcx = f(bcx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx))).bcx;\n         let unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n         bld::Unreachable(unr_cx);\n         let llswitch = bld::Switch(bcx, lldiscrim_a, unr_cx.llbb, n_variants);\n@@ -2141,7 +2135,7 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n       }\n     }\n \n-    let llrawptr = bld::BitCast(cx, v, T_ptr(T_i8()));\n+    let llrawptr = bld::PointerCast(cx, v, T_ptr(T_i8()));\n     let lltydescs =\n         bld::GEP(cx, tydesc,\n                      [C_int(0), C_int(abi::tydesc_field_first_param)]);\n@@ -2165,8 +2159,7 @@ fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n    result {\n     let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n     let td = get_tydesc(cx, t, false, tps_normal, ti).result;\n-    call_tydesc_glue_full(td.bcx, spill_if_immediate(td.bcx, v, t), td.val,\n-                          field, ti);\n+    call_tydesc_glue_full(td.bcx, v, td.val, field, ti);\n     ret rslt(td.bcx, C_nil());\n }\n \n@@ -2266,11 +2259,6 @@ fn take_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n     ret rslt(cx, C_nil());\n }\n \n-fn drop_slot(cx: &@block_ctxt, slot: ValueRef, t: ty::t) -> result {\n-    let llptr = load_if_immediate(cx, slot, t);\n-    ret drop_ty(cx, llptr, t);\n-}\n-\n fn drop_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n     if ty::type_needs_drop(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n@@ -2392,10 +2380,10 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if ty::type_is_boxed(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n-            drop_ty(cx, bld::Load(cx, dst), t).bcx\n+            drop_ty(cx, dst, t).bcx\n         } else { cx };\n-        bcx = take_ty(bcx, src, t).bcx;\n         bld::Store(bcx, src, dst);\n+        bcx = take_ty(bcx, dst, t).bcx;\n         ret bcx;\n     } else if type_is_structural_or_param(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n@@ -2433,7 +2421,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                   ty::type_is_boxed(tcx, t) {\n         if src.is_mem { src_val = bld::Load(cx, src_val); }\n         if action == DROP_EXISTING {\n-            cx = drop_ty(cx, bld::Load(cx, dst), t).bcx;\n+            cx = drop_ty(cx, dst, t).bcx;\n         }\n         bld::Store(cx, src_val, dst);\n         if src.is_mem { ret zero_alloca(cx, src.res.val, t).bcx; }\n@@ -3963,9 +3951,12 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n             if lv.is_mem {\n+                bcx = take_ty(bcx, val, e_ty).bcx;\n                 val = load_if_immediate(bcx, val, e_ty);\n+            } else if is_ext_vec_plus {\n+                let spilled = do_spill(bcx, val);\n+                bcx = take_ty(bcx, spilled, e_ty).bcx;\n             }\n-            bcx = take_ty(bcx, val, e_ty).bcx;\n             add_clean_temp(bcx, val, e_ty);\n         }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n@@ -4481,11 +4472,6 @@ fn with_out_method(work: fn(&out_method) -> result, cx: @block_ctxt,\n         if ty::type_is_nil(ccx.tcx, tp) { ret work(return); }\n         let res_alloca = alloc_ty(cx, tp);\n         cx = zero_alloca(res_alloca.bcx, res_alloca.val, tp).bcx;\n-        fn drop_hoisted_ty(cx: &@block_ctxt, target: ValueRef, t: ty::t) ->\n-           result {\n-            let reg_val = load_if_immediate(cx, target, t);\n-            ret drop_ty(cx, reg_val, t);\n-        }\n         let done = work(save_in(res_alloca.val));\n         let loaded = load_if_immediate(done.bcx, res_alloca.val, tp);\n         add_clean_temp(cx, loaded, tp);\n@@ -5274,7 +5260,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt,\n                 // Args that are locally assigned to need to do a local\n                 // take/drop\n                 if fcx.lcx.ccx.mut_map.contains_key(aarg.id) {\n-                    bcx = take_ty(bcx, aval, arg_ty).bcx;\n+                    bcx = take_ty(bcx, addr, arg_ty).bcx;\n                     add_clean(scope, addr, arg_ty);\n                 }\n             }"}, {"sha": "8edbcbdbcf96e0bbc4393a294bd1913cda6d2adb", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5917d80cd7dc83a87228a17e2c04dab8f53f06d3/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5917d80cd7dc83a87228a17e2c04dab8f53f06d3/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=5917d80cd7dc83a87228a17e2c04dab8f53f06d3", "patch": "@@ -59,7 +59,6 @@ import bld = trans_build;\n \n // FIXME: These should probably be pulled in here too.\n import trans::type_of_fn_full;\n-import trans::drop_slot;\n import trans::drop_ty;\n \n obj namegen(mutable i: int) {\n@@ -299,10 +298,15 @@ tag cleanup {\n }\n \n fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    find_scope_cx(cx).cleanups += [clean(bind drop_slot(_, val, ty))];\n+    find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, val, ty))];\n }\n fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    find_scope_cx(cx).cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n+    fn spill_and_drop(bcx: &@block_ctxt, val: ValueRef, ty: ty::t) -> result {\n+        let spilled = trans::spill_if_immediate(bcx, val, ty);\n+        ret drop_ty(bcx, spilled, ty);\n+    }\n+    find_scope_cx(cx).cleanups +=\n+        [clean_temp(val, bind spill_and_drop(_, val, ty))];\n }\n \n // Note that this only works for temporaries. We should, at some point, move"}]}