{"sha": "ee2abc1caecc3f63f021988ac1813912120f73a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMmFiYzFjYWVjYzNmNjNmMDIxOTg4YWMxODEzOTEyMTIwZjczYTk=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-07-09T18:08:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-23T22:44:03Z"}, "message": "Adding simple net::url module to parse and format urls.", "tree": {"sha": "535470e70a97ceb2f201f8231ca39694017b5e5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/535470e70a97ceb2f201f8231ca39694017b5e5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee2abc1caecc3f63f021988ac1813912120f73a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee2abc1caecc3f63f021988ac1813912120f73a9", "html_url": "https://github.com/rust-lang/rust/commit/ee2abc1caecc3f63f021988ac1813912120f73a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee2abc1caecc3f63f021988ac1813912120f73a9/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e0de67e15aebd22fd7ae6f68e0e941c1c6ec5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/26e0de67e15aebd22fd7ae6f68e0e941c1c6ec5c", "html_url": "https://github.com/rust-lang/rust/commit/26e0de67e15aebd22fd7ae6f68e0e941c1c6ec5c"}], "stats": {"total": 247, "additions": 246, "deletions": 1}, "files": [{"sha": "e1d5b2a637084625db4dc7c0c0bba736b25bfb82", "filename": "src/libstd/net.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=ee2abc1caecc3f63f021988ac1813912120f73a9", "patch": "@@ -5,3 +5,6 @@ export tcp;\n \n import ip = net_ip;\n export ip;\n+\n+import url = net_url;\n+export url;\n\\ No newline at end of file"}, {"sha": "c925e93320aed72a96eb2f96702c69068dc692ff", "filename": "src/libstd/net_url.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=ee2abc1caecc3f63f021988ac1813912120f73a9", "patch": "@@ -0,0 +1,241 @@\n+//! Types/fns concerning URLs (see RFC 3986)\n+\n+import map;\n+import map::*;\n+\n+export url, userinfo, query, from_str, to_str;\n+\n+type url = {\n+    scheme: ~str,\n+    user: option<userinfo>,\n+    host: ~str,\n+    path: ~str,\n+    query: query,\n+    fragment: option<~str>\n+};\n+\n+type userinfo = {\n+    user: ~str,\n+    pass: option<~str>\n+};\n+\n+type query = map::hashmap<~str, ~str>;\n+\n+fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str,\n+       -path: ~str, -query: query, -fragment: option<~str>) -> url {\n+    { scheme: scheme, user: user, host: host,\n+     path: path, query: query, fragment: fragment }\n+}\n+\n+fn userinfo(-user: ~str, -pass: option<~str>) -> userinfo {\n+    {user: user, pass: pass}\n+}\n+\n+fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n+    let mut v = str::splitn_char(s, c, 1);\n+    if v.len() == 1 {\n+        ret (s, ~\"\");\n+    } else {\n+        ret (vec::shift(v), vec::pop(v));\n+    }\n+}\n+\n+fn userinfo_from_str(uinfo: ~str) -> userinfo {\n+    let (user, p) = split_char_first(uinfo, ':');\n+    let pass = if str::len(p) == 0 {\n+        option::none\n+    } else {\n+        option::some(p)\n+    };\n+    ret userinfo(user, pass);\n+}\n+\n+fn userinfo_to_str(-userinfo: userinfo) -> ~str {\n+    if option::is_some(userinfo.pass) {\n+        ret str::concat(~[copy userinfo.user, ~\":\",\n+                          option::unwrap(copy userinfo.pass),\n+                          ~\"@\"]);\n+    } else {\n+        ret str::concat(~[copy userinfo.user, ~\"@\"]);\n+    }\n+}\n+\n+fn query_from_str(rawquery: ~str) -> query {\n+    let query: query = map::str_hash();\n+    if str::len(rawquery) != 0 {\n+        for str::split_char(rawquery, '&').each |p| {\n+            let (k, v) = split_char_first(p, '=');\n+            query.insert(k, v);\n+        };\n+    }\n+    ret query;\n+}\n+\n+fn query_to_str(query: query) -> ~str {\n+    let mut strvec = ~[];\n+    for query.each |k, v| {\n+        strvec += ~[#fmt(\"%s=%s\", k, v)];\n+    };\n+    ret str::connect(strvec, ~\"&\");\n+}\n+\n+fn get_scheme(rawurl: ~str) -> option::option<(~str, ~str)> {\n+    for str::each_chari(rawurl) |i,c| {\n+        if char::is_alphabetic(c) {\n+            again;\n+        } else if c == ':' && i != 0 {\n+            ret option::some((rawurl.slice(0,i),\n+                              rawurl.slice(i+3,str::len(rawurl))));\n+        } else {\n+            ret option::none;\n+        }\n+    };\n+    ret option::none;\n+}\n+\n+/**\n+ * Parse a `str` to a `url`\n+ *\n+ * # Arguments\n+ *\n+ * `rawurl` - a string representing a full url, including scheme.\n+ *\n+ * # Returns\n+ *\n+ * a `url` that contains the parsed representation of the url.\n+ *\n+ */\n+\n+fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n+    let mut schm = get_scheme(rawurl);\n+    if option::is_none(schm) {\n+        ret result::err(~\"invalid scheme\");\n+    }\n+    let (scheme, rest) = option::unwrap(schm);\n+    let (u, rest) = split_char_first(rest, '@');\n+    let user = if str::len(rest) == 0 {\n+        option::none\n+    } else {\n+        option::some(userinfo_from_str(u))\n+    };\n+    let rest = if str::len(rest) == 0 {\n+         u\n+    } else {\n+        rest\n+    };\n+    let (rest, frag) = split_char_first(rest, '#');\n+    let fragment = if str::len(frag) == 0 {\n+        option::none\n+    } else {\n+        option::some(frag)\n+    };\n+    let (rest, query) = split_char_first(rest, '?');\n+    let query = query_from_str(query);\n+    let (host, pth) = split_char_first(rest, '/');\n+    let mut path = pth;\n+    if str::len(path) != 0 {\n+        str::unshift_char(path, '/');\n+    }\n+\n+    ret result::ok(url(scheme, user, host, path, query, fragment));\n+}\n+\n+/**\n+ * Format a `url` as a string\n+ *\n+ * # Arguments\n+ *\n+ * `url` - a url.\n+ *\n+ * # Returns\n+ *\n+ * a `str` that contains the formatted url. Note that this will usually\n+ * be an inverse of `from_str` but might strip out unneeded separators.\n+ * for example, \"http://somehost.com?\", when parsed and formatted, will\n+ * result in just \"http://somehost.com\".\n+ *\n+ */\n+fn to_str(url: url) -> ~str {\n+    let user = if option::is_some(url.user) {\n+      userinfo_to_str(option::unwrap(copy url.user))\n+    } else {\n+       ~\"\"\n+    };\n+    let query = if url.query.size() == 0 {\n+        ~\"\"\n+    } else {\n+        str::concat(~[~\"?\", query_to_str(url.query)])\n+    };\n+    let fragment = if option::is_some(url.fragment) {\n+        str::concat(~[~\"#\", option::unwrap(copy url.fragment)])\n+    } else {\n+        ~\"\"\n+    };\n+\n+    ret str::concat(~[copy url.scheme,\n+                      ~\"://\",\n+                      user,\n+                      copy url.host,\n+                      copy url.path,\n+                      query,\n+                      fragment]);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_full_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_userless_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org/doc?s=v#something\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_queryless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_empty_query_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n+        let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n+        assert to_str(result::unwrap(from_str(url))) == should_be;\n+    }\n+\n+    #[test]\n+    fn test_fragmentless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_minimal_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org/doc\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_scheme_host_only_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_pathless_url_parse_and_format() {\n+        let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+    #[test]\n+    fn test_scheme_host_fragment_only_url_parse_and_format() {\n+        let url = ~\"http://rust-lang.org#something\";\n+        assert to_str(result::unwrap(from_str(url))) == url;\n+    }\n+\n+}\n\\ No newline at end of file"}, {"sha": "2a63d59bac6991b934e110af1b9013345c28cba5", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ee2abc1caecc3f63f021988ac1813912120f73a9/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ee2abc1caecc3f63f021988ac1813912120f73a9", "patch": "@@ -15,7 +15,7 @@\n use core(vers = \"0.3\");\n import core::*;\n \n-export net, net_tcp, net_ip;\n+export net, net_tcp, net_ip, net_url;\n export uv, uv_ll, uv_iotask, uv_global_loop;\n export c_vec, util, timer;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap;\n@@ -30,6 +30,7 @@ export base64;\n mod net;\n mod net_ip;\n mod net_tcp;\n+mod net_url;\n \n // libuv modules\n mod uv;"}]}