{"sha": "d04b8b5818819470457fc00f87176b273d756980", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGI4YjU4MTg4MTk0NzA0NTdmYzAwZjg3MTc2YjI3M2Q3NTY5ODA=", "commit": {"author": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2015-09-15T21:20:18Z"}, "committer": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2015-09-16T10:00:56Z"}, "message": "Improve PartialOrd for slices\n\nReusing the same idea as in #26884, we can exploit the fact that the\nlength of slices is known, hence we can use a counted loop instead of\niterators, which means that we only need a single counter, instead of\nhaving to increment and check one pointer for each iterator.\n\nUsing the generic implementation of the boolean comparison operators\n(`lt`, `le`, `gt`, `ge`) provides further speedup for simple\ntypes. This happens because the loop scans elements checking for\nequality and dispatches to element comparison or length comparison\ndepending on the result of the prefix comparison.\n\n```\ntest u8_cmp          ... bench:      14,043 ns/iter (+/- 1,732)\ntest u8_lt           ... bench:      16,156 ns/iter (+/- 1,864)\ntest u8_partial_cmp  ... bench:      16,250 ns/iter (+/- 2,608)\ntest u16_cmp         ... bench:      15,764 ns/iter (+/- 1,420)\ntest u16_lt          ... bench:      19,833 ns/iter (+/- 2,826)\ntest u16_partial_cmp ... bench:      19,811 ns/iter (+/- 2,240)\ntest u32_cmp         ... bench:      15,792 ns/iter (+/- 3,409)\ntest u32_lt          ... bench:      18,577 ns/iter (+/- 2,075)\ntest u32_partial_cmp ... bench:      18,603 ns/iter (+/- 5,666)\ntest u64_cmp         ... bench:      16,337 ns/iter (+/- 2,511)\ntest u64_lt          ... bench:      18,074 ns/iter (+/- 7,914)\ntest u64_partial_cmp ... bench:      17,909 ns/iter (+/- 1,105)\n```\n\n```\ntest u8_cmp          ... bench:       6,511 ns/iter (+/- 982)\ntest u8_lt           ... bench:       6,671 ns/iter (+/- 919)\ntest u8_partial_cmp  ... bench:       7,118 ns/iter (+/- 1,623)\ntest u16_cmp         ... bench:       6,689 ns/iter (+/- 921)\ntest u16_lt          ... bench:       6,712 ns/iter (+/- 947)\ntest u16_partial_cmp ... bench:       6,725 ns/iter (+/- 780)\ntest u32_cmp         ... bench:       7,704 ns/iter (+/- 1,294)\ntest u32_lt          ... bench:       7,611 ns/iter (+/- 3,062)\ntest u32_partial_cmp ... bench:       7,640 ns/iter (+/- 1,149)\ntest u64_cmp         ... bench:       7,517 ns/iter (+/- 2,164)\ntest u64_lt          ... bench:       7,579 ns/iter (+/- 1,048)\ntest u64_partial_cmp ... bench:       7,629 ns/iter (+/- 1,195)\n```", "tree": {"sha": "4b9323431cb3da460489167cdfd5bba87c10ce78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b9323431cb3da460489167cdfd5bba87c10ce78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04b8b5818819470457fc00f87176b273d756980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04b8b5818819470457fc00f87176b273d756980", "html_url": "https://github.com/rust-lang/rust/commit/d04b8b5818819470457fc00f87176b273d756980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04b8b5818819470457fc00f87176b273d756980/comments", "author": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1614173b589620ba33aa91c49ea82513067566fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1614173b589620ba33aa91c49ea82513067566fb", "html_url": "https://github.com/rust-lang/rust/commit/1614173b589620ba33aa91c49ea82513067566fb"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "7af808d1e82834334c1761f78d2eab50c16d012f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d04b8b5818819470457fc00f87176b273d756980/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04b8b5818819470457fc00f87176b273d756980/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d04b8b5818819470457fc00f87176b273d756980", "patch": "@@ -1558,31 +1558,34 @@ impl<T: Eq> Eq for [T] {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Ord for [T] {\n+    #[inline]\n     fn cmp(&self, other: &[T]) -> Ordering {\n-        self.iter().cmp(other.iter())\n+        let l = cmp::min(self.len(), other.len());\n+\n+        for i in 0..l {\n+            match self[i].cmp(&other[i]) {\n+                Ordering::Equal => (),\n+                non_eq => return non_eq,\n+            }\n+        }\n+\n+        self.len().cmp(&other.len())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd> PartialOrd for [T] {\n     #[inline]\n     fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n-        self.iter().partial_cmp(other.iter())\n-    }\n-    #[inline]\n-    fn lt(&self, other: &[T]) -> bool {\n-        self.iter().lt(other.iter())\n-    }\n-    #[inline]\n-    fn le(&self, other: &[T]) -> bool {\n-        self.iter().le(other.iter())\n-    }\n-    #[inline]\n-    fn ge(&self, other: &[T]) -> bool {\n-        self.iter().ge(other.iter())\n-    }\n-    #[inline]\n-    fn gt(&self, other: &[T]) -> bool {\n-        self.iter().gt(other.iter())\n+        let l = cmp::min(self.len(), other.len());\n+\n+        for i in 0..l {\n+            match self[i].partial_cmp(&other[i]) {\n+                Some(Ordering::Equal) => (),\n+                non_eq => return non_eq,\n+            }\n+        }\n+\n+        self.len().partial_cmp(&other.len())\n     }\n }"}]}