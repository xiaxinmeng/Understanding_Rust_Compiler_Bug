{"sha": "a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Nzg4ZDBiYTgxNTM4YzE3ZTRiYjAwNDExNjNjMmQ0ZDFjZWI4NmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-19T05:00:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T05:00:00Z"}, "message": "Rollup merge of #37198 - jseyfried:future_proof_macros_11, r=nrc\n\nmacros 1.1: future proofing and cleanup\n\nThis PR\n - uses the macro namespace for custom derives (instead of a dedicated custom derive namespace),\n - relaxes the shadowing rules for `#[macro_use]`-imported custom derives to match the shadowing rules for ordinary `#[macro_use]`-imported macros, and\n - treats custom derive `extern crate`s like empty modules so that we can eventually allow, for example, `extern crate serde_derive; use serde_derive::Serialize;` backwards compatibly.\n\nr? @alexcrichton", "tree": {"sha": "1e4069d412865079dae86acdd44583a52dc7f5ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e4069d412865079dae86acdd44583a52dc7f5ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "html_url": "https://github.com/rust-lang/rust/commit/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38324dee2285348e636de282f3a56ba6931f6d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38324dee2285348e636de282f3a56ba6931f6d9", "html_url": "https://github.com/rust-lang/rust/commit/c38324dee2285348e636de282f3a56ba6931f6d9"}, {"sha": "aac6dca21e6a78a8bdf3406f682e2b1a7a7bdc36", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac6dca21e6a78a8bdf3406f682e2b1a7a7bdc36", "html_url": "https://github.com/rust-lang/rust/commit/aac6dca21e6a78a8bdf3406f682e2b1a7a7bdc36"}], "stats": {"total": 187, "additions": 92, "deletions": 95}, "files": [{"sha": "b54862ae0ade6c2f4be2e08d2b2a963b54e79a49", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -35,7 +35,6 @@ use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MultiItemModifier;\n@@ -425,7 +424,7 @@ pub struct LoadedMacro {\n \n pub enum LoadedMacroKind {\n     Def(ast::MacroDef),\n-    CustomDerive(String, Rc<MultiItemModifier>),\n+    CustomDerive(String, Box<MultiItemModifier>),\n }\n \n pub trait CrateLoader {"}, {"sha": "3b1b2a4cd27e432c13763072f7640cc4e2857d2c", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -11,7 +11,6 @@\n //! Used by `rustc` when loading a crate with exported macros.\n \n use std::collections::HashSet;\n-use std::rc::Rc;\n use std::env;\n use std::mem;\n \n@@ -212,7 +211,7 @@ impl<'a> CrateLoader<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n-                let derive = Rc::new(CustomDerive::new(expand));\n+                let derive = Box::new(CustomDerive::new(expand));\n                 self.0.push(LoadedMacro {\n                     kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n                     import_site: self.1,"}, {"sha": "e0abe8da82b9c26b9b256a28b6627e772e40be79", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n+use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n@@ -195,33 +195,45 @@ impl<'b> Resolver<'b> {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n                 let is_crate_root = self.current_module.parent.is_none();\n+                let import_macro = |this: &mut Self, name, ext, span| {\n+                    let shadowing = this.builtin_macros.insert(name, Rc::new(ext)).is_some();\n+                    if shadowing && expansion != Mark::root() {\n+                        let msg = format!(\"`{}` is already in scope\", name);\n+                        this.session.struct_span_err(span, &msg)\n+                            .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n+                                   existing macros (see RFC 1560)\")\n+                            .emit();\n+                    }\n+                };\n+\n+                let mut custom_derive_crate = false;\n                 for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n                     match loaded_macro.kind {\n                         LoadedMacroKind::Def(mut def) => {\n-                            let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext =\n-                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n-                                if self.builtin_macros.insert(name, ext).is_some() &&\n-                                   expansion != Mark::root() {\n-                                    let msg = format!(\"`{}` is already in scope\", name);\n-                                    self.session.struct_span_err(loaded_macro.import_site, &msg)\n-                                        .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n-                                               existing macros (see RFC 1560)\")\n-                                        .emit();\n-                                }\n-                                self.macro_names.insert(name);\n+                                self.macro_names.insert(def.ident.name);\n+                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                                import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n                             }\n                             if def.export {\n                                 def.id = self.next_node_id();\n                                 self.exported_macros.push(def);\n                             }\n                         }\n                         LoadedMacroKind::CustomDerive(name, ext) => {\n-                            self.insert_custom_derive(&name, ext, item.span);\n+                            custom_derive_crate = true;\n+                            let ext = SyntaxExtension::CustomDerive(ext);\n+                            import_macro(self, token::intern(&name), ext, loaded_macro.import_site);\n                         }\n                     }\n                 }\n+\n+                if custom_derive_crate && !self.session.features.borrow().proc_macro {\n+                    let issue = feature_gate::GateIssue::Language;\n+                    let msg = \"loading custom derive macro crates is experimentally supported\";\n+                    emit_feature_err(&self.session.parse_sess, \"proc_macro\", item.span, issue, msg);\n+                }\n+\n                 self.crate_loader.process_item(item, &self.definitions);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n@@ -238,6 +250,12 @@ impl<'b> Resolver<'b> {\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.populate_module_if_necessary(module);\n+                } else if custom_derive_crate {\n+                    // Define an empty module\n+                    let def = Def::Mod(self.definitions.local_def_id(item.id));\n+                    let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n+                    let module = self.arenas.alloc_module(module);\n+                    self.define(parent, name, TypeNS, (module, sp, vis));\n                 }\n             }\n \n@@ -504,17 +522,6 @@ impl<'b> Resolver<'b> {\n \n         false\n     }\n-\n-    fn insert_custom_derive(&mut self, name: &str, ext: Rc<MultiItemModifier>, sp: Span) {\n-        if !self.session.features.borrow().proc_macro {\n-            let sess = &self.session.parse_sess;\n-            let msg = \"loading custom derive macro crates is experimentally supported\";\n-            emit_feature_err(sess, \"proc_macro\", sp, feature_gate::GateIssue::Language, msg);\n-        }\n-        if self.derive_modes.insert(token::intern(name), ext).is_some() {\n-            self.session.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n-        }\n-    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {"}, {"sha": "298f41b971d062b08b7ac9c9ac38ed758a3860bd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -53,7 +53,6 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n@@ -1082,7 +1081,6 @@ pub struct Resolver<'a> {\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n-    pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n     builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n@@ -1273,7 +1271,6 @@ impl<'a> Resolver<'a> {\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n             exported_macros: Vec::new(),\n-            derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n             builtin_macros: FnvHashMap(),"}, {"sha": "cf5ea236b3ec7e845eee8d9bcd01c1d5c3b0bf30", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -17,9 +17,9 @@ use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n+use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n@@ -162,30 +162,22 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        let (name, span) = match invoc.kind {\n-            InvocationKind::Bang { ref mac, .. } => {\n-                let path = &mac.node.path;\n-                if path.segments.len() > 1 || path.global ||\n-                   !path.segments[0].parameters.is_empty() {\n-                    self.session.span_err(path.span,\n-                                          \"expected macro name without module separators\");\n-                    return Err(Determinacy::Determined);\n-                }\n-                (path.segments[0].identifier.name, path.span)\n-            }\n-            InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n-        };\n+        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n+            self.session.span_err(path.span, \"expected macro name without module separators\");\n+            return Err(Determinacy::Determined);\n+        }\n+        let name = path.segments[0].identifier.name;\n \n         let invocation = self.invocations[&scope];\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n         self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n             if force {\n-                let mut err =\n-                    self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+                let msg = format!(\"macro undefined: '{}!'\", name);\n+                let mut err = self.session.struct_span_err(path.span, &msg);\n                 self.suggest_macro_name(&name.as_str(), &mut err);\n                 err.emit();\n                 Determinacy::Determined\n@@ -194,10 +186,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         })\n     }\n-\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n-        self.derive_modes.get(&ident.name).cloned()\n-    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "f3272960e8313cfc6d7649e8fe01c2039a9e4770", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -15,7 +15,7 @@ use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n-use ext::expand::{self, Invocation, Expansion};\n+use ext::expand::{self, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser};\n@@ -508,6 +508,8 @@ pub enum SyntaxExtension {\n     /// the block.\n     ///\n     IdentTT(Box<IdentMacroExpander>, Option<Span>, bool),\n+\n+    CustomDerive(Box<MultiItemModifier>),\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -522,9 +524,8 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -545,8 +546,7 @@ impl Resolver for DummyResolver {\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n-    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation, _force: bool)\n+    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }"}, {"sha": "6aeb46fd52276126f5d91aca2812a36be174128e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -240,7 +240,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let ext = match self.cx.resolver.resolve_invoc(scope, &invoc, force) {\n+            let resolution = match invoc.kind {\n+                InvocationKind::Bang { ref mac, .. } => {\n+                    self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n+                }\n+                InvocationKind::Attr { ref attr, .. } => {\n+                    let ident = ast::Ident::with_empty_ctxt(intern(&*attr.name()));\n+                    let path = ast::Path::from_ident(attr.span, ident);\n+                    self.cx.resolver.resolve_macro(scope, &path, force)\n+                }\n+            };\n+            let ext = match resolution {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -354,7 +364,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n                 self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n-            _ => unreachable!(),\n+            SyntaxExtension::CustomDerive(_) => {\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", name));\n+                kind.dummy(attr.span)\n+            }\n+            _ => {\n+                let msg = &format!(\"macro `{}` may not be used in attributes\", name);\n+                self.cx.span_err(attr.span, &msg);\n+                kind.dummy(attr.span)\n+            }\n         }\n     }\n \n@@ -429,6 +447,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 return kind.dummy(span);\n             }\n \n+            SyntaxExtension::CustomDerive(..) => {\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", extname));\n+                return kind.dummy(span);\n+            }\n+\n             SyntaxExtension::ProcMacro(ref expandfun) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg ="}, {"sha": "07401d59a15db2678321832b809035b20808756d", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::{self, MetaItem};\n use syntax::attr::HasAttrs;\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -158,10 +158,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        let derive_mode = ast::Ident::with_empty_ctxt(intern(&tname));\n-        let derive_mode = cx.resolver.resolve_derive_mode(derive_mode);\n-        if is_builtin_trait(&tname) || derive_mode.is_some() {\n-            return true\n+        if is_builtin_trait(&tname) || {\n+            let derive_mode =\n+                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+            cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n+                if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n+            }).unwrap_or(false)\n+        } {\n+            return true;\n         }\n \n         if !cx.ecfg.enable_custom_derive() {\n@@ -216,7 +220,9 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n-        let ext = cx.resolver.resolve_derive_mode(tname).unwrap();\n+        let path = ast::Path::from_ident(titem.span, tname);\n+        let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n+\n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n@@ -232,7 +238,11 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                  intern_and_get_ident(\"derive\"),\n                                  vec![titem]);\n         let item = Annotatable::Item(item);\n-        return ext.expand(cx, mitem.span, &mitem, item)\n+        if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n+            return ext.expand(cx, mitem.span, &mitem, item);\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor"}, {"sha": "4aa4238611d8947a1488f1956f42e70c5666adce", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-a-2.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c38324dee2285348e636de282f3a56ba6931f6d9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38324dee2285348e636de282f3a56ba6931f6d9/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a-2.rs?ref=c38324dee2285348e636de282f3a56ba6931f6d9", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// force-host\n-// no-prefer-dynamic\n-\n-#![feature(proc_macro)]\n-#![feature(proc_macro_lib)]\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(A)]\n-pub fn derive_a(input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "a04756ca19ba7e225a9fe0751b173298c0246b3a", "filename": "src/test/compile-fail-fulldeps/proc-macro/shadow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6788d0ba81538c17e4bb0041163c2d4d1ceb86d/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fshadow.rs?ref=a6788d0ba81538c17e4bb0041163c2d4d1ceb86d", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n // aux-build:derive-a.rs\n-// aux-build:derive-a-2.rs\n \n #![feature(proc_macro)]\n \n #[macro_use]\n extern crate derive_a;\n #[macro_use]\n-extern crate derive_a_2; //~ ERROR: cannot shadow existing derive mode `A`\n+extern crate derive_a; //~ ERROR `derive_a` has already been defined\n \n fn main() {}"}]}