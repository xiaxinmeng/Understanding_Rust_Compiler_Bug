{"sha": "99293b16e46a14e4fb49ab2ebd02a521634c2b44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MjkzYjE2ZTQ2YTE0ZTRmYjQ5YWIyZWJkMDJhNTIxNjM0YzJiNDQ=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-09-16T05:22:12Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-09-17T02:21:18Z"}, "message": "Convert restriction enum into bitflags\n\nThis makes having multiple restrictions at once cleaner.\nAlso drop NO_DOUBLEBAR restriction since it is never used.", "tree": {"sha": "064d20b6cc1f404b08595692a5a21d465263f12a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064d20b6cc1f404b08595692a5a21d465263f12a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99293b16e46a14e4fb49ab2ebd02a521634c2b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99293b16e46a14e4fb49ab2ebd02a521634c2b44", "html_url": "https://github.com/rust-lang/rust/commit/99293b16e46a14e4fb49ab2ebd02a521634c2b44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99293b16e46a14e4fb49ab2ebd02a521634c2b44/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63eaba24d6a7f93061d63337ea1f7083ca892787", "url": "https://api.github.com/repos/rust-lang/rust/commits/63eaba24d6a7f93061d63337ea1f7083ca892787", "html_url": "https://github.com/rust-lang/rust/commit/63eaba24d6a7f93061d63337ea1f7083ca892787"}], "stats": {"total": 60, "additions": 28, "deletions": 32}, "files": [{"sha": "44576f7c166d3ef4b67b5f7b55aacaecfdad0b82", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/99293b16e46a14e4fb49ab2ebd02a521634c2b44/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99293b16e46a14e4fb49ab2ebd02a521634c2b44/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=99293b16e46a14e4fb49ab2ebd02a521634c2b44", "patch": "@@ -88,14 +88,13 @@ use std::mem;\n use std::rc::Rc;\n use std::iter;\n \n-#[allow(non_camel_case_types)]\n-#[deriving(PartialEq)]\n-pub enum restriction {\n-    UNRESTRICTED,\n-    RESTRICT_STMT_EXPR,\n-    RESTRICT_NO_BAR_OP,\n-    RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n-    RESTRICT_NO_STRUCT_LITERAL,\n+bitflags! {\n+    flags Restrictions: u8 {\n+        static Unrestricted               = 0b0000,\n+        static RestrictionStmtExpr        = 0b0001,\n+        static RestrictionNoBarOp         = 0b0010,\n+        static RestrictionNoStructLiteral = 0b0100\n+    }\n }\n \n type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n@@ -314,7 +313,7 @@ pub struct Parser<'a> {\n     pub buffer_start: int,\n     pub buffer_end: int,\n     pub tokens_consumed: uint,\n-    pub restriction: restriction,\n+    pub restrictions: Restrictions,\n     pub quote_depth: uint, // not (yet) related to the quasiquoter\n     pub reader: Box<Reader+'a>,\n     pub interner: Rc<token::IdentInterner>,\n@@ -383,7 +382,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restriction: UNRESTRICTED,\n+            restrictions: Unrestricted,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2189,7 +2188,7 @@ impl<'a> Parser<'a> {\n                     if self.token == token::LBRACE {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if self.restriction != RESTRICT_NO_STRUCT_LITERAL {\n+                        if !self.restrictions.contains(RestrictionNoStructLiteral) {\n                             // It's a struct literal.\n                             self.bump();\n                             let mut fields = Vec::new();\n@@ -2651,12 +2650,9 @@ impl<'a> Parser<'a> {\n \n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n-        match (&self.token, &self.restriction) {\n-            (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n-            (&token::BINOP(token::OR),\n-                &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-            (&token::OROR, &RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) => return lhs,\n-            _ => { }\n+        if self.token == token::BINOP(token::OR) &&\n+            self.restrictions.contains(RestrictionNoBarOp) {\n+            return lhs;\n         }\n \n         let cur_opt = token_to_binop(&self.token);\n@@ -2730,7 +2726,7 @@ impl<'a> Parser<'a> {\n     /// Parse an 'if' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let thn = self.parse_block();\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2791,7 +2787,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = self.parse_pat();\n         self.expect_keyword(keywords::In);\n-        let expr = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n@@ -2800,7 +2796,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n@@ -2815,7 +2811,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let discriminant = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);\n+        let discriminant = self.parse_expr_res(RestrictionNoStructLiteral);\n         self.commit_expr_expecting(&*discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n@@ -2834,7 +2830,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr());\n         }\n         self.expect(&token::FAT_ARROW);\n-        let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+        let expr = self.parse_expr_res(RestrictionStmtExpr);\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2856,15 +2852,15 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> P<Expr> {\n-        return self.parse_expr_res(UNRESTRICTED);\n+        return self.parse_expr_res(Unrestricted);\n     }\n \n-    /// Parse an expression, subject to the given restriction\n-    pub fn parse_expr_res(&mut self, r: restriction) -> P<Expr> {\n-        let old = self.restriction;\n-        self.restriction = r;\n+    /// Parse an expression, subject to the given restrictions\n+    pub fn parse_expr_res(&mut self, r: Restrictions) -> P<Expr> {\n+        let old = self.restrictions;\n+        self.restrictions = r;\n         let e = self.parse_assign_expr();\n-        self.restriction = old;\n+        self.restrictions = old;\n         return e;\n     }\n \n@@ -3153,9 +3149,9 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n-                let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                let start = self.parse_expr_res(RestrictionNoBarOp);\n                 self.eat(&token::DOTDOT);\n-                let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n+                let end = self.parse_expr_res(RestrictionNoBarOp);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n                 let id = self.parse_ident();\n@@ -3441,7 +3437,7 @@ impl<'a> Parser<'a> {\n                     check_expected_item(self, found_attrs);\n \n                     // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+                    let e = self.parse_expr_res(RestrictionStmtExpr);\n                     P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n                 }\n             }\n@@ -3450,7 +3446,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restriction == RESTRICT_STMT_EXPR &&\n+        self.restrictions.contains(RestrictionStmtExpr) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}]}