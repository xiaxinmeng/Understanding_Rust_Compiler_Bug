{"sha": "755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NWQyN2E0MjQxZDliMmE2ZmE5MDExOGQ5ZDQwYWU3MjlmZTVjNjg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T05:33:00Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T05:33:00Z"}, "message": "Take impl Iterator for overflow routines", "tree": {"sha": "d76185889aab251256b7b6c30e26be057402a32c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d76185889aab251256b7b6c30e26be057402a32c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "html_url": "https://github.com/rust-lang/rust/commit/755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c1b0c2241bf72b2c66a73b3468e6698964e3f0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c1b0c2241bf72b2c66a73b3468e6698964e3f0a", "html_url": "https://github.com/rust-lang/rust/commit/4c1b0c2241bf72b2c66a73b3468e6698964e3f0a"}], "stats": {"total": 125, "additions": 72, "deletions": 53}, "files": [{"sha": "f104a40bf872c6d3c5f50189f6d408cae64d9659", "filename": "src/expr.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -73,7 +73,7 @@ pub fn format_expr(\n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n             \"\",\n-            &ptr_vec_to_ref_vec(expr_vec),\n+            expr_vec.iter(),\n             expr.span,\n             context,\n             shape,\n@@ -110,7 +110,7 @@ pub fn format_expr(\n             shape,\n         ),\n         ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(context, &ptr_vec_to_ref_vec(items), expr.span, shape)\n+            rewrite_tuple(context, items.iter(), expr.span, shape, items.len() == 1)\n         }\n         ast::ExprKind::If(..)\n         | ast::ExprKind::IfLet(..)\n@@ -391,15 +391,18 @@ pub fn format_expr(\n         })\n }\n \n-pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n-    name: &str,\n-    exprs: &[&T],\n+pub fn rewrite_array<'a, T: 'a>(\n+    name: &'a str,\n+    exprs: impl Iterator<Item = &'a T>,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &'a RewriteContext,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n-) -> Option<String> {\n+) -> Option<String>\n+where\n+    T: Rewrite + Spanned + ToExpr,\n+{\n     overflow::rewrite_with_square_brackets(\n         context,\n         name,\n@@ -1329,7 +1332,7 @@ pub fn rewrite_call(\n     overflow::rewrite_with_parens(\n         context,\n         callee,\n-        &ptr_vec_to_ref_vec(args),\n+        args.iter(),\n         shape,\n         span,\n         context.config.width_heuristics().fn_call_width,\n@@ -1722,17 +1725,17 @@ pub fn rewrite_field(\n \n fn rewrite_tuple_in_visual_indent_style<'a, T>(\n     context: &RewriteContext,\n-    items: &[&T],\n+    mut items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n+    is_singleton_tuple: bool,\n ) -> Option<String>\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n-    let mut items = items.iter();\n     // In case of length 1, need a trailing comma\n     debug!(\"rewrite_tuple_in_visual_indent_style {:?}\", shape);\n-    if items.len() == 1 {\n+    if is_singleton_tuple {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = shape.sub_width(3)?.visual_indent(1);\n         return items\n@@ -1772,10 +1775,11 @@ where\n }\n \n pub fn rewrite_tuple<'a, T>(\n-    context: &RewriteContext,\n-    items: &[&T],\n+    context: &'a RewriteContext,\n+    items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n+    is_singleton_tuple: bool,\n ) -> Option<String>\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n@@ -1789,7 +1793,7 @@ where\n             } else {\n                 Some(SeparatorTactic::Never)\n             }\n-        } else if items.len() == 1 {\n+        } else if is_singleton_tuple {\n             Some(SeparatorTactic::Always)\n         } else {\n             None\n@@ -1804,7 +1808,7 @@ where\n             force_tactic,\n         )\n     } else {\n-        rewrite_tuple_in_visual_indent_style(context, items, span, shape)\n+        rewrite_tuple_in_visual_indent_style(context, items, span, shape, is_singleton_tuple)\n     }\n }\n \n@@ -2068,6 +2072,16 @@ impl ToExpr for ast::GenericParam {\n     }\n }\n \n+impl<T: ToExpr> ToExpr for ptr::P<T> {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        (**self).to_expr()\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        (**self).can_be_overflowed(context, len)\n+    }\n+}\n+\n pub fn is_method_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::MethodCall(..) => true,"}, {"sha": "3f8fb852497624c49b6eccba4a78689e45fef3b2", "filename": "src/items.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -1391,11 +1391,10 @@ fn format_tuple_struct(\n         format_empty_struct_or_tuple(context, inner_span, offset, &mut result, \"(\", \")\");\n     } else {\n         let shape = Shape::indented(offset, context.config).sub_width(1)?;\n-        let fields = &fields.iter().collect::<Vec<_>>();\n         result = overflow::rewrite_with_parens(\n             context,\n             &result,\n-            fields,\n+            fields.iter(),\n             shape,\n             span,\n             context.config.width_heuristics().fn_call_width,\n@@ -2495,7 +2494,7 @@ fn rewrite_generics(\n         return Some(ident.to_owned());\n     }\n \n-    let params = &generics.params.iter().map(|e| &*e).collect::<Vec<_>>();\n+    let params = generics.params.iter();\n     overflow::rewrite_with_angle_brackets(context, ident, params, shape, generics.span)\n }\n "}, {"sha": "886e929c43f2c17f9b5c3f40c4ebb210dc14fd0e", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -278,7 +278,7 @@ pub fn rewrite_macro_inner(\n             overflow::rewrite_with_parens(\n                 context,\n                 &macro_name,\n-                &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>(),\n+                arg_vec.iter(),\n                 shape,\n                 mac.span,\n                 context.config.width_heuristics().fn_call_width,\n@@ -334,11 +334,9 @@ pub fn rewrite_macro_inner(\n                         force_trailing_comma = Some(SeparatorTactic::Vertical);\n                     };\n                 }\n-                // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n-                let arg_vec = &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>();\n                 let rewrite = rewrite_array(\n                     macro_name,\n-                    arg_vec,\n+                    arg_vec.iter(),\n                     mac.span,\n                     context,\n                     shape,"}, {"sha": "5c50e3b3a37ca742328453702236cff9fbe31ad1", "filename": "src/overflow.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -29,10 +29,10 @@ use std::cmp::min;\n \n const SHORT_ITEM_THRESHOLD: usize = 10;\n \n-pub fn rewrite_with_parens<T>(\n-    context: &RewriteContext,\n-    ident: &str,\n-    items: &[&T],\n+pub fn rewrite_with_parens<'a, 'b, T: 'a>(\n+    context: &'a RewriteContext,\n+    ident: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     item_max_width: usize,\n@@ -56,10 +56,10 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_angle_brackets<T>(\n-    context: &RewriteContext,\n-    ident: &str,\n-    items: &[&T],\n+pub fn rewrite_with_angle_brackets<'a, T: 'a>(\n+    context: &'a RewriteContext,\n+    ident: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n ) -> Option<String>\n@@ -81,10 +81,10 @@ where\n     .rewrite(shape)\n }\n \n-pub fn rewrite_with_square_brackets<T>(\n-    context: &RewriteContext,\n-    name: &str,\n-    items: &[&T],\n+pub fn rewrite_with_square_brackets<'a, T: 'a>(\n+    context: &'a RewriteContext,\n+    name: &'a str,\n+    items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n     span: Span,\n     force_separator_tactic: Option<SeparatorTactic>,\n@@ -115,7 +115,7 @@ where\n \n struct Context<'a, T: 'a> {\n     context: &'a RewriteContext<'a>,\n-    items: &'a [&'a T],\n+    items: Vec<&'a T>,\n     ident: &'a str,\n     prefix: &'static str,\n     suffix: &'static str,\n@@ -131,7 +131,7 @@ struct Context<'a, T: 'a> {\n impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n     pub fn new(\n         context: &'a RewriteContext,\n-        items: &'a [&'a T],\n+        items: impl Iterator<Item = &'a T>,\n         ident: &'a str,\n         shape: Shape,\n         span: Span,\n@@ -153,7 +153,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         let nested_shape = shape_from_indent_style(context, shape, used_width + 2, used_width + 1);\n         Context {\n             context,\n-            items,\n+            items: items.collect(),\n             ident,\n             one_line_shape,\n             nested_shape,\n@@ -192,7 +192,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                 ast::ExprKind::Closure(..) => {\n                     // If the argument consists of multiple closures, we do not overflow\n                     // the last closure.\n-                    if closures::args_have_many_closure(self.items) {\n+                    if closures::args_have_many_closure(&self.items) {\n                         None\n                     } else {\n                         closures::rewrite_last_closure(self.context, expr, shape)\n@@ -227,7 +227,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         let combine_arg_with_callee = self.items.len() == 1\n             && self.items[0].to_expr().is_some()\n             && self.ident.len() < self.context.config.tab_spaces();\n-        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, self.items);\n+        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, &self.items);\n \n         // Replace the last item with its first line to see if it fits with\n         // first arguments.\n@@ -241,7 +241,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                 }\n             }\n             let result = last_item_shape(\n-                self.items,\n+                &self.items,\n                 list_items,\n                 self.one_line_shape,\n                 self.item_max_width,\n@@ -316,7 +316,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n \n                     if tactic == DefinitiveListTactic::Vertical {\n                         if let Some((all_simple, num_args_before)) =\n-                            maybe_get_args_offset(self.ident, self.items)\n+                            maybe_get_args_offset(self.ident, &self.items)\n                         {\n                             let one_line = all_simple\n                                 && definitive_tactic(\n@@ -335,7 +335,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                             if one_line {\n                                 tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n                             };\n-                        } else if is_every_expr_simple(self.items) && no_long_items(list_items) {\n+                        } else if is_every_expr_simple(&self.items) && no_long_items(list_items) {\n                             tactic = DefinitiveListTactic::Mixed;\n                         }\n                     }"}, {"sha": "8277a768e0ee99728a93c5ebca890d684b6b8d59", "filename": "src/patterns.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -359,12 +359,11 @@ fn rewrite_tuple_pat(\n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none() && !condensed;\n     let path_str = path_str.unwrap_or_default();\n-    let pat_ref_vec = pat_vec.iter().collect::<Vec<_>>();\n \n     overflow::rewrite_with_parens(\n         &context,\n         &path_str,\n-        &pat_ref_vec,\n+        pat_vec.iter(),\n         shape,\n         span,\n         context.config.max_width(),"}, {"sha": "d151c922e812a18512ef48c1bb885dc72d9c521a", "filename": "src/rewrite.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -11,6 +11,7 @@\n // A generic trait to abstract the rewriting of an element (of the AST).\n \n use syntax::parse::ParseSess;\n+use syntax::ptr;\n use syntax::source_map::{SourceMap, Span};\n \n use config::{Config, IndentStyle};\n@@ -25,6 +26,12 @@ pub trait Rewrite {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n }\n \n+impl<T: Rewrite> Rewrite for ptr::P<T> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        (**self).rewrite(context, shape)\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct RewriteContext<'a> {\n     pub parse_session: &'a ParseSess,"}, {"sha": "504d18fb7fd1752729af5b226100a1a825af3844", "filename": "src/spanned.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::ast;\n-use syntax::source_map::Span;\n+use syntax::{ast, ptr, source_map::Span};\n \n use macros::MacroArg;\n use utils::{mk_sp, outer_attributes};\n@@ -21,6 +20,12 @@ pub trait Spanned {\n     fn span(&self) -> Span;\n }\n \n+impl<T: Spanned> Spanned for ptr::P<T> {\n+    fn span(&self) -> Span {\n+        (**self).span()\n+    }\n+}\n+\n macro_rules! span_with_attrs_lo_hi {\n     ($this:ident, $lo:expr, $hi:expr) => {{\n         let attrs = outer_attributes(&$this.attrs);"}, {"sha": "8ab89848407f1e5285d17260344679b433ed08c4", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755d27a4241d9b2a6fa90118d9d40ae729fe5c68/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=755d27a4241d9b2a6fa90118d9d40ae729fe5c68", "patch": "@@ -252,7 +252,7 @@ fn rewrite_segment(\n                 let generics_str = overflow::rewrite_with_angle_brackets(\n                     context,\n                     \"\",\n-                    &param_list.iter().map(|e| &*e).collect::<Vec<_>>(),\n+                    param_list.iter(),\n                     shape,\n                     mk_sp(*span_lo, span_hi),\n                 )?;\n@@ -664,12 +664,9 @@ impl Rewrite for ast::Ty {\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| format!(\"[{}]\", ty_str))\n             }\n-            ast::TyKind::Tup(ref items) => rewrite_tuple(\n-                context,\n-                &::utils::ptr_vec_to_ref_vec(items),\n-                self.span,\n-                shape,\n-            ),\n+            ast::TyKind::Tup(ref items) => {\n+                rewrite_tuple(context, items.iter(), self.span, shape, items.len() == 1)\n+            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }"}]}