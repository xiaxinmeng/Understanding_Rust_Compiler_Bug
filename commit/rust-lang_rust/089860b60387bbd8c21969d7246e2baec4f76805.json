{"sha": "089860b60387bbd8c21969d7246e2baec4f76805", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4OTg2MGI2MDM4N2JiZDhjMjE5NjlkNzI0NmUyYmFlYzRmNzY4MDU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-04T13:06:57Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-10T10:21:39Z"}, "message": "incr.comp.: Manage dependency graph on main thread.", "tree": {"sha": "8a832ff3dce321022a0e35b7903d9e957eb895f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a832ff3dce321022a0e35b7903d9e957eb895f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/089860b60387bbd8c21969d7246e2baec4f76805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/089860b60387bbd8c21969d7246e2baec4f76805", "html_url": "https://github.com/rust-lang/rust/commit/089860b60387bbd8c21969d7246e2baec4f76805", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/089860b60387bbd8c21969d7246e2baec4f76805/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13e87d1dbb4d3f3071b5807a69d11468173e3522", "url": "https://api.github.com/repos/rust-lang/rust/commits/13e87d1dbb4d3f3071b5807a69d11468173e3522", "html_url": "https://github.com/rust-lang/rust/commit/13e87d1dbb4d3f3071b5807a69d11468173e3522"}], "stats": {"total": 653, "additions": 175, "deletions": 478}, "files": [{"sha": "389e7f08dfd2957198de18339d0fb0435cd9916d", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 101, "deletions": 88, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=089860b60387bbd8c21969d7246e2baec4f76805", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::env;\n use super::{DepGraphQuery, DepNode};\n+use super::debug::EdgeFilter;\n \n pub struct DepGraphEdges {\n     nodes: Vec<DepNode>,\n     indices: FxHashMap<DepNode, IdIndex>,\n     edges: FxHashSet<(IdIndex, IdIndex)>,\n-    open_nodes: Vec<OpenNode>,\n+    task_stack: Vec<OpenTask>,\n+    forbidden_edge: Option<EdgeFilter>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -35,125 +38,109 @@ impl IdIndex {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-enum OpenNode {\n-    Node(IdIndex),\n+enum OpenTask {\n+    Regular {\n+        node: DepNode,\n+        reads: Vec<DepNode>,\n+        read_set: FxHashSet<DepNode>,\n+    },\n     Ignore,\n }\n \n impl DepGraphEdges {\n     pub fn new() -> DepGraphEdges {\n+        let forbidden_edge = if cfg!(debug_assertions) {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FxHashMap(),\n             edges: FxHashSet(),\n-            open_nodes: Vec::new()\n+            task_stack: Vec::new(),\n+            forbidden_edge,\n         }\n     }\n \n     fn id(&self, index: IdIndex) -> DepNode {\n-        self.nodes[index.index()].clone()\n-    }\n-\n-    /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode) -> IdIndex {\n-        if let Some(&i) = self.indices.get(&id) {\n-            return i;\n-        }\n-\n-        let index = IdIndex::new(self.nodes.len());\n-        self.nodes.push(id.clone());\n-        self.indices.insert(id, index);\n-        index\n-    }\n-\n-    /// Top of the stack of open nodes.\n-    fn current_node(&self) -> Option<OpenNode> {\n-        self.open_nodes.last().cloned()\n+        self.nodes[index.index()]\n     }\n \n     pub fn push_ignore(&mut self) {\n-        self.open_nodes.push(OpenNode::Ignore);\n+        self.task_stack.push(OpenTask::Ignore);\n     }\n \n     pub fn pop_ignore(&mut self) {\n-        let popped_node = self.open_nodes.pop().unwrap();\n-        assert_eq!(popped_node, OpenNode::Ignore);\n+        let popped_node = self.task_stack.pop().unwrap();\n+        debug_assert_eq!(popped_node, OpenTask::Ignore);\n     }\n \n     pub fn push_task(&mut self, key: DepNode) {\n-        let top_node = self.current_node();\n-\n-        let new_node = self.make_node(key);\n-        self.open_nodes.push(OpenNode::Node(new_node));\n-\n-        // if we are in the midst of doing task T, then this new task\n-        // N is a subtask of T, so add an edge N -> T.\n-        if let Some(top_node) = top_node {\n-            self.add_edge_from_open_node(top_node, |t| (new_node, t));\n-        }\n+        self.task_stack.push(OpenTask::Regular {\n+            node: key,\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n     }\n \n     pub fn pop_task(&mut self, key: DepNode) {\n-        let popped_node = self.open_nodes.pop().unwrap();\n-        assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Regular {\n+            node,\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            debug_assert_eq!(node, key);\n+\n+            let target_id = self.get_or_create_node(node);\n+\n+            for read in reads.into_iter() {\n+                let source_id = self.get_or_create_node(read);\n+                self.edges.insert((source_id, target_id));\n+            }\n+        } else {\n+            bug!(\"pop_task() - Expected regular task to be popped\")\n+        }\n     }\n \n     /// Indicates that the current task `C` reads `v` by adding an\n     /// edge from `v` to `C`. If there is no current task, has no\n     /// effect. Note that *reading* from tracked state is harmless if\n     /// you are not in a task; what is bad is *writing* to tracked\n     /// state (and leaking data that you read into a tracked task).\n-    pub fn read(&mut self, v: DepNode) {\n-        if self.current_node().is_some() {\n-            let source = self.make_node(v);\n-            self.add_edge_from_current_node(|current| (source, current))\n-        }\n-    }\n-\n-    /// Indicates that the current task `C` writes `v` by adding an\n-    /// edge from `C` to `v`. If there is no current task, panics. If\n-    /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode) {\n-        let target = self.make_node(v);\n-        self.add_edge_from_current_node(|current| (current, target))\n-    }\n-\n-    /// Invoke `add_edge_from_open_node` with the top of the stack, or\n-    /// panic if stack is empty.\n-    fn add_edge_from_current_node<OP>(&mut self,\n-                                      op: OP)\n-        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n-    {\n-        match self.current_node() {\n-            Some(open_node) => self.add_edge_from_open_node(open_node, op),\n-            None => bug!(\"no current node, cannot add edge into dependency graph\")\n-        }\n-    }\n-\n-    /// Adds an edge to or from the `open_node`, assuming `open_node`\n-    /// is not `Ignore`. The direction of the edge is determined by\n-    /// the closure `op` --- we pass as argument the open node `n`,\n-    /// and the closure returns a (source, target) tuple, which should\n-    /// include `n` in one spot or another.\n-    fn add_edge_from_open_node<OP>(&mut self,\n-                                   open_node: OpenNode,\n-                                   op: OP)\n-        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n-    {\n-        let (source, target) = match open_node {\n-            OpenNode::Node(n) => op(n),\n-            OpenNode::Ignore => { return; }\n-        };\n-\n-        // ignore trivial self edges, which are not very interesting\n-        if source == target {\n-            return;\n-        }\n-\n-        if self.edges.insert((source, target)) {\n-            debug!(\"adding edge from {:?} to {:?}\",\n-                   self.id(source),\n-                   self.id(target));\n+    pub fn read(&mut self, source: DepNode) {\n+        match self.task_stack.last_mut() {\n+            Some(&mut OpenTask::Regular {\n+                node: target,\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+\n+                    if cfg!(debug_assertions) {\n+                        if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                            if forbidden_edge.test(&source, &target) {\n+                                bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Some(&mut OpenTask::Ignore) | None => {\n+                // ignore\n+            }\n         }\n     }\n \n@@ -163,4 +150,30 @@ impl DepGraphEdges {\n                                       .collect();\n         DepGraphQuery::new(&self.nodes, &edges)\n     }\n+\n+    #[inline]\n+    pub fn add_edge(&mut self, source: DepNode, target: DepNode) {\n+        let source = self.get_or_create_node(source);\n+        let target = self.get_or_create_node(target);\n+        self.edges.insert((source, target));\n+    }\n+\n+    pub fn add_node(&mut self, node: DepNode) {\n+        self.get_or_create_node(node);\n+    }\n+\n+    #[inline]\n+    fn get_or_create_node(&mut self, dep_node: DepNode) -> IdIndex {\n+        let DepGraphEdges {\n+            ref mut indices,\n+            ref mut nodes,\n+            ..\n+        } = *self;\n+\n+        *indices.entry(dep_node).or_insert_with(|| {\n+            let next_id = nodes.len();\n+            nodes.push(dep_node);\n+            IdIndex::new(next_id)\n+        })\n+     }\n }"}, {"sha": "b657102df39f49c2e47723d25a9ad59ad7468109", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=089860b60387bbd8c21969d7246e2baec4f76805", "patch": "@@ -17,17 +17,16 @@ use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::thread::{DepGraphThreadData, DepMessage};\n+use super::edges::DepGraphEdges;\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Rc<DepGraphData>\n+    data: Option<Rc<DepGraphData>>\n }\n \n struct DepGraphData {\n-    /// We send messages to the thread to let it build up the dep-graph\n-    /// from the current run.\n-    thread: DepGraphThreadData,\n+    /// The actual graph data.\n+    edges: RefCell<DepGraphEdges>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -44,31 +43,35 @@ struct DepGraphData {\n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n-            data: Rc::new(DepGraphData {\n-                thread: DepGraphThreadData::new(enabled),\n-                previous_work_products: RefCell::new(FxHashMap()),\n-                work_products: RefCell::new(FxHashMap()),\n-                dep_node_debug: RefCell::new(FxHashMap()),\n-            })\n+            data: if enabled {\n+                Some(Rc::new(DepGraphData {\n+                    previous_work_products: RefCell::new(FxHashMap()),\n+                    work_products: RefCell::new(FxHashMap()),\n+                    edges: RefCell::new(DepGraphEdges::new()),\n+                    dep_node_debug: RefCell::new(FxHashMap()),\n+                }))\n+            } else {\n+                None\n+            }\n         }\n     }\n \n     /// True if we are actually building the full dep-graph.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n-        self.data.thread.is_fully_enabled()\n+        self.data.is_some()\n     }\n \n     pub fn query(&self) -> DepGraphQuery {\n-        self.data.thread.query()\n+        self.data.as_ref().unwrap().edges.borrow().query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        raii::IgnoreTask::new(&self.data.thread)\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n     }\n \n     pub fn in_task<'graph>(&'graph self, key: DepNode) -> Option<raii::DepTask<'graph>> {\n-        raii::DepTask::new(&self.data.thread, key)\n+        self.data.as_ref().map(|data| raii::DepTask::new(&data.edges, key))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -112,48 +115,70 @@ impl DepGraph {\n         task(cx, arg)\n     }\n \n+    #[inline]\n     pub fn read(&self, v: DepNode) {\n-        if self.data.thread.is_enqueue_enabled() {\n-            self.data.thread.enqueue(DepMessage::Read(v));\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().read(v);\n         }\n     }\n \n+    /// Only to be used during graph loading\n+    #[inline]\n+    pub fn add_edge_directly(&self, source: DepNode, target: DepNode) {\n+        self.data.as_ref().unwrap().edges.borrow_mut().add_edge(source, target);\n+    }\n+\n+    /// Only to be used during graph loading\n+    pub fn add_node_directly(&self, node: DepNode) {\n+        self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory).\n     pub fn insert_previous_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n-        self.data.previous_work_products.borrow_mut()\n-                                        .insert(v.clone(), data);\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .previous_work_products\n+            .borrow_mut()\n+            .insert(v.clone(), data);\n     }\n \n     /// Indicates that we created the given work-product in this run\n     /// for `v`. This record will be preserved and loaded in the next\n     /// run.\n     pub fn insert_work_product(&self, v: &WorkProductId, data: WorkProduct) {\n         debug!(\"insert_work_product({:?}, {:?})\", v, data);\n-        self.data.work_products.borrow_mut()\n-                               .insert(v.clone(), data);\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .work_products\n+            .borrow_mut()\n+            .insert(v.clone(), data);\n     }\n \n     /// Check whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n-        self.data.previous_work_products.borrow()\n-                                        .get(v)\n-                                        .cloned()\n+        self.data\n+            .as_ref()\n+            .and_then(|data| {\n+                data.previous_work_products.borrow().get(v).cloned()\n+            })\n     }\n \n     /// Access the map of work-products created during this run. Only\n     /// used during saving of the dep-graph.\n     pub fn work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n-        self.data.work_products.borrow()\n+        self.data.as_ref().unwrap().work_products.borrow()\n     }\n \n     /// Access the map of work-products created during the cached run. Only\n     /// used during saving of the dep-graph.\n     pub fn previous_work_products(&self) -> Ref<FxHashMap<WorkProductId, WorkProduct>> {\n-        self.data.previous_work_products.borrow()\n+        self.data.as_ref().unwrap().previous_work_products.borrow()\n     }\n \n     #[inline(always)]\n@@ -162,14 +187,14 @@ impl DepGraph {\n                                           debug_str_gen: F)\n         where F: FnOnce() -> String\n     {\n-        let mut dep_node_debug = self.data.dep_node_debug.borrow_mut();\n+        let mut dep_node_debug = self.data.as_ref().unwrap().dep_node_debug.borrow_mut();\n \n         dep_node_debug.entry(dep_node)\n                       .or_insert_with(debug_str_gen);\n     }\n \n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n-        self.data.dep_node_debug.borrow().get(&dep_node).cloned()\n+        self.data.as_ref().unwrap().dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n }\n "}, {"sha": "df8c3ba4ac847ec0edfef6271c6b9c6938b10fd2", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=089860b60387bbd8c21969d7246e2baec4f76805", "patch": "@@ -16,8 +16,6 @@ mod graph;\n mod query;\n mod raii;\n mod safe;\n-mod shadow;\n-mod thread;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;"}, {"sha": "ce261ca68e8a323b3ee719bf0e5e2fba7095c697", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=089860b60387bbd8c21969d7246e2baec4f76805", "patch": "@@ -9,53 +9,49 @@\n // except according to those terms.\n \n use super::DepNode;\n-use super::thread::{DepGraphThreadData, DepMessage};\n+use super::edges::DepGraphEdges;\n+\n+use std::cell::RefCell;\n \n pub struct DepTask<'graph> {\n-    data: &'graph DepGraphThreadData,\n-    key: Option<DepNode>,\n+    graph: &'graph RefCell<DepGraphEdges>,\n+    key: DepNode,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode)\n-               -> Option<DepTask<'graph>> {\n-        if data.is_enqueue_enabled() {\n-            data.enqueue(DepMessage::PushTask(key.clone()));\n-            Some(DepTask { data: data, key: Some(key) })\n-        } else {\n-            None\n+    pub fn new(graph: &'graph RefCell<DepGraphEdges>,\n+               key: DepNode)\n+               -> DepTask<'graph> {\n+        graph.borrow_mut().push_task(key);\n+        DepTask {\n+            graph,\n+            key,\n         }\n     }\n }\n \n impl<'graph> Drop for DepTask<'graph> {\n     fn drop(&mut self) {\n-        if self.data.is_enqueue_enabled() {\n-            self.data.enqueue(DepMessage::PopTask(self.key.take().unwrap()));\n-        }\n+        self.graph.borrow_mut().pop_task(self.key);\n     }\n }\n \n pub struct IgnoreTask<'graph> {\n-    data: &'graph DepGraphThreadData\n+    graph: &'graph RefCell<DepGraphEdges>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData) -> Option<IgnoreTask<'graph>> {\n-        if data.is_enqueue_enabled() {\n-            data.enqueue(DepMessage::PushIgnore);\n-            Some(IgnoreTask { data: data })\n-        } else {\n-            None\n+    pub fn new(graph: &'graph RefCell<DepGraphEdges>) -> IgnoreTask<'graph> {\n+        graph.borrow_mut().push_ignore();\n+        IgnoreTask {\n+            graph\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        if self.data.is_enqueue_enabled() {\n-            self.data.enqueue(DepMessage::PopIgnore);\n-        }\n+        self.graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "e32acbf4756ca3592dd2fc563ce994f79bbb75b7", "filename": "src/librustc/dep_graph/shadow.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/13e87d1dbb4d3f3071b5807a69d11468173e3522/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e87d1dbb4d3f3071b5807a69d11468173e3522/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=13e87d1dbb4d3f3071b5807a69d11468173e3522", "patch": "@@ -1,151 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The \"Shadow Graph\" is maintained on the main thread and which\n-//! tracks each message relating to the dep-graph and applies some\n-//! sanity checks as they go by. If an error results, it means you get\n-//! a nice stack-trace telling you precisely what caused the error.\n-//!\n-//! NOTE: This is a debugging facility which can potentially have non-trivial\n-//! runtime impact. Therefore, it is largely compiled out if\n-//! debug-assertions are not enabled.\n-//!\n-//! The basic sanity check, enabled if you have debug assertions\n-//! enabled, is that there is always a task (or ignore) on the stack\n-//! when you do read/write, and that the tasks are pushed/popped\n-//! according to a proper stack discipline.\n-//!\n-//! Optionally, if you specify RUST_FORBID_DEP_GRAPH_EDGE, you can\n-//! specify an edge filter to be applied to each edge as it is\n-//! created.  See `./README.md` for details.\n-\n-use std::cell::RefCell;\n-use std::env;\n-\n-use super::DepNode;\n-use super::thread::DepMessage;\n-use super::debug::EdgeFilter;\n-\n-pub struct ShadowGraph {\n-    // if you push None onto the stack, that corresponds to an Ignore\n-    stack: RefCell<Vec<Option<DepNode>>>,\n-    forbidden_edge: Option<EdgeFilter>,\n-}\n-\n-const ENABLED: bool = cfg!(debug_assertions);\n-\n-impl ShadowGraph {\n-    pub fn new() -> Self {\n-        let forbidden_edge = if !ENABLED {\n-            None\n-        } else {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => {\n-                    match EdgeFilter::new(&s) {\n-                        Ok(f) => Some(f),\n-                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                    }\n-                }\n-                Err(_) => None,\n-            }\n-        };\n-\n-        ShadowGraph {\n-            stack: RefCell::new(vec![]),\n-            forbidden_edge,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn enabled(&self) -> bool {\n-        ENABLED\n-    }\n-\n-    pub fn enqueue(&self, message: &DepMessage) {\n-        if ENABLED {\n-            if self.stack.try_borrow().is_err() {\n-                // When we apply edge filters, that invokes the Debug trait on\n-                // DefIds, which in turn reads from various bits of state and\n-                // creates reads! Ignore those recursive reads.\n-                return;\n-            }\n-\n-            let mut stack = self.stack.borrow_mut();\n-            match *message {\n-                // It is ok to READ shared state outside of a\n-                // task. That can't do any harm (at least, the only\n-                // way it can do harm is by leaking that data into a\n-                // query or task, which would be a problem\n-                // anyway). What would be bad is WRITING to that\n-                // state.\n-                DepMessage::Read(_) => { }\n-                DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n-                DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n-                DepMessage::PushIgnore => stack.push(None),\n-                DepMessage::PopTask(ref n) => {\n-                    match stack.pop() {\n-                        Some(Some(m)) => {\n-                            if *n != m {\n-                                bug!(\"stack mismatch: found {:?} expected {:?}\", m, n)\n-                            }\n-                        }\n-                        Some(None) => bug!(\"stack mismatch: found Ignore expected {:?}\", n),\n-                        None => bug!(\"stack mismatch: found empty stack, expected {:?}\", n),\n-                    }\n-                }\n-                DepMessage::PopIgnore => {\n-                    match stack.pop() {\n-                        Some(Some(m)) => bug!(\"stack mismatch: found {:?} expected ignore\", m),\n-                        Some(None) => (),\n-                        None => bug!(\"stack mismatch: found empty stack, expected ignore\"),\n-                    }\n-                }\n-                DepMessage::Query => (),\n-            }\n-        }\n-    }\n-\n-    fn check_edge(&self,\n-                  source: Option<Option<&DepNode>>,\n-                  target: Option<Option<&DepNode>>) {\n-        assert!(ENABLED);\n-        match (source, target) {\n-            // cannot happen, one side is always Some(Some(_))\n-            (None, None) => unreachable!(),\n-\n-            // nothing on top of the stack\n-            (None, Some(n)) | (Some(n), None) => bug!(\"write of {:?} but no current task\", n),\n-\n-            // this corresponds to an Ignore being top of the stack\n-            (Some(None), _) | (_, Some(None)) => (),\n-\n-            // a task is on top of the stack\n-            (Some(Some(source)), Some(Some(target))) => {\n-                if let Some(ref forbidden_edge) = self.forbidden_edge {\n-                    if forbidden_edge.test(source, target) {\n-                        bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Do a little juggling: we get back a reference to an option at the\n-// top of the stack, convert it to an optional reference.\n-fn top<'s>(stack: &'s Vec<Option<DepNode>>) -> Option<Option<&'s DepNode>> {\n-    stack.last()\n-        .map(|n: &'s Option<DepNode>| -> Option<&'s DepNode> {\n-            // (*)\n-            // (*) type annotation just there to clarify what would\n-            // otherwise be some *really* obscure code\n-            n.as_ref()\n-        })\n-}"}, {"sha": "f6635fe16f77d14aca0d978bbc7ccaa0cb42fcbc", "filename": "src/librustc/dep_graph/thread.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/13e87d1dbb4d3f3071b5807a69d11468173e3522/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e87d1dbb4d3f3071b5807a69d11468173e3522/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=13e87d1dbb4d3f3071b5807a69d11468173e3522", "patch": "@@ -1,178 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Manages the communication between the compiler's main thread and\n-//! the thread that constructs the dependency graph. The basic idea is\n-//! to use double buffering to lower the cost of producing a message.\n-//! In the compiler thread, we accumulate messages in a vector until\n-//! the vector is full, or until we want to query the graph, and then\n-//! we send that vector over to the depgraph thread. At the same time,\n-//! we receive an empty vector from the depgraph thread that we can use\n-//! to accumulate more messages. This way we only ever have two vectors\n-//! allocated (and both have a fairly large capacity).\n-\n-use rustc_data_structures::veccell::VecCell;\n-use std::sync::mpsc::{self, Sender, Receiver};\n-use std::thread;\n-\n-use super::DepGraphQuery;\n-use super::DepNode;\n-use super::edges::DepGraphEdges;\n-use super::shadow::ShadowGraph;\n-\n-#[derive(Debug)]\n-pub enum DepMessage {\n-    Read(DepNode),\n-    Write(DepNode),\n-    PushTask(DepNode),\n-    PopTask(DepNode),\n-    PushIgnore,\n-    PopIgnore,\n-    Query,\n-}\n-\n-pub struct DepGraphThreadData {\n-    enabled: bool,\n-\n-    // The \"shadow graph\" is a debugging aid. We give it each message\n-    // in real time as it arrives and it checks for various errors\n-    // (for example, a read/write when there is no current task; it\n-    // can also apply user-defined filters; see `shadow` module for\n-    // details). This only occurs if debug-assertions are enabled.\n-    //\n-    // Note that in some cases the same errors will occur when the\n-    // data is processed off the main thread, but that's annoying\n-    // because it lacks precision about the source of the error.\n-    shadow_graph: ShadowGraph,\n-\n-    // current buffer, where we accumulate messages\n-    messages: VecCell<DepMessage>,\n-\n-    // where to receive new buffer when full\n-    swap_in: Receiver<Vec<DepMessage>>,\n-\n-    // where to send buffer when full\n-    swap_out: Sender<Vec<DepMessage>>,\n-\n-    // where to receive query results\n-    query_in: Receiver<DepGraphQuery>,\n-}\n-\n-const INITIAL_CAPACITY: usize = 2048;\n-\n-impl DepGraphThreadData {\n-    pub fn new(enabled: bool) -> DepGraphThreadData {\n-        let (tx1, rx1) = mpsc::channel();\n-        let (tx2, rx2) = mpsc::channel();\n-        let (txq, rxq) = mpsc::channel();\n-\n-        if enabled {\n-            thread::spawn(move || main(rx1, tx2, txq));\n-        }\n-\n-        DepGraphThreadData {\n-            enabled,\n-            shadow_graph: ShadowGraph::new(),\n-            messages: VecCell::with_capacity(INITIAL_CAPACITY),\n-            swap_in: rx2,\n-            swap_out: tx1,\n-            query_in: rxq,\n-        }\n-    }\n-\n-    /// True if we are actually building the full dep-graph.\n-    #[inline]\n-    pub fn is_fully_enabled(&self) -> bool {\n-        self.enabled\n-    }\n-\n-    /// True if (a) we are actually building the full dep-graph, or (b) we are\n-    /// only enqueuing messages in order to sanity-check them (which happens\n-    /// when debug assertions are enabled).\n-    #[inline]\n-    pub fn is_enqueue_enabled(&self) -> bool {\n-        self.is_fully_enabled() || self.shadow_graph.enabled()\n-    }\n-\n-    /// Sends the current batch of messages to the thread. Installs a\n-    /// new vector of messages.\n-    fn swap(&self) {\n-        assert!(self.is_fully_enabled(), \"should never swap if not fully enabled\");\n-\n-        // should be a buffer waiting for us (though of course we may\n-        // have to wait for depgraph thread to finish processing the\n-        // old messages)\n-        let new_messages = self.swap_in.recv().unwrap();\n-        assert!(new_messages.is_empty());\n-\n-        // swap in the empty buffer and extract the full one\n-        let old_messages = self.messages.swap(new_messages);\n-\n-        // send full buffer to depgraph thread to be processed\n-        self.swap_out.send(old_messages).unwrap();\n-    }\n-\n-    pub fn query(&self) -> DepGraphQuery {\n-        assert!(self.is_fully_enabled(), \"should never query if not fully enabled\");\n-        self.enqueue(DepMessage::Query);\n-        self.swap();\n-        self.query_in.recv().unwrap()\n-    }\n-\n-    /// Enqueue a message to be sent when things are next swapped. (If\n-    /// the buffer is full, this may swap.)\n-    #[inline]\n-    pub fn enqueue(&self, message: DepMessage) {\n-        assert!(self.is_enqueue_enabled(), \"should never enqueue if not enqueue-enabled\");\n-        self.shadow_graph.enqueue(&message);\n-        if self.is_fully_enabled() {\n-            self.enqueue_enabled(message);\n-        }\n-    }\n-\n-    // Outline this fn since I expect it may want to be inlined\n-    // separately.\n-    fn enqueue_enabled(&self, message: DepMessage) {\n-        let len = self.messages.push(message);\n-        if len == INITIAL_CAPACITY {\n-            self.swap();\n-        }\n-    }\n-}\n-\n-/// Definition of the depgraph thread.\n-pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n-            swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery>) {\n-    let mut edges = DepGraphEdges::new();\n-\n-    // the compiler thread always expects a fresh buffer to be\n-    // waiting, so queue one up\n-    swap_out.send(Vec::with_capacity(INITIAL_CAPACITY)).unwrap();\n-\n-    // process the buffers from compiler thread as we receive them\n-    for mut messages in swap_in {\n-        for msg in messages.drain(..) {\n-            match msg {\n-                DepMessage::Read(node) => edges.read(node),\n-                DepMessage::Write(node) => edges.write(node),\n-                DepMessage::PushTask(node) => edges.push_task(node),\n-                DepMessage::PopTask(node) => edges.pop_task(node),\n-                DepMessage::PushIgnore => edges.push_ignore(),\n-                DepMessage::PopIgnore => edges.pop_ignore(),\n-                DepMessage::Query => query_out.send(edges.query()).unwrap(),\n-            }\n-        }\n-        if let Err(_) = swap_out.send(messages) {\n-            // the receiver must have been dropped already\n-            break;\n-        }\n-    }\n-}"}, {"sha": "2c43896ec73d242d9170957f423373baa109006d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/089860b60387bbd8c21969d7246e2baec4f76805/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=089860b60387bbd8c21969d7246e2baec4f76805", "patch": "@@ -202,11 +202,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             clean_work_products.insert(wp_id);\n         }\n \n-        tcx.dep_graph.with_task(*bootstrap_output, (), (), create_node);\n-\n-        fn create_node((): (), (): ()) {\n-            // just create the node with no inputs\n-        }\n+        tcx.dep_graph.add_node_directly(*bootstrap_output);\n     }\n \n     // Add in work-products that are still clean, and delete those that are\n@@ -453,13 +449,11 @@ fn process_edge<'a, 'tcx, 'edges>(\n     if !dirty_raw_nodes.contains_key(&target) {\n         let target = nodes[target];\n         let source = nodes[source];\n-        let _task = tcx.dep_graph.in_task(target);\n-        tcx.dep_graph.read(source);\n+        tcx.dep_graph.add_edge_directly(source, target);\n \n         if let DepKind::WorkProduct = target.kind {\n             let wp_id = WorkProductId::from_fingerprint(target.hash);\n             clean_work_products.insert(wp_id);\n         }\n     }\n }\n-"}]}