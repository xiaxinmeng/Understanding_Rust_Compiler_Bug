{"sha": "4f643d79fc9573489c178eb283a7da1a1e8402c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNjQzZDc5ZmM5NTczNDg5YzE3OGViMjgzYTdkYTFhMWU4NDAyYzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T01:06:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T01:06:35Z"}, "message": "rollup merge of #23863: pnkfelix/arith-oflo-const-eval\n\nconst_eval : add overflow-checking for {`+`, `-`, `*`, `/`, `<<`, `>>`}.\n\nOne tricky detail here: There is some duplication of labor between `rustc::middle::const_eval` and `rustc_trans::trans::consts`. It might be good to explore ways to try to factor out the common structure to the two passes (by abstracting over the particular value-representation used in the compile-time interpreter).\n\n----\n\nUpdate: Rebased atop #23841\n\nFix #22531\n\nFix #23030\n\nFix #23221\n\nFix #23235", "tree": {"sha": "76b2c1726ef8165e0ef5c1cd5d769c4a11de79ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b2c1726ef8165e0ef5c1cd5d769c4a11de79ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f643d79fc9573489c178eb283a7da1a1e8402c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f643d79fc9573489c178eb283a7da1a1e8402c1", "html_url": "https://github.com/rust-lang/rust/commit/4f643d79fc9573489c178eb283a7da1a1e8402c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f643d79fc9573489c178eb283a7da1a1e8402c1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f59732d7974767650abfc58f8287212e5a1fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f59732d7974767650abfc58f8287212e5a1fba", "html_url": "https://github.com/rust-lang/rust/commit/72f59732d7974767650abfc58f8287212e5a1fba"}, {"sha": "2a9de1d989d7f95846b711eec2695cbd86794ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9de1d989d7f95846b711eec2695cbd86794ee3", "html_url": "https://github.com/rust-lang/rust/commit/2a9de1d989d7f95846b711eec2695cbd86794ee3"}], "stats": {"total": 1988, "additions": 1727, "deletions": 261}, "files": [{"sha": "a78eed8ae5fa843c65007fc8bb097cc9328d81d7", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -30,6 +30,8 @@ use intrinsics::{i16_mul_with_overflow, u16_mul_with_overflow};\n use intrinsics::{i32_mul_with_overflow, u32_mul_with_overflow};\n use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n+use ::{i8,i16,i32,i64,u8,u16,u32,u64};\n+\n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n pub trait WrappingOps {\n@@ -43,6 +45,12 @@ pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n     fn overflowing_sub(self, rhs: Self) -> (Self, bool);\n     fn overflowing_mul(self, rhs: Self) -> (Self, bool);\n+\n+    fn overflowing_div(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_rem(self, rhs: Self) -> (Self, bool);\n+\n+    fn overflowing_shl(self, rhs: u32) -> (Self, bool);\n+    fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n }\n \n macro_rules! sh_impl {\n@@ -184,6 +192,20 @@ macro_rules! wrapping_impl {\n \n wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n+mod shift_max {\n+    #![allow(non_upper_case_globals)]\n+\n+    pub const  i8: u32 = (1 << 3) - 1;\n+    pub const i16: u32 = (1 << 4) - 1;\n+    pub const i32: u32 = (1 << 5) - 1;\n+    pub const i64: u32 = (1 << 6) - 1;\n+\n+    pub const  u8: u32 = i8;\n+    pub const u16: u32 = i16;\n+    pub const u32: u32 = i32;\n+    pub const u64: u32 = i64;\n+}\n+\n macro_rules! overflowing_impl {\n     ($($t:ident)*) => ($(\n         impl OverflowingOps for $t {\n@@ -205,6 +227,34 @@ macro_rules! overflowing_impl {\n                     concat_idents!($t, _mul_with_overflow)(self, rhs)\n                 }\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_div(self, rhs: $t) -> ($t, bool) {\n+                if self == $t::MIN && rhs == -1 {\n+                    (1, true)\n+                } else {\n+                    (self/rhs, false)\n+                }\n+            }\n+            #[inline(always)]\n+            fn overflowing_rem(self, rhs: $t) -> ($t, bool) {\n+                if self == $t::MIN && rhs == -1 {\n+                    (0, true)\n+                } else {\n+                    (self % rhs, false)\n+                }\n+            }\n+\n+            #[inline(always)]\n+            fn overflowing_shl(self, rhs: u32) -> ($t, bool) {\n+                (self << (rhs & self::shift_max::$t),\n+                 (rhs > self::shift_max::$t))\n+            }\n+            #[inline(always)]\n+            fn overflowing_shr(self, rhs: u32) -> ($t, bool) {\n+                (self >> (rhs & self::shift_max::$t),\n+                 (rhs > self::shift_max::$t))\n+            }\n         }\n     )*)\n }\n@@ -234,6 +284,26 @@ impl OverflowingOps for usize {\n             (res.0 as usize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_div(rhs as u64);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_rem(rhs as u64);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_shl(rhs);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_shr(rhs);\n+        (r as usize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -259,6 +329,26 @@ impl OverflowingOps for usize {\n             (res.0 as usize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_div(rhs as u32);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: usize) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_rem(rhs as u32);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_shl(rhs);\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_shr(rhs);\n+        (r as usize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n@@ -284,6 +374,26 @@ impl OverflowingOps for isize {\n             (res.0 as isize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_div(rhs as i64);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_rem(rhs as i64);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_shl(rhs);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_shr(rhs);\n+        (r as isize, f)\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n@@ -309,4 +419,24 @@ impl OverflowingOps for isize {\n             (res.0 as isize, res.1)\n         }\n     }\n+    #[inline(always)]\n+    fn overflowing_div(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_div(rhs as i32);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_rem(self, rhs: isize) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_rem(rhs as i32);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_shl(rhs);\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n+    fn overflowing_shr(self, rhs: u32) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_shr(rhs);\n+        (r as isize, f)\n+    }\n }"}, {"sha": "e3eff6e7512ecf6d3c08167ac809fd5e49ea6552", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -20,7 +20,7 @@ mod tests {\n     fn test_overflows() {\n         assert!(MAX > 0);\n         assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n+        assert!((MIN + MAX).wrapping_add(1) == 0);\n     }\n \n     #[test]"}, {"sha": "0a29ed90ad46100d863d69a2e799c34000632a69", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -68,6 +68,8 @@ register_diagnostics! {\n     E0019,\n     E0020,\n     E0022,\n+    E0079, // enum variant: expected signed integer constant\n+    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0133,\n@@ -128,7 +130,8 @@ register_diagnostics! {\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n-    E0316 // nested quantification of lifetimes\n+    E0316, // nested quantification of lifetimes\n+    E0370  // discriminant overflow\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "b6061f39233d20b26d2f7a11535223310f67c192", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -1197,7 +1197,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(ty) = tcx.node_types.borrow().get(&id) {\n+    if let Some(ty) = tcx.node_types().get(&id) {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.emit_ty(ecx, *ty);\n@@ -1884,7 +1884,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n-                        dcx.tcx.node_types.borrow_mut().insert(id, ty);\n+                        dcx.tcx.node_type_insert(id, ty);\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {"}, {"sha": "e3e5efc53c7decdca8253aab72db0ada53beea16", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 338, "deletions": 112, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -13,6 +13,8 @@\n \n pub use self::const_val::*;\n \n+use self::ErrKind::*;\n+\n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n@@ -27,6 +29,7 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n+use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};\n@@ -234,6 +237,7 @@ pub enum ErrKind {\n     NotOnStruct,\n     NotOnTuple,\n \n+    NegateWithOverflow(i64),\n     AddiWithOverflow(i64, i64),\n     SubiWithOverflow(i64, i64),\n     MuliWithOverflow(i64, i64),\n@@ -244,6 +248,8 @@ pub enum ErrKind {\n     DivideWithOverflow,\n     ModuloByZero,\n     ModuloWithOverflow,\n+    ShiftLeftWithOverflow,\n+    ShiftRightWithOverflow,\n     MissingStructField,\n     NonConstPath,\n     ExpectedConstTuple,\n@@ -257,6 +263,7 @@ pub enum ErrKind {\n impl ConstEvalErr {\n     pub fn description(&self) -> Cow<str> {\n         use self::ErrKind::*;\n+\n         match self.kind {\n             CannotCast => \"can't cast this type\".into_cow(),\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n@@ -275,6 +282,7 @@ impl ConstEvalErr {\n             NotOnStruct => \"not on struct\".into_cow(),\n             NotOnTuple => \"not on tuple\".into_cow(),\n \n+            NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n             SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n             MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n@@ -285,6 +293,8 @@ impl ConstEvalErr {\n             DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n             ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n             ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n+            ShiftLeftWithOverflow => \"attempted left shift with overflow\".into_cow(),\n+            ShiftRightWithOverflow => \"attempted right shift with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n             NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n             ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n@@ -297,57 +307,294 @@ impl ConstEvalErr {\n     }\n }\n \n+pub type EvalResult = Result<const_val, ConstEvalErr>;\n+pub type CastResult = Result<const_val, ErrKind>;\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum IntTy { I8, I16, I32, I64 }\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum UintTy { U8, U16, U32, U64 }\n+\n+impl IntTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n+        let t = if let ast::TyIs = t {\n+            tcx.sess.target.int_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyIs => unreachable!(),\n+            ast::TyI8  => IntTy::I8,\n+            ast::TyI16 => IntTy::I16,\n+            ast::TyI32 => IntTy::I32,\n+            ast::TyI64 => IntTy::I64,\n+        }\n+    }\n+}\n+\n+impl UintTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n+        let t = if let ast::TyUs = t {\n+            tcx.sess.target.uint_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyUs => unreachable!(),\n+            ast::TyU8  => UintTy::U8,\n+            ast::TyU16 => UintTy::U16,\n+            ast::TyU32 => UintTy::U32,\n+            ast::TyU64 => UintTy::U64,\n+        }\n+    }\n+}\n+\n macro_rules! signal {\n-    ($e:expr, $ctor:ident) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor })\n+    ($e:expr, $exn:expr) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n+    }\n+}\n+\n+// The const_{int,uint}_checked_{neg,add,sub,mul,div,shl,shr} family\n+// of functions catch and signal overflow errors during constant\n+// evaluation.\n+//\n+// They all take the operator's arguments (`a` and `b` if binary), the\n+// overall expression (`e`) and, if available, whole expression's\n+// concrete type (`opt_ety`).\n+//\n+// If the whole expression's concrete type is None, then this is a\n+// constant evaluation happening before type check (e.g. in the check\n+// to confirm that a pattern range's left-side is not greater than its\n+// right-side). We do not do arithmetic modulo the type's bitwidth in\n+// such a case; we just do 64-bit arithmetic and assume that later\n+// passes will do it again with the type information, and thus do the\n+// overflow checks then.\n+\n+pub fn const_int_checked_neg<'a>(\n+    a: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+\n+    let (min,max) = match opt_ety {\n+        // (-i8::MIN is itself not an i8, etc, but this is an easy way\n+        // to allow literals to pass the check. Of course that does\n+        // not work for i64::MIN.)\n+        Some(IntTy::I8) =>  (-(i8::MAX as i64), -(i8::MIN as i64)),\n+        Some(IntTy::I16) => (-(i16::MAX as i64), -(i16::MIN as i64)),\n+        Some(IntTy::I32) => (-(i32::MAX as i64), -(i32::MIN as i64)),\n+        None | Some(IntTy::I64) => (-i64::MAX, -(i64::MIN+1)),\n     };\n \n-    ($e:expr, $ctor:ident($($arg:expr),*)) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor($($arg),*) })\n+    let oflo = a < min || a > max;\n+    if oflo {\n+        signal!(e, NegateWithOverflow(a));\n+    } else {\n+        Ok(const_int(-a))\n+    }\n+}\n+\n+pub fn const_uint_checked_neg<'a>(\n+    a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n+    // This always succeeds, and by definition, returns `(!a)+1`.\n+    Ok(const_uint(-a))\n+}\n+\n+macro_rules! overflow_checking_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident,\n+     lhs: $to_8_lhs:ident $to_16_lhs:ident $to_32_lhs:ident,\n+     rhs: $to_8_rhs:ident $to_16_rhs:ident $to_32_rhs:ident $to_64_rhs:ident,\n+     $EnumTy:ident $T8: ident $T16: ident $T32: ident $T64: ident,\n+     $result_type: ident) => { {\n+        let (a,b,opt_ety) = ($a,$b,$ety);\n+        match opt_ety {\n+            Some($EnumTy::$T8) => match (a.$to_8_lhs(), b.$to_8_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T16) => match (a.$to_16_lhs(), b.$to_16_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T32) => match (a.$to_32_lhs(), b.$to_32_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            None | Some($EnumTy::$T64) => match b.$to_64_rhs() {\n+                Some(b) => a.$overflowing_op(b),\n+                None => (0, true),\n+            }\n+        }\n+    } }\n+}\n+\n+macro_rules! int_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_i8 to_i16 to_i32 to_i64, IntTy I8 I16 I32 I64, i64)\n+    }\n+}\n+\n+macro_rules! uint_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u8 to_u16 to_u32 to_u64, UintTy U8 U16 U32 U64, u64)\n+    }\n+}\n+\n+macro_rules! int_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, IntTy I8 I16 I32 I64, i64)\n     }\n }\n \n-fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, AddiWithOverflow(a, b)) }\n+macro_rules! uint_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, UintTy U8 U16 U32 U64, u64)\n+    }\n }\n-fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, SubiWithOverflow(a, b)) }\n+\n+macro_rules! pub_fn_checked_op {\n+    {$fn_name:ident ($a:ident : $a_ty:ty, $b:ident : $b_ty:ty,.. $WhichTy:ident) {\n+        $ret_oflo_body:ident $overflowing_op:ident\n+            $const_ty:ident $signal_exn:expr\n+    }} => {\n+        pub fn $fn_name<'a>($a: $a_ty,\n+                            $b: $b_ty,\n+                            e: &'a Expr,\n+                            opt_ety: Option<$WhichTy>) -> EvalResult {\n+            let (ret, oflo) = $ret_oflo_body!($a, $b, opt_ety, $overflowing_op);\n+            if !oflo { Ok($const_ty(ret)) } else { signal!(e, $signal_exn) }\n+        }\n+    }\n }\n-fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, MuliWithOverflow(a, b)) }\n+\n+pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_add const_int AddiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_sub const_int SubiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_mul const_int MuliWithOverflow(a, b)\n+}}\n+\n+pub fn const_int_checked_div<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n \n-fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, AdduWithOverflow(a, b)) }\n+pub fn const_int_checked_rem<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n-fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, SubuWithOverflow(a, b)) }\n+\n+pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_add const_uint AdduWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_sub const_uint SubuWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_mul const_uint MuluWithOverflow(a, b)\n+}}\n+\n+pub fn const_uint_checked_div<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n-fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, MuluWithOverflow(a, b)) }\n+\n+pub fn const_uint_checked_rem<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n \n+pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n \n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: Option<Ty<'tcx>>)\n-                                     -> Result<const_val, ConstEvalErr> {\n+                                     ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n+    // If type of expression itself is int or uint, normalize in these\n+    // bindings so that isize/usize is mapped to a type with an\n+    // inherently known bitwidth.\n+    let expr_int_type = ety.and_then(|ty| {\n+        if let ty::ty_int(t) = ty.sty {\n+            Some(IntTy::from(tcx, t)) } else { None }\n+    });\n+    let expr_uint_type = ety.and_then(|ty| {\n+        if let ty::ty_uint(t) = ty.sty {\n+            Some(UintTy::from(tcx, t)) } else { None }\n+    });\n+\n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n           const_float(f) => const_float(-f),\n-          const_int(i) => const_int(-i),\n-          const_uint(i) => const_uint(-i),\n+          const_int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n+          const_uint(n) => try!(const_uint_checked_neg(n, e, expr_uint_type)),\n           const_str(_) => signal!(e, NegateOnString),\n           const_bool(_) => signal!(e, NegateOnBoolean),\n           const_binary(_) => signal!(e, NegateOnBinary),\n@@ -391,51 +638,17 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           (const_int(a), const_int(b)) => {\n-            let is_a_min_value = || {\n-                let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n-                    Some(&ty::ty_int(int_ty)) => int_ty,\n-                    _ => return false\n-                };\n-                let int_ty = if let ast::TyIs = int_ty {\n-                    tcx.sess.target.int_type\n-                } else {\n-                    int_ty\n-                };\n-                match int_ty {\n-                    ast::TyI8 => (a as i8) == i8::MIN,\n-                    ast::TyI16 =>  (a as i16) == i16::MIN,\n-                    ast::TyI32 =>  (a as i32) == i32::MIN,\n-                    ast::TyI64 =>  (a as i64) == i64::MIN,\n-                    ast::TyIs => unreachable!()\n-                }\n-            };\n             match op.node {\n-              ast::BiAdd => try!(checked_add_int(e, a, b)),\n-              ast::BiSub => try!(checked_sub_int(e, a, b)),\n-              ast::BiMul => try!(checked_mul_int(e, a, b)),\n-              ast::BiDiv => {\n-                  if b == 0 {\n-                      signal!(e, DivideByZero);\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, DivideWithOverflow);\n-                  } else {\n-                      const_int(a / b)\n-                  }\n-              }\n-              ast::BiRem => {\n-                  if b == 0 {\n-                      signal!(e, ModuloByZero)\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, ModuloWithOverflow)\n-                  } else {\n-                      const_int(a % b)\n-                  }\n-              }\n+              ast::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n+              ast::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n+              ast::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n+              ast::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n+              ast::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n               ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n               ast::BiOr | ast::BiBitOr => const_int(a | b),\n               ast::BiBitXor => const_int(a ^ b),\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -446,18 +659,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           }\n           (const_uint(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiAdd => try!(checked_add_uint(e, a, b)),\n-              ast::BiSub => try!(checked_sub_uint(e, a, b)),\n-              ast::BiMul => try!(checked_mul_uint(e, a, b)),\n-              ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n-              ast::BiDiv => const_uint(a / b),\n-              ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n-              ast::BiRem => const_uint(a % b),\n+              ast::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n+              ast::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n+              ast::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n+              ast::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n+              ast::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n               ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n               ast::BiOr | ast::BiBitOr => const_uint(a | b),\n               ast::BiBitXor => const_uint(a ^ b),\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -469,15 +680,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n@@ -506,10 +717,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n+\n         // Prefer known type to noop, but always have a type hint.\n+        //\n+        // FIXME (#23833): the type-hint can cause problems,\n+        // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n+        // type to the sum, and thus no overflow is signaled.\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n-        match cast_const(val, ety) {\n+        match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n@@ -607,39 +823,49 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n-fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n-    macro_rules! define_casts {\n-        ($($ty_pat:pat => (\n-            $intermediate_ty:ty,\n-            $const_type:ident,\n-            $target_ty:ty\n-        )),*) => (match ty.sty {\n-            $($ty_pat => {\n-                match val {\n-                    const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n-                    const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                    const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                    const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                    _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n-                }\n-            },)*\n-            _ => Err(ErrKind::CannotCast),\n-        })\n+fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n+    macro_rules! convert_val {\n+        ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n+            match val {\n+                const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n+            }\n+        }\n+    }\n+\n+    // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n+    match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n+        (&ty::ty_int(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, const_int, i64),\n+        (&ty::ty_int(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, const_int, i64),\n+        (&ty::ty_int(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+\n+        (&ty::ty_uint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, const_uint, u64),\n+        (&ty::ty_uint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, const_uint, u64),\n+        (&ty::ty_uint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+\n+        _ => {}\n     }\n \n-    define_casts!{\n-        ty::ty_int(ast::TyIs) => (isize, const_int, i64),\n-        ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n-        ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n-        ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n-        ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-        ty::ty_uint(ast::TyUs) => (usize, const_uint, u64),\n-        ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n-        ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n-        ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n-        ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n-        ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n-        ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n+    match ty.sty {\n+        ty::ty_int(ast::TyIs) => unreachable!(),\n+        ty::ty_uint(ast::TyUs) => unreachable!(),\n+\n+        ty::ty_int(ast::TyI8) => convert_val!(i8, const_int, i64),\n+        ty::ty_int(ast::TyI16) => convert_val!(i16, const_int, i64),\n+        ty::ty_int(ast::TyI32) => convert_val!(i32, const_int, i64),\n+        ty::ty_int(ast::TyI64) => convert_val!(i64, const_int, i64),\n+\n+        ty::ty_uint(ast::TyU8) => convert_val!(u8, const_uint, u64),\n+        ty::ty_uint(ast::TyU16) => convert_val!(u16, const_uint, u64),\n+        ty::ty_uint(ast::TyU32) => convert_val!(u32, const_uint, u64),\n+        ty::ty_uint(ast::TyU64) => convert_val!(u64, const_uint, u64),\n+\n+        ty::ty_float(ast::TyF32) => convert_val!(f32, const_float, f64),\n+        ty::ty_float(ast::TyF64) => convert_val!(f64, const_float, f64),\n+        _ => Err(ErrKind::CannotCast),\n     }\n }\n "}, {"sha": "87d17cbc04fcd5b171e7e2286582b5468204fcfb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 271, "deletions": 54, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -68,11 +68,13 @@ use util::nodemap::FnvHashMap;\n \n use arena::TypedArena;\n use std::borrow::{Borrow, Cow};\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n+use std::num::ToPrimitive;\n+use std::num::wrapping::WrappingOps;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n@@ -83,9 +85,11 @@ use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::{ast, ast_map};\n \n pub type Disr = u64;\n@@ -685,7 +689,7 @@ pub struct ctxt<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: RefCell<NodeMap<Ty<'tcx>>>,\n+    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n@@ -850,6 +854,13 @@ pub struct ctxt<'tcx> {\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n \n+impl<'tcx> ctxt<'tcx> {\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> { self.node_types.borrow() }\n+    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+        self.node_types.borrow_mut().insert(id, ty);\n+    }\n+}\n+\n // Flags that we track on types. These flags are propagated upwards\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without\n@@ -5489,63 +5500,268 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n      }\n }\n \n+trait IntTypeExt {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n+    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_string(&self, val: Disr) -> String;\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+}\n+\n+impl IntTypeExt for attr::IntType {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(ast::TyI8)      => cx.types.i8,\n+            SignedInt(ast::TyI16)     => cx.types.i16,\n+            SignedInt(ast::TyI32)     => cx.types.i32,\n+            SignedInt(ast::TyI64)     => cx.types.i64,\n+            SignedInt(ast::TyIs)   => cx.types.isize,\n+            UnsignedInt(ast::TyU8)    => cx.types.u8,\n+            UnsignedInt(ast::TyU16)   => cx.types.u16,\n+            UnsignedInt(ast::TyU32)   => cx.types.u32,\n+            UnsignedInt(ast::TyU64)   => cx.types.u64,\n+            UnsignedInt(ast::TyUs) => cx.types.usize,\n+        }\n+    }\n+\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n+        macro_rules! add1 {\n+            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n+        }\n+        match *self {\n+            // SignedInt repr means we *want* to reinterpret the bits\n+            // treating the highest bit of Disr as a sign-bit, so\n+            // cast to i64 before range-checking.\n+            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    // This returns a String because (1.) it is only used for\n+    // rendering an error message and (2.) a string can represent the\n+    // full range from `i64::MIN` through `u64::MAX`.\n+    fn disr_string(&self, val: Disr) -> String {\n+        match *self {\n+            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n+        }\n+        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n+        match *self {\n+            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n+            SignedInt(ast::TyI16)   => add1!(val as i16),\n+            SignedInt(ast::TyI32)   => add1!(val as i32),\n+            SignedInt(ast::TyI64)   => add1!(val as i64),\n+            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(ast::TyU16) => add1!(val as u16),\n+            UnsignedInt(ast::TyU32) => add1!(val as u32),\n+            UnsignedInt(ast::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// Returns `(normalized_type, ty)`, where `normalized_type` is the\n+/// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n+/// and `ty` is the original type (i.e. may include `isize` or\n+/// `usize`).\n+pub fn enum_repr_type<'tcx>(cx: &ctxt<'tcx>,\n+                            opt_hint: Option<&attr::ReprAttr>)\n+                            -> (attr::IntType, Ty<'tcx>)\n+{\n+    let repr_type = match opt_hint {\n+        // Feed in the given type\n+        Some(&attr::ReprInt(_, int_t)) => int_t,\n+        // ... but provide sensible default if none provided\n+        //\n+        // NB. Historically `fn enum_variants` generate i64 here, while\n+        // rustc_typeck::check would generate isize.\n+        _ => SignedInt(ast::TyIs),\n+    };\n+\n+    let repr_type_ty = repr_type.to_ty(cx);\n+    let repr_type = match repr_type {\n+        SignedInt(ast::TyIs) =>\n+            SignedInt(cx.sess.target.int_type),\n+        UnsignedInt(ast::TyUs) =>\n+            UnsignedInt(cx.sess.target.uint_type),\n+        other => other\n+    };\n+\n+    (repr_type, repr_type_ty)\n+}\n+\n+fn report_discrim_overflow(cx: &ctxt,\n+                           variant_span: Span,\n+                           variant_name: &str,\n+                           repr_type: attr::IntType,\n+                           prev_val: Disr) {\n+    let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n+    let computed_value = repr_type.disr_string(computed_value);\n+    let prev_val = repr_type.disr_string(prev_val);\n+    let repr_type = repr_type.to_ty(cx).user_string(cx);\n+    span_err!(cx.sess, variant_span, E0370,\n+              \"enum discriminant overflowed on value after {}: {}; \\\n+               set explicitly via {} = {} if that is desired outcome\",\n+              prev_val, repr_type, variant_name, computed_value);\n+}\n+\n+// This computes the discriminant values for the sequence of Variants\n+// attached to a particular enum, taking into account the #[repr] (if\n+// any) provided via the `opt_hint`.\n+fn compute_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n+                               vs: &'tcx [P<ast::Variant>],\n+                               opt_hint: Option<&attr::ReprAttr>)\n+                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+    let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n+    let mut prev_disr_val: Option<ty::Disr> = None;\n+\n+    let (repr_type, repr_type_ty) = ty::enum_repr_type(cx, opt_hint);\n+\n+    for v in vs {\n+        // If the discriminant value is specified explicitly in the\n+        // enum, check whether the initialization expression is valid,\n+        // otherwise use the last value plus one.\n+        let current_disr_val;\n+\n+        // This closure marks cases where, when an error occurs during\n+        // the computation, attempt to assign a (hopefully) fresh\n+        // value to avoid spurious error reports downstream.\n+        let attempt_fresh_value = move || -> Disr {\n+            repr_type.disr_wrap_incr(prev_disr_val)\n+        };\n+\n+        match v.node.disr_expr {\n+            Some(ref e) => {\n+                debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+\n+                // check_expr (from check_const pass) doesn't guarantee\n+                // that the expression is in a form that eval_const_expr can\n+                // handle, so we may still get an internal compiler error\n+                //\n+                // pnkfelix: The above comment was transcribed from\n+                // the version of this code taken from rustc_typeck.\n+                // Presumably the implication is that we need to deal\n+                // with such ICE's as they arise.\n+                //\n+                // Since this can be called from `ty::enum_variants`\n+                // anyway, best thing is to make `eval_const_expr`\n+                // more robust (on case-by-case basis).\n+\n+                match const_eval::eval_const_expr_partial(cx, &**e, Some(repr_type_ty)) {\n+                    Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n+                    Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n+                    Ok(_) => {\n+                        span_err!(cx.sess, e.span, E0079,\n+                                  \"expected signed integer constant\");\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                    Err(ref err) => {\n+                        span_err!(cx.sess, err.span, E0080,\n+                                  \"constant evaluation error: {}\",\n+                                  err.description());\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                }\n+            },\n+            None => {\n+                current_disr_val = match prev_disr_val {\n+                    Some(prev_disr_val) => {\n+                        if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n+                            v\n+                        } else {\n+                            report_discrim_overflow(cx, v.span, v.node.name.as_str(),\n+                                                    repr_type, prev_disr_val);\n+                            attempt_fresh_value()\n+                        }\n+                    }\n+                    None => ty::INITIAL_DISCRIMINANT_VALUE\n+                }\n+            }\n+        }\n+\n+        let variant_info = Rc::new(VariantInfo::from_ast_variant(cx, &**v, current_disr_val));\n+        prev_disr_val = Some(current_disr_val);\n+\n+        variants.push(variant_info);\n+    }\n+\n+    return variants;\n+}\n+\n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n         } else {\n-            /*\n-              Although both this code and check_enum_variants in typeck/check\n-              call eval_const_expr, it should never get called twice for the same\n-              expr, since check_enum_variants also updates the enum_var_cache\n-             */\n             match cx.map.get(id.node) {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         ast::ItemEnum(ref enum_definition, _) => {\n-                            let mut last_discriminant: Option<Disr> = None;\n-                            Rc::new(enum_definition.variants.iter().map(|variant| {\n-\n-                                let mut discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                if let Some(ref e) = variant.node.disr_expr {\n-                                    // Preserve all values, and prefer signed.\n-                                    let ty = Some(cx.types.i64);\n-                                    match const_eval::eval_const_expr_partial(cx, &**e, ty) {\n-                                        Ok(const_eval::const_int(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(const_eval::const_uint(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(_) => {\n-                                            span_err!(cx.sess, e.span, E0304,\n-                                                      \"expected signed integer constant\");\n-                                        }\n-                                        Err(err) => {\n-                                            span_err!(cx.sess, err.span, E0305,\n-                                                      \"constant evaluation error: {}\",\n-                                                      err.description());\n-                                        }\n-                                    }\n-                                } else {\n-                                    if let Some(val) = last_discriminant {\n-                                        if let Some(v) = val.checked_add(1) {\n-                                            discriminant = v\n-                                        } else {\n-                                            cx.sess.span_err(\n-                                                variant.span,\n-                                                &format!(\"Discriminant overflowed!\"));\n-                                        }\n-                                    } else {\n-                                        discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                    }\n-                                }\n-\n-                                last_discriminant = Some(discriminant);\n-                                Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n-                                                                      discriminant))\n-                            }).collect())\n+                            Rc::new(compute_enum_variants(\n+                                cx,\n+                                &enum_definition.variants,\n+                                lookup_repr_hints(cx, id).get(0)))\n                         }\n                         _ => {\n                             cx.sess.bug(\"enum_variants: id not bound to an enum\")\n@@ -5831,19 +6047,20 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n                 \"expected positive integer for repeat count, found {}\",\n                 found);\n         }\n-        Err(_) => {\n+        Err(err) => {\n+            let err_description = err.description();\n             let found = match count_expr.node {\n                 ast::ExprPath(None, ast::Path {\n                     global: false,\n                     ref segments,\n                     ..\n                 }) if segments.len() == 1 =>\n-                    \"variable\",\n+                    format!(\"{}\", \"found variable\"),\n                 _ =>\n-                    \"non-constant expression\"\n+                    format!(\"but {}\", err_description),\n             };\n             span_err!(tcx.sess, count_expr.span, E0307,\n-                \"expected constant integer for repeat count, found {}\",\n+                \"expected constant integer for repeat count, {}\",\n                 found);\n         }\n     }"}, {"sha": "cdafa4a16d07dbd88a46007f5e5bd81ad653f959", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -1975,6 +1975,7 @@ extern {\n     pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMInitializeX86TargetInfo();\n     pub fn LLVMInitializeX86Target();"}, {"sha": "26fcf947e4f900e179c6365bbc0fb5ddaad20674", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -272,7 +272,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let typ =\n                     ppaux::ty_to_string(\n                         &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types.borrow().get(&id).unwrap());\n+                        *self.analysis.ty_cx.node_types().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -436,7 +436,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let typ =\n                     ppaux::ty_to_string(\n                         &self.analysis.ty_cx,\n-                        *self.analysis.ty_cx.node_types.borrow().get(&field.node.id).unwrap());\n+                        *self.analysis.ty_cx.node_types().get(&field.node.id).unwrap());\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -1471,7 +1471,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n-            let types = self.analysis.ty_cx.node_types.borrow();\n+            let types = self.analysis.ty_cx.node_types();\n             let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?)."}, {"sha": "995f3caf588701907a11b4d158284fd475861071", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -963,6 +963,32 @@ pub fn const_to_uint(v: ValueRef) -> u64 {\n     }\n }\n \n+fn is_const_integral(v: ValueRef) -> bool {\n+    unsafe {\n+        !llvm::LLVMIsAConstantInt(v).is_null()\n+    }\n+}\n+\n+pub fn const_to_opt_int(v: ValueRef) -> Option<i64> {\n+    unsafe {\n+        if is_const_integral(v) {\n+            Some(llvm::LLVMConstIntGetSExtValue(v))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub fn const_to_opt_uint(v: ValueRef) -> Option<u64> {\n+    unsafe {\n+        if is_const_integral(v) {\n+            Some(llvm::LLVMConstIntGetZExtValue(v))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub fn is_undef(val: ValueRef) -> bool {\n     unsafe {\n         llvm::LLVMIsUndef(val) != False"}, {"sha": "c32cb28ec78dbb9bbdbf83fced5510b615f2780e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 116, "deletions": 9, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -14,6 +14,14 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::{check_const, const_eval, def};\n+use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n+use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n+use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n+use middle::const_eval::{const_int_checked_mul, const_uint_checked_mul};\n+use middle::const_eval::{const_int_checked_div, const_uint_checked_div};\n+use middle::const_eval::{const_int_checked_rem, const_uint_checked_rem};\n+use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n+use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n@@ -336,6 +344,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n     if csize != tsize {\n+        cx.sess().abort_if_errors();\n         unsafe {\n             // FIXME these values could use some context\n             llvm::LLVMDumpValue(llconst);\n@@ -348,6 +357,100 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     (llconst, ety_adjusted)\n }\n \n+fn check_unary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                             te: ValueRef) {\n+    // The only kind of unary expression that we check for validity\n+    // here is `-expr`, to check if it \"overflows\" (e.g. `-i32::MIN`).\n+    if let ast::ExprUnary(ast::UnNeg, ref inner_e) = e.node {\n+\n+        // An unfortunate special case: we parse e.g. -128 as a\n+        // negation of the literal 128, which means if we're expecting\n+        // a i8 (or if it was already suffixed, e.g. `-128_i8`), then\n+        // 128 will have already overflowed to -128, and so then the\n+        // constant evaluator thinks we're trying to negate -128.\n+        //\n+        // Catch this up front by looking for ExprLit directly,\n+        // and just accepting it.\n+        if let ast::ExprLit(_) = inner_e.node { return; }\n+\n+        let result = match t.sty {\n+            ty::ty_int(int_type) => {\n+                let input = match const_to_opt_int(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_int_checked_neg(\n+                    input, e, Some(const_eval::IntTy::from(cx.tcx(), int_type)))\n+            }\n+            ty::ty_uint(uint_type) => {\n+                let input = match const_to_opt_uint(te) {\n+                    Some(v) => v,\n+                    None => return,\n+                };\n+                const_uint_checked_neg(\n+                    input, e, Some(const_eval::UintTy::from(cx.tcx(), uint_type)))\n+            }\n+            _ => return,\n+        };\n+\n+        // We do not actually care about a successful result.\n+        if let Err(err) = result {\n+            cx.tcx().sess.span_err(e.span, &err.description());\n+        }\n+    }\n+}\n+\n+fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n+                              te1: ValueRef, te2: ValueRef) {\n+    let b = if let ast::ExprBinary(b, _, _) = e.node { b } else { return };\n+\n+    let result = match t.sty {\n+        ty::ty_int(int_type) => {\n+            let (lhs, rhs) = match (const_to_opt_int(te1),\n+                                    const_to_opt_int(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::IntTy::from(cx.tcx(), int_type));\n+            match b.node {\n+                ast::BiAdd => const_int_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_int_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_int_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_int_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_int_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_int_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_int_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        ty::ty_uint(uint_type) => {\n+            let (lhs, rhs) = match (const_to_opt_uint(te1),\n+                                    const_to_opt_uint(te2)) {\n+                (Some(v1), Some(v2)) => (v1, v2),\n+                _ => return,\n+            };\n+\n+            let opt_ety = Some(const_eval::UintTy::from(cx.tcx(), uint_type));\n+            match b.node {\n+                ast::BiAdd => const_uint_checked_add(lhs, rhs, e, opt_ety),\n+                ast::BiSub => const_uint_checked_sub(lhs, rhs, e, opt_ety),\n+                ast::BiMul => const_uint_checked_mul(lhs, rhs, e, opt_ety),\n+                ast::BiDiv => const_uint_checked_div(lhs, rhs, e, opt_ety),\n+                ast::BiRem => const_uint_checked_rem(lhs, rhs, e, opt_ety),\n+                ast::BiShl => const_uint_checked_shl(lhs, rhs, e, opt_ety),\n+                ast::BiShr => const_uint_checked_shr(lhs, rhs, e, opt_ety),\n+                _ => return,\n+            }\n+        }\n+        _ => return,\n+    };\n+    // We do not actually care about a successful result.\n+    if let Err(err) = result {\n+        cx.tcx().sess.span_err(e.span, &err.description());\n+    }\n+}\n+\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n@@ -386,7 +489,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let signed = ty::type_is_signed(intype);\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n-            let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+\n+            check_binary_expr_validity(cx, e, ty, te1, te2);\n \n             match b.node {\n               ast::BiAdd   => {\n@@ -416,8 +520,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               ast::BiBitXor => llvm::LLVMConstXor(te1, te2),\n               ast::BiBitAnd => llvm::LLVMConstAnd(te1, te2),\n               ast::BiBitOr  => llvm::LLVMConstOr(te1, te2),\n-              ast::BiShl    => llvm::LLVMConstShl(te1, te2),\n+              ast::BiShl    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n+                llvm::LLVMConstShl(te1, te2)\n+              }\n               ast::BiShr    => {\n+                let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n@@ -439,8 +547,11 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n             }\n           },\n-          ast::ExprUnary(u, ref e) => {\n-            let (te, ty) = const_expr(cx, &**e, param_substs);\n+          ast::ExprUnary(u, ref inner_e) => {\n+            let (te, ty) = const_expr(cx, &**inner_e, param_substs);\n+\n+            check_unary_expr_validity(cx, e, ty, te);\n+\n             let is_float = ty::type_is_fp(ty);\n             match u {\n               ast::UnUniq | ast::UnDeref => {\n@@ -661,11 +772,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n-                Ok(const_eval::const_int(i))  => i as usize,\n-                Ok(const_eval::const_uint(i)) => i as usize,\n-                _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n-            };\n+            let n = ty::eval_repeat_count(cx.tcx(), count);\n             let unit_val = const_expr(cx, &**elem, param_substs).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {"}, {"sha": "8e9ae2eba0bcd688201775bdd050285ab1d7db22", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -3207,7 +3207,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n fn assert_type_for_node_id(cx: &CrateContext,\n                            node_id: ast::NodeId,\n                            error_reporting_span: Span) {\n-    if !cx.tcx().node_types.borrow().contains_key(&node_id) {\n+    if !cx.tcx().node_types().contains_key(&node_id) {\n         cx.sess().span_bug(error_reporting_span,\n                            \"debuginfo: Could not find type for node id!\");\n     }"}, {"sha": "fbff4e84788822d06dbf54cc62e3b6cd2c862e5b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 67, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -85,7 +85,7 @@ use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n-use middle::{const_eval, def};\n+use middle::def;\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n@@ -94,7 +94,7 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n+use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -4283,68 +4283,30 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                           vs: &'tcx [P<ast::Variant>],\n                           id: ast::NodeId,\n-                          hint: attr::ReprAttr)\n-                          -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+                          hint: attr::ReprAttr) {\n         #![allow(trivial_numeric_casts)]\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-        let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs {\n+        let inh = static_inherited_fields(ccx);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-            // If the discriminant value is specified explicitly in the enum check whether the\n-            // initialization expression is valid, otherwise use the last value plus one.\n-            let mut current_disr_val = match prev_disr_val {\n-                Some(prev_disr_val) => {\n-                    if let Some(v) = prev_disr_val.checked_add(1) {\n-                        v\n-                    } else {\n-                        ty::INITIAL_DISCRIMINANT_VALUE\n-                    }\n-                }\n-                None => ty::INITIAL_DISCRIMINANT_VALUE\n-            };\n+        let (_, repr_type_ty) = ty::enum_repr_type(ccx.tcx, Some(&hint));\n+        for v in vs {\n+            if let Some(ref e) = v.node.disr_expr {\n+                check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n+            }\n+        }\n \n-            match v.node.disr_expr {\n-                Some(ref e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+        let def_id = local_def(id);\n \n-                    let inh = static_inherited_fields(ccx);\n-                    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-                    let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked |\n-                        attr::ReprExtern => fcx.tcx().types.isize,\n+        // ty::enum_variants guards against discriminant overflows, so\n+        // we need not check for that.\n+        let variants = ty::enum_variants(ccx.tcx, def_id);\n \n-                        attr::ReprInt(_, attr::SignedInt(ity)) => {\n-                            ty::mk_mach_int(fcx.tcx(), ity)\n-                        }\n-                        attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n-                            ty::mk_mach_uint(fcx.tcx(), ity)\n-                        },\n-                    };\n-                    check_const_with_ty(&fcx, e.span, &**e, declty);\n-                    // check_expr (from check_const pass) doesn't guarantee\n-                    // that the expression is in a form that eval_const_expr can\n-                    // handle, so we may still get an internal compiler error\n-\n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e, Some(declty)) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n-                        Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n-                        Ok(_) => {\n-                            span_err!(ccx.tcx.sess, e.span, E0079,\n-                                \"expected signed integer constant\");\n-                        }\n-                        Err(ref err) => {\n-                            span_err!(ccx.tcx.sess, err.span, E0080,\n-                                      \"constant evaluation error: {}\",\n-                                      err.description());\n-                        }\n-                    }\n-                },\n-                None => ()\n-            };\n+        for (v, variant) in vs.iter().zip(variants.iter()) {\n+            let current_disr_val = variant.disr_val;\n \n             // Check for duplicate discriminant values\n             match disr_vals.iter().position(|&x| x == current_disr_val) {\n@@ -4372,15 +4334,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n             }\n             disr_vals.push(current_disr_val);\n-\n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &**v,\n-                                                                     current_disr_val));\n-            prev_disr_val = Some(current_disr_val);\n-\n-            variants.push(variant_info);\n         }\n-\n-        return variants;\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n@@ -4396,10 +4350,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         };\n     }\n \n-    let variants = do_check(ccx, vs, id, hint);\n-\n-    // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n+    do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n "}, {"sha": "a8d93c8bd111a054b8a49bfc9f97c3de14913fd8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -51,8 +51,6 @@ register_diagnostics! {\n     E0075,\n     E0076,\n     E0077,\n-    E0079,\n-    E0080,\n     E0081,\n     E0082,\n     E0083,"}, {"sha": "9d6c04b1ad49d90957a2f373b6685f4a4ae15693", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -146,7 +146,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n-    tcx.node_types.borrow_mut().insert(node_id, ty);\n+    tcx.node_type_insert(node_id, ty);\n }\n \n fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "aec794af759b1e6b6a25df0ef78fcc4cbe2a5921", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -519,7 +519,8 @@ mod bench {\n         ({\n             use super::u64_from_be_bytes;\n \n-            let data = (0..$stride*100+$start_index).collect::<Vec<_>>();\n+            let len = $stride.wrapping_mul(100).wrapping_add($start_index);\n+            let data = (0..len).collect::<Vec<_>>();\n             let mut sum = 0;\n             $b.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "be04bc9bd3b732effbb96c0d55258242f7ed6c8d", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in refutable patterns goes through\n+// different compiler control-flow paths.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const NEG_128: i8 = -128;\n+const NEG_NEG_128: i8 = -NEG_128;\n+//~^ ERROR constant evaluation error: attempted to negate with overflow\n+//~| ERROR attempted to negate with overflow\n+\n+fn main() {\n+    match -128i8 {\n+        NEG_NEG_128 => println!(\"A\"),\n+        _ => println!(\"B\"),\n+    }\n+}"}, {"sha": "c2bc5b2648af3c4d8393998c707801ab514fda41", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array expression.\n+\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup; therefore resorting to\n+// error-pattern for now.\n+\n+// error-pattern: expected constant integer for repeat count, but attempted to add with overflow\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_I\n+    : [u32; (i8::MAX as usize) + 1]\n+    = [0; (i8::MAX + 1) as usize];\n+\n+fn main() {\n+    foo(&A_I8_I[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "719b21000f7a615e48f7dcd1021f41d02a55f0ad", "filename": "src/test/compile-fail/const-eval-overflow-3b.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3b.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array expression.\n+//\n+// This is a variation of another such test, but in this case the\n+// types for the left- and right-hand sides of the addition do not\n+// match (as well as overflow).\n+\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup; therefore resorting to\n+// error-pattern for now.\n+\n+// error-pattern: mismatched types\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_I\n+    : [u32; (i8::MAX as usize) + 1]\n+    = [0; (i8::MAX + 1u8) as usize];\n+\n+fn main() {\n+    foo(&A_I8_I[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "f1f125adaa7e330a73db146083c15493a53ab1bf", "filename": "src/test/compile-fail/const-eval-overflow-4.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test this should fail to compile (#23833)\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array type.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 + 1i8) as usize]\n+    //~^ ERROR error evaluating count: attempted to add with overflow\n+    = [0; (i8::MAX as usize) + 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "6322b56a82f000b1931e24ae96ce653534c9068d", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Evaluation of constants in array-elem count goes through different\n+// compiler control-flow paths.\n+//\n+// This test is checking the count in an array type.\n+\n+#![allow(unused_imports)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const A_I8_T\n+    : [u32; (i8::MAX as i8 + 1u8) as usize]\n+    //~^ ERROR mismatched types\n+    //~| the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    //~| the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    = [0; (i8::MAX as usize) + 1];\n+\n+fn main() {\n+    foo(&A_I8_T[..]);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}\n+"}, {"sha": "f647c43e13755d216debdf165d6208284e22840e", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_imports)]\n+\n+// Note: the relevant lint pass here runs before some of the constant\n+// evaluation below (e.g. that performed by trans and llvm), so if you\n+// change this warn to a deny, then the compiler will exit before\n+// those errors are detected.\n+#![warn(unsigned_negation)]\n+\n+use std::fmt;\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+const VALS_I8: (i8, i8, i8, i8) =\n+    (-i8::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i8::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i8::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i8::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I16: (i16, i16, i16, i16) =\n+    (-i16::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i16::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i16::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i16::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I32: (i32, i32, i32, i32) =\n+    (-i32::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i32::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i32::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i32::MIN * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_I64: (i64, i64, i64, i64) =\n+    (-i64::MIN,\n+     //~^ ERROR attempted to negate with overflow\n+     i64::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     i64::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     i64::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U8: (u8, u8, u8, u8) =\n+    (-u8::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u8::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u8::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u8::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U16: (u16, u16, u16, u16) =\n+    (-u16::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u16::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u16::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u16::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U32: (u32, u32, u32, u32) =\n+    (-u32::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u32::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u32::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u32::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+const VALS_U64: (u64, u64, u64, u64) =\n+    (-u64::MIN,\n+     //~^ WARNING negation of unsigned int variable may be unintentional\n+     // (The above is separately linted; unsigned negation is defined to be !x+1.)\n+     u64::MIN - 1,\n+     //~^ ERROR attempted to sub with overflow\n+     u64::MAX + 1,\n+     //~^ ERROR attempted to add with overflow\n+     u64::MAX * 2,\n+     //~^ ERROR attempted to mul with overflow\n+     );\n+\n+fn main() {\n+    foo(VALS_I8);\n+    foo(VALS_I16);\n+    foo(VALS_I32);\n+    foo(VALS_I64);\n+\n+    foo(VALS_U8);\n+    foo(VALS_U16);\n+    foo(VALS_U32);\n+    foo(VALS_U64);\n+}\n+\n+fn foo<T:fmt::Debug>(x: T) {\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "23106c99594a6f69e7f2c0ba3734453145a1df19", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// When explicit discriminant value has\n+// a type that does not match the representation\n+// type, rustc should fail gracefully.\n+\n+// See also run-pass/discrim-explicit-23030.rs where the input types\n+// are correct.\n+\n+#![allow(dead_code, unused_variables, unused_imports)]\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u8,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i8,\n+        //~^  ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u16,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i16,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u32,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i32,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo = 0_u64,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo = 0_i64,\n+        //~^ ERROR mismatched types\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn main() { }"}, {"sha": "76378d5c8021bd03eac59f856ba9ad41e5c766aa", "filename": "src/test/compile-fail/discrim-overflow-2.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow-2.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Issue 23030: Detect overflowing discriminant\n+//\n+// Check that we detect the overflow even if enum is not used.\n+\n+// See also run-pass/discrim-explicit-23030.rs where the suggested\n+// workaround is tested.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+    }\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+    }\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "5d7e61e9d1eec67fcb340de8ca036661ab9236e9", "filename": "src/test/compile-fail/discrim-overflow.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-overflow.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Issue 23030: Detect overflowing discriminant\n+\n+// See also run-pass/discrim-explicit-23030.rs where the suggested\n+// workaround is tested.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64, u64};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 127: i8; set explicitly via OhNo = -128 if that is desired outcome\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed on value after 255: u8; set explicitly via OhNo = 0 if that is desired outcome\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo, //~ ERROR enum discriminant overflowed\n+    }\n+\n+    let x = A::Ok;\n+}\n+\n+fn main() { }"}, {"sha": "54340cf7ac414f17d922749321a2814c7997f5e1", "filename": "src/test/compile-fail/huge-array-simple.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-array-simple.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -8,9 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: too big for the current\n+// FIXME (#23926): the error output is not consistent between a\n+// self-hosted and a cross-compiled setup. Skipping for now.\n+\n+// ignore-test FIXME(#23926)\n+\n #![allow(exceeding_bitshifts)]\n \n fn main() {\n-   let fat : [u8; (1<<61)+(1<<31)] = [0; (1u64<<61) as usize +(1u64<<31) as usize];\n+    let _fat : [u8; (1<<61)+(1<<31)] =\n+        [0; (1u64<<61) as usize +(1u64<<31) as usize];\n }"}, {"sha": "a7cabae16be1b8f39be0f84ae8f66a090bbfbdad", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Note: This test is checking that we forbid a coding pattern that\n+// Issue #5873 explicitly wants to allow.\n+\n enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR expected constant integer for repeat count, found non-constant expression\n+    //~^ ERROR expected constant integer for repeat count, but non-constant path\n }"}, {"sha": "3ce206ff7fb2c0c13b1a5a7b1079aa2e65e9a16d", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -12,6 +12,7 @@\n \n fn main() {\n     fn bar(n: usize) {\n-        let _x = [0; n]; //~ ERROR expected constant integer for repeat count, found variable\n+        let _x = [0; n];\n+        //~^ ERROR expected constant integer for repeat count, found variable\n     }\n }"}, {"sha": "ff13a1345d22ba27dbe3341b54eb9b2f4e0fc3c8", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -10,11 +10,16 @@\n \n // pretty-expanded FIXME #23616\n \n+#![feature(core)]\n+\n+// Catch mistakes in the overflowing literals lint.\n+#![deny(overflowing_literals)]\n+\n pub fn main() {\n     assert_eq!(0xffffffff, (-1 as u32));\n     assert_eq!(4294967295, (-1 as u32));\n     assert_eq!(0xffffffffffffffff, (-1 as u64));\n     assert_eq!(18446744073709551615, (-1 as u64));\n \n-    assert_eq!(-2147483648 - 1, 2147483647);\n+    assert_eq!((-2147483648).wrapping_sub(1), 2147483647);\n }"}, {"sha": "aed7b1527ce76d1f2cf483058d9910505f9c177c", "filename": "src/test/run-pass/discrim-explicit-23030.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiscrim-explicit-23030.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 23030: Workaround overflowing discriminant\n+// with explicit assignments.\n+\n+// See also compile-fail/overflow-discrim.rs, which shows what\n+// happens if you leave the OhNo explicit cases out here.\n+\n+use std::{i8,u8,i16,u16,i32,u32,i64,u64,isize,usize};\n+\n+fn f_i8() {\n+    #[repr(i8)]\n+    enum A {\n+        Ok = i8::MAX - 1,\n+        Ok2,\n+        OhNo = i8::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i8;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u8() {\n+    #[repr(u8)]\n+    enum A {\n+        Ok = u8::MAX - 1,\n+        Ok2,\n+        OhNo = u8::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i16() {\n+    #[repr(i16)]\n+    enum A {\n+        Ok = i16::MAX - 1,\n+        Ok2,\n+        OhNo = i16::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i16;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u16() {\n+    #[repr(u16)]\n+    enum A {\n+        Ok = u16::MAX - 1,\n+        Ok2,\n+        OhNo = u16::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i32() {\n+    #[repr(i32)]\n+    enum A {\n+        Ok = i32::MAX - 1,\n+        Ok2,\n+        OhNo = i32::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i32;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u32() {\n+    #[repr(u32)]\n+    enum A {\n+        Ok = u32::MAX - 1,\n+        Ok2,\n+        OhNo = u32::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_i64() {\n+    #[repr(i64)]\n+    enum A {\n+        Ok = i64::MAX - 1,\n+        Ok2,\n+        OhNo = i64::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as i64;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_u64() {\n+    #[repr(u64)]\n+    enum A {\n+        Ok = u64::MAX - 1,\n+        Ok2,\n+        OhNo = u64::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn f_isize() {\n+    #[repr(isize)]\n+    enum A {\n+        Ok = isize::MAX - 1,\n+        Ok2,\n+        OhNo = isize::MIN,\n+        NotTheEnd = -1,\n+        Zero,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+    let z = (A::NotTheEnd, A::Zero).1 as isize;\n+    assert_eq!(z, 0);\n+}\n+\n+fn f_usize() {\n+    #[repr(usize)]\n+    enum A {\n+        Ok = usize::MAX - 1,\n+        Ok2,\n+        OhNo = usize::MIN,\n+    }\n+\n+    let _x = (A::Ok, A::Ok2, A::OhNo);\n+}\n+\n+fn main() {\n+    f_i8(); f_u8();\n+    f_i16(); f_u16();\n+    f_i32(); f_u32();\n+    f_i64(); f_u64();\n+\n+    f_isize(); f_usize();\n+}"}, {"sha": "a87a3072c8adbcbd1d04495b8da91c8b35068507", "filename": "src/test/run-pass/small-enum-range-edge.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f643d79fc9573489c178eb283a7da1a1e8402c1/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enum-range-edge.rs?ref=4f643d79fc9573489c178eb283a7da1a1e8402c1", "patch": "@@ -10,6 +10,9 @@\n \n // pretty-expanded FIXME #23616\n \n+// this is for the wrapping_add call below.\n+#![feature(core)]\n+\n /*!\n  * Tests the range assertion wraparound case in trans::middle::adt::load_discr.\n  */\n@@ -29,8 +32,8 @@ static CLs: Es = Es::Ls;\n static CHs: Es = Es::Hs;\n \n pub fn main() {\n-    assert_eq!((Eu::Hu as u8) + 1, Eu::Lu as u8);\n-    assert_eq!((Es::Hs as i8) + 1, Es::Ls as i8);\n+    assert_eq!((Eu::Hu as u8).wrapping_add(1), Eu::Lu as u8);\n+    assert_eq!((Es::Hs as i8).wrapping_add(1), Es::Ls as i8);\n     assert_eq!(CLu as u8, Eu::Lu as u8);\n     assert_eq!(CHu as u8, Eu::Hu as u8);\n     assert_eq!(CLs as i8, Es::Ls as i8);"}]}