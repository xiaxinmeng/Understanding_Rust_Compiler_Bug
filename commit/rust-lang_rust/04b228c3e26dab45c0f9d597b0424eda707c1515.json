{"sha": "04b228c3e26dab45c0f9d597b0424eda707c1515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YjIyOGMzZTI2ZGFiNDVjMGY5ZDU5N2IwNDI0ZWRhNzA3YzE1MTU=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-03-14T12:38:03Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2018-03-14T13:14:33Z"}, "message": "Address niko's nits", "tree": {"sha": "5d37fa7f252547052acef8b53512a58955ef51bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d37fa7f252547052acef8b53512a58955ef51bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b228c3e26dab45c0f9d597b0424eda707c1515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b228c3e26dab45c0f9d597b0424eda707c1515", "html_url": "https://github.com/rust-lang/rust/commit/04b228c3e26dab45c0f9d597b0424eda707c1515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b228c3e26dab45c0f9d597b0424eda707c1515/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1271f0bd2519d63b427ea36a752f7de32bc5a7a2", "html_url": "https://github.com/rust-lang/rust/commit/1271f0bd2519d63b427ea36a752f7de32bc5a7a2"}], "stats": {"total": 368, "additions": 173, "deletions": 195}, "files": [{"sha": "78407e33d98b884b0d0ecc4c546f243a046efbfc", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -1294,9 +1294,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<\n         use traits::WhereClauseAtom::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Implemented(ref trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            ProjectionEq(ref projection) => projection.hash_stable(hcx, hasher),\n+        match self {\n+            Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -1308,54 +1308,59 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx>\n         use traits::DomainGoal::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Holds(ref where_clause) |\n-            WellFormed(ref where_clause) |\n-            FromEnv(ref where_clause) => where_clause.hash_stable(hcx, hasher),\n-\n-            WellFormedTy(ref ty) => ty.hash_stable(hcx, hasher),\n-            FromEnvTy(ref ty) => ty.hash_stable(hcx, hasher),\n-            RegionOutlives(ref predicate) => predicate.hash_stable(hcx, hasher),\n-            TypeOutlives(ref predicate) => predicate.hash_stable(hcx, hasher),\n+        match self {\n+            Holds(where_clause) |\n+            WellFormed(where_clause) |\n+            FromEnv(where_clause) => where_clause.hash_stable(hcx, hasher),\n+\n+            WellFormedTy(ty) => ty.hash_stable(hcx, hasher),\n+            FromEnvTy(ty) => ty.hash_stable(hcx, hasher),\n+            RegionOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n+            TypeOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n         }\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::LeafGoal<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::LeafGoal::*;\n+        use traits::Goal::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            DomainGoal(ref domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                hypotheses.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n+            And(goal1, goal2) => {\n+                goal1.hash_stable(hcx, hasher);\n+                goal2.hash_stable(hcx, hasher);\n+            }\n+            Not(goal) => goal.hash_stable(hcx, hasher),\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            Quantified(quantifier, goal) => {\n+                quantifier.hash_stable(hcx, hasher);\n+                goal.hash_stable(hcx, hasher);\n+            },\n         }\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::Goal::*;\n+        use traits::Clause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Implies(ref hypotheses, ref goal) => {\n+        match self {\n+            Implies(hypotheses, goal) => {\n                 hypotheses.hash_stable(hcx, hasher);\n                 goal.hash_stable(hcx, hasher);\n-            },\n-            And(ref goal1, ref goal2) => {\n-                goal1.hash_stable(hcx, hasher);\n-                goal2.hash_stable(hcx, hasher);\n             }\n-            Not(ref goal) => goal.hash_stable(hcx, hasher),\n-            Leaf(ref leaf_goal) => leaf_goal.hash_stable(hcx, hasher),\n-            Quantified(quantifier, ref goal) => {\n-                quantifier.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            },\n+            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            ForAll(clause) => clause.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -1364,8 +1369,3 @@ impl_stable_hash_for!(enum traits::QuantifierKind {\n     Universal,\n     Existential\n });\n-\n-impl_stable_hash_for!(struct traits::ProgramClause<'tcx> {\n-    consequence,\n-    conditions\n-});"}, {"sha": "f31e474963ee2dabee82b5003c18fe16db43bbb2", "filename": "src/librustc/traits/lowering.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Flowering.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -11,8 +11,8 @@\n use hir::{self, ImplPolarity};\n use hir::def_id::DefId;\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use ty::{self, PolyTraitPredicate, TraitPredicate, PolyProjectionPredicate, TyCtxt, Predicate};\n-use super::{DomainGoal, ProgramClause, WhereClauseAtom};\n+use ty::{self, TyCtxt};\n+use super::{QuantifierKind, Goal, DomainGoal, Clause, WhereClauseAtom};\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n \n@@ -26,13 +26,13 @@ impl<T, U> Lower<Vec<U>> for Vec<T> where T: Lower<U> {\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for PolyTraitPredicate<'tcx> {\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::TraitPredicate<'tcx> {\n     fn lower(&self) -> WhereClauseAtom<'tcx> {\n         WhereClauseAtom::Implemented(*self)\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for PolyProjectionPredicate<'tcx> {\n+impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::ProjectionPredicate<'tcx> {\n     fn lower(&self) -> WhereClauseAtom<'tcx> {\n         WhereClauseAtom::ProjectionEq(*self)\n     }\n@@ -44,27 +44,52 @@ impl<'tcx, T> Lower<DomainGoal<'tcx>> for T where T: Lower<WhereClauseAtom<'tcx>\n     }\n }\n \n-impl<'tcx> Lower<DomainGoal<'tcx>> for Predicate<'tcx> {\n+impl<'tcx> Lower<DomainGoal<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n     fn lower(&self) -> DomainGoal<'tcx> {\n-        use self::Predicate::*;\n+        DomainGoal::RegionOutlives(*self)\n+    }\n+}\n+\n+impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> DomainGoal<'tcx> {\n+        DomainGoal::TypeOutlives(*self)\n+    }\n+}\n+\n+impl<'tcx, T> Lower<Goal<'tcx>> for ty::Binder<T>\n+    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx> + Copy\n+{\n+    fn lower(&self) -> Goal<'tcx> {\n+        match self.no_late_bound_regions() {\n+            Some(p) => p.lower().into(),\n+            None => Goal::Quantified(\n+                QuantifierKind::Universal,\n+                Box::new(self.map_bound(|p| p.lower().into()))\n+            ),\n+        }\n+    }\n+}\n \n-        match *self {\n+impl<'tcx> Lower<Goal<'tcx>> for ty::Predicate<'tcx> {\n+    fn lower(&self) -> Goal<'tcx> {\n+        use ty::Predicate::*;\n+\n+        match self {\n             Trait(predicate) => predicate.lower(),\n-            RegionOutlives(predicate) => DomainGoal::RegionOutlives(predicate),\n-            TypeOutlives(predicate) => DomainGoal::TypeOutlives(predicate),\n+            RegionOutlives(predicate) => predicate.lower(),\n+            TypeOutlives(predicate) => predicate.lower(),\n             Projection(predicate) => predicate.lower(),\n-            WellFormed(ty) => DomainGoal::WellFormedTy(ty),\n+            WellFormed(ty) => DomainGoal::WellFormedTy(*ty).into(),\n             ObjectSafe(..) |\n             ClosureKind(..) |\n             Subtype(..) |\n             ConstEvaluatable(..) => unimplemented!(),\n-\n         }\n     }\n }\n \n pub fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Lrc<Vec<ProgramClause<'tcx>>>\n+    -> Lrc<Vec<Clause<'tcx>>>\n {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(node_id);\n@@ -75,21 +100,17 @@ pub fn program_clauses_for<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Lrc<Vec<ProgramClause<'tcx>>>\n+    -> Lrc<Vec<Clause<'tcx>>>\n {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return Lrc::new(vec![]);\n     }\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n-    let trait_ref = ty::Binder(TraitPredicate { trait_ref }).lower();\n+    let trait_ref = ty::TraitPredicate { trait_ref }.lower();\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n-    let clause = ProgramClause {\n-        consequence: trait_ref,\n-        conditions: where_clauses.into_iter().map(|wc| wc.into()).collect(),\n-    };\n-\n+    let clause = Clause::Implies(where_clauses, trait_ref);\n     Lrc::new(vec![clause])\n }\n "}, {"sha": "ea3db0c6e92609c4ea0ddf631f57af8fcc9cf40c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -248,8 +248,8 @@ pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum WhereClauseAtom<'tcx> {\n-    Implemented(ty::PolyTraitPredicate<'tcx>),\n-    ProjectionEq(ty::PolyProjectionPredicate<'tcx>),\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -259,13 +259,8 @@ pub enum DomainGoal<'tcx> {\n     FromEnv(WhereClauseAtom<'tcx>),\n     WellFormedTy(Ty<'tcx>),\n     FromEnvTy(Ty<'tcx>),\n-    RegionOutlives(ty::PolyRegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::PolyTypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum LeafGoal<'tcx> {\n-    DomainGoal(DomainGoal<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -276,23 +271,30 @@ pub enum QuantifierKind {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Goal<'tcx> {\n-    Implies(Vec<DomainGoal<'tcx>>, Box<Goal<'tcx>>),\n+    Implies(Vec<Clause<'tcx>>, Box<Goal<'tcx>>),\n     And(Box<Goal<'tcx>>, Box<Goal<'tcx>>),\n     Not(Box<Goal<'tcx>>),\n-    Leaf(LeafGoal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n     Quantified(QuantifierKind, Box<ty::Binder<Goal<'tcx>>>)\n }\n \n impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n     fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Goal::Leaf(LeafGoal::DomainGoal(domain_goal))\n+        Goal::DomainGoal(domain_goal)\n+    }\n+}\n+\n+impl<'tcx> From<DomainGoal<'tcx>> for Clause<'tcx> {\n+    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n+        Clause::DomainGoal(domain_goal)\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct ProgramClause<'tcx> {\n-    pub consequence: DomainGoal<'tcx>,\n-    pub conditions: Vec<Goal<'tcx>>,\n+pub enum Clause<'tcx> {\n+    Implies(Vec<Goal<'tcx>>, DomainGoal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    ForAll(Box<ty::Binder<Clause<'tcx>>>),\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "d6e6f0e98adc48afb18f4f61efdae5ac64dec78d", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 71, "deletions": 119, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -429,9 +429,10 @@ BraceStructTypeFoldableImpl! {\n impl<'tcx> fmt::Display for traits::WhereClauseAtom<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::WhereClauseAtom::*;\n-        match *self {\n-            Implemented(ref trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(ref projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n         }\n     }\n }\n@@ -440,44 +441,38 @@ impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::DomainGoal::*;\n         use traits::WhereClauseAtom::*;\n-        match *self {\n+\n+        match self {\n             Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(Implemented(ref trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            WellFormed(ProjectionEq(ref projection)) => write!(fmt, \"WellFormed({})\", projection),\n-            FromEnv(Implemented(ref trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            FromEnv(ProjectionEq(ref projection)) => write!(fmt, \"FromEnv({})\", projection),\n-            WellFormedTy(ref ty) => write!(fmt, \"WellFormed({})\", ty),\n-            FromEnvTy(ref ty) => write!(fmt, \"FromEnv({})\", ty),\n-            RegionOutlives(ref predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n-            TypeOutlives(ref predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n+            WellFormed(Implemented(trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            WellFormed(ProjectionEq(projection)) => write!(fmt, \"WellFormed({})\", projection),\n+            FromEnv(Implemented(trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            FromEnv(ProjectionEq(projection)) => write!(fmt, \"FromEnv({})\", projection),\n+            WellFormedTy(ty) => write!(fmt, \"WellFormed({})\", ty),\n+            FromEnvTy(ty) => write!(fmt, \"FromEnv({})\", ty),\n+            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n+            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n         }\n     }\n }\n \n impl fmt::Display for traits::QuantifierKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::QuantifierKind::*;\n-        match *self {\n+\n+        match self {\n             Universal => write!(fmt, \"forall\"),\n             Existential => write!(fmt, \"exists\"),\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::LeafGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        use traits::LeafGoal::*;\n-        match *self {\n-            DomainGoal(ref domain_goal) => write!(fmt, \"{}\", domain_goal),\n-        }\n-    }\n-}\n-\n impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::Goal::*;\n-        match *self {\n-            Implies(ref hypotheses, ref goal) => {\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n                 write!(fmt, \"if (\")?;\n                 for (index, hyp) in hypotheses.iter().enumerate() {\n                     if index > 0 {\n@@ -487,124 +482,81 @@ impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n                 }\n                 write!(fmt, \") {{ {} }}\", goal)\n             }\n-            And(ref goal1, ref goal2) => write!(fmt, \"({}, {})\", goal1, goal2),\n-            Not(ref goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            Leaf(ref goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, ref goal) => {\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n                 // FIXME: appropriate binder names\n                 write!(fmt, \"{}<> {{ {} }}\", qkind, goal.skip_binder())\n             }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{}\", self.consequence)?;\n-        if self.conditions.is_empty() {\n-            write!(fmt, \".\")?;\n-        } else {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in self.conditions.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n+        use traits::Clause::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"{}\", goal)?;\n+                if !hypotheses.is_empty() {\n+                    write!(fmt, \" :- \")?;\n+                    for (index, condition) in hypotheses.iter().enumerate() {\n+                        if index > 0 {\n+                            write!(fmt, \", \")?;\n+                        }\n+                        write!(fmt, \"{}\", condition)?;\n+                    }\n                 }\n-                write!(fmt, \"{}\", condition)?;\n+                write!(fmt, \".\")\n+            }\n+            DomainGoal(domain_goal) => write!(fmt, \"{}.\", domain_goal),\n+            ForAll(clause) => {\n+                // FIXME: appropriate binder names\n+                write!(fmt, \"forall<> {{ {} }}\", clause.skip_binder())\n             }\n         }\n-        Ok(())\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use traits::WhereClauseAtom::*;\n-        match *self {\n-            Implemented(ref trait_ref) => Implemented(trait_ref.fold_with(folder)),\n-            ProjectionEq(ref projection) => ProjectionEq(projection.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use traits::WhereClauseAtom::*;\n-        match *self {\n-            Implemented(ref trait_ref) => trait_ref.visit_with(visitor),\n-            ProjectionEq(ref projection) => projection.visit_with(visitor),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n+        (traits::WhereClauseAtom::Implemented)(trait_ref),\n+        (traits::WhereClauseAtom::ProjectionEq)(projection),\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use traits::DomainGoal::*;\n-        match *self {\n-            Holds(ref wc) => Holds(wc.fold_with(folder)),\n-            WellFormed(ref wc) => WellFormed(wc.fold_with(folder)),\n-            FromEnv(ref wc) => FromEnv(wc.fold_with(folder)),\n-            WellFormedTy(ref ty) => WellFormedTy(ty.fold_with(folder)),\n-            FromEnvTy(ref ty) => FromEnvTy(ty.fold_with(folder)),\n-            RegionOutlives(ref predicate) => RegionOutlives(predicate.fold_with(folder)),\n-            TypeOutlives(ref predicate) => TypeOutlives(predicate.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use traits::DomainGoal::*;\n-        match *self {\n-            Holds(ref wc) |\n-            WellFormed(ref wc) |\n-            FromEnv(ref wc) => wc.visit_with(visitor),\n-            WellFormedTy(ref ty) |\n-            FromEnvTy(ref ty) => ty.visit_with(visitor),\n-            RegionOutlives(ref predicate) => predicate.visit_with(visitor),\n-            TypeOutlives(ref predicate) => predicate.visit_with(visitor),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wc),\n+        (traits::DomainGoal::FromEnv)(wc),\n+        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::FromEnvTy)(ty),\n+        (traits::DomainGoal::RegionOutlives)(predicate),\n+        (traits::DomainGoal::TypeOutlives)(predicate),\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::LeafGoal<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use traits::LeafGoal::*;\n-        match *self {\n-            DomainGoal(ref domain_goal) => DomainGoal(domain_goal.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use traits::LeafGoal::*;\n-        match *self {\n-            DomainGoal(ref domain_goal) => domain_goal.visit_with(visitor),\n-        }\n-    }\n+CloneTypeFoldableImpls! {\n+    traits::QuantifierKind,\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use traits::Goal::*;\n-        match *self {\n-            Implies(ref hypotheses, ref goal) => {\n-                Implies(\n-                    hypotheses.iter().map(|hyp| hyp.fold_with(folder)).collect(),\n-                    goal.fold_with(folder)\n-                )\n-            },\n-            And(ref goal1, ref goal2) => And(goal1.fold_with(folder), goal2.fold_with(folder)),\n-            Not(ref goal) => Not(goal.fold_with(folder)),\n-            Leaf(ref leaf_goal) => Leaf(leaf_goal.fold_with(folder)),\n-            Quantified(qkind, ref goal) => Quantified(qkind, goal.fold_with(folder)),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+        (traits::Goal::Implies)(hypotheses, goal),\n+        (traits::Goal::And)(goal1, goal2),\n+        (traits::Goal::Not)(goal),\n+        (traits::Goal::DomainGoal)(domain_goal),\n+        (traits::Goal::Quantified)(qkind, goal),\n     }\n+}\n \n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use traits::Goal::*;\n-        match *self {\n-            Implies(ref hypotheses, ref goal) => {\n-                hypotheses.iter().any(|hyp| hyp.visit_with(visitor)) || goal.visit_with(visitor)\n-            }\n-            And(ref goal1, ref goal2) => goal1.visit_with(visitor) || goal2.visit_with(visitor),\n-            Not(ref goal) => goal.visit_with(visitor),\n-            Leaf(ref leaf_goal) => leaf_goal.visit_with(visitor),\n-            Quantified(_, ref goal) => goal.visit_with(visitor),\n-        }\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::Clause<'tcx> {\n+        (traits::Clause::Implies)(hypotheses, goal),\n+        (traits::Clause::DomainGoal)(domain_goal),\n+        (traits::Clause::ForAll)(clause),\n     }\n }"}, {"sha": "50dfbeb9724ca443dd1f65f2ab3c4b0795603bf4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -38,7 +38,7 @@ use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n-use traits::ProgramClause;\n+use traits::Clause;\n use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n@@ -419,7 +419,7 @@ define_maps! { <'tcx>\n \n     [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n \n-    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<ProgramClause<'tcx>>>,\n+    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<Clause<'tcx>>>,\n }\n \n //////////////////////////////////////////////////////////////////////"}, {"sha": "ea116b4cd0a41067e930b0876ba57068cdb1608e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -1073,9 +1073,12 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<ty::Region<'tcx>,\n-                                                                   ty::Region<'tcx>>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n+pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n+                                                           ty::Region<'tcx>>;\n+pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n+                                                         ty::Region<'tcx>>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct SubtypePredicate<'tcx> {"}, {"sha": "68c9c946215d1b015741cb0eef29a2cbab0e54e1", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -1089,7 +1089,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n         time(sess, \"lint checking\", || lint::check_crate(tcx));\n \n-        time(time_passes, \"dumping chalk-like clauses\", || traits::dump_program_clauses(tcx));\n+        time(sess, \"dumping chalk-like clauses\", || traits::dump_program_clauses(tcx));\n \n         return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })"}, {"sha": "b5d791d640ada9dcd79a4c07aff37b2e845f90fa", "filename": "src/test/ui/chalkify/lower_impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04b228c3e26dab45c0f9d597b0424eda707c1515/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr?ref=04b228c3e26dab45c0f9d597b0424eda707c1515", "patch": "@@ -1,4 +1,4 @@\n-error: Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T : 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized)\n+error: Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T : 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized).\n   --> $DIR/lower_impl.rs:15:1\n    |\n LL | #[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-"}]}