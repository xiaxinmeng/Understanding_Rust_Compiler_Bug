{"sha": "bd704f794fe58a9917ed1fed04e9f9dc6856cda1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNzA0Zjc5NGZlNThhOTkxN2VkMWZlZDA0ZTlmOWRjNjg1NmNkYTE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-07T19:46:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-07T19:46:11Z"}, "message": "Rollup merge of #71598 - lcnr:drop-docs, r=RalfJung,Mark-Simulacrum\n\nimprove Drop documentation\n\nFixes #36073\n\nThis is a continuation of #57449 and most of the work here was done by\nthe excellent @steveklabnik.", "tree": {"sha": "e72eef055af2689621dd954d2b6ea1e520ddca46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e72eef055af2689621dd954d2b6ea1e520ddca46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd704f794fe58a9917ed1fed04e9f9dc6856cda1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetGWDCRBK7hj4Ov3rIwAAdHIIAF+5Qjd5GkXNQmrHETqHiBOD\niNjvJIrt8gaW0x7bQ+stfjAkhsdSwYDiVtQtNQRINgvOspuW1AdW7A0W8whq3k9c\nAvyDioO1gJOK6KTM/4fgrbfMnqMmWWeEwlt8T4hJuDpzsz4MPsayZs6MRmXe9Dsg\nzifcfAGRrAIsKW2J7e/RbuujFUTQbw/KVS4+3XpjOQh3+eYeXKjWV7UaG3Blhxto\npWRbCcMTD0My5l2kVMqXaNpHwznRb+DyxjhyEWLYTCTog1OzZRFjbDiZH0EjPo2M\n5+jJusMztSLoNjm10v4OzgOWTrPhxMGqGWa8OZfyYilgTQM8dLg8aU4eX/cbjUU=\n=GJX9\n-----END PGP SIGNATURE-----\n", "payload": "tree e72eef055af2689621dd954d2b6ea1e520ddca46\nparent 5e9b3720e5c49656b78a047922bbc34fe74a67b3\nparent 33324f5a40137edbe9d7b8248ba16c07b377227c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588880771 +0200\ncommitter GitHub <noreply@github.com> 1588880771 +0200\n\nRollup merge of #71598 - lcnr:drop-docs, r=RalfJung,Mark-Simulacrum\n\nimprove Drop documentation\n\nFixes #36073\n\nThis is a continuation of #57449 and most of the work here was done by\nthe excellent @steveklabnik.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd704f794fe58a9917ed1fed04e9f9dc6856cda1", "html_url": "https://github.com/rust-lang/rust/commit/bd704f794fe58a9917ed1fed04e9f9dc6856cda1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd704f794fe58a9917ed1fed04e9f9dc6856cda1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9b3720e5c49656b78a047922bbc34fe74a67b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9b3720e5c49656b78a047922bbc34fe74a67b3", "html_url": "https://github.com/rust-lang/rust/commit/5e9b3720e5c49656b78a047922bbc34fe74a67b3"}, {"sha": "33324f5a40137edbe9d7b8248ba16c07b377227c", "url": "https://api.github.com/repos/rust-lang/rust/commits/33324f5a40137edbe9d7b8248ba16c07b377227c", "html_url": "https://github.com/rust-lang/rust/commit/33324f5a40137edbe9d7b8248ba16c07b377227c"}], "stats": {"total": 142, "additions": 98, "deletions": 44}, "files": [{"sha": "06cfc36363615ee56515bcb64e439bea37676484", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bd704f794fe58a9917ed1fed04e9f9dc6856cda1/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd704f794fe58a9917ed1fed04e9f9dc6856cda1/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=bd704f794fe58a9917ed1fed04e9f9dc6856cda1", "patch": "@@ -1,85 +1,139 @@\n-/// Used to run some code when a value goes out of scope.\n-/// This is sometimes called a 'destructor'.\n+/// Custom code within the destructor.\n ///\n-/// When a value goes out of scope, it will have its `drop` method called if\n-/// its type implements `Drop`. Then, any fields the value contains will also\n-/// be dropped recursively.\n+/// When a value is no longer needed, Rust will run a \"destructor\" on that value.\n+/// The most common way that a value is no longer needed is when it goes out of\n+/// scope. Destructors may still run in other circumstances, but we're going to\n+/// focus on scope for the examples here. To learn about some of those other cases,\n+/// please see [the reference] section on destructors.\n ///\n-/// Because of this recursive dropping, you do not need to implement this trait\n-/// unless your type needs its own destructor logic.\n+/// [the reference]: https://doc.rust-lang.org/reference/destructors.html\n ///\n-/// Refer to [the chapter on `Drop` in *The Rust Programming Language*][book]\n-/// for some more elaboration.\n+/// This destructor consists of two components:\n+/// - A call to `Drop::drop` for that value, if this special `Drop` trait is implemented for its type.\n+/// - The automatically generated \"drop glue\" which recursively calls the destructors\n+///     of the all fields of this value.\n ///\n-/// [book]: ../../book/ch15-03-drop.html\n+/// As Rust automatically calls the destructors of all contained fields,\n+/// you don't have to implement `Drop` in most cases. But there are some cases where\n+/// it is useful, for example for types which directly manage a resource.\n+/// That resource may be memory, it may be a file descriptor, it may be a network socket.\n+/// Once a value of that type is no longer going to be used, it should \"clean up\" its\n+/// resource by freeing the memory or closing the file or socket. This is\n+/// the job of a destructor, and therefore the job of `Drop::drop`.\n ///\n-/// # Examples\n+/// ## Examples\n ///\n-/// ## Implementing `Drop`\n+/// To see destructors in action, let's take a look at the following program:\n ///\n-/// The `drop` method is called when `_x` goes out of scope, and therefore\n-/// `main` prints `Dropping!`.\n-///\n-/// ```\n+/// ```rust\n /// struct HasDrop;\n ///\n /// impl Drop for HasDrop {\n ///     fn drop(&mut self) {\n-///         println!(\"Dropping!\");\n+///         println!(\"Dropping HasDrop!\");\n+///     }\n+/// }\n+///\n+/// struct HasTwoDrops {\n+///     one: HasDrop,\n+///     two: HasDrop,\n+/// }\n+///\n+/// impl Drop for HasTwoDrops {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping HasTwoDrops!\");\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let _x = HasDrop;\n+///     let _x = HasTwoDrops { one: HasDrop, two: HasDrop };\n+///     println!(\"Running!\");\n /// }\n /// ```\n ///\n-/// ## Dropping is done recursively\n+/// Rust will first call `Drop::drop` for `_x` and then for both `_x.one` and `_x.two`,\n+/// meaning that running this will print\n ///\n-/// When `outer` goes out of scope, the `drop` method will be called first for\n-/// `Outer`, then for `Inner`. Therefore, `main` prints `Dropping Outer!` and\n-/// then `Dropping Inner!`.\n+/// ```text\n+/// Running!\n+/// Dropping HasTwoDrops!\n+/// Dropping HasDrop!\n+/// Dropping HasDrop!\n+/// ```\n+///\n+/// Even if we remove the implementation of `Drop` for `HasTwoDrop`, the destructors of its fields are still called.\n+/// This would result in\n ///\n+/// ```test\n+/// Running!\n+/// Dropping HasDrop!\n+/// Dropping HasDrop!\n /// ```\n-/// struct Inner;\n-/// struct Outer(Inner);\n ///\n-/// impl Drop for Inner {\n+/// ## You cannot call `Drop::drop` yourself\n+///\n+/// Because `Drop::drop` is used to clean up a value, it may be dangerous to use this value after\n+/// the method has been called. As `Drop::drop` does not take ownership of its input,\n+/// Rust prevents misuse by not allowing you to call `Drop::drop` directly.\n+///\n+/// In other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error.\n+///\n+/// If you'd like explicitly call the destructor of a value, [`std::mem::drop`] can be used instead.\n+///\n+/// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+///\n+/// ## Drop order\n+///\n+/// Which of our two `HasDrop` drops first, though? For structs, it's the same\n+/// order that they're declared: first `one`, then `two`. If you'd like to try\n+/// this yourself, you can modify `HasDrop` above to contain some data, like an\n+/// integer, and then use it in the `println!` inside of `Drop`. This behavior is\n+/// guaranteed by the language.\n+///\n+/// Unlike for structs, local variables are dropped in reverse order:\n+///\n+/// ```rust\n+/// struct Foo;\n+///\n+/// impl Drop for Foo {\n ///     fn drop(&mut self) {\n-///         println!(\"Dropping Inner!\");\n+///         println!(\"Dropping Foo!\")\n ///     }\n /// }\n ///\n-/// impl Drop for Outer {\n+/// struct Bar;\n+///\n+/// impl Drop for Bar {\n ///     fn drop(&mut self) {\n-///         println!(\"Dropping Outer!\");\n+///         println!(\"Dropping Bar!\")\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let _x = Outer(Inner);\n+///     let _foo = Foo;\n+///     let _bar = Bar;\n /// }\n /// ```\n ///\n-/// ## Variables are dropped in reverse order of declaration\n-///\n-/// `_first` is declared first and `_second` is declared second, so `main` will\n-/// print `Declared second!` and then `Declared first!`.\n+/// This will print\n ///\n+/// ```text\n+/// Dropping Bar!\n+/// Dropping Foo!\n /// ```\n-/// struct PrintOnDrop(&'static str);\n ///\n-/// impl Drop for PrintOnDrop {\n-///     fn drop(&mut self) {\n-///         println!(\"{}\", self.0);\n-///     }\n-/// }\n+/// Please see [the reference] for the full rules.\n ///\n-/// fn main() {\n-///     let _first = PrintOnDrop(\"Declared first!\");\n-///     let _second = PrintOnDrop(\"Declared second!\");\n-/// }\n-/// ```\n+/// [the reference]: https://doc.rust-lang.org/reference/destructors.html\n+///\n+/// ## `Copy` and `Drop` are exclusive\n+///\n+/// You cannot implement both [`Copy`] and `Drop` on the same type. Types that\n+/// are `Copy` get implicitly duplicated by the compiler, making it very\n+/// hard to predict when, and how often destructors will be executed. As such,\n+/// these types cannot have destructors.\n+///\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {"}]}