{"sha": "a07ea73bdbc023f80efe809388ed9299ba76bcb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwN2VhNzNiZGJjMDIzZjgwZWZlODA5Mzg4ZWQ5Mjk5YmE3NmJjYjg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T20:16:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T20:36:54Z"}, "message": "Make moves explicit in task; also make option::unwrap take its argument by move", "tree": {"sha": "61f8567ffbe4285ed41bdf18d205331c98849726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61f8567ffbe4285ed41bdf18d205331c98849726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a07ea73bdbc023f80efe809388ed9299ba76bcb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a07ea73bdbc023f80efe809388ed9299ba76bcb8", "html_url": "https://github.com/rust-lang/rust/commit/a07ea73bdbc023f80efe809388ed9299ba76bcb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a07ea73bdbc023f80efe809388ed9299ba76bcb8/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04f17634091587053ae7d7d35d2318406e8d7d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/04f17634091587053ae7d7d35d2318406e8d7d0d", "html_url": "https://github.com/rust-lang/rust/commit/04f17634091587053ae7d7d35d2318406e8d7d0d"}], "stats": {"total": 113, "additions": 58, "deletions": 55}, "files": [{"sha": "f97afb317a7df7b959a2f5f73f9b7c04153f29d1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a07ea73bdbc023f80efe809388ed9299ba76bcb8", "patch": "@@ -74,7 +74,7 @@ pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+T) -> U) -> Option<U> {\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n-    if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n+    if opt.is_some() { Some(f(option::unwrap(opt))) } else { None }\n }\n \n pure fn chain<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n@@ -112,7 +112,7 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+T) -> Option<T>) {\n \n     let mut opt <- x;\n     while opt.is_some() {\n-        opt = blk(unwrap(move opt));\n+        opt = blk(unwrap(opt));\n     }\n }\n \n@@ -160,8 +160,10 @@ pure fn iter_ref<T>(opt: &Option<T>, f: fn(x: &T)) {\n     match *opt { None => (), Some(ref t) => f(t) }\n }\n \n+// tjc: shouldn't this be - instead of +?\n+// then could get rid of some superfluous moves\n #[inline(always)]\n-pure fn unwrap<T>(+opt: Option<T>) -> T {\n+pure fn unwrap<T>(-opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -184,7 +186,7 @@ fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n-    unwrap(move opt)\n+    unwrap(opt)\n }\n \n // Some of these should change to be &Option<T>, some should not. See below."}, {"sha": "851671f910ce16d98ef5ad744e61204ca42a8d2e", "filename": "src/libcore/task.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=a07ea73bdbc023f80efe809388ed9299ba76bcb8", "patch": "@@ -79,7 +79,7 @@ export ManualThreads;\n export PlatformThread;\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); move y } }\n )\n \n /* Data types */\n@@ -281,7 +281,7 @@ enum TaskBuilder = {\n fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n-        gen_body: |body| body, // Identity function\n+        gen_body: |body| move body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     })\n@@ -301,7 +301,7 @@ priv impl TaskBuilder {\n             opts: {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n             gen_body: self.gen_body,\n@@ -326,7 +326,7 @@ impl TaskBuilder {\n             opts: {\n                 linked: false,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -348,7 +348,7 @@ impl TaskBuilder {\n             opts: {\n                 linked: false,\n                 supervised: true,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -369,7 +369,7 @@ impl TaskBuilder {\n             opts: {\n                 linked: true,\n                 supervised: false,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -407,7 +407,7 @@ impl TaskBuilder {\n         // Construct the future and give it to the caller.\n         let (notify_pipe_ch, notify_pipe_po) = stream::<Notification>();\n \n-        blk(do future::from_fn {\n+        blk(do future::from_fn |move notify_pipe_po| {\n             match notify_pipe_po.recv() {\n               Exit(_, result) => result\n             }\n@@ -418,7 +418,7 @@ impl TaskBuilder {\n             opts: {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: Some(notify_pipe_ch),\n+                mut notify_chan: Some(move notify_pipe_ch),\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -436,7 +436,7 @@ impl TaskBuilder {\n             opts: {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: Some({ mode: mode, foreign_stack_size: None})\n             },\n             can_not_copy: None,\n@@ -467,10 +467,10 @@ impl TaskBuilder {\n             opts: {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: notify_chan,\n+                mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n-            gen_body: |body| { wrapper(prev_gen_body(body)) },\n+            gen_body: |body| { wrapper(prev_gen_body(move body)) },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -494,21 +494,21 @@ impl TaskBuilder {\n         } else {\n             let swapped_notify_chan =\n                 option::swap_unwrap(&mut self.opts.notify_chan);\n-            Some(swapped_notify_chan)\n+            Some(move swapped_notify_chan)\n         };\n         let x = self.consume();\n         let opts = {\n             linked: x.opts.linked,\n             supervised: x.opts.supervised,\n-            mut notify_chan: notify_chan,\n+            mut notify_chan: move notify_chan,\n             sched: x.opts.sched\n         };\n-        spawn_raw(opts, x.gen_body(f));\n+        spawn_raw(move opts, x.gen_body(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: Send>(+arg: A, +f: fn~(+A)) {\n-        let arg = ~mut Some(arg);\n-        do self.spawn {\n+        let arg = ~mut Some(move arg);\n+        do self.spawn |move arg, move f|{\n             f(option::swap_unwrap(arg))\n         }\n     }\n@@ -527,11 +527,11 @@ impl TaskBuilder {\n     fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::Port();\n         let setup_ch = comm::Chan(setup_po);\n-        do self.spawn {\n+        do self.spawn |move f| {\n             let po = comm::Port();\n             let ch = comm::Chan(po);\n             comm::send(setup_ch, ch);\n-            f(po);\n+            f(move po);\n         }\n         comm::recv(setup_po)\n     }\n@@ -544,7 +544,7 @@ impl TaskBuilder {\n         -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::Port();\n         let to_parent = comm::Chan(from_child);\n-        let to_child = do self.spawn_listener |from_parent| {\n+        let to_child = do self.spawn_listener |move f, from_parent| {\n             f(from_parent, to_parent)\n         };\n         (from_child, to_child)\n@@ -568,8 +568,10 @@ impl TaskBuilder {\n         let ch = comm::Chan(po);\n         let mut result = None;\n \n-        let fr_task_builder = self.future_result(|+r| { result = Some(r); });\n-        do fr_task_builder.spawn {\n+        let fr_task_builder = self.future_result(|+r| {\n+            result = Some(move r);\n+        });\n+        do fr_task_builder.spawn |move f| {\n             comm::send(ch, f());\n         }\n         match future::get(&option::unwrap(result)) {\n@@ -610,7 +612,7 @@ fn spawn(+f: fn~()) {\n      * This function is equivalent to `task().spawn(f)`.\n      */\n \n-    task().spawn(f)\n+    task().spawn(move f)\n }\n \n fn spawn_unlinked(+f: fn~()) {\n@@ -619,7 +621,7 @@ fn spawn_unlinked(+f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().unlinked().spawn(f)\n+    task().unlinked().spawn(move f)\n }\n \n fn spawn_supervised(+f: fn~()) {\n@@ -628,7 +630,7 @@ fn spawn_supervised(+f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().supervised().spawn(f)\n+    task().supervised().spawn(move f)\n }\n \n fn spawn_with<A:Send>(+arg: A, +f: fn~(+A)) {\n@@ -642,7 +644,7 @@ fn spawn_with<A:Send>(+arg: A, +f: fn~(+A)) {\n      * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n-    task().spawn_with(arg, f)\n+    task().spawn_with(move arg, move f)\n }\n \n fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n@@ -652,7 +654,7 @@ fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n      * This function is equivalent to `task().spawn_listener(f)`.\n      */\n \n-    task().spawn_listener(f)\n+    task().spawn_listener(move f)\n }\n \n fn spawn_conversation<A: Send, B: Send>\n@@ -664,7 +666,7 @@ fn spawn_conversation<A: Send, B: Send>\n      * This function is equivalent to `task().spawn_conversation(f)`.\n      */\n \n-    task().spawn_conversation(f)\n+    task().spawn_conversation(move f)\n }\n \n fn spawn_sched(mode: SchedMode, +f: fn~()) {\n@@ -681,7 +683,7 @@ fn spawn_sched(mode: SchedMode, +f: fn~()) {\n      * greater than zero.\n      */\n \n-    task().sched_mode(mode).spawn(f)\n+    task().sched_mode(mode).spawn(move f)\n }\n \n fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n@@ -692,7 +694,7 @@ fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    task().supervised().try(f)\n+    task().supervised().try(move f)\n }\n \n \n@@ -1054,7 +1056,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                     // Swap the list out here; the caller replaces us with it.\n                     let rest = util::replace(&mut nobe.ancestors,\n                                              AncestorList(None));\n-                    (Some(rest), need_unwind)\n+                    (Some(move rest), need_unwind)\n                 } else {\n                     (None, need_unwind)\n                 }\n@@ -1067,8 +1069,8 @@ fn each_ancestor(list:        &mut AncestorList,\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n-            *parent_group <- Some(tmp_arc);\n-            result\n+            *parent_group <- Some(move tmp_arc);\n+            move result\n         }\n     }\n }\n@@ -1145,7 +1147,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n         let group = option::unwrap(newstate);\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(group);\n+        *state = Some(move group);\n         true\n     } else {\n         false\n@@ -1160,7 +1162,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n         let group = option::unwrap(newstate);\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(group);\n+        *state = Some(move group);\n     }\n }\n \n@@ -1220,11 +1222,11 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             let mut members = new_taskset();\n             taskset_insert(&mut members, spawner);\n             let tasks =\n-                unsafe::exclusive(Some({ mut members:     members,\n+                unsafe::exclusive(Some({ mut members:     move members,\n                                          mut descendants: new_taskset() }));\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n-                @TCB(spawner, tasks, AncestorList(None), true, None);\n+                @TCB(spawner, move tasks, AncestorList(None), true, None);\n             unsafe { local_set(spawner, taskgroup_key!(), group); }\n             group\n         }\n@@ -1239,7 +1241,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         // Child's ancestors are spawner's ancestors.\n         let a = share_ancestors(&mut spawner_group.ancestors);\n         // Propagate main-ness.\n-        (g, a, spawner_group.is_main)\n+        (move g, move a, spawner_group.is_main)\n     } else {\n         // Child is in a separate group from spawner.\n         let g = unsafe::exclusive(Some({ mut members:     new_taskset(),\n@@ -1260,12 +1262,12 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             AncestorList(Some(unsafe::exclusive(\n                 { generation:       new_generation,\n                   mut parent_group: Some(spawner_group.tasks.clone()),\n-                  mut ancestors:    old_ancestors })))\n+                  mut ancestors:    move old_ancestors })))\n         } else {\n             // Child has no ancestors.\n             AncestorList(None)\n         };\n-        (g,a, false)\n+        (move g, move a, false)\n     };\n \n     fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n@@ -1277,8 +1279,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         if tmp.is_some() {\n             let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n-            **ancestors <- Some(ancestor_arc);\n-            AncestorList(Some(result))\n+            **ancestors <- Some(move ancestor_arc);\n+            AncestorList(Some(move result))\n         } else {\n             AncestorList(None)\n         }\n@@ -1290,7 +1292,7 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut Some((child_tg, ancestors, f));\n+        let child_data = ~mut Some((move child_tg, move ancestors, move f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -1308,9 +1310,8 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n                 Some(option::swap_unwrap(&mut opts.notify_chan))\n             };\n \n-            let child_wrapper =\n-                make_child_wrapper(new_task, child_tg, ancestors, is_main,\n-                                   notify_chan, f);\n+            let child_wrapper = make_child_wrapper(new_task, move child_tg,\n+                  move ancestors, is_main, move notify_chan, move f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(&fptr);\n \n@@ -1332,8 +1333,8 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n                           +ancestors: AncestorList, is_main: bool,\n                           +notify_chan: Option<Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n-        let child_data = ~mut Some((child_arc, ancestors));\n-        return fn~(move notify_chan) {\n+        let child_data = ~mut Some((move child_arc, move ancestors));\n+        return fn~(move notify_chan, move child_data, move f) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n             // Child task runs this code.\n@@ -1345,14 +1346,14 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n             let notifier = match notify_chan {\n                 Some(notify_chan_value) => {\n                     let moved_ncv = move_it!(notify_chan_value);\n-                    Some(AutoNotify(moved_ncv))\n+                    Some(AutoNotify(move moved_ncv))\n                 }\n                 _ => None\n             };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @TCB(child, child_arc, ancestors,\n-                                 is_main, notifier);\n+                let group = @TCB(child, move child_arc, move ancestors,\n+                                 is_main, move notifier);\n                 unsafe { local_set(child, taskgroup_key!(), group); }\n                 // Run the child's body.\n                 f();"}, {"sha": "e242f619ccd872a4a2a44178f6e7617ccb04cb6c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07ea73bdbc023f80efe809388ed9299ba76bcb8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a07ea73bdbc023f80efe809388ed9299ba76bcb8", "patch": "@@ -1799,7 +1799,7 @@ mod unsafe {\n             let mut box2 = None;\n             box2 <-> box;\n             rusti::move_val_init(*ptr::mut_offset(p, i),\n-                                 option::unwrap(move box2));\n+                                 option::unwrap(box2));\n         }\n     }\n "}]}