{"sha": "be0a11729e5226a758261ba4f095978ef2105837", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMGExMTcyOWU1MjI2YTc1ODI2MWJhNGYwOTU5NzhlZjIxMDU4Mzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T05:23:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:15:58Z"}, "message": "core: Inherit the specific numeric modules\n\nThis implements all traits inside of core::num for all the primitive types,\nremoving all the functionality from libstd. The std modules reexport all of the\nnecessary items from the core modules.", "tree": {"sha": "12a0f2df31415c7f6aa507d6c08c77466aa8ed54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12a0f2df31415c7f6aa507d6c08c77466aa8ed54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be0a11729e5226a758261ba4f095978ef2105837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be0a11729e5226a758261ba4f095978ef2105837", "html_url": "https://github.com/rust-lang/rust/commit/be0a11729e5226a758261ba4f095978ef2105837", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be0a11729e5226a758261ba4f095978ef2105837/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c302938866cbccdecdcd78b42bb46106fdfa28e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c302938866cbccdecdcd78b42bb46106fdfa28e", "html_url": "https://github.com/rust-lang/rust/commit/0c302938866cbccdecdcd78b42bb46106fdfa28e"}], "stats": {"total": 3331, "additions": 1825, "deletions": 1506}, "files": [{"sha": "ec19a312713be34436300443a9830c4e6939c034", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -21,6 +21,25 @@\n #![feature(globs, macro_rules, managed_boxes)]\n #![deny(missing_doc)]\n \n+#[path = \"num/float_macros.rs\"] mod float_macros;\n+#[path = \"num/int_macros.rs\"]   mod int_macros;\n+#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+\n+#[path = \"num/int.rs\"]  pub mod int;\n+#[path = \"num/i8.rs\"]   pub mod i8;\n+#[path = \"num/i16.rs\"]  pub mod i16;\n+#[path = \"num/i32.rs\"]  pub mod i32;\n+#[path = \"num/i64.rs\"]  pub mod i64;\n+\n+#[path = \"num/uint.rs\"] pub mod uint;\n+#[path = \"num/u8.rs\"]   pub mod u8;\n+#[path = \"num/u16.rs\"]  pub mod u16;\n+#[path = \"num/u32.rs\"]  pub mod u32;\n+#[path = \"num/u64.rs\"]  pub mod u64;\n+\n+#[path = \"num/f32.rs\"]   pub mod f32;\n+#[path = \"num/f64.rs\"]   pub mod f64;\n+\n pub mod num;\n \n /* Core modules for ownership management */"}, {"sha": "ac45f52e710587dcd716f667f7540d185ed1ff9f", "filename": "src/libcore/num/f32.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,224 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for 32-bits floats (`f32` type)\n+\n+use cmp::{Eq, Ord};\n+use default::Default;\n+use intrinsics;\n+use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+pub static RADIX: uint = 2u;\n+\n+pub static MANTISSA_DIGITS: uint = 24u;\n+pub static DIGITS: uint = 6u;\n+\n+pub static EPSILON: f32 = 1.19209290e-07_f32;\n+\n+/// Smallest finite f32 value\n+pub static MIN_VALUE: f32 = -3.40282347e+38_f32;\n+/// Smallest positive, normalized f32 value\n+pub static MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n+/// Largest finite f32 value\n+pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n+\n+pub static MIN_EXP: int = -125;\n+pub static MAX_EXP: int = 128;\n+\n+pub static MIN_10_EXP: int = -37;\n+pub static MAX_10_EXP: int = 38;\n+\n+pub static NAN: f32 = 0.0_f32/0.0_f32;\n+pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+\n+/// Various useful constants.\n+pub mod consts {\n+    // FIXME: replace with mathematical constants from cmath.\n+\n+    // FIXME(#5527): These constants should be deprecated once associated\n+    // constants are implemented in favour of referencing the respective members\n+    // of `Float`.\n+\n+    /// Archimedes' constant\n+    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n+\n+    /// pi * 2.0\n+    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n+\n+    /// pi/2.0\n+    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n+\n+    /// pi/3.0\n+    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n+\n+    /// pi/4.0\n+    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n+\n+    /// pi/6.0\n+    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n+\n+    /// 1.0/pi\n+    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n+\n+    /// 2.0/pi\n+    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n+\n+    /// 2.0/sqrt(pi)\n+    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n+\n+    /// sqrt(2.0)\n+    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n+\n+    /// 1.0/sqrt(2.0)\n+    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n+\n+    /// Euler's number\n+    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n+\n+    /// log2(e)\n+    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n+\n+    /// log10(e)\n+    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n+\n+    /// ln(2.0)\n+    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n+\n+    /// ln(10.0)\n+    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n+}\n+\n+impl Ord for f32 {\n+    #[inline]\n+    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n+    #[inline]\n+    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n+    #[inline]\n+    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n+    #[inline]\n+    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n+}\n+impl Eq for f32 {\n+    #[inline]\n+    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n+}\n+\n+impl Num for f32 {}\n+\n+impl Default for f32 {\n+    #[inline]\n+    fn default() -> f32 { 0.0 }\n+}\n+\n+impl Primitive for f32 {}\n+\n+impl Zero for f32 {\n+    #[inline]\n+    fn zero() -> f32 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n+}\n+\n+impl One for f32 {\n+    #[inline]\n+    fn one() -> f32 { 1.0 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<f32,f32> for f32 {\n+    #[inline]\n+    fn add(&self, other: &f32) -> f32 { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<f32,f32> for f32 {\n+    #[inline]\n+    fn sub(&self, other: &f32) -> f32 { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<f32,f32> for f32 {\n+    #[inline]\n+    fn mul(&self, other: &f32) -> f32 { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<f32,f32> for f32 {\n+    #[inline]\n+    fn div(&self, other: &f32) -> f32 { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<f32,f32> for f32 {\n+    #[inline]\n+    fn rem(&self, other: &f32) -> f32 {\n+        extern { fn fmodf(a: f32, b: f32) -> f32; }\n+        unsafe { fmodf(*self, *other) }\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<f32> for f32 {\n+    #[inline]\n+    fn neg(&self) -> f32 { -*self }\n+}\n+\n+impl Signed for f32 {\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+    #[inline]\n+    fn abs(&self) -> f32 {\n+        unsafe { intrinsics::fabsf32(*self) }\n+    }\n+\n+    /// The positive difference of two numbers. Returns `0.0` if the number is\n+    /// less than or equal to `other`, otherwise the difference between`self`\n+    /// and `other` is returned.\n+    #[inline]\n+    fn abs_sub(&self, other: &f32) -> f32 {\n+        extern { fn fdimf(a: f32, b: f32) -> f32; }\n+        unsafe { fdimf(*self, *other) }\n+    }\n+\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n+    #[inline]\n+    fn signum(&self) -> f32 {\n+        if self != self { NAN } else {\n+            unsafe { intrinsics::copysignf32(1.0, *self) }\n+        }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n+}\n+\n+impl Bounded for f32 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n+    #[inline]\n+    fn min_value() -> f32 { -MAX_VALUE }\n+\n+    #[inline]\n+    fn max_value() -> f32 { MAX_VALUE }\n+}"}, {"sha": "f83ab510b7fd0919c74bb466459420cbe62dd408", "filename": "src/libcore/num/f64.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,224 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for 64-bits floats (`f64` type)\n+\n+use cmp::{Eq, Ord};\n+use default::Default;\n+use intrinsics;\n+use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+// FIXME(#5527): These constants should be deprecated once associated\n+// constants are implemented in favour of referencing the respective\n+// members of `Bounded` and `Float`.\n+\n+pub static RADIX: uint = 2u;\n+\n+pub static MANTISSA_DIGITS: uint = 53u;\n+pub static DIGITS: uint = 15u;\n+\n+pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n+\n+/// Smallest finite f64 value\n+pub static MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n+/// Smallest positive, normalized f64 value\n+pub static MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n+/// Largest finite f64 value\n+pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n+\n+pub static MIN_EXP: int = -1021;\n+pub static MAX_EXP: int = 1024;\n+\n+pub static MIN_10_EXP: int = -307;\n+pub static MAX_10_EXP: int = 308;\n+\n+pub static NAN: f64 = 0.0_f64/0.0_f64;\n+\n+pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n+\n+pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n+\n+/// Various useful constants.\n+pub mod consts {\n+    // FIXME: replace with mathematical constants from cmath.\n+\n+    // FIXME(#5527): These constants should be deprecated once associated\n+    // constants are implemented in favour of referencing the respective members\n+    // of `Float`.\n+\n+    /// Archimedes' constant\n+    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n+\n+    /// pi * 2.0\n+    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n+\n+    /// pi/2.0\n+    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n+\n+    /// pi/3.0\n+    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n+\n+    /// pi/4.0\n+    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n+\n+    /// pi/6.0\n+    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n+\n+    /// 1.0/pi\n+    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n+\n+    /// 2.0/pi\n+    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n+\n+    /// 2.0/sqrt(pi)\n+    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n+\n+    /// sqrt(2.0)\n+    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n+\n+    /// 1.0/sqrt(2.0)\n+    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n+\n+    /// Euler's number\n+    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n+\n+    /// log2(e)\n+    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n+\n+    /// log10(e)\n+    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n+\n+    /// ln(2.0)\n+    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n+\n+    /// ln(10.0)\n+    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n+}\n+\n+impl Ord for f64 {\n+    #[inline]\n+    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n+    #[inline]\n+    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n+    #[inline]\n+    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n+    #[inline]\n+    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n+}\n+impl Eq for f64 {\n+    #[inline]\n+    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n+}\n+\n+impl Default for f64 {\n+    #[inline]\n+    fn default() -> f64 { 0.0 }\n+}\n+\n+impl Primitive for f64 {}\n+\n+impl Num for f64 {}\n+\n+impl Zero for f64 {\n+    #[inline]\n+    fn zero() -> f64 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n+}\n+\n+impl One for f64 {\n+    #[inline]\n+    fn one() -> f64 { 1.0 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<f64,f64> for f64 {\n+    #[inline]\n+    fn add(&self, other: &f64) -> f64 { *self + *other }\n+}\n+#[cfg(not(test))]\n+impl Sub<f64,f64> for f64 {\n+    #[inline]\n+    fn sub(&self, other: &f64) -> f64 { *self - *other }\n+}\n+#[cfg(not(test))]\n+impl Mul<f64,f64> for f64 {\n+    #[inline]\n+    fn mul(&self, other: &f64) -> f64 { *self * *other }\n+}\n+#[cfg(not(test))]\n+impl Div<f64,f64> for f64 {\n+    #[inline]\n+    fn div(&self, other: &f64) -> f64 { *self / *other }\n+}\n+#[cfg(not(test))]\n+impl Rem<f64,f64> for f64 {\n+    #[inline]\n+    fn rem(&self, other: &f64) -> f64 {\n+        extern { fn fmod(a: f64, b: f64) -> f64; }\n+        unsafe { fmod(*self, *other) }\n+    }\n+}\n+#[cfg(not(test))]\n+impl Neg<f64> for f64 {\n+    #[inline]\n+    fn neg(&self) -> f64 { -*self }\n+}\n+\n+impl Signed for f64 {\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+    #[inline]\n+    fn abs(&self) -> f64 {\n+        unsafe { intrinsics::fabsf64(*self) }\n+    }\n+\n+    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    #[inline]\n+    fn abs_sub(&self, other: &f64) -> f64 {\n+        extern { fn fdim(a: f64, b: f64) -> f64; }\n+        unsafe { fdim(*self, *other) }\n+    }\n+\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n+    #[inline]\n+    fn signum(&self) -> f64 {\n+        if self != self { NAN } else {\n+            unsafe { intrinsics::copysignf64(1.0, *self) }\n+        }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n+}\n+\n+impl Bounded for f64 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n+    #[inline]\n+    fn min_value() -> f64 { -MAX_VALUE }\n+\n+    #[inline]\n+    fn max_value() -> f64 { MAX_VALUE }\n+}"}, {"sha": "3e403219a4fbaffdc207d8c2015ba88431a4e67f", "filename": "src/libcore/num/float_macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! assert_approx_eq(\n+    ($a:expr, $b:expr) => ({\n+        let (a, b) = (&$a, &$b);\n+        assert!((*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\", *a, *b);\n+    })\n+)"}, {"sha": "63ad3bf7d90565f2dce8de2c76c3b8c886541118", "filename": "src/libcore/num/i16.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 16-bits integers (`i16` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Option, Some, None};\n+\n+int_module!(i16, 16)\n+\n+impl Bitwise for i16 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n+}\n+\n+impl CheckedAdd for i16 {\n+    #[inline]\n+    fn checked_add(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "25f11be459e1d135e777cf0fcfe5b86ff4a729b2", "filename": "src/libcore/num/i32.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 32-bits integers (`i32` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Option, Some, None};\n+\n+int_module!(i32, 32)\n+\n+impl Bitwise for i32 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n+}\n+\n+impl CheckedAdd for i32 {\n+    #[inline]\n+    fn checked_add(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "24585009a1bcf8e8ec78e4f6ef9b7925f712a59e", "filename": "src/libcore/num/i64.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 64-bits integers (`i64` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Option, Some, None};\n+\n+int_module!(i64, 64)\n+\n+impl Bitwise for i64 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n+\n+    /// Counts the number of trailing zeros.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n+}\n+\n+impl CheckedAdd for i64 {\n+    #[inline]\n+    fn checked_add(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "0d8b9541f7b250b90f250ac627a155e79b13918d", "filename": "src/libcore/num/i8.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 8-bits integers (`i8` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Option, Some, None};\n+\n+int_module!(i8, 8)\n+\n+impl Bitwise for i8 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n+}\n+\n+impl CheckedAdd for i8 {\n+    #[inline]\n+    fn checked_add(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "dacfe987d9039fc4d4268475d7aca232bd2a3a64", "filename": "src/libcore/num/int.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for architecture-sized signed integers (`int` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Option, Some, None};\n+\n+#[cfg(target_word_size = \"32\")] int_module!(int, 32)\n+#[cfg(target_word_size = \"64\")] int_module!(int, 64)\n+\n+#[cfg(target_word_size = \"32\")]\n+impl Bitwise for int {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl Bitwise for int {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}"}, {"sha": "fc134df9b9488573a217d90b0eae02a603087340", "filename": "src/libcore/num/int_macros.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! int_module (($T:ty, $bits:expr) => (\n+\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `mem::size_of` function.\n+pub static BITS : uint = $bits;\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `mem::size_of` function.\n+pub static BYTES : uint = ($bits / 8);\n+\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `Bounded::min_value` function.\n+pub static MIN: $T = (-1 as $T) << (BITS - 1);\n+// FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `Bounded::max_value` function.\n+pub static MAX: $T = !MIN;\n+\n+impl Ord for $T {\n+    #[inline]\n+    fn lt(&self, other: &$T) -> bool { *self < *other }\n+}\n+impl TotalEq for $T {}\n+impl Eq for $T {\n+    #[inline]\n+    fn eq(&self, other: &$T) -> bool { *self == *other }\n+}\n+impl TotalOrd for $T {\n+    #[inline]\n+    fn cmp(&self, other: &$T) -> Ordering {\n+        if *self < *other { Less }\n+        else if *self > *other { Greater }\n+        else { Equal }\n+    }\n+}\n+\n+impl Num for $T {}\n+\n+impl Zero for $T {\n+    #[inline]\n+    fn zero() -> $T { 0 }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0 }\n+}\n+\n+impl One for $T {\n+    #[inline]\n+    fn one() -> $T { 1 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<$T,$T> for $T {\n+    #[inline]\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<$T,$T> for $T {\n+    #[inline]\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<$T,$T> for $T {\n+    #[inline]\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<$T,$T> for $T {\n+    /// Integer division, truncated towards 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 /  3 ==  2);\n+    /// assert!( 8 / -3 == -2);\n+    /// assert!(-8 /  3 == -2);\n+    /// assert!(-8 / -3 ==  2);\n+    ///\n+    /// assert!( 1 /  2 ==  0);\n+    /// assert!( 1 / -2 ==  0);\n+    /// assert!(-1 /  2 ==  0);\n+    /// assert!(-1 / -2 ==  0);\n+    /// ~~~\n+    #[inline]\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<$T,$T> for $T {\n+    /// Returns the integer remainder after division, satisfying:\n+    ///\n+    /// ~~~\n+    /// # let n = 1;\n+    /// # let d = 2;\n+    /// assert!((n / d) * d + (n % d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 %  3 ==  2);\n+    /// assert!( 8 % -3 ==  2);\n+    /// assert!(-8 %  3 == -2);\n+    /// assert!(-8 % -3 == -2);\n+    ///\n+    /// assert!( 1 %  2 ==  1);\n+    /// assert!( 1 % -2 ==  1);\n+    /// assert!(-1 %  2 == -1);\n+    /// assert!(-1 % -2 == -1);\n+    /// ~~~\n+    #[inline]\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<$T> for $T {\n+    #[inline]\n+    fn neg(&self) -> $T { -*self }\n+}\n+\n+impl Signed for $T {\n+    /// Computes the absolute value\n+    #[inline]\n+    fn abs(&self) -> $T {\n+        if self.is_negative() { -*self } else { *self }\n+    }\n+\n+    ///\n+    /// The positive difference of two numbers. Returns `0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline]\n+    fn abs_sub(&self, other: &$T) -> $T {\n+        if *self <= *other { 0 } else { *self - *other }\n+    }\n+\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `0` if the number is zero\n+    /// - `1` if the number is positive\n+    /// - `-1` if the number is negative\n+    ///\n+    #[inline]\n+    fn signum(&self) -> $T {\n+        match *self {\n+            n if n > 0 =>  1,\n+            0          =>  0,\n+            _          => -1,\n+        }\n+    }\n+\n+    /// Returns true if the number is positive\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0 }\n+\n+    /// Returns true if the number is negative\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl BitOr<$T,$T> for $T {\n+    #[inline]\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitAnd<$T,$T> for $T {\n+    #[inline]\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitXor<$T,$T> for $T {\n+    #[inline]\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shl<$T,$T> for $T {\n+    #[inline]\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shr<$T,$T> for $T {\n+    #[inline]\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Not<$T> for $T {\n+    #[inline]\n+    fn not(&self) -> $T { !*self }\n+}\n+\n+impl Bounded for $T {\n+    #[inline]\n+    fn min_value() -> $T { MIN }\n+\n+    #[inline]\n+    fn max_value() -> $T { MAX }\n+}\n+\n+impl CheckedDiv for $T {\n+    #[inline]\n+    fn checked_div(&self, v: &$T) -> Option<$T> {\n+        if *v == 0 {\n+            None\n+        } else {\n+            Some(self / *v)\n+        }\n+    }\n+}\n+\n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n+impl Int for $T {}\n+\n+impl Primitive for $T {}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+\n+    use int;\n+    use i32;\n+    use num;\n+    use num::Bitwise;\n+    use num::CheckedDiv;\n+    use num::ToStrRadix;\n+    use str::StrSlice;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    pub fn test_abs() {\n+        assert_eq!((1 as $T).abs(), 1 as $T);\n+        assert_eq!((0 as $T).abs(), 0 as $T);\n+        assert_eq!((-1 as $T).abs(), 1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(0 as $T)), 1 as $T);\n+        assert_eq!((1 as $T).abs_sub(&(-1 as $T)), 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert_eq!((1 as $T).signum(), 1 as $T);\n+        assert_eq!((0 as $T).signum(), 0 as $T);\n+        assert_eq!((-0 as $T).signum(), 0 as $T);\n+        assert_eq!((-1 as $T).signum(), -1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!((1 as $T).is_positive());\n+        assert!(!(0 as $T).is_positive());\n+        assert!(!(-0 as $T).is_positive());\n+        assert!(!(-1 as $T).is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!(1 as $T).is_negative());\n+        assert!(!(0 as $T).is_negative());\n+        assert!(!(-0 as $T).is_negative());\n+        assert!((-1 as $T).is_negative());\n+    }\n+\n+    #[test]\n+    fn test_bitwise() {\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n+        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n+    }\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert_eq!((0b0101100 as $T).count_ones(), 3);\n+        assert_eq!((0b0100001 as $T).count_ones(), 2);\n+        assert_eq!((0b1111001 as $T).count_ones(), 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n+        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n+        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_signed_checked_div() {\n+        assert_eq!(10i.checked_div(&2), Some(5));\n+        assert_eq!(5i.checked_div(&0), None);\n+        assert_eq!(int::MIN.checked_div(&-1), None);\n+    }\n+}\n+\n+))"}, {"sha": "92afe4955a87fa5f02463df14f44910a4f301c1a", "filename": "src/libcore/num/u16.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 16-bits integers (`u16` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Some, None, Option};\n+\n+uint_module!(u16, i16, 16)\n+\n+impl CheckedAdd for u16 {\n+    #[inline]\n+    fn checked_add(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "2cac95e5c3b96ec49439b47dc169b418a8f4ca4a", "filename": "src/libcore/num/u32.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 32-bits integers (`u32` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Some, None, Option};\n+\n+uint_module!(u32, i32, 32)\n+\n+impl CheckedAdd for u32 {\n+    #[inline]\n+    fn checked_add(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "7b6498b5a697a8e6a97a42f53c6e9f4e58dbac67", "filename": "src/libcore/num/u64.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 64-bits integer (`u64` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Some, None, Option};\n+\n+uint_module!(u64, i64, 64)\n+\n+impl CheckedAdd for u64 {\n+    #[inline]\n+    fn checked_add(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "6916c0c9f32bfebc5ea6c6312b3d4f2ced46e13f", "filename": "src/libcore/num/u8.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 8-bits integers (`u8` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Some, None, Option};\n+\n+uint_module!(u8, i8, 8)\n+\n+impl CheckedAdd for u8 {\n+    #[inline]\n+    fn checked_add(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "40e4b8327dd92ebb827cfcb938f8dfd5efa9fd70", "filename": "src/libcore/num/uint.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for architecture-sized unsigned integers (`uint` type)\n+\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+use ops::{Shl, Shr, Not};\n+use option::{Some, None, Option};\n+\n+uint_module!(uint, int, ::int::BITS)\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}"}, {"sha": "3ef785a0462fc37fe35a7ce9337e35b6010467fb", "filename": "src/libcore/num/uint_macros.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n+\n+pub static BITS : uint = $bits;\n+pub static BYTES : uint = ($bits / 8);\n+\n+pub static MIN: $T = 0 as $T;\n+pub static MAX: $T = 0 as $T - 1 as $T;\n+\n+impl Ord for $T {\n+    #[inline]\n+    fn lt(&self, other: &$T) -> bool { *self < *other }\n+}\n+impl TotalEq for $T {}\n+impl Eq for $T {\n+    #[inline]\n+    fn eq(&self, other: &$T) -> bool { *self == *other }\n+}\n+impl TotalOrd for $T {\n+    #[inline]\n+    fn cmp(&self, other: &$T) -> Ordering {\n+        if *self < *other { Less }\n+        else if *self > *other { Greater }\n+        else { Equal }\n+    }\n+}\n+\n+impl Num for $T {}\n+\n+impl Zero for $T {\n+    #[inline]\n+    fn zero() -> $T { 0 }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0 }\n+}\n+\n+impl One for $T {\n+    #[inline]\n+    fn one() -> $T { 1 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<$T,$T> for $T {\n+    #[inline]\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<$T,$T> for $T {\n+    #[inline]\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<$T,$T> for $T {\n+    #[inline]\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<$T,$T> for $T {\n+    #[inline]\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<$T,$T> for $T {\n+    #[inline]\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<$T> for $T {\n+    #[inline]\n+    fn neg(&self) -> $T { -*self }\n+}\n+\n+impl Unsigned for $T {}\n+\n+#[cfg(not(test))]\n+impl BitOr<$T,$T> for $T {\n+    #[inline]\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitAnd<$T,$T> for $T {\n+    #[inline]\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitXor<$T,$T> for $T {\n+    #[inline]\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shl<$T,$T> for $T {\n+    #[inline]\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shr<$T,$T> for $T {\n+    #[inline]\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Not<$T> for $T {\n+    #[inline]\n+    fn not(&self) -> $T { !*self }\n+}\n+\n+impl Bounded for $T {\n+    #[inline]\n+    fn min_value() -> $T { MIN }\n+\n+    #[inline]\n+    fn max_value() -> $T { MAX }\n+}\n+\n+impl Bitwise for $T {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> $T {\n+        (*self as $T_SIGNED).count_ones() as $T\n+    }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).leading_zeros() as $T\n+    }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).trailing_zeros() as $T\n+    }\n+}\n+\n+impl CheckedDiv for $T {\n+    #[inline]\n+    fn checked_div(&self, v: &$T) -> Option<$T> {\n+        if *v == 0 {\n+            None\n+        } else {\n+            Some(self / *v)\n+        }\n+    }\n+}\n+\n+impl Int for $T {}\n+\n+impl Primitive for $T {}\n+\n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+\n+    use num;\n+    use num::CheckedDiv;\n+    use num::Bitwise;\n+    use num::ToStrRadix;\n+    use str::StrSlice;\n+    use u16;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert_eq!(MIN + MAX + 1, 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_bitwise() {\n+        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n+        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n+        assert_eq!(MAX - (0b1011 as $T), (0b1011 as $T).not());\n+    }\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert_eq!((0b0101100 as $T).count_ones(), 3);\n+        assert_eq!((0b0100001 as $T).count_ones(), 2);\n+        assert_eq!((0b1111001 as $T).count_ones(), 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n+        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n+        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_unsigned_checked_div() {\n+        assert_eq!(10u.checked_div(&2), Some(5));\n+        assert_eq!(5u.checked_div(&0), None);\n+    }\n+}\n+\n+))"}, {"sha": "ea248b6d40defeec278c2b1438211bfa4adb3bdc", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 211, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -16,14 +16,18 @@\n use prelude::*;\n \n use cast;\n-use default::Default;\n use from_str::FromStr;\n-use libc::{c_int};\n+use libc::c_int;\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{Zero, One, Bounded, strconv};\n+use num::strconv;\n use num;\n use intrinsics;\n \n+pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n+pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f32::consts;\n+\n #[allow(dead_code)]\n mod cmath {\n     use libc::{c_float, c_int};\n@@ -65,214 +69,6 @@ mod cmath {\n     }\n }\n \n-pub static RADIX: uint = 2u;\n-\n-pub static MANTISSA_DIGITS: uint = 24u;\n-pub static DIGITS: uint = 6u;\n-\n-pub static EPSILON: f32 = 1.19209290e-07_f32;\n-\n-/// Smallest finite f32 value\n-pub static MIN_VALUE: f32 = -3.40282347e+38_f32;\n-/// Smallest positive, normalized f32 value\n-pub static MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n-/// Largest finite f32 value\n-pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n-\n-pub static MIN_EXP: int = -125;\n-pub static MAX_EXP: int = 128;\n-\n-pub static MIN_10_EXP: int = -37;\n-pub static MAX_10_EXP: int = 38;\n-\n-pub static NAN: f32 = 0.0_f32/0.0_f32;\n-pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n-pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n-\n-/// Various useful constants.\n-pub mod consts {\n-    // FIXME: replace with mathematical constants from cmath.\n-\n-    // FIXME(#5527): These constants should be deprecated once associated\n-    // constants are implemented in favour of referencing the respective members\n-    // of `Float`.\n-\n-    /// Archimedes' constant\n-    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n-\n-    /// pi * 2.0\n-    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n-\n-    /// pi/2.0\n-    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n-\n-    /// pi/3.0\n-    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n-\n-    /// pi/4.0\n-    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n-\n-    /// pi/6.0\n-    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n-\n-    /// pi/8.0\n-    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n-\n-    /// 1.0/pi\n-    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n-\n-    /// 2.0/pi\n-    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n-\n-    /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n-\n-    /// sqrt(2.0)\n-    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n-\n-    /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n-\n-    /// Euler's number\n-    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n-\n-    /// log2(e)\n-    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n-\n-    /// log10(e)\n-    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n-\n-    /// ln(2.0)\n-    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n-\n-    /// ln(10.0)\n-    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n-}\n-\n-impl Num for f32 {}\n-\n-#[cfg(not(test))]\n-impl Eq for f32 {\n-    #[inline]\n-    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for f32 {\n-    #[inline]\n-    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n-}\n-\n-impl Default for f32 {\n-    #[inline]\n-    fn default() -> f32 { 0.0 }\n-}\n-\n-impl Zero for f32 {\n-    #[inline]\n-    fn zero() -> f32 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f32 {\n-    #[inline]\n-    fn one() -> f32 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f32,f32> for f32 {\n-    #[inline]\n-    fn add(&self, other: &f32) -> f32 { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<f32,f32> for f32 {\n-    #[inline]\n-    fn sub(&self, other: &f32) -> f32 { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<f32,f32> for f32 {\n-    #[inline]\n-    fn mul(&self, other: &f32) -> f32 { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<f32,f32> for f32 {\n-    #[inline]\n-    fn div(&self, other: &f32) -> f32 { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<f32,f32> for f32 {\n-    #[inline]\n-    fn rem(&self, other: &f32) -> f32 {\n-        unsafe { cmath::fmodf(*self, *other) }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<f32> for f32 {\n-    #[inline]\n-    fn neg(&self) -> f32 { -*self }\n-}\n-\n-impl Signed for f32 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f32 {\n-        unsafe { intrinsics::fabsf32(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is\n-    /// less than or equal to `other`, otherwise the difference between`self`\n-    /// and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 {\n-        unsafe { cmath::fdimf(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f32 {\n-        if self.is_nan() { NAN } else {\n-            unsafe { intrinsics::copysignf32(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f32 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f32 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f32 { MAX_VALUE }\n-}\n-\n-impl Primitive for f32 {}\n-\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "77171a00befef8438038dac1889d8fdf63622999", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 6, "deletions": 210, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -15,14 +15,18 @@\n use prelude::*;\n \n use cast;\n-use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{Zero, One, Bounded, strconv};\n+use num::{strconv};\n use num;\n use intrinsics;\n \n+pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n+pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f64::consts;\n+\n #[allow(dead_code)]\n mod cmath {\n     use libc::{c_double, c_int};\n@@ -73,214 +77,6 @@ mod cmath {\n     }\n }\n \n-// FIXME(#5527): These constants should be deprecated once associated\n-// constants are implemented in favour of referencing the respective\n-// members of `Bounded` and `Float`.\n-\n-pub static RADIX: uint = 2u;\n-\n-pub static MANTISSA_DIGITS: uint = 53u;\n-pub static DIGITS: uint = 15u;\n-\n-pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n-\n-/// Smallest finite f64 value\n-pub static MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n-/// Smallest positive, normalized f64 value\n-pub static MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n-/// Largest finite f64 value\n-pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n-\n-pub static MIN_EXP: int = -1021;\n-pub static MAX_EXP: int = 1024;\n-\n-pub static MIN_10_EXP: int = -307;\n-pub static MAX_10_EXP: int = 308;\n-\n-pub static NAN: f64 = 0.0_f64/0.0_f64;\n-\n-pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n-\n-pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n-\n-/// Various useful constants.\n-pub mod consts {\n-    // FIXME: replace with mathematical constants from cmath.\n-\n-    // FIXME(#5527): These constants should be deprecated once associated\n-    // constants are implemented in favour of referencing the respective members\n-    // of `Float`.\n-\n-    /// Archimedes' constant\n-    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n-\n-    /// pi * 2.0\n-    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n-\n-    /// pi/2.0\n-    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n-\n-    /// pi/3.0\n-    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n-\n-    /// pi/4.0\n-    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n-\n-    /// pi/6.0\n-    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n-\n-    /// pi/8.0\n-    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n-\n-    /// 1.0/pi\n-    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n-\n-    /// 2.0/pi\n-    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n-\n-    /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n-\n-    /// sqrt(2.0)\n-    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n-\n-    /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n-\n-    /// Euler's number\n-    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n-\n-    /// log2(e)\n-    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n-\n-    /// log10(e)\n-    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n-\n-    /// ln(2.0)\n-    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n-\n-    /// ln(10.0)\n-    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n-}\n-\n-impl Num for f64 {}\n-\n-#[cfg(not(test))]\n-impl Eq for f64 {\n-    #[inline]\n-    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for f64 {\n-    #[inline]\n-    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n-}\n-\n-impl Default for f64 {\n-    #[inline]\n-    fn default() -> f64 { 0.0 }\n-}\n-\n-impl Zero for f64 {\n-    #[inline]\n-    fn zero() -> f64 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f64 {\n-    #[inline]\n-    fn one() -> f64 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f64,f64> for f64 {\n-    #[inline]\n-    fn add(&self, other: &f64) -> f64 { *self + *other }\n-}\n-#[cfg(not(test))]\n-impl Sub<f64,f64> for f64 {\n-    #[inline]\n-    fn sub(&self, other: &f64) -> f64 { *self - *other }\n-}\n-#[cfg(not(test))]\n-impl Mul<f64,f64> for f64 {\n-    #[inline]\n-    fn mul(&self, other: &f64) -> f64 { *self * *other }\n-}\n-#[cfg(not(test))]\n-impl Div<f64,f64> for f64 {\n-    #[inline]\n-    fn div(&self, other: &f64) -> f64 { *self / *other }\n-}\n-#[cfg(not(test))]\n-impl Rem<f64,f64> for f64 {\n-    #[inline]\n-    fn rem(&self, other: &f64) -> f64 {\n-        unsafe { cmath::fmod(*self, *other) }\n-    }\n-}\n-#[cfg(not(test))]\n-impl Neg<f64> for f64 {\n-    #[inline]\n-    fn neg(&self) -> f64 { -*self }\n-}\n-\n-impl Signed for f64 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f64 {\n-        unsafe { intrinsics::fabsf64(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 {\n-        unsafe { cmath::fdim(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f64 {\n-        if self.is_nan() { NAN } else {\n-            unsafe { intrinsics::copysignf64(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f64 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f64 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f64 { MAX_VALUE }\n-}\n-\n-impl Primitive for f64 {}\n-\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "4bd2ba07634cacd291b895ddf069b8fe25b6ff45", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i16, 16)\n-\n-impl Bitwise for i16 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n-}\n-\n-impl CheckedAdd for i16 {\n-    #[inline]\n-    fn checked_add(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i16)"}, {"sha": "3c3acfae3c0f8757ddd80cfe68a237b06c2a976a", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i32, 32)\n-\n-impl Bitwise for i32 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n-}\n-\n-impl CheckedAdd for i32 {\n-    #[inline]\n-    fn checked_add(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i32)"}, {"sha": "ad0fe1c08ef04cd621f3873b4b83726bc6cf5a6d", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,64 +10,14 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-#[cfg(target_word_size = \"64\")]\n-use num::CheckedMul;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i64, 64)\n-\n-impl Bitwise for i64 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n-\n-    /// Counts the number of trailing zeros.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n-}\n-\n-impl CheckedAdd for i64 {\n-    #[inline]\n-    fn checked_add(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i64)"}, {"sha": "bd40a2c53b656b0f99fdc8af858c649f904eb7f6", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i8, 8)\n-\n-impl Bitwise for i8 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n-}\n-\n-impl CheckedAdd for i8 {\n-    #[inline]\n-    fn checked_add(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i8)"}, {"sha": "d9552ee33400ed5c898a126593009d1bb430beca", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 6, "deletions": 110, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,118 +10,14 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-#[cfg(target_word_size = \"32\")] int_module!(int, 32)\n-#[cfg(target_word_size = \"64\")] int_module!(int, 64)\n-\n-#[cfg(target_word_size = \"32\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n \n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n+pub use core::int::{BITS, BYTES, MIN, MAX};\n \n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n+int_module!(int)"}, {"sha": "8a7bea465851ac21ba122a8866a2855c7af7c7fc", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 307, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -11,226 +11,7 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! int_module (($T:ty, $bits:expr) => (\n-\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-pub static BITS : uint = $bits;\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-pub static BYTES : uint = ($bits / 8);\n-\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `Bounded::min_value` function.\n-pub static MIN: $T = (-1 as $T) << (BITS - 1);\n-// FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `Bounded::max_value` function.\n-pub static MAX: $T = !MIN;\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 || (*self == MIN && *v == -1) {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    /// Integer division, truncated towards 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 /  3 ==  2);\n-    /// assert!( 8 / -3 == -2);\n-    /// assert!(-8 /  3 == -2);\n-    /// assert!(-8 / -3 ==  2);\n-    ///\n-    /// assert!( 1 /  2 ==  0);\n-    /// assert!( 1 / -2 ==  0);\n-    /// assert!(-1 /  2 ==  0);\n-    /// assert!(-1 / -2 ==  0);\n-    /// ~~~\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    /// Returns the integer remainder after division, satisfying:\n-    ///\n-    /// ~~~\n-    /// # let n = 1;\n-    /// # let d = 2;\n-    /// assert!((n / d) * d + (n % d) == n)\n-    /// ~~~\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 %  3 ==  2);\n-    /// assert!( 8 % -3 ==  2);\n-    /// assert!(-8 %  3 == -2);\n-    /// assert!(-8 % -3 == -2);\n-    ///\n-    /// assert!( 1 %  2 ==  1);\n-    /// assert!( 1 % -2 ==  1);\n-    /// assert!(-1 %  2 == -1);\n-    /// assert!(-1 % -2 == -1);\n-    /// ~~~\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -*self }\n-}\n-\n-impl Signed for $T {\n-    /// Computes the absolute value\n-    #[inline]\n-    fn abs(&self) -> $T {\n-        if self.is_negative() { -*self } else { *self }\n-    }\n-\n-    ///\n-    /// The positive difference of two numbers. Returns `0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n-    #[inline]\n-    fn abs_sub(&self, other: &$T) -> $T {\n-        if *self <= *other { 0 } else { *self - *other }\n-    }\n-\n-    ///\n-    /// # Returns\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    ///\n-    #[inline]\n-    fn signum(&self) -> $T {\n-        match *self {\n-            n if n > 0 =>  1,\n-            0          =>  0,\n-            _          => -1,\n-        }\n-    }\n-\n-    /// Returns true if the number is positive\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0 }\n-\n-    /// Returns true if the number is negative\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0 }\n-}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl Int for $T {}\n-\n-impl Primitive for $T {}\n+macro_rules! int_module (($T:ty) => (\n \n // String conversion functions and impl str -> num\n \n@@ -296,7 +77,7 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = Vec::new();\n+        let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n         });\n@@ -311,89 +92,10 @@ mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use int;\n     use i32;\n-    use num;\n-    use num::Bitwise;\n-    use num::CheckedDiv;\n     use num::ToStrRadix;\n     use str::StrSlice;\n \n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!((1 as $T).abs(), 1 as $T);\n-        assert_eq!((0 as $T).abs(), 0 as $T);\n-        assert_eq!((-1 as $T).abs(), 1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(0 as $T)), 1 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(-1 as $T)), 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!((1 as $T).signum(), 1 as $T);\n-        assert_eq!((0 as $T).signum(), 0 as $T);\n-        assert_eq!((-0 as $T).signum(), 0 as $T);\n-        assert_eq!((-1 as $T).signum(), -1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!((1 as $T).is_positive());\n-        assert!(!(0 as $T).is_positive());\n-        assert!(!(-0 as $T).is_positive());\n-        assert!(!(-1 as $T).is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!(1 as $T).is_negative());\n-        assert!(!(0 as $T).is_negative());\n-        assert!(!(-0 as $T).is_negative());\n-        assert!((-1 as $T).is_negative());\n-    }\n-\n-    #[test]\n-    fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n-    }\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n-    }\n-\n     #[test]\n     fn test_from_str() {\n         assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n@@ -508,13 +210,6 @@ mod tests {\n         assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n         assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n     }\n-\n-    #[test]\n-    fn test_signed_checked_div() {\n-        assert_eq!(10i.checked_div(&2), Some(5));\n-        assert_eq!(5i.checked_div(&0), None);\n-        assert_eq!(int::MIN.checked_div(&-1), None);\n-    }\n }\n \n ))"}, {"sha": "dd6a838df9ba649521654bda13a0c51722dd8794", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u16, i16, 16)\n-\n-impl CheckedAdd for u16 {\n-    #[inline]\n-    fn checked_add(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u16)"}, {"sha": "bb05938969dee5bf60fd42fe0bd5f00f94b75e0c", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u32, i32, 32)\n-\n-impl CheckedAdd for u32 {\n-    #[inline]\n-    fn checked_add(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u32)"}, {"sha": "f38806e1527fd3b98ebcdcd13559033b8279d713", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 6, "deletions": 43, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,51 +10,14 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-#[cfg(target_word_size = \"64\")]\n-use num::CheckedMul;\n-use num::{CheckedAdd, CheckedSub};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u64, i64, 64)\n-\n-impl CheckedAdd for u64 {\n-    #[inline]\n-    fn checked_add(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u64)"}, {"sha": "87fed563a1535658ddb17ce97274b84ad5dac09d", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u8, i8, 8)\n-\n-impl CheckedAdd for u8 {\n-    #[inline]\n-    fn checked_add(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u8)"}, {"sha": "61ab97e86b87c25350772be94301a73560499ebb", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 6, "deletions": 77, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -10,85 +10,14 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(uint, int, ::int::BITS)\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n \n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n+pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n+uint_module!(uint)"}, {"sha": "3e64c17161368bcc1f387918f82d6327f71085a3", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 204, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0a11729e5226a758261ba4f095978ef2105837/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=be0a11729e5226a758261ba4f095978ef2105837", "patch": "@@ -12,140 +12,7 @@\n #![doc(hidden)]\n #![allow(unsigned_negate)]\n \n-macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n-\n-pub static BITS : uint = $bits;\n-pub static BYTES : uint = ($bits / 8);\n-\n-pub static MIN: $T = 0 as $T;\n-pub static MAX: $T = 0 as $T - 1 as $T;\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -*self }\n-}\n-\n-impl Unsigned for $T {}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl Int for $T {}\n+macro_rules! uint_module (($T:ty) => (\n \n // String conversion functions and impl str -> num\n \n@@ -211,7 +78,7 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = Vec::new();\n+        let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n         });\n@@ -221,78 +88,15 @@ impl ToStrRadix for $T {\n     }\n }\n \n-impl Primitive for $T {}\n-\n-impl Bitwise for $T {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> $T {\n-        (*self as $T_SIGNED).count_ones() as $T\n-    }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).leading_zeros() as $T\n-    }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).trailing_zeros() as $T\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use num;\n-    use num::CheckedDiv;\n-    use num::Bitwise;\n     use num::ToStrRadix;\n     use str::StrSlice;\n     use u16;\n \n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(MAX - (0b1011 as $T), (0b1011 as $T).not());\n-    }\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n-    }\n-\n     #[test]\n     pub fn test_to_str() {\n         assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n@@ -404,12 +208,6 @@ mod tests {\n     pub fn to_str_radix37() {\n         100u.to_str_radix(37u);\n     }\n-\n-    #[test]\n-    fn test_unsigned_checked_div() {\n-        assert_eq!(10u.checked_div(&2), Some(5));\n-        assert_eq!(5u.checked_div(&0), None);\n-    }\n }\n \n ))"}]}