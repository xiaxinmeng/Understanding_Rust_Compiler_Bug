{"sha": "dddfbe0441476cd366943fcf14f4896e6bb09851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZGZiZTA0NDE0NzZjZDM2Njk0M2ZjZjE0ZjQ4OTZlNmJiMDk4NTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T18:39:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:19Z"}, "message": "syntax: Remove derive(Rand)", "tree": {"sha": "d1b1d58eeaff4f461b908e70c8384cd12cdaf9e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1b1d58eeaff4f461b908e70c8384cd12cdaf9e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dddfbe0441476cd366943fcf14f4896e6bb09851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dddfbe0441476cd366943fcf14f4896e6bb09851", "html_url": "https://github.com/rust-lang/rust/commit/dddfbe0441476cd366943fcf14f4896e6bb09851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dddfbe0441476cd366943fcf14f4896e6bb09851/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adcd67272e6ebcca65028fe1c8bf20390e827e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/adcd67272e6ebcca65028fe1c8bf20390e827e07", "html_url": "https://github.com/rust-lang/rust/commit/adcd67272e6ebcca65028fe1c8bf20390e827e07"}], "stats": {"total": 178, "additions": 0, "deletions": 178}, "files": [{"sha": "65554efdd680f9229fc9332799295db930d63a6e", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dddfbe0441476cd366943fcf14f4896e6bb09851/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfbe0441476cd366943fcf14f4896e6bb09851/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=dddfbe0441476cd366943fcf14f4896e6bb09851", "patch": "@@ -61,7 +61,6 @@ pub mod clone;\n pub mod encodable;\n pub mod decodable;\n pub mod hash;\n-pub mod rand;\n pub mod show;\n pub mod default;\n pub mod primitive;\n@@ -168,8 +167,6 @@ derive_traits! {\n     \"PartialOrd\" => ord::expand_deriving_ord,\n     \"Ord\" => totalord::expand_deriving_totalord,\n \n-    \"Rand\" => rand::expand_deriving_rand,\n-\n     \"Debug\" => show::expand_deriving_show,\n \n     \"Default\" => default::expand_deriving_default,"}, {"sha": "631e5f979d9ee7a38a1cf426dbc141828fa0f6a3", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/adcd67272e6ebcca65028fe1c8bf20390e827e07/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adcd67272e6ebcca65028fe1c8bf20390e827e07/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=adcd67272e6ebcca65028fe1c8bf20390e827e07", "patch": "@@ -1,175 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use ptr::P;\n-\n-pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    cx.span_warn(span,\n-                 \"`#[derive(Rand)]` is deprecated in favour of `#[derive_Rand]` from \\\n-                  `rand_macros` on crates.io\");\n-\n-    if !cx.use_std {\n-        // FIXME(#21880): lift this requirement.\n-        cx.span_err(span, \"this trait cannot be derived with #![no_std]\");\n-        return;\n-    }\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path!(std::rand::Rand),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"rand\",\n-                generics: LifetimeBounds {\n-                    lifetimes: Vec::new(),\n-                    bounds: vec!((\"R\",\n-                                  vec!( path!(std::rand::Rng) ))),\n-                },\n-                explicit_self: None,\n-                args: vec!(\n-                    Ptr(box Literal(Path::new_local(\"R\")),\n-                        Borrowed(None, ast::MutMutable))\n-                ),\n-                ret_ty: Self_,\n-                attributes: Vec::new(),\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    rand_substructure(a, b, c)\n-                }))\n-            }\n-        ),\n-        associated_types: Vec::new(),\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let rng = match substr.nonself_args {\n-        [ref rng] => rng,\n-        _ => cx.bug(\"Incorrect number of arguments to `rand` in `derive(Rand)`\")\n-    };\n-    let rand_ident = vec!(\n-        cx.ident_of(\"std\"),\n-        cx.ident_of(\"rand\"),\n-        cx.ident_of(\"Rand\"),\n-        cx.ident_of(\"rand\")\n-    );\n-    let rand_call = |cx: &mut ExtCtxt, span| {\n-        cx.expr_call_global(span,\n-                            rand_ident.clone(),\n-                            vec!(rng.clone()))\n-    };\n-\n-    return match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            let path = cx.path_ident(trait_span, substr.type_ident);\n-            rand_thing(cx, trait_span, path, summary, rand_call)\n-        }\n-        StaticEnum(_, ref variants) => {\n-            if variants.is_empty() {\n-                cx.span_err(trait_span, \"`Rand` cannot be derived for enums with no variants\");\n-                // let compilation continue\n-                return cx.expr_usize(trait_span, 0);\n-            }\n-\n-            let variant_count = cx.expr_usize(trait_span, variants.len());\n-\n-            let rand_name = cx.path_all(trait_span,\n-                                        true,\n-                                        rand_ident.clone(),\n-                                        Vec::new(),\n-                                        Vec::new(),\n-                                        Vec::new());\n-            let rand_name = cx.expr_path(rand_name);\n-\n-            // ::rand::Rand::rand(rng)\n-            let rv_call = cx.expr_call(trait_span,\n-                                       rand_name,\n-                                       vec!(rng.clone()));\n-\n-            // need to specify the usize-ness of the random number\n-            let usize_ty = cx.ty_ident(trait_span, cx.ident_of(\"usize\"));\n-            let value_ident = cx.ident_of(\"__value\");\n-            let let_statement = cx.stmt_let_typed(trait_span,\n-                                                  false,\n-                                                  value_ident,\n-                                                  usize_ty,\n-                                                  rv_call);\n-\n-            // rand() % variants.len()\n-            let value_ref = cx.expr_ident(trait_span, value_ident);\n-            let rand_variant = cx.expr_binary(trait_span,\n-                                              ast::BiRem,\n-                                              value_ref,\n-                                              variant_count);\n-\n-            let mut arms = variants.iter().enumerate().map(|(i, &(ident, v_span, ref summary))| {\n-                let i_expr = cx.expr_usize(v_span, i);\n-                let pat = cx.pat_lit(v_span, i_expr);\n-\n-                let path = cx.path(v_span, vec![substr.type_ident, ident]);\n-                let thing = rand_thing(cx, v_span, path, summary, |cx, sp| rand_call(cx, sp));\n-                cx.arm(v_span, vec!( pat ), thing)\n-            }).collect::<Vec<ast::Arm> >();\n-\n-            // _ => {} at the end. Should never occur\n-            arms.push(cx.arm_unreachable(trait_span));\n-\n-            let match_expr = cx.expr_match(trait_span, rand_variant, arms);\n-\n-            let block = cx.block(trait_span, vec!( let_statement ), Some(match_expr));\n-            cx.expr_block(block)\n-        }\n-        _ => cx.bug(\"Non-static method in `derive(Rand)`\")\n-    };\n-\n-    fn rand_thing<F>(cx: &mut ExtCtxt,\n-                     trait_span: Span,\n-                     ctor_path: ast::Path,\n-                     summary: &StaticFields,\n-                     mut rand_call: F)\n-                     -> P<Expr> where\n-        F: FnMut(&mut ExtCtxt, Span) -> P<Expr>,\n-    {\n-        let path = cx.expr_path(ctor_path.clone());\n-        match *summary {\n-            Unnamed(ref fields) => {\n-                if fields.is_empty() {\n-                    path\n-                } else {\n-                    let exprs = fields.iter().map(|span| rand_call(cx, *span)).collect();\n-                    cx.expr_call(trait_span, path, exprs)\n-                }\n-            }\n-            Named(ref fields) => {\n-                let rand_fields = fields.iter().map(|&(ident, span)| {\n-                    let e = rand_call(cx, span);\n-                    cx.field_imm(span, ident, e)\n-                }).collect();\n-                cx.expr_struct(trait_span, ctor_path, rand_fields)\n-            }\n-        }\n-    }\n-}"}]}