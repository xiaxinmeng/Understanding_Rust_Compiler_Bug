{"sha": "852073a7d2fc90597fa0369ce86611ed23f7e85d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MjA3M2E3ZDJmYzkwNTk3ZmEwMzY5Y2U4NjYxMWVkMjNmN2U4NWQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-08-15T19:31:07Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:32Z"}, "message": "Deduplicate item bounds after normalization", "tree": {"sha": "ebbdb74f52d035e691601878549e81986e5d0d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebbdb74f52d035e691601878549e81986e5d0d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/852073a7d2fc90597fa0369ce86611ed23f7e85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/852073a7d2fc90597fa0369ce86611ed23f7e85d", "html_url": "https://github.com/rust-lang/rust/commit/852073a7d2fc90597fa0369ce86611ed23f7e85d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/852073a7d2fc90597fa0369ce86611ed23f7e85d/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42c97919cd5a7fe856865cfd1034dfe14206ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42c97919cd5a7fe856865cfd1034dfe14206ceb", "html_url": "https://github.com/rust-lang/rust/commit/e42c97919cd5a7fe856865cfd1034dfe14206ceb"}], "stats": {"total": 57, "additions": 40, "deletions": 17}, "files": [{"sha": "3b2cae0dbd5a2dcb3dacbab8202905129761779f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/852073a7d2fc90597fa0369ce86611ed23f7e85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852073a7d2fc90597fa0369ce86611ed23f7e85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=852073a7d2fc90597fa0369ce86611ed23f7e85d", "patch": "@@ -1192,19 +1192,35 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n         let bounds = tcx.item_bounds(def_id).subst(tcx, substs);\n \n+        // The bounds returned by `item_bounds` may contain duplicates after\n+        // normalization, so try to deduplicate when possible to avoid\n+        // unnecessary ambiguity.\n+        let mut distinct_normalized_bounds = FxHashSet::default();\n+\n         let matching_bounds = bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n                 if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n                     let bound = ty::Binder::bind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n-                        self.match_projection(\n+                        if let Ok(normalized_trait) = self.match_projection(\n                             obligation,\n                             bound,\n                             placeholder_trait_predicate.trait_ref,\n-                        )\n-                        .is_ok()\n+                        ) {\n+                            match normalized_trait {\n+                                None => true,\n+                                Some(normalized_trait)\n+                                    if distinct_normalized_bounds.insert(normalized_trait) =>\n+                                {\n+                                    true\n+                                }\n+                                _ => false,\n+                            }\n+                        } else {\n+                            false\n+                        }\n                     }) {\n                         return Some(idx);\n                     }\n@@ -1221,34 +1237,41 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         matching_bounds\n     }\n \n+    /// Equates the trait in `obligation` with trait bound. If the two traits\n+    /// can be equated and the normalized trait bound doesn't contain inference\n+    /// variables or placeholders, the normalized bound is returned.\n     fn match_projection(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         placeholder_trait_ref: ty::TraitRef<'tcx>,\n-    ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n+    ) -> Result<Option<ty::PolyTraitRef<'tcx>>, ()> {\n         debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());\n         if placeholder_trait_ref.def_id != trait_bound.def_id() {\n             // Avoid unnecessary normalization\n             return Err(());\n         }\n \n-        let Normalized { value: trait_bound, obligations: mut nested_obligations } =\n-            ensure_sufficient_stack(|| {\n-                project::normalize_with_depth(\n-                    self,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.recursion_depth + 1,\n-                    &trait_bound,\n-                )\n-            });\n+        let Normalized { value: trait_bound, obligations: _ } = ensure_sufficient_stack(|| {\n+            project::normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_bound,\n+            )\n+        });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n-            .map(|InferOk { obligations, .. }| {\n-                nested_obligations.extend(obligations);\n-                nested_obligations\n+            .map(|InferOk { obligations: _, value: () }| {\n+                // This method is called within a probe, so we can't have\n+                // inference variables and placeholders escape.\n+                if !trait_bound.needs_infer() && !trait_bound.has_placeholders() {\n+                    Some(trait_bound)\n+                } else {\n+                    None\n+                }\n             })\n             .map_err(|_| ())\n     }"}]}