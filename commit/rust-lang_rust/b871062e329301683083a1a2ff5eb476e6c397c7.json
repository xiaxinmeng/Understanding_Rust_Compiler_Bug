{"sha": "b871062e329301683083a1a2ff5eb476e6c397c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NzEwNjJlMzI5MzAxNjgzMDgzYTFhMmZmNWViNDc2ZTZjMzk3Yzc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T17:43:37Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T17:43:37Z"}, "message": "remove Cancelable from Ty", "tree": {"sha": "79ce5dbafb59a042862ee91fdc8b89908da62644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ce5dbafb59a042862ee91fdc8b89908da62644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b871062e329301683083a1a2ff5eb476e6c397c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b871062e329301683083a1a2ff5eb476e6c397c7", "html_url": "https://github.com/rust-lang/rust/commit/b871062e329301683083a1a2ff5eb476e6c397c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b871062e329301683083a1a2ff5eb476e6c397c7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05ed6c548a7672e2c9472276a652c374a5d2a212", "url": "https://api.github.com/repos/rust-lang/rust/commits/05ed6c548a7672e2c9472276a652c374a5d2a212", "html_url": "https://github.com/rust-lang/rust/commit/05ed6c548a7672e2c9472276a652c374a5d2a212"}], "stats": {"total": 128, "additions": 57, "deletions": 71}, "files": [{"sha": "d87fe70493ae0453f2ba87141e1fcdbb035307f7", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -1,6 +1,5 @@\n use std::sync::Arc;\n \n-use ra_db::Cancelable;\n use ra_syntax::{\n     SyntaxNode,\n     ast::{self, NameOwner, StructFlavor, AstNode}\n@@ -18,8 +17,8 @@ impl Struct {\n         Struct { def_id }\n     }\n \n-    pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n-        Ok(db.struct_data(self.def_id).variant_data.clone())\n+    pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n+        db.struct_data(self.def_id).variant_data.clone()\n     }\n }\n "}, {"sha": "d0c455d0a7087e78a326bba4401491caa3aa5fc6", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -160,7 +160,7 @@ impl StructField {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n-    pub fn ty(&self, db: &impl HirDatabase) -> Cancelable<Option<Ty>> {\n+    pub fn ty(&self, db: &impl HirDatabase) -> Option<Ty> {\n         db.type_for_field(self.struct_.def_id, self.name.clone())\n     }\n }"}, {"sha": "4a2b0b3dc4b15213e66c0fb685b93573bbdfacda", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -57,12 +57,12 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::ty::infer;\n     }\n \n-    fn type_for_def(def_id: DefId) -> Cancelable<Ty> {\n+    fn type_for_def(def_id: DefId) -> Ty {\n         type TypeForDefQuery;\n         use fn crate::ty::type_for_def;\n     }\n \n-    fn type_for_field(def_id: DefId, field: Name) -> Cancelable<Option<Ty>> {\n+    fn type_for_field(def_id: DefId, field: Name) -> Option<Ty> {\n         type TypeForFieldQuery;\n         use fn crate::ty::type_for_field;\n     }"}, {"sha": "37fc8643a13f4eed8aa065899cf6cd651a101299", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -271,36 +271,36 @@ impl Ty {\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         type_ref: &TypeRef,\n-    ) -> Cancelable<Self> {\n-        Ok(match type_ref {\n+    ) -> Self {\n+        match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n                     .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n-                    .collect::<Cancelable<Vec<_>>>()?;\n+                    .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path)?,\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(_inner) => Ty::Unknown, // TODO\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner)?;\n+                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n                     .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n-                    .collect::<Cancelable<Vec<_>>>()?;\n+                    .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n                     .expect(\"TypeRef::Fn should always have at least return type\");\n@@ -311,38 +311,36 @@ impl Ty {\n                 Ty::FnPtr(Arc::new(sig))\n             }\n             TypeRef::Error => Ty::Unknown,\n-        })\n+        }\n     }\n \n     pub(crate) fn from_hir_opt(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         type_ref: Option<&TypeRef>,\n-    ) -> Cancelable<Self> {\n-        type_ref\n-            .map(|t| Ty::from_hir(db, module, impl_block, t))\n-            .unwrap_or(Ok(Ty::Unknown))\n+    ) -> Self {\n+        type_ref.map_or(Ty::Unknown, |t| Ty::from_hir(db, module, impl_block, t))\n     }\n \n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n         path: &Path,\n-    ) -> Cancelable<Self> {\n+    ) -> Self {\n         if let Some(name) = path.as_ident() {\n             if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n-                return Ok(Ty::Int(int_ty));\n+                return Ty::Int(int_ty);\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n-                return Ok(Ty::Float(float_ty));\n+                return Ty::Float(float_ty);\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n-                    KnownName::Bool => return Ok(Ty::Bool),\n-                    KnownName::Char => return Ok(Ty::Char),\n-                    KnownName::Str => return Ok(Ty::Str),\n+                    KnownName::Bool => return Ty::Bool,\n+                    KnownName::Char => return Ty::Char,\n+                    KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n             }\n@@ -352,10 +350,9 @@ impl Ty {\n         let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n             r\n         } else {\n-            return Ok(Ty::Unknown);\n+            return Ty::Unknown;\n         };\n-        let ty = db.type_for_def(resolved)?;\n-        Ok(ty)\n+        db.type_for_def(resolved)\n     }\n \n     pub fn unit() -> Self {\n@@ -445,7 +442,7 @@ impl fmt::Display for Ty {\n \n /// Compute the declared type of a function. This should not need to look at the\n /// function body.\n-fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n+fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     let signature = f.signature(db);\n     let module = f.module(db);\n     let impl_block = f.impl_block(db);\n@@ -454,38 +451,38 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n         .params()\n         .iter()\n         .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n-        .collect::<Cancelable<Vec<_>>>()?;\n-    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type())?;\n+        .collect::<Vec<_>>();\n+    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type());\n     let sig = FnSig { input, output };\n-    Ok(Ty::FnPtr(Arc::new(sig)))\n+    Ty::FnPtr(Arc::new(sig))\n }\n \n-fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n-    Ok(Ty::Adt {\n+fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n+    Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n-    })\n+    }\n }\n \n-pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n-    Ok(Ty::Adt {\n+pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+    Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n-    })\n+    }\n }\n \n-pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Ty {\n     let enum_parent = ev.parent_enum(db);\n \n     type_for_enum(db, enum_parent)\n }\n \n-pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n     let def = def_id.resolve(db);\n     match def {\n         Def::Module(..) => {\n             log::debug!(\"trying to get type for module {:?}\", def_id);\n-            Ok(Ty::Unknown)\n+            Ty::Unknown\n         }\n         Def::Function(f) => type_for_fn(db, f),\n         Def::Struct(s) => type_for_struct(db, s),\n@@ -497,19 +494,15 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n                 def_id,\n                 def\n             );\n-            Ok(Ty::Unknown)\n+            Ty::Unknown\n         }\n     }\n }\n \n-pub(super) fn type_for_field(\n-    db: &impl HirDatabase,\n-    def_id: DefId,\n-    field: Name,\n-) -> Cancelable<Option<Ty>> {\n+pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n     let def = def_id.resolve(db);\n     let variant_data = match def {\n-        Def::Struct(s) => s.variant_data(db)?,\n+        Def::Struct(s) => s.variant_data(db),\n         Def::EnumVariant(ev) => ev.variant_data(db),\n         // TODO: unions\n         _ => panic!(\n@@ -519,13 +512,8 @@ pub(super) fn type_for_field(\n     };\n     let module = def_id.module(db);\n     let impl_block = def_id.impl_block(db);\n-    let type_ref = ctry!(variant_data.get_field_type_ref(&field));\n-    Ok(Some(Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &type_ref,\n-    )?))\n+    let type_ref = variant_data.get_field_type_ref(&field)?;\n+    Some(Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -702,7 +690,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+    fn make_ty(&self, type_ref: &TypeRef) -> Ty {\n         Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n     }\n \n@@ -861,7 +849,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         // resolve in module\n         let resolved = ctry!(self.module.resolve_path(self.db, &path).take_values());\n-        let ty = self.db.type_for_def(resolved)?;\n+        let ty = self.db.type_for_def(resolved);\n         let ty = self.insert_type_vars(ty);\n         Ok(Some(ty))\n     }\n@@ -879,11 +867,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         Ok(match def_id.resolve(self.db) {\n             Def::Struct(s) => {\n-                let ty = type_for_struct(self.db, s)?;\n+                let ty = type_for_struct(self.db, s);\n                 (ty, Some(def_id))\n             }\n             Def::EnumVariant(ev) => {\n-                let ty = type_for_enum_variant(self.db, ev)?;\n+                let ty = type_for_enum_variant(self.db, ev);\n                 (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n@@ -964,7 +952,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let method_ty = match resolved {\n                     Some(def_id) => {\n                         self.write_method_resolution(expr, def_id);\n-                        self.db.type_for_def(def_id)?\n+                        self.db.type_for_def(def_id)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -1024,7 +1012,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n-                            .type_for_field(def_id, field.name.clone())?\n+                            .type_for_field(def_id, field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n                     } else {\n                         Ty::Unknown\n@@ -1047,7 +1035,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             i.and_then(|i| fields.get(i).cloned()).map(Ok)\n                         }\n                         Ty::Adt { def_id, .. } => {\n-                            transpose(self.db.type_for_field(def_id, name.clone()))\n+                            transpose(Ok(self.db.type_for_field(def_id, name.clone())))\n                         }\n                         _ => None,\n                     })\n@@ -1061,7 +1049,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 let cast_ty =\n-                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)?;\n+                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref);\n                 let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO check the cast...\n                 cast_ty\n@@ -1154,7 +1142,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         &self.module,\n                         self.impl_block.as_ref(),\n                         type_ref.as_ref(),\n-                    )?;\n+                    );\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n                         let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty))?;\n@@ -1181,12 +1169,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n-            let ty = self.make_ty(type_ref)?;\n+            let ty = self.make_ty(type_ref);\n             let ty = self.insert_type_vars(ty);\n             self.write_pat_ty(*pat, ty);\n         }\n         self.return_ty = {\n-            let ty = self.make_ty(signature.ret_type())?;\n+            let ty = self.make_ty(signature.ret_type());\n             let ty = self.insert_type_vars(ty);\n             ty\n         };"}, {"sha": "0676a989dd606689762874b48f1b8da309dd47bf", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -65,7 +65,7 @@ impl CrateImplBlocks {\n                 // ignore for now\n             } else {\n                 let target_ty =\n-                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type())?;\n+                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type());\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)"}, {"sha": "30a0a392471b289939d14b38bf7179dbd85a3aef", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b871062e329301683083a1a2ff5eb476e6c397c7/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=b871062e329301683083a1a2ff5eb476e6c397c7", "patch": "@@ -17,13 +17,13 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n     };\n     let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty.clone())?;\n+        complete_fields(acc, ctx, receiver_ty.clone());\n     }\n     complete_methods(acc, ctx, receiver_ty)?;\n     Ok(())\n }\n \n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n             Ty::Adt { def_id, .. } => {\n@@ -35,7 +35,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                                 field.name().to_string(),\n                             )\n                             .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db)?.map(|ty| ty.to_string()))\n+                            .set_detail(field.ty(ctx.db).map(|ty| ty.to_string()))\n                             .add_to(acc);\n                         }\n                     }\n@@ -53,7 +53,6 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n             _ => {}\n         };\n     }\n-    Ok(())\n }\n \n fn complete_methods("}]}