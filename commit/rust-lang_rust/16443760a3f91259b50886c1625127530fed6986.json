{"sha": "16443760a3f91259b50886c1625127530fed6986", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NDQzNzYwYTNmOTEyNTliNTA4ODZjMTYyNTEyNzUzMGZlZDY5ODY=", "commit": {"author": {"name": "Xavier Denis", "email": "xldenis@gmail.com", "date": "2020-11-11T12:03:44Z"}, "committer": {"name": "Xavier Denis", "email": "xldenis@gmail.com", "date": "2020-11-11T12:04:27Z"}, "message": "Reorder rustc_private loading", "tree": {"sha": "026f5f7671a5cdb48200fea08612c82a4e0b4825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026f5f7671a5cdb48200fea08612c82a4e0b4825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16443760a3f91259b50886c1625127530fed6986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16443760a3f91259b50886c1625127530fed6986", "html_url": "https://github.com/rust-lang/rust/commit/16443760a3f91259b50886c1625127530fed6986", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16443760a3f91259b50886c1625127530fed6986/comments", "author": {"login": "xldenis", "id": 451373, "node_id": "MDQ6VXNlcjQ1MTM3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/451373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xldenis", "html_url": "https://github.com/xldenis", "followers_url": "https://api.github.com/users/xldenis/followers", "following_url": "https://api.github.com/users/xldenis/following{/other_user}", "gists_url": "https://api.github.com/users/xldenis/gists{/gist_id}", "starred_url": "https://api.github.com/users/xldenis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xldenis/subscriptions", "organizations_url": "https://api.github.com/users/xldenis/orgs", "repos_url": "https://api.github.com/users/xldenis/repos", "events_url": "https://api.github.com/users/xldenis/events{/privacy}", "received_events_url": "https://api.github.com/users/xldenis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xldenis", "id": 451373, "node_id": "MDQ6VXNlcjQ1MTM3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/451373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xldenis", "html_url": "https://github.com/xldenis", "followers_url": "https://api.github.com/users/xldenis/followers", "following_url": "https://api.github.com/users/xldenis/following{/other_user}", "gists_url": "https://api.github.com/users/xldenis/gists{/gist_id}", "starred_url": "https://api.github.com/users/xldenis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xldenis/subscriptions", "organizations_url": "https://api.github.com/users/xldenis/orgs", "repos_url": "https://api.github.com/users/xldenis/repos", "events_url": "https://api.github.com/users/xldenis/events{/privacy}", "received_events_url": "https://api.github.com/users/xldenis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871608791934f81cdd430797fdd64a8f9da19074", "url": "https://api.github.com/repos/rust-lang/rust/commits/871608791934f81cdd430797fdd64a8f9da19074", "html_url": "https://github.com/rust-lang/rust/commit/871608791934f81cdd430797fdd64a8f9da19074"}], "stats": {"total": 173, "additions": 86, "deletions": 87}, "files": [{"sha": "8e1cee0d6a27cf5239512f71f64f44a683cf2627", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 86, "deletions": 87, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/16443760a3f91259b50886c1625127530fed6986/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16443760a3f91259b50886c1625127530fed6986/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=16443760a3f91259b50886c1625127530fed6986", "patch": "@@ -409,69 +409,6 @@ impl ProjectWorkspace {\n                 cfg_options.insert_atom(\"test\".into());\n                 cfg_options.insert_atom(\"debug_assertions\".into());\n \n-                let mut rustc_pkg_crates = FxHashMap::default();\n-\n-                // Add crate roots for rustc_private libs if a path to source is provided\n-                if let Some(rustc_workspace) = rustc {\n-                    for pkg in rustc_workspace.packages() {\n-                        for &tgt in rustc_workspace[pkg].targets.iter() {\n-                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                                continue;\n-                            }\n-                            // Exclude alloc / core / std\n-                            if rustc_workspace[tgt]\n-                                .root\n-                                .components()\n-                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                            {\n-                                continue;\n-                            }\n-\n-                            if let Some(crate_id) = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                &rustc_workspace[tgt],\n-                                &cfg_options,\n-                                proc_macro_client,\n-                                load,\n-                            ) {\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                                // Add dependencies on the core / std / alloc for rustc\n-                                for (name, krate) in public_deps.iter() {\n-                                    if let Err(_) =\n-                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n-                                    {\n-                                        log::error!(\n-                                            \"cyclic dependency on {} for {}\",\n-                                            name,\n-                                            &cargo[pkg].name\n-                                        )\n-                                    }\n-                                }\n-                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                            }\n-                        }\n-                    }\n-                    // Now add a dep edge from all targets of upstream to the lib\n-                    // target of downstream.\n-                    for pkg in rustc_workspace.packages() {\n-                        for dep in rustc_workspace[pkg].dependencies.iter() {\n-                            let name = CrateName::new(&dep.name).unwrap();\n-                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                        log::error!(\n-                                            \"cyclic dependency {} -> {}\",\n-                                            &rustc_workspace[pkg].name,\n-                                            &rustc_workspace[dep.pkg].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                };\n-\n                 let mut pkg_crates = FxHashMap::default();\n \n                 // Next, create crates for each package, target pair\n@@ -535,30 +472,6 @@ impl ProjectWorkspace {\n                     }\n                 }\n \n-                // If we have access to the rust sources, create dependencies onto rustc_private libraries from all targets\n-                // that are members of the current workspace\n-                if let Some(rustc_workspace) = rustc {\n-                    for dep in rustc_workspace.packages() {\n-                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                        if let Some(&from) = pkg_to_lib_crate.get(&dep) {\n-                            for pkg in cargo.packages() {\n-                                if !cargo[pkg].is_member {\n-                                    continue;\n-                                }\n-                                for &to in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(to, name.clone(), from) {\n-                                        log::error!(\n-                                            \"cyclic dependency22 {} -> {}\",\n-                                            &cargo[pkg].name,\n-                                            &rustc_workspace[dep].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n                 // Now add a dep edge from all targets of upstream to the lib\n                 // target of downstream.\n                 for pkg in cargo.packages() {\n@@ -577,6 +490,92 @@ impl ProjectWorkspace {\n                         }\n                     }\n                 }\n+\n+                let mut rustc_pkg_crates = FxHashMap::default();\n+\n+                // If the user provided a path to rustc sources, we add all the rustc_private crates\n+                // and create dependencies on them for the crates in the current workspace\n+                if let Some(rustc_workspace) = rustc {\n+                    for pkg in rustc_workspace.packages() {\n+                        for &tgt in rustc_workspace[pkg].targets.iter() {\n+                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                                continue;\n+                            }\n+                            // Exclude alloc / core / std\n+                            if rustc_workspace[tgt]\n+                                .root\n+                                .components()\n+                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                            {\n+                                continue;\n+                            }\n+\n+                            if let Some(crate_id) = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                &rustc_workspace[tgt],\n+                                &cfg_options,\n+                                proc_macro_client,\n+                                load,\n+                            ) {\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                                // Add dependencies on the core / std / alloc for rustc\n+                                for (name, krate) in public_deps.iter() {\n+                                    if let Err(_) =\n+                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n+                                    {\n+                                        log::error!(\n+                                            \"cyclic dependency on {} for {}\",\n+                                            name,\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                            }\n+                        }\n+                    }\n+                    // Now add a dep edge from all targets of upstream to the lib\n+                    // target of downstream.\n+                    for pkg in rustc_workspace.packages() {\n+                        for dep in rustc_workspace[pkg].dependencies.iter() {\n+                            let name = CrateName::new(&dep.name).unwrap();\n+                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &rustc_workspace[pkg].name,\n+                                            &rustc_workspace[dep.pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+                    for dep in rustc_workspace.packages() {\n+                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                            for pkg in cargo.packages() {\n+                                if !cargo[pkg].is_member {\n+                                    continue;\n+                                }\n+                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &cargo[pkg].name,\n+                                            &rustc_workspace[dep].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n         if crate_graph.patch_cfg_if() {"}]}