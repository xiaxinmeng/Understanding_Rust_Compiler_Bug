{"sha": "299d97b6d98cec673ff056c188ac45a17febc7d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OWQ5N2I2ZDk4Y2VjNjczZmYwNTZjMTg4YWM0NWExN2ZlYmM3ZDQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-24T15:01:32Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-25T18:03:55Z"}, "message": "Add handling `token` seperator in mbe", "tree": {"sha": "caec1cdbcd6350d26ebe984b3eca177079aa02b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caec1cdbcd6350d26ebe984b3eca177079aa02b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/299d97b6d98cec673ff056c188ac45a17febc7d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/299d97b6d98cec673ff056c188ac45a17febc7d4", "html_url": "https://github.com/rust-lang/rust/commit/299d97b6d98cec673ff056c188ac45a17febc7d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/299d97b6d98cec673ff056c188ac45a17febc7d4/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfab545d5df974d4a50325695a25f763b7613baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfab545d5df974d4a50325695a25f763b7613baf", "html_url": "https://github.com/rust-lang/rust/commit/dfab545d5df974d4a50325695a25f763b7613baf"}], "stats": {"total": 445, "additions": 219, "deletions": 226}, "files": [{"sha": "be574ca5397a23f77a3cd82436a65093f08e345f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -1063,6 +1063,7 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "1e5ed69079ffc9b222863e368a8a30b44f1028ad", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -10,3 +10,4 @@ ra_parser = { path = \"../ra_parser\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n itertools = \"0.8.0\"\n rustc-hash = \"1.0.0\"\n+smallvec = \"0.6.9\""}, {"sha": "7ebba807c582db1aecac53782c7a55fbe226fe7f", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 27, "deletions": 189, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -24,6 +24,7 @@ mod subtree_source;\n mod subtree_parser;\n \n use ra_syntax::SmolStr;\n+use smallvec::SmallVec;\n \n pub use tt::{Delimiter, Punct};\n \n@@ -98,11 +99,18 @@ pub(crate) struct Subtree {\n     pub(crate) token_trees: Vec<TokenTree>,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Separator {\n+    Literal(tt::Literal),\n+    Ident(tt::Ident),\n+    Puncts(SmallVec<[tt::Punct; 3]>),\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Repeat {\n     pub(crate) subtree: Subtree,\n     pub(crate) kind: RepeatKind,\n-    pub(crate) separator: Option<char>,\n+    pub(crate) separator: Option<Separator>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -175,8 +183,8 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         let expansion = rules.expand(&invocation_tt).unwrap();\n         assert_eq!(\n         expansion.to_string(),\n-        \"impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}} \\\n-         impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}}\"\n+        \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n+         impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n     )\n     }\n \n@@ -384,7 +392,7 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \"#,\n         );\n \n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar ()}\");\n+        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n     }\n \n     #[test]\n@@ -416,6 +424,18 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n     }\n \n+    #[test]\n+    fn test_match_group_with_multichar_sep() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );            \n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! (fn baz {true true} )\", \"fn baz () -> bool {true &&true}\");\n+    }\n+\n     #[test]\n     fn test_expand_to_item_list() {\n         let rules = create_rules(\n@@ -597,7 +617,7 @@ MACRO_ITEMS@[0; 40)\n         assert_expansion(\n             &rules,\n             \"foo! { bar::<u8>::baz::<u8> }\",\n-            \"fn foo () {let a = bar :: < u8 > :: baz :: < u8 > ;}\",\n+            \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n         );\n     }\n \n@@ -891,7 +911,7 @@ MACRO_ITEMS@[0; 40)\n         }\n \"#,\n         );\n-        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref < 'a > {s : & 'a str}\"#);\n+        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n     }\n \n     #[test]\n@@ -1063,7 +1083,7 @@ macro_rules! int_base {\n         );\n \n         assert_expansion(&rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n-        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt :: Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n         );\n     }\n \n@@ -1140,186 +1160,4 @@ impl_fn_for_zst !   {\n         assert_expansion(&rules, r#\"impl_nonzero_fmt ! { # [ stable ( feature = \"nonzero\" , since = \"1.28.0\" ) ] ( Debug , Display , Binary , Octal , LowerHex , UpperHex ) for NonZeroU8 }\"#, \n         \"fn foo () {}\");\n     }\n-\n-    #[test]\n-    fn test_tuple_impls() {\n-        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n-        let rules = create_rules(\n-            r#\"\n-    macro_rules! tuple_impls {\n-    ($(\n-        $Tuple:ident {\n-            $(($idx:tt) -> $T:ident)+\n-        }\n-    )+) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $(self.$idx == other.$idx)&&+\n-                }\n-                #[inline]\n-                fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $(self.$idx != other.$idx)||+\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n-                    where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                    lexical_partial_cmp!($(self.$idx, other.$idx),+)\n-                }\n-                #[inline]\n-                fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $(self.$idx, other.$idx),+)\n-                }\n-                #[inline]\n-                fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $(self.$idx, other.$idx),+)\n-                }\n-                #[inline]\n-                fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $(self.$idx, other.$idx),+)\n-                }\n-                #[inline]\n-                fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $(self.$idx, other.$idx),+)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n-                #[inline]\n-                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($(self.$idx, other.$idx),+)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Default),+> Default for ($($T,)+) {\n-                #[inline]\n-                fn default() -> ($($T,)+) {\n-                    ($({ let x: $T = Default::default(); x},)+)\n-                }\n-            }\n-        )+\n-    }\n-}\"#,\n-        );\n-\n-        assert_expansion(\n-            &rules,\n-            r#\"tuple_impls ! { \n-    Tuple1   { \n-         ( 0 )   ->   A \n-     } \n-     Tuple2   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-     } \n-     Tuple3   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-     } \n-     Tuple4   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-     } \n-     Tuple5   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-     } \n-     Tuple6   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-     } \n-     Tuple7   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-     } \n-     Tuple8   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-         ( 7 )   ->   H \n-     } \n-     Tuple9   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-         ( 7 )   ->   H \n-         ( 8 )   ->   I \n-     } \n-     Tuple10   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-         ( 7 )   ->   H \n-         ( 8 )   ->   I \n-         ( 9 )   ->   J \n-     } \n-     Tuple11   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-         ( 7 )   ->   H \n-         ( 8 )   ->   I \n-         ( 9 )   ->   J \n-         ( 10 )   ->   K \n-     } \n-     Tuple12   { \n-         ( 0 )   ->   A \n-         ( 1 )   ->   B \n-         ( 2 )   ->   C \n-         ( 3 )   ->   D \n-         ( 4 )   ->   E \n-         ( 5 )   ->   F \n-         ( 6 )   ->   G \n-         ( 7 )   ->   H \n-         ( 8 )   ->   I \n-         ( 9 )   ->   J \n-         ( 10 )   ->   K \n-         ( 11 )   ->   L \n-     } \n-}\"#,\n-            \"fn foo () {}\",\n-        );\n-    }\n }"}, {"sha": "7411dd8b19d4673235363c14609a0e619cbf4b2b", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -196,6 +196,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         \"literal\" => {\n                             let literal =\n                                 input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+\n                             res.inner.insert(\n                                 text.clone(),\n                                 Binding::Simple(tt::Leaf::from(literal).into()),\n@@ -210,7 +211,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     }\n                 }\n                 crate::Leaf::Punct(punct) => {\n-                    if input.eat_punct() != Some(punct) {\n+                    if !input.eat_punct().map(|p| p.char == punct.char).unwrap_or(false) {\n                         return Err(ExpandError::UnexpectedToken);\n                     }\n                 }\n@@ -246,8 +247,23 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                                 }\n                             }\n \n-                            if let Some(separator) = *separator {\n-                                if input.eat_punct().map(|p| p.char) != Some(separator) {\n+                            if let Some(separator) = separator {\n+                                use crate::Separator::*;\n+\n+                                if !input\n+                                    .eat_seperator()\n+                                    .map(|sep| match (sep, separator) {\n+                                        (Ident(ref a), Ident(ref b)) => a.text == b.text,\n+                                        (Literal(ref a), Literal(ref b)) => a.text == b.text,\n+                                        (Puncts(ref a), Puncts(ref b)) if a.len() == b.len() => {\n+                                            let a_iter = a.iter().map(|a| a.char);\n+                                            let b_iter = b.iter().map(|b| b.char);\n+                                            a_iter.eq(b_iter)\n+                                        }\n+                                        _ => false,\n+                                    })\n+                                    .unwrap_or(false)\n+                                {\n                                     input.rollback(memento);\n                                     break;\n                                 }\n@@ -328,7 +344,7 @@ fn expand_tt(\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n             let mut limit = 128;\n-            let mut has_sep = false;\n+            let mut has_seps = 0;\n \n             while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n                 limit -= 1;\n@@ -339,15 +355,28 @@ fn expand_tt(\n                 nesting.push(idx + 1);\n                 token_trees.push(reduce_single_token(t).into());\n \n-                if let Some(sep) = repeat.separator {\n-                    let punct =\n-                        tt::Leaf::from(tt::Punct { char: sep, spacing: tt::Spacing::Alone });\n-                    token_trees.push(punct.into());\n-                    has_sep = true;\n+                if let Some(ref sep) = repeat.separator {\n+                    match sep {\n+                        crate::Separator::Ident(ident) => {\n+                            has_seps = 1;\n+                            token_trees.push(tt::Leaf::from(ident.clone()).into());\n+                        }\n+                        crate::Separator::Literal(lit) => {\n+                            has_seps = 1;\n+                            token_trees.push(tt::Leaf::from(lit.clone()).into());\n+                        }\n+\n+                        crate::Separator::Puncts(puncts) => {\n+                            has_seps = puncts.len();\n+                            for punct in puncts {\n+                                token_trees.push(tt::Leaf::from(*punct).into());\n+                            }\n+                        }\n+                    }\n                 }\n             }\n             nesting.pop().unwrap();\n-            if has_sep {\n+            for _ in 0..has_seps {\n                 token_trees.pop();\n             }\n "}, {"sha": "c7ab463e2cd7dcd6ac0090063488a9c69572ea3b", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -74,18 +74,11 @@ fn parse_var(p: &mut TtCursor, transcriber: bool) -> Result<crate::Var, ParseErr\n     Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n-    let subtree = p.eat_subtree().unwrap();\n-    let mut subtree = parse_subtree(subtree, transcriber)?;\n-    subtree.delimiter = crate::Delimiter::None;\n-    let sep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n-    let (separator, rep) = match sep.char {\n-        '*' | '+' | '?' => (None, sep.char),\n-        char => {\n-            (Some(char), p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?.char)\n-        }\n-    };\n-\n+fn mk_repeat(\n+    rep: char,\n+    subtree: crate::Subtree,\n+    separator: Option<crate::Separator>,\n+) -> Result<crate::Repeat, ParseError> {\n     let kind = match rep {\n         '*' => crate::RepeatKind::ZeroOrMore,\n         '+' => crate::RepeatKind::OneOrMore,\n@@ -95,6 +88,27 @@ fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, Pa\n     Ok(crate::Repeat { subtree, kind, separator })\n }\n \n+fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n+    let subtree = p.eat_subtree().unwrap();\n+    let mut subtree = parse_subtree(subtree, transcriber)?;\n+    subtree.delimiter = crate::Delimiter::None;\n+\n+    if let Some(rep) = p.at_punct() {\n+        match rep.char {\n+            '*' | '+' | '?' => {\n+                p.bump();\n+                return mk_repeat(rep.char, subtree, None);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let sep = p.eat_seperator().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n+    let rep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"repeat\")))?;\n+\n+    mk_repeat(rep.char, subtree, Some(sep))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_syntax::{ast, AstNode};\n@@ -109,7 +123,7 @@ mod tests {\n         is_valid(\"($i:ident) => ()\");\n         expect_err(\"$i:ident => ()\", \"subtree\");\n         expect_err(\"($i:ident) ()\", \"`=`\");\n-        expect_err(\"($($i:ident)_) => ()\", \"separator\");\n+        expect_err(\"($($i:ident)_) => ()\", \"repeat\");\n     }\n \n     fn expect_err(macro_body: &str, expected: &str) {"}, {"sha": "e979777fea342741964fe09d0cb54aac8d491b9f", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -342,7 +342,7 @@ impl<'a> TokenSource for SubtreeTokenSource<'a> {\n     }\n }\n \n-struct TokenPeek<'a, I>\n+pub(crate) struct TokenPeek<'a, I>\n where\n     I: Iterator<Item = &'a tt::TokenTree>,\n {\n@@ -365,7 +365,7 @@ where\n         TokenPeek { iter: itertools::multipeek(iter) }\n     }\n \n-    fn current_punct2(&mut self, p: &tt::Punct) -> Option<((char, char), bool)> {\n+    pub fn current_punct2(&mut self, p: &tt::Punct) -> Option<((char, char), bool)> {\n         if p.spacing != tt::Spacing::Joint {\n             return None;\n         }\n@@ -375,7 +375,7 @@ where\n         Some(((p.char, p1.char), p1.spacing == tt::Spacing::Joint))\n     }\n \n-    fn current_punct3(&mut self, p: &tt::Punct) -> Option<((char, char, char), bool)> {\n+    pub fn current_punct3(&mut self, p: &tt::Punct) -> Option<((char, char, char), bool)> {\n         self.current_punct2(p).and_then(|((p0, p1), last_joint)| {\n             if !last_joint {\n                 None\n@@ -437,12 +437,16 @@ fn convert_delim(d: tt::Delimiter, closing: bool) -> TtToken {\n }\n \n fn convert_literal(l: &tt::Literal) -> TtToken {\n-    TtToken {\n-        kind: classify_literal(&l.text).unwrap().kind,\n-        is_joint_to_next: false,\n-        text: l.text.clone(),\n-        n_tokens: 1,\n-    }\n+    let kind = classify_literal(&l.text)\n+        .map(|tkn| tkn.kind)\n+        .or_else(|| match l.text.as_ref() {\n+            \"true\" => Some(SyntaxKind::TRUE_KW),\n+            \"false\" => Some(SyntaxKind::FALSE_KW),\n+            _ => None,\n+        })\n+        .unwrap();\n+\n+    TtToken { kind, is_joint_to_next: false, text: l.text.clone(), n_tokens: 1 }\n }\n \n fn convert_ident(ident: &tt::Ident) -> TtToken {"}, {"sha": "9cca19dbbef85466501d4707b402020701a01181", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -133,7 +133,9 @@ fn convert_tt(\n     };\n \n     let mut token_trees = Vec::new();\n-    for child in tt.children_with_tokens().skip(skip_first as usize) {\n+    let mut child_iter = tt.children_with_tokens().skip(skip_first as usize).peekable();\n+\n+    while let Some(child) = child_iter.next() {\n         if (skip_first && (child == first_child || child == last_child)) || child.kind().is_trivia()\n         {\n             continue;\n@@ -152,12 +154,25 @@ fn convert_tt(\n                         prev = Some(char)\n                     }\n                     if let Some(char) = prev {\n-                        token_trees.push(\n-                            tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Alone }).into(),\n-                        );\n+                        let spacing = match child_iter.peek() {\n+                            Some(SyntaxElement::Token(token)) => {\n+                                if token.kind().is_punct() {\n+                                    tt::Spacing::Joint\n+                                } else {\n+                                    tt::Spacing::Alone\n+                                }\n+                            }\n+                            _ => tt::Spacing::Alone,\n+                        };\n+\n+                        token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n                     }\n                 } else {\n-                    let child: tt::TokenTree = if token.kind().is_keyword()\n+                    let child: tt::TokenTree = if token.kind() == SyntaxKind::TRUE_KW\n+                        || token.kind() == SyntaxKind::FALSE_KW\n+                    {\n+                        tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n+                    } else if token.kind().is_keyword()\n                         || token.kind() == IDENT\n                         || token.kind() == LIFETIME\n                     {"}, {"sha": "3434164218c9dbd7af7931a778760d7dd67ad4f4", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/299d97b6d98cec673ff056c188ac45a17febc7d4/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=299d97b6d98cec673ff056c188ac45a17febc7d4", "patch": "@@ -1,5 +1,7 @@\n use crate::ParseError;\n use crate::subtree_parser::Parser;\n+use crate::subtree_source::TokenPeek;\n+use smallvec::{SmallVec, smallvec};\n \n #[derive(Clone)]\n pub(crate) struct TtCursor<'a> {\n@@ -162,6 +164,95 @@ impl<'a> TtCursor<'a> {\n         }\n     }\n \n+    fn eat_punct3(&mut self, p: &tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n+        let sec = self.eat_punct()?.clone();\n+        let third = self.eat_punct()?.clone();\n+        Some(smallvec![p.clone(), sec, third])\n+    }\n+\n+    fn eat_punct2(&mut self, p: &tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n+        let sec = self.eat_punct()?.clone();\n+        Some(smallvec![p.clone(), sec])\n+    }\n+\n+    fn eat_multi_char_punct<'b, I>(\n+        &mut self,\n+        p: &tt::Punct,\n+        iter: &mut TokenPeek<'b, I>,\n+    ) -> Option<SmallVec<[tt::Punct; 3]>>\n+    where\n+        I: Iterator<Item = &'b tt::TokenTree>,\n+    {\n+        if let Some((m, _)) = iter.current_punct3(p) {\n+            if let r @ Some(_) = match m {\n+                ('<', '<', '=') | ('>', '>', '=') | ('.', '.', '.') | ('.', '.', '=') => {\n+                    self.eat_punct3(p)\n+                }\n+                _ => None,\n+            } {\n+                return r;\n+            }\n+        }\n+\n+        if let Some((m, _)) = iter.current_punct2(p) {\n+            if let r @ Some(_) = match m {\n+                ('<', '=')\n+                | ('>', '=')\n+                | ('+', '=')\n+                | ('-', '=')\n+                | ('|', '=')\n+                | ('&', '=')\n+                | ('^', '=')\n+                | ('/', '=')\n+                | ('*', '=')\n+                | ('%', '=')\n+                | ('&', '&')\n+                | ('|', '|')\n+                | ('<', '<')\n+                | ('>', '>')\n+                | ('-', '>')\n+                | ('!', '=')\n+                | ('=', '>')\n+                | ('=', '=')\n+                | ('.', '.')\n+                | (':', ':') => self.eat_punct2(p),\n+\n+                _ => None,\n+            } {\n+                return r;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub(crate) fn eat_seperator(&mut self) -> Option<crate::Separator> {\n+        match self.eat()? {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n+                Some(crate::Separator::Literal(lit.clone()))\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                Some(crate::Separator::Ident(ident.clone()))\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n+                match punct.char {\n+                    '*' | '+' | '?' => return None,\n+                    _ => {}\n+                };\n+\n+                // FIXME: The parser is only handle some compositeable punct,\n+                // But at this phase, some punct still is jointed.\n+                // So we by pass that check here.\n+                let mut peekable = TokenPeek::new(self.subtree.token_trees[self.pos..].iter());\n+                let puncts = self.eat_multi_char_punct(punct, &mut peekable);\n+                let puncts = puncts.unwrap_or_else(|| smallvec![punct.clone()]);\n+\n+                Some(crate::Separator::Puncts(puncts))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     #[must_use]\n     pub(crate) fn save(&self) -> TtCursorMemento {\n         TtCursorMemento { pos: self.pos }"}]}