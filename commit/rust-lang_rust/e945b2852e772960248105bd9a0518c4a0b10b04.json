{"sha": "e945b2852e772960248105bd9a0518c4a0b10b04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NDViMjg1MmU3NzI5NjAyNDgxMDViZDlhMDUxOGM0YTBiMTBiMDQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-06T07:49:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-11T17:49:07Z"}, "message": "trans: pass essential information from trans_closure to debuginfo.", "tree": {"sha": "8eb610f5a657d5d0cfd252a104d0675ee5876c0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eb610f5a657d5d0cfd252a104d0675ee5876c0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e945b2852e772960248105bd9a0518c4a0b10b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e945b2852e772960248105bd9a0518c4a0b10b04", "html_url": "https://github.com/rust-lang/rust/commit/e945b2852e772960248105bd9a0518c4a0b10b04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e945b2852e772960248105bd9a0518c4a0b10b04/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a6e6a02bb5035c21b3d94fd8238b687bb52573", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a6e6a02bb5035c21b3d94fd8238b687bb52573", "html_url": "https://github.com/rust-lang/rust/commit/35a6e6a02bb5035c21b3d94fd8238b687bb52573"}], "stats": {"total": 386, "additions": 124, "deletions": 262}, "files": [{"sha": "f504a720cb5a3ebdad465363dcc86ef232fb8966", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e945b2852e772960248105bd9a0518c4a0b10b04", "patch": "@@ -1400,11 +1400,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               instance: Option<Instance<'tcx>>,\n+               definition: Option<(Instance<'tcx>,\n+                                   &ty::FnSig<'tcx>,\n+                                   Abi,\n+                                   &ty::Generics<'tcx>,\n+                                   Option<ast::Name>)>,\n                block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n-        let (param_substs, def_id) = match instance {\n-            Some(instance) => {\n+        let (param_substs, def_id) = match definition {\n+            Some((instance, _, _, _, _)) => {\n                 common::validate_substs(instance.substs);\n                 (instance.substs, Some(instance.def))\n             }\n@@ -1416,10 +1420,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n \n         debug!(\"FunctionContext::new({})\",\n-               instance.map_or(String::new(), |i| i.to_string()));\n-\n-        let debug_context = debuginfo::create_function_debug_context(ccx,\n-            inlined_id.unwrap_or(ast::DUMMY_NODE_ID), param_substs, llfndecl);\n+               definition.map_or(String::new(), |d| d.0.to_string()));\n \n         let cfg = inlined_id.map(|id| build_cfg(ccx.tcx(), id));\n         let nested_returns = if let Some((blk_id, Some(ref cfg))) = cfg {\n@@ -1431,10 +1432,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let check_attrs = |attrs: &[ast::Attribute]| {\n             let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n             let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n-            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n+            (default_to_mir ^ attrs.iter().any(|item| item.check_name(invert)),\n+             attrs.iter().any(|item| item.check_name(\"no_debug\")))\n         };\n \n-        let use_mir = if let Some(id) = local_id {\n+        let (use_mir, no_debug) = if let Some(id) = local_id {\n             check_attrs(ccx.tcx().map.attrs(id))\n         } else if let Some(def_id) = def_id {\n             check_attrs(&ccx.sess().cstore.item_attrs(def_id))\n@@ -1448,6 +1450,18 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             None\n         };\n \n+        let span = inlined_id.and_then(|id| ccx.tcx().map.opt_span(id));\n+\n+        let debug_context = if let (false, Some(definition)) = (no_debug, definition) {\n+            let (instance, sig, abi, generics, name) = definition;\n+            debuginfo::create_function_debug_context(ccx, instance, sig,\n+                                                     abi, generics, name,\n+                                                     span.unwrap_or(DUMMY_SP),\n+                                                     llfndecl)\n+        } else {\n+            debuginfo::empty_function_debug_context(ccx)\n+        };\n+\n         FunctionContext {\n             needs_ret_allocas: nested_returns && mir.is_none(),\n             mir: mir,\n@@ -1462,7 +1476,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n-            span: inlined_id.and_then(|id| ccx.tcx().map.opt_span(id)),\n+            span: span,\n             block_arena: block_arena,\n             lpad_arena: TypedArena::new(),\n             ccx: ccx,\n@@ -1815,8 +1829,10 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                llfndecl: ValueRef,\n                                instance: Instance<'tcx>,\n                                inlined_id: ast::NodeId,\n-                               fn_ty: FnType,\n+                               sig: &ty::FnSig<'tcx>,\n                                abi: Abi,\n+                               generics: &ty::Generics<'tcx>,\n+                               name: Option<ast::Name>,\n                                closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n@@ -1829,14 +1845,19 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"trans_closure(..., {})\", instance);\n \n+    let fn_ty = FnType::new(ccx, abi, sig, &[]);\n+\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, Some(instance), &arena);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty,\n+                               Some((instance, sig, abi, generics, name)), &arena);\n \n     if fcx.mir.is_some() {\n         return mir::trans_mir(&fcx);\n     }\n \n+    debuginfo::fill_scope_map_for_function(&fcx, decl, body, inlined_id);\n+\n     // cleanup scope for the incoming arguments\n     let fn_cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(\n         ccx, inlined_id, body.span, true);\n@@ -1891,10 +1912,8 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id, fn_cleanup_debug_loc.span);\n-\n     // Insert the mandatory first few basic blocks before lltop.\n-    fcx.finish(bcx, ret_debug_loc);\n+    fcx.finish(bcx, fn_cleanup_debug_loc.debug_loc());\n }\n \n /// Creates an LLVM function corresponding to a source language function.\n@@ -1907,25 +1926,27 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _s = StatRecorder::new(ccx, ccx.tcx().node_path_str(id));\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n-    let fn_ty = ccx.tcx().node_id_to_type(id);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n-    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let abi = fn_ty.fn_abi();\n-    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n     let def_id = if let Some(&def_id) = ccx.external_srcs().borrow().get(&id) {\n         def_id\n     } else {\n         ccx.tcx().map.local_def_id(id)\n     };\n+    let scheme = ccx.tcx().lookup_item_type(def_id);\n+    let fn_ty = scheme.ty;\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n+    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+    let abi = fn_ty.fn_abi();\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfndecl,\n                   Instance::new(def_id, param_substs),\n                   id,\n-                  fn_ty,\n+                  &sig,\n                   abi,\n+                  &scheme.generics,\n+                  Some(ccx.tcx().item_name(def_id)),\n                   closure::ClosureEnv::NotClosure);\n }\n "}, {"sha": "209f4b39319858212c2e22126030367c98f19d90", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=e945b2852e772960248105bd9a0518c4a0b10b04", "patch": "@@ -234,16 +234,21 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n         output: sig.output,\n         variadic: false\n     };\n-    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n+\n+    // This is not quite right. It should actually inherit\n+    // the generics of the enclosing function.\n+    let generics = ty::Generics::empty();\n \n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn,\n                   Instance::new(closure_def_id, param_substs),\n                   id,\n-                  fn_ty,\n+                  &sig,\n                   Abi::RustCall,\n+                  &generics,\n+                  None,\n                   ClosureEnv::Closure(closure_def_id, id));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate"}, {"sha": "cf7d98f2f0129cddefbf8197d91bbe0840578a9d", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 74, "deletions": 219, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e945b2852e772960248105bd9a0518c4a0b10b04", "patch": "@@ -14,8 +14,7 @@ mod doc;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n \n-use self::utils::{DIB, span_start, assert_type_for_node_id, contains_nodebug_attribute,\n-                  create_DIArray, is_node_local_to_unit};\n+use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::{namespace_for_item, NamespaceTreeNode};\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n@@ -25,20 +24,17 @@ use self::source_loc::InternalDebugLocation;\n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n-                      DIDescriptor, FlagPrototyped};\n+                      FlagPrototyped};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::normalize_associated_type;\n-use rustc::ty::subst::{self, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::hir;\n \n use abi::Abi;\n use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n-use monomorphize;\n-use rustc::infer;\n+use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n-use rustc::hir::map as hir_map;\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -49,7 +45,7 @@ use std::rc::Rc;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n use syntax::attr::IntType;\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token;\n \n pub mod gdb;\n mod utils;\n@@ -214,15 +210,31 @@ pub fn finalize(cx: &CrateContext) {\n     };\n }\n \n+/// Creates a function-specific debug context for a function w/o debuginfo.\n+pub fn empty_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>)\n+                                              -> FunctionDebugContext {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n+        return FunctionDebugContext::DebugInfoDisabled;\n+    }\n+\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+    FunctionDebugContext::FunctionWithoutDebugInfo\n+}\n+\n /// Creates the function-specific debug context.\n ///\n /// Returns the FunctionDebugContext for the function which holds state needed\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                               fn_ast_id: ast::NodeId,\n-                                               param_substs: &Substs<'tcx>,\n+                                               instance: Instance<'tcx>,\n+                                               sig: &ty::FnSig<'tcx>,\n+                                               abi: Abi,\n+                                               generics: &ty::Generics<'tcx>,\n+                                               name: Option<ast::Name>,\n+                                               span: Span,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n@@ -232,102 +244,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // Do this here already, in case we do an early exit from this function.\n     source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n \n-    if fn_ast_id == ast::DUMMY_NODE_ID {\n-        // This is a function not linked to any source location, so don't\n-        // generate debuginfo for it.\n-        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-    }\n-\n-    let empty_generics = hir::Generics::empty();\n-\n-    let fnitem = cx.tcx().map.get(fn_ast_id);\n-\n-    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n-        hir_map::NodeItem(ref item) => {\n-            if contains_nodebug_attribute(&item.attrs) {\n-                return FunctionDebugContext::FunctionWithoutDebugInfo;\n-            }\n-\n-            match item.node {\n-                hir::ItemFn(ref fn_decl, _, _, _, ref generics, ref top_level_block) => {\n-                    (item.name, fn_decl, generics, top_level_block, item.span, true)\n-                }\n-                _ => {\n-                    span_bug!(item.span,\n-                        \"create_function_debug_context: item bound to non-function\");\n-                }\n-            }\n-        }\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    if contains_nodebug_attribute(&impl_item.attrs) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-                    }\n-\n-                    (impl_item.name,\n-                     &sig.decl,\n-                     &sig.generics,\n-                     body,\n-                     impl_item.span,\n-                     true)\n-                }\n-                _ => {\n-                    span_bug!(impl_item.span,\n-                              \"create_function_debug_context() \\\n-                               called on non-method impl item?!\")\n-                }\n-            }\n-        }\n-        hir_map::NodeExpr(ref expr) => {\n-            match expr.node {\n-                hir::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n-                    let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::intern(&name[..]);\n-                    (name, fn_decl,\n-                        // This is not quite right. It should actually inherit\n-                        // the generics of the enclosing function.\n-                        &empty_generics,\n-                        top_level_block,\n-                        expr.span,\n-                        // Don't try to lookup the item path:\n-                        false)\n-                }\n-                _ => span_bug!(expr.span,\n-                        \"create_function_debug_context: expected an expr_fn_block here\")\n-            }\n-        }\n-        hir_map::NodeTraitItem(trait_item) => {\n-            match trait_item.node {\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    if contains_nodebug_attribute(&trait_item.attrs) {\n-                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n-                    }\n-\n-                    (trait_item.name,\n-                     &sig.decl,\n-                     &sig.generics,\n-                     body,\n-                     trait_item.span,\n-                     true)\n-                }\n-                _ => {\n-                    bug!(\"create_function_debug_context: \\\n-                          unexpected sort of node: {:?}\",\n-                         fnitem)\n-                }\n-            }\n-        }\n-        hir_map::NodeForeignItem(..) |\n-        hir_map::NodeVariant(..) |\n-        hir_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext::FunctionWithoutDebugInfo;\n-        }\n-        _ => bug!(\"create_function_debug_context: \\\n-                   unexpected sort of node: {:?}\",\n-                  fnitem)\n-    };\n-\n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n@@ -337,29 +253,28 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx,\n-                                                  fn_ast_id,\n-                                                  param_substs,\n-                                                  span);\n+        let fn_signature = get_function_signature(cx, sig, abi);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = name.to_string();\n+    let mut function_name = name.map(|name| name.to_string()).unwrap_or_else(|| {\n+        // We do this only for closures atm.\n+        format!(\"fn{}\", token::gensym(\"fn\"))\n+    });\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n-                                                      param_substs,\n+                                                      instance.substs,\n                                                       file_metadata,\n                                                       &mut function_name);\n \n     // There is no hir_map::Path for hir::ExprClosure-type functions. For now,\n     // just don't put them into a namespace. In the future this could be improved\n     // somehow (storing a path in the hir_map, or construct a path using the\n     // enclosing function).\n-    let (linkage_name, containing_scope) = if has_path {\n-        let fn_ast_def_id = cx.tcx().map.local_def_id(fn_ast_id);\n-        let namespace_node = namespace_for_item(cx, fn_ast_def_id);\n+    let (linkage_name, containing_scope) = if name.is_some() {\n+        let namespace_node = namespace_for_item(cx, instance.def);\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n             &function_name[..]);\n         let containing_scope = namespace_node.scope;\n@@ -368,11 +283,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         (function_name.clone(), file_metadata)\n     };\n \n-    // Clang sets this parameter to the opening brace of the function's block,\n-    // so let's do this too.\n-    let scope_line = span_start(cx, top_level_block.span).line;\n+    let scope_line = span_start(cx, span).line;\n \n-    let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n+    let local_id = cx.tcx().map.as_local_node_id(instance.def);\n+    let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(function_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n@@ -395,54 +309,24 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ptr::null_mut())\n     };\n \n-    let scope_map = create_scope_map::create_scope_map(cx,\n-                                                       &fn_decl.inputs,\n-                                                       &top_level_block,\n-                                                       fn_metadata,\n-                                                       fn_ast_id);\n-\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(scope_map),\n+        scope_map: RefCell::new(NodeMap()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n         source_location_override: Cell::new(false),\n     };\n \n-\n-\n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        fn_ast_id: ast::NodeId,\n-                                        param_substs: &Substs<'tcx>,\n-                                        error_reporting_span: Span) -> DIArray {\n+                                        sig: &ty::FnSig<'tcx>,\n+                                        abi: Abi) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n-        // Return type -- llvm::DIBuilder wants this at index 0\n-        assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n-        let fn_type = cx.tcx().node_id_to_type(fn_ast_id);\n-        let fn_type = monomorphize::apply_param_substs(cx.tcx(), param_substs, &fn_type);\n-\n-        let (sig, abi) = match fn_type.sty {\n-            ty::TyFnDef(_, _, ref barefnty) | ty::TyFnPtr(ref barefnty) => {\n-                let sig = cx.tcx().erase_late_bound_regions(&barefnty.sig);\n-                let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-                (sig, barefnty.abi)\n-            }\n-            ty::TyClosure(def_id, ref substs) => {\n-                let closure_type = cx.tcx().closure_type(def_id, substs);\n-                let sig = cx.tcx().erase_late_bound_regions(&closure_type.sig);\n-                let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-                (sig, closure_type.abi)\n-            }\n-\n-            _ => bug!(\"get_function_metdata: Expected a function type!\")\n-        };\n-\n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n@@ -477,86 +361,39 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         generics: &hir::Generics,\n+                                         generics: &ty::Generics<'tcx>,\n                                          param_substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n                                          -> DIArray\n     {\n-        let self_type = param_substs.self_ty();\n-        let self_type = normalize_associated_type(cx.tcx(), &self_type);\n-\n-        // Only true for static default methods:\n-        let has_self_type = self_type.is_some();\n+        let actual_types = param_substs.types.as_slice();\n \n-        if !generics.is_type_parameterized() && !has_self_type {\n+        if actual_types.is_empty() {\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n         name_to_append_suffix_to.push('<');\n-\n-        // The list to be filled with template parameters:\n-        let mut template_params: Vec<DIDescriptor> =\n-            Vec::with_capacity(generics.ty_params.len() + 1);\n-\n-        // Handle self type\n-        if has_self_type {\n-            let actual_self_type = self_type.unwrap();\n-            // Add self type name to <...> clause of function name\n-            let actual_self_type_name = compute_debuginfo_type_name(\n-                cx,\n-                actual_self_type,\n-                true);\n-\n-            name_to_append_suffix_to.push_str(&actual_self_type_name[..]);\n-\n-            if generics.is_type_parameterized() {\n-                name_to_append_suffix_to.push_str(\",\");\n-            }\n-\n-            // Only create type information if full debuginfo is enabled\n-            if cx.sess().opts.debuginfo == FullDebugInfo {\n-                let actual_self_type_metadata = type_metadata(cx,\n-                                                              actual_self_type,\n-                                                              codemap::DUMMY_SP);\n-\n-                let name = special_idents::type_self.name.as_str();\n-\n-                let name = CString::new(name.as_bytes()).unwrap();\n-                let param_metadata = unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        ptr::null_mut(),\n-                        name.as_ptr(),\n-                        actual_self_type_metadata,\n-                        file_metadata,\n-                        0,\n-                        0)\n-                };\n-\n-                template_params.push(param_metadata);\n-            }\n-        }\n-\n-        // Handle other generic parameters\n-        let actual_types = param_substs.types.get_slice(subst::FnSpace);\n-        for (index, &hir::TyParam{ name, .. }) in generics.ty_params.iter().enumerate() {\n-            let actual_type = actual_types[index];\n+        for (i, &actual_type) in actual_types.iter().enumerate() {\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n             name_to_append_suffix_to.push_str(&actual_type_name[..]);\n \n-            if index != generics.ty_params.len() - 1 {\n+            if i != actual_types.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n+        }\n+        name_to_append_suffix_to.push('>');\n \n-            // Again, only create type information if full debuginfo is enabled\n-            if cx.sess().opts.debuginfo == FullDebugInfo {\n+        // Again, only create type information if full debuginfo is enabled\n+        let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n+            generics.types.as_slice().iter().enumerate().map(|(i, param)| {\n+                let actual_type = actual_types[i];\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let name = CString::new(name.as_str().as_bytes()).unwrap();\n-                let param_metadata = unsafe {\n+                let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n+                unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n                         ptr::null_mut(),\n@@ -565,17 +402,35 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         file_metadata,\n                         0,\n                         0)\n-                };\n-                template_params.push(param_metadata);\n-            }\n-        }\n-\n-        name_to_append_suffix_to.push('>');\n+                }\n+            }).collect()\n+        } else {\n+            vec![]\n+        };\n \n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n }\n \n+/// Computes the scope map for a function given its declaration and body.\n+pub fn fill_scope_map_for_function<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                             fn_decl: &hir::FnDecl,\n+                                             top_level_block: &hir::Block,\n+                                             fn_ast_id: ast::NodeId) {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n+            let scope_map = create_scope_map::create_scope_map(fcx.ccx,\n+                                                               &fn_decl.inputs,\n+                                                               top_level_block,\n+                                                               data.fn_metadata,\n+                                                               fn_ast_id);\n+            *data.scope_map.borrow_mut() = scope_map;\n+        }\n+        FunctionDebugContext::DebugInfoDisabled |\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {}\n+    }\n+}\n+\n fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              variable_name: ast::Name,\n                              variable_type: Ty<'tcx>,"}, {"sha": "805cb67986c7455cdaa6225927cc146240e4fc02", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e945b2852e772960248105bd9a0518c4a0b10b04/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=e945b2852e772960248105bd9a0518c4a0b10b04", "patch": "@@ -44,16 +44,6 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n-    attributes.iter().any(|attr| {\n-        let meta_item: &ast::MetaItem = &attr.node.value;\n-        match meta_item.node {\n-            ast::MetaItemKind::Word(ref value) => &value[..] == \"no_debug\",\n-            _ => false\n-        }\n-    })\n-}\n-\n /// Return codemap::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo)\n@@ -87,15 +77,6 @@ pub fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     }\n }\n \n-pub fn assert_type_for_node_id(cx: &CrateContext,\n-                           node_id: ast::NodeId,\n-                           error_reporting_span: Span) {\n-    if !cx.tcx().node_types().contains_key(&node_id) {\n-        span_bug!(error_reporting_span,\n-                  \"debuginfo: Could not find type for node id!\");\n-    }\n-}\n-\n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;"}]}