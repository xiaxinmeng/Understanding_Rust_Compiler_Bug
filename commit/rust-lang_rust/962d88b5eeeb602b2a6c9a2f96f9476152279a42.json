{"sha": "962d88b5eeeb602b2a6c9a2f96f9476152279a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MmQ4OGI1ZWVlYjYwMmIyYTZjOWEyZjk2Zjk0NzYxNTIyNzlhNDI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-08T21:34:52Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-01-28T23:57:14Z"}, "message": "Fix the fallout", "tree": {"sha": "5825afa28f7c631e2f63b8f9ee9f6b0c30e6e257", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5825afa28f7c631e2f63b8f9ee9f6b0c30e6e257"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962d88b5eeeb602b2a6c9a2f96f9476152279a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962d88b5eeeb602b2a6c9a2f96f9476152279a42", "html_url": "https://github.com/rust-lang/rust/commit/962d88b5eeeb602b2a6c9a2f96f9476152279a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962d88b5eeeb602b2a6c9a2f96f9476152279a42/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18b96cf286e99ba61ff52fb916463466b2a63a67", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b96cf286e99ba61ff52fb916463466b2a63a67", "html_url": "https://github.com/rust-lang/rust/commit/18b96cf286e99ba61ff52fb916463466b2a63a67"}], "stats": {"total": 163, "additions": 63, "deletions": 100}, "files": [{"sha": "8506b1d75c5b97f2f6ff7c7cffdb6db3523ab7f6", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -119,7 +119,7 @@ E0450: r##\"\n A tuple constructor was invoked while some of its fields are private. Erroneous\n code example:\n \n-```compile_fail,E0450\n+```compile_fail\n mod Bar {\n     pub struct Foo(isize);\n }"}, {"sha": "c278171aa109a81120433777fafd9a4504dedb53", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -140,7 +140,7 @@ macro_rules! declare_keywords {(\n         $(\n             #[allow(non_upper_case_globals)]\n             pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+                ident: ast::Ident::with_empty_ctxt(super::Symbol($index))\n             };\n         )*\n     }\n@@ -282,25 +282,24 @@ impl Encodable for InternedString {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ast::Name;\n \n     #[test]\n     fn interner_tests() {\n         let mut i: Interner = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Name(0));\n+        assert_eq!(i.intern (\"dog\"), Symbol(0));\n         // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol(1));\n         // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Name(2));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(2));\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Name(3));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(3));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Name(4));\n+        assert_eq!(i.gensym(\"dog\"), Symbol(4));\n     }\n }"}, {"sha": "b9839edea2dc4e5b4e39e6423e53525341c60b61", "filename": "src/test/compile-fail-fulldeps/explore-issue-38412.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -25,21 +25,14 @@ use pub_and_stability::{Record, Trait, Tuple};\n fn main() {\n     // Okay\n     let Record { .. } = Record::new();\n-    // Okay (for now; see RFC Issue #902)\n-    let Tuple(..) = Tuple::new();\n \n     // Okay\n     let Record { a_stable_pub: _, a_unstable_declared_pub: _, .. } = Record::new();\n-    // Okay (for now; see RFC Issue #902)\n-    let Tuple(_, _, ..) = Tuple::new(); // analogous to above\n \n     let Record { a_stable_pub: _, a_unstable_declared_pub: _, a_unstable_undeclared_pub: _, .. } =\n         Record::new();\n     //~^^ ERROR use of unstable library feature 'unstable_undeclared'\n \n-    let Tuple(_, _, _, ..) = Tuple::new(); // analogous to previous\n-    //~^ ERROR use of unstable library feature 'unstable_undeclared'\n-\n     let r = Record::new();\n     let t = Tuple::new();\n "}, {"sha": "200b58a329344780be4b7610c1787fe6c7b589aa", "filename": "src/test/compile-fail/E0450.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18b96cf286e99ba61ff52fb916463466b2a63a67/src%2Ftest%2Fcompile-fail%2FE0450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b96cf286e99ba61ff52fb916463466b2a63a67/src%2Ftest%2Fcompile-fail%2FE0450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0450.rs?ref=18b96cf286e99ba61ff52fb916463466b2a63a67", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod Bar {\n-    pub struct Foo( bool, pub i32, f32, bool);\n-    //~^ NOTE private field declared here\n-    //~| NOTE private field declared here\n-    //~| NOTE private field declared here\n-}\n-\n-fn main() {\n-    let f = Bar::Foo(false,1,0.1, true); //~ ERROR E0450\n-                         //~^ NOTE cannot construct with a private field\n-}"}, {"sha": "ace96c9983e66612097228f6a949778e797cf0f0", "filename": "src/test/compile-fail/E0451.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2FE0451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2FE0451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0451.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -25,11 +25,6 @@ fn pat_match(foo: Bar::Foo) {\n                                   //~^ NOTE field `b` is private\n }\n \n-fn pat_match_tuple(foo: Bar::FooTuple) {\n-    let Bar::FooTuple(a,b) = foo; //~ ERROR E0451\n-                                  //~^ NOTE field `1` is private\n-}\n-\n fn main() {\n     let f = Bar::Foo{ a: 0, b: 0 }; //~ ERROR E0451\n                                     //~^ NOTE field `b` is private"}, {"sha": "b4feadbacf7404cc61d1b9cc91f54224eaa19ffd", "filename": "src/test/compile-fail/issue-38412.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     let Box(a) = loop { };\n-    //~^ ERROR field `0` of struct `std::boxed::Box` is private\n+    //~^ ERROR expected tuple struct/variant, found struct `Box`\n \n     // (The below is a trick to allow compiler to infer a type for\n     // variable `a` without attempting to ascribe a type to the"}, {"sha": "599c1f871604406bd3f6f99470b3078d073c2603", "filename": "src/test/compile-fail/privacy5.rs", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d88b5eeeb602b2a6c9a2f96f9476152279a42/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs?ref=962d88b5eeeb602b2a6c9a2f96f9476152279a42", "patch": "@@ -58,83 +58,80 @@ mod a {\n }\n \n fn this_crate() {\n-    let a = a::A(()); //~ ERROR: cannot invoke tuple struct constructor\n-    let b = a::B(2); //~ ERROR: cannot invoke tuple struct constructor\n-    let c = a::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let a = a::A(()); //~ ERROR tuple struct `A` is private\n+    let b = a::B(2); //~ ERROR tuple struct `B` is private\n+    let c = a::C(2, 3); //~ ERROR tuple struct `C` is private\n     let d = a::D(4);\n \n-    let a::A(()) = a; //~ ERROR: field `0` of struct `a::A` is private\n-    let a::A(_) = a;\n-    match a { a::A(()) => {} } //~ ERROR: field `0` of struct `a::A` is private\n-    match a { a::A(_) => {} }\n-\n-    let a::B(_) = b;\n-    let a::B(_b) = b; //~ ERROR: field `0` of struct `a::B` is private\n-    match b { a::B(_) => {} }\n-    match b { a::B(_b) => {} } //~ ERROR: field `0` of struct `a::B` is private\n-    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field `0` of struct `a::B` is private\n-\n-    let a::C(_, _) = c;\n-    let a::C(_a, _) = c;\n-    let a::C(_, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n-    let a::C(_a, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n-    match c { a::C(_, _) => {} }\n-    match c { a::C(_a, _) => {} }\n-    match c { a::C(_, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n-    match c { a::C(_a, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n+    let a::A(()) = a; //~ ERROR tuple struct `A` is private\n+    let a::A(_) = a; //~ ERROR tuple struct `A` is private\n+    match a { a::A(()) => {} } //~ ERROR tuple struct `A` is private\n+    match a { a::A(_) => {} } //~ ERROR tuple struct `A` is private\n+\n+    let a::B(_) = b; //~ ERROR tuple struct `B` is private\n+    let a::B(_b) = b; //~ ERROR tuple struct `B` is private\n+    match b { a::B(_) => {} } //~ ERROR tuple struct `B` is private\n+    match b { a::B(_b) => {} } //~ ERROR tuple struct `B` is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct `B` is private\n+                                            //~^ ERROR tuple struct `B` is private\n+\n+    let a::C(_, _) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n+    match c { a::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n \n     let a::D(_) = d;\n     let a::D(_d) = d;\n     match d { a::D(_) => {} }\n     match d { a::D(_d) => {} }\n     match d { a::D(1) => {} a::D(_) => {} }\n \n-    let a2 = a::A; //~ ERROR: cannot invoke tuple struct constructor\n-    let b2 = a::B; //~ ERROR: cannot invoke tuple struct constructor\n-    let c2 = a::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let a2 = a::A; //~ ERROR tuple struct `A` is private\n+    let b2 = a::B; //~ ERROR tuple struct `B` is private\n+    let c2 = a::C; //~ ERROR tuple struct `C` is private\n     let d2 = a::D;\n }\n \n fn xcrate() {\n-    let a = other::A(()); //~ ERROR: cannot invoke tuple struct constructor\n-    let b = other::B(2); //~ ERROR: cannot invoke tuple struct constructor\n-    let c = other::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let a = other::A(()); //~ ERROR tuple struct `A` is private\n+    let b = other::B(2); //~ ERROR tuple struct `B` is private\n+    let c = other::C(2, 3); //~ ERROR tuple struct `C` is private\n     let d = other::D(4);\n \n-    let other::A(()) = a; //~ ERROR: field `0` of struct `other::A` is private\n-    let other::A(_) = a;\n-    match a { other::A(()) => {} }\n-    //~^ ERROR: field `0` of struct `other::A` is private\n-    match a { other::A(_) => {} }\n-\n-    let other::B(_) = b;\n-    let other::B(_b) = b; //~ ERROR: field `0` of struct `other::B` is private\n-    match b { other::B(_) => {} }\n-    match b { other::B(_b) => {} }\n-    //~^ ERROR: field `0` of struct `other::B` is private\n-    match b { other::B(1) => {} other::B(_) => {} }\n-    //~^ ERROR: field `0` of struct `other::B` is private\n-\n-    let other::C(_, _) = c;\n-    let other::C(_a, _) = c;\n-    let other::C(_, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n-    let other::C(_a, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n-    match c { other::C(_, _) => {} }\n-    match c { other::C(_a, _) => {} }\n-    match c { other::C(_, _b) => {} }\n-    //~^ ERROR: field `1` of struct `other::C` is private\n-    match c { other::C(_a, _b) => {} }\n-    //~^ ERROR: field `1` of struct `other::C` is private\n+    let other::A(()) = a; //~ ERROR tuple struct `A` is private\n+    let other::A(_) = a; //~ ERROR tuple struct `A` is private\n+    match a { other::A(()) => {} } //~ ERROR tuple struct `A` is private\n+    match a { other::A(_) => {} } //~ ERROR tuple struct `A` is private\n+\n+    let other::B(_) = b; //~ ERROR tuple struct `B` is private\n+    let other::B(_b) = b; //~ ERROR tuple struct `B` is private\n+    match b { other::B(_) => {} } //~ ERROR tuple struct `B` is private\n+    match b { other::B(_b) => {} } //~ ERROR tuple struct `B` is private\n+    match b { other::B(1) => {} other::B(_) => {} } //~ ERROR tuple struct `B` is private\n+                                                    //~^ ERROR tuple struct `B` is private\n+\n+    let other::C(_, _) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n+    match c { other::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n \n     let other::D(_) = d;\n     let other::D(_d) = d;\n     match d { other::D(_) => {} }\n     match d { other::D(_d) => {} }\n     match d { other::D(1) => {} other::D(_) => {} }\n \n-    let a2 = other::A; //~ ERROR: cannot invoke tuple struct constructor\n-    let b2 = other::B; //~ ERROR: cannot invoke tuple struct constructor\n-    let c2 = other::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let a2 = other::A; //~ ERROR tuple struct `A` is private\n+    let b2 = other::B; //~ ERROR tuple struct `B` is private\n+    let c2 = other::C; //~ ERROR tuple struct `C` is private\n     let d2 = other::D;\n }\n "}]}