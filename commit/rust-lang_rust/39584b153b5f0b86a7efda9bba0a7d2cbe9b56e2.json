{"sha": "39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "node_id": "C_kwDOAAsO6NoAKDM5NTg0YjE1M2I1ZjBiODZhN2VmZGE5YmJhMGE3ZDJjYmU5YjU2ZTI", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-10-27T19:55:32Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-02T20:05:09Z"}, "message": "Factor out matching into `try_match_macro`\n\nThis moves out the matching part of expansion into a new function. This\nfunction will try to match the macro and return an error if it failed to\nmatch. A tracker can be used to get more information about the matching.", "tree": {"sha": "e9999e2e4d6c50b5f0155f255b240f8d01633c4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9999e2e4d6c50b5f0155f255b240f8d01633c4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQMW9+dJCX4lL6lhlcxpriHdA4yXOjASUnSW1K36Szrct1g2ImhNqxmZyqUwJYtlLQH\nrIto7w6TZumLgGolqfcgI=\n-----END SSH SIGNATURE-----", "payload": "tree e9999e2e4d6c50b5f0155f255b240f8d01633c4b\nparent 2f8a068cb760d0845e59b39444cb67479b2d2163\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1666900532 +0200\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667419509 +0100\n\nFactor out matching into `try_match_macro`\n\nThis moves out the matching part of expansion into a new function. This\nfunction will try to match the macro and return an error if it failed to\nmatch. A tracker can be used to get more information about the matching.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "html_url": "https://github.com/rust-lang/rust/commit/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8a068cb760d0845e59b39444cb67479b2d2163", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8a068cb760d0845e59b39444cb67479b2d2163", "html_url": "https://github.com/rust-lang/rust/commit/2f8a068cb760d0845e59b39444cb67479b2d2163"}], "stats": {"total": 253, "additions": 129, "deletions": 124}, "files": [{"sha": "d2dbd190c8ec2823d30aa86676fcb716878ea751", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "patch": "@@ -277,7 +277,11 @@ pub(crate) enum ParseResult<T> {\n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-pub(crate) type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n+pub(crate) type NamedParseResult = ParseResult<NamedMatches>;\n+\n+/// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.\n+/// This represents the mapping of metavars to the token trees they bind to.\n+pub(crate) type NamedMatches = FxHashMap<MacroRulesNormalizedIdent, NamedMatch>;\n \n /// Count how many metavars declarations are in `matcher`.\n pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {"}, {"sha": "b35ec453145f31f5c6e01707859e190d3e78331b", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 124, "deletions": 123, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "patch": "@@ -14,7 +14,9 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n+};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -33,7 +35,7 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n-use super::macro_parser::NamedParseResult;\n+use super::macro_parser::{NamedMatches, NamedParseResult};\n \n pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n@@ -253,9 +255,87 @@ fn expand_macro<'cx>(\n         trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n-    // Which arm's failure should we report? (the one furthest along)\n-    let mut best_failure: Option<(Token, &str)> = None;\n+    // Track nothing for the best performance\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut NoopTracker);\n+\n+    match try_success_result {\n+        Ok((i, named_matches)) => {\n+            let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n+                mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n+                _ => cx.span_bug(sp, \"malformed macro rhs\"),\n+            };\n+            let arm_span = rhses[i].span();\n+\n+            let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n+            // rhs has holes ( `$id` and `$(...)` that need filled)\n+            let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n+                Ok(tts) => tts,\n+                Err(mut err) => {\n+                    err.emit();\n+                    return DummyResult::any(arm_span);\n+                }\n+            };\n+\n+            // Replace all the tokens for the corresponding positions in the macro, to maintain\n+            // proper positions in error reporting, while maintaining the macro_backtrace.\n+            if rhs_spans.len() == tts.len() {\n+                tts = tts.map_enumerated(|i, tt| {\n+                    let mut tt = tt.clone();\n+                    let mut sp = rhs_spans[i];\n+                    sp = sp.with_ctxt(tt.span().ctxt());\n+                    tt.set_span(sp);\n+                    tt\n+                });\n+            }\n+\n+            if cx.trace_macros() {\n+                let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n+                trace_macros_note(&mut cx.expansions, sp, msg);\n+            }\n+\n+            let mut p = Parser::new(sess, tts, false, None);\n+            p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+\n+            if is_local {\n+                cx.resolver.record_macro_rule_usage(node_id, i);\n+            }\n+\n+            // Let the context choose how to interpret the result.\n+            // Weird, but useful for X-macros.\n+            return Box::new(ParserAnyMacro {\n+                parser: p,\n+\n+                // Pass along the original expansion site and the name of the macro\n+                // so we can print a useful error message if the parse of the expanded\n+                // macro leaves unparsed tokens.\n+                site_span: sp,\n+                macro_ident: name,\n+                lint_node_id: cx.current_expansion.lint_node_id,\n+                is_trailing_mac: cx.current_expansion.is_trailing_mac,\n+                arm_span,\n+                is_local,\n+            });\n+        }\n+        Err(()) => {\n+            todo!(\"Retry macro invocation while tracking diagnostics info and emit error\");\n+\n+            return DummyResult::any(sp);\n+        }\n+    }\n+\n+    DummyResult::any(sp)\n+}\n \n+/// Try expanding the macro. Returns the index of the sucessful arm and its named_matches if it was successful,\n+/// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n+/// correctly.\n+fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+    sess: &ParseSess,\n+    name: Ident,\n+    arg: &TokenStream,\n+    lhses: &'matcher [Vec<MatcherLoc>],\n+    track: &mut T,\n+) -> Result<(usize, NamedMatches), ()> {\n     // We create a base parser that can be used for the \"black box\" parts.\n     // Every iteration needs a fresh copy of that parser. However, the parser\n     // is not mutated on many of the iterations, particularly when dealing with\n@@ -277,7 +357,6 @@ fn expand_macro<'cx>(\n     // this situation.)\n     // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n-\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n@@ -287,115 +366,36 @@ fn expand_macro<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker) {\n+        let result = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, track);\n+\n+        track.after_arm(&result);\n+\n+        match result {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n-                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n-                };\n-                let arm_span = rhses[i].span();\n-\n-                let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n-                // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n-                    Ok(tts) => tts,\n-                    Err(mut err) => {\n-                        err.emit();\n-                        return DummyResult::any(arm_span);\n-                    }\n-                };\n-\n-                // Replace all the tokens for the corresponding positions in the macro, to maintain\n-                // proper positions in error reporting, while maintaining the macro_backtrace.\n-                if rhs_spans.len() == tts.len() {\n-                    tts = tts.map_enumerated(|i, tt| {\n-                        let mut tt = tt.clone();\n-                        let mut sp = rhs_spans[i];\n-                        sp = sp.with_ctxt(tt.span().ctxt());\n-                        tt.set_span(sp);\n-                        tt\n-                    });\n-                }\n-\n-                if cx.trace_macros() {\n-                    let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n-                    trace_macros_note(&mut cx.expansions, sp, msg);\n-                }\n-\n-                let mut p = Parser::new(sess, tts, false, None);\n-                p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n-\n-                if is_local {\n-                    cx.resolver.record_macro_rule_usage(node_id, i);\n-                }\n-\n-                // Let the context choose how to interpret the result.\n-                // Weird, but useful for X-macros.\n-                return Box::new(ParserAnyMacro {\n-                    parser: p,\n-\n-                    // Pass along the original expansion site and the name of the macro\n-                    // so we can print a useful error message if the parse of the expanded\n-                    // macro leaves unparsed tokens.\n-                    site_span: sp,\n-                    macro_ident: name,\n-                    lint_node_id: cx.current_expansion.lint_node_id,\n-                    is_trailing_mac: cx.current_expansion.is_trailing_mac,\n-                    arm_span,\n-                    is_local,\n-                });\n+                return Ok((i, named_matches));\n             }\n-            Failure(token, msg) => match best_failure {\n-                Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => best_failure = Some((token, msg)),\n-            },\n-            Error(err_sp, ref msg) => {\n-                let span = err_sp.substitute_dummy(sp);\n-                cx.struct_span_err(span, &msg).emit();\n-                return DummyResult::any(span);\n+            Failure(_, _) => {\n+                // Try the next arm\n+            }\n+            Error(_, _) => {\n+                // We haven't emitted an error yet\n+                return Err(());\n+            }\n+            ErrorReported(_) => {\n+                return Err(());\n             }\n-            ErrorReported(_) => return DummyResult::any(sp),\n         }\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(parser);\n-\n-    let (token, label) = best_failure.expect(\"ran no matchers\");\n-    let span = token.span.substitute_dummy(sp);\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone());\n-            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker) {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+\n+    Err(())\n }\n \n // Note that macro-by-example's input is also matched against a token tree:\n@@ -477,28 +477,29 @@ pub fn compile_declarative_macro(\n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n-    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, &mut NoopTracker) {\n-        Success(m) => m,\n-        Failure(token, msg) => {\n-            let s = parse_failure_msg(&token);\n-            let sp = token.span.substitute_dummy(def.span);\n-            let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n-            err.span_label(sp, msg);\n-            annotate_doc_comment(&mut err, sess.source_map(), sp);\n-            err.emit();\n-            return dummy_syn_ext();\n-        }\n-        Error(sp, msg) => {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n-                .emit();\n-            return dummy_syn_ext();\n-        }\n-        ErrorReported(_) => {\n-            return dummy_syn_ext();\n-        }\n-    };\n+    let argument_map =\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, &mut NoopTracker) {\n+            Success(m) => m,\n+            Failure(token, msg) => {\n+                let s = parse_failure_msg(&token);\n+                let sp = token.span.substitute_dummy(def.span);\n+                let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n+                err.span_label(sp, msg);\n+                annotate_doc_comment(&mut err, sess.source_map(), sp);\n+                err.emit();\n+                return dummy_syn_ext();\n+            }\n+            Error(sp, msg) => {\n+                sess.parse_sess\n+                    .span_diagnostic\n+                    .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                    .emit();\n+                return dummy_syn_ext();\n+            }\n+            ErrorReported(_) => {\n+                return dummy_syn_ext();\n+            }\n+        };\n \n     let mut valid = true;\n "}]}