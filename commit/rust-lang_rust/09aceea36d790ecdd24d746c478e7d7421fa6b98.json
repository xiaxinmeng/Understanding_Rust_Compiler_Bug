{"sha": "09aceea36d790ecdd24d746c478e7d7421fa6b98", "node_id": "C_kwDOAAsO6NoAKDA5YWNlZWEzNmQ3OTBlY2RkMjRkNzQ2YzQ3OGU3ZDc0MjFmYTZiOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-11T16:21:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-11T16:21:11Z"}, "message": "Auto merge of #13933 - Veykril:assoc-search, r=Veykril\n\nRefine search for const and function assoc items\n\nThis changes our searching behavior, before we always associated all usages and definitions of associated items with all implementations of a trait and the trait itself. Now, when searching for references of a an associated trait item, we still do the same and consider all implementations, but when searching for an associated item of an implementation we now only consider the uses of that specific implementations associated item.\n\nThis does not affect associated type aliases as we unfortunately are missing information in the IDE layer here still.", "tree": {"sha": "0c345bd8cf2dd44a7c89ed2f5bc83381ac83583c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c345bd8cf2dd44a7c89ed2f5bc83381ac83583c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09aceea36d790ecdd24d746c478e7d7421fa6b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09aceea36d790ecdd24d746c478e7d7421fa6b98", "html_url": "https://github.com/rust-lang/rust/commit/09aceea36d790ecdd24d746c478e7d7421fa6b98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09aceea36d790ecdd24d746c478e7d7421fa6b98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f32f64bffcbde9d8656c1c221547052f0da4f2e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f32f64bffcbde9d8656c1c221547052f0da4f2e8", "html_url": "https://github.com/rust-lang/rust/commit/f32f64bffcbde9d8656c1c221547052f0da4f2e8"}, {"sha": "bb4e272d8a05c5b6a000808c5c84d722d582603d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4e272d8a05c5b6a000808c5c84d722d582603d", "html_url": "https://github.com/rust-lang/rust/commit/bb4e272d8a05c5b6a000808c5c84d722d582603d"}], "stats": {"total": 355, "additions": 319, "deletions": 36}, "files": [{"sha": "64376e10bcc5baa5b7388e0dc2df96a56b98a944", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -712,17 +712,17 @@ fn lookup_impl_assoc_item_for_trait_ref(\n     let table = InferenceTable::new(db, env);\n \n     let impl_data = find_matching_impl(impls, table, trait_ref)?;\n-    impl_data.items.iter().find_map(|it| match it {\n+    impl_data.items.iter().find_map(|&it| match it {\n         AssocItemId::FunctionId(f) => {\n-            (db.function_data(*f).name == *name).then_some(AssocItemId::FunctionId(*f))\n+            (db.function_data(f).name == *name).then_some(AssocItemId::FunctionId(f))\n         }\n         AssocItemId::ConstId(c) => db\n-            .const_data(*c)\n+            .const_data(c)\n             .name\n             .as_ref()\n-            .map(|n| *n == *name)\n-            .and_then(|result| if result { Some(AssocItemId::ConstId(*c)) } else { None }),\n-        _ => None,\n+            .map(|n| n == name)\n+            .and_then(|result| if result { Some(AssocItemId::ConstId(c)) } else { None }),\n+        AssocItemId::TypeAliasId(_) => None,\n     })\n }\n "}, {"sha": "2fc2673bd22290b897942a54e1d2e5aca5d10b5e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -2129,7 +2129,7 @@ pub enum AssocItem {\n     Const(Const),\n     TypeAlias(TypeAlias),\n }\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum AssocItemContainer {\n     Trait(Trait),\n     Impl(Impl),"}, {"sha": "2354eb2c9ccaa94c35d590afff7efe643d243c81", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -504,7 +504,7 @@ impl SourceAnalyzer {\n                         AssocItemId::ConstId(const_id) => {\n                             self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n                         }\n-                        _ => assoc,\n+                        assoc => assoc,\n                     };\n \n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n@@ -517,7 +517,13 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some((assoc, _)) = infer.assoc_resolutions_for_pat(pat_id) {\n+                if let Some((assoc, subs)) = infer.assoc_resolutions_for_pat(pat_id) {\n+                    let assoc = match assoc {\n+                        AssocItemId::ConstId(const_id) => {\n+                            self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n+                        }\n+                        assoc => assoc,\n+                    };\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) ="}, {"sha": "fd09fdeb0bda5e3c050d5acab611464802a54267", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -7,7 +7,9 @@\n use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use hir::{\n+    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility,\n+};\n use memchr::memmem::Finder;\n use once_cell::unsync::Lazy;\n use parser::SyntaxKind;\n@@ -311,15 +313,15 @@ impl Definition {\n \n     pub fn usages<'a>(self, sema: &'a Semantics<'_, RootDatabase>) -> FindUsages<'a> {\n         FindUsages {\n-            local_repr: match self {\n-                Definition::Local(local) => Some(local.representative(sema.db)),\n-                _ => None,\n-            },\n             def: self,\n-            trait_assoc_def: as_trait_assoc_def(sema.db, self),\n+            assoc_item_container: self.as_assoc_item(sema.db).map(|a| a.container(sema.db)),\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n+            local_repr: match self {\n+                Definition::Local(local) => Some(local.representative(sema.db)),\n+                _ => None,\n+            },\n             search_self_mod: false,\n         }\n     }\n@@ -328,8 +330,7 @@ impl Definition {\n #[derive(Clone)]\n pub struct FindUsages<'a> {\n     def: Definition,\n-    /// If def is an assoc item from a trait or trait impl, this is the corresponding item of the trait definition\n-    trait_assoc_def: Option<Definition>,\n+    assoc_item_container: Option<hir::AssocItemContainer>,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n     include_self_kw_refs: Option<hir::Type>,\n@@ -380,7 +381,9 @@ impl<'a> FindUsages<'a> {\n         let sema = self.sema;\n \n         let search_scope = {\n-            let base = self.trait_assoc_def.unwrap_or(self.def).search_scope(sema.db);\n+            // FIXME: Is the trait scope needed for trait impl assoc items?\n+            let base =\n+                as_trait_assoc_def(sema.db, self.def).unwrap_or(self.def).search_scope(sema.db);\n             match &self.scope {\n                 None => base,\n                 Some(scope) => base.intersection(scope),\n@@ -651,13 +654,26 @@ impl<'a> FindUsages<'a> {\n                 sink(file_id, reference)\n             }\n             Some(NameRefClass::Definition(def))\n-                if match self.trait_assoc_def {\n-                    Some(trait_assoc_def) => {\n-                        // we have a trait assoc item, so force resolve all assoc items to their trait version\n-                        convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n-                    }\n-                    None => self.def == def,\n-                } =>\n+                if self.def == def\n+                    // is our def a trait assoc item? then we want to find everything\n+                    || matches!(self.assoc_item_container, Some(hir::AssocItemContainer::Trait(_)))\n+                        && convert_to_def_in_trait(self.sema.db, def) == self.def =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: ReferenceCategory::new(&def, name_ref),\n+                };\n+                sink(file_id, reference)\n+            }\n+            // FIXME: special case type aliases, we can't filter between impl and trait defs here as we lack the substitutions\n+            // so we always resolve all assoc type aliases to both their trait def and impl defs\n+            Some(NameRefClass::Definition(def))\n+                if self.assoc_item_container.is_some()\n+                    && matches!(self.def, Definition::TypeAlias(_))\n+                    && convert_to_def_in_trait(self.sema.db, def)\n+                        == convert_to_def_in_trait(self.sema.db, self.def) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n@@ -748,12 +764,14 @@ impl<'a> FindUsages<'a> {\n                 false\n             }\n             Some(NameClass::Definition(def)) if def != self.def => {\n-                // if the def we are looking for is a trait (impl) assoc item, we'll have to resolve the items to trait definition assoc item\n-                if !matches!(\n-                    self.trait_assoc_def,\n-                    Some(trait_assoc_def)\n-                        if convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n-                ) {\n+                // only when looking for trait assoc items, we want to find other assoc items\n+                if !matches!(self.assoc_item_container, Some(hir::AssocItemContainer::Trait(_)))\n+                    // FIXME: special case type aliases, we can't filter between impl and trait defs here as we lack the substitutions\n+                    // so we always resolve all assoc type aliases to both their trait def and impl defs\n+                    && !(matches!(self.def, Definition::TypeAlias(_))\n+                        && convert_to_def_in_trait(self.sema.db, def)\n+                            == convert_to_def_in_trait(self.sema.db, self.def))\n+                {\n                     return false;\n                 }\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());"}, {"sha": "c889eb930f30b4834e944b6155812dbff0b2d2bd", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -1356,7 +1356,6 @@ fn main() {\n             r#\"\n trait Trait {\n     fn func(self) {}\n-     //^^^^\n }\n \n impl Trait for () {\n@@ -1376,7 +1375,6 @@ fn main() {\n             r#\"\n trait Trait {\n     fn func(self) {}\n-     //^^^^\n }\n \n impl Trait for () {"}, {"sha": "e49f68c57ba8d63a535f55fbccc83689629ee7b4", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -1636,4 +1636,265 @@ pub fn deri$0ve(_stream: TokenStream) -> TokenStream {}\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn assoc_items_trait_def() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST$0: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 18..37 24..29\n+\n+                FileId(0) 71..76\n+                FileId(0) 125..130\n+                FileId(0) 183..188\n+                FileId(0) 206..211\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias$0;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 18..33 23..32\n+\n+                FileId(0) 66..75\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function$0() {}\n+}\n+\n+impl Trait for () {\n+    fn function() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 18..34 21..29\n+\n+                FileId(0) 65..73\n+                FileId(0) 112..120\n+                FileId(0) 166..174\n+                FileId(0) 192..200\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_items_trait_impl_def() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST$0: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 65..88 71..76\n+\n+                FileId(0) 183..188\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias$0 = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 61..81 66..75\n+\n+                FileId(0) 23..32\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function() {}\n+}\n+\n+impl Trait for () {\n+    fn function$0() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 62..78 65..73\n+\n+                FileId(0) 166..174\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_items_ref() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST$0;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 65..88 71..76\n+\n+                FileId(0) 183..188\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias$0;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 18..33 23..32\n+\n+                FileId(0) 66..75\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function() {}\n+}\n+\n+impl Trait for () {\n+    fn function() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function$0;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 62..78 65..73\n+\n+                FileId(0) 166..174\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "6d6e367e3740be34d30fe66a0ac2073e5bb4b40e", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aceea36d790ecdd24d746c478e7d7421fa6b98/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=09aceea36d790ecdd24d746c478e7d7421fa6b98", "patch": "@@ -1044,7 +1044,7 @@ impl Config {\n         &self.data.cargo_extraEnv\n     }\n \n-    pub fn check_on_save_extra_env(&self) -> FxHashMap<String, String> {\n+    pub fn check_extra_env(&self) -> FxHashMap<String, String> {\n         let mut extra_env = self.data.cargo_extraEnv.clone();\n         extra_env.extend(self.data.check_extraEnv.clone());\n         extra_env\n@@ -1165,7 +1165,7 @@ impl Config {\n                 FlycheckConfig::CustomCommand {\n                     command,\n                     args,\n-                    extra_env: self.check_on_save_extra_env(),\n+                    extra_env: self.check_extra_env(),\n                     invocation_strategy: match self.data.check_invocationStrategy {\n                         InvocationStrategy::Once => flycheck::InvocationStrategy::Once,\n                         InvocationStrategy::PerWorkspace => {\n@@ -1210,7 +1210,7 @@ impl Config {\n                     CargoFeaturesDef::Selected(it) => it,\n                 },\n                 extra_args: self.data.check_extraArgs.clone(),\n-                extra_env: self.check_on_save_extra_env(),\n+                extra_env: self.check_extra_env(),\n                 ansi_color_output: self.color_diagnostic_output(),\n             },\n         }"}]}