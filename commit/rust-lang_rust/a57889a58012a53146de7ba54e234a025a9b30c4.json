{"sha": "a57889a58012a53146de7ba54e234a025a9b30c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1Nzg4OWE1ODAxMmE1MzE0NmRlN2JhNTRlMjM0YTAyNWE5YjMwYzQ=", "commit": {"author": {"name": "Tom Lee", "email": "github@tomlee.co", "date": "2014-05-03T08:12:31Z"}, "committer": {"name": "Tom Lee", "email": "github@tomlee.co", "date": "2014-05-13T04:41:48Z"}, "message": "Easier interface for TCP ::connect and ::bind.\n\nPrior to this commit, TcpStream::connect and TcpListener::bind took a\nsingle SocketAddr argument. This worked well enough, but the API felt a\nlittle too \"low level\" for most simple use cases.\n\nA great example is connecting to rust-lang.org on port 80. Rust users would\nneed to:\n\n  1. resolve the IP address of rust-lang.org using\n     io::net::addrinfo::get_host_addresses.\n\n  2. check for errors\n\n  3. if all went well, use the returned IP address and the port number\n     to construct a SocketAddr\n\n  4. pass this SocketAddr to TcpStream::connect.\n\nI'm modifying the type signature of TcpStream::connect and\nTcpListener::bind so that the API is a little easier to use.\n\nTcpStream::connect now accepts two arguments: a string describing the\nhost/IP of the host we wish to connect to, and a u16 representing the\nremote port number.\n\nSimilarly, TcpListener::bind has been modified to take two arguments:\na string describing the local interface address (e.g. \"0.0.0.0\" or\n\"127.0.0.1\") and a u16 port number.\n\nHere's how to port your Rust code to use the new TcpStream::connect API:\n\n  // old ::connect API\n  let addr = SocketAddr{ip: Ipv4Addr{127, 0, 0, 1}, port: 8080};\n  let stream = TcpStream::connect(addr).unwrap()\n\n  // new ::connect API (minimal change)\n  let addr = SocketAddr{ip: Ipv4Addr{127, 0, 0, 1}, port: 8080};\n  let stream = TcpStream::connect(addr.ip.to_str(), addr.port()).unwrap()\n\n  // new ::connect API (more compact)\n  let stream = TcpStream::connect(\"127.0.0.1\", 8080).unwrap()\n\n  // new ::connect API (hostname)\n  let stream = TcpStream::connect(\"rust-lang.org\", 80)\n\nSimilarly, for TcpListener::bind:\n\n  // old ::bind API\n  let addr = SocketAddr{ip: Ipv4Addr{0, 0, 0, 0}, port: 8080};\n  let mut acceptor = TcpListener::bind(addr).listen();\n\n  // new ::bind API (minimal change)\n  let addr = SocketAddr{ip: Ipv4Addr{0, 0, 0, 0}, port: 8080};\n  let mut acceptor = TcpListener::bind(addr.ip.to_str(), addr.port()).listen()\n\n  // new ::bind API (more compact)\n  let mut acceptor = TcpListener::bind(\"0.0.0.0\", 8080).listen()\n\n[breaking-change]", "tree": {"sha": "9688bd9a3d727e2d2808872d75792e2c7e8c6560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9688bd9a3d727e2d2808872d75792e2c7e8c6560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a57889a58012a53146de7ba54e234a025a9b30c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a57889a58012a53146de7ba54e234a025a9b30c4", "html_url": "https://github.com/rust-lang/rust/commit/a57889a58012a53146de7ba54e234a025a9b30c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a57889a58012a53146de7ba54e234a025a9b30c4/comments", "author": {"login": "thomaslee", "id": 93216, "node_id": "MDQ6VXNlcjkzMjE2", "avatar_url": "https://avatars.githubusercontent.com/u/93216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomaslee", "html_url": "https://github.com/thomaslee", "followers_url": "https://api.github.com/users/thomaslee/followers", "following_url": "https://api.github.com/users/thomaslee/following{/other_user}", "gists_url": "https://api.github.com/users/thomaslee/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomaslee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomaslee/subscriptions", "organizations_url": "https://api.github.com/users/thomaslee/orgs", "repos_url": "https://api.github.com/users/thomaslee/repos", "events_url": "https://api.github.com/users/thomaslee/events{/privacy}", "received_events_url": "https://api.github.com/users/thomaslee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomaslee", "id": 93216, "node_id": "MDQ6VXNlcjkzMjE2", "avatar_url": "https://avatars.githubusercontent.com/u/93216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomaslee", "html_url": "https://github.com/thomaslee", "followers_url": "https://api.github.com/users/thomaslee/followers", "following_url": "https://api.github.com/users/thomaslee/following{/other_user}", "gists_url": "https://api.github.com/users/thomaslee/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomaslee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomaslee/subscriptions", "organizations_url": "https://api.github.com/users/thomaslee/orgs", "repos_url": "https://api.github.com/users/thomaslee/repos", "events_url": "https://api.github.com/users/thomaslee/events{/privacy}", "received_events_url": "https://api.github.com/users/thomaslee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07d63228ea38b1eb5f497b6397b06808b87e4083", "url": "https://api.github.com/repos/rust-lang/rust/commits/07d63228ea38b1eb5f497b6397b06808b87e4083", "html_url": "https://github.com/rust-lang/rust/commit/07d63228ea38b1eb5f497b6397b06808b87e4083"}], "stats": {"total": 378, "additions": 271, "deletions": 107}, "files": [{"sha": "e47e7dc33d8e4fd61a7b6f89d43c6434481118d8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a57889a58012a53146de7ba54e234a025a9b30c4", "patch": "@@ -19,7 +19,6 @@ use util;\n \n use std::io::File;\n use std::io::fs;\n-use std::io::net::ip::{Ipv4Addr, SocketAddr};\n use std::io::net::tcp;\n use std::io::process::ProcessExit;\n use std::io::process;\n@@ -316,10 +315,7 @@ fn run_debuginfo_gdb_test(config: &config, props: &TestProps, testfile: &Path) {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n                 let result = task::try(proc() {\n-                    tcp::TcpStream::connect(SocketAddr {\n-                        ip: Ipv4Addr(127, 0, 0, 1),\n-                        port: 5039,\n-                    }).unwrap();\n+                    tcp::TcpStream::connect(\"127.0.0.1\", 5039).unwrap();\n                 });\n                 if result.is_err() {\n                     continue;"}, {"sha": "5ae96e0f4e689b8e87f9df8863f5f159a016ee5b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a57889a58012a53146de7ba54e234a025a9b30c4", "patch": "@@ -83,11 +83,9 @@ Some examples of obvious things you might want to do\n \n     ```rust,should_fail\n     # #![allow(unused_must_use)]\n-    use std::io::net::ip::SocketAddr;\n     use std::io::net::tcp::TcpStream;\n \n-    let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n-    let mut socket = TcpStream::connect(addr).unwrap();\n+    let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n     let response = socket.read_to_end();\n     ```\n@@ -99,11 +97,9 @@ Some examples of obvious things you might want to do\n     # fn foo() {\n     # #![allow(dead_code)]\n     use std::io::{TcpListener, TcpStream};\n-    use std::io::net::ip::{Ipv4Addr, SocketAddr};\n     use std::io::{Acceptor, Listener};\n \n-    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n-    let listener = TcpListener::bind(addr);\n+    let listener = TcpListener::bind(\"127.0.0.1\", 80);\n \n     // bind the listener to the specified address\n     let mut acceptor = listener.listen();"}, {"sha": "454d9af5eeba2ad8a1e3798fdd1569d19ddff47a", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 256, "deletions": 90, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=a57889a58012a53146de7ba54e234a025a9b30c4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,8 +19,14 @@\n \n use clone::Clone;\n use io::IoResult;\n+use iter::Iterator;\n+use slice::ImmutableVector;\n+use result::{Ok,Err};\n+use io::net::addrinfo::get_host_addresses;\n use io::net::ip::SocketAddr;\n+use io::{IoError, ConnectionFailed, InvalidInput};\n use io::{Reader, Writer, Listener, Acceptor};\n+use from_str::FromStr;\n use kinds::Send;\n use option::{None, Some, Option};\n use owned::Box;\n@@ -35,10 +41,8 @@ use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n /// ```no_run\n /// # #![allow(unused_must_use)]\n /// use std::io::net::tcp::TcpStream;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n ///\n-/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-/// let mut stream = TcpStream::connect(addr);\n+/// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254);\n ///\n /// stream.write([1]);\n /// let mut buf = [0];\n@@ -54,13 +58,32 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    /// Creates a TCP connection to a remote socket address.\n+    /// Open a TCP connection to a remote host by hostname or IP address.\n     ///\n-    /// If no error is encountered, then `Ok(stream)` is returned.\n-    pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, None).map(TcpStream::new)\n-        })\n+    /// `host` can be a hostname or IP address string. If no error is\n+    /// encountered, then `Ok(stream)` is returned.\n+    pub fn connect(host: &str, port: u16) -> IoResult<TcpStream> {\n+        let addresses = try!(get_host_addresses(host));\n+        let mut err = IoError{\n+            kind: ConnectionFailed,\n+            desc: \"no addresses found for hostname\",\n+            detail: None\n+        };\n+        for address in addresses.iter() {\n+            let socket_addr = SocketAddr{ip: *address, port: port};\n+            let result = LocalIo::maybe_raise(|io| {\n+                io.tcp_connect(socket_addr, None).map(TcpStream::new)\n+            });\n+            match result {\n+                Ok(stream) => {\n+                    return Ok(stream)\n+                }\n+                Err(connect_err) => {\n+                    err = connect_err\n+                }\n+            }\n+        }\n+        Err(err)\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -121,10 +144,8 @@ impl TcpStream {\n     /// # #![allow(unused_must_use)]\n     /// use std::io::timer;\n     /// use std::io::net::tcp::TcpStream;\n-    /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n     ///\n-    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-    /// let mut stream = TcpStream::connect(addr).unwrap();\n+    /// let mut stream = TcpStream::connect(\"127.0.0.1\", 34254).unwrap();\n     /// let stream2 = stream.clone();\n     ///\n     /// spawn(proc() {\n@@ -251,11 +272,9 @@ impl Writer for TcpStream {\n /// # fn foo() {\n /// # #![allow(dead_code)]\n /// use std::io::{TcpListener, TcpStream};\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n /// use std::io::{Acceptor, Listener};\n ///\n-/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n-/// let listener = TcpListener::bind(addr);\n+/// let listener = TcpListener::bind(\"127.0.0.1\", 80);\n ///\n /// // bind the listener to the specified address\n /// let mut acceptor = listener.listen();\n@@ -284,17 +303,29 @@ pub struct TcpListener {\n }\n \n impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified local\n-    /// socket address. This listener is not ready for accepting connections,\n+    /// Creates a new `TcpListener` which will be bound to the specified IP\n+    /// and port. This listener is not ready for accepting connections,\n     /// `listen` must be called on it before that's possible.\n     ///\n     /// Binding with a port number of 0 will request that the OS assigns a port\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_name` function.\n-    pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {\n-        LocalIo::maybe_raise(|io| {\n-            io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n-        })\n+    pub fn bind(addr: &str, port: u16) -> IoResult<TcpListener> {\n+        match FromStr::from_str(addr) {\n+            Some(ip) => {\n+                let socket_addr = SocketAddr{ip: ip, port: port};\n+                LocalIo::maybe_raise(|io| {\n+                    io.tcp_bind(socket_addr).map(|l| TcpListener { obj: l })\n+                })\n+            }\n+            None => {\n+                Err(IoError{\n+                    kind: InvalidInput,\n+                    desc: \"invalid IP address specified\",\n+                    detail: None\n+                })\n+            }\n+        }\n     }\n \n     /// Returns the local socket address of this listener.\n@@ -338,11 +369,9 @@ impl TcpAcceptor {\n     /// ```no_run\n     /// # #![allow(experimental)]\n     /// use std::io::net::tcp::TcpListener;\n-    /// use std::io::net::ip::{SocketAddr, Ipv4Addr};\n     /// use std::io::{Listener, Acceptor, TimedOut};\n     ///\n-    /// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 8482 };\n-    /// let mut a = TcpListener::bind(addr).listen().unwrap();\n+    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n     ///\n     /// // After 100ms have passed, all accepts will fail\n     /// a.set_timeout(Some(100));\n@@ -382,27 +411,96 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match TcpListener::bind(addr) {\n+        match TcpListener::bind(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn connect_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match TcpStream::connect(addr) {\n+        match TcpStream::connect(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n     })\n \n+    iotest!(fn listen_ip4_localhost() {\n+        let socket_addr = next_test_ip4();\n+        let ip_str = socket_addr.ip.to_str();\n+        let port = socket_addr.port;\n+        let listener = TcpListener::bind(ip_str, port);\n+        let mut acceptor = listener.listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"localhost\", port);\n+            stream.write([144]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 144);\n+    })\n+\n+    iotest!(fn connect_localhost() {\n+        let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"localhost\", addr.port);\n+            stream.write([64]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 64);\n+    })\n+\n+    iotest!(fn connect_ip4_loopback() {\n+        let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"127.0.0.1\", addr.port);\n+            stream.write([44]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 44);\n+    })\n+\n+    iotest!(fn connect_ip6_loopback() {\n+        let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+\n+        spawn(proc() {\n+            let mut stream = TcpStream::connect(\"::1\", addr.port);\n+            stream.write([66]).unwrap();\n+        });\n+\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf).unwrap();\n+        assert!(buf[0] == 66);\n+    })\n+\n     iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(addr);\n+            let mut stream = TcpStream::connect(ip_str, port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -414,10 +512,12 @@ mod test {\n \n     iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(addr);\n+            let mut stream = TcpStream::connect(ip_str, port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -429,10 +529,12 @@ mod test {\n \n     iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -444,10 +546,12 @@ mod test {\n \n     iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -459,10 +563,12 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -482,10 +588,12 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -505,10 +613,12 @@ mod test {\n \n     iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -530,10 +640,12 @@ mod test {\n \n     iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(ip_str, port);\n             // Close\n         });\n \n@@ -555,12 +667,14 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -574,12 +688,14 @@ mod test {\n \n     iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -593,8 +709,10 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -613,11 +731,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -628,8 +748,10 @@ mod test {\n \n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -648,11 +770,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -664,7 +788,9 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -683,11 +809,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -699,7 +827,9 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -718,11 +848,13 @@ mod test {\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n+            let ip_str = addr.ip.to_str();\n+            let port = addr.port;\n             if i == MAX { return }\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n+                let mut stream = TcpStream::connect(ip_str, port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -732,7 +864,9 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut listener = TcpListener::bind(ip_str, port).unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n@@ -742,13 +876,15 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let acceptor = TcpListener::bind(ip_str, port).listen();\n         spawn(proc() {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        let stream = TcpStream::connect(addr);\n+        let stream = TcpStream::connect(ip_str, port);\n \n         assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n@@ -774,9 +910,11 @@ mod test {\n \n     iotest!(fn partial_read() {\n         let addr = next_test_ip4();\n+        let port = addr.port;\n         let (tx, rx) = channel();\n         spawn(proc() {\n-            let mut srv = TcpListener::bind(addr).listen().unwrap();\n+            let ip_str = addr.ip.to_str();\n+            let mut srv = TcpListener::bind(ip_str, port).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n@@ -786,7 +924,8 @@ mod test {\n         });\n \n         rx.recv();\n-        let mut c = TcpStream::connect(addr).unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let mut c = TcpStream::connect(ip_str, port).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n@@ -795,9 +934,11 @@ mod test {\n \n     iotest!(fn double_bind() {\n         let addr = next_test_ip4();\n-        let listener = TcpListener::bind(addr).unwrap().listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let listener = TcpListener::bind(ip_str, port).unwrap().listen();\n         assert!(listener.is_ok());\n-        match TcpListener::bind(addr).listen() {\n+        match TcpListener::bind(ip_str, port).listen() {\n             Ok(..) => fail!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n@@ -807,17 +948,20 @@ mod test {\n \n     iotest!(fn fast_rebind() {\n         let addr = next_test_ip4();\n+        let port = addr.port;\n         let (tx, rx) = channel();\n \n         spawn(proc() {\n+            let ip_str = addr.ip.to_str();\n             rx.recv();\n-            let _stream = TcpStream::connect(addr).unwrap();\n+            let _stream = TcpStream::connect(ip_str, port).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n+            let ip_str = addr.ip.to_str();\n+            let mut acceptor = TcpListener::bind(ip_str, port).listen();\n             tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n@@ -826,15 +970,17 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr);\n+        let _listener = TcpListener::bind(addr.ip.to_str(), port);\n     })\n \n     iotest!(fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n@@ -860,12 +1006,14 @@ mod test {\n \n     iotest!(fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             s.write([1]).unwrap();\n             rx.recv();\n             s.write([2]).unwrap();\n@@ -892,10 +1040,12 @@ mod test {\n \n     iotest!(fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr);\n+            let mut s = TcpStream::connect(ip_str, port);\n             let mut buf = [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n@@ -919,23 +1069,27 @@ mod test {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).unwrap().listen();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).unwrap().listen();\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     })\n \n     iotest!(fn accept_timeout() {\n         let addr = next_test_ip4();\n-        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).unwrap().listen().unwrap();\n \n         a.set_timeout(Some(10));\n \n@@ -954,7 +1108,7 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr).unwrap());\n+                tx.send(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n             });\n             let l = rx.recv();\n             for i in range(0, 1001) {\n@@ -971,14 +1125,16 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr).unwrap());\n+            drop(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n         });\n         a.accept().unwrap();\n     })\n \n     iotest!(fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n@@ -987,7 +1143,7 @@ mod test {\n         });\n \n         let mut b = [0];\n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         let mut s2 = s.clone();\n \n         // closing should prevent reads/writes\n@@ -1014,15 +1170,17 @@ mod test {\n \n     iotest!(fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n         });\n \n-        let mut s = TcpStream::connect(addr).unwrap();\n+        let mut s = TcpStream::connect(ip_str, port).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n         spawn(proc() {\n@@ -1039,10 +1197,12 @@ mod test {\n \n     iotest!(fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1071,10 +1231,12 @@ mod test {\n \n     iotest!(fn read_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n@@ -1099,10 +1261,12 @@ mod test {\n \n     iotest!(fn write_timeouts() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1126,10 +1290,12 @@ mod test {\n \n     iotest!(fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n+        let ip_str = addr.ip.to_str();\n+        let port = addr.port;\n+        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(addr).unwrap();\n+            let mut s = TcpStream::connect(ip_str, port).unwrap();\n             rx.recv();\n             assert_eq!(s.write([0]), Ok(()));\n             let _ = rx.recv_opt();"}, {"sha": "5612c50142cafa045087fd00e075e8774b7ba0fe", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=a57889a58012a53146de7ba54e234a025a9b30c4", "patch": "@@ -54,14 +54,16 @@ macro_rules! iotest (\n iotest!(fn eventual_timeout() {\n     use native;\n     let addr = next_test_ip4();\n+    let host = addr.ip.to_str();\n+    let port = addr.port;\n \n     // Use a native task to receive connections because it turns out libuv is\n     // really good at accepting connections and will likely run out of file\n     // descriptors before timing out.\n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n     native::task::spawn(proc() {\n-        let _l = TcpListener::bind(addr).unwrap().listen();\n+        let _l = TcpListener::bind(host, port).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();\n     });\n@@ -80,7 +82,9 @@ iotest!(fn eventual_timeout() {\n \n iotest!(fn timeout_success() {\n     let addr = next_test_ip4();\n-    let _l = TcpListener::bind(addr).unwrap().listen();\n+    let host = addr.ip.to_str();\n+    let port = addr.port;\n+    let _l = TcpListener::bind(host, port).unwrap().listen();\n \n     assert!(TcpStream::connect_timeout(addr, 1000).is_ok());\n })"}, {"sha": "829539ac709545bcc660c88b6a5c7b9df6695352", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57889a58012a53146de7ba54e234a025a9b30c4/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=a57889a58012a53146de7ba54e234a025a9b30c4", "patch": "@@ -19,7 +19,6 @@ extern crate libc;\n extern crate green;\n extern crate rustuv;\n \n-use std::io::net::ip::{Ipv4Addr, SocketAddr};\n use std::io::net::tcp::{TcpListener, TcpStream};\n use std::io::{Acceptor, Listener};\n use std::task::TaskBuilder;\n@@ -38,10 +37,11 @@ fn main() {\n         unsafe { libc::exit(1) }\n     });\n \n-    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 0 };\n+    let host = \"127.0.0.1\";\n+    let port = 0;\n     let (tx, rx) = channel();\n     spawn(proc() {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n+        let mut listener = TcpListener::bind(host, port).unwrap();\n         tx.send(listener.socket_name().unwrap());\n         let mut acceptor = listener.listen();\n         loop {\n@@ -57,14 +57,16 @@ fn main() {\n         }\n     });\n     let addr = rx.recv();\n+    let host = addr.ip.to_str();\n+    let port = addr.port;\n \n     let (tx, rx) = channel();\n     for _ in range(0, 1000) {\n         let tx = tx.clone();\n         let mut builder = TaskBuilder::new();\n         builder.opts.stack_size = Some(32 * 1024);\n         builder.spawn(proc() {\n-            match TcpStream::connect(addr) {\n+            match TcpStream::connect(host, port) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n                     stream.write([1]);"}]}