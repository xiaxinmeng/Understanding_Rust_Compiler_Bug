{"sha": "b687e84aebe871f8dc76424ceee30379d3b3381f", "node_id": "C_kwDOAAsO6NoAKGI2ODdlODRhZWJlODcxZjhkYzc2NDI0Y2VlZTMwMzc5ZDNiMzM4MWY", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-11-15T18:51:24Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-06-14T07:24:51Z"}, "message": "remove drain-on-drop behavior from BTree{Set,Map}::DrainFilter and add #[must_use]", "tree": {"sha": "520c43ffa0402b08b138d50f90565c0cde3e1a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/520c43ffa0402b08b138d50f90565c0cde3e1a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b687e84aebe871f8dc76424ceee30379d3b3381f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b687e84aebe871f8dc76424ceee30379d3b3381f", "html_url": "https://github.com/rust-lang/rust/commit/b687e84aebe871f8dc76424ceee30379d3b3381f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b687e84aebe871f8dc76424ceee30379d3b3381f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0df1c8c432e856c4317c5c7585c86c54bcb46a2", "html_url": "https://github.com/rust-lang/rust/commit/c0df1c8c432e856c4317c5c7585c86c54bcb46a2"}], "stats": {"total": 98, "additions": 40, "deletions": 58}, "files": [{"sha": "4f50cdefc3c8a517a9fdad3e79affb8addffb201", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=b687e84aebe871f8dc76424ceee30379d3b3381f", "patch": "@@ -1132,7 +1132,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n         K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        self.drain_filter(|k, v| !f(k, v));\n+        self.drain_filter(|k, v| !f(k, v)).for_each(drop);\n     }\n \n     /// Moves all elements from `other` into `self`, leaving `other` empty.\n@@ -1395,14 +1395,11 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// The iterator also lets you mutate the value of each element in the\n     /// closure, regardless of whether you choose to keep or remove it.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each\n-    /// of the remaining elements is still subjected to the closure, which may\n-    /// change its value and, by returning `true`, have the element removed and\n-    /// dropped.\n+    /// If the returned `DrainFilter` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n-    /// It is unspecified how many more elements will be subjected to the\n-    /// closure if a panic occurs in the closure, or a panic occurs while\n-    /// dropping an element, or if the `DrainFilter` value is leaked.\n+    /// [`retain`]: BTreeMap::retain\n     ///\n     /// # Examples\n     ///\n@@ -1901,6 +1898,7 @@ impl<K, V> Default for Values<'_, K, V> {\n \n /// An iterator produced by calling `drain_filter` on BTreeMap.\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct DrainFilter<\n     'a,\n     K,\n@@ -1929,16 +1927,6 @@ pub(super) struct DrainFilterInner<'a, K, V> {\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F, A: Allocator + Clone> Drop for DrainFilter<'_, K, V, F, A>\n-where\n-    F: FnMut(&K, &mut V) -> bool,\n-{\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n impl<K, V, F> fmt::Debug for DrainFilter<'_, K, V, F>\n where"}, {"sha": "1b9957fcd51d19ebbaba27c273d7d1ee88cd46ff", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=b687e84aebe871f8dc76424ceee30379d3b3381f", "patch": "@@ -947,7 +947,7 @@ mod test_drain_filter {\n     #[test]\n     fn empty() {\n         let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n-        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\")).for_each(drop);\n         assert_eq!(map.height(), None);\n         map.check();\n     }\n@@ -1008,7 +1008,7 @@ mod test_drain_filter {\n     fn underfull_keeping_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| false);\n+        map.drain_filter(|_, _| false).for_each(drop);\n         assert!(map.keys().copied().eq(0..3));\n         map.check();\n     }\n@@ -1018,7 +1018,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         for doomed in 0..3 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.drain_filter(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), 2);\n             map.check();\n         }\n@@ -1029,7 +1029,7 @@ mod test_drain_filter {\n         let pairs = (0..3).map(|i| (i, i));\n         for sacred in 0..3 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.drain_filter(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1039,7 +1039,7 @@ mod test_drain_filter {\n     fn underfull_removing_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.drain_filter(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1048,7 +1048,7 @@ mod test_drain_filter {\n     fn height_0_keeping_all() {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| false);\n+        map.drain_filter(|_, _| false).for_each(drop);\n         assert!(map.keys().copied().eq(0..node::CAPACITY));\n         map.check();\n     }\n@@ -1058,7 +1058,7 @@ mod test_drain_filter {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         for doomed in 0..node::CAPACITY {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.drain_filter(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), node::CAPACITY - 1);\n             map.check();\n         }\n@@ -1069,7 +1069,7 @@ mod test_drain_filter {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         for sacred in 0..node::CAPACITY {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.drain_filter(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1079,7 +1079,7 @@ mod test_drain_filter {\n     fn height_0_removing_all() {\n         let pairs = (0..node::CAPACITY).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.drain_filter(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1096,7 +1096,7 @@ mod test_drain_filter {\n     fn height_1_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.drain_filter(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1106,7 +1106,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.drain_filter(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n             map.check();\n         }\n@@ -1117,7 +1117,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n         for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.drain_filter(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1128,7 +1128,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i == doomed);\n+            map.drain_filter(|i, _| *i == doomed).for_each(drop);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n             map.check();\n         }\n@@ -1139,7 +1139,7 @@ mod test_drain_filter {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map = BTreeMap::from_iter(pairs.clone());\n-            map.drain_filter(|i, _| *i != sacred);\n+            map.drain_filter(|i, _| *i != sacred).for_each(drop);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n             map.check();\n         }\n@@ -1149,7 +1149,7 @@ mod test_drain_filter {\n     fn height_2_removing_all() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         let mut map = BTreeMap::from_iter(pairs);\n-        map.drain_filter(|_, _| true);\n+        map.drain_filter(|_, _| true).for_each(drop);\n         assert!(map.is_empty());\n         map.check();\n     }\n@@ -1165,7 +1165,8 @@ mod test_drain_filter {\n         map.insert(b.spawn(Panic::InDrop), ());\n         map.insert(c.spawn(Panic::Never), ());\n \n-        catch_unwind(move || drop(map.drain_filter(|dummy, _| dummy.query(true)))).unwrap_err();\n+        catch_unwind(move || map.drain_filter(|dummy, _| dummy.query(true)).for_each(drop))\n+            .unwrap_err();\n \n         assert_eq!(a.queried(), 1);\n         assert_eq!(b.queried(), 1);\n@@ -1186,8 +1187,10 @@ mod test_drain_filter {\n         map.insert(b.spawn(Panic::InQuery), ());\n         map.insert(c.spawn(Panic::InQuery), ());\n \n-        catch_unwind(AssertUnwindSafe(|| drop(map.drain_filter(|dummy, _| dummy.query(true)))))\n-            .unwrap_err();\n+        catch_unwind(AssertUnwindSafe(|| {\n+            map.drain_filter(|dummy, _| dummy.query(true)).for_each(drop)\n+        }))\n+        .unwrap_err();\n \n         assert_eq!(a.queried(), 1);\n         assert_eq!(b.queried(), 1);"}, {"sha": "d8f34a7fa480cb35586dad3ed1b86da8a74e0473", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=b687e84aebe871f8dc76424ceee30379d3b3381f", "patch": "@@ -999,7 +999,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n         T: Ord,\n         F: FnMut(&T) -> bool,\n     {\n-        self.drain_filter(|v| !f(v));\n+        self.drain_filter(|v| !f(v)).for_each(drop);\n     }\n \n     /// Moves all elements from `other` into `self`, leaving `other` empty.\n@@ -1084,14 +1084,11 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// yielded. If the closure returns `false`, or panics, the element remains\n     /// in the set and will not be yielded.\n     ///\n-    /// If the iterator is only partially consumed or not consumed at all, each\n-    /// of the remaining elements is still subjected to the closure and removed\n-    /// and dropped if it returns `true`.\n-    ///\n-    /// It is unspecified how many more elements will be subjected to the\n-    /// closure if a panic occurs in the closure, or if a panic occurs while\n-    /// dropping an element, or if the `DrainFilter` itself is leaked.\n+    /// If the returned `DrainFilter` is not exhausted, e.g. because it is dropped without iterating\n+    /// or the iteration short-circuits, then the remaining elements will be retained.\n+    /// Use [`retain`] with a negated predicate if you do not need the returned iterator.\n     ///\n+    /// [`retain`]: BTreeSet::retain\n     /// # Examples\n     ///\n     /// Splitting a set into even and odd values, reusing the original set:\n@@ -1277,6 +1274,7 @@ impl<'a, T, A: Allocator + Clone> IntoIterator for &'a BTreeSet<T, A> {\n \n /// An iterator produced by calling `drain_filter` on BTreeSet.\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct DrainFilter<\n     'a,\n     T,\n@@ -1292,16 +1290,6 @@ pub struct DrainFilter<\n     alloc: A,\n }\n \n-#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<T, F, A: Allocator + Clone> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-    }\n-}\n-\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n impl<T, F, A: Allocator + Clone> fmt::Debug for DrainFilter<'_, T, F, A>\n where"}, {"sha": "9e4be2f67ec94a190d00d9efd410ddcc9a111488", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b687e84aebe871f8dc76424ceee30379d3b3381f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=b687e84aebe871f8dc76424ceee30379d3b3381f", "patch": "@@ -370,8 +370,8 @@ fn test_drain_filter() {\n     let mut x = BTreeSet::from([1]);\n     let mut y = BTreeSet::from([1]);\n \n-    x.drain_filter(|_| true);\n-    y.drain_filter(|_| false);\n+    x.drain_filter(|_| true).for_each(drop);\n+    y.drain_filter(|_| false).for_each(drop);\n     assert_eq!(x.len(), 0);\n     assert_eq!(y.len(), 1);\n }\n@@ -387,7 +387,7 @@ fn test_drain_filter_drop_panic_leak() {\n     set.insert(b.spawn(Panic::InDrop));\n     set.insert(c.spawn(Panic::Never));\n \n-    catch_unwind(move || drop(set.drain_filter(|dummy| dummy.query(true)))).ok();\n+    catch_unwind(move || set.drain_filter(|dummy| dummy.query(true)).for_each(drop)).ok();\n \n     assert_eq!(a.queried(), 1);\n     assert_eq!(b.queried(), 1);\n@@ -408,7 +408,10 @@ fn test_drain_filter_pred_panic_leak() {\n     set.insert(b.spawn(Panic::InQuery));\n     set.insert(c.spawn(Panic::InQuery));\n \n-    catch_unwind(AssertUnwindSafe(|| drop(set.drain_filter(|dummy| dummy.query(true))))).ok();\n+    catch_unwind(AssertUnwindSafe(|| {\n+        set.drain_filter(|dummy| dummy.query(true)).for_each(drop)\n+    }))\n+    .ok();\n \n     assert_eq!(a.queried(), 1);\n     assert_eq!(b.queried(), 1);"}]}