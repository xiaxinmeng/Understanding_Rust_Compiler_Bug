{"sha": "8b19af05823a5a78241ffa792621510047a4f572", "node_id": "C_kwDOAAsO6NoAKDhiMTlhZjA1ODIzYTVhNzgyNDFmZmE3OTI2MjE1MTAwNDdhNGY1NzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T10:59:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T10:59:40Z"}, "message": "Auto merge of #2725 - RalfJung:host-to-target-path, r=RalfJung\n\nmake unix path handling on Windows hosts (and vice versa) preserve absoluteness\n\nAlso adds a magic Miri extern function so this conversion can be invoked by the program. That avoids having to duplicate that logic.", "tree": {"sha": "32a5bb6a9a29b7b9ec9f2ab5e2f87f55b3621bd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32a5bb6a9a29b7b9ec9f2ab5e2f87f55b3621bd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b19af05823a5a78241ffa792621510047a4f572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b19af05823a5a78241ffa792621510047a4f572", "html_url": "https://github.com/rust-lang/rust/commit/8b19af05823a5a78241ffa792621510047a4f572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b19af05823a5a78241ffa792621510047a4f572/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8f972fb25f7ab5ec84cf8b12ab13a70cc9f6c1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f972fb25f7ab5ec84cf8b12ab13a70cc9f6c1e", "html_url": "https://github.com/rust-lang/rust/commit/b8f972fb25f7ab5ec84cf8b12ab13a70cc9f6c1e"}, {"sha": "2949702a5c059578ea357e794ba5fab9f3bdd81d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2949702a5c059578ea357e794ba5fab9f3bdd81d", "html_url": "https://github.com/rust-lang/rust/commit/2949702a5c059578ea357e794ba5fab9f3bdd81d"}], "stats": {"total": 299, "additions": 228, "deletions": 71}, "files": [{"sha": "9a4dea949d178310516fb75b0429faa409714063", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -576,6 +576,21 @@ extern \"Rust\" {\n \n     /// Miri-provided extern function to deallocate memory.\n     fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n+\n+    /// Convert a path from the host Miri runs on to the target Miri interprets.\n+    /// Performs conversion of path separators as needed.\n+    ///\n+    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n+    /// might be necessary when reading an environment variable that was set on the host\n+    /// (such as TMPDIR) and using it as a target path.\n+    ///\n+    /// Only works with isolation disabled.\n+    ///\n+    /// `in` must point to a null-terminated string, and will be read as the input host path.\n+    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n+    /// with a null terminator.\n+    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n+    fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n }\n ```\n "}, {"sha": "abfa73db6404d6c4ef2224dc4bb4a3f896c4c9d8", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -1,4 +1,4 @@\n-use std::{collections::hash_map::Entry, io::Write, iter};\n+use std::{collections::hash_map::Entry, io::Write, iter, path::Path};\n \n use log::trace;\n \n@@ -442,6 +442,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n                 this.machine.static_roots.push(alloc_id);\n             }\n+            \"miri_host_to_target_path\" => {\n+                let [ptr, out, out_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let out = this.read_pointer(out)?;\n+                let out_size = this.read_scalar(out_size)?.to_machine_usize(this)?;\n+\n+                // The host affects program behavior here, so this requires isolation to be disabled.\n+                this.check_no_isolation(\"`miri_host_to_target_path`\")?;\n+\n+                // We read this as a plain OsStr and write it as a path, which will convert it to the target.\n+                let path = this.read_os_str_from_c_str(ptr)?.to_owned();\n+                let (success, needed_size) = this.write_path_to_c_str(Path::new(&path), out, out_size)?;\n+                // Return value: 0 on success, otherwise the size it would have needed.\n+                this.write_int(if success { 0 } else { needed_size }, dest)?;\n+            }\n \n             // Obtains the size of a Miri backtrace. See the README for details.\n             \"miri_backtrace_size\" => {"}, {"sha": "0375a228a2148833b3153ed092169c64efb0aa83", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -174,7 +174,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_c_str(ptr)?;\n \n-        Ok(match this.convert_path_separator(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n+        Ok(match this.convert_path(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n             Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n             Cow::Owned(y) => Cow::Owned(PathBuf::from(y)),\n         })\n@@ -188,10 +188,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_wide_str(ptr)?;\n \n-        Ok(this\n-            .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n-            .into_owned()\n-            .into())\n+        Ok(this.convert_path(Cow::Owned(os_str), PathConversion::TargetToHost).into_owned().into())\n     }\n \n     /// Write a Path to the machine memory (as a null-terminated sequence of bytes),\n@@ -203,8 +200,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_c_str(&os_str, ptr, size)\n     }\n \n@@ -217,8 +214,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_wide_str(&os_str, ptr, size)\n     }\n \n@@ -230,18 +227,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         memkind: MemoryKind<MiriMemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.alloc_os_str_as_c_str(&os_str, memkind)\n     }\n \n-    fn convert_path_separator<'a>(\n+    #[allow(clippy::get_first)]\n+    fn convert_path<'a>(\n         &self,\n         os_str: Cow<'a, OsStr>,\n         direction: PathConversion,\n     ) -> Cow<'a, OsStr> {\n         let this = self.eval_context_ref();\n         let target_os = &this.tcx.sess.target.os;\n+\n         #[cfg(windows)]\n         return if target_os == \"windows\" {\n             // Windows-on-Windows, all fine.\n@@ -252,24 +251,71 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 PathConversion::HostToTarget => ('\\\\', '/'),\n                 PathConversion::TargetToHost => ('/', '\\\\'),\n             };\n-            let converted = os_str\n+            let mut converted = os_str\n                 .encode_wide()\n                 .map(|wchar| if wchar == from as u16 { to as u16 } else { wchar })\n                 .collect::<Vec<_>>();\n+            // We also have to ensure that absolute paths remain absolute.\n+            match direction {\n+                PathConversion::HostToTarget => {\n+                    // If this is an absolute Windows path that starts with a drive letter (`C:/...`\n+                    // after separator conversion), it would not be considered absolute by Unix\n+                    // target code.\n+                    if converted.get(1).copied() == Some(b':' as u16)\n+                        && converted.get(2).copied() == Some(b'/' as u16)\n+                    {\n+                        // We add a `/` at the beginning, to store the absolute Windows\n+                        // path in something that looks like an absolute Unix path.\n+                        converted.insert(0, b'/' as u16);\n+                    }\n+                }\n+                PathConversion::TargetToHost => {\n+                    // If the path is `\\C:\\`, the leading backslash was probably added by the above code\n+                    // and we should get rid of it again.\n+                    if converted.get(0).copied() == Some(b'\\\\' as u16)\n+                        && converted.get(2).copied() == Some(b':' as u16)\n+                        && converted.get(3).copied() == Some(b'\\\\' as u16)\n+                    {\n+                        converted.remove(0);\n+                    }\n+                }\n+            }\n             Cow::Owned(OsString::from_wide(&converted))\n         };\n         #[cfg(unix)]\n         return if target_os == \"windows\" {\n             // Windows target, Unix host.\n             let (from, to) = match direction {\n-                PathConversion::HostToTarget => ('/', '\\\\'),\n-                PathConversion::TargetToHost => ('\\\\', '/'),\n+                PathConversion::HostToTarget => (b'/', b'\\\\'),\n+                PathConversion::TargetToHost => (b'\\\\', b'/'),\n             };\n-            let converted = os_str\n+            let mut converted = os_str\n                 .as_bytes()\n                 .iter()\n-                .map(|&wchar| if wchar == from as u8 { to as u8 } else { wchar })\n+                .map(|&wchar| if wchar == from { to } else { wchar })\n                 .collect::<Vec<_>>();\n+            // We also have to ensure that absolute paths remain absolute.\n+            match direction {\n+                PathConversion::HostToTarget => {\n+                    // If this start withs a `\\`, we add `\\\\?` so it starts with `\\\\?\\` which is\n+                    // some magic path on Windos that *is* considered absolute.\n+                    if converted.get(0).copied() == Some(b'\\\\') {\n+                        converted.splice(0..0, b\"\\\\\\\\?\".iter().copied());\n+                    }\n+                }\n+                PathConversion::TargetToHost => {\n+                    // If this starts with `//?/`, it was probably produced by the above code and we\n+                    // remove the `//?` that got added to get the Unix path back out.\n+                    if converted.get(0).copied() == Some(b'/')\n+                        && converted.get(1).copied() == Some(b'/')\n+                        && converted.get(2).copied() == Some(b'?')\n+                        && converted.get(3).copied() == Some(b'/')\n+                    {\n+                        // Remove first 3 characters\n+                        converted.splice(0..3, std::iter::empty());\n+                    }\n+                }\n+            }\n             Cow::Owned(OsString::from_vec(converted))\n         } else {\n             // Unix-on-Unix, all is fine."}, {"sha": "ce2b0143b561cd745460f66c55b1362a0eef8e94", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -1667,7 +1667,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // 'readlink' truncates the resolved path if the provided buffer is not large\n                 // enough, and does *not* add a null terminator. That means we cannot use the usual\n                 // `write_path_to_c_str` and have to re-implement parts of it ourselves.\n-                let resolved = this.convert_path_separator(\n+                let resolved = this.convert_path(\n                     Cow::Borrowed(resolved.as_ref()),\n                     crate::shims::os_str::PathConversion::HostToTarget,\n                 );"}, {"sha": "048dbbbaa0f06d9c6595376c5867f38f43580adc", "filename": "src/tools/miri/test-cargo-miri/src/main.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -2,6 +2,7 @@ use byteorder::{BigEndian, ByteOrder};\n use std::env;\n #[cfg(unix)]\n use std::io::{self, BufRead};\n+use std::path::PathBuf;\n \n fn main() {\n     // Check env var set by `build.rs`.\n@@ -21,12 +22,30 @@ fn main() {\n     // If there were no arguments, access stdin and test working dir.\n     // (We rely on the test runner to always disable isolation when passing no arguments.)\n     if std::env::args().len() <= 1 {\n+        fn host_to_target_path(path: String) -> PathBuf {\n+            use std::ffi::{CStr, CString};\n+\n+            let path = CString::new(path).unwrap();\n+            let mut out = Vec::with_capacity(1024);\n+\n+            unsafe {\n+                extern \"Rust\" {\n+                    fn miri_host_to_target_path(\n+                        path: *const i8,\n+                        out: *mut i8,\n+                        out_size: usize,\n+                    ) -> usize;\n+                }\n+                let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+                assert_eq!(ret, 0);\n+                let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+                PathBuf::from(out)\n+            }\n+        }\n+\n         // CWD should be crate root.\n-        // We have to normalize slashes, as the env var might be set for a different target's conventions.\n         let env_dir = env::current_dir().unwrap();\n-        let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-        let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-        let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+        let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n         assert_eq!(env_dir, crate_dir);\n \n         #[cfg(unix)]"}, {"sha": "1cb8091f87750a1703e60f5d7f57919ecaadc61a", "filename": "src/tools/miri/test-cargo-miri/subcrate/main.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -4,13 +4,30 @@ use std::path::PathBuf;\n fn main() {\n     println!(\"subcrate running\");\n \n+    fn host_to_target_path(path: String) -> PathBuf {\n+        use std::ffi::{CStr, CString};\n+\n+        let path = CString::new(path).unwrap();\n+        let mut out = Vec::with_capacity(1024);\n+\n+        unsafe {\n+            extern \"Rust\" {\n+                fn miri_host_to_target_path(\n+                    path: *const i8,\n+                    out: *mut i8,\n+                    out_size: usize,\n+                ) -> usize;\n+            }\n+            let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+            assert_eq!(ret, 0);\n+            let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+            PathBuf::from(out)\n+        }\n+    }\n+\n     // CWD should be workspace root, i.e., one level up from crate root.\n-    // We have to normalize slashes, as the env var might be set for a different target's conventions.\n     let env_dir = env::current_dir().unwrap();\n-    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = PathBuf::from(crate_dir);\n-    let crate_dir = crate_dir.parent().unwrap().to_string_lossy();\n+    let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n+    let crate_dir = crate_dir.parent().unwrap();\n     assert_eq!(env_dir, crate_dir);\n }"}, {"sha": "619d8c72fd0a7aae05a129bc720ac543f336b707", "filename": "src/tools/miri/test-cargo-miri/subcrate/test.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -1,16 +1,37 @@\n use std::env;\n \n+use std::path::PathBuf;\n+\n use byteorder::{ByteOrder, LittleEndian};\n \n fn main() {\n     println!(\"subcrate testing\");\n \n+    fn host_to_target_path(path: String) -> PathBuf {\n+        use std::ffi::{CStr, CString};\n+\n+        let path = CString::new(path).unwrap();\n+        let mut out = Vec::with_capacity(1024);\n+\n+        unsafe {\n+            extern \"Rust\" {\n+                fn miri_host_to_target_path(\n+                    path: *const i8,\n+                    out: *mut i8,\n+                    out_size: usize,\n+                ) -> usize;\n+            }\n+            let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+            assert_eq!(ret, 0);\n+            let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+            PathBuf::from(out)\n+        }\n+    }\n+\n     // CWD should be crate root.\n     // We have to normalize slashes, as the env var might be set for a different target's conventions.\n     let env_dir = env::current_dir().unwrap();\n-    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n     assert_eq!(env_dir, crate_dir);\n \n     // Make sure we can call dev-dependencies."}, {"sha": "ba5b269f65242427230466a2cb63d500bcf46db5", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -5,7 +5,7 @@\n #![feature(io_error_uncategorized)]\n \n use std::convert::TryInto;\n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n use std::fs::{canonicalize, remove_dir_all, remove_file, File};\n use std::io::{Error, ErrorKind, Write};\n use std::os::unix::ffi::OsStrExt;\n@@ -23,20 +23,21 @@ fn main() {\n }\n \n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-\n-            #[cfg(windows)]\n-            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n-\n-            #[cfg(not(windows))]\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n }\n \n /// Prepare: compute filename and make sure the file does not exist."}, {"sha": "20e96a92c7c5fc6dc206c3cdf3db4d32a0637100", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -7,15 +7,23 @@ use std::os::unix::io::AsRawFd;\n use std::path::PathBuf;\n \n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    use std::ffi::{CStr, CString};\n+\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n }\n \n /// Test allocating variant of `realpath`."}, {"sha": "ca90912eabc54c038ef506f011ce3edc2e03dd7b", "filename": "src/tools/miri/tests/pass/shims/env/current_dir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -3,8 +3,9 @@ use std::env;\n use std::io::ErrorKind;\n \n fn main() {\n-    // Test that `getcwd` is available\n+    // Test that `getcwd` is available and an absolute path\n     let cwd = env::current_dir().unwrap();\n+    assert!(cwd.is_absolute(), \"cwd {:?} is not absolute\", cwd);\n     // Test that changing dir to `..` actually sets the current directory to the parent of `cwd`.\n     // The only exception here is if `cwd` is the root directory, then changing directory must\n     // keep the current directory equal to `cwd`."}, {"sha": "a7d4800faecc4b973904c79b678dc3a886d90e3a", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -15,6 +15,7 @@ use std::io::{Error, ErrorKind, IsTerminal, Read, Result, Seek, SeekFrom, Write}\n use std::path::{Path, PathBuf};\n \n fn main() {\n+    test_path_conversion();\n     test_file();\n     test_file_clone();\n     test_file_create_new();\n@@ -30,21 +31,28 @@ fn main() {\n     test_from_raw_os_error();\n }\n \n+fn host_to_target_path(path: String) -> PathBuf {\n+    use std::ffi::{CStr, CString};\n+\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n+}\n+\n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-\n-            #[cfg(windows)]\n-            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n-\n-            #[cfg(not(windows))]\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    host_to_target_path(path)\n }\n \n /// Prepare: compute filename and make sure the file does not exist.\n@@ -71,6 +79,12 @@ fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n     path\n }\n \n+fn test_path_conversion() {\n+    let tmp = tmp();\n+    assert!(tmp.is_absolute(), \"{:?} is not absolute\", tmp);\n+    assert!(tmp.is_dir(), \"{:?} is not a directory\", tmp);\n+}\n+\n fn test_file() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare(\"miri_test_fs_file.txt\");"}]}