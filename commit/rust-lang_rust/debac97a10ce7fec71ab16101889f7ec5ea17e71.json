{"sha": "debac97a10ce7fec71ab16101889f7ec5ea17e71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYmFjOTdhMTBjZTdmZWM3MWFiMTYxMDE4ODlmN2VjNWVhMTdlNzE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:39Z"}, "message": "Rollup merge of #23895 - nikomatsakis:fn-trait-inheritance-add-impls, r=pnkfelix\n\nThe primary purpose of this PR is to add blanket impls for the `Fn` traits of the following (simplified) form:\r\n\r\n    impl<F:Fn> Fn for &F\r\n    impl<F:FnMut> FnMut for &mut F\r\n\r\nHowever, this wound up requiring two changes:\r\n\r\n1. A slight hack so that `x()` where `x: &mut F` is translated to `FnMut::call_mut(&mut *x, ())` vs `FnMut::call_mut(&mut x, ())`. This is achieved by just autoderef'ing one time when calling something whose type is `&F` or `&mut F`.\r\n2. Making the infinite recursion test in trait matching a bit more tailored. This involves adding a notion of \"matching\" types that looks to see if types are potentially unifiable (it's an approximation).\r\n\r\nThe PR also includes various small refactorings to the inference code that are aimed at moving the unification and other code into a library (I've got that particular change in a branch, these changes just lead the way there by removing unnecessary dependencies between the compiler and the more general unification code). \r\n\r\nNote that per rust-lang/rfcs#1023, adding impls like these would be a breaking change in the future. \r\n\r\ncc @japaric\r\ncc @alexcrichton \r\ncc @aturon \r\n\r\nFixes #23015.", "tree": {"sha": "f9b72c518b23ff59826435c2e45df2477cd98dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9b72c518b23ff59826435c2e45df2477cd98dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/debac97a10ce7fec71ab16101889f7ec5ea17e71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/debac97a10ce7fec71ab16101889f7ec5ea17e71", "html_url": "https://github.com/rust-lang/rust/commit/debac97a10ce7fec71ab16101889f7ec5ea17e71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/debac97a10ce7fec71ab16101889f7ec5ea17e71/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790", "html_url": "https://github.com/rust-lang/rust/commit/9eb0bab9dee6e650ce6f9e01f0e3eb22ca302790"}, {"sha": "11111bb6b7889ce45770a6ffe46c75a2690c387f", "url": "https://api.github.com/repos/rust-lang/rust/commits/11111bb6b7889ce45770a6ffe46c75a2690c387f", "html_url": "https://github.com/rust-lang/rust/commit/11111bb6b7889ce45770a6ffe46c75a2690c387f"}], "stats": {"total": 2897, "additions": 1627, "deletions": 1270}, "files": [{"sha": "21af342b1bf788ca448a08e8eecc50905ed4342b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -1145,3 +1145,52 @@ pub trait FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n+\n+#[cfg(not(stage0))]\n+mod impls {\n+    use marker::Sized;\n+    use super::{Fn, FnMut, FnOnce};\n+\n+    impl<'a,A,F:?Sized> Fn<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}, {"sha": "a4bb17bc354769d18a2253b7b9a0eb19421aa0f5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -120,6 +120,8 @@ pub mod middle {\n     pub mod traits;\n     pub mod ty;\n     pub mod ty_fold;\n+    pub mod ty_match;\n+    pub mod ty_relate;\n     pub mod ty_walk;\n     pub mod weak_lang_items;\n }"}, {"sha": "940dc75271c22f0a33d1585ab2af2a0eee1aede9", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -25,66 +25,54 @@\n //! In particular, it might be enough to say (A,B) are bivariant for\n //! all (A,B).\n \n-use middle::ty::BuiltinBounds;\n+use super::combine::{self, CombineFields};\n+use super::type_variable::{BiTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::cres;\n-use middle::infer::type_variable::BiTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Bivariate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Bivariate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n-    Bivariate { fields: cf }\n+impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Bivariate<'a, 'tcx> {\n+        Bivariate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Bivariate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Contravariant => self.tys(a, b),\n-            ty::Bivariant => self.tys(a, b),\n-        }\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Contravariant => self.regions(a, b),\n-            ty::Bivariant => self.regions(a, b),\n-        }\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, _: ty::Region) -> cres<'tcx, ty::Region> {\n-        Ok(a)\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n+        match variance {\n+            // If we have Foo<A> and Foo is invariant w/r/t A,\n+            // and we want to assert that\n+            //\n+            //     Foo<A> <: Foo<B> ||\n+            //     Foo<B> <: Foo<A>\n+            //\n+            // then still A must equal B.\n+            ty::Invariant => self.relate(a, b),\n+\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.relate(a, b),\n+            ty::Contravariant => self.relate(a, b),\n         }\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -109,17 +97,22 @@ impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, _: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n         let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n-        let c = try!(Combineable::combine(self, &a1, &b1));\n+        let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }\n }"}, {"sha": "86f12b669b35ebe42f714835d26cb2c5cb7a74dd", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 131, "deletions": 575, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -37,630 +37,155 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n-use super::{InferCtxt, cres};\n+use super::{InferCtxt};\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n-use middle::subst;\n-use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n-use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n+use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::BuiltinBounds;\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n-use syntax::ast::Unsafety;\n use syntax::ast;\n-use syntax::abi;\n use syntax::codemap::Span;\n \n-pub trait Combine<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n-    fn tag(&self) -> String;\n-\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n-\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n-    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n-    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n-\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n-\n-    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n-        debug!(\"{}.mts({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-\n-        if a.mutbl != b.mutbl {\n-            Err(ty::terr_mutability)\n-        } else {\n-            let mutbl = a.mutbl;\n-            let variance = match mutbl {\n-                ast::MutImmutable => ty::Covariant,\n-                ast::MutMutable => ty::Invariant,\n-            };\n-            let ty = try!(self.tys_with_variance(variance, a.ty, b.ty));\n-            Ok(ty::mt {ty: ty, mutbl: mutbl})\n-        }\n-    }\n-\n-    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>;\n-\n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n-\n-    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n-\n-    fn substs(&self,\n-              item_def_id: ast::DefId,\n-              a_subst: &subst::Substs<'tcx>,\n-              b_subst: &subst::Substs<'tcx>)\n-              -> cres<'tcx, subst::Substs<'tcx>>\n-    {\n-        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-               item_def_id.repr(self.infcx().tcx),\n-               a_subst.repr(self.infcx().tcx),\n-               b_subst.repr(self.infcx().tcx));\n-\n-        let variances = if self.infcx().tcx.variance_computed.get() {\n-            Some(ty::item_variances(self.infcx().tcx, item_def_id))\n-        } else {\n-            None\n-        };\n-        self.substs_variances(variances.as_ref().map(|v| &**v), a_subst, b_subst)\n-    }\n-\n-    fn substs_variances(&self,\n-                        variances: Option<&ty::ItemVariances>,\n-                        a_subst: &subst::Substs<'tcx>,\n-                        b_subst: &subst::Substs<'tcx>)\n-                        -> cres<'tcx, subst::Substs<'tcx>>\n-    {\n-        let mut substs = subst::Substs::empty();\n-\n-        for &space in &subst::ParamSpace::all() {\n-            let a_tps = a_subst.types.get_slice(space);\n-            let b_tps = b_subst.types.get_slice(space);\n-            let t_variances = variances.map(|v| v.types.get_slice(space));\n-            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n-            substs.types.replace(space, tps);\n-        }\n-\n-        match (&a_subst.regions, &b_subst.regions) {\n-            (&ErasedRegions, _) | (_, &ErasedRegions) => {\n-                substs.regions = ErasedRegions;\n-            }\n-\n-            (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-                for &space in &subst::ParamSpace::all() {\n-                    let a_regions = a.get_slice(space);\n-                    let b_regions = b.get_slice(space);\n-                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n-                    let regions = try!(relate_region_params(self,\n-                                                            r_variances,\n-                                                            a_regions,\n-                                                            b_regions));\n-                    substs.mut_regions().replace(space, regions);\n-                }\n-            }\n-        }\n-\n-        return Ok(substs);\n-\n-        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                      variances: Option<&[ty::Variance]>,\n-                                                      a_tys: &[Ty<'tcx>],\n-                                                      b_tys: &[Ty<'tcx>])\n-                                                      -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n-            if a_tys.len() != b_tys.len() {\n-                return Err(ty::terr_ty_param_size(expected_found(this,\n-                                                                 a_tys.len(),\n-                                                                 b_tys.len())));\n-            }\n-\n-            (0.. a_tys.len()).map(|i| {\n-                let a_ty = a_tys[i];\n-                let b_ty = b_tys[i];\n-                let v = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.tys_with_variance(v, a_ty, b_ty)\n-            }).collect()\n-        }\n-\n-        fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: Option<&[ty::Variance]>,\n-                                                        a_rs: &[ty::Region],\n-                                                        b_rs: &[ty::Region])\n-                                                        -> cres<'tcx, Vec<ty::Region>>\n-        {\n-            let tcx = this.infcx().tcx;\n-            let num_region_params = a_rs.len();\n-\n-            debug!(\"relate_region_params(\\\n-                   a_rs={}, \\\n-                   b_rs={},\n-                   variances={})\",\n-                   a_rs.repr(tcx),\n-                   b_rs.repr(tcx),\n-                   variances.repr(tcx));\n-\n-            assert_eq!(num_region_params,\n-                       variances.map_or(num_region_params,\n-                                        |v| v.len()));\n-\n-            assert_eq!(num_region_params, b_rs.len());\n-\n-            (0..a_rs.len()).map(|i| {\n-                let a_r = a_rs[i];\n-                let b_r = b_rs[i];\n-                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.regions_with_variance(variance, a_r, b_r)\n-            }).collect()\n-        }\n-    }\n-\n-    fn bare_fn_tys(&self, a: &ty::BareFnTy<'tcx>,\n-                   b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        Ok(ty::BareFnTy {unsafety: unsafety,\n-                         abi: abi,\n-                         sig: sig})\n-    }\n-\n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n-        if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n-        }\n-\n-        let inputs = try!(argvecs(self,\n-                                  &a.inputs,\n-                                  &b.inputs));\n-\n-        let output = try!(match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(self.tys(a_ty, b_ty)))),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n-                    expected_found(self, a != ty::FnDiverging, b != ty::FnDiverging))),\n-        });\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n-\n-\n-        fn argvecs<'tcx, C>(combiner: &C,\n-                            a_args: &[Ty<'tcx>],\n-                            b_args: &[Ty<'tcx>])\n-                            -> cres<'tcx, Vec<Ty<'tcx>>>\n-                            where C: Combine<'tcx> {\n-            if a_args.len() == b_args.len() {\n-                a_args.iter().zip(b_args.iter())\n-                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n-            } else {\n-                Err(ty::terr_arg_count)\n-            }\n-        }\n-    }\n-\n-    fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n-    }\n-\n-    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n-        if a != b {\n-            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<'tcx, abi::Abi> {\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n-        }\n-    }\n-\n-    fn projection_tys(&self,\n-                      a: &ty::ProjectionTy<'tcx>,\n-                      b: &ty::ProjectionTy<'tcx>)\n-                      -> cres<'tcx, ty::ProjectionTy<'tcx>>\n-    {\n-        if a.item_name != b.item_name {\n-            Err(ty::terr_projection_name_mismatched(\n-                expected_found(self, a.item_name, b.item_name)))\n-        } else {\n-            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n-            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n-        }\n-    }\n-\n-    fn projection_predicates(&self,\n-                             a: &ty::ProjectionPredicate<'tcx>,\n-                             b: &ty::ProjectionPredicate<'tcx>)\n-                             -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-    {\n-        let projection_ty = try!(self.projection_tys(&a.projection_ty, &b.projection_ty));\n-        let ty = try!(self.tys(a.ty, b.ty));\n-        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n-    }\n-\n-    fn projection_bounds(&self,\n-                         a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                         b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                         -> cres<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n-    {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(ty::terr_projection_bounds_length(expected_found(self, a.len(), b.len())))\n-        } else {\n-            a.iter()\n-                .zip(b.iter())\n-                .map(|(a, b)| self.binders(a, b))\n-                .collect()\n-        }\n-    }\n-\n-    fn existential_bounds(&self,\n-                          a: &ty::ExistentialBounds<'tcx>,\n-                          b: &ty::ExistentialBounds<'tcx>)\n-                          -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n-    {\n-        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n-        let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n-        let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n-        Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb,\n-                                   projection_bounds: pb })\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds>\n-    {\n-        // Two sets of builtin bounds are only relatable if they are\n-        // precisely the same (but see the coercion code).\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn trait_refs(&self,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>\n-    {\n-        // Different traits cannot be related\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(self.substs(a.def_id, a.substs, b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: self.tcx().mk_substs(substs) })\n-        }\n-    }\n-\n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>;\n-    // this must be overridden to do correctly, so as to account for higher-ranked\n-    // behavior\n-}\n-\n-pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n-}\n-\n-impl<'tcx,T> Combineable<'tcx> for Rc<T>\n-    where T : Combineable<'tcx>\n-{\n-    fn combine<C>(combiner: &C,\n-                  a: &Rc<T>,\n-                  b: &Rc<T>)\n-                  -> cres<'tcx, Rc<T>>\n-                  where C: Combine<'tcx> {\n-        Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.trait_refs(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &Ty<'tcx>,\n-                  b: &Ty<'tcx>)\n-                  -> cres<'tcx, Ty<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.tys(*a, *b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::ProjectionPredicate<'tcx>,\n-                  b: &ty::ProjectionPredicate<'tcx>)\n-                  -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.projection_predicates(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::FnSig<'tcx>,\n-                  b: &ty::FnSig<'tcx>)\n-                  -> cres<'tcx, ty::FnSig<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.fn_sigs(a, b)\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n }\n \n-pub fn expected_found<'tcx, C, T>(this: &C,\n-                                  a: T,\n-                                  b: T)\n-                                  -> ty::expected_found<T>\n-                                  where C: Combine<'tcx> {\n-    if this.a_is_expected() {\n-        ty::expected_found {expected: a, found: b}\n-    } else {\n-        ty::expected_found {expected: b, found: a}\n-    }\n-}\n-\n-pub fn super_tys<'tcx, C>(this: &C,\n-                          a: Ty<'tcx>,\n-                          b: Ty<'tcx>)\n-                          -> cres<'tcx, Ty<'tcx>>\n-                          where C: Combine<'tcx> {\n-    let tcx = this.infcx().tcx;\n-    let a_sty = &a.sty;\n-    let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n-    return match (a_sty, b_sty) {\n-        // The \"subtype\" ought to be handling cases involving var:\n-        (&ty::ty_infer(TyVar(_)), _)\n-        | (_, &ty::ty_infer(TyVar(_))) =>\n-            tcx.sess.bug(\n-                &format!(\"{}: bot and var types should have been handled ({},{})\",\n-                this.tag(),\n-                a.repr(this.infcx().tcx),\n-                b.repr(this.infcx().tcx))),\n-\n-        (&ty::ty_err, _) | (_, &ty::ty_err) => Ok(tcx.types.err),\n+pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       relation: &mut R,\n+                                       a: Ty<'tcx>,\n+                                       b: Ty<'tcx>)\n+                                       -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let a_is_expected = relation.a_is_expected();\n \n+    match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n-        (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(),\n-                                            a_id, b_id));\n+        (&ty::ty_infer(ty::IntVar(a_id)), &ty::ty_infer(ty::IntVar(b_id))) => {\n+            try!(infcx.int_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| int_unification_error(a_is_expected, e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_int(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, IntType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_int(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_int(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, IntType(v))\n+        (&ty::ty_int(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_uint(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, UintType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_uint(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n         }\n-        (&ty::ty_uint(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, UintType(v))\n+        (&ty::ty_uint(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n-        (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(), a_id, b_id));\n+        (&ty::ty_infer(ty::FloatVar(a_id)), &ty::ty_infer(ty::FloatVar(b_id))) => {\n+            try!(infcx.float_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| float_unification_error(relation.a_is_expected(), e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n-            unify_float_variable(this, this.a_is_expected(), v_id, v)\n-        }\n-        (&ty::ty_float(v), &ty::ty_infer(FloatVar(v_id))) => {\n-            unify_float_variable(this, !this.a_is_expected(), v_id, v)\n+        (&ty::ty_infer(ty::FloatVar(v_id)), &ty::ty_float(v)) => {\n+            unify_float_variable(infcx, a_is_expected, v_id, v)\n         }\n-\n-        (&ty::ty_char, _)\n-        | (&ty::ty_bool, _)\n-        | (&ty::ty_int(_), _)\n-        | (&ty::ty_uint(_), _)\n-        | (&ty::ty_float(_), _) => {\n-            if a == b {\n-                Ok(a)\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n+        (&ty::ty_float(v), &ty::ty_infer(ty::FloatVar(v_id))) => {\n+            unify_float_variable(infcx, !a_is_expected, v_id, v)\n         }\n \n-        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n-          a_p.idx == b_p.idx && a_p.space == b_p.space => Ok(a),\n-\n-        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        // All other cases of inference are errors\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) => {\n+            Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n-        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) => {\n-            debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-            let principal = try!(this.binders(&a_.principal, &b_.principal));\n-            let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n-            Ok(ty::mk_trait(tcx, principal, bounds))\n-        }\n-\n-        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n-\n-        (&ty::ty_closure(a_id, a_substs),\n-         &ty::ty_closure(b_id, b_substs))\n-          if a_id == b_id => {\n-            // All ty_closure types with the same id represent\n-            // the (anonymous) type of the same closure expression. So\n-            // all of their regions should be equated.\n-            let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n \n-        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = try!(this.tys(a_inner, b_inner));\n-            Ok(ty::mk_uniq(tcx, typ))\n-        }\n-\n-        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_ptr(tcx, mt))\n-        }\n-\n-        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n-        }\n-\n-        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n-                } else {\n-                    Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, sz_a))\n-                } else {\n-                    Err(ty::terr_sorts(expected_found(this, a, b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_str, &ty::ty_str) => Ok(ty::mk_str(tcx)),\n-\n-        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n-            if as_.len() == bs.len() {\n-                as_.iter().zip(bs.iter())\n-                   .map(|(a, b)| this.tys(*a, *b))\n-                   .collect::<Result<_, _>>()\n-                   .map(|ts| ty::mk_tup(tcx, ts))\n-            } else if as_.len() != 0 && bs.len() != 0 {\n-                Err(ty::terr_tuple_size(\n-                    expected_found(this, as_.len(), bs.len())))\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n-        }\n-\n-        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n-            if a_opt_def_id == b_opt_def_id =>\n-        {\n-            let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n-        }\n-\n-        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-            let projection_ty = try!(this.projection_tys(a_data, b_data));\n-            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n-        }\n-\n-        _ => Err(ty::terr_sorts(expected_found(this, a, b))),\n-    };\n-\n-    fn unify_integral_variable<'tcx, C>(this: &C,\n-                                        vid_is_expected: bool,\n-                                        vid: ty::IntVid,\n-                                        val: ty::IntVarValue)\n-                                        -> cres<'tcx, Ty<'tcx>>\n-                                        where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        match val {\n-            IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n+        _ => {\n+            ty_relate::super_relate_tys(relation, a, b)\n         }\n     }\n+}\n \n-    fn unify_float_variable<'tcx, C>(this: &C,\n-                                     vid_is_expected: bool,\n-                                     vid: ty::FloatVid,\n-                                     val: ast::FloatTy)\n-                                     -> cres<'tcx, Ty<'tcx>>\n-                                     where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        Ok(ty::mk_mach_float(this.tcx(), val))\n+fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                    vid_is_expected: bool,\n+                                    vid: ty::IntVid,\n+                                    val: ty::IntVarValue)\n+                                    -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .int_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| int_unification_error(vid_is_expected, e)));\n+    match val {\n+        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n+        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n     }\n }\n \n-impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n-    pub fn switch_expected(&self) -> CombineFields<'f, 'tcx> {\n+fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                 vid_is_expected: bool,\n+                                 vid: ty::FloatVid,\n+                                 val: ast::FloatTy)\n+                                 -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .float_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| float_unification_error(vid_is_expected, e)));\n+    Ok(ty::mk_mach_float(infcx.tcx, val))\n+}\n+\n+impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    fn equate(&self) -> Equate<'f, 'tcx> {\n-        Equate((*self).clone())\n+    pub fn equate(&self) -> Equate<'a, 'tcx> {\n+        Equate::new(self.clone())\n+    }\n+\n+    pub fn bivariate(&self) -> Bivariate<'a, 'tcx> {\n+        Bivariate::new(self.clone())\n+    }\n+\n+    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+        Sub::new(self.clone())\n     }\n \n-    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n-        Bivariate((*self).clone())\n+    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+        Lub::new(self.clone())\n     }\n \n-    fn sub(&self) -> Sub<'f, 'tcx> {\n-        Sub((*self).clone())\n+    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+        Glb::new(self.clone())\n     }\n \n     pub fn instantiate(&self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n-                       -> cres<'tcx, ()>\n+                       -> RelateResult<'tcx, ()>\n     {\n         let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n@@ -724,15 +249,12 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // relations wind up attributed to the same spans. We need\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n-            match dir {\n-                BiTo => try!(self.bivariate().tys(a_ty, b_ty)),\n-\n-                EqTo => try!(self.equate().tys(a_ty, b_ty)),\n-\n-                SubtypeOf => try!(self.sub().tys(a_ty, b_ty)),\n-\n-                SupertypeOf => try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty)),\n-            };\n+            try!(match dir {\n+                BiTo => self.bivariate().relate(&a_ty, &b_ty),\n+                EqTo => self.equate().relate(&a_ty, &b_ty),\n+                SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n+                SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n+            });\n         }\n \n         Ok(())\n@@ -746,7 +268,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> cres<'tcx, Ty<'tcx>>\n+                  -> RelateResult<'tcx, Ty<'tcx>>\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -839,3 +361,37 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.next_region_var(MiscVariable(self.span))\n     }\n }\n+\n+pub trait RelateResultCompare<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>;\n+}\n+\n+impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>,\n+    {\n+        self.clone().and_then(|s| {\n+            if s == t {\n+                self.clone()\n+            } else {\n+                Err(f())\n+            }\n+        })\n+    }\n+}\n+\n+fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n+                               -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_int_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+}\n+\n+fn float_unification_error<'tcx>(a_is_expected: bool,\n+                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_float_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+}"}, {"sha": "2003f459d89b42cb895625da636b8d3e74ecb04f", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -8,51 +8,43 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::combine::{self, CombineFields};\n+use super::higher_ranked::HigherRankedRelations;\n+use super::{Subtype};\n+use super::type_variable::{EqTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::cres;\n-use middle::infer::Subtype;\n-use middle::infer::type_variable::EqTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Equate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Equate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n-    Equate { fields: cf }\n+impl<'a, 'tcx> Equate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n+        Equate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Equate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.tys(a, b)\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.regions(a, b)\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n-        self.infcx().region_vars.make_eqregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               _: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n+    {\n+        self.relate(a, b)\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -77,15 +69,26 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n     {\n-        try!(self.sub().binders(a, b));\n-        self.sub().binders(b, a)\n+        try!(self.fields.higher_ranked_sub(a, b));\n+        self.fields.higher_ranked_sub(b, a)\n     }\n }"}, {"sha": "29f74d12ea3e814bb82c3030687b78d9eb7bd534", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -37,7 +37,7 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n+use super::unify::ToType;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -104,29 +104,38 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+\n         match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.freshen(self.infcx.type_variables.borrow().probe(v),\n-                               ty::TyVar(v),\n-                               ty::FreshTy)\n+                self.freshen(\n+                    self.infcx.type_variables.borrow().probe(v),\n+                    ty::TyVar(v),\n+                    ty::FreshTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::IntVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.int_unification_table.borrow_mut()\n+                                                    .probe(v)\n+                                                    .map(|v| v.to_type(tcx)),\n+                    ty::IntVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::FloatVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.float_unification_table.borrow_mut()\n+                                                      .probe(v)\n+                                                      .map(|v| v.to_type(tcx)),\n+                    ty::FloatVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FreshTy(c)) |\n             ty::ty_infer(ty::FreshIntTy(c)) => {\n                 if c >= self.freshen_count {\n-                    self.tcx().sess.bug(\n+                    tcx.sess.bug(\n                         &format!(\"Encountered a freshend type with id {} \\\n                                   but our counter is only at {}\",\n                                  c,"}, {"sha": "5822fb0f2d432fba8d7c3fe10959268c158d3fc4", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -8,67 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::lattice::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::cres;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Glb<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n-    Glb { fields: cf }\n+impl<'a, 'tcx> Glb<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n+        Glb { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Glb\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Glb\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.lub().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.lub().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.lub().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_glb(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_glb(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&v, &a));\n+        try!(sub.relate(&v, &b));\n+        Ok(())\n     }\n }"}, {"sha": "f347d28b93c2b0aa06f41e6e4dd00abedc938ae1", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -11,25 +11,26 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n-use super::combine::{Combine, Combineable};\n+use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::combine::CombineFields;\n \n use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n-pub trait HigherRankedRelations<'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+pub trait HigherRankedRelations<'a,'tcx> {\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n }\n \n trait InferCtxtExt {\n@@ -40,15 +41,15 @@ trait InferCtxtExt {\n                                         -> Vec<ty::RegionVid>;\n }\n \n-impl<'tcx,C> HigherRankedRelations<'tcx> for C\n-    where C : Combine<'tcx>\n-{\n+impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n-                            -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+                            -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n+        let tcx = self.infcx.tcx;\n+\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+               a.repr(tcx), b.repr(tcx));\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -60,32 +61,32 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(),\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(),\n                     HigherRankedType,\n                     a);\n \n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n             let (b_prime, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(b, snapshot);\n+                self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n-            debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+            debug!(\"a_prime={}\", a_prime.repr(tcx));\n+            debug!(\"b_prime={}\", b_prime.repr(tcx));\n \n             // Compare types now that bound regions have been replaced.\n-            let result = try!(Combineable::combine(self, &a_prime, &b_prime));\n+            let result = try!(self.sub().relate(&a_prime, &b_prime));\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match leak_check(self.infcx(), &skol_map, snapshot) {\n+            match leak_check(self.infcx, &skol_map, snapshot) {\n                 Ok(()) => { }\n                 Err((skol_br, tainted_region)) => {\n-                    if self.a_is_expected() {\n+                    if self.a_is_expected {\n                         debug!(\"Not as polymorphic!\");\n                         return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n                                                                                tainted_region));\n@@ -98,42 +99,42 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n \n             debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr(self.tcx()));\n+                   result.repr(tcx));\n \n             Ok(ty::Binder(result))\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace().origin.span();\n+            let span = self.trace.origin.span();\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, a);\n             let (b_with_fresh, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, b);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars, &a_map, r));\n \n             debug!(\"lub({},{}) = {}\",\n@@ -194,40 +195,40 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        debug!(\"{}.higher_ranked_glb({}, {})\",\n-               self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"higher_ranked_glb({}, {})\",\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, a);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, a);\n             let (b_with_fresh, b_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, b);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, b);\n             let a_vars = var_ids(self, &a_map);\n             let b_vars = var_ids(self, &b_map);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars,\n                                                     &a_map, &a_vars, &b_vars,\n                                                     r));\n@@ -332,17 +333,19 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     }\n }\n \n-fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n-                                   map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                                   -> Vec<ty::RegionVid> {\n-    map.iter().map(|(_, r)| match *r {\n-            ty::ReInfer(ty::ReVar(r)) => { r }\n-            r => {\n-                combiner.infcx().tcx.sess.span_bug(\n-                    combiner.trace().origin.span(),\n-                    &format!(\"found non-region-vid: {:?}\", r));\n-            }\n-        }).collect()\n+fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n+                      map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                     -> Vec<ty::RegionVid> {\n+    map.iter()\n+       .map(|(_, r)| match *r {\n+           ty::ReInfer(ty::ReVar(r)) => { r }\n+           r => {\n+               fields.tcx().sess.span_bug(\n+                   fields.trace.origin.span(),\n+                   &format!(\"found non-region-vid: {:?}\", r));\n+           }\n+       })\n+       .collect()\n }\n \n fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n@@ -356,8 +359,8 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n                                unbound_value: &T,\n                                mut fldr: F)\n                                -> T\n-    where T : Combineable<'tcx>,\n-          F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+    where T: TypeFoldable<'tcx>,\n+          F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n     unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "57001083b03e200e410d7fa0e9de3a76854a09a4", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -29,48 +29,32 @@\n //! over a `LatticeValue`, which is a value defined with respect to\n //! a lattice.\n \n-use super::*;\n-use super::combine::*;\n-use super::glb::Glb;\n-use super::lub::Lub;\n+use super::combine;\n+use super::InferCtxt;\n \n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n+use middle::ty_relate::{RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-pub trait LatticeDir<'tcx> {\n+pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()>;\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Lub<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(a, v));\n-        try!(sub.tys(b, v));\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Glb<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(v, a));\n-        try!(sub.tys(v, b));\n-        Ok(())\n-    }\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n-                                                                 a: Ty<'tcx>,\n-                                                                 b: Ty<'tcx>)\n-                                                                 -> cres<'tcx, Ty<'tcx>>\n+pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n+                                                        a: Ty<'tcx>,\n+                                                        b: Ty<'tcx>)\n+                                                        -> RelateResult<'tcx, Ty<'tcx>>\n+    where 'tcx: 'a\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n-           a.repr(this.infcx().tcx),\n-           b.repr(this.infcx().tcx));\n+           a.repr(this.tcx()),\n+           b.repr(this.tcx()));\n \n     if a == b {\n         return Ok(a);\n@@ -95,7 +79,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n         }\n \n         _ => {\n-            super_tys(this, a, b)\n+            combine::super_combine_tys(this.infcx(), this, a, b)\n         }\n     }\n }"}, {"sha": "f456687be13ac49567537768bfdc0c72f4a4a6a5", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -8,67 +8,80 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lattice::*;\n-use super::cres;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Lub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n-    Lub { fields: cf }\n+impl<'a, 'tcx> Lub<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n+        Lub { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Lub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Lub\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.glb().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.glb().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.glb().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n \n-        Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_lub(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_lub(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&a, &v));\n+        try!(sub.relate(&b, &v));\n+        Ok(())\n     }\n }\n+"}, {"sha": "da811c354578de5bbc4747c3439fe9f8efa74a5c", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 96, "deletions": 146, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -28,7 +28,8 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use std::cell::RefCell;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use std::cell::{RefCell};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -38,12 +39,9 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n \n-use self::combine::{Combine, Combineable, CombineFields};\n+use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::equate::Equate;\n-use self::sub::Sub;\n-use self::lub::Lub;\n-use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n+use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n \n pub mod bivariate;\n@@ -62,9 +60,7 @@ pub mod type_variable;\n pub mod unify;\n \n pub type Bound<T> = Option<T>;\n-\n-pub type cres<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n-pub type ures<'tcx> = cres<'tcx, ()>; // \"unify result\"\n+pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n@@ -265,7 +261,7 @@ pub enum LateBoundRegionConversionTime {\n ///\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n-pub enum RegionVariableOrigin<'tcx> {\n+pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n     MiscVariable(Span),\n@@ -280,7 +276,7 @@ pub enum RegionVariableOrigin<'tcx> {\n     Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(TypeTrace<'tcx>),\n+    Coercion(Span),\n \n     // Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, ast::Name),\n@@ -343,8 +339,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result =\n-        cx.commit_if_ok(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n+    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).relate(&a, &b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -359,29 +354,28 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           origin: TypeOrigin,\n                           a: Ty<'tcx>,\n                           b: Ty<'tcx>)\n-                          -> ures<'tcx>\n+                          -> UnitResult<'tcx>\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(|| {\n-        cx.sub_types(a_is_expected, origin, a, b)\n-    })\n+    cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               a: Ty<'tcx>,\n                               b: Ty<'tcx>)\n-                              -> ures<'tcx> {\n+                              -> UnitResult<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).tys(a, b).to_ures()\n+        cx.sub(true, trace).relate(&a, &b).map(|_| ())\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> ures<'tcx>\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+                             -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -401,24 +395,22 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: TypeOrigin,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n-                         -> ures<'tcx>\n+                         -> UnitResult<'tcx>\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.eq_types(a_is_expected, origin, a, b))\n+    cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n                                    a: ty::PolyTraitRef<'tcx>,\n                                    b: ty::PolyTraitRef<'tcx>)\n-                                   -> ures<'tcx>\n+                                   -> UnitResult<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+    cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -433,57 +425,6 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-trait then<'tcx> {\n-    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n-        T: Clone,\n-        F: FnOnce() -> Result<T, ty::type_err<'tcx>>;\n-}\n-\n-impl<'tcx> then<'tcx> for ures<'tcx> {\n-    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n-        T: Clone,\n-        F: FnOnce() -> Result<T, ty::type_err<'tcx>>,\n-    {\n-        self.and_then(move |_| f())\n-    }\n-}\n-\n-trait ToUres<'tcx> {\n-    fn to_ures(&self) -> ures<'tcx>;\n-}\n-\n-impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n-    fn to_ures(&self) -> ures<'tcx> {\n-        match *self {\n-          Ok(ref _v) => Ok(()),\n-          Err(ref e) => Err((*e))\n-        }\n-    }\n-}\n-\n-trait CresCompare<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>;\n-}\n-\n-impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>,\n-    {\n-        (*self).clone().and_then(move |s| {\n-            if s == t {\n-                (*self).clone()\n-            } else {\n-                Err(f())\n-            }\n-        })\n-    }\n-}\n-\n-pub fn uok<'tcx>() -> ures<'tcx> {\n-    Ok(())\n-}\n-\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n     type_snapshot: type_variable::Snapshot,\n@@ -512,41 +453,56 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::ty_infer(ty::IntVar(vid)) => {\n-                match self.int_unification_table.borrow_mut().get(self.tcx, vid).value {\n-                    None => UnconstrainedInt,\n-                    _ => Neither,\n+                if self.int_unification_table.borrow_mut().has_value(vid) {\n+                    Neither\n+                } else {\n+                    UnconstrainedInt\n                 }\n             },\n             ty::ty_infer(ty::FloatVar(vid)) => {\n-                match self.float_unification_table.borrow_mut().get(self.tcx, vid).value {\n-                    None => return UnconstrainedFloat,\n-                    _ => Neither,\n+                if self.float_unification_table.borrow_mut().has_value(vid) {\n+                    Neither\n+                } else {\n+                    UnconstrainedFloat\n                 }\n             },\n             _ => Neither,\n         }\n     }\n \n-    pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                              -> CombineFields<'b, 'tcx> {\n+    fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> Equate<'b, 'tcx> {\n-        Equate(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn equate(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+              -> equate::Equate<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).equate()\n     }\n \n-    pub fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Sub<'b, 'tcx> {\n-        Sub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn sub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> sub::Sub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).sub()\n     }\n \n-    pub fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Lub<'b, 'tcx> {\n-        Lub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn lub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> lub::Lub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).lub()\n+    }\n+\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn glb(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> glb::Glb<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).glb()\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -609,11 +565,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if successful\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n     {\n-        self.commit_unconditionally(move || self.try(move |_| f()))\n+        debug!(\"commit_if_ok()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n+        match r {\n+            Ok(_) => { self.commit_from(snapshot); }\n+            Err(_) => { self.rollback_to(snapshot); }\n+        }\n+        r\n     }\n \n     /// Execute `f` and commit only the region bindings if successful.\n@@ -628,7 +592,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                float_snapshot,\n                                region_vars_snapshot } = self.start_snapshot();\n \n-        let r = self.try(move |_| f());\n+        let r = self.commit_if_ok(|_| f());\n \n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n@@ -649,25 +613,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f`, unroll bindings on panic\n-    pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n-    {\n-        debug!(\"try()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n-        match r {\n-            Ok(_) => {\n-                self.commit_from(snapshot);\n-            }\n-            Err(_) => {\n-                self.rollback_to(snapshot);\n-            }\n-        }\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,\n@@ -691,12 +636,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      origin: TypeOrigin,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-                     -> ures<'tcx>\n+                     -> UnitResult<'tcx>\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -705,11 +650,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     origin: TypeOrigin,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n-                    -> ures<'tcx>\n+                    -> UnitResult<'tcx>\n     {\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -718,17 +663,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           origin: TypeOrigin,\n                           a: Rc<ty::TraitRef<'tcx>>,\n                           b: Rc<ty::TraitRef<'tcx>>)\n-                          -> ures<'tcx>\n+                          -> UnitResult<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&*a, &*b).map(|_| ())\n         })\n     }\n \n@@ -737,17 +682,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n-                               -> ures<'tcx>\n+                               -> UnitResult<'tcx>\n     {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).binders(&a, &b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -774,7 +719,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(&self,\n                       skol_map: &SkolemizationMap,\n                       snapshot: &CombinedSnapshot)\n-                      -> ures<'tcx>\n+                      -> UnitResult<'tcx>\n     {\n         /*! See `higher_ranked::leak_check` */\n \n@@ -799,8 +744,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n-                              -> ures<'tcx> {\n-        self.try(|snapshot| {\n+                              -> UnitResult<'tcx> {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = EquatePredicate(span);\n@@ -812,8 +757,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n-                                     -> ures<'tcx> {\n-        self.try(|snapshot| {\n+                                     -> UnitResult<'tcx> {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n@@ -852,7 +797,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -948,12 +893,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.probe_var(v)\n+                self.int_unification_table\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.probe_var(v)\n+                self.float_unification_table\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n@@ -1104,8 +1055,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n-    pub fn can_equate<T>(&self, a: &T, b: &T) -> ures<'tcx>\n-        where T : Combineable<'tcx> + Repr<'tcx>\n+    pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n+        where T: Relate<'b,'tcx> + Repr<'tcx>\n     {\n         debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.probe(|_| {\n@@ -1116,9 +1067,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let e = self.tcx.types.err;\n             let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n                                     values: Types(expected_found(true, e, e)) };\n-            let eq = self.equate(true, trace);\n-            Combineable::combine(&eq, a, b)\n-        }).to_ures()\n+            self.equate(true, trace).relate(a, b)\n+        }).map(|_| ())\n     }\n }\n \n@@ -1304,14 +1254,14 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> RegionVariableOrigin<'tcx> {\n+impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n             PatternRegion(a) => a,\n             AddrOfRegion(a) => a,\n             Autoref(a) => a,\n-            Coercion(ref a) => a.span(),\n+            Coercion(a) => a,\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _, _) => a,\n             BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n@@ -1320,7 +1270,7 @@ impl<'tcx> RegionVariableOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n+impl<'tcx> Repr<'tcx> for RegionVariableOrigin {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             MiscVariable(a) => {\n@@ -1333,7 +1283,7 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n                 format!(\"AddrOfRegion({})\", a.repr(tcx))\n             }\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }"}, {"sha": "98347e97e09c3cb498a7692c76b7f59533a7564b", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -18,14 +18,14 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n use self::Classification::*;\n \n-use super::cres;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n+use middle::ty_relate::RelateResult;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n@@ -115,7 +115,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin<'tcx>,\n+    SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n@@ -124,15 +124,15 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `v <= r1` (due to\n     /// `origin1`) and `v <= r2` (due to `origin2`) and\n     /// `r1` and `r2` have no intersection.\n-    SupSupConflict(RegionVariableOrigin<'tcx>,\n+    SupSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin<'tcx>>,\n+    ProcessedErrors(Vec<RegionVariableOrigin>,\n                     Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n                     Vec<SameRegions>),\n }\n@@ -168,7 +168,7 @@ pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin<'tcx>>>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         len as u32\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { index: id };\n@@ -798,7 +798,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// regions are given as argument, in any order, a consistent result is returned.\n     fn lub_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> ty::Region\n+                        b: &FreeRegion)\n+                        -> ty::Region\n     {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n@@ -823,7 +824,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_concrete_regions(&self,\n                             a: Region,\n                             b: Region)\n-                         -> cres<'tcx, Region> {\n+                            -> RelateResult<'tcx, Region>\n+    {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n@@ -898,7 +900,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// returned.\n     fn glb_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> cres<'tcx, ty::Region>\n+                        b: &FreeRegion)\n+                        -> RelateResult<'tcx, ty::Region>\n     {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n@@ -908,7 +911,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n                             a: &FreeRegion,\n-                            b: &FreeRegion) -> cres<'tcx, ty::Region>\n+                            b: &FreeRegion) -> RelateResult<'tcx, ty::Region>\n         {\n             if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n@@ -926,7 +929,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n                         scope_a: region::CodeExtent,\n-                        scope_b: region::CodeExtent) -> cres<'tcx, Region>\n+                        scope_b: region::CodeExtent)\n+                        -> RelateResult<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of"}, {"sha": "31b654a5b3fd3b5fcfba885019ade59349aa69a6", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -8,64 +8,49 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::cres;\n+use super::combine::{self, CombineFields};\n use super::higher_ranked::HigherRankedRelations;\n use super::Subtype;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Sub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Sub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n-    Sub { fields: cf }\n+impl<'a, 'tcx> Sub<'a, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n+        Sub { fields: f }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Sub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n-\n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n-        }\n-    }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Sub\" }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.infcx.tcx }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.switch_expected().sub().relate(b, a),\n         }\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-        self.infcx().region_vars.make_subregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n-    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -80,8 +65,8 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 try!(self.fields\n-                       .switch_expected()\n-                       .instantiate(b, SupertypeOf, a_id));\n+                         .switch_expected()\n+                         .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n@@ -94,14 +79,25 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        self.higher_ranked_sub(a, b)\n+        self.fields.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "39271d4cdc597cb8f448c5dc8205f568b92164ee", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 82, "deletions": 160, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -12,11 +12,8 @@ pub use self::VarValue::*;\n \n use std::marker;\n \n-use middle::ty::{expected_found, IntVarValue};\n+use middle::ty::{IntVarValue};\n use middle::ty::{self, Ty};\n-use middle::infer::{uok, ures};\n-use middle::infer::InferCtxt;\n-use std::cell::RefCell;\n use std::fmt::Debug;\n use std::marker::PhantomData;\n use syntax::ast;\n@@ -35,14 +32,9 @@ use util::snapshot_vec as sv;\n pub trait UnifyKey : Clone + Debug + PartialEq {\n     type Value : UnifyValue;\n \n-    fn index(&self) -> usize;\n+    fn index(&self) -> u32;\n \n-    fn from_index(u: usize) -> Self;\n-\n-    // Given an inference context, returns the unification table\n-    // appropriate to this key type.\n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self>>;\n+    fn from_index(u: u32) -> Self;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n@@ -130,21 +122,25 @@ impl<K:UnifyKey> UnificationTable<K> {\n \n     pub fn new_key(&mut self, value: K::Value) -> K {\n         let index = self.values.push(Root(value, 0));\n-        let k = UnifyKey::from_index(index);\n+        let k = UnifyKey::from_index(index as u32);\n         debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k\n     }\n \n-    /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n-    /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n-        let index = vid.index();\n+    /// Find the root node for `vid`. This uses the standard\n+    /// union-find algorithm with path compression:\n+    /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n+    ///\n+    /// NB. This is a building-block operation and you would probably\n+    /// prefer to call `probe` below.\n+    fn get(&mut self, vid: K) -> Node<K> {\n+        let index = vid.index() as usize;\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -158,58 +154,58 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n \n     fn is_root(&self, key: &K) -> bool {\n-        match *self.values.get(key.index()) {\n+        let index = key.index() as usize;\n+        match *self.values.get(index) {\n             Redirect(..) => false,\n             Root(..) => true,\n         }\n     }\n \n-    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n-    /// middle of a snapshot.\n-    pub fn set<'tcx>(&mut self,\n-                     _tcx: &ty::ctxt<'tcx>,\n-                     key: K,\n-                     new_value: VarValue<K>)\n-    {\n+    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n+    /// node! This is an internal operation used to impl other things.\n+    fn set(&mut self, key: K, new_value: VarValue<K>) {\n         assert!(self.is_root(&key));\n \n         debug!(\"Updating variable {:?} to {:?}\",\n                key, new_value);\n \n-        self.values.set(key.index(), new_value);\n+        let index = key.index() as usize;\n+        self.values.set(index, new_value);\n     }\n \n-    /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n-    /// the new root and rank. You should then update the value of the new root to something\n-    /// suitable.\n-    pub fn unify<'tcx>(&mut self,\n-                       tcx: &ty::ctxt<'tcx>,\n-                       node_a: &Node<K>,\n-                       node_b: &Node<K>)\n-                       -> (K, usize)\n-    {\n+    /// Either redirects `node_a` to `node_b` or vice versa, depending\n+    /// on the relative rank. The value associated with the new root\n+    /// will be `new_value`.\n+    ///\n+    /// NB: This is the \"union\" operation of \"union-find\". It is\n+    /// really more of a building block. If the values associated with\n+    /// your key are non-trivial, you would probably prefer to call\n+    /// `unify_var_var` below.\n+    fn unify(&mut self, node_a: &Node<K>, node_b: &Node<K>, new_value: K::Value) {\n         debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n                node_a.key,\n                node_a.rank,\n                node_b.key,\n                node_b.rank);\n \n-        if node_a.rank > node_b.rank {\n+        let (new_root, new_rank) = if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(tcx, node_a.key.clone(), Redirect(node_b.key.clone()));\n+            self.set(node_a.key.clone(), Redirect(node_b.key.clone()));\n             (node_b.key.clone(), node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank + 1)\n-        }\n+        };\n+\n+        self.set(new_root, Root(new_value, new_rank));\n     }\n }\n \n@@ -223,165 +219,104 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Code to handle simple keys like ints, floats---anything that\n-// doesn't have a subtyping relationship we need to worry about.\n-\n-/// Indicates a type that does not have any kind of subtyping\n-/// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n-    fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n-}\n-\n-pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n-                                          a_t: V,\n-                                          b_t: V)\n-                                          -> ures<'tcx> {\n-    if a_is_expected {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: a_t, found: b_t}))\n-    } else {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: b_t, found: a_t}))\n-    }\n-}\n-\n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n-{\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures<'tcx>;\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> ures<'tcx>;\n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n-}\n-\n-impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n+// Code to handle keys which carry a value, like ints,\n+// floats---anything that doesn't have a subtyping relationship we\n+// need to worry about.\n+\n+impl<'tcx,K,V> UnificationTable<K>\n+    where K: UnifyKey<Value=Option<V>>,\n+          V: Clone+PartialEq,\n+          Option<V>: UnifyValue,\n {\n-    /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n-    /// both keys have already been associated with a value, then those two values must be the\n-    /// same.\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures<'tcx>\n+    pub fn unify_var_var(&mut self,\n+                         a_id: K,\n+                         b_id: K)\n+                         -> Result<(),(V,V)>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n-        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n-        if a_id == b_id { return uok(); }\n+        if a_id == b_id { return Ok(()); }\n \n         let combined = {\n             match (&node_a.value, &node_b.value) {\n                 (&None, &None) => {\n                     None\n                 }\n                 (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n-                    Some((*v).clone())\n+                    Some(v.clone())\n                 }\n                 (&Some(ref v1), &Some(ref v2)) => {\n                     if *v1 != *v2 {\n-                        return err(a_is_expected, (*v1).clone(), (*v2).clone())\n+                        return Err((v1.clone(), v2.clone()));\n                     }\n-                    Some((*v1).clone())\n+                    Some(v1.clone())\n                 }\n             }\n         };\n \n-        let (new_root, new_rank) = table.borrow_mut().unify(tcx,\n-                                                            &node_a,\n-                                                            &node_b);\n-        table.borrow_mut().set(tcx, new_root, Root(combined, new_rank));\n-        return Ok(())\n+        Ok(self.unify(&node_a, &node_b, combined))\n     }\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n     /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> ures<'tcx>\n+    pub fn unify_var_value(&mut self,\n+                           a_id: K,\n+                           b: V)\n+                           -> Result<(),(V,V)>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let node_a = self.get(a_id);\n         let a_id = node_a.key.clone();\n \n         match node_a.value {\n             None => {\n-                table.borrow_mut().set(tcx, a_id, Root(Some(b), node_a.rank));\n-                return Ok(());\n+                self.set(a_id, Root(Some(b), node_a.rank));\n+                Ok(())\n             }\n \n             Some(ref a_t) => {\n                 if *a_t == b {\n-                    return Ok(());\n+                    Ok(())\n                 } else {\n-                    return err(a_is_expected, (*a_t).clone(), b);\n+                    Err((a_t.clone(), b))\n                 }\n             }\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        match node_a.value {\n-            None => None,\n-            Some(ref a_t) => Some(a_t.to_type(tcx))\n-        }\n+    pub fn has_value(&mut self, id: K) -> bool {\n+        self.get(id).value.is_some()\n+    }\n+\n+    pub fn probe(&mut self, a_id: K) -> Option<V> {\n+        self.get(a_id).value.clone()\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n // Integral type keys\n \n+pub trait ToType<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+}\n+\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n-\n-    fn index(&self) -> usize { self.index as usize }\n-\n-    fn from_index(i: usize) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n-        return &infcx.int_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::IntVid>) -> &'static str {\n-        \"IntVid\"\n-    }\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n+impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(tcx, i),\n             ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n         }\n     }\n-\n-    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err<'tcx> {\n-        return ty::terr_int_mismatch(err);\n-    }\n }\n \n impl UnifyValue for Option<IntVarValue> { }\n@@ -390,29 +325,16 @@ impl UnifyValue for Option<IntVarValue> { }\n \n impl UnifyKey for ty::FloatVid {\n     type Value = Option<ast::FloatTy>;\n-\n-    fn index(&self) -> usize { self.index as usize }\n-\n-    fn from_index(i: usize) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n-        return &infcx.float_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str {\n-        \"FloatVid\"\n-    }\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n }\n \n impl UnifyValue for Option<ast::FloatTy> {\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n+impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         ty::mk_mach_float(tcx, *self)\n     }\n-\n-    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {\n-        ty::terr_float_mismatch(err)\n-    }\n }"}, {"sha": "7488b8f046e74eff8215258fe5127b4c99895384", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -81,7 +81,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n \n@@ -291,6 +291,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n     }\n }\n \n+#[derive(Clone)]\n pub struct Normalized<'tcx,T> {\n     pub value: T,\n     pub obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "bb2d37c944c86d3833f61e6943cd5e2e748f9dec", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -39,11 +39,13 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n+use middle::ty_match;\n+use middle::ty_relate::TypeRelation;\n use std::cell::RefCell;\n-use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::{abi, ast};\n use util::common::ErrorReported;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n@@ -87,8 +89,8 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n-                             SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+    hashmap: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -474,7 +476,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.fresh_trait_ref.def_id() == prev.fresh_trait_ref.def_id()))\n+                  |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n+                                                     &prev.fresh_trait_ref)))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.fresh_trait_ref.repr(self.tcx()));\n@@ -1271,7 +1274,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let bound_self_ty =\n                 self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n             let (self_ty, _) =\n@@ -1808,7 +1811,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // For each type, produce a vector of resulting obligations\n         let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let (skol_ty, skol_map) =\n                     self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n@@ -1918,7 +1921,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     obligation: &TraitObligation<'tcx>)\n     {\n         let _: Result<(),()> =\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let result =\n                     self.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                                snapshot);\n@@ -2073,7 +2076,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.commit_if_ok(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n@@ -2107,7 +2110,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n             let substs =\n@@ -2505,6 +2508,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n+    fn match_fresh_trait_refs(&self,\n+                              previous: &ty::PolyTraitRef<'tcx>,\n+                              current: &ty::PolyTraitRef<'tcx>)\n+                              -> bool\n+    {\n+        let mut matcher = ty_match::Match::new(self.tcx());\n+        matcher.relate(previous, current).is_ok()\n+    }\n+\n     fn push_stack<'o,'s:'o>(&mut self,\n                             previous_stack: TraitObligationStackList<'s, 'tcx>,\n                             obligation: &'o TraitObligation<'tcx>)\n@@ -2664,7 +2676,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n-            hashmap: RefCell::new(HashMap::new())\n+            hashmap: RefCell::new(FnvHashMap())\n         }\n     }\n }"}, {"sha": "5f77574f65ed4351692f8cc5868678bd73117b25", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -39,6 +39,8 @@ use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use middle::traits;\n use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n@@ -47,7 +49,7 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx> {\n+pub trait TypeFoldable<'tcx>: Repr<'tcx> + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -149,12 +151,20 @@ pub trait TypeFolder<'tcx> : Sized {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-impl<'tcx> TypeFoldable<'tcx> for () {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n-        ()\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+            }\n+        )+\n     }\n }\n \n+CopyImpls! { (), ast::Unsafety, abi::Abi }\n+\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))"}, {"sha": "bb00fadc39c95c062ab61c9ccc3b04794797e9ef", "filename": "src/librustc/middle/ty_match.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self, Ty};\n+use middle::ty_relate::{self, Relate, TypeRelation, RelateResult};\n+use util::ppaux::Repr;\n+\n+/// A type \"A\" *matches* \"B\" if the fresh types in B could be\n+/// substituted with values so as to make it equal to A. Matching is\n+/// intended to be used only on freshened types, and it basically\n+/// indicates if the non-freshened versions of A and B could have been\n+/// unified.\n+///\n+/// It is only an approximation. If it yields false, unification would\n+/// definitely fail, but a true result doesn't mean unification would\n+/// succeed. This is because we don't track the \"side-constraints\" on\n+/// type variables, nor do we track if the same freshened type appears\n+/// more than once. To some extent these approximations could be\n+/// fixed, given effort.\n+///\n+/// Like subtyping, matching is really a binary relation, so the only\n+/// important thing about the result is Ok/Err. Also, matching never\n+/// affects any type variables or unification state.\n+pub struct Match<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n+}\n+\n+impl<'a, 'tcx> Match<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> Match<'a, 'tcx> {\n+        Match { tcx: tcx }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Match\" }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn a_is_expected(&self) -> bool { true } // irrelevant\n+\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               _: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n+    {\n+        self.relate(a, b)\n+    }\n+\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        Ok(a)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n+        if a == b { return Ok(a); }\n+\n+        match (&a.sty, &b.sty) {\n+            (_, &ty::ty_infer(ty::FreshTy(_))) |\n+            (_, &ty::ty_infer(ty::FreshIntTy(_))) => {\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(_), _) |\n+            (_, &ty::ty_infer(_)) => {\n+                Err(ty::terr_sorts(ty_relate::expected_found(self, &a, &b)))\n+            }\n+\n+            (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+                Ok(self.tcx().types.err)\n+            }\n+\n+            _ => {\n+                ty_relate::super_relate_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n+    {\n+        Ok(ty::Binder(try!(self.relate(a.skip_binder(), b.skip_binder()))))\n+    }\n+}"}, {"sha": "1205b7d957930aaf8f25a0f540efe074a62f43f9", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generalized type relating mechanism. A type relation R relates a\n+//! pair of values (A, B). A and B are usually types or regions but\n+//! can be other things. Examples of type relations are subtyping,\n+//! type equality, etc.\n+\n+use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::TypeFoldable;\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n+\n+pub trait TypeRelation<'a,'tcx> : Sized {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx>;\n+\n+    /// Returns a static string we can use for printouts.\n+    fn tag(&self) -> &'static str;\n+\n+    /// Returns true if the value `a` is the \"expected\" type in the\n+    /// relation. Just affects error messages.\n+    fn a_is_expected(&self) -> bool;\n+\n+    /// Generic relation routine suitable for most anything.\n+    fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+        Relate::relate(self, a, b)\n+    }\n+\n+    /// Switch variance for the purpose of relating `a` and `b`.\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>;\n+\n+    // Overrideable relations. You shouldn't typically call these\n+    // directly, instead call `relate()`, which in turn calls\n+    // these. This is both more uniform but also allows us to add\n+    // additional hooks for other types in the future if needed\n+    // without making older code, which called `relate`, obsolete.\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n+           -> RelateResult<'tcx, Ty<'tcx>>;\n+\n+    fn regions(&mut self, a: ty::Region, b: ty::Region)\n+               -> RelateResult<'tcx, ty::Region>;\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>;\n+}\n+\n+pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n+    fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n+                                       a: &Self,\n+                                       b: &Self)\n+                                       -> RelateResult<'tcx, Self>;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Relate impls\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::mt<'tcx>,\n+                 b: &ty::mt<'tcx>)\n+                 -> RelateResult<'tcx, ty::mt<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        debug!(\"{}.mts({}, {})\",\n+               relation.tag(),\n+               a.repr(relation.tcx()),\n+               b.repr(relation.tcx()));\n+        if a.mutbl != b.mutbl {\n+            Err(ty::terr_mutability)\n+        } else {\n+            let mutbl = a.mutbl;\n+            let variance = match mutbl {\n+                ast::MutImmutable => ty::Covariant,\n+                ast::MutMutable => ty::Invariant,\n+            };\n+            let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n+            Ok(ty::mt {ty: ty, mutbl: mutbl})\n+        }\n+    }\n+}\n+\n+// substitutions are not themselves relatable without more context,\n+// but they is an important subroutine for things that ARE relatable,\n+// like traits etc.\n+fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                                    item_def_id: ast::DefId,\n+                                    a_subst: &Substs<'tcx>,\n+                                    b_subst: &Substs<'tcx>)\n+                                    -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+           item_def_id.repr(relation.tcx()),\n+           a_subst.repr(relation.tcx()),\n+           b_subst.repr(relation.tcx()));\n+\n+    let variances;\n+    let opt_variances = if relation.tcx().variance_computed.get() {\n+        variances = ty::item_variances(relation.tcx(), item_def_id);\n+        Some(&*variances)\n+    } else {\n+        None\n+    };\n+    relate_substs(relation, opt_variances, a_subst, b_subst)\n+}\n+\n+fn relate_substs<'a,'tcx,R>(relation: &mut R,\n+                            variances: Option<&ty::ItemVariances>,\n+                            a_subst: &Substs<'tcx>,\n+                            b_subst: &Substs<'tcx>)\n+                            -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let mut substs = Substs::empty();\n+\n+    for &space in &ParamSpace::all() {\n+        let a_tps = a_subst.types.get_slice(space);\n+        let b_tps = b_subst.types.get_slice(space);\n+        let t_variances = variances.map(|v| v.types.get_slice(space));\n+        let tps = try!(relate_type_params(relation, t_variances, a_tps, b_tps));\n+        substs.types.replace(space, tps);\n+    }\n+\n+    match (&a_subst.regions, &b_subst.regions) {\n+        (&ErasedRegions, _) | (_, &ErasedRegions) => {\n+            substs.regions = ErasedRegions;\n+        }\n+\n+        (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n+            for &space in &ParamSpace::all() {\n+                let a_regions = a.get_slice(space);\n+                let b_regions = b.get_slice(space);\n+                let r_variances = variances.map(|v| v.regions.get_slice(space));\n+                let regions = try!(relate_region_params(relation,\n+                                                        r_variances,\n+                                                        a_regions,\n+                                                        b_regions));\n+                substs.mut_regions().replace(space, regions);\n+            }\n+        }\n+    }\n+\n+    Ok(substs)\n+}\n+\n+fn relate_type_params<'a,'tcx,R>(relation: &mut R,\n+                                 variances: Option<&[ty::Variance]>,\n+                                 a_tys: &[Ty<'tcx>],\n+                                 b_tys: &[Ty<'tcx>])\n+                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_tys.len() != b_tys.len() {\n+        return Err(ty::terr_ty_param_size(expected_found(relation,\n+                                                         &a_tys.len(),\n+                                                         &b_tys.len())));\n+    }\n+\n+    (0 .. a_tys.len())\n+        .map(|i| {\n+            let a_ty = a_tys[i];\n+            let b_ty = b_tys[i];\n+            let v = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(v, &a_ty, &b_ty)\n+        })\n+        .collect()\n+}\n+\n+fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n+                                      variances: Option<&[ty::Variance]>,\n+                                      a_rs: &[ty::Region],\n+                                      b_rs: &[ty::Region])\n+                                      -> RelateResult<'tcx, Vec<ty::Region>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let num_region_params = a_rs.len();\n+\n+    debug!(\"relate_region_params(a_rs={}, \\\n+            b_rs={}, variances={})\",\n+           a_rs.repr(tcx),\n+           b_rs.repr(tcx),\n+           variances.repr(tcx));\n+\n+    assert_eq!(num_region_params,\n+               variances.map_or(num_region_params,\n+                                |v| v.len()));\n+\n+    assert_eq!(num_region_params, b_rs.len());\n+\n+    (0..a_rs.len())\n+        .map(|i| {\n+            let a_r = a_rs[i];\n+            let b_r = b_rs[i];\n+            let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(variance, &a_r, &b_r)\n+        })\n+        .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BareFnTy<'tcx>,\n+                 b: &ty::BareFnTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let unsafety = try!(relation.relate(&a.unsafety, &b.unsafety));\n+        let abi = try!(relation.relate(&a.abi, &b.abi));\n+        let sig = try!(relation.relate(&a.sig, &b.sig));\n+        Ok(ty::BareFnTy {unsafety: unsafety,\n+                         abi: abi,\n+                         sig: sig})\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::FnSig<'tcx>,\n+                 b: &ty::FnSig<'tcx>)\n+                 -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(\n+                expected_found(relation, &a.variadic, &b.variadic)));\n+        }\n+\n+        let inputs = try!(relate_arg_vecs(relation,\n+                                          &a.inputs,\n+                                          &b.inputs));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(relation.relate(&a_ty, &b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+    }\n+}\n+\n+fn relate_arg_vecs<'a,'tcx,R>(relation: &mut R,\n+                              a_args: &[Ty<'tcx>],\n+                              b_args: &[Ty<'tcx>])\n+                              -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_args.len() != b_args.len() {\n+        return Err(ty::terr_arg_count);\n+    }\n+\n+    a_args.iter()\n+          .zip(b_args.iter())\n+          .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n+          .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ast::Unsafety,\n+                 b: &ast::Unsafety)\n+                 -> RelateResult<'tcx, ast::Unsafety>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n+    fn relate<R>(relation: &mut R,\n+                 a: &abi::Abi,\n+                 b: &abi::Abi)\n+                 -> RelateResult<'tcx, abi::Abi>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a == b {\n+            Ok(*a)\n+        } else {\n+            Err(ty::terr_abi_mismatch(expected_found(relation, a, b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionTy<'tcx>,\n+                 b: &ty::ProjectionTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.item_name != b.item_name {\n+            Err(ty::terr_projection_name_mismatched(\n+                expected_found(relation, &a.item_name, &b.item_name)))\n+        } else {\n+            let trait_ref = try!(relation.relate(&*a.trait_ref, &*b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionPredicate<'tcx>,\n+                 b: &ty::ProjectionPredicate<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let projection_ty = try!(relation.relate(&a.projection_ty, &b.projection_ty));\n+        let ty = try!(relation.relate(&a.ty, &b.ty));\n+        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                 b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                 -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // To be compatible, `a` and `b` must be for precisely the\n+        // same set of traits and item names. We always require that\n+        // projection bounds lists are sorted by trait-def-id and item-name,\n+        // so we can just iterate through the lists pairwise, so long as they are the\n+        // same length.\n+        if a.len() != b.len() {\n+            Err(ty::terr_projection_bounds_length(expected_found(relation, &a.len(), &b.len())))\n+        } else {\n+            a.iter()\n+                .zip(b.iter())\n+                .map(|(a, b)| relation.relate(a, b))\n+                .collect()\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ExistentialBounds<'tcx>,\n+                 b: &ty::ExistentialBounds<'tcx>)\n+                 -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let r = try!(relation.relate_with_variance(ty::Contravariant,\n+                                                   &a.region_bound,\n+                                                   &b.region_bound));\n+        let nb = try!(relation.relate(&a.builtin_bounds, &b.builtin_bounds));\n+        let pb = try!(relation.relate(&a.projection_bounds, &b.projection_bounds));\n+        Ok(ty::ExistentialBounds { region_bound: r,\n+                                   builtin_bounds: nb,\n+                                   projection_bounds: pb })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BuiltinBounds,\n+                 b: &ty::BuiltinBounds)\n+                 -> RelateResult<'tcx, ty::BuiltinBounds>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Two sets of builtin bounds are only relatable if they are\n+        // precisely the same (but see the coercion code).\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::TraitRef<'tcx>,\n+                 b: &ty::TraitRef<'tcx>)\n+                 -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(expected_found(relation, &a.def_id, &b.def_id)))\n+        } else {\n+            let substs = try!(relate_item_substs(relation, a.def_id, a.substs, b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Ty<'tcx>,\n+                 b: &Ty<'tcx>)\n+                 -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.tys(a, b)\n+    }\n+}\n+\n+/// The main \"type relation\" routine. Note that this does not handle\n+/// inference artifacts, so you should filter those out before calling\n+/// it.\n+pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n+                                      a: Ty<'tcx>,\n+                                      b: Ty<'tcx>)\n+                                      -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let a_sty = &a.sty;\n+    let b_sty = &b.sty;\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    match (a_sty, b_sty) {\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) =>\n+        {\n+            // The caller should handle these cases!\n+            tcx.sess.bug(\"var types encountered in super_relate_tys\")\n+        }\n+\n+        (&ty::ty_err, _) | (_, &ty::ty_err) =>\n+        {\n+            Ok(tcx.types.err)\n+        }\n+\n+        (&ty::ty_char, _) |\n+        (&ty::ty_bool, _) |\n+        (&ty::ty_int(_), _) |\n+        (&ty::ty_uint(_), _) |\n+        (&ty::ty_float(_), _) |\n+        (&ty::ty_str, _)\n+            if a == b =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p))\n+            if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) =>\n+        {\n+            let principal = try!(relation.relate(&a_.principal, &b_.principal));\n+            let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n+            Ok(ty::mk_trait(tcx, principal, bounds))\n+        }\n+\n+        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_closure(a_id, a_substs),\n+         &ty::ty_closure(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            // All ty_closure types with the same id represent\n+            // the (anonymous) type of the same closure expression. So\n+            // all of their regions should be equated.\n+            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) =>\n+        {\n+            let typ = try!(relation.relate(&a_inner, &b_inner));\n+            Ok(ty::mk_uniq(tcx, typ))\n+        }\n+\n+        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) =>\n+        {\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_ptr(tcx, mt))\n+        }\n+\n+        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) =>\n+        {\n+            let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n+        }\n+\n+        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            if sz_a == sz_b {\n+                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+            } else {\n+                Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n+            }\n+        }\n+\n+        (&ty::ty_vec(a_t, None), &ty::ty_vec(b_t, None)) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            Ok(ty::mk_vec(tcx, t, None))\n+        }\n+\n+        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) =>\n+        {\n+            if as_.len() == bs.len() {\n+                let ts = try!(as_.iter()\n+                                 .zip(bs.iter())\n+                                 .map(|(a, b)| relation.relate(a, b))\n+                                 .collect::<Result<_, _>>());\n+                Ok(ty::mk_tup(tcx, ts))\n+            } else if as_.len() != 0 && bs.len() != 0 {\n+                Err(ty::terr_tuple_size(\n+                    expected_found(relation, &as_.len(), &bs.len())))\n+            } else {\n+                Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+            }\n+        }\n+\n+        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n+            if a_opt_def_id == b_opt_def_id =>\n+        {\n+            let fty = try!(relation.relate(a_fty, b_fty));\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+        }\n+\n+        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) =>\n+        {\n+            let projection_ty = try!(relation.relate(a_data, b_data));\n+            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        }\n+\n+        _ =>\n+        {\n+            Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Region,\n+                 b: &ty::Region)\n+                 -> RelateResult<'tcx, ty::Region>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.regions(*a, *b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for ty::Binder<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Binder<T>,\n+                 b: &ty::Binder<T>)\n+                 -> RelateResult<'tcx, ty::Binder<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.binders(a, b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Rc<T>,\n+                 b: &Rc<T>)\n+                 -> RelateResult<'tcx, Rc<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Rc::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Box<T>,\n+                 b: &Box<T>)\n+                 -> RelateResult<'tcx, Box<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Box::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Error handling\n+\n+pub fn expected_found<'a,'tcx,R,T>(relation: &mut R,\n+                                   a: &T,\n+                                   b: &T)\n+                                   -> ty::expected_found<T>\n+    where R: TypeRelation<'a,'tcx>, T: Clone\n+{\n+    expected_found_bool(relation.a_is_expected(), a, b)\n+}\n+\n+pub fn expected_found_bool<T>(a_is_expected: bool,\n+                              a: &T,\n+                              b: &T)\n+                              -> ty::expected_found<T>\n+    where T: Clone\n+{\n+    let a = a.clone();\n+    let b = b.clone();\n+    if a_is_expected {\n+        ty::expected_found {expected: a, found: b}\n+    } else {\n+        ty::expected_found {expected: b, found: a}\n+    }\n+}\n+"}, {"sha": "60b422b3769d5bc0a2c322a590d89b776a691493", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -1526,3 +1526,9 @@ impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ast::Unsafety {\n+    fn repr(&self, _: &ctxt<'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}"}, {"sha": "f9be71561e384b5b2a85800eeca108ef90fef1c7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -22,7 +22,7 @@ use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n use rustc_typeck::middle::ty::{self, Ty};\n-use rustc_typeck::middle::infer::combine::Combine;\n+use rustc_typeck::middle::ty_relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n@@ -350,21 +350,21 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn sub(&self) -> Sub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Sub(self.infcx.combine_fields(true, trace))\n+        self.infcx.sub(true, trace)\n     }\n \n     pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Lub(self.infcx.combine_fields(true, trace))\n+        self.infcx.lub(true, trace)\n     }\n \n     pub fn glb(&self) -> Glb<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Glb(self.infcx.combine_fields(true, trace))\n+        self.infcx.glb(true, trace)\n     }\n \n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Ok(_) => { }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({},{}): {}\",\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Err(_) => { }\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({},{})\",\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n             }\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),\n                self.ty_to_string(t_glb));\n-        match self.glb().tys(t1, t2) {\n+        match self.glb().relate(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "3f9c14e0afe398ab8d3b905cf60e3ef082dfb029", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -83,9 +83,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                   UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n-                      let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n-                      try_overloaded_call_step(fcx, call_expr, callee_expr,\n-                                               adj_ty, autoderefref)\n+                      try_overloaded_call_step(fcx, call_expr, callee_expr, adj_ty, idx)\n                   });\n \n     match result {\n@@ -119,13 +117,15 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       call_expr: &'tcx ast::Expr,\n                                       callee_expr: &'tcx ast::Expr,\n                                       adjusted_ty: Ty<'tcx>,\n-                                      autoderefref: ty::AutoDerefRef<'tcx>)\n+                                      autoderefs: usize)\n                                       -> Option<CallStep<'tcx>>\n {\n-    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefref={})\",\n+    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefs={})\",\n            call_expr.repr(fcx.tcx()),\n            adjusted_ty.repr(fcx.tcx()),\n-           autoderefref.repr(fcx.tcx()));\n+           autoderefs);\n+\n+    let autoderefref = ty::AutoDerefRef { autoderefs: autoderefs, autoref: None };\n \n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n@@ -161,6 +161,18 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n+        // Hack: we know that there are traits implementing Fn for &F\n+        // where F:Fn and so forth. In the particular case of types\n+        // like `x: &mut FnMut()`, if there is a call `x()`, we would\n+        // normally translate to `FnMut::call_mut(&mut x, ())`, but\n+        // that winds up requiring `mut x: &mut FnMut()`. A little\n+        // over the top. The simplest fix by far is to just ignore\n+        // this case and deref again, so we wind up with\n+        // `FnMut::call_mut(&mut *x, ())`.\n+        ty::ty_rptr(..) if autoderefs == 0 => {\n+            return None;\n+        }\n+\n         _ => {}\n     }\n "}, {"sha": "ced6cec3ef0dc3daef00349ce18f90f9e057a242", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -62,12 +62,11 @@\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n-use middle::infer::{self, cres, Coercion, TypeTrace};\n-use middle::infer::combine::Combine;\n-use middle::infer::sub::Sub;\n+use middle::infer::{self, Coercion};\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{self, mt, Ty};\n+use middle::ty_relate::RelateResult;\n use util::common::indent;\n use util::ppaux;\n use util::ppaux::Repr;\n@@ -76,25 +75,27 @@ use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    trace: TypeTrace<'tcx>\n+    origin: infer::TypeOrigin,\n }\n \n-type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n \n     fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.tys(a, b));\n+        try!(self.fcx.infcx().sub_types(false, self.origin.clone(), a, b));\n         Ok(None) // No coercion required.\n     }\n \n-    fn outlives(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ()> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.regions(b, a));\n+    fn outlives(&self,\n+                origin: infer::SubregionOrigin<'tcx>,\n+                a: ty::Region,\n+                b: ty::Region)\n+                -> RelateResult<'tcx, ()> {\n+        infer::mk_subr(self.fcx.infcx(), origin, b, a);\n         Ok(())\n     }\n \n@@ -190,7 +191,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => return self.subtype(a, b)\n         }\n \n-        let coercion = Coercion(self.trace.clone());\n+        let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n \n@@ -214,7 +215,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = ty::mk_rptr(self.tcx(), r_borrow,\n                                  mt {ty: inner_ty, mutbl: mutbl_b});\n-            if let Err(err) = self.fcx.infcx().try(|_| self.subtype(ty, b)) {\n+            if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n                 }\n@@ -264,12 +265,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             return Err(ty::terr_mutability);\n                         }\n \n-                        let coercion = Coercion(self.trace.clone());\n+                        let coercion = Coercion(self.origin.span());\n                         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                         let ty = ty::mk_rptr(self.tcx(),\n                                              self.tcx().mk_region(r_borrow),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -290,7 +291,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                         let ty = ty::mk_ptr(self.tcx(),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -306,7 +307,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 match self.unsize_ty(t_a, t_b) {\n                     Some((ty, kind)) => {\n                         let ty = ty::mk_uniq(self.tcx(), ty);\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoUnsizeUniq({:?}))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -365,9 +366,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n \n                             // relate `a1` to `b`\n-                            let result = self.fcx.infcx().try(|_| {\n+                            let result = self.fcx.infcx().commit_if_ok(|_| {\n                                 // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                                try!(self.outlives(data_a.bounds.region_bound,\n+                                try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n+                                                   data_a.bounds.region_bound,\n                                                    data_b.bounds.region_bound));\n                                 self.subtype(ty_a1, ty_b)\n                             });\n@@ -399,7 +401,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let mut result = None;\n                         let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                         for (i, (tp_a, tp_b)) in tps {\n-                            if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n+                            if self.subtype(*tp_a, *tp_b).is_ok() {\n                                 continue;\n                             }\n                             match self.unsize_ty(*tp_a, *tp_b) {\n@@ -408,7 +410,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                     let mut new_substs = substs_a.clone();\n                                     new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                     let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                    if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n+                                    if self.subtype(ty, ty_b).is_err() {\n                                         debug!(\"Unsized type parameter '{}', but still \\\n                                                 could not match types {} and {}\",\n                                                ppaux::ty_to_string(tcx, *tp_a),\n@@ -534,14 +536,13 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              expr: &ast::Expr,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> cres<'tcx, ()> {\n+                             -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n     let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|| {\n-            let origin = infer::ExprAssignable(expr.span);\n+        fcx.infcx().commit_if_ok(|_| {\n             Coerce {\n                 fcx: fcx,\n-                trace: infer::TypeTrace::types(origin, false, a, b)\n+                origin: infer::ExprAssignable(expr.span),\n             }.coerce(expr, a, b)\n         })\n     }));"}, {"sha": "532277d75b2e06af52afc2002fffe37f62957b58", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -282,7 +282,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n-    let err = infcx.try(|snapshot| {\n+    let err = infcx.commit_if_ok(|snapshot| {\n         let origin = infer::MethodCompatCheck(impl_m_span);\n \n         let (impl_sig, _) ="}, {"sha": "2f7e0073e1751ad0f99ee08fc7714ee5269749ff", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -95,7 +95,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         ty::lookup_item_type(tcx, self_type_did);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);\n         let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);"}, {"sha": "e203019bd0638fe43d2fe0ea2d8d307c35db27b5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -1130,7 +1130,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::ures<'tcx> {\n+    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n "}, {"sha": "9171367468026a8f9226b4537b22500f4ff51394", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -1542,7 +1542,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n             debug!(\"projection_bounds: outlives={} (2)\",\n                    outlives.repr(tcx));\n \n-            let region_result = infcx.try(|_| {\n+            let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n                     infcx.replace_late_bound_regions_with_fresh_var(\n                         span,"}, {"sha": "51d0c18872dc4213b9756cb3585bb5d7a8bc34cd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n use CrateCtxt;\n-use middle::infer::combine::Combine;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n use std::collections::HashSet;"}, {"sha": "2d87345db2245f5c71701480ad892e3cceda4f61", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -23,10 +23,6 @@ pub fn main() {\n     let f2: &Fat<[isize; 3]> = &f1;\n     let f3: &Fat<[usize]> = f2;\n     //~^ ERROR mismatched types\n-    //~| expected `&Fat<[usize]>`\n-    //~| found `&Fat<[isize; 3]>`\n-    //~| expected usize\n-    //~| found isize\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}, {"sha": "4fba45e2a66c589f61ff74396997e632b30088ae", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -81,8 +81,8 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR cannot infer\n-        //~| ERROR mismatched types\n+        //~^ ERROR lifetime of the source pointer does not outlive lifetime bound\n+        //~| ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "7fae530984f898e36b8781d30e7eb577fee63bd4", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR mismatched types\n+    ss.r //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR mismatched types\n+    ss.r = b; //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn main() {"}, {"sha": "10b883d4dc830b8568e8eb3391d5ffe0a0f3e0fc", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR mismatched types\n+    box v as Box<SomeTrait+'a> //~ ERROR lifetime of the source pointer does not outlive\n }\n \n fn main() {"}, {"sha": "f3722690ef8959f27e0e158d3e2329cb7f0b01fd", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR mismatched types\n+    x //~ ERROR lifetime of the source pointer does not outlive\n      //~^ ERROR cannot infer\n }\n "}, {"sha": "37dccca1e22455c883bb1807f6a275055ef670bd", "filename": "src/test/run-pass/unboxed-closures-blanket-fn-mut.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you can supply `&F` where `F: FnMut()`.\n+\n+// pretty-expanded FIXME #23616\n+\n+#![feature(lang_items, unboxed_closures)]\n+\n+fn a<F:FnMut() -> i32>(mut f: F) -> i32 {\n+    f()\n+}\n+\n+fn b(f: &mut FnMut() -> i32) -> i32 {\n+    a(f)\n+}\n+\n+fn c<F:FnMut() -> i32>(f: &mut F) -> i32 {\n+    a(f)\n+}\n+\n+fn main() {\n+    let z: isize = 7;\n+\n+    let x = b(&mut || 22);\n+    assert_eq!(x, 22);\n+\n+    let x = c(&mut || 22);\n+    assert_eq!(x, 22);\n+}"}, {"sha": "0f93966077bc30ae3c850c1e6a231eccfd27278a", "filename": "src/test/run-pass/unboxed-closures-blanket-fn.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/debac97a10ce7fec71ab16101889f7ec5ea17e71/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs?ref=debac97a10ce7fec71ab16101889f7ec5ea17e71", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you can supply `&F` where `F: Fn()`.\n+\n+// pretty-expanded FIXME #23616\n+\n+#![feature(lang_items, unboxed_closures)]\n+\n+fn a<F:Fn() -> i32>(f: F) -> i32 {\n+    f()\n+}\n+\n+fn b(f: &Fn() -> i32) -> i32 {\n+    a(f)\n+}\n+\n+fn c<F:Fn() -> i32>(f: &F) -> i32 {\n+    a(f)\n+}\n+\n+fn main() {\n+    let z: isize = 7;\n+\n+    let x = b(&|| 22);\n+    assert_eq!(x, 22);\n+\n+    let x = c(&|| 22);\n+    assert_eq!(x, 22);\n+}"}]}