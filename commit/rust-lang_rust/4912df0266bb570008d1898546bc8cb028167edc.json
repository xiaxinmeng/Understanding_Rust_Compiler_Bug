{"sha": "4912df0266bb570008d1898546bc8cb028167edc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MTJkZjAyNjZiYjU3MDAwOGQxODk4NTQ2YmM4Y2IwMjgxNjdlZGM=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-22T19:31:43Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-04T23:14:36Z"}, "message": "Generate StorageDead along unwind paths for generators", "tree": {"sha": "f20e5a83a2056b63b35cb74de318765afb902fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20e5a83a2056b63b35cb74de318765afb902fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4912df0266bb570008d1898546bc8cb028167edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4912df0266bb570008d1898546bc8cb028167edc", "html_url": "https://github.com/rust-lang/rust/commit/4912df0266bb570008d1898546bc8cb028167edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4912df0266bb570008d1898546bc8cb028167edc/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d682cd941c6936018c8330256549fb5e97296f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d682cd941c6936018c8330256549fb5e97296f7", "html_url": "https://github.com/rust-lang/rust/commit/3d682cd941c6936018c8330256549fb5e97296f7"}], "stats": {"total": 154, "additions": 88, "deletions": 66}, "files": [{"sha": "8e2c3dd3d8ad9d5ffb72d70838ebf6dcb86c0750", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=4912df0266bb570008d1898546bc8cb028167edc", "patch": "@@ -666,7 +666,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size,\n                     align,\n                 });\n-                debug!(\"generator layout: {:#?}\", layout);\n+                debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n                 layout\n             }\n "}, {"sha": "b5efe656c99b232b3df8650586af2a595f5473a4", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=4912df0266bb570008d1898546bc8cb028167edc", "patch": "@@ -544,7 +544,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let place = Place::Base(PlaceBase::Local(local_id));\n         let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage { cached_block: CachedBlock::default() });\n         place\n     }\n "}, {"sha": "780f2313304311e8ab16b6ffc800c5aaccd19d02", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 86, "deletions": 64, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912df0266bb570008d1898546bc8cb028167edc/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4912df0266bb570008d1898546bc8cb028167edc", "patch": "@@ -88,7 +88,7 @@ use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n use rustc::mir::*;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{DUMMY_SP, Span};\n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -164,10 +164,8 @@ pub(crate) struct CachedBlock {\n \n #[derive(Debug)]\n pub(crate) enum DropKind {\n-    Value {\n-        cached_block: CachedBlock,\n-    },\n-    Storage\n+    Value { cached_block: CachedBlock },\n+    Storage { cached_block: CachedBlock },\n }\n \n #[derive(Clone, Debug)]\n@@ -211,7 +209,7 @@ impl DropKind {\n     fn may_panic(&self) -> bool {\n         match *self {\n             DropKind::Value { .. } => true,\n-            DropKind::Storage => false\n+            DropKind::Storage { .. } => false\n         }\n     }\n }\n@@ -225,25 +223,28 @@ impl<'tcx> Scope<'tcx> {\n     /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n-    fn invalidate_cache(&mut self, storage_only: bool, this_scope_only: bool) {\n+    fn invalidate_cache(&mut self, storage_only: bool, is_generator: bool, this_scope_only: bool) {\n         // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n         // with lots of `try!`?\n \n         // cached exits drop storage and refer to the top-of-scope\n         self.cached_exits.clear();\n \n-        if !storage_only {\n-            // the current generator drop and unwind ignore\n-            // storage but refer to top-of-scope\n-            self.cached_generator_drop = None;\n+        // the current generator drop and unwind refer to top-of-scope\n+        self.cached_generator_drop = None;\n+\n+        let ignore_unwinds = storage_only && !is_generator;\n+        if !ignore_unwinds {\n             self.cached_unwind.invalidate();\n         }\n \n-        if !storage_only && !this_scope_only {\n+        if !ignore_unwinds && !this_scope_only {\n             for drop_data in &mut self.drops {\n-                if let DropKind::Value { ref mut cached_block } = drop_data.kind {\n-                    cached_block.invalidate();\n-                }\n+                let cached_block = match drop_data.kind {\n+                    DropKind::Storage { ref mut cached_block } => cached_block,\n+                    DropKind::Value { ref mut cached_block } => cached_block,\n+                };\n+                cached_block.invalidate();\n             }\n         }\n     }\n@@ -388,6 +389,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n+            self.is_generator,\n             &scope,\n             block,\n             unwind_to,\n@@ -454,6 +456,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n+                self.is_generator,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -484,10 +487,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let result = block;\n \n         while let Some(scope) = scopes.next() {\n-            if !scope.needs_cleanup && !self.is_generator {\n-                continue;\n-            }\n-\n             block = if let Some(b) = scope.cached_generator_drop {\n                 self.cfg.terminate(block, src_info,\n                                    TerminatorKind::Goto { target: b });\n@@ -508,6 +507,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n+                self.is_generator,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -644,7 +644,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ) {\n         self.schedule_drop(\n             span, region_scope, place, place_ty,\n-            DropKind::Storage,\n+            DropKind::Storage {\n+                cached_block: CachedBlock::default(),\n+            },\n         );\n         self.schedule_drop(\n             span, region_scope, place, place_ty,\n@@ -672,7 +674,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let needs_drop = self.hir.needs_drop(place_ty);\n         match drop_kind {\n             DropKind::Value { .. } => if !needs_drop { return },\n-            DropKind::Storage => {\n+            DropKind::Storage { .. } => {\n                 match *place {\n                     Place::Base(PlaceBase::Local(index)) => if index.index() <= self.arg_count {\n                         span_bug!(\n@@ -735,8 +737,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Note that this code iterates scopes from the inner-most to the outer-most,\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n-            // cache of outer scope stays intact.\n-            scope.invalidate_cache(!needs_drop, this_scope);\n+            // cache of outer scpoe stays intact.\n+            scope.invalidate_cache(!needs_drop, self.is_generator, this_scope);\n             if this_scope {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n@@ -797,6 +799,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // to left reading the cached results but never created anything.\n \n         // Find the last cached block\n+        debug!(\"diverge_cleanup_gen(self.scopes = {:?})\", self.scopes);\n         let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n             .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n             (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n@@ -890,7 +893,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n-        top_scope.invalidate_cache(false, true);\n+        top_scope.invalidate_cache(false, self.is_generator, true);\n     }\n \n     /// Drops the single variable provided\n@@ -941,21 +944,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        top_scope.invalidate_cache(true, true);\n+        top_scope.invalidate_cache(true, self.is_generator, true);\n     }\n \n }\n \n /// Builds drops for pop_scope and exit_scope.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n+    is_generator: bool,\n     scope: &Scope<'tcx>,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n     generator_drop: bool,\n ) -> BlockAnd<()> {\n-    debug!(\"build_scope_drops({:?} -> {:?}\", block, scope);\n+    debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n \n     // Build up the drops in evaluation order. The end result will\n     // look like:\n@@ -969,28 +973,20 @@ fn build_scope_drops<'tcx>(\n     // The horizontal arrows represent the execution path when the drops return\n     // successfully. The downwards arrows represent the execution path when the\n     // drops panic (panicking while unwinding will abort, so there's no need for\n-    // another set of arrows). The drops for the unwind path should have already\n-    // been generated by `diverge_cleanup_gen`.\n-\n-    let mut unwind_blocks = scope.drops.iter().rev().filter_map(|drop_data| {\n-        if let DropKind::Value { cached_block } = drop_data.kind {\n-            Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n-                span_bug!(drop_data.span, \"cached block not present?\")\n-            }))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    // When we unwind from a drop, we start cleaning up from the next one, so\n-    // we don't need this block.\n-    unwind_blocks.next();\n+    // another set of arrows).\n+    //\n+    // For generators, we unwind from a drop on a local to its StorageDead\n+    // statement. For other functions we don't worry about StorageDead. The\n+    // drops for the unwind path should have already been generated by\n+    // `diverge_cleanup_gen`.\n \n-    for drop_data in scope.drops.iter().rev() {\n+    for drop_idx in (0..scope.drops.len()).rev() {\n+        let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n         match drop_data.kind {\n             DropKind::Value { .. } => {\n-                let unwind_to = unwind_blocks.next().unwrap_or(last_unwind_to);\n+                let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n+                    .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n@@ -1000,7 +996,7 @@ fn build_scope_drops<'tcx>(\n                 });\n                 block = next;\n             }\n-            DropKind::Storage => {\n+            DropKind::Storage { .. } => {\n                 // Drop the storage for both value and storage drops.\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n@@ -1018,6 +1014,31 @@ fn build_scope_drops<'tcx>(\n     block.unit()\n }\n \n+fn get_unwind_to<'tcx>(\n+    scope: &Scope<'tcx>,\n+    is_generator: bool,\n+    unwind_from: usize,\n+    generator_drop: bool,\n+) -> Option<BasicBlock> {\n+    for drop_idx in (0..unwind_from).rev() {\n+        let drop_data = &scope.drops[drop_idx];\n+        match drop_data.kind {\n+            DropKind::Storage { cached_block } if is_generator => {\n+                return Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n+                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n+                }));\n+            }\n+            DropKind::Value { cached_block } if !is_generator => {\n+                return Some(cached_block.get(generator_drop).unwrap_or_else(|| {\n+                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n+                }));\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}\n+\n fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              span: Span,\n                              scope: &mut Scope<'tcx>,\n@@ -1051,6 +1072,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n     // Build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n+    debug!(\"build_diverge_scope({:?})\", scope.drops);\n     for (j, drop_data) in scope.drops.iter_mut().enumerate() {\n         debug!(\"build_diverge_scope drop_data[{}]: {:?}\", j, drop_data);\n         // Only full value drops are emitted in the diverging path,\n@@ -1062,28 +1084,38 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n         match drop_data.kind {\n-            DropKind::Storage if is_generator => {\n+            DropKind::Storage { ref mut cached_block } if is_generator => {\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n                     Place::Base(PlaceBase::Local(index)) => {\n                         storage_deads.push(Statement {\n                             source_info: source_info(drop_data.span),\n                             kind: StatementKind::StorageDead(index)\n                         });\n+                        if !target_built_by_us {\n+                            // We cannot add statements to an existing block, so we create a new\n+                            // block for our StorageDead statements.\n+                            let block = cfg.start_new_cleanup_block();\n+                            let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n+                            cfg.terminate(block, source_info,\n+                                          TerminatorKind::Goto { target: target });\n+                            target = block;\n+                            target_built_by_us = true;\n+                        }\n                     }\n                     _ => unreachable!(),\n                 };\n+                *cached_block.ref_mut(generator_drop) = Some(target);\n             }\n-            DropKind::Storage => {}\n+            DropKind::Storage { .. } => {}\n             DropKind::Value { ref mut cached_block } => {\n                 let cached_block = cached_block.ref_mut(generator_drop);\n                 target = if let Some(cached_block) = *cached_block {\n                     storage_deads.clear();\n                     target_built_by_us = false;\n                     cached_block\n                 } else {\n-                    push_storage_deads(\n-                        cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n+                    push_storage_deads(cfg, target, &mut storage_deads);\n                     let block = cfg.start_new_cleanup_block();\n                     cfg.terminate(block, source_info(drop_data.span),\n                                   TerminatorKind::Drop {\n@@ -1098,7 +1130,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n             }\n         };\n     }\n-    push_storage_deads(cfg, &mut target, &mut storage_deads, target_built_by_us, source_scope);\n+    push_storage_deads(cfg, target, &mut storage_deads);\n     *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n     assert!(storage_deads.is_empty());\n@@ -1108,23 +1140,13 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n }\n \n fn push_storage_deads(cfg: &mut CFG<'tcx>,\n-                      target: &mut BasicBlock,\n-                      storage_deads: &mut Vec<Statement<'tcx>>,\n-                      target_built_by_us: bool,\n-                      source_scope: SourceScope) {\n+                      target: BasicBlock,\n+                      storage_deads: &mut Vec<Statement<'tcx>>) {\n     if storage_deads.is_empty() { return; }\n-    if !target_built_by_us {\n-        // We cannot add statements to an existing block, so we create a new\n-        // block for our StorageDead statements.\n-        let block = cfg.start_new_cleanup_block();\n-        let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n-        cfg.terminate(block, source_info, TerminatorKind::Goto { target: *target });\n-        *target = block;\n-    }\n-    let statements = &mut cfg.block_data_mut(*target).statements;\n+    let statements = &mut cfg.block_data_mut(target).statements;\n     storage_deads.reverse();\n     debug!(\"push_storage_deads({:?}), storage_deads={:?}, statements={:?}\",\n-           *target, storage_deads, statements);\n+           target, storage_deads, statements);\n     storage_deads.append(statements);\n     mem::swap(statements, storage_deads);\n     assert!(storage_deads.is_empty());"}]}