{"sha": "abe5973b9d1202f1a6460c0116f22fc33c9506c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZTU5NzNiOWQxMjAyZjFhNjQ2MGMwMTE2ZjIyZmMzM2M5NTA2YzU=", "commit": {"author": {"name": "Rakshith Ravi", "email": "rakshith.ravi@gmx.com", "date": "2020-04-15T19:49:51Z"}, "committer": {"name": "Rakshith Ravi", "email": "rakshith.ravi@gmx.com", "date": "2020-04-15T19:49:51Z"}, "message": "Inlined everything into a single trait and trait impl", "tree": {"sha": "d786d9fa185fd9439eed32e08ffcdce1929d9385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d786d9fa185fd9439eed32e08ffcdce1929d9385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abe5973b9d1202f1a6460c0116f22fc33c9506c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abe5973b9d1202f1a6460c0116f22fc33c9506c5", "html_url": "https://github.com/rust-lang/rust/commit/abe5973b9d1202f1a6460c0116f22fc33c9506c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abe5973b9d1202f1a6460c0116f22fc33c9506c5/comments", "author": {"login": "rakshith-ravi", "id": 12864597, "node_id": "MDQ6VXNlcjEyODY0NTk3", "avatar_url": "https://avatars.githubusercontent.com/u/12864597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakshith-ravi", "html_url": "https://github.com/rakshith-ravi", "followers_url": "https://api.github.com/users/rakshith-ravi/followers", "following_url": "https://api.github.com/users/rakshith-ravi/following{/other_user}", "gists_url": "https://api.github.com/users/rakshith-ravi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakshith-ravi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakshith-ravi/subscriptions", "organizations_url": "https://api.github.com/users/rakshith-ravi/orgs", "repos_url": "https://api.github.com/users/rakshith-ravi/repos", "events_url": "https://api.github.com/users/rakshith-ravi/events{/privacy}", "received_events_url": "https://api.github.com/users/rakshith-ravi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rakshith-ravi", "id": 12864597, "node_id": "MDQ6VXNlcjEyODY0NTk3", "avatar_url": "https://avatars.githubusercontent.com/u/12864597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakshith-ravi", "html_url": "https://github.com/rakshith-ravi", "followers_url": "https://api.github.com/users/rakshith-ravi/followers", "following_url": "https://api.github.com/users/rakshith-ravi/following{/other_user}", "gists_url": "https://api.github.com/users/rakshith-ravi/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakshith-ravi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakshith-ravi/subscriptions", "organizations_url": "https://api.github.com/users/rakshith-ravi/orgs", "repos_url": "https://api.github.com/users/rakshith-ravi/repos", "events_url": "https://api.github.com/users/rakshith-ravi/events{/privacy}", "received_events_url": "https://api.github.com/users/rakshith-ravi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51cd29cf6cb4bd4ec025ae436f5d8ae6260335a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cd29cf6cb4bd4ec025ae436f5d8ae6260335a2", "html_url": "https://github.com/rust-lang/rust/commit/51cd29cf6cb4bd4ec025ae436f5d8ae6260335a2"}], "stats": {"total": 267, "additions": 141, "deletions": 126}, "files": [{"sha": "502fc2e631502a2c5637a482c746a6ab95b58b05", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 141, "deletions": 126, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/abe5973b9d1202f1a6460c0116f22fc33c9506c5/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe5973b9d1202f1a6460c0116f22fc33c9506c5/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=abe5973b9d1202f1a6460c0116f22fc33c9506c5", "patch": "@@ -66,27 +66,27 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        FuseIteratorImpl::next(self)\n+        FuseImpl::next(self)\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        FuseIteratorImpl::nth(self, n)\n+        FuseImpl::nth(self, n)\n     }\n \n     #[inline]\n     fn last(self) -> Option<Self::Item> {\n-        FuseIteratorImpl::last(self)\n+        FuseImpl::last(self)\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        FuseIteratorImpl::count(self)\n+        FuseImpl::count(self)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        FuseIteratorImpl::size_hint(self)\n+        FuseImpl::size_hint(self)\n     }\n \n     #[inline]\n@@ -96,23 +96,23 @@ where\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        FuseIteratorImpl::try_fold(self, acc, fold)\n+        FuseImpl::try_fold(self, acc, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        FuseIteratorImpl::fold(self, acc, fold)\n+        FuseImpl::fold(self, acc, fold)\n     }\n \n     #[inline]\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        FuseIteratorImpl::find(self, predicate)\n+        FuseImpl::find(self, predicate)\n     }\n }\n \n@@ -123,12 +123,12 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        FuseDoubleEndedIteratorImpl::next_back(self)\n+        FuseImpl::next_back(self)\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        FuseDoubleEndedIteratorImpl::nth_back(self, n)\n+        FuseImpl::nth_back(self, n)\n     }\n \n     #[inline]\n@@ -138,23 +138,23 @@ where\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        FuseDoubleEndedIteratorImpl::try_rfold(self, acc, fold)\n+        FuseImpl::try_rfold(self, acc, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        FuseDoubleEndedIteratorImpl::rfold(self, acc, fold)\n+        FuseImpl::rfold(self, acc, fold)\n     }\n \n     #[inline]\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        FuseDoubleEndedIteratorImpl::rfind(self, predicate)\n+        FuseImpl::rfind(self, predicate)\n     }\n }\n \n@@ -164,11 +164,11 @@ where\n     I: ExactSizeIterator,\n {\n     fn len(&self) -> usize {\n-        FuseExactSizeIteratorImpl::len(self)\n+        FuseImpl::len(self)\n     }\n \n     fn is_empty(&self) -> bool {\n-        FuseExactSizeIteratorImpl::is_empty(self)\n+        FuseImpl::is_empty(self)\n     }\n }\n \n@@ -190,12 +190,11 @@ where\n }\n \n // Fuse specialization trait\n-// Iterators and DoubleEndedIterators cannot be overlapped successfully\n-// So, they're separated into each it's own trait to provide internal implementations\n-// Similarly, ExactSizeIterators cannot be overlapped, so requires its own trait\n #[doc(hidden)]\n-trait FuseIteratorImpl<I> {\n+trait FuseImpl<I> {\n     type Item;\n+\n+    // Functions specific to any normal Iterators\n     fn next(&mut self) -> Option<Self::Item>;\n     fn nth(&mut self, n: usize) -> Option<Self::Item>;\n     fn last(self) -> Option<Self::Item>;\n@@ -212,11 +211,41 @@ trait FuseIteratorImpl<I> {\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool;\n+\n+    // Functions specific to DoubleEndedIterators\n+    fn next_back(&mut self) -> Option<Self::Item>\n+    where\n+        I: DoubleEndedIterator;\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item>\n+    where\n+        I: DoubleEndedIterator;\n+    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator;\n+    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator;\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator;\n+\n+    // Functions specific to ExactSizeIterator\n+    fn len(&self) -> usize\n+    where\n+        I: ExactSizeIterator;\n+    fn is_empty(&self) -> bool\n+    where\n+        I: ExactSizeIterator;\n }\n \n // General Fuse impl\n #[doc(hidden)]\n-impl<I> FuseIteratorImpl<I> for Fuse<I>\n+impl<I> FuseImpl<I> for Fuse<I>\n where\n     I: Iterator,\n {\n@@ -288,146 +317,151 @@ where\n     {\n         fuse!(self.iter.find(predicate))\n     }\n-}\n-\n-#[doc(hidden)]\n-impl<I> FuseIteratorImpl<I> for Fuse<I>\n-where\n-    I: FusedIterator,\n-{\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        unchecked!(self).next()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        unchecked!(self).nth(n)\n-    }\n \n     #[inline]\n-    fn last(self) -> Option<I::Item> {\n-        unchecked!(self).last()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        unchecked!(self).count()\n+    default fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n+        fuse!(self.iter.next_back())\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        unchecked!(self).size_hint()\n+    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n+        fuse!(self.iter.nth_back(n))\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    default fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator,\n     {\n-        unchecked!(self).try_fold(init, fold)\n+        if let Some(ref mut iter) = self.iter {\n+            acc = iter.try_rfold(acc, fold)?;\n+            self.iter = None;\n+        }\n+        Try::from_ok(acc)\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator,\n     {\n-        unchecked!(self).fold(init, fold)\n+        if let Some(iter) = self.iter {\n+            acc = iter.rfold(acc, fold);\n+        }\n+        acc\n     }\n \n     #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator,\n     {\n-        unchecked!(self).find(predicate)\n+        fuse!(self.iter.rfind(predicate))\n     }\n-}\n \n-#[doc(hidden)]\n-trait FuseDoubleEndedIteratorImpl<I> {\n-    type Item;\n-    fn next_back(&mut self) -> Option<Self::Item>;\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item>;\n-    fn try_rfold<Acc, Fold, R>(&mut self, acc: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>;\n-    fn rfold<Acc, Fold>(self, acc: Acc, fold: Fold) -> Acc\n+    #[inline]\n+    default fn len(&self) -> usize\n     where\n-        Fold: FnMut(Acc, Self::Item) -> Acc;\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+        I: ExactSizeIterator,\n+    {\n+        match self.iter {\n+            Some(ref iter) => iter.len(),\n+            None => 0,\n+        }\n+    }\n+\n+    #[inline]\n+    default fn is_empty(&self) -> bool\n     where\n-        P: FnMut(&Self::Item) -> bool;\n+        I: ExactSizeIterator,\n+    {\n+        match self.iter {\n+            Some(ref iter) => iter.is_empty(),\n+            None => true,\n+        }\n+    }\n }\n \n #[doc(hidden)]\n-impl<I> FuseDoubleEndedIteratorImpl<I> for Fuse<I>\n+impl<I> FuseImpl<I> for Fuse<I>\n where\n-    I: DoubleEndedIterator,\n+    I: FusedIterator,\n {\n-    type Item = <I as Iterator>::Item;\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        unchecked!(self).next()\n+    }\n \n     #[inline]\n-    default fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next_back())\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        unchecked!(self).nth(n)\n     }\n \n     #[inline]\n-    default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.nth_back(n))\n+    fn last(self) -> Option<I::Item> {\n+        unchecked!(self).last()\n     }\n \n     #[inline]\n-    default fn try_rfold<Acc, Fold, R>(&mut self, mut acc: Acc, fold: Fold) -> R\n+    fn count(self) -> usize {\n+        unchecked!(self).count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        unchecked!(self).size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n     where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        if let Some(ref mut iter) = self.iter {\n-            acc = iter.try_rfold(acc, fold)?;\n-            self.iter = None;\n-        }\n-        Try::from_ok(acc)\n+        unchecked!(self).try_fold(init, fold)\n     }\n \n     #[inline]\n-    default fn rfold<Acc, Fold>(self, mut acc: Acc, fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        if let Some(iter) = self.iter {\n-            acc = iter.rfold(acc, fold);\n-        }\n-        acc\n+        unchecked!(self).fold(init, fold)\n     }\n \n     #[inline]\n-    default fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.rfind(predicate))\n+        unchecked!(self).find(predicate)\n     }\n-}\n \n-#[doc(hidden)]\n-impl<I> FuseDoubleEndedIteratorImpl<I> for Fuse<I>\n-where\n-    I: DoubleEndedIterator + FusedIterator,\n-{\n     #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         unchecked!(self).next_back()\n     }\n \n     #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n+    where\n+        I: DoubleEndedIterator,\n+    {\n         unchecked!(self).nth_back(n)\n     }\n \n@@ -437,6 +471,7 @@ where\n         Self: Sized,\n         Fold: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).try_rfold(init, fold)\n     }\n@@ -445,6 +480,7 @@ where\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n     where\n         Fold: FnMut(Acc, Self::Item) -> Acc,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).rfold(init, fold)\n     }\n@@ -453,45 +489,24 @@ where\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n+        I: DoubleEndedIterator,\n     {\n         unchecked!(self).rfind(predicate)\n     }\n-}\n-\n-#[doc(hidden)]\n-trait FuseExactSizeIteratorImpl<I> {\n-    fn len(&self) -> usize;\n-    fn is_empty(&self) -> bool;\n-}\n-\n-impl<I> FuseExactSizeIteratorImpl<I> for Fuse<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    default fn len(&self) -> usize {\n-        match self.iter {\n-            Some(ref iter) => iter.len(),\n-            None => 0,\n-        }\n-    }\n-\n-    default fn is_empty(&self) -> bool {\n-        match self.iter {\n-            Some(ref iter) => iter.is_empty(),\n-            None => true,\n-        }\n-    }\n-}\n \n-impl<I> FuseExactSizeIteratorImpl<I> for Fuse<I>\n-where\n-    I: ExactSizeIterator + FusedIterator,\n-{\n-    fn len(&self) -> usize {\n+    #[inline]\n+    fn len(&self) -> usize\n+    where\n+        I: ExactSizeIterator,\n+    {\n         unchecked!(self).len()\n     }\n \n-    fn is_empty(&self) -> bool {\n+    #[inline]\n+    fn is_empty(&self) -> bool\n+    where\n+        I: ExactSizeIterator,\n+    {\n         unchecked!(self).is_empty()\n     }\n }"}]}