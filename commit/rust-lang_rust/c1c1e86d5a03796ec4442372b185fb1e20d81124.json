{"sha": "c1c1e86d5a03796ec4442372b185fb1e20d81124", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYzFlODZkNWEwMzc5NmVjNDQ0MjM3MmIxODVmYjFlMjBkODExMjQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-31T17:29:31Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-07T23:31:59Z"}, "message": "Item to function", "tree": {"sha": "be8f73736fac6f7c3f1152daaedb6f527254141f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8f73736fac6f7c3f1152daaedb6f527254141f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1c1e86d5a03796ec4442372b185fb1e20d81124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c1e86d5a03796ec4442372b185fb1e20d81124", "html_url": "https://github.com/rust-lang/rust/commit/c1c1e86d5a03796ec4442372b185fb1e20d81124", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1c1e86d5a03796ec4442372b185fb1e20d81124/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a502e856034bcd4bc38152b3bd74cad792b62c63", "url": "https://api.github.com/repos/rust-lang/rust/commits/a502e856034bcd4bc38152b3bd74cad792b62c63", "html_url": "https://github.com/rust-lang/rust/commit/a502e856034bcd4bc38152b3bd74cad792b62c63"}], "stats": {"total": 163, "additions": 79, "deletions": 84}, "files": [{"sha": "fc23ffe2b8ca75987e69d5eb9acf636510f6e6fd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 79, "deletions": 84, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c1c1e86d5a03796ec4442372b185fb1e20d81124/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c1e86d5a03796ec4442372b185fb1e20d81124/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c1c1e86d5a03796ec4442372b185fb1e20d81124", "patch": "@@ -381,12 +381,6 @@ pub struct RenderInfo {\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n-#[derive(Copy, Clone)]\n-struct Item<'a> {\n-    cx: &'a Context,\n-    item: &'a clean::Item,\n-}\n-\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n@@ -1974,7 +1968,7 @@ impl Context {\n         if !self.render_redirect_pages {\n             layout::render(&self.shared.layout, &page,\n                            |buf: &mut _| print_sidebar(self, it, buf),\n-                           |buf: &mut Buffer| buf.from_display(Item { cx: self, item: it }),\n+                           |buf: &mut _| print_item(self, it, buf),\n                            &self.shared.themes)\n         } else {\n             let mut url = self.root_path();\n@@ -2115,7 +2109,7 @@ impl Context {\n     }\n }\n \n-impl<'a> Item<'a> {\n+impl Context {\n     /// Generates a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -2125,26 +2119,26 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn src_href(&self) -> Option<String> {\n-        let mut root = self.cx.root_path();\n+    fn src_href(&self, item: &clean::Item) -> Option<String> {\n+        let mut root = self.root_path();\n \n         let cache = cache();\n         let mut path = String::new();\n \n         // We can safely ignore macros from other libraries\n-        let file = match self.item.source.filename {\n+        let file = match item.source.filename {\n             FileName::Real(ref path) => path,\n             _ => return None,\n         };\n \n-        let (krate, path) = if self.item.def_id.is_local() {\n-            if let Some(path) = self.cx.shared.local_sources.get(file) {\n-                (&self.cx.shared.layout.krate, path)\n+        let (krate, path) = if item.def_id.is_local() {\n+            if let Some(path) = self.shared.local_sources.get(file) {\n+                (&self.shared.layout.krate, path)\n             } else {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&self.item.def_id.krate)? {\n+            let (krate, src_root) = match *cache.extern_locations.get(&item.def_id.krate)? {\n                 (ref name, ref src, Local) => (name, src),\n                 (ref name, ref src, Remote(ref s)) => {\n                     root = s.to_string();\n@@ -2164,10 +2158,10 @@ impl<'a> Item<'a> {\n             (krate, &path)\n         };\n \n-        let lines = if self.item.source.loline == self.item.source.hiline {\n-            self.item.source.loline.to_string()\n+        let lines = if item.source.loline == item.source.hiline {\n+            item.source.loline.to_string()\n         } else {\n-            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n+            format!(\"{}-{}\", item.source.loline, item.source.hiline)\n         };\n         Some(format!(\"{root}src/{krate}/{path}#{lines}\",\n                      root = Escape(&root),\n@@ -2185,108 +2179,109 @@ where F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result {\n     write!(w, \"</div>\")\n }\n \n-impl<'a> fmt::Display for Item<'a> {\n-fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    debug_assert!(!self.item.is_stripped());\n+fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n+    debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n-    write!(fmt, \"<h1 class='fqn'><span class='out-of-band'>\")?;\n-    if let Some(version) = self.item.stable_since() {\n-        write!(fmt, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\",\n-                version)?;\n+    write!(buf, \"<h1 class='fqn'><span class='out-of-band'>\");\n+    if let Some(version) = item.stable_since() {\n+        write!(buf, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\",\n+                version);\n     }\n-    write!(fmt,\n+    write!(buf,\n             \"<span id='render-detail'>\\\n                 <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n                     title=\\\"collapse all docs\\\">\\\n                     [<span class='inner'>&#x2212;</span>]\\\n                 </a>\\\n-            </span>\")?;\n+            </span>\");\n \n     // Write `src` tag\n     //\n     // When this item is part of a `pub use` in a downstream crate, the\n     // [src] link in the downstream documentation will actually come back to\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n-    if self.cx.shared.include_sources && !self.item.is_primitive() {\n-        if let Some(l) = self.src_href() {\n-            write!(fmt, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                    l, \"goto source code\")?;\n+    if cx.shared.include_sources && !item.is_primitive() {\n+        if let Some(l) = cx.src_href(item) {\n+            write!(buf, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                    l, \"goto source code\");\n         }\n     }\n \n-    write!(fmt, \"</span>\")?; // out-of-band\n-    write!(fmt, \"<span class='in-band'>\")?;\n-    match self.item.inner {\n+    write!(buf, \"</span>\"); // out-of-band\n+    write!(buf, \"<span class='in-band'>\");\n+    let name = match item.inner {\n         clean::ModuleItem(ref m) => if m.is_crate {\n-                write!(fmt, \"Crate \")?;\n+                \"Crate \"\n             } else {\n-                write!(fmt, \"Module \")?;\n+                \"Module \"\n             },\n-        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => write!(fmt, \"Function \")?,\n-        clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n-        clean::StructItem(..) => write!(fmt, \"Struct \")?,\n-        clean::UnionItem(..) => write!(fmt, \"Union \")?,\n-        clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n-        clean::TypedefItem(..) => write!(fmt, \"Type Definition \")?,\n-        clean::MacroItem(..) => write!(fmt, \"Macro \")?,\n+        clean::FunctionItem(..) | clean::ForeignFunctionItem(..) => \"Function \",\n+        clean::TraitItem(..) => \"Trait \",\n+        clean::StructItem(..) => \"Struct \",\n+        clean::UnionItem(..) => \"Union \",\n+        clean::EnumItem(..) => \"Enum \",\n+        clean::TypedefItem(..) => \"Type Definition \",\n+        clean::MacroItem(..) => \"Macro \",\n         clean::ProcMacroItem(ref mac) => match mac.kind {\n-            MacroKind::Bang => write!(fmt, \"Macro \")?,\n-            MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n-            MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n-        }\n-        clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n-        clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n-        clean::ConstantItem(..) => write!(fmt, \"Constant \")?,\n-        clean::ForeignTypeItem => write!(fmt, \"Foreign Type \")?,\n-        clean::KeywordItem(..) => write!(fmt, \"Keyword \")?,\n-        clean::OpaqueTyItem(..) => write!(fmt, \"Opaque Type \")?,\n-        clean::TraitAliasItem(..) => write!(fmt, \"Trait Alias \")?,\n+            MacroKind::Bang => \"Macro \",\n+            MacroKind::Attr => \"Attribute Macro \",\n+            MacroKind::Derive => \"Derive Macro \",\n+        }\n+        clean::PrimitiveItem(..) => \"Primitive Type \",\n+        clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n+        clean::ConstantItem(..) => \"Constant \",\n+        clean::ForeignTypeItem => \"Foreign Type \",\n+        clean::KeywordItem(..) => \"Keyword \",\n+        clean::OpaqueTyItem(..) => \"Opaque Type \",\n+        clean::TraitAliasItem(..) => \"Trait Alias \",\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n         }\n-    }\n-    if !self.item.is_primitive() && !self.item.is_keyword() {\n-        let cur = &self.cx.current;\n-        let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n+    };\n+    buf.write_str(name);\n+    if !item.is_primitive() && !item.is_keyword() {\n+        let cur = &cx.current;\n+        let amt = if item.is_mod() { cur.len() - 1 } else { cur.len() };\n         for (i, component) in cur.iter().enumerate().take(amt) {\n-            write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n+            write!(buf, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                     \"../\".repeat(cur.len() - i - 1),\n-                    component)?;\n+                    component);\n         }\n     }\n-    write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n-            self.item.type_(), self.item.name.as_ref().unwrap())?;\n+    write!(buf, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n+            item.type_(), item.name.as_ref().unwrap());\n \n-    write!(fmt, \"</span></h1>\")?; // in-band\n+    write!(buf, \"</span></h1>\"); // in-band\n \n-    match self.item.inner {\n+    buf.with_formatter(|fmt| {\n+    match item.inner {\n         clean::ModuleItem(ref m) =>\n-            item_module(fmt, self.cx, self.item, &m.items),\n+            item_module(fmt, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-            item_function(fmt, self.cx, self.item, f),\n-        clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n-        clean::StructItem(ref s) => item_struct(fmt, self.cx, self.item, s),\n-        clean::UnionItem(ref s) => item_union(fmt, self.cx, self.item, s),\n-        clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n-        clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n-        clean::ProcMacroItem(ref m) => item_proc_macro(fmt, self.cx, self.item, m),\n-        clean::PrimitiveItem(ref p) => item_primitive(fmt, self.cx, self.item, p),\n+            item_function(fmt, cx, item, f),\n+        clean::TraitItem(ref t) => item_trait(fmt, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(fmt, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(fmt, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(fmt, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(fmt, cx, item, t),\n+        clean::MacroItem(ref m) => item_macro(fmt, cx, item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(fmt, cx, item, m),\n+        clean::PrimitiveItem(ref p) => item_primitive(fmt, cx, item, p),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n-            item_static(fmt, self.cx, self.item, i),\n-        clean::ConstantItem(ref c) => item_constant(fmt, self.cx, self.item, c),\n-        clean::ForeignTypeItem => item_foreign_type(fmt, self.cx, self.item),\n-        clean::KeywordItem(ref k) => item_keyword(fmt, self.cx, self.item, k),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, self.cx, self.item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, self.cx, self.item, ta),\n+            item_static(fmt, cx, item, i),\n+        clean::ConstantItem(ref c) => item_constant(fmt, cx, item, c),\n+        clean::ForeignTypeItem => item_foreign_type(fmt, cx, item),\n+        clean::KeywordItem(ref k) => item_keyword(fmt, cx, item, k),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, cx, item, ta),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n         }\n     }\n-}\n+    })\n }\n \n fn item_path(ty: ItemType, name: &str) -> String {\n@@ -4004,7 +3999,7 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id)?;\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version)?;\n-        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).src_href() {\n+        if let Some(l) = cx.src_href(&i.impl_item) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n                    l, \"goto source code\")?;\n         }\n@@ -4050,7 +4045,7 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                    if let Some(l) = (Item { cx, item }).src_href() {\n+                    if let Some(l) = cx.src_href(item) {\n                         write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n                                l, \"goto source code\")?;\n                     }\n@@ -4073,7 +4068,7 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\")?;\n                 write!(w, \"</code>\")?;\n                 render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                if let Some(l) = (Item { cx, item }).src_href() {\n+                if let Some(l) = cx.src_href(item) {\n                     write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n                             l, \"goto source code\")?;\n                 }"}]}