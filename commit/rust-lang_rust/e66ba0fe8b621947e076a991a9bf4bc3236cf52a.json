{"sha": "e66ba0fe8b621947e076a991a9bf4bc3236cf52a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NmJhMGZlOGI2MjE5NDdlMDc2YTk5MWE5YmY0YmMzMjM2Y2Y1MmE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-05-26T11:32:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-26T11:32:21Z"}, "message": "Rollup merge of #51034 - oli-obk:lowering, r=pnkfelix\n\nRemove unused lowering field and method\n\nr? @nikomatsakis\n\nSo while trying to understand lowering better, I found out that there's something related to creating definitions. Analyzing that further, I realized that it is entirely dead code.\n\nThe `parent_def` field was only ever used for setting and resetting the field itself. The field was never read anywhere else and thus its value was entirely unused.\n\nMaybe the `unused_field` lint should detect when the only use of a field is the field being read without using the read value other than writing back to the field?\n\nThe diff is best viewed without whitespace changes getting in the way: https://github.com/rust-lang/rust/pull/51034/files?w=1", "tree": {"sha": "c828f77819f8b23a5c853d83173e6fc331f73878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c828f77819f8b23a5c853d83173e6fc331f73878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e66ba0fe8b621947e076a991a9bf4bc3236cf52a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbCUXFCRBK7hj4Ov3rIwAAdHIIACNzXkxQ64A1/Qg80VKdFgUu\n6TScrT7hzkBe/HhaX8ezZixbXCDUFvl/Shzwf+xgXQ3tNH19Gi2AoxkmkfhMGuBh\npczasB8veFClDz4aV16UdUi11lhDzYBcHEVJhDn6A/GOK2MgpiQJLywU191umTNq\nWIPsg+J0ZhLyKJuGNry4o69z2dOG0T2/gUMMuE0girYD2M2XFpszdpqInQFaA1qp\nwt2Yi4TWdlIMNBCK0o4sgN8SUJgbnjpxEkwEg0GmDynlvKzR9rzfKgjEbrXS8a7K\nyS6LcWPYh+QO5kLkEMKRX9NBoGADu5THFEPaiC0xzhHeSQY0OESdBL3Pwgf8foE=\n=UHDu\n-----END PGP SIGNATURE-----\n", "payload": "tree c828f77819f8b23a5c853d83173e6fc331f73878\nparent ee18e926841b5104f94a1c3b22ff9016c6b14129\nparent 6a0806b75a6e7f98b07ef14804c6e9fbc1b7b9f4\nauthor kennytm <kennytm@gmail.com> 1527334341 +0800\ncommitter GitHub <noreply@github.com> 1527334341 +0800\n\nRollup merge of #51034 - oli-obk:lowering, r=pnkfelix\n\nRemove unused lowering field and method\n\nr? @nikomatsakis\n\nSo while trying to understand lowering better, I found out that there's something related to creating definitions. Analyzing that further, I realized that it is entirely dead code.\n\nThe `parent_def` field was only ever used for setting and resetting the field itself. The field was never read anywhere else and thus its value was entirely unused.\n\nMaybe the `unused_field` lint should detect when the only use of a field is the field being read without using the read value other than writing back to the field?\n\nThe diff is best viewed without whitespace changes getting in the way: https://github.com/rust-lang/rust/pull/51034/files?w=1\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e66ba0fe8b621947e076a991a9bf4bc3236cf52a", "html_url": "https://github.com/rust-lang/rust/commit/e66ba0fe8b621947e076a991a9bf4bc3236cf52a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e66ba0fe8b621947e076a991a9bf4bc3236cf52a/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee18e926841b5104f94a1c3b22ff9016c6b14129", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee18e926841b5104f94a1c3b22ff9016c6b14129", "html_url": "https://github.com/rust-lang/rust/commit/ee18e926841b5104f94a1c3b22ff9016c6b14129"}, {"sha": "6a0806b75a6e7f98b07ef14804c6e9fbc1b7b9f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0806b75a6e7f98b07ef14804c6e9fbc1b7b9f4", "html_url": "https://github.com/rust-lang/rust/commit/6a0806b75a6e7f98b07ef14804c6e9fbc1b7b9f4"}], "stats": {"total": 399, "additions": 184, "deletions": 215}, "files": [{"sha": "d2dce2c7f69baaab71cb0c2a292fd3d7ac89242a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 184, "deletions": 215, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/e66ba0fe8b621947e076a991a9bf4bc3236cf52a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e66ba0fe8b621947e076a991a9bf4bc3236cf52a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e66ba0fe8b621947e076a991a9bf4bc3236cf52a", "patch": "@@ -82,10 +82,6 @@ pub struct LoweringContext<'a> {\n \n     cstore: &'a CrateStore,\n \n-    // As we walk the AST we must keep track of the current 'parent' def id (in\n-    // the form of a DefIndex) so that if we create a new node which introduces\n-    // a definition, then we can properly create the def id.\n-    parent_def: Option<DefIndex>,\n     resolver: &'a mut Resolver,\n     name_map: FxHashMap<Ident, Name>,\n \n@@ -205,7 +201,6 @@ pub fn lower_crate(\n         crate_root: std_inject::injected_crate_name(),\n         sess,\n         cstore,\n-        parent_def: None,\n         resolver,\n         name_map: FxHashMap(),\n         items: BTreeMap::new(),\n@@ -885,22 +880,6 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n-    where\n-        F: FnOnce(&mut LoweringContext) -> T,\n-    {\n-        let old_def = self.parent_def;\n-        self.parent_def = {\n-            let defs = self.resolver.definitions();\n-            Some(defs.opt_def_index(parent_id).unwrap())\n-        };\n-\n-        let result = f(self);\n-\n-        self.parent_def = old_def;\n-        result\n-    }\n-\n     fn def_key(&mut self, id: DefId) -> DefKey {\n         if id.is_local() {\n             self.resolver.definitions().def_key(id.index)\n@@ -2461,74 +2440,72 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n-        self.with_parent_def(i.id, |this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n-            let trait_item_def_id = this.resolver.definitions().local_def_id(node_id);\n-\n-            let (generics, node) = match i.node {\n-                TraitItemKind::Const(ref ty, ref default) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::TraitItemKind::Const(\n-                        this.lower_ty(ty, ImplTraitContext::Disallowed),\n-                        default\n-                            .as_ref()\n-                            .map(|x| this.lower_body(None, |this| this.lower_expr(x))),\n-                    ),\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let trait_item_def_id = self.resolver.definitions().local_def_id(node_id);\n+\n+        let (generics, node) = match i.node {\n+            TraitItemKind::Const(ref ty, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::TraitItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n                 ),\n-                TraitItemKind::Method(ref sig, None) => {\n-                    let names = this.lower_fn_args_to_names(&sig.decl);\n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        trait_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::TraitItemKind::Method(\n-                                this.lower_method_sig(sig, trait_item_def_id, false),\n-                                hir::TraitMethod::Required(names),\n-                            )\n-                        },\n-                    )\n-                }\n-                TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n+            ),\n+            TraitItemKind::Method(ref sig, None) => {\n+                let names = self.lower_fn_args_to_names(&sig.decl);\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    trait_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            hir::TraitMethod::Required(names),\n+                        )\n+                    },\n+                )\n+            }\n+            TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                    let body = this.lower_block(body, false);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n \n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        trait_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::TraitItemKind::Method(\n-                                this.lower_method_sig(sig, trait_item_def_id, false),\n-                                hir::TraitMethod::Provided(body_id),\n-                            )\n-                        },\n-                    )\n-                }\n-                TraitItemKind::Type(ref bounds, ref default) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::TraitItemKind::Type(\n-                        this.lower_bounds(bounds, ImplTraitContext::Disallowed),\n-                        default\n-                            .as_ref()\n-                            .map(|x| this.lower_ty(x, ImplTraitContext::Disallowed)),\n-                    ),\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    trait_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::TraitItemKind::Method(\n+                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            hir::TraitMethod::Provided(body_id),\n+                        )\n+                    },\n+                )\n+            }\n+            TraitItemKind::Type(ref bounds, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::TraitItemKind::Type(\n+                    self.lower_bounds(bounds, ImplTraitContext::Disallowed),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n                 ),\n-                TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-            };\n+            ),\n+            TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+        };\n \n-            hir::TraitItem {\n-                id: node_id,\n-                hir_id,\n-                name: this.lower_ident(i.ident),\n-                attrs: this.lower_attrs(&i.attrs),\n-                generics,\n-                node,\n-                span: i.span,\n-            }\n-        })\n+        hir::TraitItem {\n+            id: node_id,\n+            hir_id,\n+            name: self.lower_ident(i.ident),\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            node,\n+            span: i.span,\n+        }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n@@ -2557,63 +2534,61 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n-        self.with_parent_def(i.id, |this| {\n-            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n-            let impl_item_def_id = this.resolver.definitions().local_def_id(node_id);\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+        let impl_item_def_id = self.resolver.definitions().local_def_id(node_id);\n+\n+        let (generics, node) = match i.node {\n+            ImplItemKind::Const(ref ty, ref expr) => {\n+                let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n+                (\n+                    self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                    hir::ImplItemKind::Const(\n+                        self.lower_ty(ty, ImplTraitContext::Disallowed),\n+                        body_id,\n+                    ),\n+                )\n+            }\n+            ImplItemKind::Method(ref sig, ref body) => {\n+                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                    let body = this.lower_block(body, false);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n \n-            let (generics, node) = match i.node {\n-                ImplItemKind::Const(ref ty, ref expr) => {\n-                    let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n-                    (\n-                        this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                        hir::ImplItemKind::Const(\n-                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                self.add_in_band_defs(\n+                    &i.generics,\n+                    impl_item_def_id,\n+                    AnonymousLifetimeMode::PassThrough,\n+                    |this| {\n+                        hir::ImplItemKind::Method(\n+                            this.lower_method_sig(\n+                                sig,\n+                                impl_item_def_id,\n+                                impl_trait_return_allow,\n+                            ),\n                             body_id,\n-                        ),\n-                    )\n-                }\n-                ImplItemKind::Method(ref sig, ref body) => {\n-                    let body_id = this.lower_body(Some(&sig.decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n-                    let impl_trait_return_allow = !this.is_in_trait_impl;\n-\n-                    this.add_in_band_defs(\n-                        &i.generics,\n-                        impl_item_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this| {\n-                            hir::ImplItemKind::Method(\n-                                this.lower_method_sig(\n-                                    sig,\n-                                    impl_item_def_id,\n-                                    impl_trait_return_allow,\n-                                ),\n-                                body_id,\n-                            )\n-                        },\n-                    )\n-                }\n-                ImplItemKind::Type(ref ty) => (\n-                    this.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n-                    hir::ImplItemKind::Type(this.lower_ty(ty, ImplTraitContext::Disallowed)),\n-                ),\n-                ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n-            };\n-\n-            hir::ImplItem {\n-                id: node_id,\n-                hir_id,\n-                name: this.lower_ident(i.ident),\n-                attrs: this.lower_attrs(&i.attrs),\n-                generics,\n-                vis: this.lower_visibility(&i.vis, None),\n-                defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n-                node,\n-                span: i.span,\n+                        )\n+                    },\n+                )\n             }\n-        })\n+            ImplItemKind::Type(ref ty) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::Disallowed),\n+                hir::ImplItemKind::Type(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+            ),\n+            ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n+        };\n+\n+        hir::ImplItem {\n+            id: node_id,\n+            hir_id,\n+            name: self.lower_ident(i.ident),\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            vis: self.lower_visibility(&i.vis, None),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            node,\n+            span: i.span,\n+        }\n \n         // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n@@ -2689,9 +2664,7 @@ impl<'a> LoweringContext<'a> {\n             return None;\n         }\n \n-        let node = self.with_parent_def(i.id, |this| {\n-            this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n-        });\n+        let node = self.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node);\n \n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n \n@@ -2707,40 +2680,38 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n-        self.with_parent_def(i.id, |this| {\n-            let node_id = this.lower_node_id(i.id).node_id;\n-            let def_id = this.resolver.definitions().local_def_id(node_id);\n-            hir::ForeignItem {\n-                id: node_id,\n-                name: i.ident.name,\n-                attrs: this.lower_attrs(&i.attrs),\n-                node: match i.node {\n-                    ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        let (generics, (fn_dec, fn_args)) = this.add_in_band_defs(\n-                            generics,\n-                            def_id,\n-                            AnonymousLifetimeMode::PassThrough,\n-                            |this| {\n-                                (\n-                                    // Disallow impl Trait in foreign items\n-                                    this.lower_fn_decl(fdec, None, false),\n-                                    this.lower_fn_args_to_names(fdec),\n-                                )\n-                            },\n-                        );\n+        let node_id = self.lower_node_id(i.id).node_id;\n+        let def_id = self.resolver.definitions().local_def_id(node_id);\n+        hir::ForeignItem {\n+            id: node_id,\n+            name: i.ident.name,\n+            attrs: self.lower_attrs(&i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n+                        generics,\n+                        def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this| {\n+                            (\n+                                // Disallow impl Trait in foreign items\n+                                this.lower_fn_decl(fdec, None, false),\n+                                this.lower_fn_args_to_names(fdec),\n+                            )\n+                        },\n+                    );\n \n-                        hir::ForeignItemFn(fn_dec, fn_args, generics)\n-                    }\n-                    ForeignItemKind::Static(ref t, m) => {\n-                        hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)\n-                    }\n-                    ForeignItemKind::Ty => hir::ForeignItemType,\n-                    ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n-                },\n-                vis: this.lower_visibility(&i.vis, None),\n-                span: i.span,\n-            }\n-        })\n+                    hir::ForeignItemFn(fn_dec, fn_args, generics)\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemStatic(self.lower_ty(t, ImplTraitContext::Disallowed), m)\n+                }\n+                ForeignItemKind::Ty => hir::ForeignItemType,\n+                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+            },\n+            vis: self.lower_visibility(&i.vis, None),\n+            span: i.span,\n+        }\n     }\n \n     fn lower_method_sig(\n@@ -3064,46 +3035,44 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Closure(capture_clause, movability, ref decl, ref body, fn_decl_span) => {\n                 self.with_new_scopes(|this| {\n-                    this.with_parent_def(e.id, |this| {\n-                        let mut is_generator = false;\n-                        let body_id = this.lower_body(Some(decl), |this| {\n-                            let e = this.lower_expr(body);\n-                            is_generator = this.is_generator;\n-                            e\n-                        });\n-                        let generator_option = if is_generator {\n-                            if !decl.inputs.is_empty() {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0628,\n-                                    \"generators cannot have explicit arguments\"\n-                                );\n-                                this.sess.abort_if_errors();\n-                            }\n-                            Some(match movability {\n-                                Movability::Movable => hir::GeneratorMovability::Movable,\n-                                Movability::Static => hir::GeneratorMovability::Static,\n-                            })\n-                        } else {\n-                            if movability == Movability::Static {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0906,\n-                                    \"closures cannot be static\"\n-                                );\n-                            }\n-                            None\n-                        };\n-                        hir::ExprClosure(\n-                            this.lower_capture_clause(capture_clause),\n-                            this.lower_fn_decl(decl, None, false),\n-                            body_id,\n-                            fn_decl_span,\n-                            generator_option,\n-                        )\n-                    })\n+                    let mut is_generator = false;\n+                    let body_id = this.lower_body(Some(decl), |this| {\n+                        let e = this.lower_expr(body);\n+                        is_generator = this.is_generator;\n+                        e\n+                    });\n+                    let generator_option = if is_generator {\n+                        if !decl.inputs.is_empty() {\n+                            span_err!(\n+                                this.sess,\n+                                fn_decl_span,\n+                                E0628,\n+                                \"generators cannot have explicit arguments\"\n+                            );\n+                            this.sess.abort_if_errors();\n+                        }\n+                        Some(match movability {\n+                            Movability::Movable => hir::GeneratorMovability::Movable,\n+                            Movability::Static => hir::GeneratorMovability::Static,\n+                        })\n+                    } else {\n+                        if movability == Movability::Static {\n+                            span_err!(\n+                                this.sess,\n+                                fn_decl_span,\n+                                E0906,\n+                                \"closures cannot be static\"\n+                            );\n+                        }\n+                        None\n+                    };\n+                    hir::ExprClosure(\n+                        this.lower_capture_clause(capture_clause),\n+                        this.lower_fn_decl(decl, None, false),\n+                        body_id,\n+                        fn_decl_span,\n+                        generator_option,\n+                    )\n                 })\n             }\n             ExprKind::Block(ref blk, opt_label) => {"}]}