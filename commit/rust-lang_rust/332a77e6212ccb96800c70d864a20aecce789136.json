{"sha": "332a77e6212ccb96800c70d864a20aecce789136", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMmE3N2U2MjEyY2NiOTY4MDBjNzBkODY0YTIwYWVjY2U3ODkxMzY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-22T16:32:31Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-22T23:39:54Z"}, "message": "syntax: extract `builin_attrs.rs`.", "tree": {"sha": "0cfc15c942345624edf004539d83102dd796a3b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cfc15c942345624edf004539d83102dd796a3b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/332a77e6212ccb96800c70d864a20aecce789136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/332a77e6212ccb96800c70d864a20aecce789136", "html_url": "https://github.com/rust-lang/rust/commit/332a77e6212ccb96800c70d864a20aecce789136", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/332a77e6212ccb96800c70d864a20aecce789136/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7afb2a82ecf74e69e4b581558990464301790b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/7afb2a82ecf74e69e4b581558990464301790b90", "html_url": "https://github.com/rust-lang/rust/commit/7afb2a82ecf74e69e4b581558990464301790b90"}], "stats": {"total": 1447, "additions": 732, "deletions": 715}, "files": [{"sha": "0e04d4c6c23090774f7d8186e4ad7b635009e6d5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 714, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/332a77e6212ccb96800c70d864a20aecce789136/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332a77e6212ccb96800c70d864a20aecce789136/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=332a77e6212ccb96800c70d864a20aecce789136", "patch": "@@ -19,15 +19,18 @@ use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n mod active;\n use active::{ACTIVE_FEATURES};\n pub use active::{Features, INCOMPLETE_FEATURES};\n-\n-use AttributeType::*;\n-use AttributeGate::*;\n+mod builtin_attrs;\n+pub use builtin_attrs::{\n+    AttributeGate, AttributeType, GatedCfg,\n+    BuiltinAttribute, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    deprecated_attributes, is_builtin_attr,  is_builtin_attr_name,\n+};\n \n use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n     PatKind, RangeEnd,\n };\n-use crate::attr::{self, check_builtin_attribute, AttributeTemplate};\n+use crate::attr::{self, check_builtin_attribute};\n use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n@@ -41,67 +44,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::debug;\n-use lazy_static::lazy_static;\n \n use std::env;\n \n-// If you change this, please modify `src/doc/unstable-book` as well. You must\n-// move that documentation into the relevant place in the other docs, and\n-// remove the chapter on the flag.\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum AttributeType {\n-    /// Normal, builtin attribute that is consumed\n-    /// by the compiler before the unused_attribute check\n-    Normal,\n-\n-    /// Builtin attribute that may not be consumed by the compiler\n-    /// before the unused_attribute check. These attributes\n-    /// will be ignored by the unused_attribute lint\n-    Whitelisted,\n-\n-    /// Builtin attribute that is only allowed at the crate level\n-    CrateLevel,\n-}\n-\n-pub enum AttributeGate {\n-    /// Is gated by a given feature gate, reason\n-    /// and function to check if enabled\n-    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n-\n-    /// Ungated attribute, can be used on all release channels\n-    Ungated,\n-}\n-\n-/// A convenience macro for constructing attribute templates.\n-/// E.g., `template!(Word, List: \"description\")` means that the attribute\n-/// supports forms `#[attr]` and `#[attr(description)]`.\n-macro_rules! template {\n-    (Word) => { template!(@ true, None, None) };\n-    (List: $descr: expr) => { template!(@ false, Some($descr), None) };\n-    (NameValueStr: $descr: expr) => { template!(@ false, None, Some($descr)) };\n-    (Word, List: $descr: expr) => { template!(@ true, Some($descr), None) };\n-    (Word, NameValueStr: $descr: expr) => { template!(@ true, None, Some($descr)) };\n-    (List: $descr1: expr, NameValueStr: $descr2: expr) => {\n-        template!(@ false, Some($descr1), Some($descr2))\n-    };\n-    (Word, List: $descr1: expr, NameValueStr: $descr2: expr) => {\n-        template!(@ true, Some($descr1), Some($descr2))\n-    };\n-    (@ $word: expr, $list: expr, $name_value_str: expr) => { AttributeTemplate {\n-        word: $word, list: $list, name_value_str: $name_value_str\n-    } };\n-}\n-\n-impl AttributeGate {\n-    fn is_deprecated(&self) -> bool {\n-        match *self {\n-            Gated(Stability::Deprecated(_, _), ..) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Stability {\n     Unstable,\n@@ -110,657 +55,6 @@ pub enum Stability {\n     Deprecated(&'static str, Option<&'static str>),\n }\n \n-// fn() is not Debug\n-impl std::fmt::Debug for AttributeGate {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match *self {\n-            Gated(ref stab, name, expl, _) =>\n-                write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),\n-            Ungated => write!(fmt, \"Ungated\")\n-        }\n-    }\n-}\n-\n-macro_rules! cfg_fn {\n-    ($field: ident) => {{\n-        fn f(features: &Features) -> bool {\n-            features.$field\n-        }\n-        f as fn(&Features) -> bool\n-    }}\n-}\n-\n-pub fn deprecated_attributes() -> Vec<&'static (Symbol, AttributeType,\n-                                                AttributeTemplate, AttributeGate)> {\n-    BUILTIN_ATTRIBUTES.iter().filter(|(.., gate)| gate.is_deprecated()).collect()\n-}\n-\n-pub fn is_builtin_attr_name(name: ast::Name) -> bool {\n-    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n-}\n-\n-pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n-    attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).is_some()\n-}\n-\n-/// Attributes that have a special meaning to rustc or rustdoc\n-pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n-    // Normal attributes\n-\n-    (\n-        sym::warn,\n-        Normal,\n-        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n-        Ungated\n-    ),\n-    (\n-        sym::allow,\n-        Normal,\n-        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n-        Ungated\n-    ),\n-    (\n-        sym::forbid,\n-        Normal,\n-        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n-        Ungated\n-    ),\n-    (\n-        sym::deny,\n-        Normal,\n-        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n-        Ungated\n-    ),\n-\n-    (sym::macro_use, Normal, template!(Word, List: \"name1, name2, ...\"), Ungated),\n-    (sym::macro_export, Normal, template!(Word, List: \"local_inner_macros\"), Ungated),\n-    (sym::plugin_registrar, Normal, template!(Word), Ungated),\n-\n-    (sym::cfg, Normal, template!(List: \"predicate\"), Ungated),\n-    (sym::cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\"), Ungated),\n-    (sym::main, Normal, template!(Word), Ungated),\n-    (sym::start, Normal, template!(Word), Ungated),\n-    (sym::repr, Normal, template!(List: \"C, packed, ...\"), Ungated),\n-    (sym::path, Normal, template!(NameValueStr: \"file\"), Ungated),\n-    (sym::automatically_derived, Normal, template!(Word), Ungated),\n-    (sym::no_mangle, Whitelisted, template!(Word), Ungated),\n-    (sym::no_link, Normal, template!(Word), Ungated),\n-    (sym::derive, Normal, template!(List: \"Trait1, Trait2, ...\"), Ungated),\n-    (\n-        sym::should_panic,\n-        Normal,\n-        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n-        Ungated\n-    ),\n-    (sym::ignore, Normal, template!(Word, NameValueStr: \"reason\"), Ungated),\n-    (sym::no_implicit_prelude, Normal, template!(Word), Ungated),\n-    (sym::reexport_test_harness_main, Normal, template!(NameValueStr: \"name\"), Ungated),\n-    (sym::link_args, Normal, template!(NameValueStr: \"args\"), Gated(Stability::Unstable,\n-                                sym::link_args,\n-                                \"the `link_args` attribute is experimental and not \\\n-                                portable across platforms, it is recommended to \\\n-                                use `#[link(name = \\\"foo\\\")] instead\",\n-                                cfg_fn!(link_args))),\n-    (sym::macro_escape, Normal, template!(Word), Ungated),\n-\n-    // RFC #1445.\n-    (sym::structural_match, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::structural_match,\n-                                            \"the semantics of constant patterns is \\\n-                                            not yet settled\",\n-                                            cfg_fn!(structural_match))),\n-\n-    // RFC #2008\n-    (sym::non_exhaustive, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        sym::non_exhaustive,\n-                                        \"non exhaustive is an experimental feature\",\n-                                        cfg_fn!(non_exhaustive))),\n-\n-    // RFC #1268\n-    (sym::marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                            sym::marker_trait_attr,\n-                            \"marker traits is an experimental feature\",\n-                            cfg_fn!(marker_trait_attr))),\n-\n-    (sym::plugin, CrateLevel, template!(List: \"name|name(args)\"), Gated(Stability::Unstable,\n-                                sym::plugin,\n-                                \"compiler plugins are experimental \\\n-                                and possibly buggy\",\n-                                cfg_fn!(plugin))),\n-\n-    (sym::no_std, CrateLevel, template!(Word), Ungated),\n-    (sym::no_core, CrateLevel, template!(Word), Gated(Stability::Unstable,\n-                                sym::no_core,\n-                                \"no_core is experimental\",\n-                                cfg_fn!(no_core))),\n-    (sym::lang, Normal, template!(NameValueStr: \"name\"), Gated(Stability::Unstable,\n-                        sym::lang_items,\n-                        \"language items are subject to change\",\n-                        cfg_fn!(lang_items))),\n-    (sym::linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n-                                Gated(Stability::Unstable,\n-                                sym::linkage,\n-                                \"the `linkage` attribute is experimental \\\n-                                    and not portable across platforms\",\n-                                cfg_fn!(linkage))),\n-    (sym::thread_local, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        sym::thread_local,\n-                                        \"`#[thread_local]` is an experimental feature, and does \\\n-                                         not currently handle destructors\",\n-                                        cfg_fn!(thread_local))),\n-\n-    (sym::rustc_on_unimplemented, Whitelisted, template!(List:\n-                        r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n-                        NameValueStr: \"message\"),\n-                                            Gated(Stability::Unstable,\n-                                            sym::on_unimplemented,\n-                                            \"the `#[rustc_on_unimplemented]` attribute \\\n-                                            is an experimental feature\",\n-                                            cfg_fn!(on_unimplemented))),\n-    (sym::rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n-                                            Gated(Stability::Unstable,\n-                                            sym::rustc_const_unstable,\n-                                            \"the `#[rustc_const_unstable]` attribute \\\n-                                            is an internal feature\",\n-                                            cfg_fn!(rustc_const_unstable))),\n-    (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::allocator_internals,\n-                                            \"the `#[default_lib_allocator]` \\\n-                                            attribute is an experimental feature\",\n-                                            cfg_fn!(allocator_internals))),\n-    (sym::needs_allocator, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    sym::allocator_internals,\n-                                    \"the `#[needs_allocator]` \\\n-                                    attribute is an experimental \\\n-                                    feature\",\n-                                    cfg_fn!(allocator_internals))),\n-    (sym::panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        sym::panic_runtime,\n-                                        \"the `#[panic_runtime]` attribute is \\\n-                                        an experimental feature\",\n-                                        cfg_fn!(panic_runtime))),\n-    (sym::needs_panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::needs_panic_runtime,\n-                                            \"the `#[needs_panic_runtime]` \\\n-                                                attribute is an experimental \\\n-                                                feature\",\n-                                            cfg_fn!(needs_panic_runtime))),\n-    (sym::rustc_outlives, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_outlives]` attribute \\\n-                                    is just used for rustc unit tests \\\n-                                    and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_variance, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_variance]` attribute \\\n-                                    is just used for rustc unit tests \\\n-                                    and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_layout, Normal, template!(List: \"field1, field2, ...\"),\n-    Gated(Stability::Unstable,\n-        sym::rustc_attrs,\n-        \"the `#[rustc_layout]` attribute \\\n-            is just used for rustc unit tests \\\n-            and will never be stable\",\n-        cfg_fn!(rustc_attrs))),\n-    (sym::rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n-    Gated(Stability::Unstable,\n-        sym::rustc_attrs,\n-        \"the `#[rustc_layout_scalar_valid_range_start]` attribute \\\n-            is just used to enable niche optimizations in libcore \\\n-            and will never be stable\",\n-        cfg_fn!(rustc_attrs))),\n-    (sym::rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n-    Gated(Stability::Unstable,\n-        sym::rustc_attrs,\n-        \"the `#[rustc_layout_scalar_valid_range_end]` attribute \\\n-            is just used to enable niche optimizations in libcore \\\n-            and will never be stable\",\n-        cfg_fn!(rustc_attrs))),\n-    (sym::rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n-    Gated(Stability::Unstable,\n-        sym::rustc_attrs,\n-        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute \\\n-            is just used to enable niche optimizations in libcore \\\n-            and will never be stable\",\n-        cfg_fn!(rustc_attrs))),\n-    (sym::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_regions]` attribute \\\n-                                    is just used for rustc unit tests \\\n-                                    and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_error, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_error]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_dump_user_substs, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"this attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\"),\n-                                                Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"the `#[rustc_if_this_changed]` attribute \\\n-                                                is just used for rustc unit tests \\\n-                                                and will never be stable\",\n-                                                cfg_fn!(rustc_attrs))),\n-    (sym::rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\"),\n-                                                    Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"the `#[rustc_if_this_changed]` attribute \\\n-                                                    is just used for rustc unit tests \\\n-                                                    and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_dirty, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n-                                                    /*opt*/ except = \"...\"\"#),\n-                                    Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_dirty]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_clean, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n-                                                    /*opt*/ except = \"...\"\"#),\n-                                    Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_clean]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (\n-        sym::rustc_partition_reused,\n-        Whitelisted,\n-        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n-        Gated(\n-            Stability::Unstable,\n-            sym::rustc_attrs,\n-            \"this attribute \\\n-            is just used for rustc unit tests \\\n-            and will never be stable\",\n-            cfg_fn!(rustc_attrs)\n-        )\n-    ),\n-    (\n-        sym::rustc_partition_codegened,\n-        Whitelisted,\n-        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n-        Gated(\n-            Stability::Unstable,\n-            sym::rustc_attrs,\n-            \"this attribute \\\n-            is just used for rustc unit tests \\\n-            and will never be stable\",\n-            cfg_fn!(rustc_attrs),\n-        )\n-    ),\n-    (sym::rustc_expected_cgu_reuse, Whitelisted, template!(List: r#\"cfg = \"...\", module = \"...\",\n-                                                            kind = \"...\"\"#),\n-                                                    Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"this attribute \\\n-                                                    is just used for rustc unit tests \\\n-                                                    and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_synthetic, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"this attribute \\\n-                                                    is just used for rustc unit tests \\\n-                                                    and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_symbol_name, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::rustc_attrs,\n-                                            \"internal rustc attributes will never be stable\",\n-                                            cfg_fn!(rustc_attrs))),\n-    (sym::rustc_def_path, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        sym::rustc_attrs,\n-                                        \"internal rustc attributes will never be stable\",\n-                                        cfg_fn!(rustc_attrs))),\n-    (sym::rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\"), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_mir]` attribute \\\n-                                    is just used for rustc unit tests \\\n-                                    and will never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (\n-        sym::rustc_inherit_overflow_checks,\n-        Whitelisted,\n-        template!(Word),\n-        Gated(\n-            Stability::Unstable,\n-            sym::rustc_attrs,\n-            \"the `#[rustc_inherit_overflow_checks]` \\\n-            attribute is just used to control \\\n-            overflow checking behavior of several \\\n-            libcore functions that are inlined \\\n-            across crates and will never be stable\",\n-            cfg_fn!(rustc_attrs),\n-        )\n-    ),\n-\n-    (sym::rustc_dump_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"the `#[rustc_dump_program_clauses]` \\\n-                                                    attribute is just used for rustc unit \\\n-                                                    tests and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_dump_env_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"the `#[rustc_dump_env_program_clauses]` \\\n-                                                    attribute is just used for rustc unit \\\n-                                                    tests and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_object_lifetime_default, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"the `#[rustc_object_lifetime_default]` \\\n-                                                    attribute is just used for rustc unit \\\n-                                                    tests and will never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"the `#[rustc_test_marker]` attribute \\\n-                                    is used internally to track tests\",\n-                                    cfg_fn!(rustc_attrs))),\n-    (sym::rustc_macro_transparency, Whitelisted, template!(NameValueStr:\n-                                                           \"transparent|semitransparent|opaque\"),\n-                                                Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"used internally for testing macro hygiene\",\n-                                                    cfg_fn!(rustc_attrs))),\n-    (sym::compiler_builtins, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::compiler_builtins,\n-                                            \"the `#[compiler_builtins]` attribute is used to \\\n-                                            identify the `compiler_builtins` crate which \\\n-                                            contains compiler-rt intrinsics and will never be \\\n-                                            stable\",\n-                                        cfg_fn!(compiler_builtins))),\n-    (sym::sanitizer_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::sanitizer_runtime,\n-                                            \"the `#[sanitizer_runtime]` attribute is used to \\\n-                                            identify crates that contain the runtime of a \\\n-                                            sanitizer and will never be stable\",\n-                                            cfg_fn!(sanitizer_runtime))),\n-    (sym::profiler_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            sym::profiler_runtime,\n-                                            \"the `#[profiler_runtime]` attribute is used to \\\n-                                            identify the `profiler_builtins` crate which \\\n-                                            contains the profiler runtime and will never be \\\n-                                            stable\",\n-                                            cfg_fn!(profiler_runtime))),\n-\n-    (sym::allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n-                                            Gated(Stability::Unstable,\n-                                            sym::allow_internal_unstable,\n-                                            EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n-                                            cfg_fn!(allow_internal_unstable))),\n-\n-    (sym::allow_internal_unsafe, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            sym::allow_internal_unsafe,\n-                                            EXPLAIN_ALLOW_INTERNAL_UNSAFE,\n-                                            cfg_fn!(allow_internal_unsafe))),\n-\n-    (sym::fundamental, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    sym::fundamental,\n-                                    \"the `#[fundamental]` attribute \\\n-                                        is an experimental feature\",\n-                                    cfg_fn!(fundamental))),\n-\n-    (sym::proc_macro_derive, Normal, template!(List: \"TraitName, \\\n-                                                /*opt*/ attributes(name1, name2, ...)\"),\n-                                    Ungated),\n-\n-    (sym::rustc_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n-    (sym::rustc_allocator_nounwind, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n-    (sym::rustc_builtin_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n-    (sym::rustc_promotable, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n-    (sym::rustc_allow_const_fn_ptr, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n-    (sym::rustc_dummy, Normal, template!(Word /* doesn't matter*/), Gated(Stability::Unstable,\n-                                         sym::rustc_attrs,\n-                                         \"used by the test suite\",\n-                                         cfg_fn!(rustc_attrs))),\n-\n-    // FIXME: #14408 whitelist docs since rustdoc looks at them\n-    (\n-        sym::doc,\n-        Whitelisted,\n-        template!(List: \"hidden|inline|...\", NameValueStr: \"string\"),\n-        Ungated\n-    ),\n-\n-    // FIXME: #14406 these are processed in codegen, which happens after the\n-    // lint pass\n-    (sym::cold, Whitelisted, template!(Word), Ungated),\n-    (sym::naked, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                sym::naked_functions,\n-                                \"the `#[naked]` attribute \\\n-                                is an experimental feature\",\n-                                cfg_fn!(naked_functions))),\n-    (sym::ffi_returns_twice, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                sym::ffi_returns_twice,\n-                                \"the `#[ffi_returns_twice]` attribute \\\n-                                is an experimental feature\",\n-                                cfg_fn!(ffi_returns_twice))),\n-    (sym::target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#), Ungated),\n-    (sym::export_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (sym::inline, Whitelisted, template!(Word, List: \"always|never\"), Ungated),\n-    (sym::link, Whitelisted, template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n-                                               /*opt*/ cfg = \"...\"\"#), Ungated),\n-    (sym::link_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (sym::link_section, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n-    (sym::no_builtins, Whitelisted, template!(Word), Ungated),\n-    (sym::no_debug, Whitelisted, template!(Word), Gated(\n-        Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n-        sym::no_debug,\n-        \"the `#[no_debug]` attribute was an experimental feature that has been \\\n-        deprecated due to lack of demand\",\n-        cfg_fn!(no_debug))),\n-    (\n-        sym::omit_gdb_pretty_printer_section,\n-        Whitelisted,\n-        template!(Word),\n-        Gated(\n-            Stability::Unstable,\n-            sym::omit_gdb_pretty_printer_section,\n-            \"the `#[omit_gdb_pretty_printer_section]` \\\n-                attribute is just used for the Rust test \\\n-                suite\",\n-            cfg_fn!(omit_gdb_pretty_printer_section)\n-        )\n-    ),\n-    (sym::may_dangle,\n-    Normal,\n-    template!(Word),\n-    Gated(Stability::Unstable,\n-        sym::dropck_eyepatch,\n-        \"`may_dangle` has unstable semantics and may be removed in the future\",\n-        cfg_fn!(dropck_eyepatch))),\n-    (sym::unwind, Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n-                                sym::unwind_attributes,\n-                                \"`#[unwind]` is experimental\",\n-                                cfg_fn!(unwind_attributes))),\n-    (sym::used, Whitelisted, template!(Word), Ungated),\n-\n-    // used in resolve\n-    (sym::prelude_import, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        sym::prelude_import,\n-                                        \"`#[prelude_import]` is for use by rustc only\",\n-                                        cfg_fn!(prelude_import))),\n-\n-    // FIXME: #14407 these are only looked at on-demand so we can't\n-    // guarantee they'll have already been checked\n-    (\n-        sym::rustc_deprecated,\n-        Whitelisted,\n-        template!(List: r#\"since = \"version\", reason = \"...\"\"#),\n-        Ungated\n-    ),\n-    (sym::must_use, Whitelisted, template!(Word, NameValueStr: \"reason\"), Ungated),\n-    (\n-        sym::stable,\n-        Whitelisted,\n-        template!(List: r#\"feature = \"name\", since = \"version\"\"#),\n-        Ungated\n-    ),\n-    (\n-        sym::unstable,\n-        Whitelisted,\n-        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n-        Ungated\n-    ),\n-    (sym::deprecated,\n-        Normal,\n-        template!(\n-            Word,\n-            List: r#\"/*opt*/ since = \"version\", /*opt*/ note = \"reason\"\"#,\n-            NameValueStr: \"reason\"\n-        ),\n-        Ungated\n-    ),\n-\n-    (sym::rustc_paren_sugar, Normal, template!(Word), Gated(Stability::Unstable,\n-                                        sym::unboxed_closures,\n-                                        \"unboxed_closures are still evolving\",\n-                                        cfg_fn!(unboxed_closures))),\n-\n-    (sym::windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\"), Ungated),\n-\n-    (sym::proc_macro_attribute, Normal, template!(Word), Ungated),\n-    (sym::proc_macro, Normal, template!(Word), Ungated),\n-\n-    (sym::rustc_proc_macro_decls, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            sym::rustc_attrs,\n-                                            \"used internally by rustc\",\n-                                            cfg_fn!(rustc_attrs))),\n-\n-    (sym::allow_fail, Normal, template!(Word), Gated(Stability::Unstable,\n-                                sym::allow_fail,\n-                                \"allow_fail attribute is currently unstable\",\n-                                cfg_fn!(allow_fail))),\n-\n-    (sym::rustc_std_internal_symbol, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    sym::rustc_attrs,\n-                                    \"this is an internal attribute that will \\\n-                                    never be stable\",\n-                                    cfg_fn!(rustc_attrs))),\n-\n-    // whitelists \"identity-like\" conversion methods to suggest on type mismatch\n-    (sym::rustc_conversion_suggestion, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    sym::rustc_attrs,\n-                                                    \"this is an internal attribute that will \\\n-                                                        never be stable\",\n-                                                    cfg_fn!(rustc_attrs))),\n-\n-    (\n-        sym::rustc_args_required_const,\n-        Whitelisted,\n-        template!(List: \"N\"),\n-        Gated(Stability::Unstable, sym::rustc_attrs, \"never will be stable\",\n-           cfg_fn!(rustc_attrs))\n-    ),\n-    // RFC 2070\n-    (sym::panic_handler, Normal, template!(Word), Ungated),\n-\n-    (sym::alloc_error_handler, Normal, template!(Word), Gated(Stability::Unstable,\n-                        sym::alloc_error_handler,\n-                        \"`#[alloc_error_handler]` is an unstable feature\",\n-                        cfg_fn!(alloc_error_handler))),\n-\n-    // RFC 2412\n-    (sym::optimize, Whitelisted, template!(List: \"size|speed\"), Gated(Stability::Unstable,\n-                            sym::optimize_attribute,\n-                            \"`#[optimize]` attribute is an unstable feature\",\n-                            cfg_fn!(optimize_attribute))),\n-\n-    // Crate level attributes\n-    (sym::crate_name, CrateLevel, template!(NameValueStr: \"name\"), Ungated),\n-    (sym::crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), Ungated),\n-    (sym::crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), Ungated),\n-    (sym::feature, CrateLevel, template!(List: \"name1, name1, ...\"), Ungated),\n-    (sym::no_start, CrateLevel, template!(Word), Ungated),\n-    (sym::no_main, CrateLevel, template!(Word), Ungated),\n-    (sym::recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n-    (sym::type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n-    (sym::test_runner, CrateLevel, template!(List: \"path\"), Gated(Stability::Unstable,\n-                    sym::custom_test_frameworks,\n-                    \"custom test frameworks are an unstable feature\",\n-                    cfg_fn!(custom_test_frameworks))),\n-];\n-\n-pub type BuiltinAttribute = (Symbol, AttributeType, AttributeTemplate, AttributeGate);\n-\n-lazy_static! {\n-    pub static ref BUILTIN_ATTRIBUTE_MAP: FxHashMap<Symbol, &'static BuiltinAttribute> = {\n-        let mut map = FxHashMap::default();\n-        for attr in BUILTIN_ATTRIBUTES.iter() {\n-            if map.insert(attr.0, attr).is_some() {\n-                panic!(\"duplicate builtin attribute `{}`\", attr.0);\n-            }\n-        }\n-        map\n-    };\n-}\n-\n-// cfg(...)'s that are feature gated\n-const GATED_CFGS: &[(Symbol, Symbol, fn(&Features) -> bool)] = &[\n-    // (name in cfg, feature, function to check if the feature is enabled)\n-    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n-    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n-    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n-    (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n-];\n-\n-#[derive(Debug)]\n-pub struct GatedCfg {\n-    span: Span,\n-    index: usize,\n-}\n-\n-impl GatedCfg {\n-    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        GATED_CFGS.iter()\n-                  .position(|info| cfg.check_name(info.0))\n-                  .map(|idx| {\n-                      GatedCfg {\n-                          span: cfg.span,\n-                          index: idx\n-                      }\n-                  })\n-    }\n-\n-    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n-        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) && !self.span.allows_unstable(feature) {\n-            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n-            emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n-        }\n-    }\n-}\n-\n struct Context<'a> {\n     features: &'a Features,\n     parse_sess: &'a ParseSess,\n@@ -800,7 +94,7 @@ impl<'a> Context<'a> {\n     ) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n-            if let Gated(_, name, desc, ref has_feature) = *gateage {\n+            if let AttributeGate::Gated(_, name, desc, ref has_feature) = *gateage {\n                 if !attr.span.allows_unstable(name) {\n                     gate_feature_fn!(\n                         self, has_feature, attr.span, name, desc, GateStrength::Hard"}, {"sha": "46330df364852963702e6854b44742d2378337b5", "filename": "src/libsyntax/feature_gate/attr.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7afb2a82ecf74e69e4b581558990464301790b90/src%2Flibsyntax%2Ffeature_gate%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7afb2a82ecf74e69e4b581558990464301790b90/src%2Flibsyntax%2Ffeature_gate%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fattr.rs?ref=7afb2a82ecf74e69e4b581558990464301790b90", "patch": "@@ -1 +0,0 @@\n-//! TODO"}, {"sha": "17e58df89e1371edd891f860a32e02bef8468858", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "added", "additions": 724, "deletions": 0, "changes": 724, "blob_url": "https://github.com/rust-lang/rust/blob/332a77e6212ccb96800c70d864a20aecce789136/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332a77e6212ccb96800c70d864a20aecce789136/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=332a77e6212ccb96800c70d864a20aecce789136", "patch": "@@ -0,0 +1,724 @@\n+//! Built-in attributes and `cfg` flag gating.\n+\n+use AttributeType::*;\n+use AttributeGate::*;\n+\n+use super::{emit_feature_err, GateIssue};\n+use super::{Stability, EXPLAIN_ALLOW_INTERNAL_UNSAFE, EXPLAIN_ALLOW_INTERNAL_UNSTABLE};\n+use super::active::Features;\n+\n+use crate::ast;\n+use crate::attr::AttributeTemplate;\n+use crate::symbol::{Symbol, sym};\n+use crate::parse::ParseSess;\n+\n+use syntax_pos::Span;\n+use rustc_data_structures::fx::FxHashMap;\n+use lazy_static::lazy_static;\n+\n+macro_rules! cfg_fn {\n+    ($field: ident) => {{\n+        fn f(features: &Features) -> bool {\n+            features.$field\n+        }\n+        f as fn(&Features) -> bool\n+    }}\n+}\n+\n+// cfg(...)'s that are feature gated\n+const GATED_CFGS: &[(Symbol, Symbol, fn(&Features) -> bool)] = &[\n+    // (name in cfg, feature, function to check if the feature is enabled)\n+    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n+    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n+    (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n+];\n+\n+#[derive(Debug)]\n+pub struct GatedCfg {\n+    span: Span,\n+    index: usize,\n+}\n+\n+impl GatedCfg {\n+    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n+        GATED_CFGS.iter()\n+                  .position(|info| cfg.check_name(info.0))\n+                  .map(|idx| {\n+                      GatedCfg {\n+                          span: cfg.span,\n+                          index: idx\n+                      }\n+                  })\n+    }\n+\n+    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n+        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n+        if !has_feature(features) && !self.span.allows_unstable(feature) {\n+            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+            emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n+        }\n+    }\n+}\n+\n+// If you change this, please modify `src/doc/unstable-book` as well. You must\n+// move that documentation into the relevant place in the other docs, and\n+// remove the chapter on the flag.\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n+\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n+\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n+pub enum AttributeGate {\n+    /// Is gated by a given feature gate, reason\n+    /// and function to check if enabled\n+    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n+\n+    /// Ungated attribute, can be used on all release channels\n+    Ungated,\n+}\n+\n+// fn() is not Debug\n+impl std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match *self {\n+            Self::Gated(ref stab, name, expl, _) =>\n+                write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),\n+            Self::Ungated => write!(fmt, \"Ungated\")\n+        }\n+    }\n+}\n+\n+impl AttributeGate {\n+    fn is_deprecated(&self) -> bool {\n+        match *self {\n+            Self::Gated(Stability::Deprecated(_, _), ..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// A convenience macro for constructing attribute templates.\n+/// E.g., `template!(Word, List: \"description\")` means that the attribute\n+/// supports forms `#[attr]` and `#[attr(description)]`.\n+macro_rules! template {\n+    (Word) => { template!(@ true, None, None) };\n+    (List: $descr: expr) => { template!(@ false, Some($descr), None) };\n+    (NameValueStr: $descr: expr) => { template!(@ false, None, Some($descr)) };\n+    (Word, List: $descr: expr) => { template!(@ true, Some($descr), None) };\n+    (Word, NameValueStr: $descr: expr) => { template!(@ true, None, Some($descr)) };\n+    (List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ false, Some($descr1), Some($descr2))\n+    };\n+    (Word, List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ true, Some($descr1), Some($descr2))\n+    };\n+    (@ $word: expr, $list: expr, $name_value_str: expr) => { AttributeTemplate {\n+        word: $word, list: $list, name_value_str: $name_value_str\n+    } };\n+}\n+\n+pub type BuiltinAttribute = (Symbol, AttributeType, AttributeTemplate, AttributeGate);\n+\n+/// Attributes that have a special meaning to rustc or rustdoc\n+pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n+    // Normal attributes\n+\n+    (\n+        sym::warn,\n+        Normal,\n+        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        Ungated\n+    ),\n+    (\n+        sym::allow,\n+        Normal,\n+        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        Ungated\n+    ),\n+    (\n+        sym::forbid,\n+        Normal,\n+        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        Ungated\n+    ),\n+    (\n+        sym::deny,\n+        Normal,\n+        template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        Ungated\n+    ),\n+\n+    (sym::macro_use, Normal, template!(Word, List: \"name1, name2, ...\"), Ungated),\n+    (sym::macro_export, Normal, template!(Word, List: \"local_inner_macros\"), Ungated),\n+    (sym::plugin_registrar, Normal, template!(Word), Ungated),\n+\n+    (sym::cfg, Normal, template!(List: \"predicate\"), Ungated),\n+    (sym::cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\"), Ungated),\n+    (sym::main, Normal, template!(Word), Ungated),\n+    (sym::start, Normal, template!(Word), Ungated),\n+    (sym::repr, Normal, template!(List: \"C, packed, ...\"), Ungated),\n+    (sym::path, Normal, template!(NameValueStr: \"file\"), Ungated),\n+    (sym::automatically_derived, Normal, template!(Word), Ungated),\n+    (sym::no_mangle, Whitelisted, template!(Word), Ungated),\n+    (sym::no_link, Normal, template!(Word), Ungated),\n+    (sym::derive, Normal, template!(List: \"Trait1, Trait2, ...\"), Ungated),\n+    (\n+        sym::should_panic,\n+        Normal,\n+        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n+        Ungated\n+    ),\n+    (sym::ignore, Normal, template!(Word, NameValueStr: \"reason\"), Ungated),\n+    (sym::no_implicit_prelude, Normal, template!(Word), Ungated),\n+    (sym::reexport_test_harness_main, Normal, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::link_args, Normal, template!(NameValueStr: \"args\"), Gated(Stability::Unstable,\n+                                sym::link_args,\n+                                \"the `link_args` attribute is experimental and not \\\n+                                portable across platforms, it is recommended to \\\n+                                use `#[link(name = \\\"foo\\\")] instead\",\n+                                cfg_fn!(link_args))),\n+    (sym::macro_escape, Normal, template!(Word), Ungated),\n+\n+    // RFC #1445.\n+    (sym::structural_match, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::structural_match,\n+                                            \"the semantics of constant patterns is \\\n+                                            not yet settled\",\n+                                            cfg_fn!(structural_match))),\n+\n+    // RFC #2008\n+    (sym::non_exhaustive, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::non_exhaustive,\n+                                        \"non exhaustive is an experimental feature\",\n+                                        cfg_fn!(non_exhaustive))),\n+\n+    // RFC #1268\n+    (sym::marker, Normal, template!(Word), Gated(Stability::Unstable,\n+                            sym::marker_trait_attr,\n+                            \"marker traits is an experimental feature\",\n+                            cfg_fn!(marker_trait_attr))),\n+\n+    (sym::plugin, CrateLevel, template!(List: \"name|name(args)\"), Gated(Stability::Unstable,\n+                                sym::plugin,\n+                                \"compiler plugins are experimental \\\n+                                and possibly buggy\",\n+                                cfg_fn!(plugin))),\n+\n+    (sym::no_std, CrateLevel, template!(Word), Ungated),\n+    (sym::no_core, CrateLevel, template!(Word), Gated(Stability::Unstable,\n+                                sym::no_core,\n+                                \"no_core is experimental\",\n+                                cfg_fn!(no_core))),\n+    (sym::lang, Normal, template!(NameValueStr: \"name\"), Gated(Stability::Unstable,\n+                        sym::lang_items,\n+                        \"language items are subject to change\",\n+                        cfg_fn!(lang_items))),\n+    (sym::linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n+                                Gated(Stability::Unstable,\n+                                sym::linkage,\n+                                \"the `linkage` attribute is experimental \\\n+                                    and not portable across platforms\",\n+                                cfg_fn!(linkage))),\n+    (sym::thread_local, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::thread_local,\n+                                        \"`#[thread_local]` is an experimental feature, and does \\\n+                                         not currently handle destructors\",\n+                                        cfg_fn!(thread_local))),\n+\n+    (sym::rustc_on_unimplemented, Whitelisted, template!(List:\n+                        r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n+                        NameValueStr: \"message\"),\n+                                            Gated(Stability::Unstable,\n+                                            sym::on_unimplemented,\n+                                            \"the `#[rustc_on_unimplemented]` attribute \\\n+                                            is an experimental feature\",\n+                                            cfg_fn!(on_unimplemented))),\n+    (sym::rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n+                                            Gated(Stability::Unstable,\n+                                            sym::rustc_const_unstable,\n+                                            \"the `#[rustc_const_unstable]` attribute \\\n+                                            is an internal feature\",\n+                                            cfg_fn!(rustc_const_unstable))),\n+    (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::allocator_internals,\n+                                            \"the `#[default_lib_allocator]` \\\n+                                            attribute is an experimental feature\",\n+                                            cfg_fn!(allocator_internals))),\n+    (sym::needs_allocator, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::allocator_internals,\n+                                    \"the `#[needs_allocator]` \\\n+                                    attribute is an experimental \\\n+                                    feature\",\n+                                    cfg_fn!(allocator_internals))),\n+    (sym::panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::panic_runtime,\n+                                        \"the `#[panic_runtime]` attribute is \\\n+                                        an experimental feature\",\n+                                        cfg_fn!(panic_runtime))),\n+    (sym::needs_panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::needs_panic_runtime,\n+                                            \"the `#[needs_panic_runtime]` \\\n+                                                attribute is an experimental \\\n+                                                feature\",\n+                                            cfg_fn!(needs_panic_runtime))),\n+    (sym::rustc_outlives, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_outlives]` attribute \\\n+                                    is just used for rustc unit tests \\\n+                                    and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_variance, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_variance]` attribute \\\n+                                    is just used for rustc unit tests \\\n+                                    and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_layout, Normal, template!(List: \"field1, field2, ...\"),\n+    Gated(Stability::Unstable,\n+        sym::rustc_attrs,\n+        \"the `#[rustc_layout]` attribute \\\n+            is just used for rustc unit tests \\\n+            and will never be stable\",\n+        cfg_fn!(rustc_attrs))),\n+    (sym::rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n+    Gated(Stability::Unstable,\n+        sym::rustc_attrs,\n+        \"the `#[rustc_layout_scalar_valid_range_start]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+        cfg_fn!(rustc_attrs))),\n+    (sym::rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n+    Gated(Stability::Unstable,\n+        sym::rustc_attrs,\n+        \"the `#[rustc_layout_scalar_valid_range_end]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+        cfg_fn!(rustc_attrs))),\n+    (sym::rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n+    Gated(Stability::Unstable,\n+        sym::rustc_attrs,\n+        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute \\\n+            is just used to enable niche optimizations in libcore \\\n+            and will never be stable\",\n+        cfg_fn!(rustc_attrs))),\n+    (sym::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_regions]` attribute \\\n+                                    is just used for rustc unit tests \\\n+                                    and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_error, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_error]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_dump_user_substs, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"this attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\"),\n+                                                Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"the `#[rustc_if_this_changed]` attribute \\\n+                                                is just used for rustc unit tests \\\n+                                                and will never be stable\",\n+                                                cfg_fn!(rustc_attrs))),\n+    (sym::rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\"),\n+                                                    Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_if_this_changed]` attribute \\\n+                                                    is just used for rustc unit tests \\\n+                                                    and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_dirty, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n+                                                    /*opt*/ except = \"...\"\"#),\n+                                    Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_dirty]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_clean, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n+                                                    /*opt*/ except = \"...\"\"#),\n+                                    Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_clean]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (\n+        sym::rustc_partition_reused,\n+        Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+        Gated(\n+            Stability::Unstable,\n+            sym::rustc_attrs,\n+            \"this attribute \\\n+            is just used for rustc unit tests \\\n+            and will never be stable\",\n+            cfg_fn!(rustc_attrs)\n+        )\n+    ),\n+    (\n+        sym::rustc_partition_codegened,\n+        Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+        Gated(\n+            Stability::Unstable,\n+            sym::rustc_attrs,\n+            \"this attribute \\\n+            is just used for rustc unit tests \\\n+            and will never be stable\",\n+            cfg_fn!(rustc_attrs),\n+        )\n+    ),\n+    (sym::rustc_expected_cgu_reuse, Whitelisted, template!(List: r#\"cfg = \"...\", module = \"...\",\n+                                                            kind = \"...\"\"#),\n+                                                    Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"this attribute \\\n+                                                    is just used for rustc unit tests \\\n+                                                    and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_synthetic, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"this attribute \\\n+                                                    is just used for rustc unit tests \\\n+                                                    and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_symbol_name, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::rustc_attrs,\n+                                            \"internal rustc attributes will never be stable\",\n+                                            cfg_fn!(rustc_attrs))),\n+    (sym::rustc_def_path, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::rustc_attrs,\n+                                        \"internal rustc attributes will never be stable\",\n+                                        cfg_fn!(rustc_attrs))),\n+    (sym::rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\"), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_mir]` attribute \\\n+                                    is just used for rustc unit tests \\\n+                                    and will never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (\n+        sym::rustc_inherit_overflow_checks,\n+        Whitelisted,\n+        template!(Word),\n+        Gated(\n+            Stability::Unstable,\n+            sym::rustc_attrs,\n+            \"the `#[rustc_inherit_overflow_checks]` \\\n+            attribute is just used to control \\\n+            overflow checking behavior of several \\\n+            libcore functions that are inlined \\\n+            across crates and will never be stable\",\n+            cfg_fn!(rustc_attrs),\n+        )\n+    ),\n+\n+    (sym::rustc_dump_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_dump_program_clauses]` \\\n+                                                    attribute is just used for rustc unit \\\n+                                                    tests and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_dump_env_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_dump_env_program_clauses]` \\\n+                                                    attribute is just used for rustc unit \\\n+                                                    tests and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_object_lifetime_default, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"the `#[rustc_object_lifetime_default]` \\\n+                                                    attribute is just used for rustc unit \\\n+                                                    tests and will never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"the `#[rustc_test_marker]` attribute \\\n+                                    is used internally to track tests\",\n+                                    cfg_fn!(rustc_attrs))),\n+    (sym::rustc_macro_transparency, Whitelisted, template!(NameValueStr:\n+                                                           \"transparent|semitransparent|opaque\"),\n+                                                Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"used internally for testing macro hygiene\",\n+                                                    cfg_fn!(rustc_attrs))),\n+    (sym::compiler_builtins, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::compiler_builtins,\n+                                            \"the `#[compiler_builtins]` attribute is used to \\\n+                                            identify the `compiler_builtins` crate which \\\n+                                            contains compiler-rt intrinsics and will never be \\\n+                                            stable\",\n+                                        cfg_fn!(compiler_builtins))),\n+    (sym::sanitizer_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::sanitizer_runtime,\n+                                            \"the `#[sanitizer_runtime]` attribute is used to \\\n+                                            identify crates that contain the runtime of a \\\n+                                            sanitizer and will never be stable\",\n+                                            cfg_fn!(sanitizer_runtime))),\n+    (sym::profiler_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                            sym::profiler_runtime,\n+                                            \"the `#[profiler_runtime]` attribute is used to \\\n+                                            identify the `profiler_builtins` crate which \\\n+                                            contains the profiler runtime and will never be \\\n+                                            stable\",\n+                                            cfg_fn!(profiler_runtime))),\n+\n+    (sym::allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+                                            Gated(Stability::Unstable,\n+                                            sym::allow_internal_unstable,\n+                                            EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n+                                            cfg_fn!(allow_internal_unstable))),\n+\n+    (sym::allow_internal_unsafe, Normal, template!(Word), Gated(Stability::Unstable,\n+                                            sym::allow_internal_unsafe,\n+                                            EXPLAIN_ALLOW_INTERNAL_UNSAFE,\n+                                            cfg_fn!(allow_internal_unsafe))),\n+\n+    (sym::fundamental, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::fundamental,\n+                                    \"the `#[fundamental]` attribute \\\n+                                        is an experimental feature\",\n+                                    cfg_fn!(fundamental))),\n+\n+    (sym::proc_macro_derive, Normal, template!(List: \"TraitName, \\\n+                                                /*opt*/ attributes(name1, name2, ...)\"),\n+                                    Ungated),\n+\n+    (sym::rustc_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_allocator_nounwind, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_builtin_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_promotable, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_allow_const_fn_ptr, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                sym::rustc_attrs,\n+                                                \"internal implementation detail\",\n+                                                cfg_fn!(rustc_attrs))),\n+\n+    (sym::rustc_dummy, Normal, template!(Word /* doesn't matter*/), Gated(Stability::Unstable,\n+                                         sym::rustc_attrs,\n+                                         \"used by the test suite\",\n+                                         cfg_fn!(rustc_attrs))),\n+\n+    // FIXME: #14408 whitelist docs since rustdoc looks at them\n+    (\n+        sym::doc,\n+        Whitelisted,\n+        template!(List: \"hidden|inline|...\", NameValueStr: \"string\"),\n+        Ungated\n+    ),\n+\n+    // FIXME: #14406 these are processed in codegen, which happens after the\n+    // lint pass\n+    (sym::cold, Whitelisted, template!(Word), Ungated),\n+    (sym::naked, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                sym::naked_functions,\n+                                \"the `#[naked]` attribute \\\n+                                is an experimental feature\",\n+                                cfg_fn!(naked_functions))),\n+    (sym::ffi_returns_twice, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                sym::ffi_returns_twice,\n+                                \"the `#[ffi_returns_twice]` attribute \\\n+                                is an experimental feature\",\n+                                cfg_fn!(ffi_returns_twice))),\n+    (sym::target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#), Ungated),\n+    (sym::export_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::inline, Whitelisted, template!(Word, List: \"always|never\"), Ungated),\n+    (sym::link, Whitelisted, template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n+                                               /*opt*/ cfg = \"...\"\"#), Ungated),\n+    (sym::link_name, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::link_section, Whitelisted, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::no_builtins, Whitelisted, template!(Word), Ungated),\n+    (sym::no_debug, Whitelisted, template!(Word), Gated(\n+        Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n+        sym::no_debug,\n+        \"the `#[no_debug]` attribute was an experimental feature that has been \\\n+        deprecated due to lack of demand\",\n+        cfg_fn!(no_debug))),\n+    (\n+        sym::omit_gdb_pretty_printer_section,\n+        Whitelisted,\n+        template!(Word),\n+        Gated(\n+            Stability::Unstable,\n+            sym::omit_gdb_pretty_printer_section,\n+            \"the `#[omit_gdb_pretty_printer_section]` \\\n+                attribute is just used for the Rust test \\\n+                suite\",\n+            cfg_fn!(omit_gdb_pretty_printer_section)\n+        )\n+    ),\n+    (sym::may_dangle,\n+    Normal,\n+    template!(Word),\n+    Gated(Stability::Unstable,\n+        sym::dropck_eyepatch,\n+        \"`may_dangle` has unstable semantics and may be removed in the future\",\n+        cfg_fn!(dropck_eyepatch))),\n+    (sym::unwind, Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n+                                sym::unwind_attributes,\n+                                \"`#[unwind]` is experimental\",\n+                                cfg_fn!(unwind_attributes))),\n+    (sym::used, Whitelisted, template!(Word), Ungated),\n+\n+    // used in resolve\n+    (sym::prelude_import, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                        sym::prelude_import,\n+                                        \"`#[prelude_import]` is for use by rustc only\",\n+                                        cfg_fn!(prelude_import))),\n+\n+    // FIXME: #14407 these are only looked at on-demand so we can't\n+    // guarantee they'll have already been checked\n+    (\n+        sym::rustc_deprecated,\n+        Whitelisted,\n+        template!(List: r#\"since = \"version\", reason = \"...\"\"#),\n+        Ungated\n+    ),\n+    (sym::must_use, Whitelisted, template!(Word, NameValueStr: \"reason\"), Ungated),\n+    (\n+        sym::stable,\n+        Whitelisted,\n+        template!(List: r#\"feature = \"name\", since = \"version\"\"#),\n+        Ungated\n+    ),\n+    (\n+        sym::unstable,\n+        Whitelisted,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n+        Ungated\n+    ),\n+    (sym::deprecated,\n+        Normal,\n+        template!(\n+            Word,\n+            List: r#\"/*opt*/ since = \"version\", /*opt*/ note = \"reason\"\"#,\n+            NameValueStr: \"reason\"\n+        ),\n+        Ungated\n+    ),\n+\n+    (sym::rustc_paren_sugar, Normal, template!(Word), Gated(Stability::Unstable,\n+                                        sym::unboxed_closures,\n+                                        \"unboxed_closures are still evolving\",\n+                                        cfg_fn!(unboxed_closures))),\n+\n+    (sym::windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\"), Ungated),\n+\n+    (sym::proc_macro_attribute, Normal, template!(Word), Ungated),\n+    (sym::proc_macro, Normal, template!(Word), Ungated),\n+\n+    (sym::rustc_proc_macro_decls, Normal, template!(Word), Gated(Stability::Unstable,\n+                                            sym::rustc_attrs,\n+                                            \"used internally by rustc\",\n+                                            cfg_fn!(rustc_attrs))),\n+\n+    (sym::allow_fail, Normal, template!(Word), Gated(Stability::Unstable,\n+                                sym::allow_fail,\n+                                \"allow_fail attribute is currently unstable\",\n+                                cfg_fn!(allow_fail))),\n+\n+    (sym::rustc_std_internal_symbol, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                    sym::rustc_attrs,\n+                                    \"this is an internal attribute that will \\\n+                                    never be stable\",\n+                                    cfg_fn!(rustc_attrs))),\n+\n+    // whitelists \"identity-like\" conversion methods to suggest on type mismatch\n+    (sym::rustc_conversion_suggestion, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+                                                    sym::rustc_attrs,\n+                                                    \"this is an internal attribute that will \\\n+                                                        never be stable\",\n+                                                    cfg_fn!(rustc_attrs))),\n+\n+    (\n+        sym::rustc_args_required_const,\n+        Whitelisted,\n+        template!(List: \"N\"),\n+        Gated(Stability::Unstable, sym::rustc_attrs, \"never will be stable\",\n+           cfg_fn!(rustc_attrs))\n+    ),\n+    // RFC 2070\n+    (sym::panic_handler, Normal, template!(Word), Ungated),\n+\n+    (sym::alloc_error_handler, Normal, template!(Word), Gated(Stability::Unstable,\n+                        sym::alloc_error_handler,\n+                        \"`#[alloc_error_handler]` is an unstable feature\",\n+                        cfg_fn!(alloc_error_handler))),\n+\n+    // RFC 2412\n+    (sym::optimize, Whitelisted, template!(List: \"size|speed\"), Gated(Stability::Unstable,\n+                            sym::optimize_attribute,\n+                            \"`#[optimize]` attribute is an unstable feature\",\n+                            cfg_fn!(optimize_attribute))),\n+\n+    // Crate level attributes\n+    (sym::crate_name, CrateLevel, template!(NameValueStr: \"name\"), Ungated),\n+    (sym::crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), Ungated),\n+    (sym::crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), Ungated),\n+    (sym::feature, CrateLevel, template!(List: \"name1, name1, ...\"), Ungated),\n+    (sym::no_start, CrateLevel, template!(Word), Ungated),\n+    (sym::no_main, CrateLevel, template!(Word), Ungated),\n+    (sym::recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n+    (sym::type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n+    (sym::test_runner, CrateLevel, template!(List: \"path\"), Gated(Stability::Unstable,\n+                    sym::custom_test_frameworks,\n+                    \"custom test frameworks are an unstable feature\",\n+                    cfg_fn!(custom_test_frameworks))),\n+];\n+\n+pub fn deprecated_attributes() -> Vec<&'static BuiltinAttribute> {\n+    BUILTIN_ATTRIBUTES.iter().filter(|(.., gate)| gate.is_deprecated()).collect()\n+}\n+\n+pub fn is_builtin_attr_name(name: ast::Name) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n+}\n+\n+pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n+    attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).is_some()\n+}\n+\n+lazy_static! {\n+    pub static ref BUILTIN_ATTRIBUTE_MAP: FxHashMap<Symbol, &'static BuiltinAttribute> = {\n+        let mut map = FxHashMap::default();\n+        for attr in BUILTIN_ATTRIBUTES.iter() {\n+            if map.insert(attr.0, attr).is_some() {\n+                panic!(\"duplicate builtin attribute `{}`\", attr.0);\n+            }\n+        }\n+        map\n+    };\n+}"}]}