{"sha": "bcc68c298a4e8c323151355404cdc1e87f22436b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYzY4YzI5OGE0ZThjMzIzMTUxMzU1NDA0Y2RjMWU4N2YyMjQzNmI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-09T11:17:02Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-05-09T11:17:02Z"}, "message": "Rustup to rustc 1.54.0-nightly (881c1ac40 2021-05-08)", "tree": {"sha": "60a04957bc39fab17c64615aa2d94169375bc190", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60a04957bc39fab17c64615aa2d94169375bc190"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcc68c298a4e8c323151355404cdc1e87f22436b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc68c298a4e8c323151355404cdc1e87f22436b", "html_url": "https://github.com/rust-lang/rust/commit/bcc68c298a4e8c323151355404cdc1e87f22436b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcc68c298a4e8c323151355404cdc1e87f22436b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "961d8b69fa4efef8b17f14958c590aa7241494e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/961d8b69fa4efef8b17f14958c590aa7241494e1", "html_url": "https://github.com/rust-lang/rust/commit/961d8b69fa4efef8b17f14958c590aa7241494e1"}], "stats": {"total": 127, "additions": 101, "deletions": 26}, "files": [{"sha": "7d608df9253df85fe72e5c38bfb438b29bc267ab", "filename": "example/std_example.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcc68c298a4e8c323151355404cdc1e87f22436b/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc68c298a4e8c323151355404cdc1e87f22436b/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=bcc68c298a4e8c323151355404cdc1e87f22436b", "patch": "@@ -187,20 +187,6 @@ unsafe fn test_mm_slli_si128() {\n     );\n     let r = _mm_slli_si128(a, 16);\n     assert_eq_m128i(r, _mm_set1_epi8(0));\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -1);\n-    assert_eq_m128i(_mm_set1_epi8(0), r);\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -0x80000000);\n-    assert_eq_m128i(r, _mm_set1_epi8(0));\n }\n \n #[cfg(target_arch = \"x86_64\")]\n@@ -295,7 +281,7 @@ unsafe fn test_mm_extract_epi8() {\n         8, 9, 10, 11, 12, 13, 14, 15\n     );\n     let r1 = _mm_extract_epi8(a, 0);\n-    let r2 = _mm_extract_epi8(a, 19);\n+    let r2 = _mm_extract_epi8(a, 3);\n     assert_eq!(r1, 0xFF);\n     assert_eq!(r2, 3);\n }"}, {"sha": "e5789427afc68f8294555764388a10135d820031", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcc68c298a4e8c323151355404cdc1e87f22436b/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/bcc68c298a4e8c323151355404cdc1e87f22436b/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=bcc68c298a4e8c323151355404cdc1e87f22436b", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-05-04\"\n+channel = \"nightly-2021-05-09\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "7728a3324533ffe5bd9e3153efbe9f49cf5bfa57", "filename": "src/constant.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bcc68c298a4e8c323151355404cdc1e87f22436b/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc68c298a4e8c323151355404cdc1e87f22436b/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=bcc68c298a4e8c323151355404cdc1e87f22436b", "patch": "@@ -448,12 +448,89 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n     operand: &Operand<'tcx>,\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n-        Operand::Copy(_) | Operand::Move(_) => None,\n         Operand::Constant(const_) => match const_.literal {\n             ConstantKind::Ty(const_) => {\n                 fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val.try_to_value()\n             }\n             ConstantKind::Val(val, _) => Some(val),\n         },\n+        // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored\n+        // inside a temporary before being passed to the intrinsic requiring the const argument.\n+        // This code tries to find a single constant defining definition of the referenced local.\n+        Operand::Copy(place) | Operand::Move(place) => {\n+            if !place.projection.is_empty() {\n+                return None;\n+            }\n+            let mut computed_const_val = None;\n+            for bb_data in fx.mir.basic_blocks() {\n+                for stmt in &bb_data.statements {\n+                    match &stmt.kind {\n+                        StatementKind::Assign(local_and_rvalue) if &local_and_rvalue.0 == place => {\n+                            match &local_and_rvalue.1 {\n+                                Rvalue::Cast(CastKind::Misc, operand, ty) => {\n+                                    if computed_const_val.is_some() {\n+                                        return None; // local assigned twice\n+                                    }\n+                                    if !matches!(ty.kind(), ty::Uint(_) | ty::Int(_)) {\n+                                        return None;\n+                                    }\n+                                    let const_val = mir_operand_get_const_val(fx, operand)?;\n+                                    if fx.layout_of(ty).size\n+                                        != const_val.try_to_scalar_int()?.size()\n+                                    {\n+                                        return None;\n+                                    }\n+                                    computed_const_val = Some(const_val);\n+                                }\n+                                Rvalue::Use(operand) => {\n+                                    computed_const_val = mir_operand_get_const_val(fx, operand)\n+                                }\n+                                _ => return None,\n+                            }\n+                        }\n+                        StatementKind::SetDiscriminant { place: stmt_place, variant_index: _ }\n+                            if &**stmt_place == place =>\n+                        {\n+                            return None;\n+                        }\n+                        StatementKind::LlvmInlineAsm(_) | StatementKind::CopyNonOverlapping(_) => {\n+                            return None;\n+                        } // conservative handling\n+                        StatementKind::Assign(_)\n+                        | StatementKind::FakeRead(_)\n+                        | StatementKind::SetDiscriminant { .. }\n+                        | StatementKind::StorageLive(_)\n+                        | StatementKind::StorageDead(_)\n+                        | StatementKind::Retag(_, _)\n+                        | StatementKind::AscribeUserType(_, _)\n+                        | StatementKind::Coverage(_)\n+                        | StatementKind::Nop => {}\n+                    }\n+                }\n+                match &bb_data.terminator().kind {\n+                    TerminatorKind::Goto { .. }\n+                    | TerminatorKind::SwitchInt { .. }\n+                    | TerminatorKind::Resume\n+                    | TerminatorKind::Abort\n+                    | TerminatorKind::Return\n+                    | TerminatorKind::Unreachable\n+                    | TerminatorKind::Drop { .. }\n+                    | TerminatorKind::Assert { .. } => {}\n+                    TerminatorKind::DropAndReplace { .. }\n+                    | TerminatorKind::Yield { .. }\n+                    | TerminatorKind::GeneratorDrop\n+                    | TerminatorKind::FalseEdge { .. }\n+                    | TerminatorKind::FalseUnwind { .. } => unreachable!(),\n+                    TerminatorKind::InlineAsm { .. } => return None,\n+                    TerminatorKind::Call { destination: Some((call_place, _)), .. }\n+                        if call_place == place =>\n+                    {\n+                        return None;\n+                    }\n+                    TerminatorKind::Call { .. } => {}\n+                }\n+            }\n+            computed_const_val\n+        }\n     }\n }"}, {"sha": "09c5e6031c78dce37d6f985a7c901466f0bb84f9", "filename": "src/inline_asm.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bcc68c298a4e8c323151355404cdc1e87f22436b/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc68c298a4e8c323151355404cdc1e87f22436b/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=bcc68c298a4e8c323151355404cdc1e87f22436b", "patch": "@@ -24,14 +24,22 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         let true_ = fx.bcx.ins().iconst(types::I32, 1);\n         fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n         return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"mov rsi, rbx\".to_string())\n-        && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[2] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-        && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[4] == InlineAsmTemplatePiece::String(\"xchg rsi, rbx\".to_string())\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        && matches!(\n+            template[1],\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n+        )\n+        && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+        && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+        && matches!(\n+            template[6],\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n+        )\n     {\n         assert_eq!(operands.len(), 4);\n-        let (leaf, eax_place) = match operands[0] {\n+        let (leaf, eax_place) = match operands[1] {\n             InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n                 let reg = expect_reg(reg);\n                 assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::ax));\n@@ -42,10 +50,14 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             }\n             _ => unreachable!(),\n         };\n-        let ebx_place = match operands[1] {\n+        let ebx_place = match operands[0] {\n             InlineAsmOperand::Out { reg, late: true, place } => {\n-                let reg = expect_reg(reg);\n-                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::si));\n+                assert_eq!(\n+                    reg,\n+                    InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n+                        X86InlineAsmRegClass::reg\n+                    ))\n+                );\n                 crate::base::codegen_place(fx, place.unwrap())\n             }\n             _ => unreachable!(),"}]}