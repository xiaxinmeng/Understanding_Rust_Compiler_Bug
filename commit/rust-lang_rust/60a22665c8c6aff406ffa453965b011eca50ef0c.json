{"sha": "60a22665c8c6aff406ffa453965b011eca50ef0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYTIyNjY1YzhjNmFmZjQwNmZmYTQ1Mzk2NWIwMTFlY2E1MGVmMGM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-23T10:12:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-31T18:25:57Z"}, "message": "rustc_codegen_ssa: introduce MIR VarDebugInfo, but only for codegen.", "tree": {"sha": "c797b4aeb6fafb2e774afe05b993f2f1111a4fb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c797b4aeb6fafb2e774afe05b993f2f1111a4fb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a22665c8c6aff406ffa453965b011eca50ef0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a22665c8c6aff406ffa453965b011eca50ef0c", "html_url": "https://github.com/rust-lang/rust/commit/60a22665c8c6aff406ffa453965b011eca50ef0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a22665c8c6aff406ffa453965b011eca50ef0c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e42072673929227239215bb2f3333f5351f88ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e42072673929227239215bb2f3333f5351f88ca", "html_url": "https://github.com/rust-lang/rust/commit/1e42072673929227239215bb2f3333f5351f88ca"}], "stats": {"total": 324, "additions": 186, "deletions": 138}, "files": [{"sha": "c215db34ccbc8bec54fec479088cf5d50451eb41", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 184, "deletions": 138, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/60a22665c8c6aff406ffa453965b011eca50ef0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a22665c8c6aff406ffa453965b011eca50ef0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=60a22665c8c6aff406ffa453965b011eca50ef0c", "patch": "@@ -2,12 +2,11 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::hir::def_id::CrateNum;\n use rustc::mir;\n use rustc::session::config::DebugInfo;\n-use rustc::ty::{self, UpvarSubsts};\n-use rustc::ty::layout::{HasTyCtxt, Size};\n-use rustc_target::abi::{Variants, VariantIdx};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::{LayoutOf, Size, VariantIdx};\n use crate::traits::*;\n \n-use syntax_pos::{DUMMY_SP, BytePos, Span};\n+use syntax_pos::{BytePos, Span, Symbol};\n use syntax::symbol::kw;\n \n use super::{FunctionCx, LocalRef};\n@@ -19,6 +18,7 @@ pub struct FunctionDebugContext<D> {\n     pub defining_crate: CrateNum,\n }\n \n+#[derive(Copy, Clone)]\n pub enum VariableKind {\n     ArgumentVariable(usize /*index*/),\n     LocalVariable,\n@@ -104,37 +104,49 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n     // not just `llvm.dbg.declare` (which requires `alloca`).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n-        let upvar_debuginfo = &self.mir.__upvar_debuginfo_codegen_only_do_not_use;\n-\n         // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n         if local == mir::RETURN_PLACE {\n             return;\n         }\n \n-        let decl = &self.mir.local_decls[local];\n-        let (name, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+        let vars = match &self.per_local_var_debug_info {\n+            Some(per_local) => &per_local[local],\n+            None => return,\n+        };\n+        let whole_local_var = vars.iter().find(|var| {\n+            var.place.projection.is_empty()\n+        });\n+        let has_proj = || vars.iter().any(|var| {\n+            !var.place.projection.is_empty()\n+        });\n+\n+        let (fallback_var, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n             let arg_index = local.index() - 1;\n \n             // Add debuginfo even to unnamed arguments.\n             // FIXME(eddyb) is this really needed?\n-            let name = if arg_index == 0 && !upvar_debuginfo.is_empty() {\n+            let var = if arg_index == 0 && has_proj() {\n                 // Hide closure environments from debuginfo.\n                 // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n                 // be offset to account for the hidden environment?\n                 None\n             } else {\n-                Some(decl.name.unwrap_or(kw::Invalid))\n+                Some(VarDebugInfo {\n+                    name: kw::Invalid,\n+                    source_info: self.mir.local_decls[local].source_info,\n+                    place: local.into(),\n+                })\n             };\n-            (name, VariableKind::ArgumentVariable(arg_index + 1))\n+            (var, VariableKind::ArgumentVariable(arg_index + 1))\n         } else {\n-            (decl.name, VariableKind::LocalVariable)\n+            (None, VariableKind::LocalVariable)\n         };\n \n         let local_ref = &self.locals[local];\n \n         if !bx.sess().fewer_names() {\n-            let name = match name {\n-                Some(name) if name != kw::Invalid => name.to_string(),\n+            let name = match whole_local_var.or(fallback_var.as_ref()) {\n+                Some(var) if var.name != kw::Invalid => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             };\n             match local_ref {\n@@ -158,127 +170,161 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n \n-        if let Some(name) = name {\n-            if bx.sess().opts.debuginfo != DebugInfo::Full {\n-                return;\n-            }\n+        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+            return;\n+        }\n \n-            let debug_context = match &self.debug_context {\n-                Some(debug_context) => debug_context,\n-                None => return,\n-            };\n+        let debug_context = match &self.debug_context {\n+            Some(debug_context) => debug_context,\n+            None => return,\n+        };\n+\n+        // FIXME(eddyb) add debuginfo for unsized places too.\n+        let base = match local_ref {\n+            LocalRef::Place(place) => place,\n+            _ => return,\n+        };\n+\n+        let vars = vars.iter().chain(if whole_local_var.is_none() {\n+            fallback_var.as_ref()\n+        } else {\n+            None\n+        });\n \n-            // FIXME(eddyb) add debuginfo for unsized places too.\n-            let place = match local_ref {\n-                LocalRef::Place(place) => place,\n-                _ => return,\n+        for var in vars {\n+            let mut layout = base.layout;\n+            let mut direct_offset = Size::ZERO;\n+            // FIXME(eddyb) use smallvec here.\n+            let mut indirect_offsets = vec![];\n+\n+            let kind = if var.place.projection.is_empty() {\n+                kind\n+            } else {\n+                VariableKind::LocalVariable\n             };\n \n-            let (scope, span) = self.debug_loc(mir::SourceInfo {\n-                span: decl.source_info.span,\n-                scope: decl.visibility_scope,\n-            });\n+            for elem in &var.place.projection[..] {\n+                match *elem {\n+                    mir::ProjectionElem::Deref => {\n+                        indirect_offsets.push(Size::ZERO);\n+                        layout = bx.cx().layout_of(\n+                            layout.ty.builtin_deref(true)\n+                                .unwrap_or_else(|| {\n+                                    span_bug!(\n+                                        var.source_info.span,\n+                                        \"cannot deref `{}`\",\n+                                        layout.ty,\n+                                    )\n+                                }).ty,\n+                        );\n+                    }\n+                    mir::ProjectionElem::Field(field, _) => {\n+                        let i = field.index();\n+                        let offset = indirect_offsets.last_mut()\n+                            .unwrap_or(&mut direct_offset);\n+                        *offset += layout.fields.offset(i);\n+                        layout = layout.field(bx.cx(), i);\n+                    }\n+                    mir::ProjectionElem::Downcast(_, variant) => {\n+                        layout = layout.for_variant(bx.cx(), variant);\n+                    }\n+                    _ => span_bug!(\n+                        var.source_info.span,\n+                        \"unsupported var debuginfo place `{:?}`\",\n+                        var.place,\n+                    ),\n+                }\n+            }\n+\n+            let (scope, span) = self.debug_loc(var.source_info);\n             if let Some(scope) = scope {\n-                bx.declare_local(debug_context, name, place.layout.ty, scope,\n-                    place.llval, Size::ZERO, &[], kind, span);\n+                bx.declare_local(debug_context, var.name, layout.ty, scope,\n+                    base.llval, direct_offset, &indirect_offsets, kind, span);\n             }\n         }\n     }\n \n     pub fn debug_introduce_locals(&self, bx: &mut Bx) {\n-        let tcx = self.cx.tcx();\n-        let upvar_debuginfo = &self.mir.__upvar_debuginfo_codegen_only_do_not_use;\n-\n-        if bx.sess().opts.debuginfo != DebugInfo::Full {\n-            // HACK(eddyb) figure out a way to perhaps disentangle\n-            // the use of `declare_local` and `set_var_name`.\n-            // Or maybe just running this loop always is not that expensive?\n-            if !bx.sess().fewer_names() {\n-                for local in self.locals.indices() {\n-                    self.debug_introduce_local(bx, local);\n-                }\n+        if bx.sess().opts.debuginfo == DebugInfo::Full || !bx.sess().fewer_names() {\n+            for local in self.locals.indices() {\n+                self.debug_introduce_local(bx, local);\n             }\n-\n-            return;\n         }\n+    }\n+}\n \n-        let debug_context = match &self.debug_context {\n-            Some(debug_context) => debug_context,\n-            None => return,\n-        };\n-\n-        for local in self.locals.indices() {\n-            self.debug_introduce_local(bx, local);\n+pub fn per_local_var_debug_info(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mir::Body<'tcx>,\n+) -> Option<IndexVec<mir::Local, Vec<VarDebugInfo<'tcx>>>> {\n+    if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n+        let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n+            if let Some(name) = decl.name {\n+                per_local[local].push(VarDebugInfo {\n+                    name,\n+                    source_info: mir::SourceInfo {\n+                        span: decl.source_info.span,\n+                        scope: decl.visibility_scope,\n+                    },\n+                    place: local.into(),\n+                });\n+            }\n         }\n \n-        // Declare closure captures as if they were local variables.\n-        // FIXME(eddyb) generalize this to `name => place` mappings.\n-        let upvar_scope = if !upvar_debuginfo.is_empty() {\n-            debug_context.scopes[mir::OUTERMOST_SOURCE_SCOPE].scope_metadata\n-        } else {\n-            None\n-        };\n-        if let Some(scope) = upvar_scope {\n-            let place = match self.locals[mir::Local::new(1)] {\n-                LocalRef::Place(place) => place,\n-                _ => bug!(),\n-            };\n+        let upvar_debuginfo = &body.__upvar_debuginfo_codegen_only_do_not_use;\n+        if !upvar_debuginfo.is_empty() {\n+\n+            let env_arg = mir::Local::new(1);\n+            let mut env_projs = vec![];\n \n             let pin_did = tcx.lang_items().pin_type();\n-            let (closure_layout, env_ref) = match place.layout.ty.kind {\n-                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n+            match body.local_decls[env_arg].ty.kind {\n+                ty::RawPtr(_) |\n+                ty::Ref(..)  => {\n+                    env_projs.push(mir::ProjectionElem::Deref);\n+                }\n                 ty::Adt(def, substs) if Some(def.did) == pin_did => {\n-                    match substs.type_at(0).kind {\n-                        ty::Ref(_, ty, _)  => (bx.layout_of(ty), true),\n-                        _ => (place.layout, false),\n+                    if let ty::Ref(..) = substs.type_at(0).kind {\n+                        env_projs.push(mir::ProjectionElem::Field(\n+                            mir::Field::new(0),\n+                            // HACK(eddyb) field types aren't used or needed here.\n+                            tcx.types.err,\n+                        ));\n+                        env_projs.push(mir::ProjectionElem::Deref);\n                     }\n                 }\n-                _ => (place.layout, false)\n-            };\n-\n-            let (def_id, upvar_substs) = match closure_layout.ty.kind {\n-                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n-                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-                _ => bug!(\"upvar debuginfo with non-closure arg0 type `{}`\", closure_layout.ty)\n-            };\n-            let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n+                _ => {}\n+            }\n \n             let extra_locals = {\n                 let upvars = upvar_debuginfo\n                     .iter()\n-                    .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (upvar, ty))| {\n-                        (None, i, upvar.debug_name, upvar.by_ref, ty, scope, DUMMY_SP)\n+                    .map(|(i, upvar)| {\n+                        let source_info = mir::SourceInfo {\n+                            span: body.span,\n+                            scope: mir::OUTERMOST_SOURCE_SCOPE,\n+                        };\n+                        (None, i, upvar.debug_name, upvar.by_ref, source_info)\n                     });\n \n-                let generator_fields = self.mir.generator_layout.as_ref().map(|generator_layout| {\n-                    let (def_id, gen_substs) = match closure_layout.ty.kind {\n-                        ty::Generator(def_id, substs, _) => (def_id, substs),\n-                        _ => bug!(\"generator layout without generator substs\"),\n-                    };\n-                    let state_tys = gen_substs.as_generator().state_tys(def_id, tcx);\n-\n+                let generator_fields = body.generator_layout.as_ref().map(|generator_layout| {\n                     generator_layout.variant_fields.iter()\n-                        .zip(state_tys)\n                         .enumerate()\n-                        .flat_map(move |(variant_idx, (fields, tys))| {\n+                        .flat_map(move |(variant_idx, fields)| {\n                             let variant_idx = Some(VariantIdx::from(variant_idx));\n                             fields.iter()\n-                                .zip(tys)\n                                 .enumerate()\n-                                .filter_map(move |(i, (field, ty))| {\n+                                .filter_map(move |(i, field)| {\n                                     let decl = &generator_layout.\n                                         __local_debuginfo_codegen_only_do_not_use[*field];\n                                     if let Some(name) = decl.name {\n-                                        let ty = self.monomorphize(&ty);\n-                                        let (var_scope, var_span) = self.debug_loc(mir::SourceInfo {\n+                                        let source_info = mir::SourceInfo {\n                                             span: decl.source_info.span,\n                                             scope: decl.visibility_scope,\n-                                        });\n-                                        let var_scope = var_scope.unwrap_or(scope);\n-                                        Some((variant_idx, i, name, false, ty, var_scope, var_span))\n+                                        };\n+                                        Some((variant_idx, i, name, false, source_info))\n                                     } else {\n                                         None\n                                     }\n@@ -289,51 +335,51 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 upvars.chain(generator_fields)\n             };\n \n-            for (variant_idx, field, name, by_ref, ty, var_scope, var_span) in extra_locals {\n-                let fields = match variant_idx {\n-                    Some(variant_idx) => {\n-                        match &closure_layout.variants {\n-                            Variants::Multiple { variants, .. } => {\n-                                &variants[variant_idx].fields\n-                            },\n-                            _ => bug!(\"variant index on univariant layout\"),\n-                        }\n-                    }\n-                    None => &closure_layout.fields,\n-                };\n-\n-                // The environment and the capture can each be indirect.\n-                let mut direct_offset = Size::ZERO;\n-                let indirect_offsets = [\n-                    fields.offset(field),\n-                    Size::ZERO,\n-                ];\n-                let mut indirect_offsets = &indirect_offsets[..];\n-\n-                if !env_ref {\n-                    direct_offset = indirect_offsets[0];\n-                    indirect_offsets = &indirect_offsets[1..];\n+            for (variant_idx, field, name, by_ref, source_info) in extra_locals {\n+                let mut projs = env_projs.clone();\n+\n+                if let Some(variant_idx) = variant_idx {\n+                    projs.push(mir::ProjectionElem::Downcast(None, variant_idx));\n                 }\n \n-                let ty = if let (true, &ty::Ref(_, ty, _)) = (by_ref, &ty.kind) {\n-                    ty\n-                } else {\n-                    indirect_offsets = &indirect_offsets[..indirect_offsets.len() - 1];\n-                    ty\n-                };\n+                projs.push(mir::ProjectionElem::Field(\n+                    mir::Field::new(field),\n+                    // HACK(eddyb) field types aren't used or needed here.\n+                    tcx.types.err,\n+                ));\n \n-                bx.declare_local(\n-                    debug_context,\n+                if by_ref {\n+                    projs.push(mir::ProjectionElem::Deref);\n+                }\n+\n+                per_local[env_arg].push(VarDebugInfo {\n                     name,\n-                    ty,\n-                    var_scope,\n-                    place.llval,\n-                    direct_offset,\n-                    indirect_offsets,\n-                    VariableKind::LocalVariable,\n-                    var_span\n-                );\n+                    source_info,\n+                    place: mir::Place {\n+                        base: mir::PlaceBase::Local(env_arg),\n+                        projection: tcx.intern_place_elems(&projs),\n+                    },\n+                });\n             }\n         }\n+\n+        Some(per_local)\n+    } else {\n+        None\n     }\n }\n+\n+/// Debug information relatating to an user variable.\n+// FIXME(eddyb) move this to the MIR bodies themselves.\n+#[derive(Clone)]\n+pub struct VarDebugInfo<'tcx> {\n+    pub name: Symbol,\n+\n+    /// Source info of the user variable, including the scope\n+    /// within which the variable is visible (to debuginfo)\n+    /// (see `LocalDecl`'s `source_info` field for more details).\n+    pub source_info: mir::SourceInfo,\n+\n+    /// Where the data for this user variable is to be found.\n+    pub place: mir::Place<'tcx>,\n+}"}, {"sha": "5ad14456285ba80a7af96810ffbc7374e5275450", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a22665c8c6aff406ffa453965b011eca50ef0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a22665c8c6aff406ffa453965b011eca50ef0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=60a22665c8c6aff406ffa453965b011eca50ef0c", "patch": "@@ -74,6 +74,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n+    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<debuginfo::VarDebugInfo<'tcx>>>>,\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -168,6 +169,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         funclets,\n         locals: IndexVec::new(),\n         debug_context,\n+        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir),\n     };\n \n     let memory_locals = analyze::non_ssa_locals(&fx);"}]}